; ModuleID = 'bench/redis/original/module.ll'
source_filename = "bench/redis/original/module.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.redisServer = type { i32, i64, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i32, i64, i32, i32, i32, ptr, ptr, i32, i32, i64, ptr, ptr, ptr, ptr, [2 x i32], i32, i32, i32, i32, i32, [16 x ptr], i32, ptr, ptr, i32, [8 x %struct.connListener], i32, %struct.connListener, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i32, ptr, [3 x %struct.pause_event], [256 x i8], ptr, i64, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, ptr, i64, i64, i64, %struct.malloc_stats, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, [4 x i64], i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [7 x %struct.anon.2], i64, i64, i64, i64, i64, i64, [4 x %struct.durationStats], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i32, ptr, [3 x %struct.clientBufferLimitsConfig], i32, i32, ptr, i32, i32, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, ptr, i32, i64, i64, i64, i64, ptr, i32, ptr, i32, i32, i32, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, ptr, i32, i32, ptr, i32, i32, i32, [2 x i32], i32, %struct.redisOpArray, i32, ptr, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [41 x i8], [41 x i8], i64, i64, i64, i64, i32, i32, ptr, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, ptr, ptr, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, ptr, i32, ptr, i64, i32, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i64, i32, ptr, i32, i32, i64, i64, i32, i32, i32, i32, i32, i64, [3 x i32], i32, i32, i32, [9 x i32], ptr, ptr, i32, i64, ptr, ptr, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i32, i64, i64, i64, i64, i64, ptr, ptr, i32, ptr, i32, i32, i32, i64, i64, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i64, i32, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, i64, ptr, i32, %struct.aclInfo, i32, i64, i32, i32, i32, %struct.redisTLSContextConfig, ptr, ptr, ptr, ptr, ptr, i64, i32, ptr, i32, i32, i32, i64, i32, ptr }
%struct.connListener = type { [16 x i32], i32, ptr, i32, i32, ptr, ptr }
%struct.pause_event = type { i32, i64 }
%struct.malloc_stats = type { i64, i64, i64, i64, i64 }
%struct.anon.2 = type { i64, i64, [16 x i64], i32 }
%struct.durationStats = type { i64, i64, i64 }
%struct.clientBufferLimitsConfig = type { i64, i64, i64 }
%struct.redisOpArray = type { ptr, i32, i32 }
%struct.aclInfo = type { i64, i64, i64, i64 }
%struct.redisTLSContextConfig = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32 }
%struct.sharedObjectsStruct = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [4 x ptr], [4 x ptr], [4 x ptr], [4 x ptr], ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr], [10000 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], ptr, ptr }
%struct.anon.15 = type { i64, ptr }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.dictType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.RedisModuleDefragCtx = type { i64, ptr, ptr, i32 }
%struct.RedisModuleCtx = type { ptr, ptr, ptr, ptr, ptr, i32, i32, i32, ptr, i32, ptr, ptr, ptr, ptr, i64, ptr }
%struct.RedisModulePoolAllocBlock = type { i32, i32, ptr, [0 x i8] }
%struct.client = type { i64, i64, ptr, i32, ptr, ptr, ptr, ptr, ptr, i64, i64, i32, ptr, i32, i32, ptr, i64, ptr, ptr, ptr, ptr, i32, i32, i64, ptr, i64, ptr, i64, i64, i64, i32, ptr, i64, i64, i32, i32, i32, i32, i64, i64, ptr, i64, i64, i64, i64, i64, i64, i64, i64, [41 x i8], i32, ptr, i32, i32, %struct.multiState, %struct.blockingState, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, i32, ptr, ptr, ptr, i64, %struct.listNode, i64, i64, i32, i64, ptr }
%struct.multiState = type { ptr, i32, i32, i32, i64, i32 }
%struct.blockingState = type { i32, i64, i32, ptr, i32, i32, i64, ptr, ptr }
%struct.listNode = type { ptr, ptr, ptr }
%struct.RedisModuleAsyncRMCallPromise = type { i64, ptr, ptr, ptr, ptr, ptr }
%struct.RedisModuleKey = type { ptr, ptr, ptr, ptr, ptr, i32, %union.anon }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.listTypeEntry, i64 }
%struct.listTypeEntry = type { ptr, ptr, %struct.quicklistEntry }
%struct.quicklistEntry = type { ptr, ptr, ptr, ptr, i64, i64, i32 }
%struct.RedisModule = type { ptr, ptr, i32, i32, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i64 }
%struct.AutoMemEntry = type { ptr, i32 }
%struct.redisDb = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i64, i64, ptr, i32, [2 x %struct.dbDictState] }
%struct.dbDictState = type { i32, i32, i64, i64, ptr }
%struct.list = type { ptr, ptr, ptr, ptr, ptr, i64 }
%struct.clientReplyBlock = type { i64, i64, [0 x i8] }
%struct.redisCommand = type { ptr, ptr, ptr, ptr, i32, ptr, ptr, i32, ptr, i32, ptr, i32, ptr, i32, i64, i64, ptr, i32, ptr, i32, ptr, ptr, i64, i64, i64, i64, i32, ptr, ptr, %struct.keySpec, ptr, ptr, ptr }
%struct.keySpec = type { ptr, i64, i32, %union.anon.3, i32, %union.anon.6 }
%union.anon.3 = type { %struct.anon.5 }
%struct.anon.5 = type { ptr, i32 }
%union.anon.6 = type { %struct.anon.7 }
%struct.anon.7 = type { i32, i32, i32 }
%struct.RedisModuleCommand = type { ptr, ptr, ptr }
%struct.redisObject = type { i32, i32, ptr }
%struct.getKeysResult = type { [256 x %struct.keyReference], ptr, i32, i32 }
%struct.keyReference = type { i32, i32 }
%struct.redisCommandArg = type { ptr, i32, i32, ptr, ptr, ptr, i32, ptr, i32, ptr, ptr }
%struct.RedisModuleCommandInfo = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr }
%struct.RedisModuleCommandHistoryEntry = type { ptr, ptr }
%struct.RedisModuleCommandKeySpec = type { ptr, i64, i32, %union.anon.9, i32, %union.anon.12 }
%union.anon.9 = type { %struct.anon.11 }
%struct.anon.11 = type { ptr, i32 }
%union.anon.12 = type { %struct.anon.13 }
%struct.anon.13 = type { i32, i32, i32 }
%struct.commandHistory = type { ptr, ptr }
%struct.RedisModuleCommandArg = type { ptr, i32, i32, ptr, ptr, ptr, i32, ptr, ptr, ptr }
%struct.RedisModuleBlockedClient = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i64, i64 }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.streamID = type { i64, i64 }
%struct.RedisModuleClientInfo = type { i64, i64, i64, [46 x i8], i16, i16 }
%struct.ConnectionType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.RedisModuleReplicationInfo = type { i64, i32, ptr, i32, ptr, ptr, i64, i64 }
%struct.RedisModuleKeyOptCtx = type { ptr, ptr, i32, i32 }
%struct.listTypeIterator = type { ptr, i8, i8, ptr, ptr }
%struct.zset = type { ptr, ptr }
%struct.zskiplistNode = type { ptr, double, ptr, [0 x %struct.zskiplistLevel] }
%struct.zskiplistLevel = type { ptr, i64 }
%struct.RedisModuleStreamID = type { i64, i64 }
%struct.stream = type { ptr, i64, %struct.streamID, %struct.streamID, %struct.streamID, i64, ptr }
%struct.listIter = type { ptr, i32 }
%struct.RedisModuleCommandFilterCtx = type { ptr, i32, i32, ptr }
%struct.RedisModuleCommandFilter = type { ptr, ptr, i32 }
%struct.RedisModuleType = type { i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, [10 x i8] }
%struct.moduleValue = type { ptr, ptr }
%struct.typemethods = type { i64, ptr, ptr, ptr, ptr, ptr, ptr, %struct.anon.16, %struct.anon.17, %struct.anon.18, %struct.anon.19 }
%struct.anon.16 = type { ptr, ptr, i32 }
%struct.anon.17 = type { ptr, ptr, ptr, ptr }
%struct.anon.18 = type { ptr, ptr, ptr, ptr }
%struct.anon.19 = type { ptr }
%struct.RedisModuleIO = type { i64, ptr, ptr, i32, ptr, ptr, i32, ptr }
%struct.RedisModuleDigest = type { [20 x i8], [20 x i8], ptr, i32 }
%struct._rio = type { ptr, ptr, ptr, ptr, ptr, i64, i64, i64, i64, %union.anon.22 }
%union.anon.22 = type { %struct.anon.25 }
%struct.anon.25 = type { ptr, i64, ptr, i64, i64 }
%struct.RedisModuleAuthCtx = type { ptr, ptr }
%struct.RedisModuleKeyspaceSubscriber = type { ptr, ptr, i32, i32 }
%struct.RedisModulePostExecUnitJob = type { ptr, ptr, ptr, ptr, i32 }
%struct.moduleClusterReceiver = type { i64, ptr, ptr, ptr }
%struct.raxIterator = type { i32, ptr, ptr, ptr, i64, i64, [128 x i8], ptr, %struct.raxStack, ptr }
%struct.raxStack = type { ptr, i64, i64, [32 x ptr], i32 }
%struct.RedisModuleTimer = type { ptr, ptr, ptr, i32 }
%struct.EventLoopData = type { ptr, ptr, ptr }
%struct.EventLoopOneShot = type { ptr, ptr }
%struct.RedisModuleUser = type { ptr, i32 }
%struct.user = type { ptr, i32, ptr, ptr, ptr }
%struct.RedisModuleDictIter = type { ptr, %struct.raxIterator }
%struct.RedisModuleInfoCtx = type { ptr, ptr, ptr, i32, i32, i32 }
%struct.RedisModuleSharedAPI = type { ptr, ptr }
%struct.rax = type { ptr, i64, i64 }
%struct.RedisModuleScanCursor = type { i64, i32 }
%struct.ScanCBData = type { ptr, ptr, ptr }
%struct.ScanKeyCBData = type { ptr, ptr, ptr }
%struct.RedisModuleEventListener = type { ptr, %struct.RedisModuleEvent, ptr }
%struct.RedisModuleEvent = type { i64, i64 }
%struct.RedisModuleModuleChange = type { i64, ptr, i32 }
%struct.RedisModuleKeyInfo = type { i64, ptr }
%struct.KeyInfo = type { i32, ptr, ptr, i32 }
%struct.RedisModuleFlushInfo = type { i64, i32, i32 }
%struct.RedisModuleLoadingProgressInfo = type { i64, i32, i32 }
%struct.moduleLoadQueueEntry = type { ptr, i32, ptr }
%struct.dict = type { ptr, [2 x ptr], [2 x i64], i64, i16, [2 x i8], [0 x ptr] }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }
%struct.ModuleConfig = type { ptr, ptr, %union.get_fn, %union.set_fn, ptr, ptr }
%union.get_fn = type { ptr }
%union.set_fn = type { ptr }
%struct.configEnum = type { ptr, i32 }
%struct.RedisModuleRdbStream = type { i32, %union.anon.27 }
%union.anon.27 = type { ptr }

@moduleTempClientCount = internal unnamed_addr global i64 0, align 8
@moduleTempClients = internal unnamed_addr global ptr null, align 8
@moduleTempClientMinCount = internal unnamed_addr global i64 0, align 8
@moduleTempClientCap = internal unnamed_addr global i64 0, align 8
@server = external global %struct.redisServer, align 8
@.str = private unnamed_addr constant [152 x i8] c"API misuse detected in module %s: RedisModule_ReplyWith*(REDISMODULE_POSTPONED_LEN) not matched by the same number of RedisModule_SetReply*Len() calls.\00", align 1
@.str.1 = private unnamed_addr constant [8 x i8] c"promise\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c"module.c\00", align 1
@getMonotonicUs = external local_unnamed_addr global ptr, align 8
@.str.3 = private unnamed_addr constant [8 x i8] c" \0D\0A|@=,\00", align 1
@.str.4 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.6 = private unnamed_addr constant [9 x i8] c"readonly\00", align 1
@.str.7 = private unnamed_addr constant [6 x i8] c"admin\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"deny-oom\00", align 1
@.str.9 = private unnamed_addr constant [12 x i8] c"deny-script\00", align 1
@.str.10 = private unnamed_addr constant [14 x i8] c"allow-loading\00", align 1
@.str.11 = private unnamed_addr constant [7 x i8] c"pubsub\00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"random\00", align 1
@.str.13 = private unnamed_addr constant [9 x i8] c"blocking\00", align 1
@.str.14 = private unnamed_addr constant [12 x i8] c"allow-stale\00", align 1
@.str.15 = private unnamed_addr constant [11 x i8] c"no-monitor\00", align 1
@.str.16 = private unnamed_addr constant [11 x i8] c"no-slowlog\00", align 1
@.str.17 = private unnamed_addr constant [5 x i8] c"fast\00", align 1
@.str.18 = private unnamed_addr constant [8 x i8] c"no-auth\00", align 1
@.str.19 = private unnamed_addr constant [14 x i8] c"may-replicate\00", align 1
@.str.20 = private unnamed_addr constant [12 x i8] c"getkeys-api\00", align 1
@.str.21 = private unnamed_addr constant [16 x i8] c"getchannels-api\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"no-cluster\00", align 1
@.str.23 = private unnamed_addr constant [18 x i8] c"no-mandatory-keys\00", align 1
@.str.24 = private unnamed_addr constant [11 x i8] c"allow-busy\00", align 1
@.str.25 = private unnamed_addr constant [73 x i8] c"dictAdd(server.commands, sdsdup(declared_name), cp->rediscmd) == DICT_OK\00", align 1
@.str.26 = private unnamed_addr constant [78 x i8] c"dictAdd(server.orig_commands, sdsdup(declared_name), cp->rediscmd) == DICT_OK\00", align 1
@.str.27 = private unnamed_addr constant [16 x i8] c"count < INT_MAX\00", align 1
@.str.28 = private unnamed_addr constant [47 x i8] c"Unrecognized categories flag %s on module load\00", align 1
@.str.29 = private unnamed_addr constant [42 x i8] c"count < SIZE_MAX / sizeof(commandHistory)\00", align 1
@.str.30 = private unnamed_addr constant [26 x i8] c"Unknown begin_search_type\00", align 1
@.str.31 = private unnamed_addr constant [23 x i8] c"Unknown find_keys_type\00", align 1
@modules = dso_local local_unnamed_addr global ptr null, align 8
@RM_Yield.yield_nesting = internal unnamed_addr global i32 0, align 4
@.str.32 = private unnamed_addr constant [41 x i8] c"(NULL string reply referenced in module)\00", align 1
@.str.33 = private unnamed_addr constant [150 x i8] c"Module attempted to use an in-place string modify operation with a string referenced multiple times. Please check the code for API usage correctness.\00", align 1
@.str.34 = private unnamed_addr constant [4 x i8] c"-%s\00", align 1
@.str.35 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"\0D\0A\00", align 1
@shared = external local_unnamed_addr global %struct.sharedObjectsStruct, align 8
@.str.37 = private unnamed_addr constant [35 x i8] c"Invalid module empty reply type %d\00", align 1
@.str.38 = private unnamed_addr constant [29 x i8] c"Invalid module reply type %d\00", align 1
@.str.39 = private unnamed_addr constant [148 x i8] c"API misuse detected in module %s: RedisModule_ReplySet*Length() called without previous RedisModule_ReplyWith*(ctx,REDISMODULE_POSTPONED_LEN) call.\00", align 1
@.str.40 = private unnamed_addr constant [4 x i8] c"txt\00", align 1
@.str.41 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.42 = private unnamed_addr constant [19 x i8] c"<dma-empty-string>\00", align 1
@.str.43 = private unnamed_addr constant [18 x i8] c"key->iter != NULL\00", align 1
@.str.44 = private unnamed_addr constant [44 x i8] c"listTypeNext(key->iter, &key->u.list.entry)\00", align 1
@.str.45 = private unnamed_addr constant [26 x i8] c"Unsupported zset encoding\00", align 1
@.str.46 = private unnamed_addr constant [77 x i8] c"cannot run as user, no user directly attached to context or context's client\00", align 1
@.str.47 = private unnamed_addr constant [43 x i8] c"command '%S' is not allowed on script mode\00", align 1
@.str.48 = private unnamed_addr constant [58 x i8] c"Write command '%S' was called while write is not allowed.\00", align 1
@.str.49 = private unnamed_addr constant [13 x i8] c"-NOPERM %S\0D\0A\00", align 1
@.str.50 = private unnamed_addr constant [76 x i8] c"Can not execute a write command '%S' while the cluster is down and readonly\00", align 1
@.str.51 = private unnamed_addr constant [57 x i8] c"Can not execute a command '%S' while the cluster is down\00", align 1
@.str.52 = private unnamed_addr constant [54 x i8] c"Attempted to access a non local key in a cluster node\00", align 1
@.str.53 = private unnamed_addr constant [37 x i8] c"flags & REDISMODULE_ARGV_ALLOW_BLOCK\00", align 1
@.str.54 = private unnamed_addr constant [12 x i8] c"ctx->module\00", align 1
@.str.55 = private unnamed_addr constant [65 x i8] c"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\00", align 1
@ModuleTypeNameCharSet = dso_local local_unnamed_addr global ptr @.str.55, align 8
@moduleTypeLookupModuleByID.cache = internal unnamed_addr global [3 x %struct.anon.15] zeroinitializer, align 16
@.str.56 = private unnamed_addr constant [42 x i8] c"cmd->proc == RedisModuleCommandDispatcher\00", align 1
@.str.57 = private unnamed_addr constant [34 x i8] c"not supported for this module key\00", align 1
@.str.58 = private unnamed_addr constant [26 x i8] c"module key failed to copy\00", align 1
@.str.59 = private unnamed_addr constant [154 x i8] c"Error loading data from RDB (short read or EOF). Read performed by module '%s' about type '%s' after reading '%llu' bytes of a value for key named: '%s'.\00", align 1
@.str.60 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str.61 = private unnamed_addr constant [79 x i8] c"Fatal: AOF method for module data type '%s' tried to emit unknown command '%s'\00", align 1
@.str.62 = private unnamed_addr constant [114 x i8] c"Fatal: AOF method for module data type '%s' tried to call RedisModule_EmitAOF() with wrong format specifiers '%s'\00", align 1
@.str.63 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.64 = private unnamed_addr constant [8 x i8] c"verbose\00", align 1
@.str.65 = private unnamed_addr constant [7 x i8] c"notice\00", align 1
@.str.66 = private unnamed_addr constant [8 x i8] c"warning\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"<%s> \00", align 1
@.str.68 = private unnamed_addr constant [7 x i8] c"module\00", align 1
@.str.69 = private unnamed_addr constant [24 x i8] c"timeout is out of range\00", align 1
@.str.70 = private unnamed_addr constant [47 x i8] c"Blocking module command called from Lua script\00", align 1
@.str.71 = private unnamed_addr constant [48 x i8] c"Blocking module command called from transaction\00", align 1
@.str.72 = private unnamed_addr constant [61 x i8] c"Blocking module command called from a Reply callback context\00", align 1
@.str.73 = private unnamed_addr constant [75 x i8] c"Clients undergoing module based authentication can only be blocked on auth\00", align 1
@moduleAuthCallbacks = internal unnamed_addr global ptr null, align 8
@.str.74 = private unnamed_addr constant [35 x i8] c"result == REDISMODULE_AUTH_HANDLED\00", align 1
@.str.75 = private unnamed_addr constant [83 x i8] c"Module blocking client on auth when not currently undergoing module authentication\00", align 1
@moduleUnblockedClientsMutex = internal global %union.pthread_mutex_t zeroinitializer, align 8
@moduleUnblockedClients = internal unnamed_addr global ptr null, align 8
@.str.76 = private unnamed_addr constant [2 x i8] c"A\00", align 1
@.str.77 = private unnamed_addr constant [30 x i8] c"server.execution_nesting == 0\00", align 1
@.str.78 = private unnamed_addr constant [30 x i8] c"server.execution_nesting == 1\00", align 1
@moduleGIL = internal global %union.pthread_mutex_t zeroinitializer, align 8
@moduleKeyspaceSubscribers = internal unnamed_addr global ptr null, align 8
@modulePostExecUnitJobs = internal unnamed_addr global ptr null, align 8
@clusterReceivers = internal unnamed_addr global [255 x ptr] zeroinitializer, align 16
@aeTimer = dso_local local_unnamed_addr global i64 -1, align 8
@Timers = internal unnamed_addr global ptr null, align 8
@.str.79 = private unnamed_addr constant [2 x i8] c"^\00", align 1
@moduleEventLoopMutex = internal global %union.pthread_mutex_t zeroinitializer, align 8
@moduleEventLoopOneShots = dso_local local_unnamed_addr global ptr null, align 8
@DefaultUser = external local_unnamed_addr global ptr, align 8
@.str.80 = private unnamed_addr constant [13 x i8] c"user != NULL\00", align 1
@.str.81 = private unnamed_addr constant [4 x i8] c"_%s\00", align 1
@.str.82 = private unnamed_addr constant [7 x i8] c"# %S\0D\0A\00", align 1
@.str.83 = private unnamed_addr constant [7 x i8] c"%s_%s:\00", align 1
@.str.84 = private unnamed_addr constant [7 x i8] c"%s=%S,\00", align 1
@.str.85 = private unnamed_addr constant [11 x i8] c"%s_%s:%S\0D\0A\00", align 1
@.str.86 = private unnamed_addr constant [7 x i8] c"%s=%s,\00", align 1
@.str.87 = private unnamed_addr constant [11 x i8] c"%s_%s:%s\0D\0A\00", align 1
@.str.88 = private unnamed_addr constant [10 x i8] c"%s=%.17g,\00", align 1
@.str.89 = private unnamed_addr constant [14 x i8] c"%s_%s:%.17g\0D\0A\00", align 1
@.str.90 = private unnamed_addr constant [7 x i8] c"%s=%I,\00", align 1
@.str.91 = private unnamed_addr constant [11 x i8] c"%s_%s:%I\0D\0A\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"%s=%U,\00", align 1
@.str.93 = private unnamed_addr constant [11 x i8] c"%s_%s:%U\0D\0A\00", align 1
@moduleCommandFilters = internal unnamed_addr global ptr null, align 8
@.str.94 = private unnamed_addr constant [24 x i8] c"str->type == OBJ_STRING\00", align 1
@.str.95 = private unnamed_addr constant [18 x i8] c"redis-module-fork\00", align 1
@.str.96 = private unnamed_addr constant [26 x i8] c"Can't fork for module: %s\00", align 1
@moduleForkInfo.0 = internal unnamed_addr global ptr null, align 8
@moduleForkInfo.1 = internal unnamed_addr global ptr null, align 8
@.str.97 = private unnamed_addr constant [30 x i8] c"Module fork started pid: %ld \00", align 1
@.str.98 = private unnamed_addr constant [12 x i8] c"Module fork\00", align 1
@.str.99 = private unnamed_addr constant [39 x i8] c"Killing running module fork child: %ld\00", align 1
@.str.100 = private unnamed_addr constant [55 x i8] c"Module fork exited pid: %ld, retcode: %d, bysignal: %d\00", align 1
@moduleEventVersions = internal unnamed_addr constant [18 x i64] [i64 1, i64 -1, i64 1, i64 -1, i64 1, i64 -1, i64 -1, i64 -1, i64 1, i64 1, i64 1, i64 1, i64 -1, i64 -1, i64 -1, i64 -1, i64 -1, i64 1], align 16
@RedisModule_EventListeners = dso_local local_unnamed_addr global ptr null, align 8
@.str.101 = private unnamed_addr constant [83 x i8] c"modulePopulateClientInfoStructure(&civ1,data, el->event.dataver) == REDISMODULE_OK\00", align 1
@.str.102 = private unnamed_addr constant [82 x i8] c"modulePopulateReplicationInfoStructure(&riv1,el->event.dataver) == REDISMODULE_OK\00", align 1
@processModuleLoadingProgressEvent.next_event = internal unnamed_addr global i64 0, align 8
@moduleAPIDictType = dso_local global %struct.dictType { ptr @dictCStringKeyHash, ptr null, ptr null, ptr @dictCStringKeyCompare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@sdsKeyValueHashDictType = dso_local global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@modulesDictType = external global %struct.dictType, align 8
@.str.103 = private unnamed_addr constant [45 x i8] c"Can't create the pipe for module threads: %s\00", align 1
@.str.104 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.105 = private unnamed_addr constant [43 x i8] c"Can't load module from %s: server aborting\00", align 1
@.str.106 = private unnamed_addr constant [92 x i8] c"Module Configuration detected without loadmodule directive or no ApplyConfig call: aborting\00", align 1
@.str.107 = private unnamed_addr constant [65 x i8] c"dictDelete(cmd->subcommands_dict, sub->declared_name) == DICT_OK\00", align 1
@.str.108 = private unnamed_addr constant [54 x i8] c"dictDelete(server.commands, cmd->fullname) == DICT_OK\00", align 1
@.str.109 = private unnamed_addr constant [59 x i8] c"dictDelete(server.orig_commands, cmd->fullname) == DICT_OK\00", align 1
@.str.110 = private unnamed_addr constant [7 x i8] c"CONFIG\00", align 1
@.str.111 = private unnamed_addr constant [41 x i8] c"CONFIG specified without name value pair\00", align 1
@.str.112 = private unnamed_addr constant [5 x i8] c"ARGS\00", align 1
@.str.113 = private unnamed_addr constant [49 x i8] c"Syntax Error from arguments to loadex around %s.\00", align 1
@.str.114 = private unnamed_addr constant [64 x i8] c"Module %s failed to load: It does not have execute permissions.\00", align 1
@.str.115 = private unnamed_addr constant [29 x i8] c"Module %s failed to load: %s\00", align 1
@.str.116 = private unnamed_addr constant [19 x i8] c"RedisModule_OnLoad\00", align 1
@.str.117 = private unnamed_addr constant [74 x i8] c"Module %s does not export RedisModule_OnLoad() symbol. Module not loaded.\00", align 1
@.str.118 = private unnamed_addr constant [51 x i8] c"Module %s initialization failed. Module not loaded\00", align 1
@.str.119 = private unnamed_addr constant [27 x i8] c"Module '%s' loaded from %s\00", align 1
@.str.120 = private unnamed_addr constant [93 x i8] c"Module Configurations were not set, likely a missing LoadConfigs call. Unloading the module.\00", align 1
@.str.121 = private unnamed_addr constant [95 x i8] c"Loadex configurations were not applied, likely due to invalid arguments. Unloading the module.\00", align 1
@.str.122 = private unnamed_addr constant [30 x i8] c"no such module with that name\00", align 1
@.str.123 = private unnamed_addr constant [68 x i8] c"the module exports one or more module-side data types, can't unload\00", align 1
@.str.124 = private unnamed_addr constant [86 x i8] c"the module exports APIs used by other modules. Please unload them first and try again\00", align 1
@.str.125 = private unnamed_addr constant [83 x i8] c"the module has blocked clients. Please wait for them to be unblocked and try again\00", align 1
@.str.126 = private unnamed_addr constant [88 x i8] c"the module holds timer that is not fired. Please stop the timer or wait until it fires.\00", align 1
@.str.127 = private unnamed_addr constant [21 x i8] c"RedisModule_OnUnload\00", align 1
@.str.128 = private unnamed_addr constant [45 x i8] c"Module %s OnUnload failed.  Unload canceled.\00", align 1
@.str.129 = private unnamed_addr constant [14 x i8] c"Unknown error\00", align 1
@.str.130 = private unnamed_addr constant [45 x i8] c"Error when trying to close the %s module: %s\00", align 1
@.str.131 = private unnamed_addr constant [19 x i8] c"Module %s unloaded\00", align 1
@.str.132 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.133 = private unnamed_addr constant [4 x i8] c"ver\00", align 1
@.str.134 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str.135 = private unnamed_addr constant [5 x i8] c"args\00", align 1
@.str.136 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.137 = private unnamed_addr constant [2 x i8] c"|\00", align 1
@.str.138 = private unnamed_addr constant [2 x i8] c"]\00", align 1
@.str.139 = private unnamed_addr constant [18 x i8] c"handle-io-errors|\00", align 1
@.str.140 = private unnamed_addr constant [24 x i8] c"handle-repl-async-load|\00", align 1
@.str.141 = private unnamed_addr constant [29 x i8] c"no-implicit-signal-modified|\00", align 1
@.str.142 = private unnamed_addr constant [72 x i8] c"module:name=%S,ver=%i,api=%i,filters=%i,usedby=%S,using=%S,options=%S\0D\0A\00", align 1
@.str.143 = private unnamed_addr constant [34 x i8] c"Invalid flag(s) for configuration\00", align 1
@.str.144 = private unnamed_addr constant [53 x i8] c"Numeric flag provided for non-numeric configuration.\00", align 1
@.str.145 = private unnamed_addr constant [47 x i8] c"Enum flag provided for non-enum configuration.\00", align 1
@.str.146 = private unnamed_addr constant [49 x i8] c"Invalid character %c in Module resource name %s.\00", align 1
@.str.147 = private unnamed_addr constant [6 x i8] c"%s.%s\00", align 1
@.str.148 = private unnamed_addr constant [46 x i8] c"Issue during loading of configuration %s : %s\00", align 1
@.str.149 = private unnamed_addr constant [63 x i8] c"Issue attempting to set default value of configuration %s : %s\00", align 1
@.str.150 = private unnamed_addr constant [49 x i8] c"Configuration by the name: %s already registered\00", align 1
@.str.151 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.152 = private unnamed_addr constant [44 x i8] c"stream->type == REDISMODULE_RDB_STREAM_FILE\00", align 1
@.str.153 = private unnamed_addr constant [5 x i8] c"help\00", align 1
@.str.154 = private unnamed_addr constant [5 x i8] c"LIST\00", align 1
@.str.155 = private unnamed_addr constant [37 x i8] c"    Return a list of loaded modules.\00", align 1
@.str.156 = private unnamed_addr constant [24 x i8] c"LOAD <path> [<arg> ...]\00", align 1
@.str.157 = private unnamed_addr constant [77 x i8] c"    Load a module library from <path>, passing to it any optional arguments.\00", align 1
@.str.158 = private unnamed_addr constant [67 x i8] c"LOADEX <path> [[CONFIG NAME VALUE] [CONFIG NAME VALUE]] [ARGS ...]\00", align 1
@.str.159 = private unnamed_addr constant [102 x i8] c"    Load a module library from <path>, while passing it module configurations and optional arguments.\00", align 1
@.str.160 = private unnamed_addr constant [14 x i8] c"UNLOAD <name>\00", align 1
@.str.161 = private unnamed_addr constant [21 x i8] c"    Unload a module.\00", align 1
@__const.moduleCommand.help = private unnamed_addr constant [9 x ptr] [ptr @.str.154, ptr @.str.155, ptr @.str.156, ptr @.str.157, ptr @.str.158, ptr @.str.159, ptr @.str.160, ptr @.str.161, ptr null], align 16
@.str.162 = private unnamed_addr constant [5 x i8] c"load\00", align 1
@.str.163 = private unnamed_addr constant [59 x i8] c"Error loading the extension. Please check the server logs.\00", align 1
@.str.164 = private unnamed_addr constant [7 x i8] c"loadex\00", align 1
@.str.165 = private unnamed_addr constant [7 x i8] c"unload\00", align 1
@.str.166 = private unnamed_addr constant [24 x i8] c"operation not possible.\00", align 1
@.str.167 = private unnamed_addr constant [27 x i8] c"Error unloading module: %s\00", align 1
@.str.168 = private unnamed_addr constant [30 x i8] c"Error unloading module %s: %s\00", align 1
@.str.169 = private unnamed_addr constant [5 x i8] c"list\00", align 1
@__const.moduleDefragGlobals.defrag_ctx = private unnamed_addr constant %struct.RedisModuleDefragCtx { i64 0, ptr null, ptr null, i32 -1 }, align 8
@.str.170 = private unnamed_addr constant [18 x i8] c"RedisModule_Alloc\00", align 1
@.str.171 = private unnamed_addr constant [21 x i8] c"RedisModule_TryAlloc\00", align 1
@.str.172 = private unnamed_addr constant [19 x i8] c"RedisModule_Calloc\00", align 1
@.str.173 = private unnamed_addr constant [20 x i8] c"RedisModule_Realloc\00", align 1
@.str.174 = private unnamed_addr constant [17 x i8] c"RedisModule_Free\00", align 1
@.str.175 = private unnamed_addr constant [19 x i8] c"RedisModule_Strdup\00", align 1
@.str.176 = private unnamed_addr constant [26 x i8] c"RedisModule_CreateCommand\00", align 1
@.str.177 = private unnamed_addr constant [23 x i8] c"RedisModule_GetCommand\00", align 1
@.str.178 = private unnamed_addr constant [29 x i8] c"RedisModule_CreateSubcommand\00", align 1
@.str.179 = private unnamed_addr constant [27 x i8] c"RedisModule_SetCommandInfo\00", align 1
@.str.180 = private unnamed_addr constant [36 x i8] c"RedisModule_SetCommandACLCategories\00", align 1
@.str.181 = private unnamed_addr constant [27 x i8] c"RedisModule_AddACLCategory\00", align 1
@.str.182 = private unnamed_addr constant [29 x i8] c"RedisModule_SetModuleAttribs\00", align 1
@.str.183 = private unnamed_addr constant [29 x i8] c"RedisModule_IsModuleNameBusy\00", align 1
@.str.184 = private unnamed_addr constant [23 x i8] c"RedisModule_WrongArity\00", align 1
@.str.185 = private unnamed_addr constant [30 x i8] c"RedisModule_ReplyWithLongLong\00", align 1
@.str.186 = private unnamed_addr constant [27 x i8] c"RedisModule_ReplyWithError\00", align 1
@.str.187 = private unnamed_addr constant [33 x i8] c"RedisModule_ReplyWithErrorFormat\00", align 1
@.str.188 = private unnamed_addr constant [34 x i8] c"RedisModule_ReplyWithSimpleString\00", align 1
@.str.189 = private unnamed_addr constant [27 x i8] c"RedisModule_ReplyWithArray\00", align 1
@.str.190 = private unnamed_addr constant [25 x i8] c"RedisModule_ReplyWithMap\00", align 1
@.str.191 = private unnamed_addr constant [25 x i8] c"RedisModule_ReplyWithSet\00", align 1
@.str.192 = private unnamed_addr constant [31 x i8] c"RedisModule_ReplyWithAttribute\00", align 1
@.str.193 = private unnamed_addr constant [31 x i8] c"RedisModule_ReplyWithNullArray\00", align 1
@.str.194 = private unnamed_addr constant [32 x i8] c"RedisModule_ReplyWithEmptyArray\00", align 1
@.str.195 = private unnamed_addr constant [32 x i8] c"RedisModule_ReplySetArrayLength\00", align 1
@.str.196 = private unnamed_addr constant [30 x i8] c"RedisModule_ReplySetMapLength\00", align 1
@.str.197 = private unnamed_addr constant [30 x i8] c"RedisModule_ReplySetSetLength\00", align 1
@.str.198 = private unnamed_addr constant [36 x i8] c"RedisModule_ReplySetAttributeLength\00", align 1
@.str.199 = private unnamed_addr constant [28 x i8] c"RedisModule_ReplyWithString\00", align 1
@.str.200 = private unnamed_addr constant [33 x i8] c"RedisModule_ReplyWithEmptyString\00", align 1
@.str.201 = private unnamed_addr constant [36 x i8] c"RedisModule_ReplyWithVerbatimString\00", align 1
@.str.202 = private unnamed_addr constant [40 x i8] c"RedisModule_ReplyWithVerbatimStringType\00", align 1
@.str.203 = private unnamed_addr constant [34 x i8] c"RedisModule_ReplyWithStringBuffer\00", align 1
@.str.204 = private unnamed_addr constant [29 x i8] c"RedisModule_ReplyWithCString\00", align 1
@.str.205 = private unnamed_addr constant [26 x i8] c"RedisModule_ReplyWithNull\00", align 1
@.str.206 = private unnamed_addr constant [26 x i8] c"RedisModule_ReplyWithBool\00", align 1
@.str.207 = private unnamed_addr constant [31 x i8] c"RedisModule_ReplyWithCallReply\00", align 1
@.str.208 = private unnamed_addr constant [28 x i8] c"RedisModule_ReplyWithDouble\00", align 1
@.str.209 = private unnamed_addr constant [31 x i8] c"RedisModule_ReplyWithBigNumber\00", align 1
@.str.210 = private unnamed_addr constant [32 x i8] c"RedisModule_ReplyWithLongDouble\00", align 1
@.str.211 = private unnamed_addr constant [26 x i8] c"RedisModule_GetSelectedDb\00", align 1
@.str.212 = private unnamed_addr constant [21 x i8] c"RedisModule_SelectDb\00", align 1
@.str.213 = private unnamed_addr constant [22 x i8] c"RedisModule_KeyExists\00", align 1
@.str.214 = private unnamed_addr constant [20 x i8] c"RedisModule_OpenKey\00", align 1
@.str.215 = private unnamed_addr constant [31 x i8] c"RedisModule_GetOpenKeyModesAll\00", align 1
@.str.216 = private unnamed_addr constant [21 x i8] c"RedisModule_CloseKey\00", align 1
@.str.217 = private unnamed_addr constant [20 x i8] c"RedisModule_KeyType\00", align 1
@.str.218 = private unnamed_addr constant [24 x i8] c"RedisModule_ValueLength\00", align 1
@.str.219 = private unnamed_addr constant [21 x i8] c"RedisModule_ListPush\00", align 1
@.str.220 = private unnamed_addr constant [20 x i8] c"RedisModule_ListPop\00", align 1
@.str.221 = private unnamed_addr constant [20 x i8] c"RedisModule_ListGet\00", align 1
@.str.222 = private unnamed_addr constant [20 x i8] c"RedisModule_ListSet\00", align 1
@.str.223 = private unnamed_addr constant [23 x i8] c"RedisModule_ListInsert\00", align 1
@.str.224 = private unnamed_addr constant [23 x i8] c"RedisModule_ListDelete\00", align 1
@.str.225 = private unnamed_addr constant [29 x i8] c"RedisModule_StringToLongLong\00", align 1
@.str.226 = private unnamed_addr constant [30 x i8] c"RedisModule_StringToULongLong\00", align 1
@.str.227 = private unnamed_addr constant [27 x i8] c"RedisModule_StringToDouble\00", align 1
@.str.228 = private unnamed_addr constant [31 x i8] c"RedisModule_StringToLongDouble\00", align 1
@.str.229 = private unnamed_addr constant [29 x i8] c"RedisModule_StringToStreamID\00", align 1
@.str.230 = private unnamed_addr constant [17 x i8] c"RedisModule_Call\00", align 1
@.str.231 = private unnamed_addr constant [27 x i8] c"RedisModule_CallReplyProto\00", align 1
@.str.232 = private unnamed_addr constant [26 x i8] c"RedisModule_FreeCallReply\00", align 1
@.str.233 = private unnamed_addr constant [29 x i8] c"RedisModule_CallReplyInteger\00", align 1
@.str.234 = private unnamed_addr constant [28 x i8] c"RedisModule_CallReplyDouble\00", align 1
@.str.235 = private unnamed_addr constant [31 x i8] c"RedisModule_CallReplyBigNumber\00", align 1
@.str.236 = private unnamed_addr constant [30 x i8] c"RedisModule_CallReplyVerbatim\00", align 1
@.str.237 = private unnamed_addr constant [26 x i8] c"RedisModule_CallReplyBool\00", align 1
@.str.238 = private unnamed_addr constant [32 x i8] c"RedisModule_CallReplySetElement\00", align 1
@.str.239 = private unnamed_addr constant [32 x i8] c"RedisModule_CallReplyMapElement\00", align 1
@.str.240 = private unnamed_addr constant [38 x i8] c"RedisModule_CallReplyAttributeElement\00", align 1
@.str.241 = private unnamed_addr constant [46 x i8] c"RedisModule_CallReplyPromiseSetUnblockHandler\00", align 1
@.str.242 = private unnamed_addr constant [34 x i8] c"RedisModule_CallReplyPromiseAbort\00", align 1
@.str.243 = private unnamed_addr constant [31 x i8] c"RedisModule_CallReplyAttribute\00", align 1
@.str.244 = private unnamed_addr constant [26 x i8] c"RedisModule_CallReplyType\00", align 1
@.str.245 = private unnamed_addr constant [28 x i8] c"RedisModule_CallReplyLength\00", align 1
@.str.246 = private unnamed_addr constant [34 x i8] c"RedisModule_CallReplyArrayElement\00", align 1
@.str.247 = private unnamed_addr constant [31 x i8] c"RedisModule_CallReplyStringPtr\00", align 1
@.str.248 = private unnamed_addr constant [38 x i8] c"RedisModule_CreateStringFromCallReply\00", align 1
@.str.249 = private unnamed_addr constant [25 x i8] c"RedisModule_CreateString\00", align 1
@.str.250 = private unnamed_addr constant [37 x i8] c"RedisModule_CreateStringFromLongLong\00", align 1
@.str.251 = private unnamed_addr constant [38 x i8] c"RedisModule_CreateStringFromULongLong\00", align 1
@.str.252 = private unnamed_addr constant [35 x i8] c"RedisModule_CreateStringFromDouble\00", align 1
@.str.253 = private unnamed_addr constant [39 x i8] c"RedisModule_CreateStringFromLongDouble\00", align 1
@.str.254 = private unnamed_addr constant [35 x i8] c"RedisModule_CreateStringFromString\00", align 1
@.str.255 = private unnamed_addr constant [37 x i8] c"RedisModule_CreateStringFromStreamID\00", align 1
@.str.256 = private unnamed_addr constant [31 x i8] c"RedisModule_CreateStringPrintf\00", align 1
@.str.257 = private unnamed_addr constant [23 x i8] c"RedisModule_FreeString\00", align 1
@.str.258 = private unnamed_addr constant [25 x i8] c"RedisModule_StringPtrLen\00", align 1
@.str.259 = private unnamed_addr constant [23 x i8] c"RedisModule_AutoMemory\00", align 1
@.str.260 = private unnamed_addr constant [22 x i8] c"RedisModule_Replicate\00", align 1
@.str.261 = private unnamed_addr constant [30 x i8] c"RedisModule_ReplicateVerbatim\00", align 1
@.str.262 = private unnamed_addr constant [22 x i8] c"RedisModule_DeleteKey\00", align 1
@.str.263 = private unnamed_addr constant [22 x i8] c"RedisModule_UnlinkKey\00", align 1
@.str.264 = private unnamed_addr constant [22 x i8] c"RedisModule_StringSet\00", align 1
@.str.265 = private unnamed_addr constant [22 x i8] c"RedisModule_StringDMA\00", align 1
@.str.266 = private unnamed_addr constant [27 x i8] c"RedisModule_StringTruncate\00", align 1
@.str.267 = private unnamed_addr constant [22 x i8] c"RedisModule_SetExpire\00", align 1
@.str.268 = private unnamed_addr constant [22 x i8] c"RedisModule_GetExpire\00", align 1
@.str.269 = private unnamed_addr constant [25 x i8] c"RedisModule_SetAbsExpire\00", align 1
@.str.270 = private unnamed_addr constant [25 x i8] c"RedisModule_GetAbsExpire\00", align 1
@.str.271 = private unnamed_addr constant [25 x i8] c"RedisModule_ResetDataset\00", align 1
@.str.272 = private unnamed_addr constant [19 x i8] c"RedisModule_DbSize\00", align 1
@.str.273 = private unnamed_addr constant [22 x i8] c"RedisModule_RandomKey\00", align 1
@.str.274 = private unnamed_addr constant [20 x i8] c"RedisModule_ZsetAdd\00", align 1
@.str.275 = private unnamed_addr constant [23 x i8] c"RedisModule_ZsetIncrby\00", align 1
@.str.276 = private unnamed_addr constant [22 x i8] c"RedisModule_ZsetScore\00", align 1
@.str.277 = private unnamed_addr constant [20 x i8] c"RedisModule_ZsetRem\00", align 1
@.str.278 = private unnamed_addr constant [26 x i8] c"RedisModule_ZsetRangeStop\00", align 1
@.str.279 = private unnamed_addr constant [34 x i8] c"RedisModule_ZsetFirstInScoreRange\00", align 1
@.str.280 = private unnamed_addr constant [33 x i8] c"RedisModule_ZsetLastInScoreRange\00", align 1
@.str.281 = private unnamed_addr constant [32 x i8] c"RedisModule_ZsetFirstInLexRange\00", align 1
@.str.282 = private unnamed_addr constant [31 x i8] c"RedisModule_ZsetLastInLexRange\00", align 1
@.str.283 = private unnamed_addr constant [36 x i8] c"RedisModule_ZsetRangeCurrentElement\00", align 1
@.str.284 = private unnamed_addr constant [26 x i8] c"RedisModule_ZsetRangeNext\00", align 1
@.str.285 = private unnamed_addr constant [26 x i8] c"RedisModule_ZsetRangePrev\00", align 1
@.str.286 = private unnamed_addr constant [32 x i8] c"RedisModule_ZsetRangeEndReached\00", align 1
@.str.287 = private unnamed_addr constant [20 x i8] c"RedisModule_HashSet\00", align 1
@.str.288 = private unnamed_addr constant [20 x i8] c"RedisModule_HashGet\00", align 1
@.str.289 = private unnamed_addr constant [22 x i8] c"RedisModule_StreamAdd\00", align 1
@.str.290 = private unnamed_addr constant [25 x i8] c"RedisModule_StreamDelete\00", align 1
@.str.291 = private unnamed_addr constant [32 x i8] c"RedisModule_StreamIteratorStart\00", align 1
@.str.292 = private unnamed_addr constant [31 x i8] c"RedisModule_StreamIteratorStop\00", align 1
@.str.293 = private unnamed_addr constant [33 x i8] c"RedisModule_StreamIteratorNextID\00", align 1
@.str.294 = private unnamed_addr constant [36 x i8] c"RedisModule_StreamIteratorNextField\00", align 1
@.str.295 = private unnamed_addr constant [33 x i8] c"RedisModule_StreamIteratorDelete\00", align 1
@.str.296 = private unnamed_addr constant [31 x i8] c"RedisModule_StreamTrimByLength\00", align 1
@.str.297 = private unnamed_addr constant [27 x i8] c"RedisModule_StreamTrimByID\00", align 1
@.str.298 = private unnamed_addr constant [34 x i8] c"RedisModule_IsKeysPositionRequest\00", align 1
@.str.299 = private unnamed_addr constant [21 x i8] c"RedisModule_KeyAtPos\00", align 1
@.str.300 = private unnamed_addr constant [30 x i8] c"RedisModule_KeyAtPosWithFlags\00", align 1
@.str.301 = private unnamed_addr constant [38 x i8] c"RedisModule_IsChannelsPositionRequest\00", align 1
@.str.302 = private unnamed_addr constant [34 x i8] c"RedisModule_ChannelAtPosWithFlags\00", align 1
@.str.303 = private unnamed_addr constant [24 x i8] c"RedisModule_GetClientId\00", align 1
@.str.304 = private unnamed_addr constant [34 x i8] c"RedisModule_GetClientUserNameById\00", align 1
@.str.305 = private unnamed_addr constant [28 x i8] c"RedisModule_GetContextFlags\00", align 1
@.str.306 = private unnamed_addr constant [32 x i8] c"RedisModule_AvoidReplicaTraffic\00", align 1
@.str.307 = private unnamed_addr constant [22 x i8] c"RedisModule_PoolAlloc\00", align 1
@.str.308 = private unnamed_addr constant [27 x i8] c"RedisModule_CreateDataType\00", align 1
@.str.309 = private unnamed_addr constant [31 x i8] c"RedisModule_ModuleTypeSetValue\00", align 1
@.str.310 = private unnamed_addr constant [35 x i8] c"RedisModule_ModuleTypeReplaceValue\00", align 1
@.str.311 = private unnamed_addr constant [30 x i8] c"RedisModule_ModuleTypeGetType\00", align 1
@.str.312 = private unnamed_addr constant [31 x i8] c"RedisModule_ModuleTypeGetValue\00", align 1
@.str.313 = private unnamed_addr constant [22 x i8] c"RedisModule_IsIOError\00", align 1
@.str.314 = private unnamed_addr constant [29 x i8] c"RedisModule_SetModuleOptions\00", align 1
@.str.315 = private unnamed_addr constant [30 x i8] c"RedisModule_SignalModifiedKey\00", align 1
@.str.316 = private unnamed_addr constant [25 x i8] c"RedisModule_SaveUnsigned\00", align 1
@.str.317 = private unnamed_addr constant [25 x i8] c"RedisModule_LoadUnsigned\00", align 1
@.str.318 = private unnamed_addr constant [23 x i8] c"RedisModule_SaveSigned\00", align 1
@.str.319 = private unnamed_addr constant [23 x i8] c"RedisModule_LoadSigned\00", align 1
@.str.320 = private unnamed_addr constant [23 x i8] c"RedisModule_SaveString\00", align 1
@.str.321 = private unnamed_addr constant [29 x i8] c"RedisModule_SaveStringBuffer\00", align 1
@.str.322 = private unnamed_addr constant [23 x i8] c"RedisModule_LoadString\00", align 1
@.str.323 = private unnamed_addr constant [29 x i8] c"RedisModule_LoadStringBuffer\00", align 1
@.str.324 = private unnamed_addr constant [23 x i8] c"RedisModule_SaveDouble\00", align 1
@.str.325 = private unnamed_addr constant [23 x i8] c"RedisModule_LoadDouble\00", align 1
@.str.326 = private unnamed_addr constant [22 x i8] c"RedisModule_SaveFloat\00", align 1
@.str.327 = private unnamed_addr constant [22 x i8] c"RedisModule_LoadFloat\00", align 1
@.str.328 = private unnamed_addr constant [27 x i8] c"RedisModule_SaveLongDouble\00", align 1
@.str.329 = private unnamed_addr constant [27 x i8] c"RedisModule_LoadLongDouble\00", align 1
@.str.330 = private unnamed_addr constant [33 x i8] c"RedisModule_SaveDataTypeToString\00", align 1
@.str.331 = private unnamed_addr constant [35 x i8] c"RedisModule_LoadDataTypeFromString\00", align 1
@.str.332 = private unnamed_addr constant [41 x i8] c"RedisModule_LoadDataTypeFromStringEncver\00", align 1
@.str.333 = private unnamed_addr constant [20 x i8] c"RedisModule_EmitAOF\00", align 1
@.str.334 = private unnamed_addr constant [16 x i8] c"RedisModule_Log\00", align 1
@.str.335 = private unnamed_addr constant [23 x i8] c"RedisModule_LogIOError\00", align 1
@.str.336 = private unnamed_addr constant [20 x i8] c"RedisModule__Assert\00", align 1
@.str.337 = private unnamed_addr constant [29 x i8] c"RedisModule_LatencyAddSample\00", align 1
@.str.338 = private unnamed_addr constant [31 x i8] c"RedisModule_StringAppendBuffer\00", align 1
@.str.339 = private unnamed_addr constant [33 x i8] c"RedisModule_TrimStringAllocation\00", align 1
@.str.340 = private unnamed_addr constant [25 x i8] c"RedisModule_RetainString\00", align 1
@.str.341 = private unnamed_addr constant [23 x i8] c"RedisModule_HoldString\00", align 1
@.str.342 = private unnamed_addr constant [26 x i8] c"RedisModule_StringCompare\00", align 1
@.str.343 = private unnamed_addr constant [29 x i8] c"RedisModule_GetContextFromIO\00", align 1
@.str.344 = private unnamed_addr constant [29 x i8] c"RedisModule_GetKeyNameFromIO\00", align 1
@.str.345 = private unnamed_addr constant [36 x i8] c"RedisModule_GetKeyNameFromModuleKey\00", align 1
@.str.346 = private unnamed_addr constant [33 x i8] c"RedisModule_GetDbIdFromModuleKey\00", align 1
@.str.347 = private unnamed_addr constant [26 x i8] c"RedisModule_GetDbIdFromIO\00", align 1
@.str.348 = private unnamed_addr constant [33 x i8] c"RedisModule_GetKeyNameFromOptCtx\00", align 1
@.str.349 = private unnamed_addr constant [35 x i8] c"RedisModule_GetToKeyNameFromOptCtx\00", align 1
@.str.350 = private unnamed_addr constant [30 x i8] c"RedisModule_GetDbIdFromOptCtx\00", align 1
@.str.351 = private unnamed_addr constant [32 x i8] c"RedisModule_GetToDbIdFromOptCtx\00", align 1
@.str.352 = private unnamed_addr constant [36 x i8] c"RedisModule_GetKeyNameFromDefragCtx\00", align 1
@.str.353 = private unnamed_addr constant [33 x i8] c"RedisModule_GetDbIdFromDefragCtx\00", align 1
@.str.354 = private unnamed_addr constant [33 x i8] c"RedisModule_GetKeyNameFromDigest\00", align 1
@.str.355 = private unnamed_addr constant [30 x i8] c"RedisModule_GetDbIdFromDigest\00", align 1
@.str.356 = private unnamed_addr constant [24 x i8] c"RedisModule_BlockClient\00", align 1
@.str.357 = private unnamed_addr constant [38 x i8] c"RedisModule_BlockClientGetPrivateData\00", align 1
@.str.358 = private unnamed_addr constant [38 x i8] c"RedisModule_BlockClientSetPrivateData\00", align 1
@.str.359 = private unnamed_addr constant [30 x i8] c"RedisModule_BlockClientOnAuth\00", align 1
@.str.360 = private unnamed_addr constant [26 x i8] c"RedisModule_UnblockClient\00", align 1
@.str.361 = private unnamed_addr constant [34 x i8] c"RedisModule_IsBlockedReplyRequest\00", align 1
@.str.362 = private unnamed_addr constant [36 x i8] c"RedisModule_IsBlockedTimeoutRequest\00", align 1
@.str.363 = private unnamed_addr constant [40 x i8] c"RedisModule_GetBlockedClientPrivateData\00", align 1
@.str.364 = private unnamed_addr constant [23 x i8] c"RedisModule_AbortBlock\00", align 1
@.str.365 = private unnamed_addr constant [25 x i8] c"RedisModule_Milliseconds\00", align 1
@.str.366 = private unnamed_addr constant [34 x i8] c"RedisModule_MonotonicMicroseconds\00", align 1
@.str.367 = private unnamed_addr constant [25 x i8] c"RedisModule_Microseconds\00", align 1
@.str.368 = private unnamed_addr constant [31 x i8] c"RedisModule_CachedMicroseconds\00", align 1
@.str.369 = private unnamed_addr constant [42 x i8] c"RedisModule_BlockedClientMeasureTimeStart\00", align 1
@.str.370 = private unnamed_addr constant [40 x i8] c"RedisModule_BlockedClientMeasureTimeEnd\00", align 1
@.str.371 = private unnamed_addr constant [33 x i8] c"RedisModule_GetThreadSafeContext\00", align 1
@.str.372 = private unnamed_addr constant [41 x i8] c"RedisModule_GetDetachedThreadSafeContext\00", align 1
@.str.373 = private unnamed_addr constant [34 x i8] c"RedisModule_FreeThreadSafeContext\00", align 1
@.str.374 = private unnamed_addr constant [34 x i8] c"RedisModule_ThreadSafeContextLock\00", align 1
@.str.375 = private unnamed_addr constant [37 x i8] c"RedisModule_ThreadSafeContextTryLock\00", align 1
@.str.376 = private unnamed_addr constant [36 x i8] c"RedisModule_ThreadSafeContextUnlock\00", align 1
@.str.377 = private unnamed_addr constant [34 x i8] c"RedisModule_DigestAddStringBuffer\00", align 1
@.str.378 = private unnamed_addr constant [30 x i8] c"RedisModule_DigestAddLongLong\00", align 1
@.str.379 = private unnamed_addr constant [30 x i8] c"RedisModule_DigestEndSequence\00", align 1
@.str.380 = private unnamed_addr constant [32 x i8] c"RedisModule_NotifyKeyspaceEvent\00", align 1
@.str.381 = private unnamed_addr constant [36 x i8] c"RedisModule_GetNotifyKeyspaceEvents\00", align 1
@.str.382 = private unnamed_addr constant [38 x i8] c"RedisModule_SubscribeToKeyspaceEvents\00", align 1
@.str.383 = private unnamed_addr constant [35 x i8] c"RedisModule_AddPostNotificationJob\00", align 1
@.str.384 = private unnamed_addr constant [43 x i8] c"RedisModule_RegisterClusterMessageReceiver\00", align 1
@.str.385 = private unnamed_addr constant [31 x i8] c"RedisModule_SendClusterMessage\00", align 1
@.str.386 = private unnamed_addr constant [31 x i8] c"RedisModule_GetClusterNodeInfo\00", align 1
@.str.387 = private unnamed_addr constant [32 x i8] c"RedisModule_GetClusterNodesList\00", align 1
@.str.388 = private unnamed_addr constant [33 x i8] c"RedisModule_FreeClusterNodesList\00", align 1
@.str.389 = private unnamed_addr constant [24 x i8] c"RedisModule_CreateTimer\00", align 1
@.str.390 = private unnamed_addr constant [22 x i8] c"RedisModule_StopTimer\00", align 1
@.str.391 = private unnamed_addr constant [25 x i8] c"RedisModule_GetTimerInfo\00", align 1
@.str.392 = private unnamed_addr constant [27 x i8] c"RedisModule_GetMyClusterID\00", align 1
@.str.393 = private unnamed_addr constant [27 x i8] c"RedisModule_GetClusterSize\00", align 1
@.str.394 = private unnamed_addr constant [27 x i8] c"RedisModule_GetRandomBytes\00", align 1
@.str.395 = private unnamed_addr constant [30 x i8] c"RedisModule_GetRandomHexChars\00", align 1
@.str.396 = private unnamed_addr constant [38 x i8] c"RedisModule_BlockedClientDisconnected\00", align 1
@.str.397 = private unnamed_addr constant [34 x i8] c"RedisModule_SetDisconnectCallback\00", align 1
@.str.398 = private unnamed_addr constant [35 x i8] c"RedisModule_GetBlockedClientHandle\00", align 1
@.str.399 = private unnamed_addr constant [28 x i8] c"RedisModule_SetClusterFlags\00", align 1
@.str.400 = private unnamed_addr constant [23 x i8] c"RedisModule_CreateDict\00", align 1
@.str.401 = private unnamed_addr constant [21 x i8] c"RedisModule_FreeDict\00", align 1
@.str.402 = private unnamed_addr constant [21 x i8] c"RedisModule_DictSize\00", align 1
@.str.403 = private unnamed_addr constant [21 x i8] c"RedisModule_DictSetC\00", align 1
@.str.404 = private unnamed_addr constant [25 x i8] c"RedisModule_DictReplaceC\00", align 1
@.str.405 = private unnamed_addr constant [20 x i8] c"RedisModule_DictSet\00", align 1
@.str.406 = private unnamed_addr constant [24 x i8] c"RedisModule_DictReplace\00", align 1
@.str.407 = private unnamed_addr constant [21 x i8] c"RedisModule_DictGetC\00", align 1
@.str.408 = private unnamed_addr constant [20 x i8] c"RedisModule_DictGet\00", align 1
@.str.409 = private unnamed_addr constant [21 x i8] c"RedisModule_DictDelC\00", align 1
@.str.410 = private unnamed_addr constant [20 x i8] c"RedisModule_DictDel\00", align 1
@.str.411 = private unnamed_addr constant [31 x i8] c"RedisModule_DictIteratorStartC\00", align 1
@.str.412 = private unnamed_addr constant [30 x i8] c"RedisModule_DictIteratorStart\00", align 1
@.str.413 = private unnamed_addr constant [29 x i8] c"RedisModule_DictIteratorStop\00", align 1
@.str.414 = private unnamed_addr constant [32 x i8] c"RedisModule_DictIteratorReseekC\00", align 1
@.str.415 = private unnamed_addr constant [31 x i8] c"RedisModule_DictIteratorReseek\00", align 1
@.str.416 = private unnamed_addr constant [22 x i8] c"RedisModule_DictNextC\00", align 1
@.str.417 = private unnamed_addr constant [22 x i8] c"RedisModule_DictPrevC\00", align 1
@.str.418 = private unnamed_addr constant [21 x i8] c"RedisModule_DictNext\00", align 1
@.str.419 = private unnamed_addr constant [21 x i8] c"RedisModule_DictPrev\00", align 1
@.str.420 = private unnamed_addr constant [25 x i8] c"RedisModule_DictCompareC\00", align 1
@.str.421 = private unnamed_addr constant [24 x i8] c"RedisModule_DictCompare\00", align 1
@.str.422 = private unnamed_addr constant [28 x i8] c"RedisModule_ExportSharedAPI\00", align 1
@.str.423 = private unnamed_addr constant [25 x i8] c"RedisModule_GetSharedAPI\00", align 1
@.str.424 = private unnamed_addr constant [34 x i8] c"RedisModule_RegisterCommandFilter\00", align 1
@.str.425 = private unnamed_addr constant [36 x i8] c"RedisModule_UnregisterCommandFilter\00", align 1
@.str.426 = private unnamed_addr constant [35 x i8] c"RedisModule_CommandFilterArgsCount\00", align 1
@.str.427 = private unnamed_addr constant [32 x i8] c"RedisModule_CommandFilterArgGet\00", align 1
@.str.428 = private unnamed_addr constant [35 x i8] c"RedisModule_CommandFilterArgInsert\00", align 1
@.str.429 = private unnamed_addr constant [36 x i8] c"RedisModule_CommandFilterArgReplace\00", align 1
@.str.430 = private unnamed_addr constant [35 x i8] c"RedisModule_CommandFilterArgDelete\00", align 1
@.str.431 = private unnamed_addr constant [37 x i8] c"RedisModule_CommandFilterGetClientId\00", align 1
@.str.432 = private unnamed_addr constant [17 x i8] c"RedisModule_Fork\00", align 1
@.str.433 = private unnamed_addr constant [31 x i8] c"RedisModule_SendChildHeartbeat\00", align 1
@.str.434 = private unnamed_addr constant [26 x i8] c"RedisModule_ExitFromChild\00", align 1
@.str.435 = private unnamed_addr constant [26 x i8] c"RedisModule_KillForkChild\00", align 1
@.str.436 = private unnamed_addr constant [29 x i8] c"RedisModule_RegisterInfoFunc\00", align 1
@.str.437 = private unnamed_addr constant [27 x i8] c"RedisModule_InfoAddSection\00", align 1
@.str.438 = private unnamed_addr constant [31 x i8] c"RedisModule_InfoBeginDictField\00", align 1
@.str.439 = private unnamed_addr constant [29 x i8] c"RedisModule_InfoEndDictField\00", align 1
@.str.440 = private unnamed_addr constant [31 x i8] c"RedisModule_InfoAddFieldString\00", align 1
@.str.441 = private unnamed_addr constant [32 x i8] c"RedisModule_InfoAddFieldCString\00", align 1
@.str.442 = private unnamed_addr constant [31 x i8] c"RedisModule_InfoAddFieldDouble\00", align 1
@.str.443 = private unnamed_addr constant [33 x i8] c"RedisModule_InfoAddFieldLongLong\00", align 1
@.str.444 = private unnamed_addr constant [34 x i8] c"RedisModule_InfoAddFieldULongLong\00", align 1
@.str.445 = private unnamed_addr constant [26 x i8] c"RedisModule_GetServerInfo\00", align 1
@.str.446 = private unnamed_addr constant [27 x i8] c"RedisModule_FreeServerInfo\00", align 1
@.str.447 = private unnamed_addr constant [31 x i8] c"RedisModule_ServerInfoGetField\00", align 1
@.str.448 = private unnamed_addr constant [32 x i8] c"RedisModule_ServerInfoGetFieldC\00", align 1
@.str.449 = private unnamed_addr constant [37 x i8] c"RedisModule_ServerInfoGetFieldSigned\00", align 1
@.str.450 = private unnamed_addr constant [39 x i8] c"RedisModule_ServerInfoGetFieldUnsigned\00", align 1
@.str.451 = private unnamed_addr constant [37 x i8] c"RedisModule_ServerInfoGetFieldDouble\00", align 1
@.str.452 = private unnamed_addr constant [30 x i8] c"RedisModule_GetClientInfoById\00", align 1
@.str.453 = private unnamed_addr constant [30 x i8] c"RedisModule_GetClientNameById\00", align 1
@.str.454 = private unnamed_addr constant [30 x i8] c"RedisModule_SetClientNameById\00", align 1
@.str.455 = private unnamed_addr constant [27 x i8] c"RedisModule_PublishMessage\00", align 1
@.str.456 = private unnamed_addr constant [32 x i8] c"RedisModule_PublishMessageShard\00", align 1
@.str.457 = private unnamed_addr constant [35 x i8] c"RedisModule_SubscribeToServerEvent\00", align 1
@.str.458 = private unnamed_addr constant [19 x i8] c"RedisModule_SetLRU\00", align 1
@.str.459 = private unnamed_addr constant [19 x i8] c"RedisModule_GetLRU\00", align 1
@.str.460 = private unnamed_addr constant [19 x i8] c"RedisModule_SetLFU\00", align 1
@.str.461 = private unnamed_addr constant [19 x i8] c"RedisModule_GetLFU\00", align 1
@.str.462 = private unnamed_addr constant [30 x i8] c"RedisModule_BlockClientOnKeys\00", align 1
@.str.463 = private unnamed_addr constant [39 x i8] c"RedisModule_BlockClientOnKeysWithFlags\00", align 1
@.str.464 = private unnamed_addr constant [29 x i8] c"RedisModule_SignalKeyAsReady\00", align 1
@.str.465 = private unnamed_addr constant [37 x i8] c"RedisModule_GetBlockedClientReadyKey\00", align 1
@.str.466 = private unnamed_addr constant [31 x i8] c"RedisModule_GetUsedMemoryRatio\00", align 1
@.str.467 = private unnamed_addr constant [23 x i8] c"RedisModule_MallocSize\00", align 1
@.str.468 = private unnamed_addr constant [29 x i8] c"RedisModule_MallocUsableSize\00", align 1
@.str.469 = private unnamed_addr constant [29 x i8] c"RedisModule_MallocSizeString\00", align 1
@.str.470 = private unnamed_addr constant [27 x i8] c"RedisModule_MallocSizeDict\00", align 1
@.str.471 = private unnamed_addr constant [29 x i8] c"RedisModule_ScanCursorCreate\00", align 1
@.str.472 = private unnamed_addr constant [30 x i8] c"RedisModule_ScanCursorDestroy\00", align 1
@.str.473 = private unnamed_addr constant [30 x i8] c"RedisModule_ScanCursorRestart\00", align 1
@.str.474 = private unnamed_addr constant [17 x i8] c"RedisModule_Scan\00", align 1
@.str.475 = private unnamed_addr constant [20 x i8] c"RedisModule_ScanKey\00", align 1
@.str.476 = private unnamed_addr constant [29 x i8] c"RedisModule_CreateModuleUser\00", align 1
@.str.477 = private unnamed_addr constant [27 x i8] c"RedisModule_SetContextUser\00", align 1
@.str.478 = private unnamed_addr constant [29 x i8] c"RedisModule_SetModuleUserACL\00", align 1
@.str.479 = private unnamed_addr constant [35 x i8] c"RedisModule_SetModuleUserACLString\00", align 1
@.str.480 = private unnamed_addr constant [35 x i8] c"RedisModule_GetModuleUserACLString\00", align 1
@.str.481 = private unnamed_addr constant [31 x i8] c"RedisModule_GetCurrentUserName\00", align 1
@.str.482 = private unnamed_addr constant [38 x i8] c"RedisModule_GetModuleUserFromUserName\00", align 1
@.str.483 = private unnamed_addr constant [39 x i8] c"RedisModule_ACLCheckCommandPermissions\00", align 1
@.str.484 = private unnamed_addr constant [35 x i8] c"RedisModule_ACLCheckKeyPermissions\00", align 1
@.str.485 = private unnamed_addr constant [39 x i8] c"RedisModule_ACLCheckChannelPermissions\00", align 1
@.str.486 = private unnamed_addr constant [27 x i8] c"RedisModule_ACLAddLogEntry\00", align 1
@.str.487 = private unnamed_addr constant [37 x i8] c"RedisModule_ACLAddLogEntryByUserName\00", align 1
@.str.488 = private unnamed_addr constant [27 x i8] c"RedisModule_FreeModuleUser\00", align 1
@.str.489 = private unnamed_addr constant [41 x i8] c"RedisModule_DeauthenticateAndCloseClient\00", align 1
@.str.490 = private unnamed_addr constant [42 x i8] c"RedisModule_AuthenticateClientWithACLUser\00", align 1
@.str.491 = private unnamed_addr constant [39 x i8] c"RedisModule_AuthenticateClientWithUser\00", align 1
@.str.492 = private unnamed_addr constant [31 x i8] c"RedisModule_GetContextFlagsAll\00", align 1
@.str.493 = private unnamed_addr constant [32 x i8] c"RedisModule_GetModuleOptionsAll\00", align 1
@.str.494 = private unnamed_addr constant [44 x i8] c"RedisModule_GetKeyspaceNotificationFlagsAll\00", align 1
@.str.495 = private unnamed_addr constant [32 x i8] c"RedisModule_IsSubEventSupported\00", align 1
@.str.496 = private unnamed_addr constant [29 x i8] c"RedisModule_GetServerVersion\00", align 1
@.str.497 = private unnamed_addr constant [33 x i8] c"RedisModule_GetClientCertificate\00", align 1
@.str.498 = private unnamed_addr constant [40 x i8] c"RedisModule_RedactClientCommandArgument\00", align 1
@.str.499 = private unnamed_addr constant [27 x i8] c"RedisModule_GetCommandKeys\00", align 1
@.str.500 = private unnamed_addr constant [36 x i8] c"RedisModule_GetCommandKeysWithFlags\00", align 1
@.str.501 = private unnamed_addr constant [34 x i8] c"RedisModule_GetCurrentCommandName\00", align 1
@.str.502 = private unnamed_addr constant [33 x i8] c"RedisModule_GetTypeMethodVersion\00", align 1
@.str.503 = private unnamed_addr constant [31 x i8] c"RedisModule_RegisterDefragFunc\00", align 1
@.str.504 = private unnamed_addr constant [24 x i8] c"RedisModule_DefragAlloc\00", align 1
@.str.505 = private unnamed_addr constant [36 x i8] c"RedisModule_DefragRedisModuleString\00", align 1
@.str.506 = private unnamed_addr constant [29 x i8] c"RedisModule_DefragShouldStop\00", align 1
@.str.507 = private unnamed_addr constant [28 x i8] c"RedisModule_DefragCursorSet\00", align 1
@.str.508 = private unnamed_addr constant [28 x i8] c"RedisModule_DefragCursorGet\00", align 1
@.str.509 = private unnamed_addr constant [25 x i8] c"RedisModule_EventLoopAdd\00", align 1
@.str.510 = private unnamed_addr constant [25 x i8] c"RedisModule_EventLoopDel\00", align 1
@.str.511 = private unnamed_addr constant [32 x i8] c"RedisModule_EventLoopAddOneShot\00", align 1
@.str.512 = private unnamed_addr constant [18 x i8] c"RedisModule_Yield\00", align 1
@.str.513 = private unnamed_addr constant [31 x i8] c"RedisModule_RegisterBoolConfig\00", align 1
@.str.514 = private unnamed_addr constant [34 x i8] c"RedisModule_RegisterNumericConfig\00", align 1
@.str.515 = private unnamed_addr constant [33 x i8] c"RedisModule_RegisterStringConfig\00", align 1
@.str.516 = private unnamed_addr constant [31 x i8] c"RedisModule_RegisterEnumConfig\00", align 1
@.str.517 = private unnamed_addr constant [24 x i8] c"RedisModule_LoadConfigs\00", align 1
@.str.518 = private unnamed_addr constant [33 x i8] c"RedisModule_RegisterAuthCallback\00", align 1
@.str.519 = private unnamed_addr constant [36 x i8] c"RedisModule_RdbStreamCreateFromFile\00", align 1
@.str.520 = private unnamed_addr constant [26 x i8] c"RedisModule_RdbStreamFree\00", align 1
@.str.521 = private unnamed_addr constant [20 x i8] c"RedisModule_RdbLoad\00", align 1
@.str.522 = private unnamed_addr constant [20 x i8] c"RedisModule_RdbSave\00", align 1
@.str.523 = private unnamed_addr constant [12 x i8] c"!promise->c\00", align 1
@.str.524 = private unnamed_addr constant [38 x i8] c"Invalid command info: version missing\00", align 1
@.str.525 = private unnamed_addr constant [51 x i8] c"Invalid command info: history[%zd].changes missing\00", align 1
@.str.526 = private unnamed_addr constant [41 x i8] c"Invalid command info: Too many key specs\00", align 1
@.str.527 = private unnamed_addr constant [93 x i8] c"Invalid command info: key_specs[%zd].flags: Exactly one of the flags RO, RW, OW, RM required\00", align 1
@.str.528 = private unnamed_addr constant [93 x i8] c"Invalid command info: key_specs[%zd].flags: INSERT, DELETE and UPDATE are mutually exclusive\00", align 1
@.str.529 = private unnamed_addr constant [99 x i8] c"Invalid command info: key_specs[%zd].bs.keyword.keyword required when begin_search_type is KEYWORD\00", align 1
@.str.530 = private unnamed_addr constant [73 x i8] c"Invalid command info: key_specs[%zd].begin_search_type: Invalid value %d\00", align 1
@.str.531 = private unnamed_addr constant [70 x i8] c"Invalid command info: key_specs[%zd].find_keys_type: Invalid value %d\00", align 1
@.str.532 = private unnamed_addr constant [55 x i8] c"Invalid command info: Argument \22%s\22: Undefined type %d\00", align 1
@.str.533 = private unnamed_addr constant [76 x i8] c"Invalid command info: Argument \22%s\22: token required when type is PURE_TOKEN\00", align 1
@.str.534 = private unnamed_addr constant [78 x i8] c"Invalid command info: Argument \22%s\22: key_spec_index required when type is KEY\00", align 1
@.str.535 = private unnamed_addr constant [81 x i8] c"Invalid command info: Argument \22%s\22: key_spec_index specified but type isn't KEY\00", align 1
@.str.536 = private unnamed_addr constant [51 x i8] c"Invalid command info: Argument \22%s\22: Invalid flags\00", align 1
@.str.537 = private unnamed_addr constant [82 x i8] c"Invalid command info: Argument \22%s\22: subargs required when type is ONEOF or BLOCK\00", align 1
@.str.538 = private unnamed_addr constant [86 x i8] c"Invalid command info: Argument \22%s\22: subargs specified but type isn't ONEOF nor BLOCK\00", align 1
@__const.moduleConvertKeySpecsFlags.map = private unnamed_addr constant [12 x [2 x i64]] [[2 x i64] [i64 1, i64 1], [2 x i64] [i64 2, i64 2], [2 x i64] [i64 4, i64 4], [2 x i64] [i64 8, i64 8], [2 x i64] [i64 16, i64 16], [2 x i64] [i64 64, i64 64], [2 x i64] [i64 32, i64 32], [2 x i64] [i64 128, i64 128], [2 x i64] [i64 256, i64 256], [2 x i64] [i64 512, i64 512], [2 x i64] [i64 1024, i64 1024], [2 x i64] zeroinitializer], align 16
@.str.539 = private unnamed_addr constant [50 x i8] c"count < SIZE_MAX / sizeof(struct redisCommandArg)\00", align 1
@.str.540 = private unnamed_addr constant [18 x i8] c"key->iter == NULL\00", align 1
@.str.541 = private unnamed_addr constant [29 x i8] c"key->value->type == OBJ_LIST\00", align 1
@configerr = internal global [256 x i8] zeroinitializer, align 16
@switch.table.RM_KeyType = private unnamed_addr constant [7 x i32] [i32 1, i32 2, i32 4, i32 5, i32 3, i32 6, i32 7], align 4
@switch.table.RM_ACLAddLogEntryByUserName = private unnamed_addr constant [4 x i32] [i32 3, i32 1, i32 2, i32 4], align 4

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Alloc(i64 noundef %bytes) #0 {
entry:
  %call = tail call ptr @zmalloc_usable(i64 noundef %bytes, ptr noundef null) #32
  ret ptr %call
}

declare ptr @zmalloc_usable(i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_TryAlloc(i64 noundef %bytes) #0 {
entry:
  %call = tail call ptr @ztrymalloc_usable(i64 noundef %bytes, ptr noundef null) #32
  ret ptr %call
}

declare ptr @ztrymalloc_usable(i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Calloc(i64 noundef %nmemb, i64 noundef %size) #0 {
entry:
  %mul = mul i64 %size, %nmemb
  %call = tail call ptr @zcalloc_usable(i64 noundef %mul, ptr noundef null) #32
  ret ptr %call
}

declare ptr @zcalloc_usable(i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Realloc(ptr noundef %ptr, i64 noundef %bytes) #0 {
entry:
  %call = tail call ptr @zrealloc_usable(ptr noundef %ptr, i64 noundef %bytes, ptr noundef null) #32
  ret ptr %call
}

declare ptr @zrealloc_usable(ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_Free(ptr noundef %ptr) #0 {
entry:
  tail call void @zfree(ptr noundef %ptr) #32
  ret void
}

declare void @zfree(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noalias ptr @RM_Strdup(ptr noundef %str) #0 {
entry:
  %call = tail call noalias ptr @zstrdup(ptr noundef %str) #32
  ret ptr %call
}

declare noalias ptr @zstrdup(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @poolAllocRelease(ptr nocapture noundef %ctx) local_unnamed_addr #0 {
entry:
  %pa_head = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 13
  %0 = load ptr, ptr %pa_head, align 8
  %cmp.not4 = icmp eq ptr %0, null
  br i1 %cmp.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body
  %head.05 = phi ptr [ %1, %while.body ], [ %0, %entry ]
  %next1 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %head.05, i64 0, i32 2
  %1 = load ptr, ptr %next1, align 8
  tail call void @zfree(ptr noundef nonnull %head.05) #32
  %cmp.not = icmp eq ptr %1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !5

while.end:                                        ; preds = %while.body, %entry
  store ptr null, ptr %pa_head, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_PoolAlloc(ptr nocapture noundef %ctx, i64 noundef %bytes) #0 {
entry:
  %cmp = icmp eq i64 %bytes, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %pa_head = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 13
  %0 = load ptr, ptr %pa_head, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.end
  %1 = load i32, ptr %0, align 8
  %used = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %0, i64 0, i32 1
  %2 = load i32, ptr %used, align 4
  %sub = sub i32 %1, %2
  %3 = zext i32 %sub to i64
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ 0, %if.end ]
  %cmp1.not = icmp ult i64 %cond, %bytes
  br i1 %cmp1.not, label %if.end33, label %while.cond

while.cond:                                       ; preds = %cond.end, %while.cond
  %alignment.0 = phi i64 [ %div36, %while.cond ], [ 8, %cond.end ]
  %cmp4 = icmp ugt i64 %alignment.0, %bytes
  %div36 = lshr i64 %alignment.0, 1
  %cmp6 = icmp uge i64 %div36, %bytes
  %4 = and i1 %cmp4, %cmp6
  br i1 %4, label %while.cond, label %while.end, !llvm.loop !7

while.end:                                        ; preds = %while.cond
  %used9 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %0, i64 0, i32 1
  %5 = load i32, ptr %used9, align 4
  %conv10 = zext i32 %5 to i64
  %6 = add nuw nsw i64 %alignment.0, 4294967295
  %rem = and i64 %6, %conv10
  %tobool11.not = icmp eq i64 %rem, 0
  br i1 %tobool11.not, label %if.end20, label %if.then12

if.then12:                                        ; preds = %while.end
  %sub16 = sub nsw i64 %alignment.0, %rem
  %7 = trunc i64 %sub16 to i32
  %conv19 = add i32 %5, %7
  store i32 %conv19, ptr %used9, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then12, %while.end
  %8 = phi i32 [ %conv19, %if.then12 ], [ %5, %while.end ]
  %9 = load i32, ptr %0, align 8
  %narrow = tail call i32 @llvm.usub.sat.i32(i32 %9, i32 %8)
  %cond31 = zext i32 %narrow to i64
  br label %if.end33

if.end33:                                         ; preds = %if.end20, %cond.end
  %left.0 = phi i64 [ %cond31, %if.end20 ], [ %cond, %cond.end ]
  %cmp34 = icmp ult i64 %left.0, %bytes
  br i1 %cmp34, label %if.then36, label %if.end33.if.end47_crit_edge

if.end33.if.end47_crit_edge:                      ; preds = %if.end33
  %used49.phi.trans.insert = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %0, i64 0, i32 1
  %.pre = load i32, ptr %used49.phi.trans.insert, align 4
  br label %if.end47

if.then36:                                        ; preds = %if.end33
  %spec.select = tail call i64 @llvm.umax.i64(i64 %bytes, i64 8192)
  %add41 = add i64 %spec.select, 16
  %call = tail call noalias ptr @zmalloc(i64 noundef %add41) #33
  %conv42 = trunc i64 %spec.select to i32
  store i32 %conv42, ptr %call, align 8
  %used44 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %call, i64 0, i32 1
  store i32 0, ptr %used44, align 4
  %10 = load ptr, ptr %pa_head, align 8
  %next = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %call, i64 0, i32 2
  store ptr %10, ptr %next, align 8
  store ptr %call, ptr %pa_head, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.end33.if.end47_crit_edge, %if.then36
  %11 = phi i32 [ 0, %if.then36 ], [ %.pre, %if.end33.if.end47_crit_edge ]
  %b.0 = phi ptr [ %call, %if.then36 ], [ %0, %if.end33.if.end47_crit_edge ]
  %memory = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %b.0, i64 0, i32 3
  %used49 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %b.0, i64 0, i32 1
  %idx.ext = zext i32 %11 to i64
  %add.ptr = getelementptr inbounds i8, ptr %memory, i64 %idx.ext
  %12 = trunc i64 %bytes to i32
  %conv53 = add i32 %11, %12
  store i32 %conv53, ptr %used49, align 4
  br label %return

return:                                           ; preds = %entry, %if.end47
  %retval.0 = phi ptr [ %add.ptr, %if.end47 ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: allocsize(0)
declare noalias ptr @zmalloc(i64 noundef) local_unnamed_addr #2

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleAllocTempClient() local_unnamed_addr #0 {
entry:
  %0 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not = icmp eq i64 %0, 0
  br i1 %cmp.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @moduleTempClients, align 8
  %dec = add i64 %0, -1
  store i64 %dec, ptr @moduleTempClientCount, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %dec
  %2 = load ptr, ptr %arrayidx, align 8
  %3 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1 = icmp ult i64 %dec, %3
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.then
  store i64 %dec, ptr @moduleTempClientMinCount, align 8
  br label %if.end3

if.else:                                          ; preds = %entry
  %call = tail call ptr @createClient(ptr noundef null) #32
  %flags = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 1
  %4 = load i64, ptr %flags, align 8
  %or = or i64 %4, 134217728
  store i64 %or, ptr %flags, align 8
  %user = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 20
  store ptr null, ptr %user, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then, %if.then2, %if.else
  %c.0 = phi ptr [ %2, %if.then2 ], [ %2, %if.then ], [ %call, %if.else ]
  ret ptr %c.0
}

declare ptr @createClient(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleReleaseTempClient(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %0 = load i64, ptr @moduleTempClientCount, align 8
  %1 = load i64, ptr @moduleTempClientCap, align 8
  %cmp = icmp eq i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tobool.not = icmp eq i64 %0, 0
  %mul = shl i64 %0, 1
  %cond = select i1 %tobool.not, i64 32, i64 %mul
  store i64 %cond, ptr @moduleTempClientCap, align 8
  %2 = load ptr, ptr @moduleTempClients, align 8
  %mul1 = shl i64 %cond, 3
  %call = tail call ptr @zrealloc(ptr noundef %2, i64 noundef %mul1) #34
  store ptr %call, ptr @moduleTempClients, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  tail call void @clearClientConnectionState(ptr noundef %c) #32
  %reply = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 24
  %3 = load ptr, ptr %reply, align 8
  tail call void @listEmpty(ptr noundef %3) #32
  %reply_bytes = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 25
  store i64 0, ptr %reply_bytes, align 8
  %duration = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 29
  store i64 0, ptr %duration, align 8
  tail call void @resetClient(ptr noundef %c) #32
  %bufpos = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 82
  store i32 0, ptr %bufpos, align 8
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  store i64 134217728, ptr %flags, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %async_rm_call_handle = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55, i32 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %cmd, i8 0, i64 32, i1 false)
  %4 = load ptr, ptr %async_rm_call_handle, align 8
  %tobool2.not = icmp eq ptr %4, null
  br i1 %tobool2.not, label %if.end9, label %if.then3

if.then3:                                         ; preds = %if.end
  %c6 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %4, i64 0, i32 4
  store ptr null, ptr %c6, align 8
  %5 = load i64, ptr %4, align 8
  %dec.i = add i64 %5, -1
  store i64 %dec.i, ptr %4, align 8
  %cmp.not.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.not.i, label %cond.end.i, label %freeRedisModuleAsyncRMCallPromise.exit

cond.end.i:                                       ; preds = %if.then3
  tail call void @zfree(ptr noundef nonnull %4) #32
  br label %freeRedisModuleAsyncRMCallPromise.exit

freeRedisModuleAsyncRMCallPromise.exit:           ; preds = %if.then3, %cond.end.i
  store ptr null, ptr %async_rm_call_handle, align 8
  br label %if.end9

if.end9:                                          ; preds = %freeRedisModuleAsyncRMCallPromise.exit, %if.end
  %6 = load ptr, ptr @moduleTempClients, align 8
  %7 = load i64, ptr @moduleTempClientCount, align 8
  %inc = add i64 %7, 1
  store i64 %inc, ptr @moduleTempClientCount, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %6, i64 %7
  store ptr %c, ptr %arrayidx, align 8
  ret void
}

; Function Attrs: allocsize(1)
declare ptr @zrealloc(ptr noundef, i64 noundef) local_unnamed_addr #3

declare void @clearClientConnectionState(ptr noundef) local_unnamed_addr #1

declare void @listEmpty(ptr noundef) local_unnamed_addr #1

declare void @resetClient(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleCreateEmptyKey(ptr nocapture noundef %key, i32 noundef %type) local_unnamed_addr #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  switch i32 %type, label %return [
    i32 2, label %sw.bb
    i32 5, label %sw.bb2
    i32 3, label %sw.bb4
    i32 7, label %sw.bb6
  ]

sw.bb:                                            ; preds = %if.end
  %call = tail call ptr @createListListpackObject() #32
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.end
  %call3 = tail call ptr @createZsetListpackObject() #32
  br label %sw.epilog

sw.bb4:                                           ; preds = %if.end
  %call5 = tail call ptr @createHashObject() #32
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.end
  %call7 = tail call ptr @createStreamObject() #32
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb6, %sw.bb4, %sw.bb2, %sw.bb
  %obj.0 = phi ptr [ %call7, %sw.bb6 ], [ %call5, %sw.bb4 ], [ %call3, %sw.bb2 ], [ %call, %sw.bb ]
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %2 = load ptr, ptr %db, align 8
  %key8 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %3 = load ptr, ptr %key8, align 8
  tail call void @dbAdd(ptr noundef %2, ptr noundef %3, ptr noundef %obj.0) #32
  store ptr %obj.0, ptr %value, align 8
  %bf.load.i = load i32, ptr %obj.0, align 8
  %bf.clear.i = and i32 %bf.load.i, 15
  switch i32 %bf.clear.i, label %return [
    i32 3, label %sw.bb.i
    i32 6, label %sw.bb1.i
  ]

sw.bb.i:                                          ; preds = %sw.epilog
  %u.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  store i32 0, ptr %u.i.i, align 8
  %current.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i, align 8
  %er.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i.i, align 8
  br label %return

sw.bb1.i:                                         ; preds = %sw.epilog
  %signalready.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 0, ptr %signalready.i, align 8
  br label %return

return:                                           ; preds = %sw.bb1.i, %sw.bb.i, %sw.epilog, %if.end, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %if.end ], [ 0, %sw.epilog ], [ 0, %sw.bb.i ], [ 0, %sw.bb1.i ]
  ret i32 %retval.0
}

declare ptr @createListListpackObject() local_unnamed_addr #1

declare ptr @createZsetListpackObject() local_unnamed_addr #1

declare ptr @createHashObject() local_unnamed_addr #1

declare ptr @createStreamObject() local_unnamed_addr #1

declare void @dbAdd(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleDelKeyIfEmpty(ptr nocapture noundef %key) local_unnamed_addr #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %return [
    i32 1, label %sw.epilog
    i32 2, label %sw.bb3
    i32 3, label %sw.bb7
    i32 4, label %sw.bb11
    i32 6, label %sw.bb15
  ]

sw.bb3:                                           ; preds = %if.end
  %call4 = tail call i64 @setTypeSize(ptr noundef nonnull %1) #32
  %cmp5 = icmp eq i64 %call4, 0
  br i1 %cmp5, label %if.then20, label %return

sw.bb7:                                           ; preds = %if.end
  %call8 = tail call i64 @zsetLength(ptr noundef nonnull %1) #32
  %cmp9 = icmp eq i64 %call8, 0
  br i1 %cmp9, label %if.then20, label %return

sw.bb11:                                          ; preds = %if.end
  %call12 = tail call i64 @hashTypeLength(ptr noundef nonnull %1) #32
  %cmp13 = icmp eq i64 %call12, 0
  br i1 %cmp13, label %if.then20, label %return

sw.bb15:                                          ; preds = %if.end
  %call16 = tail call i64 @streamLength(ptr noundef nonnull %1) #32
  %cmp17 = icmp eq i64 %call16, 0
  br i1 %cmp17, label %if.then20, label %return

sw.epilog:                                        ; preds = %if.end
  %call = tail call i64 @listTypeLength(ptr noundef nonnull %1) #32
  %cmp2 = icmp eq i64 %call, 0
  br i1 %cmp2, label %if.then20, label %return

if.then20:                                        ; preds = %sw.bb3, %sw.bb7, %sw.bb11, %sw.bb15, %sw.epilog
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %2 = load ptr, ptr %iter, align 8
  %tobool21.not = icmp eq ptr %2, null
  br i1 %tobool21.not, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.then20
  tail call fastcc void @moduleFreeKeyIterator(ptr noundef nonnull %key)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then20
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %3 = load ptr, ptr %db, align 8
  %key24 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %4 = load ptr, ptr %key24, align 8
  %call25 = tail call i32 @dbDelete(ptr noundef %3, ptr noundef %4) #32
  store ptr null, ptr %value, align 8
  br label %return

return:                                           ; preds = %sw.bb3, %sw.bb7, %sw.bb11, %sw.bb15, %sw.epilog, %if.end, %entry, %lor.lhs.false, %if.end23
  %retval.0 = phi i32 [ 1, %if.end23 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %if.end ], [ 0, %sw.epilog ], [ 0, %sw.bb15 ], [ 0, %sw.bb11 ], [ 0, %sw.bb7 ], [ 0, %sw.bb3 ]
  ret i32 %retval.0
}

declare i64 @listTypeLength(ptr noundef) local_unnamed_addr #1

declare i64 @setTypeSize(ptr noundef) local_unnamed_addr #1

declare i64 @zsetLength(ptr noundef) local_unnamed_addr #1

declare i64 @hashTypeLength(ptr noundef) local_unnamed_addr #1

declare i64 @streamLength(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc void @moduleFreeKeyIterator(ptr nocapture noundef %key) unnamed_addr #0 {
entry:
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %0 = load ptr, ptr %iter, align 8
  %cmp.not = icmp eq ptr %0, null
  br i1 %cmp.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.43, ptr noundef nonnull @.str.2, i32 noundef 718) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %sw.default [
    i32 1, label %sw.bb
    i32 6, label %sw.bb3
  ]

sw.bb:                                            ; preds = %cond.end
  tail call void @listTypeReleaseIterator(ptr noundef nonnull %0) #32
  br label %sw.epilog

sw.bb3:                                           ; preds = %cond.end
  tail call void @streamIteratorStop(ptr noundef nonnull %0) #32
  %2 = load ptr, ptr %iter, align 8
  tail call void @zfree(ptr noundef %2) #32
  br label %sw.epilog

sw.default:                                       ; preds = %cond.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 725) #32
  tail call void @abort() #35
  unreachable

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb
  store ptr null, ptr %iter, align 8
  ret void
}

declare i32 @dbDelete(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_GetApi(ptr noundef %funcname, ptr nocapture noundef writeonly %targetPtrPtr) #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call = tail call ptr @dictFind(ptr noundef %0, ptr noundef %funcname) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call1 = tail call ptr @dictGetVal(ptr noundef nonnull %call) #32
  store ptr %call1, ptr %targetPtrPtr, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare ptr @dictFind(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @dictGetVal(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @modulePostExecutionUnitOperations() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %tobool = icmp eq i32 %0, 0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %tobool1 = icmp ne i32 %1, 0
  %or.cond = select i1 %tobool, i1 %tobool1, i1 false
  br i1 %or.cond, label %if.then2, label %if.end6

if.then2:                                         ; preds = %entry
  tail call void @blockingOperationEnds() #32
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %tobool3.not = icmp eq ptr %2, null
  br i1 %tobool3.not, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.then2
  tail call void @unprotectClient(ptr noundef nonnull %2) #32
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.then2
  tail call void @unblockPostponedClients() #32
  br label %if.end6

if.end6:                                          ; preds = %entry, %if.end5
  ret void
}

declare void @blockingOperationEnds() local_unnamed_addr #1

declare void @unprotectClient(ptr noundef) local_unnamed_addr #1

declare void @unblockPostponedClients() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleFreeContext(ptr nocapture noundef %ctx) local_unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 528
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @exitExecutionUnit() #32
  tail call void @postExecutionUnitOperations() #32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  tail call void @autoMemoryCollect(ptr noundef nonnull %ctx)
  %pa_head.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 13
  %1 = load ptr, ptr %pa_head.i, align 8
  %cmp.not4.i = icmp eq ptr %1, null
  br i1 %cmp.not4.i, label %poolAllocRelease.exit, label %while.body.i

while.body.i:                                     ; preds = %if.end, %while.body.i
  %head.05.i = phi ptr [ %2, %while.body.i ], [ %1, %if.end ]
  %next1.i = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %head.05.i, i64 0, i32 2
  %2 = load ptr, ptr %next1.i, align 8
  tail call void @zfree(ptr noundef nonnull %head.05.i) #32
  %cmp.not.i = icmp eq ptr %2, null
  br i1 %cmp.not.i, label %poolAllocRelease.exit, label %while.body.i, !llvm.loop !5

poolAllocRelease.exit:                            ; preds = %while.body.i, %if.end
  store ptr null, ptr %pa_head.i, align 8
  %postponed_arrays = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %3 = load ptr, ptr %postponed_arrays, align 8
  %tobool1.not = icmp eq ptr %3, null
  br i1 %tobool1.not, label %if.end6, label %if.then2

if.then2:                                         ; preds = %poolAllocRelease.exit
  tail call void @zfree(ptr noundef nonnull %3) #32
  %postponed_arrays_count = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 9
  store i32 0, ptr %postponed_arrays_count, align 8
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %4, 3
  br i1 %cmp, label %if.end6, label %if.end5

if.end5:                                          ; preds = %if.then2
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %5 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 1
  %6 = load ptr, ptr %name, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str, ptr noundef %6) #32
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.then2, %poolAllocRelease.exit
  %7 = load i32, ptr %flags, align 8
  %and8 = and i32 %7, 64
  %tobool9.not = icmp eq i32 %and8, 0
  br i1 %tobool9.not, label %if.else, label %if.then10

if.then10:                                        ; preds = %if.end6
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %8 = load ptr, ptr %client, align 8
  tail call void @moduleReleaseTempClient(ptr noundef %8)
  br label %if.end17

if.else:                                          ; preds = %if.end6
  %and12 = and i32 %7, 128
  %tobool13.not = icmp eq i32 %and12, 0
  br i1 %tobool13.not, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.else
  %client15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %9 = load ptr, ptr %client15, align 8
  tail call void @freeClient(ptr noundef %9) #32
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then14, %if.then10
  ret void
}

declare void @exitExecutionUnit() local_unnamed_addr #1

declare void @postExecutionUnitOperations() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @autoMemoryCollect(ptr nocapture noundef %ctx) local_unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %and2 = and i32 %0, -2
  store i32 %and2, ptr %flags, align 8
  %amqueue_used = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used, align 4
  %cmp22 = icmp sgt i32 %1, 0
  br i1 %cmp22, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.end
  %amqueue = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %2 = load ptr, ptr %amqueue, align 8
  %arrayidx = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %indvars.iv
  %3 = load ptr, ptr %arrayidx, align 8
  %type = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %indvars.iv, i32 1
  %4 = load i32, ptr %type, align 8
  switch i32 %4, label %for.inc [
    i32 1, label %sw.bb
    i32 2, label %sw.bb7
    i32 0, label %sw.bb8
    i32 4, label %sw.bb9
    i32 5, label %sw.bb10
  ]

sw.bb:                                            ; preds = %for.body
  tail call void @decrRefCount(ptr noundef %3) #32
  br label %for.inc

sw.bb7:                                           ; preds = %for.body
  tail call void @RM_FreeCallReply(ptr noundef %3)
  br label %for.inc

sw.bb8:                                           ; preds = %for.body
  %cmp.i = icmp eq ptr %3, null
  br i1 %cmp.i, label %for.inc, label %if.end.i

if.end.i:                                         ; preds = %sw.bb8
  tail call fastcc void @moduleCloseKey(ptr noundef nonnull %3)
  %5 = load ptr, ptr %3, align 8
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 7
  %6 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %6, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %autoMemoryFreed.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.end.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 6
  %7 = load i32, ptr %amqueue_used.i.i, align 4
  %cmp21.i.i = icmp sgt i32 %7, 0
  br i1 %cmp21.i.i, label %for.cond1.preheader.lr.ph.i.i, label %autoMemoryFreed.exit.i

for.cond1.preheader.lr.ph.i.i:                    ; preds = %if.end.i.i
  %add.i.i = add nuw nsw i32 %7, 1
  %div2731.i.i = lshr i32 %add.i.i, 1
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 4
  %8 = load ptr, ptr %amqueue.i.i, align 8
  br label %for.cond1.preheader.i.i

for.cond1.preheader.i.i:                          ; preds = %for.inc34.i.i, %for.cond1.preheader.lr.ph.i.i
  %j.022.i.i = phi i32 [ 0, %for.cond1.preheader.lr.ph.i.i ], [ %inc35.i.i, %for.inc34.i.i ]
  %9 = xor i32 %j.022.i.i, -1
  %sub6.i.i = add nsw i32 %7, %9
  br label %for.body3.i.i

for.body3.i.i:                                    ; preds = %for.inc.i.i, %for.cond1.preheader.i.i
  %cmp4.i.i = phi i1 [ true, %for.cond1.preheader.i.i ], [ false, %for.inc.i.i ]
  %cond.i.i = select i1 %cmp4.i.i, i32 %sub6.i.i, i32 %j.022.i.i
  %idxprom.i.i = sext i32 %cond.i.i to i64
  %type7.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom.i.i, i32 1
  %10 = load i32, ptr %type7.i.i, align 8
  %cmp8.i.i = icmp eq i32 %10, 0
  br i1 %cmp8.i.i, label %land.lhs.true.i.i, label %for.inc.i.i

land.lhs.true.i.i:                                ; preds = %for.body3.i.i
  %arrayidx.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom.i.i
  %11 = load ptr, ptr %arrayidx.i.i, align 8
  %cmp13.i.i = icmp eq ptr %11, %3
  br i1 %cmp13.i.i, label %if.then14.i.i, label %for.inc.i.i

if.then14.i.i:                                    ; preds = %land.lhs.true.i.i
  store i32 3, ptr %type7.i.i, align 8
  %12 = load i32, ptr %amqueue_used.i.i, align 4
  %sub20.i.i = add nsw i32 %12, -1
  %cmp21.not.i.i = icmp eq i32 %cond.i.i, %sub20.i.i
  br i1 %cmp21.not.i.i, label %if.end31.i.i, label %if.then22.i.i

if.then22.i.i:                                    ; preds = %if.then14.i.i
  %13 = load ptr, ptr %amqueue.i.i, align 8
  %arrayidx25.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %13, i64 %idxprom.i.i
  %idxprom29.i.i = sext i32 %sub20.i.i to i64
  %arrayidx30.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %13, i64 %idxprom29.i.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %arrayidx25.i.i, ptr noundef nonnull align 8 dereferenceable(16) %arrayidx30.i.i, i64 16, i1 false)
  %.pre.i.i = load i32, ptr %amqueue_used.i.i, align 4
  %.pre26.i.i = add nsw i32 %.pre.i.i, -1
  br label %if.end31.i.i

if.end31.i.i:                                     ; preds = %if.then22.i.i, %if.then14.i.i
  %dec.pre-phi.i.i = phi i32 [ %.pre26.i.i, %if.then22.i.i ], [ %cond.i.i, %if.then14.i.i ]
  store i32 %dec.pre-phi.i.i, ptr %amqueue_used.i.i, align 4
  br label %autoMemoryFreed.exit.i

for.inc.i.i:                                      ; preds = %land.lhs.true.i.i, %for.body3.i.i
  br i1 %cmp4.i.i, label %for.body3.i.i, label %for.inc34.i.i, !llvm.loop !8

for.inc34.i.i:                                    ; preds = %for.inc.i.i
  %inc35.i.i = add nuw nsw i32 %j.022.i.i, 1
  %exitcond.not.i.i = icmp eq i32 %inc35.i.i, %div2731.i.i
  br i1 %exitcond.not.i.i, label %autoMemoryFreed.exit.i, label %for.cond1.preheader.i.i, !llvm.loop !9

autoMemoryFreed.exit.i:                           ; preds = %for.inc34.i.i, %if.end31.i.i, %if.end.i.i, %if.end.i
  tail call void @zfree(ptr noundef nonnull %3) #32
  br label %for.inc

sw.bb9:                                           ; preds = %for.body
  %14 = load ptr, ptr %3, align 8
  tail call void @raxFree(ptr noundef %14) #32
  tail call void @zfree(ptr noundef nonnull %3) #32
  br label %for.inc

sw.bb10:                                          ; preds = %for.body
  %15 = load ptr, ptr %3, align 8
  tail call void @raxFreeWithCallback(ptr noundef %15, ptr noundef nonnull @sdsfree) #32
  tail call void @zfree(ptr noundef nonnull %3) #32
  br label %for.inc

for.inc:                                          ; preds = %autoMemoryFreed.exit.i, %sw.bb8, %for.body, %sw.bb, %sw.bb7, %sw.bb9, %sw.bb10
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %16 = load i32, ptr %amqueue_used, align 4
  %17 = sext i32 %16 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %17
  br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !10

for.end.loopexit:                                 ; preds = %for.inc
  %.pre = load i32, ptr %flags, align 8
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.end
  %18 = phi i32 [ %.pre, %for.end.loopexit ], [ %and2, %if.end ]
  %or = or i32 %18, 1
  store i32 %or, ptr %flags, align 8
  %amqueue12 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %19 = load ptr, ptr %amqueue12, align 8
  tail call void @zfree(ptr noundef %19) #32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %amqueue12, i8 0, i64 16, i1 false)
  br label %return

return:                                           ; preds = %entry, %for.end
  ret void
}

declare void @_serverLog(i32 noundef, ptr noundef, ...) local_unnamed_addr #1

declare void @freeClient(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleCallCommandUnblockedHandler(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %async_rm_call_handle = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55, i32 8
  %0 = load ptr, ptr %async_rm_call_handle, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.1, ptr noundef nonnull @.str.2, i32 noundef 855) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %on_unblocked = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %0, i64 0, i32 3
  %1 = load ptr, ptr %on_unblocked, align 8
  %tobool4.not = icmp eq ptr %1, null
  br i1 %tobool4.not, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  tail call void @moduleReleaseTempClient(ptr noundef nonnull %c)
  br label %return

if.end:                                           ; preds = %cond.end
  %module3 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %0, i64 0, i32 2
  %2 = load ptr, ptr %module3, align 8
  %3 = getelementptr inbounds i8, ptr %ctx, i64 16
  %4 = getelementptr inbounds i8, ptr %ctx, i64 24
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %4, i8 0, i64 96, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %2, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 64, ptr %flags.i, align 8
  %5 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i.i = icmp eq i64 %5, 0
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end
  %6 = load ptr, ptr @moduleTempClients, align 8
  %dec.i.i = add i64 %5, -1
  store i64 %dec.i.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %6, i64 %dec.i.i
  %7 = load ptr, ptr %arrayidx.i.i, align 8
  %8 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i.i = icmp ult i64 %dec.i.i, %8
  br i1 %cmp1.i.i, label %if.then2.i.i, label %if.end7.sink.split.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  store i64 %dec.i.i, ptr @moduleTempClientMinCount, align 8
  br label %if.end7.sink.split.i

if.else.i.i:                                      ; preds = %if.end
  %call.i.i = tail call ptr @createClient(ptr noundef null) #32
  %flags.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 1
  %9 = load i64, ptr %flags.i.i, align 8
  %or.i.i = or i64 %9, 134217728
  store i64 %or.i.i, ptr %flags.i.i, align 8
  %user.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 20
  store ptr null, ptr %user.i.i, align 8
  br label %if.end7.sink.split.i

if.end7.sink.split.i:                             ; preds = %if.else.i.i, %if.then2.i.i, %if.then.i.i
  %10 = phi ptr [ %7, %if.then2.i.i ], [ %7, %if.then.i.i ], [ %call.i.i, %if.else.i.i ]
  store ptr %10, ptr %3, align 8
  %11 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %11, 0
  %12 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %12() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end7.sink.split.i
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %13
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end7.sink.split.i
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %14, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %15, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %db = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 4
  %16 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %16, i64 0, i32 6
  %17 = load i32, ptr %id, align 8
  %call = tail call i32 @selectDb(ptr noundef %10, i32 noundef %17) #32
  %buf.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 84
  %18 = load ptr, ptr %buf.i, align 8
  %bufpos.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 82
  %19 = load i32, ptr %bufpos.i, align 8
  %conv.i11 = sext i32 %19 to i64
  %call.i = tail call ptr @sdsnewlen(ptr noundef %18, i64 noundef %conv.i11) #32
  store i32 0, ptr %bufpos.i, align 8
  %reply.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 24
  %20 = load ptr, ptr %reply.i, align 8
  %len11.i = getelementptr inbounds %struct.list, ptr %20, i64 0, i32 5
  %21 = load i64, ptr %len11.i, align 8
  %tobool.not12.i = icmp eq i64 %21, 0
  br i1 %tobool.not12.i, label %moduleParseReply.exit, label %while.body.i

while.body.i:                                     ; preds = %moduleCreateContext.exit, %while.body.i
  %22 = phi ptr [ %28, %while.body.i ], [ %20, %moduleCreateContext.exit ]
  %proto.013.i = phi ptr [ %call4.i, %while.body.i ], [ %call.i, %moduleCreateContext.exit ]
  %23 = load ptr, ptr %22, align 8
  %value.i = getelementptr inbounds %struct.listNode, ptr %23, i64 0, i32 2
  %24 = load ptr, ptr %value.i, align 8
  %buf3.i = getelementptr inbounds %struct.clientReplyBlock, ptr %24, i64 0, i32 2
  %used.i = getelementptr inbounds %struct.clientReplyBlock, ptr %24, i64 0, i32 1
  %25 = load i64, ptr %used.i, align 8
  %call4.i = tail call ptr @sdscatlen(ptr noundef %proto.013.i, ptr noundef nonnull %buf3.i, i64 noundef %25) #32
  %26 = load ptr, ptr %reply.i, align 8
  %27 = load ptr, ptr %26, align 8
  tail call void @listDelNode(ptr noundef nonnull %26, ptr noundef %27) #32
  %28 = load ptr, ptr %reply.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %28, i64 0, i32 5
  %29 = load i64, ptr %len.i, align 8
  %tobool.not.i = icmp eq i64 %29, 0
  br i1 %tobool.not.i, label %moduleParseReply.exit, label %while.body.i, !llvm.loop !11

moduleParseReply.exit:                            ; preds = %while.body.i, %moduleCreateContext.exit
  %proto.0.lcssa.i = phi ptr [ %call.i, %moduleCreateContext.exit ], [ %call4.i, %while.body.i ]
  %deferred_reply_errors.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 26
  %30 = load ptr, ptr %deferred_reply_errors.i, align 8
  %call9.i = tail call ptr @callReplyCreate(ptr noundef %proto.0.lcssa.i, ptr noundef %30, ptr noundef null) #32
  store ptr null, ptr %deferred_reply_errors.i, align 8
  %in_call = getelementptr inbounds %struct.RedisModule, ptr %2, i64 0, i32 10
  %31 = load i32, ptr %in_call, align 4
  %inc = add nsw i32 %31, 1
  store i32 %inc, ptr %in_call, align 4
  %32 = load ptr, ptr %on_unblocked, align 8
  %private_data = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %0, i64 0, i32 1
  %33 = load ptr, ptr %private_data, align 8
  call void %32(ptr noundef nonnull %ctx, ptr noundef %call9.i, ptr noundef %33) #32
  %34 = load i32, ptr %in_call, align 4
  %dec = add nsw i32 %34, -1
  store i32 %dec, ptr %in_call, align 4
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  call void @moduleReleaseTempClient(ptr noundef nonnull %c)
  br label %return

return:                                           ; preds = %moduleParseReply.exit, %if.then
  ret void
}

declare void @_serverAssert(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: noreturn nounwind
declare void @abort() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @moduleCreateContext(ptr nocapture noundef writeonly %out_ctx, ptr noundef %module, i32 noundef %ctx_flags) local_unnamed_addr #0 {
entry:
  %0 = getelementptr inbounds i8, ptr %out_ctx, i64 16
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %0, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %out_ctx, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %out_ctx, i64 0, i32 1
  store ptr %module, ptr %module1, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %out_ctx, i64 0, i32 7
  store i32 %ctx_flags, ptr %flags, align 8
  %and = and i32 %ctx_flags, 64
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i = icmp eq i64 %1, 0
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %2 = load ptr, ptr @moduleTempClients, align 8
  %dec.i = add i64 %1, -1
  store i64 %dec.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i = getelementptr inbounds ptr, ptr %2, i64 %dec.i
  %3 = load ptr, ptr %arrayidx.i, align 8
  %4 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i = icmp ult i64 %dec.i, %4
  br i1 %cmp1.i, label %if.then2.i, label %if.end7.sink.split

if.then2.i:                                       ; preds = %if.then.i
  store i64 %dec.i, ptr @moduleTempClientMinCount, align 8
  br label %if.end7.sink.split

if.else.i:                                        ; preds = %if.then
  %call.i = tail call ptr @createClient(ptr noundef null) #32
  %flags.i = getelementptr inbounds %struct.client, ptr %call.i, i64 0, i32 1
  %5 = load i64, ptr %flags.i, align 8
  %or.i = or i64 %5, 134217728
  store i64 %or.i, ptr %flags.i, align 8
  %user.i = getelementptr inbounds %struct.client, ptr %call.i, i64 0, i32 20
  store ptr null, ptr %user.i, align 8
  br label %if.end7.sink.split

if.else:                                          ; preds = %entry
  %and2 = and i32 %ctx_flags, 128
  %tobool3.not = icmp eq i32 %and2, 0
  br i1 %tobool3.not, label %if.end7, label %if.then4

if.then4:                                         ; preds = %if.else
  %call5 = tail call ptr @createClient(ptr noundef null) #32
  br label %if.end7.sink.split

if.end7.sink.split:                               ; preds = %if.else.i, %if.then2.i, %if.then.i, %if.then4
  %call5.sink = phi ptr [ %call5, %if.then4 ], [ %3, %if.then2.i ], [ %3, %if.then.i ], [ %call.i, %if.else.i ]
  %client6 = getelementptr inbounds %struct.RedisModuleCtx, ptr %out_ctx, i64 0, i32 2
  store ptr %call5.sink, ptr %client6, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end7.sink.split, %if.else
  %6 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not = icmp eq i32 %6, 0
  %7 = load ptr, ptr @getMonotonicUs, align 8
  %call12 = tail call i64 %7() #32
  br i1 %tobool8.not, label %if.else11, label %if.then9

if.then9:                                         ; preds = %if.end7
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div = sdiv i32 1000000, %8
  %conv = sext i32 %div to i64
  %add = add i64 %call12, %conv
  br label %if.end15

if.else11:                                        ; preds = %if.end7
  %9 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul = mul nsw i64 %9, 1000
  %add13 = add i64 %mul, %call12
  br label %if.end15

if.end15:                                         ; preds = %if.else11, %if.then9
  %add.sink = phi i64 [ %add13, %if.else11 ], [ %add, %if.then9 ]
  %10 = getelementptr inbounds %struct.RedisModuleCtx, ptr %out_ctx, i64 0, i32 14
  store i64 %add.sink, ptr %10, align 8
  %and16 = and i32 %ctx_flags, 528
  %tobool17.not = icmp eq i32 %and16, 0
  br i1 %tobool17.not, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  ret void
}

declare i32 @selectDb(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc ptr @moduleParseReply(ptr nocapture noundef %c, ptr noundef %ctx) unnamed_addr #0 {
entry:
  %buf = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 84
  %0 = load ptr, ptr %buf, align 8
  %bufpos = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 82
  %1 = load i32, ptr %bufpos, align 8
  %conv = sext i32 %1 to i64
  %call = tail call ptr @sdsnewlen(ptr noundef %0, i64 noundef %conv) #32
  store i32 0, ptr %bufpos, align 8
  %reply = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 24
  %2 = load ptr, ptr %reply, align 8
  %len11 = getelementptr inbounds %struct.list, ptr %2, i64 0, i32 5
  %3 = load i64, ptr %len11, align 8
  %tobool.not12 = icmp eq i64 %3, 0
  br i1 %tobool.not12, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body
  %4 = phi ptr [ %10, %while.body ], [ %2, %entry ]
  %proto.013 = phi ptr [ %call4, %while.body ], [ %call, %entry ]
  %5 = load ptr, ptr %4, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %value, align 8
  %buf3 = getelementptr inbounds %struct.clientReplyBlock, ptr %6, i64 0, i32 2
  %used = getelementptr inbounds %struct.clientReplyBlock, ptr %6, i64 0, i32 1
  %7 = load i64, ptr %used, align 8
  %call4 = tail call ptr @sdscatlen(ptr noundef %proto.013, ptr noundef nonnull %buf3, i64 noundef %7) #32
  %8 = load ptr, ptr %reply, align 8
  %9 = load ptr, ptr %8, align 8
  tail call void @listDelNode(ptr noundef nonnull %8, ptr noundef %9) #32
  %10 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.list, ptr %10, i64 0, i32 5
  %11 = load i64, ptr %len, align 8
  %tobool.not = icmp eq i64 %11, 0
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !11

while.end:                                        ; preds = %while.body, %entry
  %proto.0.lcssa = phi ptr [ %call, %entry ], [ %call4, %while.body ]
  %deferred_reply_errors = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 26
  %12 = load ptr, ptr %deferred_reply_errors, align 8
  %call9 = tail call ptr @callReplyCreate(ptr noundef %proto.0.lcssa, ptr noundef %12, ptr noundef %ctx) #32
  store ptr null, ptr %deferred_reply_errors, align 8
  ret ptr %call9
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #5

declare void @enterExecutionUnit(i32 noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RedisModuleCommandDispatcher(ptr noundef %c) #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %0 = load ptr, ptr %cmd, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 32
  %1 = load ptr, ptr %module_cmd, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds i8, ptr %ctx, i64 16
  %4 = getelementptr inbounds i8, ptr %ctx, i64 24
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %4, i8 0, i64 96, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %2, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 512, ptr %flags.i, align 8
  %5 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %5, 0
  %6 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %6() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %entry
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %7
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %entry
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %8, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %9, align 8
  store ptr %c, ptr %3, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %1, i64 0, i32 1
  %10 = load ptr, ptr %func, align 8
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %11 = load ptr, ptr %argv, align 8
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %12 = load i32, ptr %argc, align 8
  %call = call i32 %10(ptr noundef nonnull %ctx, ptr noundef %11, i32 noundef %12) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %13 = load i32, ptr %argc, align 8
  %cmp11 = icmp sgt i32 %13, 0
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %moduleCreateContext.exit, %for.inc
  %14 = phi i32 [ %18, %for.inc ], [ %13, %moduleCreateContext.exit ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %moduleCreateContext.exit ]
  %15 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %15, i64 %indvars.iv
  %16 = load ptr, ptr %arrayidx, align 8
  %refcount = getelementptr inbounds %struct.redisObject, ptr %16, i64 0, i32 1
  %17 = load i32, ptr %refcount, align 4
  %cmp3 = icmp sgt i32 %17, 1
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @trimStringObjectIfNeeded(ptr noundef nonnull %16, i32 noundef 0) #32
  %.pre = load i32, ptr %argc, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %18 = phi i32 [ %14, %for.body ], [ %.pre, %if.then ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %19 = sext i32 %18 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %19
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !12

for.end:                                          ; preds = %for.inc, %moduleCreateContext.exit
  ret void
}

declare void @trimStringObjectIfNeeded(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleGetCommandKeysViaAPI(ptr nocapture noundef readonly %cmd, ptr noundef %argv, i32 noundef %argc, ptr noundef %result) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 32
  %0 = load ptr, ptr %module_cmd, align 8
  %1 = load ptr, ptr %0, align 8
  %2 = getelementptr inbounds i8, ptr %ctx, i64 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %1, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 2, ptr %flags.i, align 8
  %3 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %3, 0
  %4 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %4() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %entry
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %5
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %entry
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %6, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %7 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %7, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %call = tail call ptr @getKeysPrepareResult(ptr noundef %result, i32 noundef 256) #32
  %keys_result = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 12
  store ptr %result, ptr %keys_result, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %0, i64 0, i32 1
  %8 = load ptr, ptr %func, align 8
  %call1 = call i32 %8(ptr noundef nonnull %ctx, ptr noundef %argv, i32 noundef %argc) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 2
  %9 = load i32, ptr %numkeys, align 8
  ret i32 %9
}

declare ptr @getKeysPrepareResult(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleGetCommandChannelsViaAPI(ptr nocapture noundef readonly %cmd, ptr noundef %argv, i32 noundef %argc, ptr noundef %result) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 32
  %0 = load ptr, ptr %module_cmd, align 8
  %1 = load ptr, ptr %0, align 8
  %2 = getelementptr inbounds i8, ptr %ctx, i64 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %1, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 256, ptr %flags.i, align 8
  %3 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %3, 0
  %4 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %4() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %entry
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %5
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %entry
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %6, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %7 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %7, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %call = tail call ptr @getKeysPrepareResult(ptr noundef %result, i32 noundef 256) #32
  %keys_result = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 12
  store ptr %result, ptr %keys_result, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %0, i64 0, i32 1
  %8 = load ptr, ptr %func, align 8
  %call1 = call i32 %8(ptr noundef nonnull %ctx, ptr noundef %argv, i32 noundef %argc) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 2
  %9 = load i32, ptr %numkeys, align 8
  ret i32 %9
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_IsKeysPositionRequest(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = lshr i32 %0, 1
  %and.lobit = and i32 %and, 1
  ret i32 %and.lobit
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_KeyAtPosWithFlags(ptr nocapture noundef readonly %ctx, i32 noundef %pos, i32 noundef %flags) #0 {
entry:
  %flags1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags1, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %keys_result = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 12
  %1 = load ptr, ptr %keys_result, align 8
  %tobool2 = icmp eq ptr %1, null
  %cmp = icmp slt i32 %pos, 1
  %or.cond = or i1 %cmp, %tobool2
  br i1 %or.cond, label %return, label %if.end4

if.end4:                                          ; preds = %lor.lhs.false
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %1, i64 0, i32 2
  %2 = load i32, ptr %numkeys, align 8
  %size = getelementptr inbounds %struct.getKeysResult, ptr %1, i64 0, i32 3
  %3 = load i32, ptr %size, align 4
  %cmp6 = icmp eq i32 %2, %3
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end4
  %spec.select = tail call i32 @llvm.smin.i32(i32 %2, i32 8192)
  %add = add nsw i32 %spec.select, %2
  %call = tail call ptr @getKeysPrepareResult(ptr noundef nonnull %1, i32 noundef %add) #32
  %.pre = load i32, ptr %numkeys, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %if.end4
  %4 = phi i32 [ %.pre, %if.then7 ], [ %2, %if.end4 ]
  %keys = getelementptr inbounds %struct.getKeysResult, ptr %1, i64 0, i32 1
  %5 = load ptr, ptr %keys, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.keyReference, ptr %5, i64 %idxprom
  store i32 %pos, ptr %arrayidx, align 4
  %conv = sext i32 %flags to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %if.end12
  %indvars.iv.i = phi i64 [ 0, %if.end12 ], [ %indvars.iv.next.i, %for.inc.i ]
  %out.06.i = phi i64 [ 0, %if.end12 ], [ %out.1.i, %for.inc.i ]
  %arrayidx7.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 0
  %6 = load i64, ptr %arrayidx7.i, align 16
  %and.i = and i64 %6, %conv
  %tobool8.not.i = icmp eq i64 %and.i, 0
  br i1 %tobool8.not.i, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %arrayidx12.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 1
  %7 = load i64, ptr %arrayidx12.i, align 8
  %or.i = or i64 %7, %out.06.i
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %for.body.i
  %out.1.i = phi i64 [ %or.i, %if.then.i ], [ %out.06.i, %for.body.i ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i, 11
  br i1 %exitcond.i, label %moduleConvertKeySpecsFlags.exit, label %for.body.i, !llvm.loop !13

moduleConvertKeySpecsFlags.exit:                  ; preds = %for.inc.i
  %conv16 = trunc i64 %out.1.i to i32
  %8 = load ptr, ptr %keys, align 8
  %9 = load i32, ptr %numkeys, align 8
  %idxprom19 = sext i32 %9 to i64
  %flags21 = getelementptr inbounds %struct.keyReference, ptr %8, i64 %idxprom19, i32 1
  store i32 %conv16, ptr %flags21, align 4
  %10 = load i32, ptr %numkeys, align 8
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %numkeys, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %moduleConvertKeySpecsFlags.exit
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_KeyAtPos(ptr nocapture noundef readonly %ctx, i32 noundef %pos) #0 {
entry:
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %entry
  %indvars.iv.i = phi i64 [ 0, %entry ], [ %indvars.iv.next.i, %for.inc.i ]
  %out.06.i = phi i64 [ 0, %entry ], [ %out.1.i, %for.inc.i ]
  %0 = lshr i64 4013, %indvars.iv.i
  %1 = and i64 %0, 1
  %tobool8.not.i.not = icmp eq i64 %1, 0
  br i1 %tobool8.not.i.not, label %if.then.i, label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  %arrayidx12.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 0
  %2 = load i64, ptr %arrayidx12.i, align 16
  %or.i = or i64 %2, %out.06.i
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %for.body.i
  %out.1.i = phi i64 [ %or.i, %if.then.i ], [ %out.06.i, %for.body.i ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i, 11
  br i1 %exitcond.i, label %moduleConvertKeySpecsFlags.exit, label %for.body.i, !llvm.loop !13

moduleConvertKeySpecsFlags.exit:                  ; preds = %for.inc.i
  %flags1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %3 = load i32, ptr %flags1.i, align 8
  %and.i1 = and i32 %3, 2
  %tobool.not.i = icmp eq i32 %and.i1, 0
  br i1 %tobool.not.i, label %RM_KeyAtPosWithFlags.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %moduleConvertKeySpecsFlags.exit
  %keys_result.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 12
  %4 = load ptr, ptr %keys_result.i, align 8
  %tobool2.i = icmp eq ptr %4, null
  %cmp.i = icmp slt i32 %pos, 1
  %or.cond.i = or i1 %cmp.i, %tobool2.i
  br i1 %or.cond.i, label %RM_KeyAtPosWithFlags.exit, label %if.end4.i

if.end4.i:                                        ; preds = %lor.lhs.false.i
  %numkeys.i = getelementptr inbounds %struct.getKeysResult, ptr %4, i64 0, i32 2
  %5 = load i32, ptr %numkeys.i, align 8
  %size.i = getelementptr inbounds %struct.getKeysResult, ptr %4, i64 0, i32 3
  %6 = load i32, ptr %size.i, align 4
  %cmp6.i = icmp eq i32 %5, %6
  br i1 %cmp6.i, label %if.then7.i, label %if.end12.i

if.then7.i:                                       ; preds = %if.end4.i
  %spec.select.i = tail call i32 @llvm.smin.i32(i32 %5, i32 8192)
  %add.i = add nsw i32 %spec.select.i, %5
  %call.i = tail call ptr @getKeysPrepareResult(ptr noundef nonnull %4, i32 noundef %add.i) #32
  %.pre.i = load i32, ptr %numkeys.i, align 8
  br label %if.end12.i

if.end12.i:                                       ; preds = %if.then7.i, %if.end4.i
  %7 = phi i32 [ %.pre.i, %if.then7.i ], [ %5, %if.end4.i ]
  %keys.i = getelementptr inbounds %struct.getKeysResult, ptr %4, i64 0, i32 1
  %8 = load ptr, ptr %keys.i, align 8
  %idxprom.i = sext i32 %7 to i64
  %arrayidx.i = getelementptr inbounds %struct.keyReference, ptr %8, i64 %idxprom.i
  store i32 %pos, ptr %arrayidx.i, align 4
  %sext = shl i64 %out.1.i, 32
  %conv.i = ashr exact i64 %sext, 32
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %if.end12.i
  %indvars.iv.i.i = phi i64 [ 0, %if.end12.i ], [ %indvars.iv.next.i.i, %for.inc.i.i ]
  %out.06.i.i = phi i64 [ 0, %if.end12.i ], [ %out.1.i.i, %for.inc.i.i ]
  %arrayidx7.i.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i.i, i64 0
  %9 = load i64, ptr %arrayidx7.i.i, align 16
  %and.i.i = and i64 %9, %conv.i
  %tobool8.not.i.i = icmp eq i64 %and.i.i, 0
  br i1 %tobool8.not.i.i, label %for.inc.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %arrayidx12.i.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i.i, i64 1
  %10 = load i64, ptr %arrayidx12.i.i, align 8
  %or.i.i = or i64 %10, %out.06.i.i
  br label %for.inc.i.i

for.inc.i.i:                                      ; preds = %if.then.i.i, %for.body.i.i
  %out.1.i.i = phi i64 [ %or.i.i, %if.then.i.i ], [ %out.06.i.i, %for.body.i.i ]
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.i.i = icmp eq i64 %indvars.iv.next.i.i, 11
  br i1 %exitcond.i.i, label %moduleConvertKeySpecsFlags.exit.i, label %for.body.i.i, !llvm.loop !13

moduleConvertKeySpecsFlags.exit.i:                ; preds = %for.inc.i.i
  %conv16.i = trunc i64 %out.1.i.i to i32
  %11 = load ptr, ptr %keys.i, align 8
  %12 = load i32, ptr %numkeys.i, align 8
  %idxprom19.i = sext i32 %12 to i64
  %flags21.i = getelementptr inbounds %struct.keyReference, ptr %11, i64 %idxprom19.i, i32 1
  store i32 %conv16.i, ptr %flags21.i, align 4
  %13 = load i32, ptr %numkeys.i, align 8
  %inc.i = add nsw i32 %13, 1
  store i32 %inc.i, ptr %numkeys.i, align 8
  br label %RM_KeyAtPosWithFlags.exit

RM_KeyAtPosWithFlags.exit:                        ; preds = %moduleConvertKeySpecsFlags.exit, %lor.lhs.false.i, %moduleConvertKeySpecsFlags.exit.i
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_IsChannelsPositionRequest(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = lshr i32 %0, 8
  %and.lobit = and i32 %and, 1
  ret i32 %and.lobit
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ChannelAtPosWithFlags(ptr nocapture noundef readonly %ctx, i32 noundef %pos, i32 noundef %flags) #0 {
entry:
  %flags1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags1, align 8
  %and = and i32 %0, 256
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %keys_result = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 12
  %1 = load ptr, ptr %keys_result, align 8
  %tobool2 = icmp eq ptr %1, null
  %cmp = icmp slt i32 %pos, 1
  %or.cond = or i1 %cmp, %tobool2
  br i1 %or.cond, label %return, label %if.end4

if.end4:                                          ; preds = %lor.lhs.false
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %1, i64 0, i32 2
  %2 = load i32, ptr %numkeys, align 8
  %size = getelementptr inbounds %struct.getKeysResult, ptr %1, i64 0, i32 3
  %3 = load i32, ptr %size, align 4
  %cmp6 = icmp eq i32 %2, %3
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end4
  %spec.select = tail call i32 @llvm.smin.i32(i32 %2, i32 8192)
  %add = add nsw i32 %spec.select, %2
  %call = tail call ptr @getKeysPrepareResult(ptr noundef nonnull %1, i32 noundef %add) #32
  %.pre = load i32, ptr %numkeys, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %if.end4
  %4 = phi i32 [ %.pre, %if.then7 ], [ %2, %if.end4 ]
  %and13 = shl i32 %flags, 10
  %new_flags.1 = and i32 %and13, 12288
  %and28 = shl i32 %flags, 13
  %5 = and i32 %and28, 16384
  %new_flags.2 = or disjoint i32 %new_flags.1, %5
  %6 = shl i32 %flags, 11
  %7 = and i32 %6, 2048
  %new_flags.3 = or disjoint i32 %new_flags.2, %7
  %keys = getelementptr inbounds %struct.getKeysResult, ptr %1, i64 0, i32 1
  %8 = load ptr, ptr %keys, align 8
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.keyReference, ptr %8, i64 %idxprom
  store i32 %pos, ptr %arrayidx, align 4
  %9 = load ptr, ptr %keys, align 8
  %10 = load i32, ptr %numkeys, align 8
  %idxprom47 = sext i32 %10 to i64
  %flags49 = getelementptr inbounds %struct.keyReference, ptr %9, i64 %idxprom47, i32 1
  store i32 %new_flags.3, ptr %flags49, align 4
  %11 = load i32, ptr %numkeys, align 8
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %numkeys, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end12
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @isCommandNameValid(ptr noundef readonly %name) local_unnamed_addr #7 {
entry:
  %call = tail call ptr @strpbrk(ptr noundef %name, ptr noundef nonnull @.str.3) #36
  %tobool.not = icmp eq ptr %call, null
  %. = zext i1 %tobool.not to i32
  ret i32 %.
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strpbrk(ptr noundef, ptr nocapture noundef) local_unnamed_addr #8

; Function Attrs: nounwind uwtable
define dso_local i64 @commandFlagsFromString(ptr noundef %s) local_unnamed_addr #0 {
entry:
  %count = alloca i32, align 4
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %s) #36
  %call1 = call ptr @sdssplitlen(ptr noundef %s, i64 noundef %call, ptr noundef nonnull @.str.4, i32 noundef 1, ptr noundef nonnull %count) #32
  %0 = load i32, ptr %count, align 4
  %cmp44 = icmp sgt i32 %0, 0
  br i1 %cmp44, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext nneg i32 %0 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %flags.045 = phi i64 [ 0, %for.body.preheader ], [ %flags.1, %for.inc ]
  %arrayidx = getelementptr inbounds ptr, ptr %call1, i64 %indvars.iv
  %1 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.5) #36
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %or = or i64 %flags.045, 1
  br label %for.inc

if.else:                                          ; preds = %for.body
  %call3 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.6) #36
  %tobool4.not = icmp eq i32 %call3, 0
  br i1 %tobool4.not, label %if.then5, label %if.else7

if.then5:                                         ; preds = %if.else
  %or6 = or i64 %flags.045, 2
  br label %for.inc

if.else7:                                         ; preds = %if.else
  %call8 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.7) #36
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %if.then10, label %if.else12

if.then10:                                        ; preds = %if.else7
  %or11 = or i64 %flags.045, 16
  br label %for.inc

if.else12:                                        ; preds = %if.else7
  %call13 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.8) #36
  %tobool14.not = icmp eq i32 %call13, 0
  br i1 %tobool14.not, label %if.then15, label %if.else17

if.then15:                                        ; preds = %if.else12
  %or16 = or i64 %flags.045, 4
  br label %for.inc

if.else17:                                        ; preds = %if.else12
  %call18 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.9) #36
  %tobool19.not = icmp eq i32 %call18, 0
  br i1 %tobool19.not, label %if.then20, label %if.else22

if.then20:                                        ; preds = %if.else17
  %or21 = or i64 %flags.045, 64
  br label %for.inc

if.else22:                                        ; preds = %if.else17
  %call23 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.10) #36
  %tobool24.not = icmp eq i32 %call23, 0
  br i1 %tobool24.not, label %if.then25, label %if.else27

if.then25:                                        ; preds = %if.else22
  %or26 = or i64 %flags.045, 512
  br label %for.inc

if.else27:                                        ; preds = %if.else22
  %call28 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.11) #36
  %tobool29.not = icmp eq i32 %call28, 0
  br i1 %tobool29.not, label %if.then30, label %if.else32

if.then30:                                        ; preds = %if.else27
  %or31 = or i64 %flags.045, 32
  br label %for.inc

if.else32:                                        ; preds = %if.else27
  %call33 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.12) #36
  %tobool34.not = icmp eq i32 %call33, 0
  br i1 %tobool34.not, label %for.inc, label %if.else36

if.else36:                                        ; preds = %if.else32
  %call37 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.13) #36
  %tobool38.not = icmp eq i32 %call37, 0
  br i1 %tobool38.not, label %if.then39, label %if.else41

if.then39:                                        ; preds = %if.else36
  %or40 = or i64 %flags.045, 256
  br label %for.inc

if.else41:                                        ; preds = %if.else36
  %call42 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.14) #36
  %tobool43.not = icmp eq i32 %call42, 0
  br i1 %tobool43.not, label %if.then44, label %if.else46

if.then44:                                        ; preds = %if.else41
  %or45 = or i64 %flags.045, 1024
  br label %for.inc

if.else46:                                        ; preds = %if.else41
  %call47 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.15) #36
  %tobool48.not = icmp eq i32 %call47, 0
  br i1 %tobool48.not, label %if.then49, label %if.else51

if.then49:                                        ; preds = %if.else46
  %or50 = or i64 %flags.045, 2048
  br label %for.inc

if.else51:                                        ; preds = %if.else46
  %call52 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.16) #36
  %tobool53.not = icmp eq i32 %call52, 0
  br i1 %tobool53.not, label %if.then54, label %if.else56

if.then54:                                        ; preds = %if.else51
  %or55 = or i64 %flags.045, 4096
  br label %for.inc

if.else56:                                        ; preds = %if.else51
  %call57 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.17) #36
  %tobool58.not = icmp eq i32 %call57, 0
  br i1 %tobool58.not, label %if.then59, label %if.else61

if.then59:                                        ; preds = %if.else56
  %or60 = or i64 %flags.045, 16384
  br label %for.inc

if.else61:                                        ; preds = %if.else56
  %call62 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.18) #36
  %tobool63.not = icmp eq i32 %call62, 0
  br i1 %tobool63.not, label %if.then64, label %if.else66

if.then64:                                        ; preds = %if.else61
  %or65 = or i64 %flags.045, 32768
  br label %for.inc

if.else66:                                        ; preds = %if.else61
  %call67 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.19) #36
  %tobool68.not = icmp eq i32 %call67, 0
  br i1 %tobool68.not, label %if.then69, label %if.else71

if.then69:                                        ; preds = %if.else66
  %or70 = or i64 %flags.045, 65536
  br label %for.inc

if.else71:                                        ; preds = %if.else66
  %call72 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.20) #36
  %tobool73.not = icmp eq i32 %call72, 0
  br i1 %tobool73.not, label %if.then74, label %if.else76

if.then74:                                        ; preds = %if.else71
  %or75 = or i64 %flags.045, 2097152
  br label %for.inc

if.else76:                                        ; preds = %if.else71
  %call77 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.21) #36
  %tobool78.not = icmp eq i32 %call77, 0
  br i1 %tobool78.not, label %if.then79, label %if.else81

if.then79:                                        ; preds = %if.else76
  %or80 = or i64 %flags.045, 134217728
  br label %for.inc

if.else81:                                        ; preds = %if.else76
  %call82 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.22) #36
  %tobool83.not = icmp eq i32 %call82, 0
  br i1 %tobool83.not, label %if.then84, label %if.else86

if.then84:                                        ; preds = %if.else81
  %or85 = or i64 %flags.045, 4194304
  br label %for.inc

if.else86:                                        ; preds = %if.else81
  %call87 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.23) #36
  %tobool88.not = icmp eq i32 %call87, 0
  br i1 %tobool88.not, label %if.then89, label %if.else91

if.then89:                                        ; preds = %if.else86
  %or90 = or i64 %flags.045, 524288
  br label %for.inc

if.else91:                                        ; preds = %if.else86
  %call92 = call i32 @strcasecmp(ptr noundef %1, ptr noundef nonnull @.str.24) #36
  %tobool93.not = icmp eq i32 %call92, 0
  br i1 %tobool93.not, label %if.then94, label %for.end.loopexit.split.loop.exit

if.then94:                                        ; preds = %if.else91
  %or95 = or i64 %flags.045, 67108864
  br label %for.inc

for.inc:                                          ; preds = %if.then, %if.then10, %if.then20, %if.then30, %if.then39, %if.then49, %if.then59, %if.then69, %if.then79, %if.then89, %if.then94, %if.then84, %if.then74, %if.then64, %if.then54, %if.then44, %if.else32, %if.then25, %if.then15, %if.then5
  %flags.1 = phi i64 [ %or95, %if.then94 ], [ %or90, %if.then89 ], [ %or85, %if.then84 ], [ %or80, %if.then79 ], [ %or75, %if.then74 ], [ %or70, %if.then69 ], [ %or65, %if.then64 ], [ %or60, %if.then59 ], [ %or55, %if.then54 ], [ %or50, %if.then49 ], [ %or45, %if.then44 ], [ %or40, %if.then39 ], [ %flags.045, %if.else32 ], [ %or31, %if.then30 ], [ %or26, %if.then25 ], [ %or21, %if.then20 ], [ %or16, %if.then15 ], [ %or11, %if.then10 ], [ %or6, %if.then5 ], [ %or, %if.then ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !14

for.end.loopexit.split.loop.exit:                 ; preds = %if.else91
  %2 = trunc i64 %indvars.iv to i32
  br label %for.end

for.end:                                          ; preds = %for.inc, %for.end.loopexit.split.loop.exit, %entry
  %flags.0.lcssa = phi i64 [ 0, %entry ], [ %flags.045, %for.end.loopexit.split.loop.exit ], [ %flags.1, %for.inc ]
  %j.0.lcssa = phi i32 [ 0, %entry ], [ %2, %for.end.loopexit.split.loop.exit ], [ %0, %for.inc ]
  call void @sdsfreesplitres(ptr noundef %call1, i32 noundef %0) #32
  %3 = load i32, ptr %count, align 4
  %cmp116.not = icmp eq i32 %j.0.lcssa, %3
  %flags.0. = select i1 %cmp116.not, i64 %flags.0.lcssa, i64 -1
  ret i64 %flags.0.
}

declare ptr @sdssplitlen(ptr noundef, i64 noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strlen(ptr nocapture noundef) local_unnamed_addr #8

; Function Attrs: mustprogress nofree nounwind willreturn memory(read)
declare i32 @strcasecmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #9

declare void @sdsfreesplitres(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_CreateCommand(ptr nocapture noundef readonly %ctx, ptr noundef %name, ptr noundef %cmdfunc, ptr noundef %strflags, i32 noundef %firstkey, i32 noundef %lastkey, i32 noundef %keystep) #0 {
entry:
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 18
  %1 = load i32, ptr %onload, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1.not = icmp eq ptr %strflags, null
  br i1 %tobool1.not, label %if.end7, label %cond.end

cond.end:                                         ; preds = %if.end
  %call = tail call i64 @commandFlagsFromString(ptr noundef nonnull %strflags)
  %cmp = icmp eq i64 %call, -1
  br i1 %cmp, label %return, label %if.end3

if.end3:                                          ; preds = %cond.end
  %and = and i64 %call, 4194304
  %tobool4 = icmp ne i64 %and, 0
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool5 = icmp ne i32 %2, 0
  %or.cond = select i1 %tobool4, i1 %tobool5, i1 false
  br i1 %or.cond, label %return, label %if.end7

if.end7:                                          ; preds = %if.end, %if.end3
  %cond1723 = phi i64 [ %call, %if.end3 ], [ 0, %if.end ]
  %call.i = tail call ptr @strpbrk(ptr noundef %name, ptr noundef nonnull @.str.3) #36
  %tobool.not.i.not = icmp eq ptr %call.i, null
  br i1 %tobool.not.i.not, label %if.end11, label %return

if.end11:                                         ; preds = %if.end7
  %call12 = tail call ptr @lookupCommandByCString(ptr noundef %name) #32
  %cmp13.not = icmp eq ptr %call12, null
  br i1 %cmp13.not, label %if.end15, label %return

if.end15:                                         ; preds = %if.end11
  %call16 = tail call ptr @sdsnew(ptr noundef %name) #32
  %3 = load ptr, ptr %module, align 8
  %call18 = tail call ptr @sdsdup(ptr noundef %call16) #32
  %call19 = tail call ptr @moduleCreateCommandProxy(ptr noundef %3, ptr noundef %call16, ptr noundef %call18, ptr noundef %cmdfunc, i64 noundef %cond1723, i32 noundef %firstkey, i32 noundef %lastkey, i32 noundef %keystep)
  %tobool20.not = icmp eq ptr %cmdfunc, null
  %cond21 = select i1 %tobool20.not, i32 -2, i32 -1
  %rediscmd = getelementptr inbounds %struct.RedisModuleCommand, ptr %call19, i64 0, i32 2
  %4 = load ptr, ptr %rediscmd, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %4, i64 0, i32 13
  store i32 %cond21, ptr %arity, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call22 = tail call ptr @sdsdup(ptr noundef %call16) #32
  %6 = load ptr, ptr %rediscmd, align 8
  %call24 = tail call i32 @dictAdd(ptr noundef %5, ptr noundef %call22, ptr noundef %6) #32
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %cond.end30, label %cond.false29

cond.false29:                                     ; preds = %if.end15
  tail call void @_serverAssert(ptr noundef nonnull @.str.25, ptr noundef nonnull @.str.2, i32 noundef 1278) #32
  tail call void @abort() #35
  unreachable

cond.end30:                                       ; preds = %if.end15
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 13), align 8
  %call31 = tail call ptr @sdsdup(ptr noundef %call16) #32
  %8 = load ptr, ptr %rediscmd, align 8
  %call33 = tail call i32 @dictAdd(ptr noundef %7, ptr noundef %call31, ptr noundef %8) #32
  %cmp34 = icmp eq i32 %call33, 0
  br i1 %cmp34, label %cond.end44, label %cond.false43

cond.false43:                                     ; preds = %cond.end30
  tail call void @_serverAssert(ptr noundef nonnull @.str.26, ptr noundef nonnull @.str.2, i32 noundef 1279) #32
  tail call void @abort() #35
  unreachable

cond.end44:                                       ; preds = %cond.end30
  %call45 = tail call i64 @ACLGetCommandID(ptr noundef %call16) #32
  %conv46 = trunc i64 %call45 to i32
  %9 = load ptr, ptr %rediscmd, align 8
  %id = getelementptr inbounds %struct.redisCommand, ptr %9, i64 0, i32 26
  store i32 %conv46, ptr %id, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.end7, %if.end3, %cond.end, %entry, %cond.end44
  %retval.0 = phi i32 [ 0, %cond.end44 ], [ 1, %entry ], [ 1, %cond.end ], [ 1, %if.end3 ], [ 1, %if.end7 ], [ 1, %if.end11 ]
  ret i32 %retval.0
}

declare ptr @lookupCommandByCString(ptr noundef) local_unnamed_addr #1

declare ptr @sdsnew(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @moduleCreateCommandProxy(ptr noundef %module, ptr noundef %declared_name, ptr noundef %fullname, ptr noundef %cmdfunc, i64 noundef %flags, i32 noundef %firstkey, i32 noundef %lastkey, i32 noundef %keystep) local_unnamed_addr #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(24) ptr @zcalloc(i64 noundef 24) #33
  store ptr %module, ptr %call, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %call, i64 0, i32 1
  store ptr %cmdfunc, ptr %func, align 8
  %call2 = tail call noalias dereferenceable_or_null(312) ptr @zcalloc(i64 noundef 312) #33
  %rediscmd3 = getelementptr inbounds %struct.RedisModuleCommand, ptr %call, i64 0, i32 2
  store ptr %call2, ptr %rediscmd3, align 8
  store ptr %declared_name, ptr %call2, align 8
  %fullname7 = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 27
  store ptr %fullname, ptr %fullname7, align 8
  %group = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 7
  store i32 17, ptr %group, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 12
  store ptr @RedisModuleCommandDispatcher, ptr %proc, align 8
  %or = or i64 %flags, 8
  %flags11 = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 14
  store i64 %or, ptr %flags11, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 32
  store ptr %call, ptr %module_cmd, align 8
  %cmp.not = icmp eq i32 %firstkey, 0
  %key_specs_num49 = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 17
  br i1 %cmp.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %key_specs_num49, align 8
  %call14 = tail call noalias dereferenceable_or_null(56) ptr @zcalloc(i64 noundef 56) #33
  %0 = load ptr, ptr %rediscmd3, align 8
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 16
  store ptr %call14, ptr %key_specs, align 8
  %1 = load ptr, ptr %rediscmd3, align 8
  %key_specs17 = getelementptr inbounds %struct.redisCommand, ptr %1, i64 0, i32 16
  %2 = load ptr, ptr %key_specs17, align 8
  %flags18 = getelementptr inbounds %struct.keySpec, ptr %2, i64 0, i32 1
  store i64 50, ptr %flags18, align 8
  %and = and i64 %flags, 2097152
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then19

if.then19:                                        ; preds = %if.then
  %3 = load ptr, ptr %rediscmd3, align 8
  %key_specs21 = getelementptr inbounds %struct.redisCommand, ptr %3, i64 0, i32 16
  %4 = load ptr, ptr %key_specs21, align 8
  %flags23 = getelementptr inbounds %struct.keySpec, ptr %4, i64 0, i32 1
  %5 = load i64, ptr %flags23, align 8
  %or24 = or i64 %5, 1024
  store i64 %or24, ptr %flags23, align 8
  br label %if.end

if.end:                                           ; preds = %if.then19, %if.then
  %6 = load ptr, ptr %rediscmd3, align 8
  %key_specs26 = getelementptr inbounds %struct.redisCommand, ptr %6, i64 0, i32 16
  %7 = load ptr, ptr %key_specs26, align 8
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %7, i64 0, i32 2
  store i32 2, ptr %begin_search_type, align 8
  %8 = load ptr, ptr %rediscmd3, align 8
  %key_specs29 = getelementptr inbounds %struct.redisCommand, ptr %8, i64 0, i32 16
  %9 = load ptr, ptr %key_specs29, align 8
  %bs = getelementptr inbounds %struct.keySpec, ptr %9, i64 0, i32 3
  store i32 %firstkey, ptr %bs, align 8
  %10 = load ptr, ptr %rediscmd3, align 8
  %key_specs32 = getelementptr inbounds %struct.redisCommand, ptr %10, i64 0, i32 16
  %11 = load ptr, ptr %key_specs32, align 8
  %find_keys_type = getelementptr inbounds %struct.keySpec, ptr %11, i64 0, i32 4
  store i32 2, ptr %find_keys_type, align 8
  %cmp34 = icmp slt i32 %lastkey, 0
  %sub = select i1 %cmp34, i32 0, i32 %firstkey
  %cond = sub nsw i32 %lastkey, %sub
  %12 = load ptr, ptr %rediscmd3, align 8
  %key_specs36 = getelementptr inbounds %struct.redisCommand, ptr %12, i64 0, i32 16
  %13 = load ptr, ptr %key_specs36, align 8
  %fk = getelementptr inbounds %struct.keySpec, ptr %13, i64 0, i32 5
  store i32 %cond, ptr %fk, align 4
  %14 = load ptr, ptr %rediscmd3, align 8
  %key_specs40 = getelementptr inbounds %struct.redisCommand, ptr %14, i64 0, i32 16
  %15 = load ptr, ptr %key_specs40, align 8
  %keystep43 = getelementptr inbounds %struct.keySpec, ptr %15, i64 0, i32 5, i32 0, i32 1
  store i32 %keystep, ptr %keystep43, align 4
  %16 = load ptr, ptr %rediscmd3, align 8
  %key_specs45 = getelementptr inbounds %struct.redisCommand, ptr %16, i64 0, i32 16
  %17 = load ptr, ptr %key_specs45, align 8
  %limit = getelementptr inbounds %struct.keySpec, ptr %17, i64 0, i32 5, i32 0, i32 2
  store i32 0, ptr %limit, align 4
  %.pre = load ptr, ptr %rediscmd3, align 8
  br label %if.end52

if.else:                                          ; preds = %entry
  store i32 0, ptr %key_specs_num49, align 8
  %key_specs51 = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 16
  store ptr null, ptr %key_specs51, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.else, %if.end
  %18 = phi ptr [ %call2, %if.else ], [ %.pre, %if.end ]
  tail call void @populateCommandLegacyRangeSpec(ptr noundef %18) #32
  %19 = load ptr, ptr %rediscmd3, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %19, i64 0, i32 22
  store i64 0, ptr %microseconds, align 8
  %20 = load ptr, ptr %rediscmd3, align 8
  %calls = getelementptr inbounds %struct.redisCommand, ptr %20, i64 0, i32 23
  store i64 0, ptr %calls, align 8
  %21 = load ptr, ptr %rediscmd3, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %21, i64 0, i32 24
  store i64 0, ptr %rejected_calls, align 8
  %22 = load ptr, ptr %rediscmd3, align 8
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %22, i64 0, i32 25
  store i64 0, ptr %failed_calls, align 8
  ret ptr %call
}

declare ptr @sdsdup(ptr noundef) local_unnamed_addr #1

declare i32 @dictAdd(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare i64 @ACLGetCommandID(ptr noundef) local_unnamed_addr #1

; Function Attrs: allocsize(0)
declare noalias ptr @zcalloc(i64 noundef) local_unnamed_addr #2

declare void @populateCommandLegacyRangeSpec(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetCommand(ptr nocapture noundef readonly %ctx, ptr noundef %name) #0 {
entry:
  %call = tail call ptr @lookupCommandByCString(ptr noundef %name) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %flags = getelementptr inbounds %struct.redisCommand, ptr %call, i64 0, i32 14
  %0 = load i64, ptr %flags, align 8
  %and = and i64 %0, 8
  %tobool1.not = icmp eq i64 %and, 0
  br i1 %tobool1.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %call, i64 0, i32 32
  %1 = load ptr, ptr %module_cmd, align 8
  %2 = load ptr, ptr %1, align 8
  %module2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %3 = load ptr, ptr %module2, align 8
  %cmp.not = icmp eq ptr %2, %3
  %. = select i1 %cmp.not, ptr %1, ptr null
  br label %return

return:                                           ; preds = %if.end, %entry, %lor.lhs.false
  %retval.0 = phi ptr [ null, %lor.lhs.false ], [ null, %entry ], [ %., %if.end ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_CreateSubcommand(ptr nocapture noundef readonly %parent, ptr noundef %name, ptr noundef %cmdfunc, ptr noundef %strflags, i32 noundef %firstkey, i32 noundef %lastkey, i32 noundef %keystep) #0 {
entry:
  %0 = load ptr, ptr %parent, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 18
  %1 = load i32, ptr %onload, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1.not = icmp eq ptr %strflags, null
  br i1 %tobool1.not, label %if.end7, label %cond.end

cond.end:                                         ; preds = %if.end
  %call = tail call i64 @commandFlagsFromString(ptr noundef nonnull %strflags)
  %cmp = icmp eq i64 %call, -1
  br i1 %cmp, label %return, label %if.end3

if.end3:                                          ; preds = %cond.end
  %and = and i64 %call, 4194304
  %tobool4 = icmp ne i64 %and, 0
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool5 = icmp ne i32 %2, 0
  %or.cond = select i1 %tobool4, i1 %tobool5, i1 false
  br i1 %or.cond, label %return, label %if.end7

if.end7:                                          ; preds = %if.end, %if.end3
  %cond1925 = phi i64 [ %call, %if.end3 ], [ 0, %if.end ]
  %rediscmd = getelementptr inbounds %struct.RedisModuleCommand, ptr %parent, i64 0, i32 2
  %3 = load ptr, ptr %rediscmd, align 8
  %parent8 = getelementptr inbounds %struct.redisCommand, ptr %3, i64 0, i32 31
  %4 = load ptr, ptr %parent8, align 8
  %tobool9.not = icmp eq ptr %4, null
  br i1 %tobool9.not, label %if.end11, label %return

if.end11:                                         ; preds = %if.end7
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %3, i64 0, i32 32
  %5 = load ptr, ptr %module_cmd, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %5, i64 0, i32 1
  %6 = load ptr, ptr %func, align 8
  %tobool12.not = icmp eq ptr %6, null
  br i1 %tobool12.not, label %if.end14, label %return

if.end14:                                         ; preds = %if.end11
  %call.i = tail call ptr @strpbrk(ptr noundef %name, ptr noundef nonnull @.str.3) #36
  %tobool.not.i.not = icmp eq ptr %call.i, null
  br i1 %tobool.not.i.not, label %if.end18, label %return

if.end18:                                         ; preds = %if.end14
  %call19 = tail call ptr @sdsnew(ptr noundef %name) #32
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %3, i64 0, i32 30
  %7 = load ptr, ptr %subcommands_dict, align 8
  %tobool20.not = icmp eq ptr %7, null
  br i1 %tobool20.not, label %if.end25, label %land.lhs.true21

land.lhs.true21:                                  ; preds = %if.end18
  %call22 = tail call ptr @lookupSubcommand(ptr noundef nonnull %3, ptr noundef %call19) #32
  %cmp23.not = icmp eq ptr %call22, null
  br i1 %cmp23.not, label %if.end25, label %if.then24

if.then24:                                        ; preds = %land.lhs.true21
  tail call void @sdsfree(ptr noundef %call19) #32
  br label %return

if.end25:                                         ; preds = %land.lhs.true21, %if.end18
  %fullname26 = getelementptr inbounds %struct.redisCommand, ptr %3, i64 0, i32 27
  %8 = load ptr, ptr %fullname26, align 8
  %call27 = tail call ptr @catSubCommandFullname(ptr noundef %8, ptr noundef %name) #32
  %9 = load ptr, ptr %parent, align 8
  %call29 = tail call ptr @moduleCreateCommandProxy(ptr noundef %9, ptr noundef %call19, ptr noundef %call27, ptr noundef %cmdfunc, i64 noundef %cond1925, i32 noundef %firstkey, i32 noundef %lastkey, i32 noundef %keystep)
  %rediscmd30 = getelementptr inbounds %struct.RedisModuleCommand, ptr %call29, i64 0, i32 2
  %10 = load ptr, ptr %rediscmd30, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %10, i64 0, i32 13
  store i32 -2, ptr %arity, align 8
  %11 = load ptr, ptr %rediscmd30, align 8
  tail call void @commandAddSubcommand(ptr noundef nonnull %3, ptr noundef %11, ptr noundef %name) #32
  br label %return

return:                                           ; preds = %if.end14, %if.end11, %if.end7, %if.end3, %cond.end, %entry, %if.end25, %if.then24
  %retval.0 = phi i32 [ 1, %if.then24 ], [ 0, %if.end25 ], [ 1, %entry ], [ 1, %cond.end ], [ 1, %if.end3 ], [ 1, %if.end7 ], [ 1, %if.end11 ], [ 1, %if.end14 ]
  ret i32 %retval.0
}

declare ptr @lookupSubcommand(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @sdsfree(ptr noundef) #1

declare ptr @catSubCommandFullname(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @commandAddSubcommand(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @populateArgsStructure(ptr noundef %args) local_unnamed_addr #0 {
entry:
  %tobool.not = icmp eq ptr %args, null
  br i1 %tobool.not, label %return, label %while.cond.preheader

while.cond.preheader:                             ; preds = %entry
  %0 = load ptr, ptr %args, align 8
  %tobool1.not8 = icmp eq ptr %0, null
  br i1 %tobool1.not8, label %return, label %while.body

while.body:                                       ; preds = %while.cond.preheader, %cond.end
  %count.010 = phi i32 [ %inc, %cond.end ], [ 0, %while.cond.preheader ]
  %args.addr.09 = phi ptr [ %incdec.ptr, %cond.end ], [ %args, %while.cond.preheader ]
  %cmp.not = icmp eq i32 %count.010, 2147483647
  br i1 %cmp.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %while.body
  tail call void @_serverAssert(ptr noundef nonnull @.str.27, ptr noundef nonnull @.str.2, i32 noundef 1446) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %while.body
  %subargs = getelementptr inbounds %struct.redisCommandArg, ptr %args.addr.09, i64 0, i32 9
  %1 = load ptr, ptr %subargs, align 8
  %call = tail call i32 @populateArgsStructure(ptr noundef %1)
  %num_args = getelementptr inbounds %struct.redisCommandArg, ptr %args.addr.09, i64 0, i32 8
  store i32 %call, ptr %num_args, align 8
  %inc = add nuw nsw i32 %count.010, 1
  %incdec.ptr = getelementptr inbounds %struct.redisCommandArg, ptr %args.addr.09, i64 1
  %2 = load ptr, ptr %incdec.ptr, align 8
  %tobool1.not = icmp eq ptr %2, null
  br i1 %tobool1.not, label %return, label %while.body, !llvm.loop !15

return:                                           ; preds = %cond.end, %while.cond.preheader, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %while.cond.preheader ], [ %inc, %cond.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_AddACLCategory(ptr nocapture noundef readonly %ctx, ptr noundef %name) #0 {
entry:
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 18
  %1 = load i32, ptr %onload, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i8, ptr %name, align 1
  %.fr1921.i = freeze i8 %2
  %cmp.i = icmp eq i8 %.fr1921.i, 0
  br i1 %cmp.i, label %if.then2, label %for.body.i

for.body.i:                                       ; preds = %if.end, %for.inc.i
  %.fr1924.i = phi i8 [ %.fr19.i, %for.inc.i ], [ %.fr1921.i, %if.end ]
  %i.023.i = phi i64 [ %inc.i, %for.inc.i ], [ 0, %if.end ]
  %3 = and i8 %.fr1924.i, -33
  %4 = add i8 %3, -65
  %or.cond18.i = icmp ult i8 %4, 26
  %5 = add i8 %.fr1924.i, -48
  %or.cond2.i = icmp ult i8 %5, 10
  %or.cond.i = or i1 %or.cond2.i, %or.cond18.i
  br i1 %or.cond.i, label %for.inc.i, label %switch.early.test.i

switch.early.test.i:                              ; preds = %for.body.i
  switch i8 %.fr1924.i, label %do.body.i [
    i8 95, label %for.inc.i
    i8 45, label %for.inc.i
  ]

do.body.i:                                        ; preds = %switch.early.test.i
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp38.i = icmp sgt i32 %6, 3
  br i1 %cmp38.i, label %if.then2, label %if.end41.i

if.end41.i:                                       ; preds = %do.body.i
  %conv3.le.i = sext i8 %.fr1924.i to i32
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.146, i32 noundef %conv3.le.i, ptr noundef nonnull %name) #32
  br label %if.then2

for.inc.i:                                        ; preds = %switch.early.test.i, %switch.early.test.i, %for.body.i
  %inc.i = add i64 %i.023.i, 1
  %arrayidx2.i = getelementptr inbounds i8, ptr %name, i64 %inc.i
  %7 = load i8, ptr %arrayidx2.i, align 1
  %.fr19.i = freeze i8 %7
  %cmp4.not.i = icmp eq i8 %.fr19.i, 0
  br i1 %cmp4.not.i, label %if.end4, label %for.body.i, !llvm.loop !16

if.then2:                                         ; preds = %if.end, %do.body.i, %if.end41.i
  %call3 = tail call ptr @__errno_location() #37
  store i32 22, ptr %call3, align 4
  br label %return

if.end4:                                          ; preds = %for.inc.i
  %call5 = tail call i64 @ACLGetCommandCategoryFlagByName(ptr noundef nonnull %name) #32
  %tobool6.not = icmp eq i64 %call5, 0
  br i1 %tobool6.not, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.end4
  %call8 = tail call ptr @__errno_location() #37
  store i32 16, ptr %call8, align 4
  br label %return

if.end9:                                          ; preds = %if.end4
  %call10 = tail call i32 @ACLAddCommandCategory(ptr noundef nonnull %name, i64 noundef 0) #32
  %tobool11.not = icmp eq i32 %call10, 0
  br i1 %tobool11.not, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.end9
  %8 = load ptr, ptr %module, align 8
  %num_acl_categories_added = getelementptr inbounds %struct.RedisModule, ptr %8, i64 0, i32 19
  %9 = load i64, ptr %num_acl_categories_added, align 8
  %inc = add i64 %9, 1
  store i64 %inc, ptr %num_acl_categories_added, align 8
  br label %return

if.else:                                          ; preds = %if.end9
  %call14 = tail call ptr @__errno_location() #37
  store i32 12, ptr %call14, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then12, %if.then7, %if.then2, %if.then
  %retval.0 = phi i32 [ 1, %if.then2 ], [ 1, %if.then7 ], [ 0, %if.then12 ], [ 1, %if.else ], [ 1, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare ptr @__errno_location() local_unnamed_addr #10

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleVerifyResourceName(ptr noundef %name) local_unnamed_addr #0 {
entry:
  %0 = load i8, ptr %name, align 1
  %.fr1921 = freeze i8 %0
  %cmp = icmp eq i8 %.fr1921, 0
  br i1 %cmp, label %return, label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %.fr1924 = phi i8 [ %.fr19, %for.inc ], [ %.fr1921, %entry ]
  %i.023 = phi i64 [ %inc, %for.inc ], [ 0, %entry ]
  %1 = and i8 %.fr1924, -33
  %2 = add i8 %1, -65
  %or.cond18 = icmp ult i8 %2, 26
  %3 = add i8 %.fr1924, -48
  %or.cond2 = icmp ult i8 %3, 10
  %or.cond = or i1 %or.cond2, %or.cond18
  br i1 %or.cond, label %for.inc, label %switch.early.test

switch.early.test:                                ; preds = %for.body
  switch i8 %.fr1924, label %do.body [
    i8 95, label %for.inc
    i8 45, label %for.inc
  ]

do.body:                                          ; preds = %switch.early.test
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp38 = icmp sgt i32 %4, 3
  br i1 %cmp38, label %return, label %if.end41

if.end41:                                         ; preds = %do.body
  %conv3.le = sext i8 %.fr1924 to i32
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.146, i32 noundef %conv3.le, ptr noundef nonnull %name) #32
  br label %return

for.inc:                                          ; preds = %switch.early.test, %switch.early.test, %for.body
  %inc = add i64 %i.023, 1
  %arrayidx2 = getelementptr inbounds i8, ptr %name, i64 %inc
  %5 = load i8, ptr %arrayidx2, align 1
  %.fr19 = freeze i8 %5
  %cmp4.not = icmp eq i8 %.fr19, 0
  br i1 %cmp4.not, label %return, label %for.body, !llvm.loop !16

return:                                           ; preds = %for.inc, %if.end41, %do.body, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 1, %do.body ], [ 1, %if.end41 ], [ 0, %for.inc ]
  ret i32 %retval.0
}

declare i64 @ACLGetCommandCategoryFlagByName(ptr noundef) local_unnamed_addr #1

declare i32 @ACLAddCommandCategory(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @matchAclCategoryFlag(ptr noundef %flag, ptr nocapture noundef %acl_categories_flags) local_unnamed_addr #0 {
entry:
  %call = tail call i64 @ACLGetCommandCategoryFlagByName(ptr noundef %flag) #32
  %tobool.not = icmp eq i64 %call, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i64, ptr %acl_categories_flags, align 8
  %or = or i64 %0, %call
  store i64 %or, ptr %acl_categories_flags, align 8
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i64 @categoryFlagsFromString(ptr noundef %aclflags) local_unnamed_addr #0 {
entry:
  %count = alloca i32, align 4
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %aclflags) #36
  %call1 = call ptr @sdssplitlen(ptr noundef %aclflags, i64 noundef %call, ptr noundef nonnull @.str.4, i32 noundef 1, ptr noundef nonnull %count) #32
  %0 = load i32, ptr %count, align 4
  %cmp16 = icmp sgt i32 %0, 0
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %acl_categories_flags.017 = phi i64 [ %or.i, %for.inc ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds ptr, ptr %call1, i64 %indvars.iv
  %1 = load ptr, ptr %arrayidx, align 8
  %call.i = call i64 @ACLGetCommandCategoryFlagByName(ptr noundef %1) #32
  %tobool.not.i = icmp eq i64 %call.i, 0
  br i1 %tobool.not.i, label %do.body, label %for.inc

do.body:                                          ; preds = %for.body
  %2 = trunc i64 %indvars.iv to i32
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3 = icmp sgt i32 %3, 3
  br i1 %cmp3, label %for.end, label %if.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.28, ptr noundef %1) #32
  br label %for.end

for.inc:                                          ; preds = %for.body
  %or.i = or i64 %call.i, %acl_categories_flags.017
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %4 = load i32, ptr %count, align 4
  %5 = sext i32 %4 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %5
  br i1 %cmp, label %for.body, label %for.end.loopexit, !llvm.loop !17

for.end.loopexit:                                 ; preds = %for.inc
  %6 = trunc i64 %indvars.iv.next to i32
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry, %if.end, %do.body
  %acl_categories_flags.015 = phi i64 [ %acl_categories_flags.017, %if.end ], [ %acl_categories_flags.017, %do.body ], [ 0, %entry ], [ %or.i, %for.end.loopexit ]
  %j.013 = phi i32 [ %2, %if.end ], [ %2, %do.body ], [ 0, %entry ], [ %6, %for.end.loopexit ]
  %7 = load i32, ptr %count, align 4
  call void @sdsfreesplitres(ptr noundef %call1, i32 noundef %7) #32
  %8 = load i32, ptr %count, align 4
  %cmp6.not = icmp eq i32 %j.013, %8
  %retval.0 = select i1 %cmp6.not, i64 %acl_categories_flags.015, i64 -1
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SetCommandACLCategories(ptr noundef readonly %command, ptr noundef %aclflags) #0 {
entry:
  %tobool.not = icmp eq ptr %command, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load ptr, ptr %command, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %onload = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 18
  %1 = load i32, ptr %onload, align 4
  %tobool4.not = icmp eq i32 %1, 0
  br i1 %tobool4.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false2
  %tobool5.not = icmp eq ptr %aclflags, null
  br i1 %tobool5.not, label %if.end7, label %cond.end

cond.end:                                         ; preds = %if.end
  %call = tail call i64 @categoryFlagsFromString(ptr noundef nonnull %aclflags)
  %cmp = icmp eq i64 %call, -1
  br i1 %cmp, label %return, label %if.end7

if.end7:                                          ; preds = %if.end, %cond.end
  %cond9 = phi i64 [ %call, %cond.end ], [ 0, %if.end ]
  %rediscmd = getelementptr inbounds %struct.RedisModuleCommand, ptr %command, i64 0, i32 2
  %2 = load ptr, ptr %rediscmd, align 8
  %acl_categories = getelementptr inbounds %struct.redisCommand, ptr %2, i64 0, i32 15
  store i64 %cond9, ptr %acl_categories, align 8
  %3 = load ptr, ptr %command, align 8
  %num_commands_with_acl_categories = getelementptr inbounds %struct.RedisModule, ptr %3, i64 0, i32 17
  %4 = load i32, ptr %num_commands_with_acl_categories, align 8
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %num_commands_with_acl_categories, align 8
  br label %return

return:                                           ; preds = %cond.end, %entry, %lor.lhs.false, %lor.lhs.false2, %if.end7
  %retval.0 = phi i32 [ 0, %if.end7 ], [ 1, %lor.lhs.false2 ], [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %cond.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SetCommandInfo(ptr nocapture noundef readonly %command, ptr nocapture noundef readonly %info) #0 {
entry:
  %count87 = alloca i32, align 4
  %0 = load ptr, ptr %info, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %do.body.i, label %if.end3.i

do.body.i:                                        ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp.i = icmp sgt i32 %1, 3
  br i1 %cmp.i, label %if.then, label %if.end.i

if.end.i:                                         ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.524) #32
  br label %if.then

if.end3.i:                                        ; preds = %entry
  %history.i = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %info, i64 0, i32 4
  %2 = load ptr, ptr %history.i, align 8
  %tobool4.not.i = icmp eq ptr %2, null
  br i1 %tobool4.not.i, label %if.end20.i, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %if.end3.i
  %3 = getelementptr i8, ptr %0, i64 8
  %.val.i = load i64, ptr %3, align 8
  %4 = load ptr, ptr %2, align 8
  %tobool7.not66.i = icmp eq ptr %4, null
  br i1 %tobool7.not66.i, label %if.end20.i, label %for.body.i

for.body.i:                                       ; preds = %for.cond.preheader.i, %for.inc.i
  %add.ptr.i68.i = phi ptr [ %add.ptr.i.i, %for.inc.i ], [ %2, %for.cond.preheader.i ]
  %j.067.i = phi i64 [ %inc.i, %for.inc.i ], [ 0, %for.cond.preheader.i ]
  %changes.i = getelementptr inbounds %struct.RedisModuleCommandHistoryEntry, ptr %add.ptr.i68.i, i64 0, i32 1
  %5 = load ptr, ptr %changes.i, align 8
  %tobool11.not.i = icmp eq ptr %5, null
  br i1 %tobool11.not.i, label %do.body13.i, label %for.inc.i

do.body13.i:                                      ; preds = %for.body.i
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp14.i = icmp sgt i32 %6, 3
  br i1 %cmp14.i, label %if.then, label %if.end17.i

if.end17.i:                                       ; preds = %do.body13.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.525, i64 noundef %j.067.i) #32
  br label %if.then

for.inc.i:                                        ; preds = %for.body.i
  %inc.i = add i64 %j.067.i, 1
  %sext.i = shl i64 %inc.i, 32
  %conv.i.i = ashr exact i64 %sext.i, 32
  %mul.i.i = mul i64 %conv.i.i, %.val.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %2, i64 %mul.i.i
  %7 = load ptr, ptr %add.ptr.i.i, align 8
  %tobool7.not.i = icmp eq ptr %7, null
  br i1 %tobool7.not.i, label %if.end20.i, label %for.body.i, !llvm.loop !18

if.end20.i:                                       ; preds = %for.inc.i, %for.cond.preheader.i, %if.end3.i
  %key_specs.i = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %info, i64 0, i32 7
  %8 = load ptr, ptr %key_specs.i, align 8
  %tobool21.not.i = icmp eq ptr %8, null
  br i1 %tobool21.not.i, label %moduleValidateCommandInfo.exit, label %for.cond24.preheader.i

for.cond24.preheader.i:                           ; preds = %if.end20.i
  %9 = getelementptr i8, ptr %0, i64 16
  %.val33.i = load i64, ptr %9, align 8
  %begin_search_type69.i = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %8, i64 0, i32 2
  %10 = load i32, ptr %begin_search_type69.i, align 8
  %tobool28.not70.i = icmp eq i32 %10, 0
  br i1 %tobool28.not70.i, label %moduleValidateCommandInfo.exit, label %for.body29.i

for.body29.i:                                     ; preds = %for.cond24.preheader.i, %for.inc102.i
  %11 = phi i32 [ %23, %for.inc102.i ], [ %10, %for.cond24.preheader.i ]
  %add.ptr.i4072.i = phi ptr [ %add.ptr.i40.i, %for.inc102.i ], [ %8, %for.cond24.preheader.i ]
  %j23.071.i = phi i64 [ %inc103.i, %for.inc102.i ], [ 0, %for.cond24.preheader.i ]
  %exitcond.i = icmp eq i64 %j23.071.i, 2147483647
  br i1 %exitcond.i, label %do.body36.i, label %if.end42.i

do.body36.i:                                      ; preds = %for.body29.i
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp37.i = icmp sgt i32 %12, 3
  br i1 %cmp37.i, label %if.then, label %if.end40.i

if.end40.i:                                       ; preds = %do.body36.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.526) #32
  br label %if.then

if.end42.i:                                       ; preds = %for.body29.i
  %flags.i = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i4072.i, i64 0, i32 1
  %13 = load i64, ptr %flags.i, align 8
  %and.i = and i64 %13, 15
  %14 = tail call i64 @llvm.ctpop.i64(i64 %and.i), !range !19
  %or.cond.not.i = icmp eq i64 %14, 1
  br i1 %or.cond.not.i, label %if.end52.i, label %do.body46.i

do.body46.i:                                      ; preds = %if.end42.i
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp47.i = icmp sgt i32 %15, 3
  br i1 %cmp47.i, label %if.then, label %if.end50.i

if.end50.i:                                       ; preds = %do.body46.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.527, i64 noundef %j23.071.i) #32
  br label %if.then

if.end52.i:                                       ; preds = %if.end42.i
  %and54.i = and i64 %13, 224
  %16 = tail call i64 @llvm.ctpop.i64(i64 %and54.i), !range !20
  %tobool1.not.i46.i = icmp ugt i64 %16, 1
  br i1 %tobool1.not.i46.i, label %do.body62.i, label %if.end68.i

do.body62.i:                                      ; preds = %if.end52.i
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp63.i = icmp sgt i32 %17, 3
  br i1 %cmp63.i, label %if.then, label %if.end66.i

if.end66.i:                                       ; preds = %do.body62.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.528, i64 noundef %j23.071.i) #32
  br label %if.then

if.end68.i:                                       ; preds = %if.end52.i
  switch i32 %11, label %do.body82.i [
    i32 1, label %sw.epilog.i
    i32 2, label %sw.epilog.i
    i32 3, label %sw.bb71.i
  ]

sw.bb71.i:                                        ; preds = %if.end68.i
  %bs.i = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i4072.i, i64 0, i32 3
  %18 = load ptr, ptr %bs.i, align 8
  %cmp72.i = icmp eq ptr %18, null
  br i1 %cmp72.i, label %do.body75.i, label %sw.epilog.i

do.body75.i:                                      ; preds = %sw.bb71.i
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp76.i = icmp sgt i32 %19, 3
  br i1 %cmp76.i, label %if.then, label %if.end79.i

if.end79.i:                                       ; preds = %do.body75.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.529, i64 noundef %j23.071.i) #32
  br label %if.then

do.body82.i:                                      ; preds = %if.end68.i
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp83.i = icmp sgt i32 %20, 3
  br i1 %cmp83.i, label %if.then, label %if.end86.i

if.end86.i:                                       ; preds = %do.body82.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.530, i64 noundef %j23.071.i, i32 noundef %11) #32
  br label %if.then

sw.epilog.i:                                      ; preds = %sw.bb71.i, %if.end68.i, %if.end68.i
  %find_keys_type.i = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i4072.i, i64 0, i32 4
  %21 = load i32, ptr %find_keys_type.i, align 8
  %switch.i = icmp ult i32 %21, 4
  br i1 %switch.i, label %for.inc102.i, label %do.body94.i

do.body94.i:                                      ; preds = %sw.epilog.i
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp95.i = icmp sgt i32 %22, 3
  br i1 %cmp95.i, label %if.then, label %if.end98.i

if.end98.i:                                       ; preds = %do.body94.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.531, i64 noundef %j23.071.i, i32 noundef %21) #32
  br label %if.then

for.inc102.i:                                     ; preds = %sw.epilog.i
  %inc103.i = add nuw nsw i64 %j23.071.i, 1
  %mul.i39.i = mul i64 %inc103.i, %.val33.i
  %add.ptr.i40.i = getelementptr inbounds i8, ptr %8, i64 %mul.i39.i
  %begin_search_type.i = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i40.i, i64 0, i32 2
  %23 = load i32, ptr %begin_search_type.i, align 8
  %tobool28.not.i = icmp eq i32 %23, 0
  br i1 %tobool28.not.i, label %moduleValidateCommandInfo.exit, label %for.body29.i, !llvm.loop !21

moduleValidateCommandInfo.exit:                   ; preds = %for.inc102.i, %if.end20.i, %for.cond24.preheader.i
  %args.i = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %info, i64 0, i32 8
  %24 = load ptr, ptr %args.i, align 8
  %call106.i = tail call fastcc i32 @moduleValidateCommandArgs(ptr noundef %24, ptr noundef nonnull %0), !range !22
  %tobool.not = icmp eq i32 %call106.i, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %if.end98.i, %do.body94.i, %if.end86.i, %do.body82.i, %if.end79.i, %do.body75.i, %if.end66.i, %do.body62.i, %if.end50.i, %do.body46.i, %if.end40.i, %do.body36.i, %if.end17.i, %do.body13.i, %if.end.i, %do.body.i, %moduleValidateCommandInfo.exit
  %call1 = tail call ptr @__errno_location() #37
  store i32 22, ptr %call1, align 4
  br label %return

if.end:                                           ; preds = %moduleValidateCommandInfo.exit
  %rediscmd = getelementptr inbounds %struct.RedisModuleCommand, ptr %command, i64 0, i32 2
  %25 = load ptr, ptr %rediscmd, align 8
  %summary = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 1
  %26 = load ptr, ptr %summary, align 8
  %tobool2.not = icmp eq ptr %26, null
  br i1 %tobool2.not, label %lor.lhs.false, label %if.then21

lor.lhs.false:                                    ; preds = %if.end
  %complexity = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 2
  %27 = load ptr, ptr %complexity, align 8
  %tobool3.not = icmp eq ptr %27, null
  br i1 %tobool3.not, label %lor.lhs.false4, label %if.then21

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %since = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 3
  %28 = load ptr, ptr %since, align 8
  %tobool5.not = icmp eq ptr %28, null
  br i1 %tobool5.not, label %lor.lhs.false6, label %if.then21

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %history = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 8
  %29 = load ptr, ptr %history, align 8
  %tobool7.not = icmp eq ptr %29, null
  br i1 %tobool7.not, label %lor.lhs.false8, label %if.then21

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %tips = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 10
  %30 = load ptr, ptr %tips, align 8
  %tobool9.not = icmp eq ptr %30, null
  br i1 %tobool9.not, label %lor.lhs.false10, label %if.then21

lor.lhs.false10:                                  ; preds = %lor.lhs.false8
  %args = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 21
  %31 = load ptr, ptr %args, align 8
  %tobool11.not = icmp eq ptr %31, null
  br i1 %tobool11.not, label %lor.lhs.false12, label %if.then21

lor.lhs.false12:                                  ; preds = %lor.lhs.false10
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 17
  %32 = load i32, ptr %key_specs_num, align 8
  switch i32 %32, label %if.then21 [
    i32 0, label %if.end23
    i32 1, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %lor.lhs.false12
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 16
  %33 = load ptr, ptr %key_specs, align 8
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %33, i64 0, i32 2
  %34 = load i32, ptr %begin_search_type, align 8
  %cmp16 = icmp eq i32 %34, 2
  br i1 %cmp16, label %land.lhs.true17, label %if.then21

land.lhs.true17:                                  ; preds = %land.lhs.true
  %find_keys_type = getelementptr inbounds %struct.keySpec, ptr %33, i64 0, i32 4
  %35 = load i32, ptr %find_keys_type, align 8
  %cmp20 = icmp eq i32 %35, 2
  br i1 %cmp20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %lor.lhs.false12, %land.lhs.true17, %land.lhs.true, %lor.lhs.false10, %lor.lhs.false8, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false, %if.end
  %call22 = tail call ptr @__errno_location() #37
  store i32 17, ptr %call22, align 4
  br label %return

if.end23:                                         ; preds = %lor.lhs.false12, %land.lhs.true17
  %summary24 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %info, i64 0, i32 1
  %36 = load ptr, ptr %summary24, align 8
  %tobool25.not = icmp eq ptr %36, null
  br i1 %tobool25.not, label %if.end30, label %if.then26

if.then26:                                        ; preds = %if.end23
  %call28 = tail call noalias ptr @zstrdup(ptr noundef nonnull %36) #32
  store ptr %call28, ptr %summary, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then26, %if.end23
  %complexity31 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %info, i64 0, i32 2
  %37 = load ptr, ptr %complexity31, align 8
  %tobool32.not = icmp eq ptr %37, null
  br i1 %tobool32.not, label %if.end37, label %if.then33

if.then33:                                        ; preds = %if.end30
  %call35 = tail call noalias ptr @zstrdup(ptr noundef nonnull %37) #32
  store ptr %call35, ptr %complexity, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then33, %if.end30
  %since38 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %info, i64 0, i32 3
  %38 = load ptr, ptr %since38, align 8
  %tobool39.not = icmp eq ptr %38, null
  br i1 %tobool39.not, label %if.end44, label %if.then40

if.then40:                                        ; preds = %if.end37
  %call42 = tail call noalias ptr @zstrdup(ptr noundef nonnull %38) #32
  store ptr %call42, ptr %since, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then40, %if.end37
  %39 = load ptr, ptr %info, align 8
  %40 = load ptr, ptr %history.i, align 8
  %tobool47.not = icmp eq ptr %40, null
  br i1 %tobool47.not, label %if.end83, label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.end44
  %41 = getelementptr i8, ptr %39, i64 8
  %.val = load i64, ptr %41, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %while.cond.preheader
  %count.0 = phi i64 [ %inc, %while.cond ], [ 0, %while.cond.preheader ]
  %sext = shl i64 %count.0, 32
  %conv.i = ashr exact i64 %sext, 32
  %mul.i = mul i64 %conv.i, %.val
  %add.ptr.i = getelementptr inbounds i8, ptr %40, i64 %mul.i
  %42 = load ptr, ptr %add.ptr.i, align 8
  %tobool52.not = icmp eq ptr %42, null
  %inc = add i64 %count.0, 1
  br i1 %tobool52.not, label %while.end, label %while.cond, !llvm.loop !23

while.end:                                        ; preds = %while.cond
  %conv.le = trunc i64 %count.0 to i32
  %cmp53 = icmp ult i64 %count.0, 1152921504606846975
  br i1 %cmp53, label %cond.end, label %cond.false

cond.false:                                       ; preds = %while.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.29, ptr noundef nonnull @.str.2, i32 noundef 1881) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %while.end
  %add = shl nuw i64 %count.0, 4
  %mul = add nuw i64 %add, 16
  %call58 = tail call noalias ptr @zmalloc(i64 noundef %mul) #33
  store ptr %call58, ptr %history, align 8
  %cmp60182.not = icmp eq i64 %count.0, 0
  br i1 %cmp60182.not, label %for.end, label %for.body

for.body:                                         ; preds = %cond.end, %for.body
  %j.0183 = phi i64 [ %inc75, %for.body ], [ 0, %cond.end ]
  %43 = load ptr, ptr %history.i, align 8
  %.val142 = load i64, ptr %41, align 8
  %sext160 = shl i64 %j.0183, 32
  %conv.i145 = ashr exact i64 %sext160, 32
  %mul.i146 = mul i64 %.val142, %conv.i145
  %add.ptr.i147 = getelementptr inbounds i8, ptr %43, i64 %mul.i146
  %44 = load ptr, ptr %add.ptr.i147, align 8
  %call67 = tail call noalias ptr @zstrdup(ptr noundef %44) #32
  %45 = load ptr, ptr %history, align 8
  %arrayidx69 = getelementptr inbounds %struct.commandHistory, ptr %45, i64 %j.0183
  store ptr %call67, ptr %arrayidx69, align 8
  %changes = getelementptr inbounds %struct.RedisModuleCommandHistoryEntry, ptr %add.ptr.i147, i64 0, i32 1
  %46 = load ptr, ptr %changes, align 8
  %call71 = tail call noalias ptr @zstrdup(ptr noundef %46) #32
  %47 = load ptr, ptr %history, align 8
  %changes74 = getelementptr inbounds %struct.commandHistory, ptr %47, i64 %j.0183, i32 1
  store ptr %call71, ptr %changes74, align 8
  %inc75 = add nuw i64 %j.0183, 1
  %exitcond.not = icmp eq i64 %inc75, %count.0
  br i1 %exitcond.not, label %for.end.loopexit, label %for.body, !llvm.loop !24

for.end.loopexit:                                 ; preds = %for.body
  %.pre = load ptr, ptr %history, align 8
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %cond.end
  %48 = phi ptr [ %.pre, %for.end.loopexit ], [ %call58, %cond.end ]
  %arrayidx77 = getelementptr inbounds %struct.commandHistory, ptr %48, i64 %count.0
  store ptr null, ptr %arrayidx77, align 8
  %49 = load ptr, ptr %history, align 8
  %changes81 = getelementptr inbounds %struct.commandHistory, ptr %49, i64 %count.0, i32 1
  store ptr null, ptr %changes81, align 8
  %num_history = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 9
  store i32 %conv.le, ptr %num_history, align 8
  br label %if.end83

if.end83:                                         ; preds = %for.end, %if.end44
  %tips84 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %info, i64 0, i32 5
  %50 = load ptr, ptr %tips84, align 8
  %tobool85.not = icmp eq ptr %50, null
  br i1 %tobool85.not, label %if.end116, label %if.then86

if.then86:                                        ; preds = %if.end83
  %call90 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %50) #36
  %call91 = call ptr @sdssplitlen(ptr noundef nonnull %50, i64 noundef %call90, ptr noundef nonnull @.str.4, i32 noundef 1, ptr noundef nonnull %count87) #32
  %tobool92.not = icmp eq ptr %call91, null
  br i1 %tobool92.not, label %if.end116, label %if.then93

if.then93:                                        ; preds = %if.then86
  %51 = load i32, ptr %count87, align 4
  %add94 = add nsw i32 %51, 1
  %conv95 = sext i32 %add94 to i64
  %mul96 = shl nsw i64 %conv95, 3
  %call97 = call noalias ptr @zmalloc(i64 noundef %mul96) #33
  store ptr %call97, ptr %tips, align 8
  %52 = load i32, ptr %count87, align 4
  %cmp101184 = icmp sgt i32 %52, 0
  br i1 %cmp101184, label %for.body103, label %if.then93.for.end111_crit_edge

if.then93.for.end111_crit_edge:                   ; preds = %if.then93
  %.pre210 = sext i32 %52 to i64
  br label %for.end111

for.body103:                                      ; preds = %if.then93, %for.body103
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body103 ], [ 0, %if.then93 ]
  %arrayidx104 = getelementptr inbounds ptr, ptr %call91, i64 %indvars.iv
  %53 = load ptr, ptr %arrayidx104, align 8
  %call105 = call noalias ptr @zstrdup(ptr noundef %53) #32
  %54 = load ptr, ptr %tips, align 8
  %arrayidx108 = getelementptr inbounds ptr, ptr %54, i64 %indvars.iv
  store ptr %call105, ptr %arrayidx108, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %55 = load i32, ptr %count87, align 4
  %56 = sext i32 %55 to i64
  %cmp101 = icmp slt i64 %indvars.iv.next, %56
  br i1 %cmp101, label %for.body103, label %for.end111.loopexit, !llvm.loop !25

for.end111.loopexit:                              ; preds = %for.body103
  %.pre209 = load ptr, ptr %tips, align 8
  br label %for.end111

for.end111:                                       ; preds = %if.then93.for.end111_crit_edge, %for.end111.loopexit
  %idxprom113.pre-phi = phi i64 [ %.pre210, %if.then93.for.end111_crit_edge ], [ %56, %for.end111.loopexit ]
  %57 = phi ptr [ %call97, %if.then93.for.end111_crit_edge ], [ %.pre209, %for.end111.loopexit ]
  %.lcssa163 = phi i32 [ %52, %if.then93.for.end111_crit_edge ], [ %55, %for.end111.loopexit ]
  %arrayidx114 = getelementptr inbounds ptr, ptr %57, i64 %idxprom113.pre-phi
  store ptr null, ptr %arrayidx114, align 8
  %num_tips = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 11
  store i32 %.lcssa163, ptr %num_tips, align 8
  call void @sdsfreesplitres(ptr noundef nonnull %call91, i32 noundef %.lcssa163) #32
  br label %if.end116

if.end116:                                        ; preds = %if.then86, %for.end111, %if.end83
  %arity = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %info, i64 0, i32 6
  %58 = load i32, ptr %arity, align 8
  %tobool117.not = icmp eq i32 %58, 0
  br i1 %tobool117.not, label %if.end121, label %if.then118

if.then118:                                       ; preds = %if.end116
  %arity120 = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 13
  store i32 %58, ptr %arity120, align 8
  br label %if.end121

if.end121:                                        ; preds = %if.then118, %if.end116
  %59 = load ptr, ptr %key_specs.i, align 8
  %tobool123.not = icmp eq ptr %59, null
  br i1 %tobool123.not, label %if.end264, label %while.cond126.preheader

while.cond126.preheader:                          ; preds = %if.end121
  %60 = getelementptr i8, ptr %39, i64 16
  %.val143 = load i64, ptr %60, align 8
  %invariant.gep = getelementptr %struct.RedisModuleCommandKeySpec, ptr %59, i64 0, i32 2
  br label %while.cond126

while.cond126:                                    ; preds = %while.cond126, %while.cond126.preheader
  %count125.0 = phi i64 [ %inc133, %while.cond126 ], [ 0, %while.cond126.preheader ]
  %sext161 = shl i64 %count125.0, 32
  %conv.i148 = ashr exact i64 %sext161, 32
  %mul.i149 = mul i64 %conv.i148, %.val143
  %gep = getelementptr i8, ptr %invariant.gep, i64 %mul.i149
  %61 = load i32, ptr %gep, align 8
  %tobool131.not = icmp eq i32 %61, 0
  %inc133 = add i64 %count125.0, 1
  br i1 %tobool131.not, label %while.end134, label %while.cond126, !llvm.loop !26

while.end134:                                     ; preds = %while.cond126
  %cmp135 = icmp ult i64 %count125.0, 2147483647
  br i1 %cmp135, label %cond.end145, label %cond.false144

cond.false144:                                    ; preds = %while.end134
  call void @_serverAssert(ptr noundef nonnull @.str.27, ptr noundef nonnull @.str.2, i32 noundef 1915) #32
  call void @abort() #35
  unreachable

cond.end145:                                      ; preds = %while.end134
  %conv128.le = trunc i64 %count125.0 to i32
  %key_specs146 = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 16
  %62 = load ptr, ptr %key_specs146, align 8
  call void @zfree(ptr noundef %62) #32
  %mul147 = mul nuw nsw i64 %count125.0, 56
  %call148 = call noalias ptr @zmalloc(i64 noundef %mul147) #33
  store ptr %call148, ptr %key_specs146, align 8
  store i32 %conv128.le, ptr %key_specs_num, align 8
  %cmp154187.not = icmp eq i64 %count125.0, 0
  br i1 %cmp154187.not, label %for.end263, label %for.body156

for.body156:                                      ; preds = %cond.end145, %for.inc261
  %j152.0188 = phi i64 [ %inc262, %for.inc261 ], [ 0, %cond.end145 ]
  %63 = load ptr, ptr %key_specs.i, align 8
  %.val144 = load i64, ptr %60, align 8
  %sext162 = shl i64 %j152.0188, 32
  %conv.i151 = ashr exact i64 %sext162, 32
  %mul.i152 = mul i64 %.val144, %conv.i151
  %add.ptr.i153 = getelementptr inbounds i8, ptr %63, i64 %mul.i152
  %64 = load ptr, ptr %add.ptr.i153, align 8
  %tobool160.not = icmp eq ptr %64, null
  br i1 %tobool160.not, label %cond.end165, label %cond.true161

cond.true161:                                     ; preds = %for.body156
  %call163 = call noalias ptr @zstrdup(ptr noundef nonnull %64) #32
  br label %cond.end165

cond.end165:                                      ; preds = %for.body156, %cond.true161
  %cond = phi ptr [ %call163, %cond.true161 ], [ null, %for.body156 ]
  %65 = load ptr, ptr %key_specs146, align 8
  %arrayidx167 = getelementptr inbounds %struct.keySpec, ptr %65, i64 %j152.0188
  store ptr %cond, ptr %arrayidx167, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 1
  %66 = load i64, ptr %flags, align 8
  br label %for.body.i154

for.body.i154:                                    ; preds = %for.inc.i156, %cond.end165
  %indvars.iv.i = phi i64 [ 0, %cond.end165 ], [ %indvars.iv.next.i, %for.inc.i156 ]
  %out.06.i = phi i64 [ 0, %cond.end165 ], [ %out.1.i, %for.inc.i156 ]
  %arrayidx7.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 0
  %67 = load i64, ptr %arrayidx7.i, align 16
  %and.i155 = and i64 %67, %66
  %tobool8.not.i = icmp eq i64 %and.i155, 0
  br i1 %tobool8.not.i, label %for.inc.i156, label %if.then.i

if.then.i:                                        ; preds = %for.body.i154
  %arrayidx12.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 1
  %68 = load i64, ptr %arrayidx12.i, align 8
  %or.i = or i64 %68, %out.06.i
  br label %for.inc.i156

for.inc.i156:                                     ; preds = %if.then.i, %for.body.i154
  %out.1.i = phi i64 [ %or.i, %if.then.i ], [ %out.06.i, %for.body.i154 ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.i157 = icmp eq i64 %indvars.iv.next.i, 11
  br i1 %exitcond.i157, label %moduleConvertKeySpecsFlags.exit, label %for.body.i154, !llvm.loop !13

moduleConvertKeySpecsFlags.exit:                  ; preds = %for.inc.i156
  %69 = load ptr, ptr %key_specs146, align 8
  %flags172 = getelementptr inbounds %struct.keySpec, ptr %69, i64 %j152.0188, i32 1
  store i64 %out.1.i, ptr %flags172, align 8
  %begin_search_type173 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 2
  %70 = load i32, ptr %begin_search_type173, align 8
  switch i32 %70, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb177
    i32 3, label %sw.bb185
  ]

sw.bb:                                            ; preds = %moduleConvertKeySpecsFlags.exit
  %71 = load ptr, ptr %key_specs146, align 8
  %begin_search_type176 = getelementptr inbounds %struct.keySpec, ptr %71, i64 %j152.0188, i32 2
  store i32 1, ptr %begin_search_type176, align 8
  br label %sw.epilog

sw.bb177:                                         ; preds = %moduleConvertKeySpecsFlags.exit
  %72 = load ptr, ptr %key_specs146, align 8
  %begin_search_type180 = getelementptr inbounds %struct.keySpec, ptr %72, i64 %j152.0188, i32 2
  store i32 2, ptr %begin_search_type180, align 8
  %bs = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 3
  %73 = load i32, ptr %bs, align 8
  %74 = load ptr, ptr %key_specs146, align 8
  %bs183 = getelementptr inbounds %struct.keySpec, ptr %74, i64 %j152.0188, i32 3
  store i32 %73, ptr %bs183, align 8
  br label %sw.epilog

sw.bb185:                                         ; preds = %moduleConvertKeySpecsFlags.exit
  %75 = load ptr, ptr %key_specs146, align 8
  %begin_search_type188 = getelementptr inbounds %struct.keySpec, ptr %75, i64 %j152.0188, i32 2
  store i32 3, ptr %begin_search_type188, align 8
  %bs189 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 3
  %76 = load ptr, ptr %bs189, align 8
  %call190 = call noalias ptr @zstrdup(ptr noundef %76) #32
  %77 = load ptr, ptr %key_specs146, align 8
  %bs193 = getelementptr inbounds %struct.keySpec, ptr %77, i64 %j152.0188, i32 3
  store ptr %call190, ptr %bs193, align 8
  %startfrom = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 3, i32 0, i32 1
  %78 = load i32, ptr %startfrom, align 8
  %79 = load ptr, ptr %key_specs146, align 8
  %startfrom199 = getelementptr inbounds %struct.keySpec, ptr %79, i64 %j152.0188, i32 3, i32 0, i32 1
  store i32 %78, ptr %startfrom199, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %moduleConvertKeySpecsFlags.exit
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 1941, ptr noundef nonnull @.str.30) #32
  call void @abort() #35
  unreachable

sw.epilog:                                        ; preds = %sw.bb185, %sw.bb177, %sw.bb
  %find_keys_type200 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 4
  %80 = load i32, ptr %find_keys_type200, align 8
  switch i32 %80, label %sw.default259 [
    i32 0, label %sw.bb201
    i32 1, label %sw.bb213
    i32 2, label %sw.bb217
    i32 3, label %sw.bb239
  ]

sw.bb201:                                         ; preds = %sw.epilog
  %81 = load ptr, ptr %key_specs146, align 8
  %find_keys_type204 = getelementptr inbounds %struct.keySpec, ptr %81, i64 %j152.0188, i32 4
  store i32 2, ptr %find_keys_type204, align 8
  %82 = load ptr, ptr %key_specs146, align 8
  %fk = getelementptr inbounds %struct.keySpec, ptr %82, i64 %j152.0188, i32 5
  store i32 0, ptr %fk, align 4
  %83 = load ptr, ptr %key_specs146, align 8
  %keystep = getelementptr inbounds %struct.keySpec, ptr %83, i64 %j152.0188, i32 5, i32 0, i32 1
  store i32 1, ptr %keystep, align 4
  %84 = load ptr, ptr %key_specs146, align 8
  %limit = getelementptr inbounds %struct.keySpec, ptr %84, i64 %j152.0188, i32 5, i32 0, i32 2
  store i32 0, ptr %limit, align 4
  br label %for.inc261

sw.bb213:                                         ; preds = %sw.epilog
  %85 = load ptr, ptr %key_specs146, align 8
  %find_keys_type216 = getelementptr inbounds %struct.keySpec, ptr %85, i64 %j152.0188, i32 4
  store i32 1, ptr %find_keys_type216, align 8
  br label %for.inc261

sw.bb217:                                         ; preds = %sw.epilog
  %86 = load ptr, ptr %key_specs146, align 8
  %find_keys_type220 = getelementptr inbounds %struct.keySpec, ptr %86, i64 %j152.0188, i32 4
  store i32 2, ptr %find_keys_type220, align 8
  %fk221 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 5
  %87 = load i32, ptr %fk221, align 4
  %88 = load ptr, ptr %key_specs146, align 8
  %fk225 = getelementptr inbounds %struct.keySpec, ptr %88, i64 %j152.0188, i32 5
  store i32 %87, ptr %fk225, align 4
  %keystep228 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 5, i32 0, i32 1
  %89 = load i32, ptr %keystep228, align 4
  %90 = load ptr, ptr %key_specs146, align 8
  %keystep232 = getelementptr inbounds %struct.keySpec, ptr %90, i64 %j152.0188, i32 5, i32 0, i32 1
  store i32 %89, ptr %keystep232, align 4
  %limit234 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 5, i32 0, i32 2
  %91 = load i32, ptr %limit234, align 4
  %92 = load ptr, ptr %key_specs146, align 8
  %limit238 = getelementptr inbounds %struct.keySpec, ptr %92, i64 %j152.0188, i32 5, i32 0, i32 2
  store i32 %91, ptr %limit238, align 4
  br label %for.inc261

sw.bb239:                                         ; preds = %sw.epilog
  %93 = load ptr, ptr %key_specs146, align 8
  %find_keys_type242 = getelementptr inbounds %struct.keySpec, ptr %93, i64 %j152.0188, i32 4
  store i32 3, ptr %find_keys_type242, align 8
  %fk243 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 5
  %94 = load i32, ptr %fk243, align 4
  %95 = load ptr, ptr %key_specs146, align 8
  %fk246 = getelementptr inbounds %struct.keySpec, ptr %95, i64 %j152.0188, i32 5
  store i32 %94, ptr %fk246, align 4
  %firstkey = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 5, i32 0, i32 1
  %96 = load i32, ptr %firstkey, align 4
  %97 = load ptr, ptr %key_specs146, align 8
  %firstkey252 = getelementptr inbounds %struct.keySpec, ptr %97, i64 %j152.0188, i32 5, i32 0, i32 1
  store i32 %96, ptr %firstkey252, align 4
  %keystep254 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %add.ptr.i153, i64 0, i32 5, i32 0, i32 2
  %98 = load i32, ptr %keystep254, align 4
  %99 = load ptr, ptr %key_specs146, align 8
  %keystep258 = getelementptr inbounds %struct.keySpec, ptr %99, i64 %j152.0188, i32 5, i32 0, i32 2
  store i32 %98, ptr %keystep258, align 4
  br label %for.inc261

sw.default259:                                    ; preds = %sw.epilog
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 1969, ptr noundef nonnull @.str.31) #32
  call void @abort() #35
  unreachable

for.inc261:                                       ; preds = %sw.bb201, %sw.bb213, %sw.bb217, %sw.bb239
  %inc262 = add nuw i64 %j152.0188, 1
  %exitcond208.not = icmp eq i64 %inc262, %count125.0
  br i1 %exitcond208.not, label %for.end263, label %for.body156, !llvm.loop !27

for.end263:                                       ; preds = %for.inc261, %cond.end145
  call void @populateCommandLegacyRangeSpec(ptr noundef nonnull %25) #32
  br label %if.end264

if.end264:                                        ; preds = %for.end263, %if.end121
  %100 = load ptr, ptr %args.i, align 8
  %tobool266.not = icmp eq ptr %100, null
  br i1 %tobool266.not, label %return, label %if.then267

if.then267:                                       ; preds = %if.end264
  %call269 = call fastcc ptr @moduleCopyCommandArgs(ptr noundef nonnull %100, ptr noundef %39)
  store ptr %call269, ptr %args, align 8
  %call272 = call i32 @populateArgsStructure(ptr noundef %call269)
  %num_args = getelementptr inbounds %struct.redisCommand, ptr %25, i64 0, i32 19
  store i32 %call272, ptr %num_args, align 8
  br label %return

return:                                           ; preds = %if.end264, %if.then267, %if.then21, %if.then
  %retval.0 = phi i32 [ 1, %if.then21 ], [ 1, %if.then ], [ 0, %if.then267 ], [ 0, %if.end264 ]
  ret i32 %retval.0
}

declare void @_serverPanic(ptr noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc noalias ptr @moduleCopyCommandArgs(ptr nocapture noundef readonly %args, ptr nocapture noundef readonly %version) unnamed_addr #0 {
entry:
  %0 = getelementptr i8, ptr %version, i64 24
  %version.val = load i64, ptr %0, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %count.0 = phi i64 [ 0, %entry ], [ %inc, %while.cond ]
  %sext = shl i64 %count.0, 32
  %conv.i = ashr exact i64 %sext, 32
  %mul.i = mul i64 %conv.i, %version.val
  %add.ptr.i = getelementptr inbounds i8, ptr %args, i64 %mul.i
  %1 = load ptr, ptr %add.ptr.i, align 8
  %tobool.not = icmp eq ptr %1, null
  %inc = add i64 %count.0, 1
  br i1 %tobool.not, label %while.end, label %while.cond, !llvm.loop !28

while.end:                                        ; preds = %while.cond
  %cmp = icmp ult i64 %count.0, 230584300921369395
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %while.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.539, ptr noundef nonnull @.str.2, i32 noundef 2193) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %while.end
  %2 = mul nuw i64 %count.0, 80
  %mul = add nuw i64 %2, 80
  %call5 = tail call noalias ptr @zcalloc(i64 noundef %mul) #33
  %cmp661.not = icmp eq i64 %count.0, 0
  br i1 %cmp661.not, label %for.end, label %for.body

for.body:                                         ; preds = %cond.end, %for.inc
  %j.062 = phi i64 [ %inc68, %for.inc ], [ 0, %cond.end ]
  %version.val53 = load i64, ptr %0, align 8
  %sext60 = shl i64 %j.062, 32
  %conv.i54 = ashr exact i64 %sext60, 32
  %mul.i55 = mul i64 %version.val53, %conv.i54
  %add.ptr.i56 = getelementptr inbounds i8, ptr %args, i64 %mul.i55
  %3 = load ptr, ptr %add.ptr.i56, align 8
  %call11 = tail call noalias ptr @zstrdup(ptr noundef %3) #32
  %arrayidx = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062
  store ptr %call11, ptr %arrayidx, align 8
  %type = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 1
  %4 = load i32, ptr %type, align 8
  switch i32 %4, label %sw.default.i [
    i32 0, label %if.else
    i32 1, label %if.else
    i32 2, label %if.else
    i32 3, label %if.then
    i32 4, label %if.else
    i32 5, label %if.else
    i32 6, label %if.else
    i32 7, label %if.else
    i32 8, label %if.else
  ]

sw.default.i:                                     ; preds = %for.body
  br label %if.else

if.then:                                          ; preds = %for.body
  %type15 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 1
  store i32 3, ptr %type15, align 8
  %key_spec_index = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 2
  %5 = load i32, ptr %key_spec_index, align 4
  br label %if.end

if.else:                                          ; preds = %for.body, %for.body, %for.body, %for.body, %for.body, %for.body, %for.body, %for.body, %sw.default.i
  %retval.0.i.ph = phi i32 [ -1, %sw.default.i ], [ %4, %for.body ], [ %4, %for.body ], [ %4, %for.body ], [ %4, %for.body ], [ %4, %for.body ], [ %4, %for.body ], [ %4, %for.body ], [ %4, %for.body ]
  %type1558 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 1
  store i32 %retval.0.i.ph, ptr %type1558, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %.sink = phi i32 [ -1, %if.else ], [ %5, %if.then ]
  %key_spec_index22 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 2
  store i32 %.sink, ptr %key_spec_index22, align 4
  %token = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 3
  %6 = load ptr, ptr %token, align 8
  %tobool23.not = icmp eq ptr %6, null
  br i1 %tobool23.not, label %if.end29, label %if.then24

if.then24:                                        ; preds = %if.end
  %call26 = tail call noalias ptr @zstrdup(ptr noundef nonnull %6) #32
  %token28 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 3
  store ptr %call26, ptr %token28, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.then24, %if.end
  %summary = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 4
  %7 = load ptr, ptr %summary, align 8
  %tobool30.not = icmp eq ptr %7, null
  br i1 %tobool30.not, label %if.end36, label %if.then31

if.then31:                                        ; preds = %if.end29
  %call33 = tail call noalias ptr @zstrdup(ptr noundef nonnull %7) #32
  %summary35 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 4
  store ptr %call33, ptr %summary35, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.then31, %if.end29
  %since = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 5
  %8 = load ptr, ptr %since, align 8
  %tobool37.not = icmp eq ptr %8, null
  br i1 %tobool37.not, label %if.end43, label %if.then38

if.then38:                                        ; preds = %if.end36
  %call40 = tail call noalias ptr @zstrdup(ptr noundef nonnull %8) #32
  %since42 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 5
  store ptr %call40, ptr %since42, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.then38, %if.end36
  %deprecated_since = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 7
  %9 = load ptr, ptr %deprecated_since, align 8
  %tobool44.not = icmp eq ptr %9, null
  br i1 %tobool44.not, label %if.end50, label %if.then45

if.then45:                                        ; preds = %if.end43
  %call47 = tail call noalias ptr @zstrdup(ptr noundef nonnull %9) #32
  %deprecated_since49 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 7
  store ptr %call47, ptr %deprecated_since49, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then45, %if.end43
  %display_text = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 9
  %10 = load ptr, ptr %display_text, align 8
  %tobool51.not = icmp eq ptr %10, null
  br i1 %tobool51.not, label %if.end57, label %if.then52

if.then52:                                        ; preds = %if.end50
  %call54 = tail call noalias ptr @zstrdup(ptr noundef nonnull %10) #32
  %display_text56 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 10
  store ptr %call54, ptr %display_text56, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then52, %if.end50
  %flags = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 6
  %11 = load i32, ptr %flags, align 8
  %realflags.2.i = and i32 %11, 7
  %flags60 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 6
  store i32 %realflags.2.i, ptr %flags60, align 8
  %subargs = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i56, i64 0, i32 8
  %12 = load ptr, ptr %subargs, align 8
  %tobool61.not = icmp eq ptr %12, null
  br i1 %tobool61.not, label %for.inc, label %if.then62

if.then62:                                        ; preds = %if.end57
  %call64 = tail call fastcc ptr @moduleCopyCommandArgs(ptr noundef nonnull %12, ptr noundef nonnull %version)
  %subargs66 = getelementptr inbounds %struct.redisCommandArg, ptr %call5, i64 %j.062, i32 9
  store ptr %call64, ptr %subargs66, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end57, %if.then62
  %inc68 = add nuw i64 %j.062, 1
  %exitcond.not = icmp eq i64 %inc68, %count.0
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !29

for.end:                                          ; preds = %for.inc, %cond.end
  ret ptr %call5
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleGetHandleByName(ptr noundef %modulename) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictFetchValue(ptr noundef %0, ptr noundef %modulename) #32
  ret ptr %call
}

declare ptr @dictFetchValue(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @moduleIsModuleCommand(ptr noundef readnone %module_handle, ptr nocapture noundef readonly %cmd) local_unnamed_addr #11 {
entry:
  %proc = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 12
  %0 = load ptr, ptr %proc, align 8
  %cmp.not = icmp ne ptr %0, @RedisModuleCommandDispatcher
  %cmp1 = icmp eq ptr %module_handle, null
  %or.cond = or i1 %cmp1, %cmp.not
  br i1 %or.cond, label %return, label %if.end3

if.end3:                                          ; preds = %entry
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 32
  %1 = load ptr, ptr %module_cmd, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp4 = icmp eq ptr %2, %module_handle
  %conv = zext i1 %cmp4 to i32
  br label %return

return:                                           ; preds = %entry, %if.end3
  %retval.0 = phi i32 [ %conv, %if.end3 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(read) uwtable
define dso_local i32 @moduleListConfigMatch(ptr nocapture noundef readonly %config, ptr nocapture noundef readonly %name) #12 {
entry:
  %0 = load ptr, ptr %config, align 8
  %call = tail call i32 @strcasecmp(ptr noundef %0, ptr noundef %name) #36
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleListFree(ptr noundef %config) #0 {
entry:
  %0 = load ptr, ptr %config, align 8
  tail call void @sdsfree(ptr noundef %0) #32
  tail call void @zfree(ptr noundef nonnull %config) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SetModuleAttribs(ptr nocapture noundef %ctx, ptr noundef %name, i32 noundef %ver, i32 noundef %apiver) #0 {
entry:
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module1, align 8
  %cmp.not = icmp eq ptr %0, null
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = tail call noalias dereferenceable_or_null(128) ptr @zmalloc(i64 noundef 128) #33
  %call2 = tail call ptr @sdsnew(ptr noundef %name) #32
  %name3 = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 1
  store ptr %call2, ptr %name3, align 8
  %ver4 = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 2
  store i32 %ver, ptr %ver4, align 8
  %apiver5 = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 3
  store i32 %apiver, ptr %apiver5, align 4
  %call6 = tail call ptr @listCreate() #32
  %types = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 4
  store ptr %call6, ptr %types, align 8
  %call7 = tail call ptr @listCreate() #32
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 5
  store ptr %call7, ptr %usedby, align 8
  %call8 = tail call ptr @listCreate() #32
  %using = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 6
  store ptr %call8, ptr %using, align 8
  %call9 = tail call ptr @listCreate() #32
  %filters = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 7
  store ptr %call9, ptr %filters, align 8
  %call10 = tail call ptr @listCreate() #32
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 8
  store ptr %call10, ptr %module_configs, align 8
  %match = getelementptr inbounds %struct.list, ptr %call10, i64 0, i32 4
  store ptr @moduleListConfigMatch, ptr %match, align 8
  %free = getelementptr inbounds %struct.list, ptr %call10, i64 0, i32 3
  store ptr @moduleListFree, ptr %free, align 8
  %configs_initialized = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 9
  %info_cb = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 14
  %onload = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 18
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %configs_initialized, i8 0, i64 16, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(28) %info_cb, i8 0, i64 28, i1 false)
  store i32 1, ptr %onload, align 4
  %num_acl_categories_added = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 19
  store i64 0, ptr %num_acl_categories_added, align 8
  store ptr %call, ptr %module1, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

declare ptr @listCreate() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_IsModuleNameBusy(ptr noundef %name) #0 {
entry:
  %call = tail call ptr @sdsnew(ptr noundef %name) #32
  %0 = load ptr, ptr @modules, align 8
  %call1 = tail call ptr @dictFind(ptr noundef %0, ptr noundef %call) #32
  tail call void @sdsfree(ptr noundef %call) #32
  %cmp = icmp ne ptr %call1, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_Milliseconds() #0 {
entry:
  %call = tail call i64 @mstime() #32
  ret i64 %call
}

declare i64 @mstime() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MonotonicMicroseconds() #0 {
entry:
  %0 = load ptr, ptr @getMonotonicUs, align 8
  %call = tail call i64 %0() #32
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_Microseconds() #0 {
entry:
  %call = tail call i64 @ustime() #32
  ret i64 %call
}

declare i64 @ustime() local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable
define dso_local i64 @RM_CachedMicroseconds() #13 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_BlockedClientMeasureTimeStart(ptr nocapture noundef writeonly %bc) #0 {
entry:
  %background_timer = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 13
  %0 = load ptr, ptr @getMonotonicUs, align 8
  %call.i = tail call i64 %0() #32
  store i64 %call.i, ptr %background_timer, align 8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_BlockedClientMeasureTimeEnd(ptr nocapture noundef %bc) #0 {
entry:
  %background_timer = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 13
  %0 = load i64, ptr %background_timer, align 8
  %tobool.not = icmp eq i64 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @getMonotonicUs, align 8
  %call.i = tail call i64 %1() #32
  %sub.i = sub i64 %call.i, %0
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 14
  %2 = load i64, ptr %background_duration, align 8
  %add = add i64 %sub.i, %2
  store i64 %add, ptr %background_duration, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_Yield(ptr nocapture noundef %ctx, i32 noundef %flags, ptr noundef %busy_reply) #0 {
entry:
  %0 = load i32, ptr @RM_Yield.yield_nesting, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr @RM_Yield.yield_nesting, align 4
  %1 = load ptr, ptr @getMonotonicUs, align 8
  %call = tail call i64 %1() #32
  %next_yield_time = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  %2 = load i64, ptr %next_yield_time, align 8
  %cmp.not = icmp slt i64 %call, %2
  br i1 %cmp.not, label %if.end16, label %if.then1

if.then1:                                         ; preds = %if.end
  %3 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool2.not = icmp eq i32 %3, 0
  br i1 %tobool2.not, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.then1
  tail call void @processEventsWhileBlocked() #32
  br label %if.end14

if.else:                                          ; preds = %if.then1
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 32), align 8
  store ptr %busy_reply, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 32), align 8
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %tobool4.not = icmp eq i32 %5, 0
  br i1 %tobool4.not, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.else
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  tail call void @blockingOperationStarts() #32
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %tobool6.not = icmp eq ptr %6, null
  br i1 %tobool6.not, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.then5
  tail call void @protectClient(ptr noundef nonnull %6) #32
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %if.then7, %if.else
  %and = and i32 %flags, 2
  %tobool10.not = icmp eq i32 %and, 0
  br i1 %tobool10.not, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %or = or i32 %7, 2
  store i32 %or, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end9
  tail call void @processEventsWhileBlocked() #32
  store ptr %4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 32), align 8
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %and13 = and i32 %8, -3
  store i32 %and13, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end12, %if.then3
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div = sdiv i32 1000000, %9
  %conv = sext i32 %div to i64
  %add = add nsw i64 %call, %conv
  store i64 %add, ptr %next_yield_time, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.end14, %if.end
  %10 = load i32, ptr @RM_Yield.yield_nesting, align 4
  %dec = add nsw i32 %10, -1
  store i32 %dec, ptr @RM_Yield.yield_nesting, align 4
  br label %return

return:                                           ; preds = %entry, %if.end16
  ret void
}

declare void @processEventsWhileBlocked() local_unnamed_addr #1

declare void @blockingOperationStarts() local_unnamed_addr #1

declare void @protectClient(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define dso_local void @RM_SetModuleOptions(ptr nocapture noundef readonly %ctx, i32 noundef %options) #14 {
entry:
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %options1 = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 12
  store i32 %options, ptr %options1, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SignalModifiedKey(ptr nocapture noundef readonly %ctx, ptr noundef %keyname) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db, align 8
  tail call void @signalModifiedKey(ptr noundef %0, ptr noundef %1, ptr noundef %keyname) #32
  ret i32 0
}

declare void @signalModifiedKey(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local void @RM_AutoMemory(ptr nocapture noundef %ctx) #15 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %or = or i32 %0, 1
  store i32 %or, ptr %flags, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @autoMemoryAdd(ptr nocapture noundef %ctx, i32 noundef %type, ptr noundef %ptr) local_unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %amqueue_used = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used, align 4
  %amqueue_len = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len, align 8
  %cmp = icmp eq i32 %1, %2
  br i1 %cmp, label %if.then1, label %if.end.if.end11_crit_edge

if.end.if.end11_crit_edge:                        ; preds = %if.end
  %amqueue12.phi.trans.insert = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre = load ptr, ptr %amqueue12.phi.trans.insert, align 8
  br label %if.end11

if.then1:                                         ; preds = %if.end
  %mul = shl nsw i32 %1, 1
  %cmp4 = icmp slt i32 %1, 8
  %spec.select = select i1 %cmp4, i32 16, i32 %mul
  store i32 %spec.select, ptr %amqueue_len, align 8
  %amqueue = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue, align 8
  %conv = sext i32 %spec.select to i64
  %mul9 = shl nsw i64 %conv, 4
  %call = tail call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9) #34
  store ptr %call, ptr %amqueue, align 8
  %.pre14 = load i32, ptr %amqueue_used, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.end.if.end11_crit_edge, %if.then1
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge ], [ %.pre14, %if.then1 ]
  %5 = phi ptr [ %.pre, %if.end.if.end11_crit_edge ], [ %call, %if.then1 ]
  %amqueue12 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom = sext i32 %4 to i64
  %type14 = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom, i32 1
  store i32 %type, ptr %type14, align 8
  %6 = load ptr, ptr %amqueue12, align 8
  %7 = load i32, ptr %amqueue_used, align 4
  %idxprom17 = sext i32 %7 to i64
  %arrayidx18 = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17
  store ptr %ptr, ptr %arrayidx18, align 8
  %8 = load i32, ptr %amqueue_used, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %amqueue_used, align 4
  br label %return

return:                                           ; preds = %entry, %if.end11
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local noundef i32 @autoMemoryFreed(ptr nocapture noundef %ctx, i32 noundef %type, ptr noundef readnone %ptr) local_unnamed_addr #16 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %amqueue_used = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used, align 4
  %cmp21 = icmp sgt i32 %1, 0
  br i1 %cmp21, label %for.cond1.preheader.lr.ph, label %return

for.cond1.preheader.lr.ph:                        ; preds = %if.end
  %add = add nuw nsw i32 %1, 1
  %div2731 = lshr i32 %add, 1
  %amqueue = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %2 = load ptr, ptr %amqueue, align 8
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %for.cond1.preheader.lr.ph, %for.inc34
  %j.022 = phi i32 [ 0, %for.cond1.preheader.lr.ph ], [ %inc35, %for.inc34 ]
  %3 = xor i32 %j.022, -1
  %sub6 = add nsw i32 %1, %3
  br label %for.body3

for.body3:                                        ; preds = %for.cond1.preheader, %for.inc
  %cmp4 = phi i1 [ true, %for.cond1.preheader ], [ false, %for.inc ]
  %cond = select i1 %cmp4, i32 %sub6, i32 %j.022
  %idxprom = sext i32 %cond to i64
  %type7 = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom, i32 1
  %4 = load i32, ptr %type7, align 8
  %cmp8 = icmp eq i32 %4, %type
  br i1 %cmp8, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body3
  %arrayidx = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom
  %5 = load ptr, ptr %arrayidx, align 8
  %cmp13 = icmp eq ptr %5, %ptr
  br i1 %cmp13, label %if.then14, label %for.inc

if.then14:                                        ; preds = %land.lhs.true
  store i32 3, ptr %type7, align 8
  %6 = load i32, ptr %amqueue_used, align 4
  %sub20 = add nsw i32 %6, -1
  %cmp21.not = icmp eq i32 %cond, %sub20
  br i1 %cmp21.not, label %if.end31, label %if.then22

if.then22:                                        ; preds = %if.then14
  %7 = load ptr, ptr %amqueue, align 8
  %arrayidx25 = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom
  %idxprom29 = sext i32 %sub20 to i64
  %arrayidx30 = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom29
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %arrayidx25, ptr noundef nonnull align 8 dereferenceable(16) %arrayidx30, i64 16, i1 false)
  %.pre = load i32, ptr %amqueue_used, align 4
  %.pre26 = add nsw i32 %.pre, -1
  br label %if.end31

if.end31:                                         ; preds = %if.then22, %if.then14
  %dec.pre-phi = phi i32 [ %.pre26, %if.then22 ], [ %sub20, %if.then14 ]
  store i32 %dec.pre-phi, ptr %amqueue_used, align 4
  br label %return

for.inc:                                          ; preds = %for.body3, %land.lhs.true
  br i1 %cmp4, label %for.body3, label %for.inc34, !llvm.loop !8

for.inc34:                                        ; preds = %for.inc
  %inc35 = add nuw nsw i32 %j.022, 1
  %exitcond.not = icmp eq i32 %inc35, %div2731
  br i1 %exitcond.not, label %return, label %for.cond1.preheader, !llvm.loop !9

return:                                           ; preds = %for.inc34, %if.end, %entry, %if.end31
  %retval.0 = phi i32 [ 1, %if.end31 ], [ 0, %entry ], [ 0, %if.end ], [ 0, %for.inc34 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #17

declare void @decrRefCount(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeCallReply(ptr noundef %reply) #0 {
entry:
  %call = tail call i32 @callReplyType(ptr noundef %reply) #32
  %cmp = icmp eq i32 %call, 12
  %call1 = tail call ptr @callReplyGetPrivateData(ptr noundef %reply) #32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %ctx2 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %call1, i64 0, i32 5
  %0 = load ptr, ptr %ctx2, align 8
  %1 = load i64, ptr %call1, align 8
  %dec.i = add i64 %1, -1
  store i64 %dec.i, ptr %call1, align 8
  %cmp.not.i = icmp eq i64 %dec.i, 0
  br i1 %cmp.not.i, label %if.end.i, label %if.end

if.end.i:                                         ; preds = %if.then
  %c.i = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %call1, i64 0, i32 4
  %2 = load ptr, ptr %c.i, align 8
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %if.end.i
  tail call void @_serverAssert(ptr noundef nonnull @.str.523, ptr noundef nonnull @.str.2, i32 noundef 649) #32
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %if.end.i
  tail call void @zfree(ptr noundef nonnull %call1) #32
  br label %if.end

if.end:                                           ; preds = %entry, %cond.end.i, %if.then
  %ctx.0 = phi ptr [ %0, %if.then ], [ %0, %cond.end.i ], [ %call1, %entry ]
  tail call void @freeCallReply(ptr noundef %reply) #32
  %tobool.not = icmp eq ptr %ctx.0, null
  br i1 %tobool.not, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.0, i64 0, i32 7
  %3 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %3, 1
  %tobool.not.i7 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i7, label %if.end6, label %if.end.i8

if.end.i8:                                        ; preds = %if.then4
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.0, i64 0, i32 6
  %4 = load i32, ptr %amqueue_used.i, align 4
  %cmp21.i = icmp sgt i32 %4, 0
  br i1 %cmp21.i, label %for.cond1.preheader.lr.ph.i, label %if.end6

for.cond1.preheader.lr.ph.i:                      ; preds = %if.end.i8
  %add.i = add nuw nsw i32 %4, 1
  %div2731.i = lshr i32 %add.i, 1
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.0, i64 0, i32 4
  %5 = load ptr, ptr %amqueue.i, align 8
  br label %for.cond1.preheader.i

for.cond1.preheader.i:                            ; preds = %for.inc34.i, %for.cond1.preheader.lr.ph.i
  %j.022.i = phi i32 [ 0, %for.cond1.preheader.lr.ph.i ], [ %inc35.i, %for.inc34.i ]
  %6 = xor i32 %j.022.i, -1
  %sub6.i = add nsw i32 %4, %6
  br label %for.body3.i

for.body3.i:                                      ; preds = %for.inc.i, %for.cond1.preheader.i
  %cmp4.i = phi i1 [ true, %for.cond1.preheader.i ], [ false, %for.inc.i ]
  %cond.i = select i1 %cmp4.i, i32 %sub6.i, i32 %j.022.i
  %idxprom.i = sext i32 %cond.i to i64
  %type7.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i, i32 1
  %7 = load i32, ptr %type7.i, align 8
  %cmp8.i = icmp eq i32 %7, 2
  br i1 %cmp8.i, label %land.lhs.true.i, label %for.inc.i

land.lhs.true.i:                                  ; preds = %for.body3.i
  %arrayidx.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i
  %8 = load ptr, ptr %arrayidx.i, align 8
  %cmp13.i = icmp eq ptr %8, %reply
  br i1 %cmp13.i, label %if.then14.i, label %for.inc.i

if.then14.i:                                      ; preds = %land.lhs.true.i
  store i32 3, ptr %type7.i, align 8
  %9 = load i32, ptr %amqueue_used.i, align 4
  %sub20.i = add nsw i32 %9, -1
  %cmp21.not.i = icmp eq i32 %cond.i, %sub20.i
  br i1 %cmp21.not.i, label %if.end31.i, label %if.then22.i

if.then22.i:                                      ; preds = %if.then14.i
  %10 = load ptr, ptr %amqueue.i, align 8
  %arrayidx25.i = getelementptr inbounds %struct.AutoMemEntry, ptr %10, i64 %idxprom.i
  %idxprom29.i = sext i32 %sub20.i to i64
  %arrayidx30.i = getelementptr inbounds %struct.AutoMemEntry, ptr %10, i64 %idxprom29.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %arrayidx25.i, ptr noundef nonnull align 8 dereferenceable(16) %arrayidx30.i, i64 16, i1 false)
  %.pre.i = load i32, ptr %amqueue_used.i, align 4
  %.pre26.i = add nsw i32 %.pre.i, -1
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.then22.i, %if.then14.i
  %dec.pre-phi.i = phi i32 [ %.pre26.i, %if.then22.i ], [ %cond.i, %if.then14.i ]
  store i32 %dec.pre-phi.i, ptr %amqueue_used.i, align 4
  br label %if.end6

for.inc.i:                                        ; preds = %land.lhs.true.i, %for.body3.i
  br i1 %cmp4.i, label %for.body3.i, label %for.inc34.i, !llvm.loop !8

for.inc34.i:                                      ; preds = %for.inc.i
  %inc35.i = add nuw nsw i32 %j.022.i, 1
  %exitcond.not.i = icmp eq i32 %inc35.i, %div2731.i
  br i1 %exitcond.not.i, label %if.end6, label %for.cond1.preheader.i, !llvm.loop !9

if.end6:                                          ; preds = %for.inc34.i, %if.end31.i, %if.end.i8, %if.then4, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_CloseKey(ptr noundef %key) #0 {
entry:
  %cmp = icmp eq ptr %key, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  tail call fastcc void @moduleCloseKey(ptr noundef nonnull %key)
  %0 = load ptr, ptr %key, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 7
  %1 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %1, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %autoMemoryFreed.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 6
  %2 = load i32, ptr %amqueue_used.i, align 4
  %cmp21.i = icmp sgt i32 %2, 0
  br i1 %cmp21.i, label %for.cond1.preheader.lr.ph.i, label %autoMemoryFreed.exit

for.cond1.preheader.lr.ph.i:                      ; preds = %if.end.i
  %add.i = add nuw nsw i32 %2, 1
  %div2731.i = lshr i32 %add.i, 1
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i, align 8
  br label %for.cond1.preheader.i

for.cond1.preheader.i:                            ; preds = %for.inc34.i, %for.cond1.preheader.lr.ph.i
  %j.022.i = phi i32 [ 0, %for.cond1.preheader.lr.ph.i ], [ %inc35.i, %for.inc34.i ]
  %4 = xor i32 %j.022.i, -1
  %sub6.i = add nsw i32 %2, %4
  br label %for.body3.i

for.body3.i:                                      ; preds = %for.inc.i, %for.cond1.preheader.i
  %cmp4.i = phi i1 [ true, %for.cond1.preheader.i ], [ false, %for.inc.i ]
  %cond.i = select i1 %cmp4.i, i32 %sub6.i, i32 %j.022.i
  %idxprom.i = sext i32 %cond.i to i64
  %type7.i = getelementptr inbounds %struct.AutoMemEntry, ptr %3, i64 %idxprom.i, i32 1
  %5 = load i32, ptr %type7.i, align 8
  %cmp8.i = icmp eq i32 %5, 0
  br i1 %cmp8.i, label %land.lhs.true.i, label %for.inc.i

land.lhs.true.i:                                  ; preds = %for.body3.i
  %arrayidx.i = getelementptr inbounds %struct.AutoMemEntry, ptr %3, i64 %idxprom.i
  %6 = load ptr, ptr %arrayidx.i, align 8
  %cmp13.i = icmp eq ptr %6, %key
  br i1 %cmp13.i, label %if.then14.i, label %for.inc.i

if.then14.i:                                      ; preds = %land.lhs.true.i
  store i32 3, ptr %type7.i, align 8
  %7 = load i32, ptr %amqueue_used.i, align 4
  %sub20.i = add nsw i32 %7, -1
  %cmp21.not.i = icmp eq i32 %cond.i, %sub20.i
  br i1 %cmp21.not.i, label %if.end31.i, label %if.then22.i

if.then22.i:                                      ; preds = %if.then14.i
  %8 = load ptr, ptr %amqueue.i, align 8
  %arrayidx25.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom.i
  %idxprom29.i = sext i32 %sub20.i to i64
  %arrayidx30.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom29.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %arrayidx25.i, ptr noundef nonnull align 8 dereferenceable(16) %arrayidx30.i, i64 16, i1 false)
  %.pre.i = load i32, ptr %amqueue_used.i, align 4
  %.pre26.i = add nsw i32 %.pre.i, -1
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.then22.i, %if.then14.i
  %dec.pre-phi.i = phi i32 [ %.pre26.i, %if.then22.i ], [ %cond.i, %if.then14.i ]
  store i32 %dec.pre-phi.i, ptr %amqueue_used.i, align 4
  br label %autoMemoryFreed.exit

for.inc.i:                                        ; preds = %land.lhs.true.i, %for.body3.i
  br i1 %cmp4.i, label %for.body3.i, label %for.inc34.i, !llvm.loop !8

for.inc34.i:                                      ; preds = %for.inc.i
  %inc35.i = add nuw nsw i32 %j.022.i, 1
  %exitcond.not.i = icmp eq i32 %inc35.i, %div2731.i
  br i1 %exitcond.not.i, label %autoMemoryFreed.exit, label %for.cond1.preheader.i, !llvm.loop !9

autoMemoryFreed.exit:                             ; preds = %for.inc34.i, %if.end, %if.end.i, %if.end31.i
  tail call void @zfree(ptr noundef nonnull %key) #32
  br label %return

return:                                           ; preds = %entry, %autoMemoryFreed.exit
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeDict(ptr noundef %ctx, ptr noundef %d) #0 {
entry:
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %cmp21.i = icmp sgt i32 %1, 0
  br i1 %cmp21.i, label %for.cond1.preheader.lr.ph.i, label %if.end

for.cond1.preheader.lr.ph.i:                      ; preds = %if.end.i
  %add.i = add nuw nsw i32 %1, 1
  %div2731.i = lshr i32 %add.i, 1
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %2 = load ptr, ptr %amqueue.i, align 8
  br label %for.cond1.preheader.i

for.cond1.preheader.i:                            ; preds = %for.inc34.i, %for.cond1.preheader.lr.ph.i
  %j.022.i = phi i32 [ 0, %for.cond1.preheader.lr.ph.i ], [ %inc35.i, %for.inc34.i ]
  %3 = xor i32 %j.022.i, -1
  %sub6.i = add nsw i32 %1, %3
  br label %for.body3.i

for.body3.i:                                      ; preds = %for.inc.i, %for.cond1.preheader.i
  %cmp4.i = phi i1 [ true, %for.cond1.preheader.i ], [ false, %for.inc.i ]
  %cond.i = select i1 %cmp4.i, i32 %sub6.i, i32 %j.022.i
  %idxprom.i = sext i32 %cond.i to i64
  %type7.i = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom.i, i32 1
  %4 = load i32, ptr %type7.i, align 8
  %cmp8.i = icmp eq i32 %4, 4
  br i1 %cmp8.i, label %land.lhs.true.i, label %for.inc.i

land.lhs.true.i:                                  ; preds = %for.body3.i
  %arrayidx.i = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom.i
  %5 = load ptr, ptr %arrayidx.i, align 8
  %cmp13.i = icmp eq ptr %5, %d
  br i1 %cmp13.i, label %if.then14.i, label %for.inc.i

if.then14.i:                                      ; preds = %land.lhs.true.i
  store i32 3, ptr %type7.i, align 8
  %6 = load i32, ptr %amqueue_used.i, align 4
  %sub20.i = add nsw i32 %6, -1
  %cmp21.not.i = icmp eq i32 %cond.i, %sub20.i
  br i1 %cmp21.not.i, label %if.end31.i, label %if.then22.i

if.then22.i:                                      ; preds = %if.then14.i
  %7 = load ptr, ptr %amqueue.i, align 8
  %arrayidx25.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom.i
  %idxprom29.i = sext i32 %sub20.i to i64
  %arrayidx30.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom29.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %arrayidx25.i, ptr noundef nonnull align 8 dereferenceable(16) %arrayidx30.i, i64 16, i1 false)
  %.pre.i = load i32, ptr %amqueue_used.i, align 4
  %.pre26.i = add nsw i32 %.pre.i, -1
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.then22.i, %if.then14.i
  %dec.pre-phi.i = phi i32 [ %.pre26.i, %if.then22.i ], [ %cond.i, %if.then14.i ]
  store i32 %dec.pre-phi.i, ptr %amqueue_used.i, align 4
  br label %if.end

for.inc.i:                                        ; preds = %land.lhs.true.i, %for.body3.i
  br i1 %cmp4.i, label %for.body3.i, label %for.inc34.i, !llvm.loop !8

for.inc34.i:                                      ; preds = %for.inc.i
  %inc35.i = add nuw nsw i32 %j.022.i, 1
  %exitcond.not.i = icmp eq i32 %inc35.i, %div2731.i
  br i1 %exitcond.not.i, label %if.end, label %for.cond1.preheader.i, !llvm.loop !9

if.end:                                           ; preds = %for.inc34.i, %if.end31.i, %if.end.i, %if.then, %entry
  %8 = load ptr, ptr %d, align 8
  tail call void @raxFree(ptr noundef %8) #32
  tail call void @zfree(ptr noundef nonnull %d) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeServerInfo(ptr noundef %ctx, ptr noundef %data) #0 {
entry:
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %cmp21.i = icmp sgt i32 %1, 0
  br i1 %cmp21.i, label %for.cond1.preheader.lr.ph.i, label %if.end

for.cond1.preheader.lr.ph.i:                      ; preds = %if.end.i
  %add.i = add nuw nsw i32 %1, 1
  %div2731.i = lshr i32 %add.i, 1
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %2 = load ptr, ptr %amqueue.i, align 8
  br label %for.cond1.preheader.i

for.cond1.preheader.i:                            ; preds = %for.inc34.i, %for.cond1.preheader.lr.ph.i
  %j.022.i = phi i32 [ 0, %for.cond1.preheader.lr.ph.i ], [ %inc35.i, %for.inc34.i ]
  %3 = xor i32 %j.022.i, -1
  %sub6.i = add nsw i32 %1, %3
  br label %for.body3.i

for.body3.i:                                      ; preds = %for.inc.i, %for.cond1.preheader.i
  %cmp4.i = phi i1 [ true, %for.cond1.preheader.i ], [ false, %for.inc.i ]
  %cond.i = select i1 %cmp4.i, i32 %sub6.i, i32 %j.022.i
  %idxprom.i = sext i32 %cond.i to i64
  %type7.i = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom.i, i32 1
  %4 = load i32, ptr %type7.i, align 8
  %cmp8.i = icmp eq i32 %4, 5
  br i1 %cmp8.i, label %land.lhs.true.i, label %for.inc.i

land.lhs.true.i:                                  ; preds = %for.body3.i
  %arrayidx.i = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom.i
  %5 = load ptr, ptr %arrayidx.i, align 8
  %cmp13.i = icmp eq ptr %5, %data
  br i1 %cmp13.i, label %if.then14.i, label %for.inc.i

if.then14.i:                                      ; preds = %land.lhs.true.i
  store i32 3, ptr %type7.i, align 8
  %6 = load i32, ptr %amqueue_used.i, align 4
  %sub20.i = add nsw i32 %6, -1
  %cmp21.not.i = icmp eq i32 %cond.i, %sub20.i
  br i1 %cmp21.not.i, label %if.end31.i, label %if.then22.i

if.then22.i:                                      ; preds = %if.then14.i
  %7 = load ptr, ptr %amqueue.i, align 8
  %arrayidx25.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom.i
  %idxprom29.i = sext i32 %sub20.i to i64
  %arrayidx30.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom29.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %arrayidx25.i, ptr noundef nonnull align 8 dereferenceable(16) %arrayidx30.i, i64 16, i1 false)
  %.pre.i = load i32, ptr %amqueue_used.i, align 4
  %.pre26.i = add nsw i32 %.pre.i, -1
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.then22.i, %if.then14.i
  %dec.pre-phi.i = phi i32 [ %.pre26.i, %if.then22.i ], [ %cond.i, %if.then14.i ]
  store i32 %dec.pre-phi.i, ptr %amqueue_used.i, align 4
  br label %if.end

for.inc.i:                                        ; preds = %land.lhs.true.i, %for.body3.i
  br i1 %cmp4.i, label %for.body3.i, label %for.inc34.i, !llvm.loop !8

for.inc34.i:                                      ; preds = %for.inc.i
  %inc35.i = add nuw nsw i32 %j.022.i, 1
  %exitcond.not.i = icmp eq i32 %inc35.i, %div2731.i
  br i1 %exitcond.not.i, label %if.end, label %for.cond1.preheader.i, !llvm.loop !9

if.end:                                           ; preds = %for.inc34.i, %if.end31.i, %if.end.i, %if.then, %entry
  %8 = load ptr, ptr %data, align 8
  tail call void @raxFreeWithCallback(ptr noundef %8, ptr noundef nonnull @sdsfree) #32
  tail call void @zfree(ptr noundef nonnull %data) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateString(ptr noundef %ctx, ptr noundef %ptr, i64 noundef %len) #0 {
entry:
  %call = tail call ptr @createStringObject(ptr noundef %ptr, i64 noundef %len) #32
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %1, %2
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %1, 1
  %cmp4.i = icmp slt i32 %1, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %5 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %4 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %6 = load ptr, ptr %amqueue12.i, align 8
  %7 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %7 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i
  store ptr %call, ptr %arrayidx18.i, align 8
  %8 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %8, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %if.end

if.end:                                           ; preds = %if.end11.i, %if.then, %entry
  ret ptr %call
}

declare ptr @createStringObject(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringPrintf(ptr noundef %ctx, ptr noundef %fmt, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %call = tail call ptr @sdsempty() #32
  call void @llvm.va_start(ptr nonnull %ap)
  %call2 = call ptr @sdscatvprintf(ptr noundef %call, ptr noundef %fmt, ptr noundef nonnull %ap) #32
  call void @llvm.va_end(ptr nonnull %ap)
  %call4 = call ptr @createObject(i32 noundef 0, ptr noundef %call2) #32
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %1, %2
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %1, 1
  %cmp4.i = icmp slt i32 %1, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %5 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %4 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %6 = load ptr, ptr %amqueue12.i, align 8
  %7 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %7 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i
  store ptr %call4, ptr %arrayidx18.i, align 8
  %8 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %8, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %if.end

if.end:                                           ; preds = %if.end11.i, %if.then, %entry
  ret ptr %call4
}

declare ptr @sdsempty() local_unnamed_addr #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #18

declare ptr @sdscatvprintf(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #18

declare ptr @createObject(i32 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromLongLong(ptr noundef %ctx, i64 noundef %ll) #0 {
entry:
  %buf = alloca [21 x i8], align 16
  %call = call i32 @ll2string(ptr noundef nonnull %buf, i64 noundef 21, i64 noundef %ll) #32
  %conv = sext i32 %call to i64
  %call.i = call ptr @createStringObject(ptr noundef nonnull %buf, i64 noundef %conv) #32
  %cmp.not.i = icmp eq ptr %ctx, null
  br i1 %cmp.not.i, label %RM_CreateString.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %0, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %RM_CreateString.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %1, %2
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %if.end11.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %1, 1
  %cmp4.i.i = icmp slt i32 %1, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then1.i.i, %if.end.if.end11_crit_edge.i.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ]
  %5 = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ]
  %amqueue12.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i.i = sext i32 %4 to i64
  %type14.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i.i, i32 1
  store i32 1, ptr %type14.i.i, align 8
  %6 = load ptr, ptr %amqueue12.i.i, align 8
  %7 = load i32, ptr %amqueue_used.i.i, align 4
  %idxprom17.i.i = sext i32 %7 to i64
  %arrayidx18.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i.i
  store ptr %call.i, ptr %arrayidx18.i.i, align 8
  %8 = load i32, ptr %amqueue_used.i.i, align 4
  %inc.i.i = add nsw i32 %8, 1
  store i32 %inc.i.i, ptr %amqueue_used.i.i, align 4
  br label %RM_CreateString.exit

RM_CreateString.exit:                             ; preds = %entry, %if.then.i, %if.end11.i.i
  ret ptr %call.i
}

declare i32 @ll2string(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromULongLong(ptr noundef %ctx, i64 noundef %ull) #0 {
entry:
  %buf = alloca [21 x i8], align 16
  %call = call i32 @ull2string(ptr noundef nonnull %buf, i64 noundef 21, i64 noundef %ull) #32
  %conv = sext i32 %call to i64
  %call.i = call ptr @createStringObject(ptr noundef nonnull %buf, i64 noundef %conv) #32
  %cmp.not.i = icmp eq ptr %ctx, null
  br i1 %cmp.not.i, label %RM_CreateString.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %0, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %RM_CreateString.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %1, %2
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %if.end11.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %1, 1
  %cmp4.i.i = icmp slt i32 %1, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then1.i.i, %if.end.if.end11_crit_edge.i.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ]
  %5 = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ]
  %amqueue12.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i.i = sext i32 %4 to i64
  %type14.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i.i, i32 1
  store i32 1, ptr %type14.i.i, align 8
  %6 = load ptr, ptr %amqueue12.i.i, align 8
  %7 = load i32, ptr %amqueue_used.i.i, align 4
  %idxprom17.i.i = sext i32 %7 to i64
  %arrayidx18.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i.i
  store ptr %call.i, ptr %arrayidx18.i.i, align 8
  %8 = load i32, ptr %amqueue_used.i.i, align 4
  %inc.i.i = add nsw i32 %8, 1
  store i32 %inc.i.i, ptr %amqueue_used.i.i, align 4
  br label %RM_CreateString.exit

RM_CreateString.exit:                             ; preds = %entry, %if.then.i, %if.end11.i.i
  ret ptr %call.i
}

declare i32 @ull2string(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromDouble(ptr noundef %ctx, double noundef %d) #0 {
entry:
  %buf = alloca [128 x i8], align 16
  %call = call i32 @d2string(ptr noundef nonnull %buf, i64 noundef 128, double noundef %d) #32
  %conv = sext i32 %call to i64
  %call.i = call ptr @createStringObject(ptr noundef nonnull %buf, i64 noundef %conv) #32
  %cmp.not.i = icmp eq ptr %ctx, null
  br i1 %cmp.not.i, label %RM_CreateString.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %0, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %RM_CreateString.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %1, %2
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %if.end11.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %1, 1
  %cmp4.i.i = icmp slt i32 %1, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then1.i.i, %if.end.if.end11_crit_edge.i.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ]
  %5 = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ]
  %amqueue12.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i.i = sext i32 %4 to i64
  %type14.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i.i, i32 1
  store i32 1, ptr %type14.i.i, align 8
  %6 = load ptr, ptr %amqueue12.i.i, align 8
  %7 = load i32, ptr %amqueue_used.i.i, align 4
  %idxprom17.i.i = sext i32 %7 to i64
  %arrayidx18.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i.i
  store ptr %call.i, ptr %arrayidx18.i.i, align 8
  %8 = load i32, ptr %amqueue_used.i.i, align 4
  %inc.i.i = add nsw i32 %8, 1
  store i32 %inc.i.i, ptr %amqueue_used.i.i, align 4
  br label %RM_CreateString.exit

RM_CreateString.exit:                             ; preds = %entry, %if.then.i, %if.end11.i.i
  ret ptr %call.i
}

declare i32 @d2string(ptr noundef, i64 noundef, double noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromLongDouble(ptr noundef %ctx, x86_fp80 noundef %ld, i32 noundef %humanfriendly) #0 {
entry:
  %buf = alloca [5120 x i8], align 16
  %tobool.not = icmp ne i32 %humanfriendly, 0
  %cond = zext i1 %tobool.not to i32
  %call = call i32 @ld2string(ptr noundef nonnull %buf, i64 noundef 5120, x86_fp80 noundef %ld, i32 noundef %cond) #32
  %conv = sext i32 %call to i64
  %call.i = call ptr @createStringObject(ptr noundef nonnull %buf, i64 noundef %conv) #32
  %cmp.not.i = icmp eq ptr %ctx, null
  br i1 %cmp.not.i, label %RM_CreateString.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %0, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %RM_CreateString.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %1, %2
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %if.end11.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %1, 1
  %cmp4.i.i = icmp slt i32 %1, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then1.i.i, %if.end.if.end11_crit_edge.i.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ]
  %5 = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ]
  %amqueue12.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i.i = sext i32 %4 to i64
  %type14.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i.i, i32 1
  store i32 1, ptr %type14.i.i, align 8
  %6 = load ptr, ptr %amqueue12.i.i, align 8
  %7 = load i32, ptr %amqueue_used.i.i, align 4
  %idxprom17.i.i = sext i32 %7 to i64
  %arrayidx18.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i.i
  store ptr %call.i, ptr %arrayidx18.i.i, align 8
  %8 = load i32, ptr %amqueue_used.i.i, align 4
  %inc.i.i = add nsw i32 %8, 1
  store i32 %inc.i.i, ptr %amqueue_used.i.i, align 4
  br label %RM_CreateString.exit

RM_CreateString.exit:                             ; preds = %entry, %if.then.i, %if.end11.i.i
  ret ptr %call.i
}

declare i32 @ld2string(ptr noundef, i64 noundef, x86_fp80 noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %call = tail call ptr @dupStringObject(ptr noundef %str) #32
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %1, %2
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %1, 1
  %cmp4.i = icmp slt i32 %1, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %5 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %4 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %6 = load ptr, ptr %amqueue12.i, align 8
  %7 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %7 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i
  store ptr %call, ptr %arrayidx18.i, align 8
  %8 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %8, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %if.end

if.end:                                           ; preds = %if.end11.i, %if.then, %entry
  ret ptr %call
}

declare ptr @dupStringObject(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromStreamID(ptr noundef %ctx, ptr nocapture noundef readonly %id) #0 {
entry:
  %streamid = alloca %struct.streamID, align 16
  %0 = load <2 x i64>, ptr %id, align 8
  store <2 x i64> %0, ptr %streamid, align 16
  %call = call ptr @createObjectFromStreamID(ptr noundef nonnull %streamid) #32
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %1 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %1, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %2 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %3 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %2, %3
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %2, 1
  %cmp4.i = icmp slt i32 %2, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %4 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = call ptr @zrealloc(ptr noundef %4, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %5 = phi i32 [ %2, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %6 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %5 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %7 = load ptr, ptr %amqueue12.i, align 8
  %8 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %8 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom17.i
  store ptr %call, ptr %arrayidx18.i, align 8
  %9 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %9, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %if.end

if.end:                                           ; preds = %if.end11.i, %if.then, %entry
  ret ptr %call
}

declare ptr @createObjectFromStreamID(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  tail call void @decrRefCount(ptr noundef %str) #32
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %cmp21.i = icmp sgt i32 %1, 0
  br i1 %cmp21.i, label %for.cond1.preheader.lr.ph.i, label %if.end

for.cond1.preheader.lr.ph.i:                      ; preds = %if.end.i
  %add.i = add nuw nsw i32 %1, 1
  %div2731.i = lshr i32 %add.i, 1
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %2 = load ptr, ptr %amqueue.i, align 8
  br label %for.cond1.preheader.i

for.cond1.preheader.i:                            ; preds = %for.inc34.i, %for.cond1.preheader.lr.ph.i
  %j.022.i = phi i32 [ 0, %for.cond1.preheader.lr.ph.i ], [ %inc35.i, %for.inc34.i ]
  %3 = xor i32 %j.022.i, -1
  %sub6.i = add nsw i32 %1, %3
  br label %for.body3.i

for.body3.i:                                      ; preds = %for.inc.i, %for.cond1.preheader.i
  %cmp4.i = phi i1 [ true, %for.cond1.preheader.i ], [ false, %for.inc.i ]
  %cond.i = select i1 %cmp4.i, i32 %sub6.i, i32 %j.022.i
  %idxprom.i = sext i32 %cond.i to i64
  %type7.i = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom.i, i32 1
  %4 = load i32, ptr %type7.i, align 8
  %cmp8.i = icmp eq i32 %4, 1
  br i1 %cmp8.i, label %land.lhs.true.i, label %for.inc.i

land.lhs.true.i:                                  ; preds = %for.body3.i
  %arrayidx.i = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom.i
  %5 = load ptr, ptr %arrayidx.i, align 8
  %cmp13.i = icmp eq ptr %5, %str
  br i1 %cmp13.i, label %if.then14.i, label %for.inc.i

if.then14.i:                                      ; preds = %land.lhs.true.i
  store i32 3, ptr %type7.i, align 8
  %6 = load i32, ptr %amqueue_used.i, align 4
  %sub20.i = add nsw i32 %6, -1
  %cmp21.not.i = icmp eq i32 %cond.i, %sub20.i
  br i1 %cmp21.not.i, label %if.end31.i, label %if.then22.i

if.then22.i:                                      ; preds = %if.then14.i
  %7 = load ptr, ptr %amqueue.i, align 8
  %arrayidx25.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom.i
  %idxprom29.i = sext i32 %sub20.i to i64
  %arrayidx30.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom29.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %arrayidx25.i, ptr noundef nonnull align 8 dereferenceable(16) %arrayidx30.i, i64 16, i1 false)
  %.pre.i = load i32, ptr %amqueue_used.i, align 4
  %.pre26.i = add nsw i32 %.pre.i, -1
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.then22.i, %if.then14.i
  %dec.pre-phi.i = phi i32 [ %.pre26.i, %if.then22.i ], [ %cond.i, %if.then14.i ]
  store i32 %dec.pre-phi.i, ptr %amqueue_used.i, align 4
  br label %if.end

for.inc.i:                                        ; preds = %land.lhs.true.i, %for.body3.i
  br i1 %cmp4.i, label %for.body3.i, label %for.inc34.i, !llvm.loop !8

for.inc34.i:                                      ; preds = %for.inc.i
  %inc35.i = add nuw nsw i32 %j.022.i, 1
  %exitcond.not.i = icmp eq i32 %inc35.i, %div2731.i
  br i1 %exitcond.not.i, label %if.end, label %for.cond1.preheader.i, !llvm.loop !9

if.end:                                           ; preds = %for.inc34.i, %if.end31.i, %if.end.i, %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_RetainString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %cmp = icmp eq ptr %ctx, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.then, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %cmp21.i = icmp sgt i32 %1, 0
  br i1 %cmp21.i, label %for.cond1.preheader.lr.ph.i, label %if.then

for.cond1.preheader.lr.ph.i:                      ; preds = %if.end.i
  %add.i = add nuw nsw i32 %1, 1
  %div2731.i = lshr i32 %add.i, 1
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %2 = load ptr, ptr %amqueue.i, align 8
  br label %for.cond1.preheader.i

for.cond1.preheader.i:                            ; preds = %for.inc34.i, %for.cond1.preheader.lr.ph.i
  %j.022.i = phi i32 [ 0, %for.cond1.preheader.lr.ph.i ], [ %inc35.i, %for.inc34.i ]
  %3 = xor i32 %j.022.i, -1
  %sub6.i = add nsw i32 %1, %3
  br label %for.body3.i

for.body3.i:                                      ; preds = %for.inc.i, %for.cond1.preheader.i
  %cmp4.i = phi i1 [ true, %for.cond1.preheader.i ], [ false, %for.inc.i ]
  %cond.i = select i1 %cmp4.i, i32 %sub6.i, i32 %j.022.i
  %idxprom.i = sext i32 %cond.i to i64
  %type7.i = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom.i, i32 1
  %4 = load i32, ptr %type7.i, align 8
  %cmp8.i = icmp eq i32 %4, 1
  br i1 %cmp8.i, label %land.lhs.true.i, label %for.inc.i

land.lhs.true.i:                                  ; preds = %for.body3.i
  %arrayidx.i = getelementptr inbounds %struct.AutoMemEntry, ptr %2, i64 %idxprom.i
  %5 = load ptr, ptr %arrayidx.i, align 8
  %cmp13.i = icmp eq ptr %5, %str
  br i1 %cmp13.i, label %if.then14.i, label %for.inc.i

if.then14.i:                                      ; preds = %land.lhs.true.i
  store i32 3, ptr %type7.i, align 8
  %6 = load i32, ptr %amqueue_used.i, align 4
  %sub20.i = add nsw i32 %6, -1
  %cmp21.not.i = icmp eq i32 %cond.i, %sub20.i
  br i1 %cmp21.not.i, label %autoMemoryFreed.exit, label %if.then22.i

if.then22.i:                                      ; preds = %if.then14.i
  %7 = load ptr, ptr %amqueue.i, align 8
  %arrayidx25.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom.i
  %idxprom29.i = sext i32 %sub20.i to i64
  %arrayidx30.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom29.i
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %arrayidx25.i, ptr noundef nonnull align 8 dereferenceable(16) %arrayidx30.i, i64 16, i1 false)
  %.pre.i = load i32, ptr %amqueue_used.i, align 4
  %.pre26.i = add nsw i32 %.pre.i, -1
  br label %autoMemoryFreed.exit

for.inc.i:                                        ; preds = %land.lhs.true.i, %for.body3.i
  br i1 %cmp4.i, label %for.body3.i, label %for.inc34.i, !llvm.loop !8

for.inc34.i:                                      ; preds = %for.inc.i
  %inc35.i = add nuw nsw i32 %j.022.i, 1
  %exitcond.not.i = icmp eq i32 %inc35.i, %div2731.i
  br i1 %exitcond.not.i, label %if.then, label %for.cond1.preheader.i, !llvm.loop !9

autoMemoryFreed.exit:                             ; preds = %if.then14.i, %if.then22.i
  %dec.pre-phi.i = phi i32 [ %.pre26.i, %if.then22.i ], [ %cond.i, %if.then14.i ]
  store i32 %dec.pre-phi.i, ptr %amqueue_used.i, align 4
  br label %if.end

if.then:                                          ; preds = %for.inc34.i, %if.end.i, %lor.lhs.false, %entry
  tail call void @incrRefCount(ptr noundef %str) #32
  br label %if.end

if.end:                                           ; preds = %autoMemoryFreed.exit, %if.then
  ret void
}

declare void @incrRefCount(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_HoldString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %refcount = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 1
  %0 = load i32, ptr %refcount, align 4
  %cmp = icmp eq i32 %0, 2147483646
  %cmp.not.i = icmp eq ptr %ctx, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call.i = tail call ptr @dupStringObject(ptr noundef nonnull %str) #32
  br i1 %cmp.not.i, label %return, label %if.then.i

if.then.i:                                        ; preds = %if.then
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %1 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %1, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %2 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %3 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %2, %3
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %return.sink.split

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %2, 1
  %cmp4.i.i = icmp slt i32 %2, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %4 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = tail call ptr @zrealloc(ptr noundef %4, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %return.sink.split

if.end:                                           ; preds = %entry
  tail call void @incrRefCount(ptr noundef nonnull %str) #32
  br i1 %cmp.not.i, label %return, label %if.then2

if.then2:                                         ; preds = %if.end
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %5 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %5, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then2
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %6 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %7 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %6, %7
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %return.sink.split

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %6, 1
  %cmp4.i = icmp slt i32 %6, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %8 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i7 = tail call ptr @zrealloc(ptr noundef %8, i64 noundef %mul9.i) #34
  store ptr %call.i7, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %return.sink.split

return.sink.split:                                ; preds = %if.end.if.end11_crit_edge.i, %if.then1.i, %if.end.if.end11_crit_edge.i.i, %if.then1.i.i
  %.sink11 = phi i32 [ %2, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ], [ %6, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %.sink = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ], [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i7, %if.then1.i ]
  %amqueue_used.i.sink10 = phi ptr [ %amqueue_used.i.i, %if.end.if.end11_crit_edge.i.i ], [ %amqueue_used.i.i, %if.then1.i.i ], [ %amqueue_used.i, %if.end.if.end11_crit_edge.i ], [ %amqueue_used.i, %if.then1.i ]
  %str.sink = phi ptr [ %call.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i, %if.then1.i.i ], [ %str, %if.end.if.end11_crit_edge.i ], [ %str, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %.sink11 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %.sink, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %9 = load ptr, ptr %amqueue12.i, align 8
  %10 = load i32, ptr %amqueue_used.i.sink10, align 4
  %idxprom17.i = sext i32 %10 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %9, i64 %idxprom17.i
  store ptr %str.sink, ptr %arrayidx18.i, align 8
  %11 = load i32, ptr %amqueue_used.i.sink10, align 4
  %inc.i = add nsw i32 %11, 1
  store i32 %inc.i, ptr %amqueue_used.i.sink10, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %if.then2, %if.then.i, %if.then, %if.end
  %retval.0 = phi ptr [ %str, %if.end ], [ %call.i, %if.then ], [ %call.i, %if.then.i ], [ %str, %if.then2 ], [ %str.sink, %return.sink.split ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define dso_local ptr @RM_StringPtrLen(ptr noundef readonly %str, ptr noundef writeonly %len) #19 {
entry:
  %cmp = icmp eq ptr %str, null
  %tobool.not = icmp eq ptr %len, null
  br i1 %cmp, label %if.then, label %if.end2

if.then:                                          ; preds = %entry
  br i1 %tobool.not, label %return, label %if.then1

if.then1:                                         ; preds = %if.then
  store i64 40, ptr %len, align 8
  br label %return

if.end2:                                          ; preds = %entry
  br i1 %tobool.not, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end2
  %ptr = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then4
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then4
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then4
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then4
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then4
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then4, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then4 ]
  store i64 %retval.0.i, ptr %len, align 8
  br label %if.end6

if.end6:                                          ; preds = %sdslen.exit, %if.end2
  %ptr7 = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %6 = load ptr, ptr %ptr7, align 8
  br label %return

return:                                           ; preds = %if.then, %if.then1, %if.end6
  %retval.0 = phi ptr [ %6, %if.end6 ], [ @.str.32, %if.then1 ], [ @.str.32, %if.then ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define internal fastcc i64 @sdslen(ptr nocapture noundef readonly %s) unnamed_addr #6 {
entry:
  %arrayidx = getelementptr inbounds i8, ptr %s, i64 -1
  %0 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %return [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %shr = lshr i32 %conv, 3
  %conv2 = zext nneg i32 %shr to i64
  br label %return

sw.bb3:                                           ; preds = %entry
  %add.ptr = getelementptr inbounds i8, ptr %s, i64 -3
  %1 = load i8, ptr %add.ptr, align 1
  %conv4 = zext i8 %1 to i64
  br label %return

sw.bb5:                                           ; preds = %entry
  %add.ptr6 = getelementptr inbounds i8, ptr %s, i64 -5
  %2 = load i16, ptr %add.ptr6, align 1
  %conv8 = zext i16 %2 to i64
  br label %return

sw.bb9:                                           ; preds = %entry
  %add.ptr10 = getelementptr inbounds i8, ptr %s, i64 -9
  %3 = load i32, ptr %add.ptr10, align 1
  %conv12 = zext i32 %3 to i64
  br label %return

sw.bb13:                                          ; preds = %entry
  %add.ptr14 = getelementptr inbounds i8, ptr %s, i64 -17
  %4 = load i64, ptr %add.ptr14, align 1
  br label %return

return:                                           ; preds = %entry, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb
  %retval.0 = phi i64 [ %4, %sw.bb13 ], [ %conv12, %sw.bb9 ], [ %conv8, %sw.bb5 ], [ %conv4, %sw.bb3 ], [ %conv2, %sw.bb ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToLongLong(ptr nocapture noundef readonly %str, ptr noundef %ll) #0 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call2 = tail call i32 @string2ll(ptr noundef nonnull %0, i64 noundef %retval.0.i, ptr noundef %ll) #32
  %tobool.not = icmp eq i32 %call2, 0
  %cond = zext i1 %tobool.not to i32
  ret i32 %cond
}

declare i32 @string2ll(ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToULongLong(ptr nocapture noundef readonly %str, ptr noundef %ull) #0 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %call = tail call i32 @string2ull(ptr noundef %0, ptr noundef %ull) #32
  %tobool.not = icmp eq i32 %call, 0
  %cond = zext i1 %tobool.not to i32
  ret i32 %cond
}

declare i32 @string2ull(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToDouble(ptr noundef %str, ptr noundef %d) #0 {
entry:
  %call = tail call i32 @getDoubleFromObject(ptr noundef %str, ptr noundef %d) #32
  %cmp = icmp ne i32 %call, 0
  %cond = zext i1 %cmp to i32
  ret i32 %cond
}

declare i32 @getDoubleFromObject(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToLongDouble(ptr nocapture noundef readonly %str, ptr noundef %ld) #0 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call3 = tail call i32 @string2ld(ptr noundef nonnull %0, i64 noundef %retval.0.i, ptr noundef %ld) #32
  %tobool.not = icmp eq i32 %call3, 0
  %cond = zext i1 %tobool.not to i32
  ret i32 %cond
}

declare i32 @string2ld(ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StringToStreamID(ptr noundef %str, ptr nocapture noundef writeonly %id) #0 {
entry:
  %streamid = alloca %struct.streamID, align 16
  %call = call i32 @streamParseID(ptr noundef %str, ptr noundef nonnull %streamid) #32
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %0 = load <2 x i64>, ptr %streamid, align 16
  store <2 x i64> %0, ptr %id, align 8
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 1, %entry ]
  ret i32 %retval.0
}

declare i32 @streamParseID(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringCompare(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %call = tail call i32 @compareStringObjects(ptr noundef %a, ptr noundef %b) #32
  ret i32 %call
}

declare i32 @compareStringObjects(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @moduleAssertUnsharedString(ptr noundef %str) local_unnamed_addr #0 {
entry:
  %refcount = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 1
  %0 = load i32, ptr %refcount, align 4
  %cmp.not = icmp eq i32 %0, 1
  br i1 %cmp.not, label %if.end3, label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %1, 3
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.33) #32
  br label %return

if.end3:                                          ; preds = %entry
  %bf.load = load i32, ptr %str, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  switch i32 %bf.clear, label %return [
    i32 8, label %if.then5
    i32 1, label %if.then15
  ]

if.then5:                                         ; preds = %if.end3
  %ptr = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %2, i64 -1
  %3 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %3 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then5
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then5
  %add.ptr.i = getelementptr inbounds i8, ptr %2, i64 -3
  %4 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %4 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then5
  %add.ptr6.i = getelementptr inbounds i8, ptr %2, i64 -5
  %5 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %5 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then5
  %add.ptr10.i = getelementptr inbounds i8, ptr %2, i64 -9
  %6 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %6 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then5
  %add.ptr14.i = getelementptr inbounds i8, ptr %2, i64 -17
  %7 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then5, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %7, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then5 ]
  %call7 = tail call ptr @sdsnewlen(ptr noundef nonnull %2, i64 noundef %retval.0.i) #32
  store ptr %call7, ptr %ptr, align 8
  %bf.load9 = load i32, ptr %str, align 8
  %bf.clear10 = and i32 %bf.load9, -241
  store i32 %bf.clear10, ptr %str, align 8
  br label %return

if.then15:                                        ; preds = %if.end3
  %ptr16 = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %8 = load ptr, ptr %ptr16, align 8
  %9 = ptrtoint ptr %8 to i64
  %call17 = tail call ptr @sdsfromlonglong(i64 noundef %9) #32
  store ptr %call17, ptr %ptr16, align 8
  %bf.load19 = load i32, ptr %str, align 8
  %bf.clear20 = and i32 %bf.load19, -241
  store i32 %bf.clear20, ptr %str, align 8
  br label %return

return:                                           ; preds = %sdslen.exit, %if.then15, %if.end3, %if.end, %do.body
  %retval.0 = phi ptr [ null, %do.body ], [ null, %if.end ], [ %str, %if.end3 ], [ %str, %if.then15 ], [ %str, %sdslen.exit ]
  ret ptr %retval.0
}

declare ptr @sdsnewlen(ptr noundef, i64 noundef) local_unnamed_addr #1

declare ptr @sdsfromlonglong(i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StringAppendBuffer(ptr nocapture readnone %ctx, ptr noundef %str, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %call = tail call ptr @moduleAssertUnsharedString(ptr noundef %str)
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %ptr = getelementptr inbounds %struct.redisObject, ptr %call, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %call1 = tail call ptr @sdscatlen(ptr noundef %0, ptr noundef %buf, i64 noundef %len) #32
  store ptr %call1, ptr %ptr, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare ptr @sdscatlen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_TrimStringAllocation(ptr noundef %str) #0 {
entry:
  %tobool.not = icmp eq ptr %str, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  tail call void @trimStringObjectIfNeeded(ptr noundef nonnull %str, i32 noundef 1) #32
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_WrongArity(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  tail call void @addReplyErrorArity(ptr noundef %0) #32
  ret i32 0
}

declare void @addReplyErrorArity(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @moduleGetReplyClient(ptr nocapture noundef readonly %ctx) local_unnamed_addr #11 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 16
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else4, label %if.then

if.then:                                          ; preds = %entry
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.then
  %reply_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %return.sink.split

if.else4:                                         ; preds = %entry
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %return.sink.split

return.sink.split:                                ; preds = %if.then2, %if.else4
  %client.sink = phi ptr [ %client, %if.else4 ], [ %reply_client, %if.then2 ]
  %2 = load ptr, ptr %client.sink, align 8
  br label %return

return:                                           ; preds = %return.sink.split, %if.then
  %retval.0 = phi ptr [ null, %if.then ], [ %2, %return.sink.split ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithLongLong(ptr nocapture noundef readonly %ctx, i64 noundef %ll) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyLongLong(ptr noundef nonnull %2, i64 noundef %ll) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyLongLong(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithError(ptr nocapture noundef readonly %ctx, ptr noundef %err) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %2, ptr noundef nonnull @.str.34, ptr noundef %err) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyErrorFormat(ptr noundef, ptr noundef, ...) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithErrorFormat(ptr nocapture noundef readonly %ctx, ptr noundef %fmt, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  %call1 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %fmt) #36
  %conv = shl i64 %call1, 32
  %sext = add i64 %conv, 8589934592
  %conv2 = ashr exact i64 %sext, 32
  %call3 = tail call noalias ptr @zmalloc(i64 noundef %conv2) #33
  %call5 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %call3, i64 noundef %conv2, ptr noundef nonnull @.str.34, ptr noundef %fmt) #32
  call void @llvm.va_start(ptr nonnull %ap)
  call void @addReplyErrorFormatInternal(ptr noundef nonnull %2, i32 noundef 0, ptr noundef %call3, ptr noundef nonnull %ap) #32
  call void @llvm.va_end(ptr nonnull %ap)
  call void @zfree(ptr noundef %call3) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

; Function Attrs: nofree nounwind
declare noundef i32 @snprintf(ptr noalias nocapture noundef writeonly, i64 noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #20

declare void @addReplyErrorFormatInternal(ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithSimpleString(ptr nocapture noundef readonly %ctx, ptr noundef %msg) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyProto(ptr noundef nonnull %2, ptr noundef nonnull @.str.35, i64 noundef 1) #32
  %call1 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %msg) #36
  tail call void @addReplyProto(ptr noundef nonnull %2, ptr noundef %msg, i64 noundef %call1) #32
  tail call void @addReplyProto(ptr noundef nonnull %2, ptr noundef nonnull @.str.36, i64 noundef 2) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyProto(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleReplyWithCollection(ptr nocapture noundef %ctx, i64 noundef %len, i32 noundef %type) local_unnamed_addr #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  switch i64 %len, label %if.else20 [
    i64 -1, label %if.then2
    i64 0, label %if.then11
  ]

if.then2:                                         ; preds = %if.end
  %postponed_arrays = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %3 = load ptr, ptr %postponed_arrays, align 8
  %postponed_arrays_count = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 9
  %4 = load i32, ptr %postponed_arrays_count, align 8
  %add = add nsw i32 %4, 1
  %conv = sext i32 %add to i64
  %mul = shl nsw i64 %conv, 3
  %call3 = tail call ptr @zrealloc(ptr noundef %3, i64 noundef %mul) #34
  store ptr %call3, ptr %postponed_arrays, align 8
  %call5 = tail call ptr @addReplyDeferredLen(ptr noundef nonnull %2) #32
  %5 = load ptr, ptr %postponed_arrays, align 8
  %6 = load i32, ptr %postponed_arrays_count, align 8
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %idxprom
  store ptr %call5, ptr %arrayidx, align 8
  %7 = load i32, ptr %postponed_arrays_count, align 8
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %postponed_arrays_count, align 8
  br label %return

if.then11:                                        ; preds = %if.end
  switch i32 %type, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb12
    i32 3, label %sw.bb15
    i32 4, label %sw.bb19
  ]

sw.bb:                                            ; preds = %if.then11
  %8 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 12), align 8
  tail call void @addReply(ptr noundef nonnull %2, ptr noundef %8) #32
  br label %return

sw.bb12:                                          ; preds = %if.then11
  %resp = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 3
  %9 = load i32, ptr %resp, align 8
  %idxprom13 = sext i32 %9 to i64
  %arrayidx14 = getelementptr inbounds %struct.sharedObjectsStruct, ptr @shared, i64 0, i32 10, i64 %idxprom13
  %10 = load ptr, ptr %arrayidx14, align 8
  tail call void @addReply(ptr noundef nonnull %2, ptr noundef %10) #32
  br label %return

sw.bb15:                                          ; preds = %if.then11
  %resp16 = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 3
  %11 = load i32, ptr %resp16, align 8
  %idxprom17 = sext i32 %11 to i64
  %arrayidx18 = getelementptr inbounds %struct.sharedObjectsStruct, ptr @shared, i64 0, i32 11, i64 %idxprom17
  %12 = load ptr, ptr %arrayidx18, align 8
  tail call void @addReply(ptr noundef nonnull %2, ptr noundef %12) #32
  br label %return

sw.bb19:                                          ; preds = %if.then11
  tail call void @addReplyAttributeLen(ptr noundef nonnull %2, i64 noundef 0) #32
  br label %return

sw.default:                                       ; preds = %if.then11
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 3118, ptr noundef nonnull @.str.37, i32 noundef %type) #32
  tail call void @abort() #35
  unreachable

if.else20:                                        ; preds = %if.end
  switch i32 %type, label %sw.default25 [
    i32 1, label %sw.bb21
    i32 2, label %sw.bb22
    i32 3, label %sw.bb23
    i32 4, label %sw.bb24
  ]

sw.bb21:                                          ; preds = %if.else20
  tail call void @addReplyArrayLen(ptr noundef nonnull %2, i64 noundef %len) #32
  br label %return

sw.bb22:                                          ; preds = %if.else20
  tail call void @addReplyMapLen(ptr noundef nonnull %2, i64 noundef %len) #32
  br label %return

sw.bb23:                                          ; preds = %if.else20
  tail call void @addReplySetLen(ptr noundef nonnull %2, i64 noundef %len) #32
  br label %return

sw.bb24:                                          ; preds = %if.else20
  tail call void @addReplyAttributeLen(ptr noundef nonnull %2, i64 noundef %len) #32
  br label %return

sw.default25:                                     ; preds = %if.else20
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 3134, ptr noundef nonnull @.str.38, i32 noundef %type) #32
  tail call void @abort() #35
  unreachable

return:                                           ; preds = %if.then.i, %if.then2, %sw.bb21, %sw.bb22, %sw.bb23, %sw.bb24, %sw.bb, %sw.bb12, %sw.bb15, %sw.bb19, %moduleGetReplyClient.exit
  ret i32 0
}

declare ptr @addReplyDeferredLen(ptr noundef) local_unnamed_addr #1

declare void @addReply(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @addReplyAttributeLen(ptr noundef, i64 noundef) local_unnamed_addr #1

declare void @addReplyArrayLen(ptr noundef, i64 noundef) local_unnamed_addr #1

declare void @addReplyMapLen(ptr noundef, i64 noundef) local_unnamed_addr #1

declare void @addReplySetLen(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithArray(ptr nocapture noundef %ctx, i64 noundef %len) #0 {
entry:
  %call = tail call i32 @moduleReplyWithCollection(ptr noundef %ctx, i64 noundef %len, i32 noundef 1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithMap(ptr nocapture noundef %ctx, i64 noundef %len) #0 {
entry:
  %call = tail call i32 @moduleReplyWithCollection(ptr noundef %ctx, i64 noundef %len, i32 noundef 2)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithSet(ptr nocapture noundef %ctx, i64 noundef %len) #0 {
entry:
  %call = tail call i32 @moduleReplyWithCollection(ptr noundef %ctx, i64 noundef %len, i32 noundef 3)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithAttribute(ptr nocapture noundef %ctx, i64 noundef %len) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %resp = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 3
  %1 = load i32, ptr %resp, align 8
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %2 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %2, 16
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end
  %blocked_client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %3 = load ptr, ptr %blocked_client.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i.i, label %return, label %moduleGetReplyClient.exit.i

moduleGetReplyClient.exit.i:                      ; preds = %if.then.i.i
  %reply_client.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %3, i64 0, i32 9
  %.pre = load ptr, ptr %reply_client.i.i, align 8
  %cmp.i = icmp eq ptr %.pre, null
  br i1 %cmp.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.end, %moduleGetReplyClient.exit.i
  %4 = phi ptr [ %.pre, %moduleGetReplyClient.exit.i ], [ %0, %if.end ]
  switch i64 %len, label %if.else20.i [
    i64 -1, label %if.then2.i
    i64 0, label %if.then11.i
  ]

if.then2.i:                                       ; preds = %if.end.i
  %postponed_arrays.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %5 = load ptr, ptr %postponed_arrays.i, align 8
  %postponed_arrays_count.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 9
  %6 = load i32, ptr %postponed_arrays_count.i, align 8
  %add.i = add nsw i32 %6, 1
  %conv.i = sext i32 %add.i to i64
  %mul.i = shl nsw i64 %conv.i, 3
  %call3.i = tail call ptr @zrealloc(ptr noundef %5, i64 noundef %mul.i) #34
  store ptr %call3.i, ptr %postponed_arrays.i, align 8
  %call5.i = tail call ptr @addReplyDeferredLen(ptr noundef nonnull %4) #32
  %7 = load ptr, ptr %postponed_arrays.i, align 8
  %8 = load i32, ptr %postponed_arrays_count.i, align 8
  %idxprom.i = sext i32 %8 to i64
  %arrayidx.i = getelementptr inbounds ptr, ptr %7, i64 %idxprom.i
  store ptr %call5.i, ptr %arrayidx.i, align 8
  %9 = load i32, ptr %postponed_arrays_count.i, align 8
  %inc.i = add nsw i32 %9, 1
  store i32 %inc.i, ptr %postponed_arrays_count.i, align 8
  br label %return

if.then11.i:                                      ; preds = %if.end.i
  tail call void @addReplyAttributeLen(ptr noundef nonnull %4, i64 noundef 0) #32
  br label %return

if.else20.i:                                      ; preds = %if.end.i
  tail call void @addReplyAttributeLen(ptr noundef nonnull %4, i64 noundef %len) #32
  br label %return

return:                                           ; preds = %if.else20.i, %if.then11.i, %if.then2.i, %moduleGetReplyClient.exit.i, %if.then.i.i, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %if.then.i.i ], [ 0, %moduleGetReplyClient.exit.i ], [ 0, %if.then2.i ], [ 0, %if.then11.i ], [ 0, %if.else20.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithNullArray(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyNullArray(ptr noundef nonnull %2) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyNullArray(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithEmptyArray(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  %3 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 12), align 8
  tail call void @addReply(ptr noundef nonnull %2, ptr noundef %3) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleReplySetCollectionLength(ptr nocapture noundef %ctx, i64 noundef %len, i32 noundef %type) local_unnamed_addr #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %if.end29, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.end29, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  %postponed_arrays_count = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 9
  %3 = load i32, ptr %postponed_arrays_count, align 8
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %do.body, label %if.end6

do.body:                                          ; preds = %if.end
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3 = icmp sgt i32 %4, 3
  br i1 %cmp3, label %if.end29, label %if.end5

if.end5:                                          ; preds = %do.body
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %5 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 1
  %6 = load ptr, ptr %name, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.39, ptr noundef %6) #32
  br label %if.end29

if.end6:                                          ; preds = %if.end
  %dec = add nsw i32 %3, -1
  store i32 %dec, ptr %postponed_arrays_count, align 8
  switch i32 %type, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb9
    i32 3, label %sw.bb14
    i32 4, label %sw.bb19
  ]

sw.bb:                                            ; preds = %if.end6
  %postponed_arrays = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %7 = load ptr, ptr %postponed_arrays, align 8
  %idxprom = sext i32 %dec to i64
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 %idxprom
  %8 = load ptr, ptr %arrayidx, align 8
  tail call void @setDeferredArrayLen(ptr noundef nonnull %2, ptr noundef %8, i64 noundef %len) #32
  br label %sw.epilog

sw.bb9:                                           ; preds = %if.end6
  %postponed_arrays10 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %9 = load ptr, ptr %postponed_arrays10, align 8
  %idxprom12 = sext i32 %dec to i64
  %arrayidx13 = getelementptr inbounds ptr, ptr %9, i64 %idxprom12
  %10 = load ptr, ptr %arrayidx13, align 8
  tail call void @setDeferredMapLen(ptr noundef nonnull %2, ptr noundef %10, i64 noundef %len) #32
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end6
  %postponed_arrays15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %11 = load ptr, ptr %postponed_arrays15, align 8
  %idxprom17 = sext i32 %dec to i64
  %arrayidx18 = getelementptr inbounds ptr, ptr %11, i64 %idxprom17
  %12 = load ptr, ptr %arrayidx18, align 8
  tail call void @setDeferredSetLen(ptr noundef nonnull %2, ptr noundef %12, i64 noundef %len) #32
  br label %sw.epilog

sw.bb19:                                          ; preds = %if.end6
  %postponed_arrays20 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %13 = load ptr, ptr %postponed_arrays20, align 8
  %idxprom22 = sext i32 %dec to i64
  %arrayidx23 = getelementptr inbounds ptr, ptr %13, i64 %idxprom22
  %14 = load ptr, ptr %arrayidx23, align 8
  tail call void @setDeferredAttributeLen(ptr noundef nonnull %2, ptr noundef %14, i64 noundef %len) #32
  br label %sw.epilog

sw.default:                                       ; preds = %if.end6
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 3256, ptr noundef nonnull @.str.38, i32 noundef %type) #32
  tail call void @abort() #35
  unreachable

sw.epilog:                                        ; preds = %sw.bb19, %sw.bb14, %sw.bb9, %sw.bb
  %15 = load i32, ptr %postponed_arrays_count, align 8
  %cmp25 = icmp eq i32 %15, 0
  br i1 %cmp25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %sw.epilog
  %postponed_arrays27 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %16 = load ptr, ptr %postponed_arrays27, align 8
  tail call void @zfree(ptr noundef %16) #32
  store ptr null, ptr %postponed_arrays27, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.then.i, %if.end5, %do.body, %moduleGetReplyClient.exit, %if.then26, %sw.epilog
  ret void
}

declare void @setDeferredArrayLen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

declare void @setDeferredMapLen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

declare void @setDeferredSetLen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

declare void @setDeferredAttributeLen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_ReplySetArrayLength(ptr nocapture noundef %ctx, i64 noundef %len) #0 {
entry:
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %0, 16
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.else4.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %blocked_client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i.i, label %moduleReplySetCollectionLength.exit, label %if.then2.i.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  %reply_client.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit.i

if.else4.i.i:                                     ; preds = %entry
  %client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit.i

moduleGetReplyClient.exit.i:                      ; preds = %if.else4.i.i, %if.then2.i.i
  %client.sink.i.i = phi ptr [ %client.i.i, %if.else4.i.i ], [ %reply_client.i.i, %if.then2.i.i ]
  %2 = load ptr, ptr %client.sink.i.i, align 8
  %cmp.i = icmp eq ptr %2, null
  br i1 %cmp.i, label %moduleReplySetCollectionLength.exit, label %if.end.i

if.end.i:                                         ; preds = %moduleGetReplyClient.exit.i
  %postponed_arrays_count.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 9
  %3 = load i32, ptr %postponed_arrays_count.i, align 8
  %cmp1.i = icmp eq i32 %3, 0
  br i1 %cmp1.i, label %do.body.i, label %if.end6.i

do.body.i:                                        ; preds = %if.end.i
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3.i = icmp sgt i32 %4, 3
  br i1 %cmp3.i, label %moduleReplySetCollectionLength.exit, label %if.end5.i

if.end5.i:                                        ; preds = %do.body.i
  %module.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %5 = load ptr, ptr %module.i, align 8
  %name.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 1
  %6 = load ptr, ptr %name.i, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.39, ptr noundef %6) #32
  br label %moduleReplySetCollectionLength.exit

if.end6.i:                                        ; preds = %if.end.i
  %dec.i = add nsw i32 %3, -1
  store i32 %dec.i, ptr %postponed_arrays_count.i, align 8
  %postponed_arrays.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %7 = load ptr, ptr %postponed_arrays.i, align 8
  %idxprom.i = sext i32 %dec.i to i64
  %arrayidx.i = getelementptr inbounds ptr, ptr %7, i64 %idxprom.i
  %8 = load ptr, ptr %arrayidx.i, align 8
  tail call void @setDeferredArrayLen(ptr noundef nonnull %2, ptr noundef %8, i64 noundef %len) #32
  %9 = load i32, ptr %postponed_arrays_count.i, align 8
  %cmp25.i = icmp eq i32 %9, 0
  br i1 %cmp25.i, label %if.then26.i, label %moduleReplySetCollectionLength.exit

if.then26.i:                                      ; preds = %if.end6.i
  %10 = load ptr, ptr %postponed_arrays.i, align 8
  tail call void @zfree(ptr noundef %10) #32
  store ptr null, ptr %postponed_arrays.i, align 8
  br label %moduleReplySetCollectionLength.exit

moduleReplySetCollectionLength.exit:              ; preds = %if.then.i.i, %moduleGetReplyClient.exit.i, %do.body.i, %if.end5.i, %if.end6.i, %if.then26.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ReplySetMapLength(ptr nocapture noundef %ctx, i64 noundef %len) #0 {
entry:
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %0, 16
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.else4.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %blocked_client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i.i, label %moduleReplySetCollectionLength.exit, label %if.then2.i.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  %reply_client.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit.i

if.else4.i.i:                                     ; preds = %entry
  %client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit.i

moduleGetReplyClient.exit.i:                      ; preds = %if.else4.i.i, %if.then2.i.i
  %client.sink.i.i = phi ptr [ %client.i.i, %if.else4.i.i ], [ %reply_client.i.i, %if.then2.i.i ]
  %2 = load ptr, ptr %client.sink.i.i, align 8
  %cmp.i = icmp eq ptr %2, null
  br i1 %cmp.i, label %moduleReplySetCollectionLength.exit, label %if.end.i

if.end.i:                                         ; preds = %moduleGetReplyClient.exit.i
  %postponed_arrays_count.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 9
  %3 = load i32, ptr %postponed_arrays_count.i, align 8
  %cmp1.i = icmp eq i32 %3, 0
  br i1 %cmp1.i, label %do.body.i, label %if.end6.i

do.body.i:                                        ; preds = %if.end.i
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3.i = icmp sgt i32 %4, 3
  br i1 %cmp3.i, label %moduleReplySetCollectionLength.exit, label %if.end5.i

if.end5.i:                                        ; preds = %do.body.i
  %module.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %5 = load ptr, ptr %module.i, align 8
  %name.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 1
  %6 = load ptr, ptr %name.i, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.39, ptr noundef %6) #32
  br label %moduleReplySetCollectionLength.exit

if.end6.i:                                        ; preds = %if.end.i
  %dec.i = add nsw i32 %3, -1
  store i32 %dec.i, ptr %postponed_arrays_count.i, align 8
  %postponed_arrays10.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %7 = load ptr, ptr %postponed_arrays10.i, align 8
  %idxprom12.i = sext i32 %dec.i to i64
  %arrayidx13.i = getelementptr inbounds ptr, ptr %7, i64 %idxprom12.i
  %8 = load ptr, ptr %arrayidx13.i, align 8
  tail call void @setDeferredMapLen(ptr noundef nonnull %2, ptr noundef %8, i64 noundef %len) #32
  %9 = load i32, ptr %postponed_arrays_count.i, align 8
  %cmp25.i = icmp eq i32 %9, 0
  br i1 %cmp25.i, label %if.then26.i, label %moduleReplySetCollectionLength.exit

if.then26.i:                                      ; preds = %if.end6.i
  %10 = load ptr, ptr %postponed_arrays10.i, align 8
  tail call void @zfree(ptr noundef %10) #32
  store ptr null, ptr %postponed_arrays10.i, align 8
  br label %moduleReplySetCollectionLength.exit

moduleReplySetCollectionLength.exit:              ; preds = %if.then.i.i, %moduleGetReplyClient.exit.i, %do.body.i, %if.end5.i, %if.end6.i, %if.then26.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ReplySetSetLength(ptr nocapture noundef %ctx, i64 noundef %len) #0 {
entry:
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %0, 16
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.else4.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %blocked_client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i.i, label %moduleReplySetCollectionLength.exit, label %if.then2.i.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  %reply_client.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit.i

if.else4.i.i:                                     ; preds = %entry
  %client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit.i

moduleGetReplyClient.exit.i:                      ; preds = %if.else4.i.i, %if.then2.i.i
  %client.sink.i.i = phi ptr [ %client.i.i, %if.else4.i.i ], [ %reply_client.i.i, %if.then2.i.i ]
  %2 = load ptr, ptr %client.sink.i.i, align 8
  %cmp.i = icmp eq ptr %2, null
  br i1 %cmp.i, label %moduleReplySetCollectionLength.exit, label %if.end.i

if.end.i:                                         ; preds = %moduleGetReplyClient.exit.i
  %postponed_arrays_count.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 9
  %3 = load i32, ptr %postponed_arrays_count.i, align 8
  %cmp1.i = icmp eq i32 %3, 0
  br i1 %cmp1.i, label %do.body.i, label %if.end6.i

do.body.i:                                        ; preds = %if.end.i
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3.i = icmp sgt i32 %4, 3
  br i1 %cmp3.i, label %moduleReplySetCollectionLength.exit, label %if.end5.i

if.end5.i:                                        ; preds = %do.body.i
  %module.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %5 = load ptr, ptr %module.i, align 8
  %name.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 1
  %6 = load ptr, ptr %name.i, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.39, ptr noundef %6) #32
  br label %moduleReplySetCollectionLength.exit

if.end6.i:                                        ; preds = %if.end.i
  %dec.i = add nsw i32 %3, -1
  store i32 %dec.i, ptr %postponed_arrays_count.i, align 8
  %postponed_arrays15.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %7 = load ptr, ptr %postponed_arrays15.i, align 8
  %idxprom17.i = sext i32 %dec.i to i64
  %arrayidx18.i = getelementptr inbounds ptr, ptr %7, i64 %idxprom17.i
  %8 = load ptr, ptr %arrayidx18.i, align 8
  tail call void @setDeferredSetLen(ptr noundef nonnull %2, ptr noundef %8, i64 noundef %len) #32
  %9 = load i32, ptr %postponed_arrays_count.i, align 8
  %cmp25.i = icmp eq i32 %9, 0
  br i1 %cmp25.i, label %if.then26.i, label %moduleReplySetCollectionLength.exit

if.then26.i:                                      ; preds = %if.end6.i
  %10 = load ptr, ptr %postponed_arrays15.i, align 8
  tail call void @zfree(ptr noundef %10) #32
  store ptr null, ptr %postponed_arrays15.i, align 8
  br label %moduleReplySetCollectionLength.exit

moduleReplySetCollectionLength.exit:              ; preds = %if.then.i.i, %moduleGetReplyClient.exit.i, %do.body.i, %if.end5.i, %if.end6.i, %if.then26.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ReplySetAttributeLength(ptr nocapture noundef %ctx, i64 noundef %len) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %resp = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 3
  %1 = load i32, ptr %resp, align 8
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %2 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %2, 16
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end
  %blocked_client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %3 = load ptr, ptr %blocked_client.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i.i, label %return, label %moduleGetReplyClient.exit.i

moduleGetReplyClient.exit.i:                      ; preds = %if.then.i.i
  %reply_client.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %3, i64 0, i32 9
  %.pre = load ptr, ptr %reply_client.i.i, align 8
  %cmp.i = icmp eq ptr %.pre, null
  br i1 %cmp.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.end, %moduleGetReplyClient.exit.i
  %4 = phi ptr [ %.pre, %moduleGetReplyClient.exit.i ], [ %0, %if.end ]
  %postponed_arrays_count.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 9
  %5 = load i32, ptr %postponed_arrays_count.i, align 8
  %cmp1.i = icmp eq i32 %5, 0
  br i1 %cmp1.i, label %do.body.i, label %if.end6.i

do.body.i:                                        ; preds = %if.end.i
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3.i = icmp sgt i32 %6, 3
  br i1 %cmp3.i, label %return, label %if.end5.i

if.end5.i:                                        ; preds = %do.body.i
  %module.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %7 = load ptr, ptr %module.i, align 8
  %name.i = getelementptr inbounds %struct.RedisModule, ptr %7, i64 0, i32 1
  %8 = load ptr, ptr %name.i, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.39, ptr noundef %8) #32
  br label %return

if.end6.i:                                        ; preds = %if.end.i
  %dec.i = add nsw i32 %5, -1
  store i32 %dec.i, ptr %postponed_arrays_count.i, align 8
  %postponed_arrays20.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 8
  %9 = load ptr, ptr %postponed_arrays20.i, align 8
  %idxprom22.i = sext i32 %dec.i to i64
  %arrayidx23.i = getelementptr inbounds ptr, ptr %9, i64 %idxprom22.i
  %10 = load ptr, ptr %arrayidx23.i, align 8
  tail call void @setDeferredAttributeLen(ptr noundef nonnull %4, ptr noundef %10, i64 noundef %len) #32
  %11 = load i32, ptr %postponed_arrays_count.i, align 8
  %cmp25.i = icmp eq i32 %11, 0
  br i1 %cmp25.i, label %if.then26.i, label %return

if.then26.i:                                      ; preds = %if.end6.i
  %12 = load ptr, ptr %postponed_arrays20.i, align 8
  tail call void @zfree(ptr noundef %12) #32
  store ptr null, ptr %postponed_arrays20.i, align 8
  br label %return

return:                                           ; preds = %if.then26.i, %if.end6.i, %if.end5.i, %do.body.i, %moduleGetReplyClient.exit.i, %if.then.i.i, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithStringBuffer(ptr nocapture noundef readonly %ctx, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyBulkCBuffer(ptr noundef nonnull %2, ptr noundef %buf, i64 noundef %len) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyBulkCBuffer(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithCString(ptr nocapture noundef readonly %ctx, ptr noundef %buf) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyBulkCString(ptr noundef nonnull %2, ptr noundef %buf) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyBulkCString(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithString(ptr nocapture noundef readonly %ctx, ptr noundef %str) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyBulk(ptr noundef nonnull %2, ptr noundef %str) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyBulk(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithEmptyString(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  %3 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 2), align 8
  tail call void @addReply(ptr noundef nonnull %2, ptr noundef %3) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithVerbatimStringType(ptr nocapture noundef readonly %ctx, ptr noundef %buf, i64 noundef %len, ptr noundef %ext) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyVerbatim(ptr noundef nonnull %2, ptr noundef %buf, i64 noundef %len, ptr noundef %ext) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyVerbatim(ptr noundef, ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithVerbatimString(ptr nocapture noundef readonly %ctx, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %0, 16
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.else4.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %entry
  %blocked_client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i.i, label %RM_ReplyWithVerbatimStringType.exit, label %if.then2.i.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  %reply_client.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit.i

if.else4.i.i:                                     ; preds = %entry
  %client.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit.i

moduleGetReplyClient.exit.i:                      ; preds = %if.else4.i.i, %if.then2.i.i
  %client.sink.i.i = phi ptr [ %client.i.i, %if.else4.i.i ], [ %reply_client.i.i, %if.then2.i.i ]
  %2 = load ptr, ptr %client.sink.i.i, align 8
  %cmp.i = icmp eq ptr %2, null
  br i1 %cmp.i, label %RM_ReplyWithVerbatimStringType.exit, label %if.end.i

if.end.i:                                         ; preds = %moduleGetReplyClient.exit.i
  tail call void @addReplyVerbatim(ptr noundef nonnull %2, ptr noundef %buf, i64 noundef %len, ptr noundef nonnull @.str.40) #32
  br label %RM_ReplyWithVerbatimStringType.exit

RM_ReplyWithVerbatimStringType.exit:              ; preds = %if.then.i.i, %moduleGetReplyClient.exit.i, %if.end.i
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithNull(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyNull(ptr noundef nonnull %2) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyNull(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithBool(ptr nocapture noundef readonly %ctx, i32 noundef %b) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyBool(ptr noundef nonnull %2, i32 noundef %b) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyBool(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithCallReply(ptr nocapture noundef readonly %ctx, ptr noundef %reply) #0 {
entry:
  %proto_len = alloca i64, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  %resp = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 3
  %3 = load i32, ptr %resp, align 8
  %cmp1 = icmp eq i32 %3, 2
  br i1 %cmp1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %call2 = tail call i32 @callReplyIsResp3(ptr noundef %reply) #32
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %if.end4, label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %call5 = call ptr @callReplyGetProto(ptr noundef %reply, ptr noundef nonnull %proto_len) #32
  %4 = load i64, ptr %proto_len, align 8
  call void @addReplyProto(ptr noundef nonnull %2, ptr noundef %call5, i64 noundef %4) #32
  %call6 = call ptr @callReplyDeferredErrorList(ptr noundef %reply) #32
  %tobool7.not = icmp eq ptr %call6, null
  br i1 %tobool7.not, label %return, label %if.then8

if.then8:                                         ; preds = %if.end4
  call void @deferredAfterErrorReply(ptr noundef nonnull %2, ptr noundef nonnull %call6) #32
  br label %return

return:                                           ; preds = %if.then.i, %if.end4, %if.then8, %land.lhs.true, %moduleGetReplyClient.exit
  %retval.0 = phi i32 [ 0, %moduleGetReplyClient.exit ], [ 1, %land.lhs.true ], [ 0, %if.then8 ], [ 0, %if.end4 ], [ 0, %if.then.i ]
  ret i32 %retval.0
}

declare i32 @callReplyIsResp3(ptr noundef) local_unnamed_addr #1

declare ptr @callReplyGetProto(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @callReplyDeferredErrorList(ptr noundef) local_unnamed_addr #1

declare void @deferredAfterErrorReply(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithDouble(ptr nocapture noundef readonly %ctx, double noundef %d) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyDouble(ptr noundef nonnull %2, double noundef %d) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyDouble(ptr noundef, double noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithBigNumber(ptr nocapture noundef readonly %ctx, ptr noundef %bignum, i64 noundef %len) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyBigNum(ptr noundef nonnull %2, ptr noundef %bignum, i64 noundef %len) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyBigNum(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplyWithLongDouble(ptr nocapture noundef readonly %ctx, x86_fp80 noundef %ld) #0 {
entry:
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 16
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.else4.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %blocked_client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %1 = load ptr, ptr %blocked_client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %if.then.i
  %reply_client.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 9
  br label %moduleGetReplyClient.exit

if.else4.i:                                       ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  br label %moduleGetReplyClient.exit

moduleGetReplyClient.exit:                        ; preds = %if.then2.i, %if.else4.i
  %client.sink.i = phi ptr [ %client.i, %if.else4.i ], [ %reply_client.i, %if.then2.i ]
  %2 = load ptr, ptr %client.sink.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %moduleGetReplyClient.exit
  tail call void @addReplyHumanLongDouble(ptr noundef nonnull %2, x86_fp80 noundef %ld) #32
  br label %return

return:                                           ; preds = %if.then.i, %moduleGetReplyClient.exit, %if.end
  ret i32 0
}

declare void @addReplyHumanLongDouble(ptr noundef, x86_fp80 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_Replicate(ptr nocapture noundef readonly %ctx, ptr noundef %cmdname, ptr nocapture noundef readonly %fmt, ...) #0 {
entry:
  %argc = alloca i32, align 4
  %flags = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store i32 0, ptr %argc, align 4
  store i32 0, ptr %flags, align 4
  %call = tail call ptr @lookupCommandByCString(ptr noundef %cmdname) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @llvm.va_start(ptr nonnull %ap)
  %call2 = call ptr @moduleCreateArgvFromUserFormat(ptr noundef %cmdname, ptr noundef %fmt, ptr noundef nonnull %argc, ptr noundef nonnull %flags, ptr noundef nonnull %ap)
  call void @llvm.va_end(ptr nonnull %ap)
  %cmp = icmp eq ptr %call2, null
  br i1 %cmp, label %return, label %if.end5

if.end5:                                          ; preds = %if.end
  %0 = load i32, ptr %flags, align 4
  %and = lshr i32 %0, 1
  %1 = and i32 %and, 3
  %target.1 = xor i32 %1, 3
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 4
  %3 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %3, i64 0, i32 6
  %4 = load i32, ptr %id, align 8
  %5 = load i32, ptr %argc, align 4
  call void @alsoPropagate(i32 noundef %4, ptr noundef nonnull %call2, i32 noundef %5, i32 noundef %target.1) #32
  %6 = load i32, ptr %argc, align 4
  %cmp149 = icmp sgt i32 %6, 0
  br i1 %cmp149, label %for.body, label %for.end

for.body:                                         ; preds = %if.end5, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %if.end5 ]
  %arrayidx = getelementptr inbounds ptr, ptr %call2, i64 %indvars.iv
  %7 = load ptr, ptr %arrayidx, align 8
  call void @decrRefCount(ptr noundef %7) #32
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %8 = load i32, ptr %argc, align 4
  %9 = sext i32 %8 to i64
  %cmp14 = icmp slt i64 %indvars.iv.next, %9
  br i1 %cmp14, label %for.body, label %for.end, !llvm.loop !30

for.end:                                          ; preds = %for.body, %if.end5
  call void @zfree(ptr noundef nonnull %call2) #32
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  %inc15 = add nsw i64 %10, 1
  store i64 %inc15, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  br label %return

return:                                           ; preds = %if.end, %entry, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ 1, %entry ], [ 1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleCreateArgvFromUserFormat(ptr noundef %cmdname, ptr nocapture noundef readonly %fmt, ptr noundef writeonly %argcp, ptr noundef %flags, ptr nocapture noundef %ap) local_unnamed_addr #0 {
entry:
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %fmt) #36
  %0 = trunc i64 %call to i32
  %conv = add i32 %0, 1
  %conv1 = sext i32 %conv to i64
  %mul = shl nsw i64 %conv1, 3
  %call2 = tail call ptr @zrealloc(ptr noundef null, i64 noundef %mul) #34
  %call3 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %cmdname) #36
  %call4 = tail call ptr @createStringObject(ptr noundef %cmdname, i64 noundef %call3) #32
  store ptr %call4, ptr %call2, align 8
  %tobool231.not = icmp eq ptr %flags, null
  %overflow_arg_area_p98 = getelementptr inbounds %struct.__va_list_tag, ptr %ap, i64 0, i32 2
  %1 = getelementptr inbounds %struct.__va_list_tag, ptr %ap, i64 0, i32 3
  br label %while.cond

while.cond:                                       ; preds = %if.end252, %entry
  %p.0 = phi ptr [ %fmt, %entry ], [ %incdec.ptr, %if.end252 ]
  %argv.0 = phi ptr [ %call2, %entry ], [ %argv.1, %if.end252 ]
  %argv_size.0 = phi i32 [ %conv, %entry ], [ %argv_size.1, %if.end252 ]
  %argc.0 = phi i32 [ 1, %entry ], [ %argc.2, %if.end252 ]
  %2 = load i8, ptr %p.0, align 1
  switch i8 %2, label %for.cond256.preheader [
    i8 0, label %while.end
    i8 99, label %if.then
    i8 115, label %if.then14
    i8 98, label %if.then40
    i8 108, label %if.then71
    i8 118, label %if.then91
    i8 33, label %if.then132
    i8 65, label %if.then140
    i8 82, label %if.then149
    i8 51, label %if.then158
    i8 48, label %if.then167
    i8 67, label %if.then176
    i8 83, label %if.then185
    i8 87, label %if.then194
    i8 77, label %if.then203
    i8 69, label %if.then212
    i8 68, label %if.then221
    i8 75, label %if.then230
  ]

for.cond256.preheader:                            ; preds = %while.cond
  %cmp25787 = icmp sgt i32 %argc.0, 0
  br i1 %cmp25787, label %for.body259.preheader, label %for.end264

for.body259.preheader:                            ; preds = %for.cond256.preheader
  %wide.trip.count = zext nneg i32 %argc.0 to i64
  br label %for.body259

if.then:                                          ; preds = %while.cond
  %gp_offset = load i32, ptr %ap, align 8
  %fits_in_gp = icmp ult i32 %gp_offset, 41
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %if.then
  %reg_save_area = load ptr, ptr %1, align 8
  %3 = zext nneg i32 %gp_offset to i64
  %4 = getelementptr i8, ptr %reg_save_area, i64 %3
  %5 = add nuw nsw i32 %gp_offset, 8
  store i32 %5, ptr %ap, align 8
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %if.then
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p98, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i64 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p98, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %4, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %6 = load ptr, ptr %vaarg.addr, align 8
  %call7 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %6) #36
  %call8 = tail call ptr @createStringObject(ptr noundef %6, i64 noundef %call7) #32
  %inc9 = add nsw i32 %argc.0, 1
  %idxprom = sext i32 %argc.0 to i64
  %arrayidx10 = getelementptr inbounds ptr, ptr %argv.0, i64 %idxprom
  store ptr %call8, ptr %arrayidx10, align 8
  br label %if.end252

if.then14:                                        ; preds = %while.cond
  %gp_offset16 = load i32, ptr %ap, align 8
  %fits_in_gp17 = icmp ult i32 %gp_offset16, 41
  br i1 %fits_in_gp17, label %vaarg.in_reg18, label %vaarg.in_mem20

vaarg.in_reg18:                                   ; preds = %if.then14
  %reg_save_area19 = load ptr, ptr %1, align 8
  %7 = zext nneg i32 %gp_offset16 to i64
  %8 = getelementptr i8, ptr %reg_save_area19, i64 %7
  %9 = add nuw nsw i32 %gp_offset16, 8
  store i32 %9, ptr %ap, align 8
  br label %vaarg.end24

vaarg.in_mem20:                                   ; preds = %if.then14
  %overflow_arg_area22 = load ptr, ptr %overflow_arg_area_p98, align 8
  %overflow_arg_area.next23 = getelementptr i8, ptr %overflow_arg_area22, i64 8
  store ptr %overflow_arg_area.next23, ptr %overflow_arg_area_p98, align 8
  br label %vaarg.end24

vaarg.end24:                                      ; preds = %vaarg.in_mem20, %vaarg.in_reg18
  %vaarg.addr25 = phi ptr [ %8, %vaarg.in_reg18 ], [ %overflow_arg_area22, %vaarg.in_mem20 ]
  %10 = load ptr, ptr %vaarg.addr25, align 8
  %refcount = getelementptr inbounds %struct.redisObject, ptr %10, i64 0, i32 1
  %11 = load i32, ptr %refcount, align 4
  %cmp26 = icmp eq i32 %11, 2147483646
  br i1 %cmp26, label %if.then28, label %if.else32

if.then28:                                        ; preds = %vaarg.end24
  %ptr = getelementptr inbounds %struct.redisObject, ptr %10, i64 0, i32 2
  %12 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %12, i64 -1
  %13 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %13 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then28
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then28
  %add.ptr.i = getelementptr inbounds i8, ptr %12, i64 -3
  %14 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %14 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then28
  %add.ptr6.i = getelementptr inbounds i8, ptr %12, i64 -5
  %15 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %15 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then28
  %add.ptr10.i = getelementptr inbounds i8, ptr %12, i64 -9
  %16 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %16 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then28
  %add.ptr14.i = getelementptr inbounds i8, ptr %12, i64 -17
  %17 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then28, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %17, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then28 ]
  %call31 = tail call ptr @createStringObject(ptr noundef nonnull %12, i64 noundef %retval.0.i) #32
  br label %if.end

if.else32:                                        ; preds = %vaarg.end24
  tail call void @incrRefCount(ptr noundef nonnull %10) #32
  br label %if.end

if.end:                                           ; preds = %if.else32, %sdslen.exit
  %obj.0 = phi ptr [ %call31, %sdslen.exit ], [ %10, %if.else32 ]
  %inc33 = add nsw i32 %argc.0, 1
  %idxprom34 = sext i32 %argc.0 to i64
  %arrayidx35 = getelementptr inbounds ptr, ptr %argv.0, i64 %idxprom34
  store ptr %obj.0, ptr %arrayidx35, align 8
  br label %if.end252

if.then40:                                        ; preds = %while.cond
  %gp_offset42 = load i32, ptr %ap, align 8
  %fits_in_gp43 = icmp ult i32 %gp_offset42, 41
  br i1 %fits_in_gp43, label %vaarg.end50, label %vaarg.end50.thread

vaarg.end50.thread:                               ; preds = %if.then40
  %overflow_arg_area48 = load ptr, ptr %overflow_arg_area_p98, align 8
  %overflow_arg_area.next49 = getelementptr i8, ptr %overflow_arg_area48, i64 8
  store ptr %overflow_arg_area.next49, ptr %overflow_arg_area_p98, align 8
  %18 = load ptr, ptr %overflow_arg_area48, align 8
  br label %vaarg.in_mem57

vaarg.end50:                                      ; preds = %if.then40
  %reg_save_area45 = load ptr, ptr %1, align 8
  %19 = zext nneg i32 %gp_offset42 to i64
  %20 = getelementptr i8, ptr %reg_save_area45, i64 %19
  %21 = add nuw nsw i32 %gp_offset42, 8
  store i32 %21, ptr %ap, align 8
  %22 = load ptr, ptr %20, align 8
  %fits_in_gp54 = icmp ult i32 %gp_offset42, 33
  br i1 %fits_in_gp54, label %vaarg.in_reg55, label %vaarg.in_mem57

vaarg.in_reg55:                                   ; preds = %vaarg.end50
  %reg_save_area56 = load ptr, ptr %1, align 8
  %23 = zext nneg i32 %21 to i64
  %24 = getelementptr i8, ptr %reg_save_area56, i64 %23
  %25 = add nuw nsw i32 %gp_offset42, 16
  store i32 %25, ptr %ap, align 8
  br label %vaarg.end61

vaarg.in_mem57:                                   ; preds = %vaarg.end50.thread, %vaarg.end50
  %26 = phi ptr [ %18, %vaarg.end50.thread ], [ %22, %vaarg.end50 ]
  %overflow_arg_area59 = load ptr, ptr %overflow_arg_area_p98, align 8
  %overflow_arg_area.next60 = getelementptr i8, ptr %overflow_arg_area59, i64 8
  store ptr %overflow_arg_area.next60, ptr %overflow_arg_area_p98, align 8
  br label %vaarg.end61

vaarg.end61:                                      ; preds = %vaarg.in_mem57, %vaarg.in_reg55
  %27 = phi ptr [ %22, %vaarg.in_reg55 ], [ %26, %vaarg.in_mem57 ]
  %vaarg.addr62 = phi ptr [ %24, %vaarg.in_reg55 ], [ %overflow_arg_area59, %vaarg.in_mem57 ]
  %28 = load i64, ptr %vaarg.addr62, align 8
  %call63 = tail call ptr @createStringObject(ptr noundef %27, i64 noundef %28) #32
  %inc64 = add nsw i32 %argc.0, 1
  %idxprom65 = sext i32 %argc.0 to i64
  %arrayidx66 = getelementptr inbounds ptr, ptr %argv.0, i64 %idxprom65
  store ptr %call63, ptr %arrayidx66, align 8
  br label %if.end252

if.then71:                                        ; preds = %while.cond
  %gp_offset73 = load i32, ptr %ap, align 8
  %fits_in_gp74 = icmp ult i32 %gp_offset73, 41
  br i1 %fits_in_gp74, label %vaarg.in_reg75, label %vaarg.in_mem77

vaarg.in_reg75:                                   ; preds = %if.then71
  %reg_save_area76 = load ptr, ptr %1, align 8
  %29 = zext nneg i32 %gp_offset73 to i64
  %30 = getelementptr i8, ptr %reg_save_area76, i64 %29
  %31 = add nuw nsw i32 %gp_offset73, 8
  store i32 %31, ptr %ap, align 8
  br label %vaarg.end81

vaarg.in_mem77:                                   ; preds = %if.then71
  %overflow_arg_area79 = load ptr, ptr %overflow_arg_area_p98, align 8
  %overflow_arg_area.next80 = getelementptr i8, ptr %overflow_arg_area79, i64 8
  store ptr %overflow_arg_area.next80, ptr %overflow_arg_area_p98, align 8
  br label %vaarg.end81

vaarg.end81:                                      ; preds = %vaarg.in_mem77, %vaarg.in_reg75
  %vaarg.addr82 = phi ptr [ %30, %vaarg.in_reg75 ], [ %overflow_arg_area79, %vaarg.in_mem77 ]
  %32 = load i64, ptr %vaarg.addr82, align 8
  %call83 = tail call ptr @createStringObjectFromLongLongWithSds(i64 noundef %32) #32
  %inc84 = add nsw i32 %argc.0, 1
  %idxprom85 = sext i32 %argc.0 to i64
  %arrayidx86 = getelementptr inbounds ptr, ptr %argv.0, i64 %idxprom85
  store ptr %call83, ptr %arrayidx86, align 8
  br label %if.end252

if.then91:                                        ; preds = %while.cond
  %gp_offset93 = load i32, ptr %ap, align 8
  %fits_in_gp94 = icmp ult i32 %gp_offset93, 41
  br i1 %fits_in_gp94, label %vaarg.end101, label %vaarg.end101.thread

vaarg.end101.thread:                              ; preds = %if.then91
  %overflow_arg_area99 = load ptr, ptr %overflow_arg_area_p98, align 8
  %overflow_arg_area.next100 = getelementptr i8, ptr %overflow_arg_area99, i64 8
  store ptr %overflow_arg_area.next100, ptr %overflow_arg_area_p98, align 8
  %33 = load ptr, ptr %overflow_arg_area99, align 8
  br label %vaarg.in_mem108

vaarg.end101:                                     ; preds = %if.then91
  %reg_save_area96 = load ptr, ptr %1, align 8
  %34 = zext nneg i32 %gp_offset93 to i64
  %35 = getelementptr i8, ptr %reg_save_area96, i64 %34
  %36 = add nuw nsw i32 %gp_offset93, 8
  store i32 %36, ptr %ap, align 8
  %37 = load ptr, ptr %35, align 8
  %fits_in_gp105 = icmp ult i32 %gp_offset93, 33
  br i1 %fits_in_gp105, label %vaarg.in_reg106, label %vaarg.in_mem108

vaarg.in_reg106:                                  ; preds = %vaarg.end101
  %reg_save_area107 = load ptr, ptr %1, align 8
  %38 = zext nneg i32 %36 to i64
  %39 = getelementptr i8, ptr %reg_save_area107, i64 %38
  %40 = add nuw nsw i32 %gp_offset93, 16
  store i32 %40, ptr %ap, align 8
  br label %vaarg.end112

vaarg.in_mem108:                                  ; preds = %vaarg.end101.thread, %vaarg.end101
  %41 = phi ptr [ %33, %vaarg.end101.thread ], [ %37, %vaarg.end101 ]
  %overflow_arg_area110 = load ptr, ptr %overflow_arg_area_p98, align 8
  %overflow_arg_area.next111 = getelementptr i8, ptr %overflow_arg_area110, i64 8
  store ptr %overflow_arg_area.next111, ptr %overflow_arg_area_p98, align 8
  br label %vaarg.end112

vaarg.end112:                                     ; preds = %vaarg.in_mem108, %vaarg.in_reg106
  %42 = phi ptr [ %37, %vaarg.in_reg106 ], [ %41, %vaarg.in_mem108 ]
  %vaarg.addr113 = phi ptr [ %39, %vaarg.in_reg106 ], [ %overflow_arg_area110, %vaarg.in_mem108 ]
  %43 = load i64, ptr %vaarg.addr113, align 8
  %44 = trunc i64 %43 to i32
  %45 = add i32 %argv_size.0, -1
  %conv116 = add i32 %45, %44
  %conv117 = sext i32 %conv116 to i64
  %mul118 = shl nsw i64 %conv117, 3
  %call119 = tail call ptr @zrealloc(ptr noundef %argv.0, i64 noundef %mul118) #34
  %cmp12084.not = icmp eq i64 %43, 0
  br i1 %cmp12084.not, label %if.end252, label %for.body.preheader

for.body.preheader:                               ; preds = %vaarg.end112
  %46 = sext i32 %argc.0 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ %46, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %i.086 = phi i64 [ 0, %for.body.preheader ], [ %inc127, %for.body ]
  %arrayidx122 = getelementptr inbounds ptr, ptr %42, i64 %i.086
  %47 = load ptr, ptr %arrayidx122, align 8
  tail call void @incrRefCount(ptr noundef %47) #32
  %48 = load ptr, ptr %arrayidx122, align 8
  %indvars.iv.next = add i64 %indvars.iv, 1
  %arrayidx126 = getelementptr inbounds ptr, ptr %call119, i64 %indvars.iv
  store ptr %48, ptr %arrayidx126, align 8
  %inc127 = add nuw i64 %i.086, 1
  %exitcond.not = icmp eq i64 %inc127, %43
  br i1 %exitcond.not, label %if.end252.loopexit, label %for.body, !llvm.loop !31

if.then132:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then134

if.then134:                                       ; preds = %if.then132
  %49 = load i32, ptr %flags, align 4
  %or = or i32 %49, 1
  store i32 %or, ptr %flags, align 4
  br label %if.end252

if.then140:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then142

if.then142:                                       ; preds = %if.then140
  %50 = load i32, ptr %flags, align 4
  %or143 = or i32 %50, 2
  store i32 %or143, ptr %flags, align 4
  br label %if.end252

if.then149:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then151

if.then151:                                       ; preds = %if.then149
  %51 = load i32, ptr %flags, align 4
  %or152 = or i32 %51, 4
  store i32 %or152, ptr %flags, align 4
  br label %if.end252

if.then158:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then160

if.then160:                                       ; preds = %if.then158
  %52 = load i32, ptr %flags, align 4
  %or161 = or i32 %52, 8
  store i32 %or161, ptr %flags, align 4
  br label %if.end252

if.then167:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then169

if.then169:                                       ; preds = %if.then167
  %53 = load i32, ptr %flags, align 4
  %or170 = or i32 %53, 16
  store i32 %or170, ptr %flags, align 4
  br label %if.end252

if.then176:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then178

if.then178:                                       ; preds = %if.then176
  %54 = load i32, ptr %flags, align 4
  %or179 = or i32 %54, 32
  store i32 %or179, ptr %flags, align 4
  br label %if.end252

if.then185:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then187

if.then187:                                       ; preds = %if.then185
  %55 = load i32, ptr %flags, align 4
  %or188 = or i32 %55, 64
  store i32 %or188, ptr %flags, align 4
  br label %if.end252

if.then194:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then196

if.then196:                                       ; preds = %if.then194
  %56 = load i32, ptr %flags, align 4
  %or197 = or i32 %56, 128
  store i32 %or197, ptr %flags, align 4
  br label %if.end252

if.then203:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then205

if.then205:                                       ; preds = %if.then203
  %57 = load i32, ptr %flags, align 4
  %or206 = or i32 %57, 512
  store i32 %or206, ptr %flags, align 4
  br label %if.end252

if.then212:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then214

if.then214:                                       ; preds = %if.then212
  %58 = load i32, ptr %flags, align 4
  %or215 = or i32 %58, 256
  store i32 %or215, ptr %flags, align 4
  br label %if.end252

if.then221:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then223

if.then223:                                       ; preds = %if.then221
  %59 = load i32, ptr %flags, align 4
  %or224 = or i32 %59, 1280
  store i32 %or224, ptr %flags, align 4
  br label %if.end252

if.then230:                                       ; preds = %while.cond
  br i1 %tobool231.not, label %if.end252, label %if.then232

if.then232:                                       ; preds = %if.then230
  %60 = load i32, ptr %flags, align 4
  %or233 = or i32 %60, 2048
  store i32 %or233, ptr %flags, align 4
  br label %if.end252

if.end252.loopexit:                               ; preds = %for.body
  %61 = trunc i64 %indvars.iv.next to i32
  br label %if.end252

if.end252:                                        ; preds = %if.end252.loopexit, %vaarg.end112, %if.end, %vaarg.end81, %if.then134, %if.then132, %if.then151, %if.then149, %if.then169, %if.then167, %if.then187, %if.then185, %if.then205, %if.then203, %if.then223, %if.then221, %if.then230, %if.then232, %if.then212, %if.then214, %if.then194, %if.then196, %if.then176, %if.then178, %if.then158, %if.then160, %if.then140, %if.then142, %vaarg.end61, %vaarg.end
  %argv.1 = phi ptr [ %argv.0, %vaarg.end ], [ %argv.0, %if.end ], [ %argv.0, %vaarg.end61 ], [ %argv.0, %vaarg.end81 ], [ %argv.0, %if.then134 ], [ %argv.0, %if.then132 ], [ %argv.0, %if.then142 ], [ %argv.0, %if.then140 ], [ %argv.0, %if.then151 ], [ %argv.0, %if.then149 ], [ %argv.0, %if.then160 ], [ %argv.0, %if.then158 ], [ %argv.0, %if.then169 ], [ %argv.0, %if.then167 ], [ %argv.0, %if.then178 ], [ %argv.0, %if.then176 ], [ %argv.0, %if.then187 ], [ %argv.0, %if.then185 ], [ %argv.0, %if.then196 ], [ %argv.0, %if.then194 ], [ %argv.0, %if.then205 ], [ %argv.0, %if.then203 ], [ %argv.0, %if.then214 ], [ %argv.0, %if.then212 ], [ %argv.0, %if.then223 ], [ %argv.0, %if.then221 ], [ %argv.0, %if.then232 ], [ %argv.0, %if.then230 ], [ %call119, %vaarg.end112 ], [ %call119, %if.end252.loopexit ]
  %argv_size.1 = phi i32 [ %argv_size.0, %vaarg.end ], [ %argv_size.0, %if.end ], [ %argv_size.0, %vaarg.end61 ], [ %argv_size.0, %vaarg.end81 ], [ %argv_size.0, %if.then134 ], [ %argv_size.0, %if.then132 ], [ %argv_size.0, %if.then142 ], [ %argv_size.0, %if.then140 ], [ %argv_size.0, %if.then151 ], [ %argv_size.0, %if.then149 ], [ %argv_size.0, %if.then160 ], [ %argv_size.0, %if.then158 ], [ %argv_size.0, %if.then169 ], [ %argv_size.0, %if.then167 ], [ %argv_size.0, %if.then178 ], [ %argv_size.0, %if.then176 ], [ %argv_size.0, %if.then187 ], [ %argv_size.0, %if.then185 ], [ %argv_size.0, %if.then196 ], [ %argv_size.0, %if.then194 ], [ %argv_size.0, %if.then205 ], [ %argv_size.0, %if.then203 ], [ %argv_size.0, %if.then214 ], [ %argv_size.0, %if.then212 ], [ %argv_size.0, %if.then223 ], [ %argv_size.0, %if.then221 ], [ %argv_size.0, %if.then232 ], [ %argv_size.0, %if.then230 ], [ %conv116, %vaarg.end112 ], [ %conv116, %if.end252.loopexit ]
  %argc.2 = phi i32 [ %inc9, %vaarg.end ], [ %inc33, %if.end ], [ %inc64, %vaarg.end61 ], [ %inc84, %vaarg.end81 ], [ %argc.0, %if.then134 ], [ %argc.0, %if.then132 ], [ %argc.0, %if.then142 ], [ %argc.0, %if.then140 ], [ %argc.0, %if.then151 ], [ %argc.0, %if.then149 ], [ %argc.0, %if.then160 ], [ %argc.0, %if.then158 ], [ %argc.0, %if.then169 ], [ %argc.0, %if.then167 ], [ %argc.0, %if.then178 ], [ %argc.0, %if.then176 ], [ %argc.0, %if.then187 ], [ %argc.0, %if.then185 ], [ %argc.0, %if.then196 ], [ %argc.0, %if.then194 ], [ %argc.0, %if.then205 ], [ %argc.0, %if.then203 ], [ %argc.0, %if.then214 ], [ %argc.0, %if.then212 ], [ %argc.0, %if.then223 ], [ %argc.0, %if.then221 ], [ %argc.0, %if.then232 ], [ %argc.0, %if.then230 ], [ %argc.0, %vaarg.end112 ], [ %61, %if.end252.loopexit ]
  %incdec.ptr = getelementptr inbounds i8, ptr %p.0, i64 1
  br label %while.cond, !llvm.loop !32

while.end:                                        ; preds = %while.cond
  %tobool253.not = icmp eq ptr %argcp, null
  br i1 %tobool253.not, label %return, label %if.then254

if.then254:                                       ; preds = %while.end
  store i32 %argc.0, ptr %argcp, align 4
  br label %return

for.body259:                                      ; preds = %for.body259.preheader, %for.body259
  %indvars.iv92 = phi i64 [ 0, %for.body259.preheader ], [ %indvars.iv.next93, %for.body259 ]
  %arrayidx261 = getelementptr inbounds ptr, ptr %argv.0, i64 %indvars.iv92
  %62 = load ptr, ptr %arrayidx261, align 8
  tail call void @decrRefCount(ptr noundef %62) #32
  %indvars.iv.next93 = add nuw nsw i64 %indvars.iv92, 1
  %exitcond95.not = icmp eq i64 %indvars.iv.next93, %wide.trip.count
  br i1 %exitcond95.not, label %for.end264, label %for.body259, !llvm.loop !33

for.end264:                                       ; preds = %for.body259, %for.cond256.preheader
  tail call void @zfree(ptr noundef %argv.0) #32
  br label %return

return:                                           ; preds = %while.end, %if.then254, %for.end264
  %retval.0 = phi ptr [ null, %for.end264 ], [ %argv.0, %if.then254 ], [ %argv.0, %while.end ]
  ret ptr %retval.0
}

declare void @alsoPropagate(i32 noundef, ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ReplicateVerbatim(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %1, i64 0, i32 6
  %2 = load i32, ptr %id, align 8
  %argv = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 12
  %3 = load ptr, ptr %argv, align 8
  %argc = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 11
  %4 = load i32, ptr %argc, align 8
  tail call void @alsoPropagate(i32 noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 3) #32
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  %inc = add nsw i64 %5, 1
  store i64 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i64 @RM_GetClientId(ptr nocapture noundef readonly %ctx) #11 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %0, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %1, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetClientUserNameById(ptr nocapture noundef %ctx, i64 noundef %id) #0 {
entry:
  %call = tail call ptr @lookupClientByID(i64 noundef %id) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call ptr @__errno_location() #37
  store i32 2, ptr %call1, align 4
  br label %return

if.end:                                           ; preds = %entry
  %user = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 20
  %0 = load ptr, ptr %user, align 8
  %cmp2 = icmp eq ptr %0, null
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call4, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %1 = load ptr, ptr %0, align 8
  %call8 = tail call ptr @sdsnew(ptr noundef %1) #32
  %call9 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call8) #32
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %2 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.end5
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %3 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %4 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %3, %4
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %3, 1
  %cmp4.i = icmp slt i32 %3, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %5 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %5, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %6 = phi i32 [ %3, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %7 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %6 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %8 = load ptr, ptr %amqueue12.i, align 8
  %9 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %9 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom17.i
  store ptr %call9, ptr %arrayidx18.i, align 8
  %10 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %10, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end11.i, %if.end5, %if.then3, %if.then
  %retval.0 = phi ptr [ null, %if.then ], [ null, %if.then3 ], [ %call9, %if.end5 ], [ %call9, %if.end11.i ]
  ret ptr %retval.0
}

declare ptr @lookupClientByID(i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @modulePopulateClientInfoStructure(ptr noundef %ci, ptr nocapture noundef readonly %client, i32 noundef %structver) local_unnamed_addr #0 {
entry:
  %port = alloca i32, align 4
  %cmp.not = icmp eq i32 %structver, 1
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %0 = getelementptr inbounds i8, ptr %ci, i64 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(80) %0, i8 0, i64 72, i1 false)
  store i64 1, ptr %ci, align 8
  %flags = getelementptr inbounds %struct.client, ptr %client, i64 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %and = and i64 %1, 8
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end3, label %if.then1

if.then1:                                         ; preds = %if.end
  %flags2 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 1
  store i64 32, ptr %flags2, align 8
  %.pre = load i64, ptr %flags, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %2 = phi i64 [ 32, %if.then1 ], [ 0, %if.end ]
  %3 = phi i64 [ %.pre, %if.then1 ], [ %1, %if.end ]
  %and5 = and i64 %3, 262144
  %tobool6.not = icmp eq i64 %and5, 0
  br i1 %tobool6.not, label %if.end10, label %if.then7

if.then7:                                         ; preds = %if.end3
  %flags8 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 1
  %or9 = or disjoint i64 %2, 2
  store i64 %or9, ptr %flags8, align 8
  %.pre21 = load i64, ptr %flags, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end3
  %4 = phi i64 [ %or9, %if.then7 ], [ %2, %if.end3 ]
  %5 = phi i64 [ %.pre21, %if.then7 ], [ %3, %if.end3 ]
  %and12 = and i64 %5, 2048
  %tobool13.not = icmp eq i64 %and12, 0
  br i1 %tobool13.not, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.end10
  %flags15 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 1
  %or16 = or i64 %4, 16
  store i64 %or16, ptr %flags15, align 8
  %.pre22 = load i64, ptr %flags, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end10
  %6 = phi i64 [ %or16, %if.then14 ], [ %4, %if.end10 ]
  %7 = phi i64 [ %.pre22, %if.then14 ], [ %5, %if.end10 ]
  %and19 = and i64 %7, 2147483648
  %tobool20.not = icmp eq i64 %and19, 0
  br i1 %tobool20.not, label %if.end24, label %if.then21

if.then21:                                        ; preds = %if.end17
  %flags22 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 1
  %or23 = or i64 %6, 8
  store i64 %or23, ptr %flags22, align 8
  %.pre23 = load i64, ptr %flags, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end17
  %8 = phi i64 [ %or23, %if.then21 ], [ %6, %if.end17 ]
  %9 = phi i64 [ %.pre23, %if.then21 ], [ %7, %if.end17 ]
  %and26 = and i64 %9, 16
  %tobool27.not = icmp eq i64 %and26, 0
  br i1 %tobool27.not, label %if.end31, label %if.then28

if.then28:                                        ; preds = %if.end24
  %flags29 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 1
  %or30 = or i64 %8, 4
  store i64 %or30, ptr %flags29, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %if.end24
  %conn = getelementptr inbounds %struct.client, ptr %client, i64 0, i32 2
  %10 = load ptr, ptr %conn, align 8
  %11 = load ptr, ptr %10, align 8
  %call = tail call ptr @connectionTypeTls() #32
  %cmp32 = icmp eq ptr %11, %call
  br i1 %cmp32, label %if.then34, label %if.end37

if.then34:                                        ; preds = %if.end31
  %flags35 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 1
  %12 = load i64, ptr %flags35, align 8
  %or36 = or i64 %12, 1
  store i64 %or36, ptr %flags35, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then34, %if.end31
  %13 = load ptr, ptr %conn, align 8
  %addr = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 3
  %tobool.not.i.i = icmp eq ptr %13, null
  br i1 %tobool.not.i.i, label %connAddrPeerName.exit, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.end37
  %14 = load ptr, ptr %13, align 8
  %addr.i.i = getelementptr inbounds %struct.ConnectionType, ptr %14, i64 0, i32 6
  %15 = load ptr, ptr %addr.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %15, null
  br i1 %tobool1.not.i.i, label %connAddrPeerName.exit, label %if.then.i.i

if.then.i.i:                                      ; preds = %land.lhs.true.i.i
  %call.i.i = call i32 %15(ptr noundef nonnull %13, ptr noundef nonnull %addr, i64 noundef 46, ptr noundef nonnull %port, i32 noundef 1) #32
  %.pre24 = load i32, ptr %port, align 4
  %16 = trunc i32 %.pre24 to i16
  br label %connAddrPeerName.exit

connAddrPeerName.exit:                            ; preds = %if.end37, %land.lhs.true.i.i, %if.then.i.i
  %conv40 = phi i16 [ undef, %if.end37 ], [ undef, %land.lhs.true.i.i ], [ %16, %if.then.i.i ]
  %port41 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 4
  store i16 %conv40, ptr %port41, align 2
  %db = getelementptr inbounds %struct.client, ptr %client, i64 0, i32 4
  %17 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %17, i64 0, i32 6
  %18 = load i32, ptr %id, align 8
  %conv42 = trunc i32 %18 to i16
  %db43 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 5
  store i16 %conv42, ptr %db43, align 8
  %19 = load i64, ptr %client, align 8
  %id45 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %ci, i64 0, i32 2
  store i64 %19, ptr %id45, align 8
  br label %return

return:                                           ; preds = %entry, %connAddrPeerName.exit
  %retval.0 = phi i32 [ 0, %connAddrPeerName.exit ], [ 1, %entry ]
  ret i32 %retval.0
}

declare ptr @connectionTypeTls() local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: write, inaccessiblemem: none) uwtable
define dso_local noundef i32 @modulePopulateReplicationInfoStructure(ptr nocapture noundef writeonly %ri, i32 noundef %structver) local_unnamed_addr #21 {
entry:
  %cmp.not = icmp eq i32 %structver, 1
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %0 = getelementptr inbounds i8, ptr %ri, i64 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(64) %0, i8 0, i64 56, i1 false)
  store i64 1, ptr %ri, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp1 = icmp eq ptr %1, null
  %conv2 = zext i1 %cmp1 to i32
  %master = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %ri, i64 0, i32 1
  store i32 %conv2, ptr %master, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %tobool.not = icmp eq ptr %2, null
  %cond = select i1 %tobool.not, ptr @.str.41, ptr %2
  %masterhost = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %ri, i64 0, i32 2
  store ptr %cond, ptr %masterhost, align 8
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 284), align 8
  %masterport = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %ri, i64 0, i32 3
  store i32 %3, ptr %masterport, align 8
  %replid1 = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %ri, i64 0, i32 4
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 260), ptr %replid1, align 8
  %replid2 = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %ri, i64 0, i32 5
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 261), ptr %replid2, align 8
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %repl1_offset = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %ri, i64 0, i32 6
  store i64 %4, ptr %repl1_offset, align 8
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 263), align 8
  %repl2_offset = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %ri, i64 0, i32 7
  store i64 %5, ptr %repl2_offset, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_GetClientInfoById(ptr noundef %ci, i64 noundef %id) #0 {
entry:
  %call = tail call ptr @lookupClientByID(i64 noundef %id) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq ptr %ci, null
  br i1 %cmp1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %0 = load i64, ptr %ci, align 8
  %conv = trunc i64 %0 to i32
  %call4 = tail call i32 @modulePopulateClientInfoStructure(ptr noundef nonnull %ci, ptr noundef nonnull %call, i32 noundef %conv), !range !22
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi i32 [ %call4, %if.end3 ], [ 1, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetClientNameById(ptr nocapture noundef %ctx, i64 noundef %id) #0 {
entry:
  %call = tail call ptr @lookupClientByID(i64 noundef %id) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %name = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 5
  %0 = load ptr, ptr %name, align 8
  %cmp1 = icmp eq ptr %0, null
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  tail call void @incrRefCount(ptr noundef nonnull %0) #32
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %1 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %1, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %2 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %3 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %2, %3
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %2, 1
  %cmp4.i = icmp slt i32 %2, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %4 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %4, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %5 = phi i32 [ %2, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %6 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %5 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %7 = load ptr, ptr %amqueue12.i, align 8
  %8 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %8 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom17.i
  store ptr %0, ptr %arrayidx18.i, align 8
  %9 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %9, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end11.i, %if.end, %entry, %lor.lhs.false
  %retval.0 = phi ptr [ null, %lor.lhs.false ], [ null, %entry ], [ %0, %if.end ], [ %0, %if.end11.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SetClientNameById(i64 noundef %id, ptr noundef %name) #0 {
entry:
  %call = tail call ptr @lookupClientByID(i64 noundef %id) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return.sink.split, label %if.end

if.end:                                           ; preds = %entry
  %call2 = tail call i32 @clientSetName(ptr noundef nonnull %call, ptr noundef %name, ptr noundef null) #32
  %cmp3 = icmp eq i32 %call2, -1
  br i1 %cmp3, label %return.sink.split, label %return

return.sink.split:                                ; preds = %if.end, %entry
  %.sink = phi i32 [ 2, %entry ], [ 22, %if.end ]
  %call5 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call5, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %return.sink.split ]
  ret i32 %retval.0
}

declare i32 @clientSetName(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_PublishMessage(ptr nocapture readnone %ctx, ptr noundef %channel, ptr noundef %message) #0 {
entry:
  %call = tail call i32 @pubsubPublishMessageAndPropagateToCluster(ptr noundef %channel, ptr noundef %message, i32 noundef 0) #32
  ret i32 %call
}

declare i32 @pubsubPublishMessageAndPropagateToCluster(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_PublishMessageShard(ptr nocapture readnone %ctx, ptr noundef %channel, ptr noundef %message) #0 {
entry:
  %call = tail call i32 @pubsubPublishMessageAndPropagateToCluster(ptr noundef %channel, ptr noundef %message, i32 noundef 1) #32
  ret i32 %call
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @RM_GetSelectedDb(ptr nocapture noundef readonly %ctx) #11 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %1, i64 0, i32 6
  %2 = load i32, ptr %id, align 8
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetContextFlags(ptr noundef readonly %ctx) #0 {
entry:
  %level = alloca float, align 4
  %tobool.not = icmp eq ptr %ctx, null
  br i1 %tobool.not, label %if.end30, label %if.then

if.then:                                          ; preds = %entry
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.end18, label %if.then2

if.then2:                                         ; preds = %if.then
  %flags4 = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 1
  %1 = load i64, ptr %flags4, align 8
  %and = lshr i64 %1, 20
  %2 = trunc i64 %and to i32
  %spec.select = and i32 %2, 2097152
  %3 = trunc i64 %1 to i32
  %4 = shl i32 %3, 11
  %5 = and i32 %4, 4096
  %flags.1 = or disjoint i32 %spec.select, %5
  %resp = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 3
  %6 = load i32, ptr %resp, align 8
  %cmp = icmp eq i32 %6, 3
  %or16 = or disjoint i32 %flags.1, 4194304
  %spec.select45 = select i1 %cmp, i32 %or16, i32 %flags.1
  br label %if.end18

if.end18:                                         ; preds = %if.then2, %if.then
  %flags.2 = phi i32 [ 0, %if.then ], [ %spec.select45, %if.then2 ]
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %7 = load ptr, ptr %blocked_client, align 8
  %tobool19.not = icmp eq ptr %7, null
  %client. = select i1 %tobool19.not, ptr %client, ptr %7
  %cond = load ptr, ptr %client., align 8
  %tobool23.not = icmp eq ptr %cond, null
  br i1 %tobool23.not, label %if.end30, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end18
  %flags24 = getelementptr inbounds %struct.client, ptr %cond, i64 0, i32 1
  %8 = load i64, ptr %flags24, align 8
  %and25 = and i64 %8, 4128
  %tobool26.not = icmp eq i64 %and25, 0
  %or28 = or i32 %flags.2, 524288
  %spec.select37 = select i1 %tobool26.not, i32 %flags.2, i32 %or28
  br label %if.end30

if.end30:                                         ; preds = %land.lhs.true, %if.end18, %entry
  %flags.3 = phi i32 [ %flags.2, %if.end18 ], [ 0, %entry ], [ %spec.select37, %land.lhs.true ]
  %call = tail call i32 @scriptIsRunning() #32
  %tobool31.not = icmp ne i32 %call, 0
  %or33 = zext i1 %tobool31.not to i32
  %spec.select38 = or i32 %flags.3, %or33
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 30), align 4
  %tobool35.not = icmp eq i32 %9, 0
  %or37 = or i32 %spec.select38, 2
  %flags.5 = select i1 %tobool35.not, i32 %spec.select38, i32 %or37
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool39.not = icmp eq i32 %10, 0
  %or41 = or i32 %flags.5, 32
  %flags.6 = select i1 %tobool39.not, i32 %flags.5, i32 %or41
  %11 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 82), align 8
  %tobool43.not = icmp eq i32 %11, 0
  br i1 %tobool43.not, label %if.else, label %if.then44

if.then44:                                        ; preds = %if.end30
  %or45 = or i32 %flags.6, 8388608
  br label %if.end50

if.else:                                          ; preds = %if.end30
  %12 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool46.not = icmp eq i32 %12, 0
  %or48 = or i32 %flags.6, 8192
  %spec.select39 = select i1 %tobool46.not, i32 %flags.6, i32 %or48
  br label %if.end50

if.end50:                                         ; preds = %if.else, %if.then44
  %flags.7 = phi i32 [ %or45, %if.then44 ], [ %spec.select39, %if.else ]
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 314), align 8
  %cmp51.not = icmp eq i64 %13, 0
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  br i1 %cmp51.not, label %if.end61, label %land.lhs.true52

land.lhs.true52:                                  ; preds = %if.end50
  %tobool53 = icmp ne ptr %.pre, null
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 299), align 8
  %tobool54 = icmp ne i32 %14, 0
  %or.cond = select i1 %tobool53, i1 %tobool54, i1 false
  br i1 %or.cond, label %if.end61, label %if.then55

if.then55:                                        ; preds = %land.lhs.true52
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 316), align 8
  %cmp57.not = icmp eq i32 %15, 1792
  %spec.select40.v = select i1 %cmp57.not, i32 256, i32 768
  %spec.select40 = or i32 %spec.select40.v, %flags.7
  br label %if.end61

if.end61:                                         ; preds = %if.then55, %land.lhs.true52, %if.end50
  %flags.8 = phi i32 [ %flags.7, %land.lhs.true52 ], [ %flags.7, %if.end50 ], [ %spec.select40, %if.then55 ]
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp62.not = icmp eq i32 %16, 0
  %or64 = or i32 %flags.8, 64
  %spec.select41 = select i1 %cmp62.not, i32 %flags.8, i32 %or64
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 224), align 8
  %cmp66 = icmp sgt i32 %17, 0
  %or68 = or i32 %spec.select41, 128
  %flags.10 = select i1 %cmp66, i32 %or68, i32 %spec.select41
  %cmp70 = icmp eq ptr %.pre, null
  br i1 %cmp70, label %if.then71, label %if.else73

if.then71:                                        ; preds = %if.end61
  %or72 = or i32 %flags.10, 4
  br label %if.end99

if.else73:                                        ; preds = %if.end61
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 298), align 4
  %tobool75.not = icmp eq i32 %18, 0
  %spec.select42.v = select i1 %tobool75.not, i32 8, i32 24
  %spec.select42 = or i32 %spec.select42.v, %flags.10
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  %20 = add i32 %19, -1
  %or.cond1 = icmp ult i32 %20, 2
  br i1 %or.cond1, label %if.then82, label %if.else84

if.then82:                                        ; preds = %if.else73
  %or83 = or i32 %spec.select42, 32768
  br label %if.end94

if.else84:                                        ; preds = %if.else73
  switch i32 %19, label %if.end94 [
    i32 11, label %if.then86
    i32 12, label %if.then90
  ]

if.then86:                                        ; preds = %if.else84
  %or87 = or i32 %spec.select42, 65536
  br label %if.end94

if.then90:                                        ; preds = %if.else84
  %or91 = or i32 %spec.select42, 131072
  br label %if.end94

if.end94:                                         ; preds = %if.else84, %if.then86, %if.then90, %if.then82
  %flags.12 = phi i32 [ %or83, %if.then82 ], [ %or87, %if.then86 ], [ %or91, %if.then90 ], [ %spec.select42, %if.else84 ]
  %cmp95.not = icmp eq i32 %19, 12
  %or97 = or i32 %flags.12, 16384
  %spec.select43 = select i1 %cmp95.not, i32 %flags.12, i32 %or97
  br label %if.end99

if.end99:                                         ; preds = %if.end94, %if.then71
  %flags.13 = phi i32 [ %or72, %if.then71 ], [ %spec.select43, %if.end94 ]
  %call101 = call i32 @getMaxmemoryState(ptr noundef null, ptr noundef null, ptr noundef null, ptr noundef nonnull %level) #32
  %cmp102 = icmp eq i32 %call101, -1
  %or104 = or i32 %flags.13, 1024
  %spec.select44 = select i1 %cmp102, i32 %or104, i32 %flags.13
  %21 = load float, ptr %level, align 4
  %cmp106 = fcmp ogt float %21, 7.500000e-01
  %or109 = or i32 %spec.select44, 2048
  %flags.15 = select i1 %cmp106, i32 %or109, i32 %spec.select44
  %call111 = call i32 @hasActiveChildProcess() #32
  %tobool112.not = icmp eq i32 %call111, 0
  %or114 = or i32 %flags.15, 262144
  %flags.16 = select i1 %tobool112.not, i32 %flags.15, i32 %or114
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %tobool116.not = icmp eq i32 %22, 0
  %or118 = or i32 %flags.16, 1048576
  %flags.17 = select i1 %tobool116.not, i32 %flags.16, i32 %or118
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 40), align 8
  %len = getelementptr inbounds %struct.list, ptr %23, i64 0, i32 5
  %24 = load i64, ptr %len, align 8
  %cmp120.not = icmp eq i64 %24, 0
  %or123 = or i32 %flags.17, 16777216
  %flags.18 = select i1 %cmp120.not, i32 %flags.17, i32 %or123
  ret i32 %flags.18
}

declare i32 @scriptIsRunning() local_unnamed_addr #1

declare i32 @getMaxmemoryState(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @hasActiveChildProcess() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_AvoidReplicaTraffic() #0 {
entry:
  %call = tail call i32 @isPausedActionsWithUpdate(i32 noundef 16) #32
  %tobool = icmp ne i32 %call, 0
  %lnot.ext = zext i1 %tobool to i32
  ret i32 %lnot.ext
}

declare i32 @isPausedActionsWithUpdate(i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SelectDb(ptr nocapture noundef readonly %ctx, i32 noundef %newid) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %call = tail call i32 @selectDb(ptr noundef %0, i32 noundef %newid) #32
  %cmp = icmp ne i32 %call, 0
  %cond = zext i1 %cmp to i32
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_KeyExists(ptr nocapture noundef readonly %ctx, ptr noundef %keyname) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db, align 8
  %call = tail call ptr @lookupKeyReadWithFlags(ptr noundef %1, ptr noundef %keyname, i32 noundef 1) #32
  %cmp = icmp ne ptr %call, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare ptr @lookupKeyReadWithFlags(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_OpenKey(ptr noundef %ctx, ptr noundef %keyname, i32 noundef %mode) #0 {
entry:
  %and = lshr i32 %mode, 16
  %or8 = and i32 %and, 7
  %and9 = lshr i32 %mode, 15
  %cond11 = and i32 %and9, 16
  %or12 = or disjoint i32 %or8, %cond11
  %and13 = and i32 %mode, 1048576
  %tobool14.not = icmp eq i32 %and13, 0
  %cond15 = select i1 %tobool14.not, i32 0, i32 23
  %or16 = or i32 %or12, %cond15
  %and17 = and i32 %mode, 2
  %tobool18.not = icmp eq i32 %and17, 0
  %client19 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client19, align 8
  %db20 = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db20, align 8
  br i1 %tobool18.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call ptr @lookupKeyWriteWithFlags(ptr noundef %1, ptr noundef %keyname, i32 noundef %or16) #32
  br label %if.end23

if.else:                                          ; preds = %entry
  %call21 = tail call ptr @lookupKeyReadWithFlags(ptr noundef %1, ptr noundef %keyname, i32 noundef %or16) #32
  %cmp = icmp eq ptr %call21, null
  br i1 %cmp, label %return, label %if.end23

if.end23:                                         ; preds = %if.else, %if.then
  %value.0 = phi ptr [ %call, %if.then ], [ %call21, %if.else ]
  %call24 = tail call noalias dereferenceable_or_null(128) ptr @zmalloc(i64 noundef 128) #33
  store ptr %ctx, ptr %call24, align 8
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %client.i, align 8
  %db.i = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 4
  %3 = load ptr, ptr %db.i, align 8
  %db2.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 1
  store ptr %3, ptr %db2.i, align 8
  %key.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 2
  store ptr %keyname, ptr %key.i, align 8
  tail call void @incrRefCount(ptr noundef %keyname) #32
  %value3.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 3
  store ptr %value.0, ptr %value3.i, align 8
  %iter.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 4
  store ptr null, ptr %iter.i, align 8
  %mode4.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 5
  store i32 %mode, ptr %mode4.i, align 8
  %tobool.not.i = icmp eq ptr %value.0, null
  br i1 %tobool.not.i, label %moduleInitKey.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end23
  %bf.load.i.i = load i32, ptr %value.0, align 8
  %bf.clear.i.i = and i32 %bf.load.i.i, 15
  switch i32 %bf.clear.i.i, label %moduleInitKey.exit [
    i32 3, label %sw.bb.i.i
    i32 6, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i
  %u.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 6
  store i32 0, ptr %u.i.i.i, align 8
  %current.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i.i, align 8
  %er.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i.i.i, align 8
  br label %moduleInitKey.exit

sw.bb1.i.i:                                       ; preds = %if.then.i
  %signalready.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %call24, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 0, ptr %signalready.i.i, align 8
  br label %moduleInitKey.exit

moduleInitKey.exit:                               ; preds = %if.end23, %if.then.i, %sw.bb.i.i, %sw.bb1.i.i
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %4 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %4, 1
  %tobool.not.i21 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i21, label %return, label %if.end.i

if.end.i:                                         ; preds = %moduleInitKey.exit
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %5 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %6 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %5, %6
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %5, 1
  %cmp4.i = icmp slt i32 %5, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %7 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %7, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %8 = phi i32 [ %5, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %9 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %8 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %9, i64 %idxprom.i, i32 1
  store i32 0, ptr %type14.i, align 8
  %10 = load ptr, ptr %amqueue12.i, align 8
  %11 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %11 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %10, i64 %idxprom17.i
  store ptr %call24, ptr %arrayidx18.i, align 8
  %12 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %12, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end11.i, %moduleInitKey.exit, %if.else
  %retval.0 = phi ptr [ null, %if.else ], [ %call24, %moduleInitKey.exit ], [ %call24, %if.end11.i ]
  ret ptr %retval.0
}

declare ptr @lookupKeyWriteWithFlags(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @RM_GetOpenKeyModesAll() #22 {
entry:
  ret i32 2031619
}

; Function Attrs: nounwind uwtable
define internal fastcc void @moduleCloseKey(ptr noundef %key) unnamed_addr #0 {
entry:
  %0 = load ptr, ptr %key, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %options = getelementptr inbounds %struct.RedisModule, ptr %1, i64 0, i32 12
  %2 = load i32, ptr %options, align 4
  %3 = and i32 %2, 2
  %4 = icmp eq i32 %3, 0
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi i1 [ %4, %cond.true ], [ true, %entry ]
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %5 = load i32, ptr %mode, align 8
  %and4 = and i32 %5, 2
  %tobool5 = icmp ne i32 %and4, 0
  %or.cond = select i1 %tobool5, i1 %cond, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 2
  %6 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %7 = load ptr, ptr %db, align 8
  %key8 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %8 = load ptr, ptr %key8, align 8
  tail call void @signalModifiedKey(ptr noundef %6, ptr noundef %7, ptr noundef %8) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %9 = load ptr, ptr %value, align 8
  %tobool9.not = icmp eq ptr %9, null
  br i1 %tobool9.not, label %if.end21, label %if.then10

if.then10:                                        ; preds = %if.end
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %10 = load ptr, ptr %iter, align 8
  %tobool11.not = icmp eq ptr %10, null
  br i1 %tobool11.not, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.then10
  tail call fastcc void @moduleFreeKeyIterator(ptr noundef nonnull %key)
  %.pre = load ptr, ptr %value, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then10
  %11 = phi ptr [ %.pre, %if.then12 ], [ %9, %if.then10 ]
  %bf.load = load i32, ptr %11, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %if.end21 [
    i32 3, label %if.end.i
    i32 6, label %sw.bb15
  ]

if.end.i:                                         ; preds = %if.end13
  %u.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %12 = load i32, ptr %u.i, align 8
  %cmp2.i = icmp eq i32 %12, 1
  br i1 %cmp2.i, label %if.then3.i, label %RM_ZsetRangeStop.exit

if.then3.i:                                       ; preds = %if.end.i
  %lrs.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  tail call void @zslFreeLexRange(ptr noundef nonnull %lrs.i) #32
  br label %RM_ZsetRangeStop.exit

RM_ZsetRangeStop.exit:                            ; preds = %if.end.i, %if.then3.i
  store i32 0, ptr %u.i, align 8
  %current.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i, align 8
  %er.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i.i, align 8
  br label %if.end21

sw.bb15:                                          ; preds = %if.end13
  %signalready = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  %13 = load i32, ptr %signalready, align 8
  %tobool16.not = icmp eq i32 %13, 0
  br i1 %tobool16.not, label %if.end21, label %if.then17

if.then17:                                        ; preds = %sw.bb15
  %db18 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %14 = load ptr, ptr %db18, align 8
  %key19 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %15 = load ptr, ptr %key19, align 8
  tail call void @signalKeyAsReady(ptr noundef %14, ptr noundef %15, i32 noundef 6) #32
  br label %if.end21

if.end21:                                         ; preds = %if.end13, %RM_ZsetRangeStop.exit, %if.then17, %sw.bb15, %if.end
  %iter22 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %16 = load ptr, ptr %iter22, align 8
  %cmp = icmp eq ptr %16, null
  br i1 %cmp, label %cond.end30, label %cond.false29

cond.false29:                                     ; preds = %if.end21
  tail call void @_serverAssert(ptr noundef nonnull @.str.540, ptr noundef nonnull @.str.2, i32 noundef 4097) #32
  tail call void @abort() #35
  unreachable

cond.end30:                                       ; preds = %if.end21
  %key31 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %17 = load ptr, ptr %key31, align 8
  tail call void @decrRefCount(ptr noundef %17) #32
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local noundef i32 @RM_KeyType(ptr noundef readonly %key) #11 {
entry:
  %cmp = icmp eq ptr %key, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %0, null
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %1 = icmp ult i32 %bf.clear, 7
  br i1 %1, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %if.end
  %2 = zext nneg i32 %bf.clear to i64
  %switch.gep = getelementptr inbounds [7 x i32], ptr @switch.table.RM_KeyType, i64 0, i64 %2
  %switch.load = load i32, ptr %switch.gep, align 4
  br label %return

return:                                           ; preds = %if.end, %switch.lookup, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ 0, %lor.lhs.false ], [ 0, %entry ], [ %switch.load, %switch.lookup ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_ValueLength(ptr noundef readonly %key) #0 {
entry:
  %cmp = icmp eq ptr %key, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %0, null
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %return [
    i32 0, label %sw.bb
    i32 1, label %sw.bb4
    i32 2, label %sw.bb7
    i32 3, label %sw.bb10
    i32 4, label %sw.bb13
    i32 6, label %sw.bb16
  ]

sw.bb:                                            ; preds = %if.end
  %call = tail call i64 @stringObjectLen(ptr noundef nonnull %0) #32
  br label %return

sw.bb4:                                           ; preds = %if.end
  %call6 = tail call i64 @listTypeLength(ptr noundef nonnull %0) #32
  br label %return

sw.bb7:                                           ; preds = %if.end
  %call9 = tail call i64 @setTypeSize(ptr noundef nonnull %0) #32
  br label %return

sw.bb10:                                          ; preds = %if.end
  %call12 = tail call i64 @zsetLength(ptr noundef nonnull %0) #32
  br label %return

sw.bb13:                                          ; preds = %if.end
  %call15 = tail call i64 @hashTypeLength(ptr noundef nonnull %0) #32
  br label %return

sw.bb16:                                          ; preds = %if.end
  %call18 = tail call i64 @streamLength(ptr noundef nonnull %0) #32
  br label %return

return:                                           ; preds = %if.end, %entry, %lor.lhs.false, %sw.bb16, %sw.bb13, %sw.bb10, %sw.bb7, %sw.bb4, %sw.bb
  %retval.0 = phi i64 [ %call18, %sw.bb16 ], [ %call15, %sw.bb13 ], [ %call12, %sw.bb10 ], [ %call9, %sw.bb7 ], [ %call6, %sw.bb4 ], [ %call, %sw.bb ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %if.end ]
  ret i64 %retval.0
}

declare i64 @stringObjectLen(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_DeleteKey(ptr nocapture noundef %key) #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.end
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %2 = load ptr, ptr %db, align 8
  %key3 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %3 = load ptr, ptr %key3, align 8
  %call = tail call i32 @dbDelete(ptr noundef %2, ptr noundef %3) #32
  store ptr null, ptr %value, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then2, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %if.then2 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_UnlinkKey(ptr nocapture noundef %key) #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.end
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %2 = load ptr, ptr %db, align 8
  %key3 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %3 = load ptr, ptr %key3, align 8
  %call = tail call i32 @dbAsyncDelete(ptr noundef %2, ptr noundef %3) #32
  store ptr null, ptr %value, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then2, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %if.then2 ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare i32 @dbAsyncDelete(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_GetExpire(ptr nocapture noundef readonly %key) #0 {
entry:
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %0 = load ptr, ptr %db, align 8
  %key1 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %1 = load ptr, ptr %key1, align 8
  %call = tail call i64 @getExpire(ptr noundef %0, ptr noundef %1) #32
  %cmp = icmp eq i64 %call, -1
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %cmp2 = icmp eq ptr %2, null
  br i1 %cmp2, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call3 = tail call i64 @commandTimeSnapshot() #32
  %sub = sub nsw i64 %call, %call3
  %cond = tail call i64 @llvm.smax.i64(i64 %sub, i64 0)
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i64 [ %cond, %if.end ], [ -1, %lor.lhs.false ], [ -1, %entry ]
  ret i64 %retval.0
}

declare i64 @getExpire(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i64 @commandTimeSnapshot() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SetExpire(ptr nocapture noundef readonly %key, i64 noundef %expire) #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %1, null
  %or.cond = icmp slt i64 %expire, -1
  %or.cond11 = or i1 %or.cond, %cmp
  br i1 %or.cond11, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %cmp3.not = icmp eq i64 %expire, -1
  br i1 %cmp3.not, label %if.else, label %if.then5

if.then5:                                         ; preds = %if.end
  %call = tail call i64 @commandTimeSnapshot() #32
  %add = add nsw i64 %call, %expire
  %2 = load ptr, ptr %key, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %4 = load ptr, ptr %db, align 8
  %key6 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %5 = load ptr, ptr %key6, align 8
  tail call void @setExpire(ptr noundef %3, ptr noundef %4, ptr noundef %5, i64 noundef %add) #32
  br label %return

if.else:                                          ; preds = %if.end
  %db7 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %6 = load ptr, ptr %db7, align 8
  %key8 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %7 = load ptr, ptr %key8, align 8
  %call9 = tail call i32 @removeExpire(ptr noundef %6, ptr noundef %7) #32
  br label %return

return:                                           ; preds = %if.then5, %if.else, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 0, %if.else ], [ 0, %if.then5 ]
  ret i32 %retval.0
}

declare void @setExpire(ptr noundef, ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

declare i32 @removeExpire(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_GetAbsExpire(ptr nocapture noundef readonly %key) #0 {
entry:
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %0 = load ptr, ptr %db, align 8
  %key1 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %1 = load ptr, ptr %key1, align 8
  %call = tail call i64 @getExpire(ptr noundef %0, ptr noundef %1) #32
  %cmp = icmp eq i64 %call, -1
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %cmp2 = icmp eq ptr %2, null
  %spec.select = select i1 %cmp2, i64 -1, i64 %call
  br label %return

return:                                           ; preds = %lor.lhs.false, %entry
  %retval.0 = phi i64 [ -1, %entry ], [ %spec.select, %lor.lhs.false ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SetAbsExpire(ptr nocapture noundef readonly %key, i64 noundef %expire) #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %1, null
  %or.cond = icmp slt i64 %expire, -1
  %or.cond10 = or i1 %or.cond, %cmp
  br i1 %or.cond10, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %cmp3.not = icmp eq i64 %expire, -1
  br i1 %cmp3.not, label %if.else, label %if.then5

if.then5:                                         ; preds = %if.end
  %2 = load ptr, ptr %key, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %4 = load ptr, ptr %db, align 8
  %key6 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %5 = load ptr, ptr %key6, align 8
  tail call void @setExpire(ptr noundef %3, ptr noundef %4, ptr noundef %5, i64 noundef %expire) #32
  br label %return

if.else:                                          ; preds = %if.end
  %db7 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %6 = load ptr, ptr %db7, align 8
  %key8 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %7 = load ptr, ptr %key8, align 8
  %call = tail call i32 @removeExpire(ptr noundef %6, ptr noundef %7) #32
  br label %return

return:                                           ; preds = %if.then5, %if.else, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 0, %if.else ], [ 0, %if.then5 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ResetDataset(i32 noundef %restart_aof, i32 noundef %async) #0 {
entry:
  %tobool = icmp ne i32 %restart_aof, 0
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp = icmp ne i32 %0, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @stopAppendOnly() #32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool1.not = icmp ne i32 %async, 0
  %cond = zext i1 %tobool1.not to i32
  %or = or disjoint i32 %cond, 2
  tail call void @flushAllDataAndResetRDB(i32 noundef %or) #32
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 184), align 4
  %tobool2 = icmp ne i32 %1, 0
  %or.cond1 = and i1 %tobool, %tobool2
  br i1 %or.cond1, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  tail call void @restartAOFAfterSYNC() #32
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  ret void
}

declare void @stopAppendOnly() local_unnamed_addr #1

declare void @flushAllDataAndResetRDB(i32 noundef) local_unnamed_addr #1

declare void @restartAOFAfterSYNC() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_DbSize(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db, align 8
  %call = tail call i64 @dbSize(ptr noundef %1, i32 noundef 0) #32
  ret i64 %call
}

declare i64 @dbSize(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_RandomKey(ptr nocapture noundef %ctx) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db, align 8
  %call = tail call ptr @dbRandomKey(ptr noundef %1) #32
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %2 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %2, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %autoMemoryAdd.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %3 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %4 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %3, %4
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %3, 1
  %cmp4.i = icmp slt i32 %3, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %5 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %5, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %6 = phi i32 [ %3, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %7 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %6 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %8 = load ptr, ptr %amqueue12.i, align 8
  %9 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %9 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom17.i
  store ptr %call, ptr %arrayidx18.i, align 8
  %10 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %10, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %autoMemoryAdd.exit

autoMemoryAdd.exit:                               ; preds = %entry, %if.end11.i
  ret ptr %call
}

declare ptr @dbRandomKey(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetKeyNameFromOptCtx(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %0 = load ptr, ptr %ctx, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetToKeyNameFromOptCtx(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %to_key, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_GetDbIdFromOptCtx(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 2
  %0 = load i32, ptr %from_dbid, align 8
  ret i32 %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_GetToDbIdFromOptCtx(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 3
  %0 = load i32, ptr %to_dbid, align 4
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StringSet(ptr nocapture noundef %key, ptr noundef %str) #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end.i, label %return

if.end.i:                                         ; preds = %lor.lhs.false
  %value.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %2 = load ptr, ptr %value.i, align 8
  %tobool1.not.i = icmp eq ptr %2, null
  br i1 %tobool1.not.i, label %RM_DeleteKey.exit, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %db.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %3 = load ptr, ptr %db.i, align 8
  %key3.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %4 = load ptr, ptr %key3.i, align 8
  %call.i = tail call i32 @dbDelete(ptr noundef %3, ptr noundef %4) #32
  store ptr null, ptr %value.i, align 8
  br label %RM_DeleteKey.exit

RM_DeleteKey.exit:                                ; preds = %if.end.i, %if.then2.i
  %5 = load ptr, ptr %key, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %7 = load ptr, ptr %db, align 8
  %key2 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %8 = load ptr, ptr %key2, align 8
  tail call void @setKey(ptr noundef %6, ptr noundef %7, ptr noundef %8, ptr noundef %str, i32 noundef 2) #32
  store ptr %str, ptr %value.i, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %RM_DeleteKey.exit
  %retval.0 = phi i32 [ 0, %RM_DeleteKey.exit ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @setKey(ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_StringDMA(ptr nocapture noundef %key, ptr nocapture noundef writeonly %len, i32 noundef %mode) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %len, align 8
  br label %return

if.end:                                           ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp2.not = icmp eq i32 %bf.clear, 0
  br i1 %cmp2.not, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %and = and i32 %mode, 2
  %1 = and i32 %bf.load, 240
  %2 = or disjoint i32 %1, %and
  %or.cond = icmp eq i32 %2, 0
  br i1 %or.cond, label %if.end13, label %if.then9

if.then9:                                         ; preds = %if.end4
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %3 = load ptr, ptr %db, align 8
  %key10 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %4 = load ptr, ptr %key10, align 8
  %call = tail call ptr @dbUnshareStringValue(ptr noundef %3, ptr noundef %4, ptr noundef nonnull %0) #32
  store ptr %call, ptr %value, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.end4, %if.then9
  %5 = phi ptr [ %0, %if.end4 ], [ %call, %if.then9 ]
  %ptr = getelementptr inbounds %struct.redisObject, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %6, i64 -1
  %7 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %7 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end13
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end13
  %add.ptr.i = getelementptr inbounds i8, ptr %6, i64 -3
  %8 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %8 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end13
  %add.ptr6.i = getelementptr inbounds i8, ptr %6, i64 -5
  %9 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %9 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end13
  %add.ptr10.i = getelementptr inbounds i8, ptr %6, i64 -9
  %10 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %10 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end13
  %add.ptr14.i = getelementptr inbounds i8, ptr %6, i64 -17
  %11 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end13, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %11, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end13 ]
  store i64 %retval.0.i, ptr %len, align 8
  %12 = load ptr, ptr %value, align 8
  %ptr17 = getelementptr inbounds %struct.redisObject, ptr %12, i64 0, i32 2
  %13 = load ptr, ptr %ptr17, align 8
  br label %return

return:                                           ; preds = %if.end, %sdslen.exit, %if.then
  %retval.0 = phi ptr [ @.str.42, %if.then ], [ %13, %sdslen.exit ], [ null, %if.end ]
  ret ptr %retval.0
}

declare ptr @dbUnshareStringValue(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StringTruncate(ptr nocapture noundef %key, i64 noundef %newlen) #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp ne i32 %bf.clear, 0
  %cmp5 = icmp ugt i64 %newlen, 536870912
  %or.cond31 = or i1 %cmp5, %cmp.not
  br i1 %or.cond31, label %return, label %if.else

if.end4:                                          ; preds = %if.end
  %cmp5.old = icmp ugt i64 %newlen, 536870912
  br i1 %cmp5.old, label %return, label %if.end7

if.end7:                                          ; preds = %if.end4
  %cmp11 = icmp eq i64 %newlen, 0
  br i1 %cmp11, label %return, label %if.then16

if.then16:                                        ; preds = %if.end7
  %call = tail call ptr @sdsnewlen(ptr noundef null, i64 noundef %newlen) #32
  %call17 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call) #32
  %2 = load ptr, ptr %key, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %4 = load ptr, ptr %db, align 8
  %key18 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %5 = load ptr, ptr %key18, align 8
  tail call void @setKey(ptr noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %call17, i32 noundef 2) #32
  store ptr %call17, ptr %value, align 8
  tail call void @decrRefCount(ptr noundef %call17) #32
  br label %return

if.else:                                          ; preds = %land.lhs.true
  %db20 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %6 = load ptr, ptr %db20, align 8
  %key21 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %7 = load ptr, ptr %key21, align 8
  %call23 = tail call ptr @dbUnshareStringValue(ptr noundef %6, ptr noundef %7, ptr noundef nonnull %1) #32
  store ptr %call23, ptr %value, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %call23, i64 0, i32 2
  %8 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %8, i64 -1
  %9 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %9 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.else
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.else
  %add.ptr.i = getelementptr inbounds i8, ptr %8, i64 -3
  %10 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %10 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.else
  %add.ptr6.i = getelementptr inbounds i8, ptr %8, i64 -5
  %11 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %11 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.else
  %add.ptr10.i = getelementptr inbounds i8, ptr %8, i64 -9
  %12 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %12 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.else
  %add.ptr14.i = getelementptr inbounds i8, ptr %8, i64 -17
  %13 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.else, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %13, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.else ]
  %cmp27 = icmp ult i64 %retval.0.i, %newlen
  br i1 %cmp27, label %if.then28, label %if.else34

if.then28:                                        ; preds = %sdslen.exit
  %call31 = tail call ptr @sdsgrowzero(ptr noundef nonnull %8, i64 noundef %newlen) #32
  %14 = load ptr, ptr %value, align 8
  %ptr33 = getelementptr inbounds %struct.redisObject, ptr %14, i64 0, i32 2
  store ptr %call31, ptr %ptr33, align 8
  br label %return

if.else34:                                        ; preds = %sdslen.exit
  %cmp35 = icmp ugt i64 %retval.0.i, %newlen
  br i1 %cmp35, label %if.then36, label %return

if.then36:                                        ; preds = %if.else34
  tail call void @sdssubstr(ptr noundef nonnull %8, i64 noundef 0, i64 noundef %newlen) #32
  %15 = load ptr, ptr %value, align 8
  %ptr40 = getelementptr inbounds %struct.redisObject, ptr %15, i64 0, i32 2
  %16 = load ptr, ptr %ptr40, align 8
  %call41 = tail call fastcc i64 @sdslen(ptr noundef %16)
  %call44 = tail call fastcc i64 @sdsavail(ptr noundef %16)
  %cmp45 = icmp ult i64 %call41, %call44
  br i1 %cmp45, label %if.then46, label %return

if.then46:                                        ; preds = %if.then36
  %call49 = tail call ptr @sdsRemoveFreeSpace(ptr noundef %16, i32 noundef 0) #32
  %17 = load ptr, ptr %value, align 8
  %ptr51 = getelementptr inbounds %struct.redisObject, ptr %17, i64 0, i32 2
  store ptr %call49, ptr %ptr51, align 8
  br label %return

return:                                           ; preds = %if.then16, %if.else34, %if.then46, %if.then36, %if.then28, %if.end7, %if.end4, %land.lhs.true, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 1, %land.lhs.true ], [ 1, %if.end4 ], [ 0, %if.end7 ], [ 0, %if.then28 ], [ 0, %if.then36 ], [ 0, %if.then46 ], [ 0, %if.else34 ], [ 0, %if.then16 ]
  ret i32 %retval.0
}

declare ptr @sdsgrowzero(ptr noundef, i64 noundef) local_unnamed_addr #1

declare void @sdssubstr(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define internal fastcc i64 @sdsavail(ptr nocapture noundef readonly %s) unnamed_addr #6 {
entry:
  %arrayidx = getelementptr inbounds i8, ptr %s, i64 -1
  %0 = load i8, ptr %arrayidx, align 1
  %1 = and i8 %0, 7
  switch i8 %1, label %return [
    i8 4, label %sw.bb21
    i8 1, label %sw.bb1
    i8 2, label %sw.bb5
    i8 3, label %sw.bb14
  ]

sw.bb1:                                           ; preds = %entry
  %add.ptr = getelementptr inbounds i8, ptr %s, i64 -3
  %alloc = getelementptr inbounds i8, ptr %s, i64 -2
  %2 = load i8, ptr %alloc, align 1
  %conv2 = zext i8 %2 to i64
  %3 = load i8, ptr %add.ptr, align 1
  %conv3 = zext i8 %3 to i64
  %sub = sub nsw i64 %conv2, %conv3
  br label %return

sw.bb5:                                           ; preds = %entry
  %add.ptr7 = getelementptr inbounds i8, ptr %s, i64 -5
  %alloc8 = getelementptr inbounds i8, ptr %s, i64 -3
  %4 = load i16, ptr %alloc8, align 1
  %conv9 = zext i16 %4 to i64
  %5 = load i16, ptr %add.ptr7, align 1
  %conv11 = zext i16 %5 to i64
  %sub12 = sub nsw i64 %conv9, %conv11
  br label %return

sw.bb14:                                          ; preds = %entry
  %add.ptr16 = getelementptr inbounds i8, ptr %s, i64 -9
  %alloc17 = getelementptr inbounds i8, ptr %s, i64 -5
  %6 = load i32, ptr %alloc17, align 1
  %7 = load i32, ptr %add.ptr16, align 1
  %sub19 = sub i32 %6, %7
  %conv20 = zext i32 %sub19 to i64
  br label %return

sw.bb21:                                          ; preds = %entry
  %add.ptr23 = getelementptr inbounds i8, ptr %s, i64 -17
  %alloc24 = getelementptr inbounds i8, ptr %s, i64 -9
  %8 = load i64, ptr %alloc24, align 1
  %9 = load i64, ptr %add.ptr23, align 1
  %sub26 = sub i64 %8, %9
  br label %return

return:                                           ; preds = %entry, %sw.bb21, %sw.bb14, %sw.bb5, %sw.bb1
  %retval.0 = phi i64 [ %sub26, %sw.bb21 ], [ %conv20, %sw.bb14 ], [ %sub12, %sw.bb5 ], [ %sub, %sw.bb1 ], [ 0, %entry ]
  ret i64 %retval.0
}

declare ptr @sdsRemoveFreeSpace(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleListIteratorSeek(ptr noundef %key, i64 noundef %index, i32 noundef %mode) local_unnamed_addr #0 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 1
  br i1 %cmp.not, label %if.end5, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call4, align 4
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  %mode6 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode6, align 8
  %and = and i32 %1, %mode
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %call9 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call9, align 4
  br label %return

if.end10:                                         ; preds = %if.end5
  %call12 = tail call i64 @listTypeLength(ptr noundef nonnull %0) #32
  %sub = sub nsw i64 0, %call12
  %cmp13 = icmp sle i64 %sub, %index
  %cmp15.not = icmp sgt i64 %call12, %index
  %or.cond = and i1 %cmp13, %cmp15.not
  br i1 %or.cond, label %if.end18, label %if.then16

if.then16:                                        ; preds = %if.end10
  %call17 = tail call ptr @__errno_location() #37
  store i32 33, ptr %call17, align 4
  br label %return

if.end18:                                         ; preds = %if.end10
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %2 = load ptr, ptr %iter, align 8
  %cmp19 = icmp eq ptr %2, null
  br i1 %cmp19, label %if.then20, label %if.end43

if.then20:                                        ; preds = %if.end18
  %3 = load ptr, ptr %value, align 8
  %call22 = tail call ptr @listTypeInitIterator(ptr noundef %3, i64 noundef %index, i8 noundef zeroext 1) #32
  store ptr %call22, ptr %iter, align 8
  %cmp25.not = icmp eq ptr %call22, null
  br i1 %cmp25.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then20
  tail call void @_serverAssert(ptr noundef nonnull @.str.43, ptr noundef nonnull @.str.2, i32 noundef 4440) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.then20
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %call30 = tail call i32 @listTypeNext(ptr noundef nonnull %call22, ptr noundef nonnull %u) #32
  %tobool31.not = icmp eq i32 %call30, 0
  br i1 %tobool31.not, label %cond.false39, label %cond.end40

cond.false39:                                     ; preds = %cond.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.44, ptr noundef nonnull @.str.2, i32 noundef 4441) #32
  tail call void @abort() #35
  unreachable

cond.end40:                                       ; preds = %cond.end
  %index42 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i64 %index, ptr %index42, align 8
  br label %return

if.end43:                                         ; preds = %if.end18
  %cmp44 = icmp slt i64 %index, 0
  %index47 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  %4 = load i64, ptr %index47, align 8
  %cmp4839 = icmp slt i64 %4, 0
  %sub60 = select i1 %cmp4839, i64 %call12, i64 0
  %add = select i1 %cmp4839, i64 0, i64 %call12
  %5 = sub i64 0, %sub60
  %index.addr.0.p = select i1 %cmp44, i64 %add, i64 %5
  %index.addr.0 = add i64 %index.addr.0.p, %index
  %u63 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %index64 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  %cmp65 = icmp eq i64 %index.addr.0, %4
  br i1 %cmp65, label %return, label %if.end68

if.end68:                                         ; preds = %if.end43
  %cmp71 = icmp slt i64 %4, %index.addr.0
  %conv73 = zext i1 %cmp71 to i8
  tail call void @listTypeSetIteratorDirection(ptr noundef nonnull %2, ptr noundef nonnull %u63, i8 noundef zeroext %conv73) #32
  %6 = load i64, ptr %index64, align 8
  %cmp79.not40 = icmp eq i64 %6, %index.addr.0
  br i1 %cmp79.not40, label %return, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end68
  %conv99 = select i1 %cmp71, i64 1, i64 -1
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %cond.end94
  %7 = load ptr, ptr %iter, align 8
  %call84 = tail call i32 @listTypeNext(ptr noundef %7, ptr noundef nonnull %u63) #32
  %tobool85.not = icmp eq i32 %call84, 0
  br i1 %tobool85.not, label %cond.false93, label %cond.end94

cond.false93:                                     ; preds = %while.body
  tail call void @_serverAssert(ptr noundef nonnull @.str.44, ptr noundef nonnull @.str.2, i32 noundef 4457) #32
  tail call void @abort() #35
  unreachable

cond.end94:                                       ; preds = %while.body
  %8 = load i64, ptr %index64, align 8
  %add102 = add nsw i64 %8, %conv99
  store i64 %add102, ptr %index64, align 8
  %cmp79.not = icmp eq i64 %add102, %index.addr.0
  br i1 %cmp79.not, label %return, label %while.body, !llvm.loop !34

return:                                           ; preds = %cond.end94, %if.end68, %if.end43, %cond.end40, %if.then16, %if.then8, %if.then3, %if.then
  %retval.0 = phi i32 [ 0, %if.then3 ], [ 0, %if.then16 ], [ 1, %cond.end40 ], [ 0, %if.then8 ], [ 0, %if.then ], [ 1, %if.end43 ], [ 1, %if.end68 ], [ 1, %cond.end94 ]
  ret i32 %retval.0
}

declare ptr @listTypeInitIterator(ptr noundef, i64 noundef, i8 noundef zeroext) local_unnamed_addr #1

declare i32 @listTypeNext(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @listTypeSetIteratorDirection(ptr noundef, ptr noundef, i8 noundef zeroext) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ListPush(ptr noundef %key, i32 noundef %where, ptr noundef %ele) #0 {
entry:
  %ele.addr = alloca ptr, align 8
  store ptr %ele, ptr %ele.addr, align 8
  %tobool = icmp ne ptr %key, null
  %tobool1 = icmp ne ptr %ele, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp.not = icmp eq ptr %0, null
  br i1 %cmp.not, label %if.end6, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp3.not = icmp eq i32 %bf.clear, 1
  br i1 %cmp3.not, label %if.end6.thread, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  %call5 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call5, align 4
  br label %return

if.end6:                                          ; preds = %if.else
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %if.then8, label %if.end24

if.end6.thread:                                   ; preds = %land.lhs.true
  %mode15 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %2 = load i32, ptr %mode15, align 8
  %and16 = and i32 %2, 2
  %tobool7.not17 = icmp eq i32 %and16, 0
  br i1 %tobool7.not17, label %if.then8, label %if.end24

if.then8:                                         ; preds = %if.end6.thread, %if.end6
  %call9 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call9, align 4
  br label %return

if.end24:                                         ; preds = %if.end6.thread, %if.end6
  %mode1821 = phi ptr [ %mode, %if.end6 ], [ %mode15, %if.end6.thread ]
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %3 = load ptr, ptr %iter, align 8
  %tobool25.not = icmp eq ptr %3, null
  br i1 %tobool25.not, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.end24
  tail call fastcc void @moduleFreeKeyIterator(ptr noundef nonnull %key)
  %.pre = load ptr, ptr %value, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.end24
  %4 = phi ptr [ %.pre, %if.then26 ], [ %0, %if.end24 ]
  %cmp29 = icmp eq ptr %4, null
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end27
  %5 = load i32, ptr %mode1821, align 8
  %and.i = and i32 %5, 2
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end32, label %if.end.i

if.end.i:                                         ; preds = %if.then30
  %call.i = tail call ptr @createListListpackObject() #32
  %db.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %6 = load ptr, ptr %db.i, align 8
  %key8.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %7 = load ptr, ptr %key8.i, align 8
  tail call void @dbAdd(ptr noundef %6, ptr noundef %7, ptr noundef %call.i) #32
  store ptr %call.i, ptr %value, align 8
  %bf.load.i.i = load i32, ptr %call.i, align 8
  %bf.clear.i.i = and i32 %bf.load.i.i, 15
  switch i32 %bf.clear.i.i, label %if.end32 [
    i32 3, label %sw.bb.i.i
    i32 6, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %u.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  store i32 0, ptr %u.i.i.i, align 8
  %current.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i.i, align 8
  %er.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i.i.i, align 8
  br label %if.end32

sw.bb1.i.i:                                       ; preds = %if.end.i
  %signalready.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 0, ptr %signalready.i.i, align 8
  br label %if.end32

if.end32:                                         ; preds = %sw.bb1.i.i, %sw.bb.i.i, %if.end.i, %if.then30, %if.end27
  %8 = phi ptr [ %call.i, %sw.bb1.i.i ], [ %call.i, %sw.bb.i.i ], [ %call.i, %if.end.i ], [ null, %if.then30 ], [ %4, %if.end27 ]
  call void @listTypeTryConversionAppend(ptr noundef %8, ptr noundef nonnull %ele.addr, i32 noundef 0, i32 noundef 0, ptr noundef nonnull @moduleFreeListIterator, ptr noundef nonnull %key) #32
  %9 = load ptr, ptr %value, align 8
  %10 = load ptr, ptr %ele.addr, align 8
  %cmp35 = icmp ne i32 %where, 0
  %cond = zext i1 %cmp35 to i32
  call void @listTypePush(ptr noundef %9, ptr noundef %10, i32 noundef %cond) #32
  br label %return

return:                                           ; preds = %if.end32, %if.then8, %if.then4, %if.then
  %retval.0 = phi i32 [ 1, %if.then4 ], [ 0, %if.end32 ], [ 1, %if.then8 ], [ 1, %if.then ]
  ret i32 %retval.0
}

declare void @listTypeTryConversionAppend(ptr noundef, ptr noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal void @moduleFreeListIterator(ptr nocapture noundef %data) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %data, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp eq i32 %bf.clear, 1
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.541, ptr noundef nonnull @.str.2, i32 noundef 734) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %data, i64 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %tobool2.not = icmp eq ptr %1, null
  br i1 %tobool2.not, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  tail call fastcc void @moduleFreeKeyIterator(ptr noundef nonnull %data)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  ret void
}

declare void @listTypePush(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ListPop(ptr noundef %key, i32 noundef %where) #0 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp2.not = icmp eq i32 %bf.clear, 1
  br i1 %cmp2.not, label %if.else5, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call4, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool6.not = icmp eq i32 %and, 0
  br i1 %tobool6.not, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.else5
  %call8 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call8, align 4
  br label %return

if.end10:                                         ; preds = %if.else5
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %2 = load ptr, ptr %iter, align 8
  %tobool11.not = icmp eq ptr %2, null
  br i1 %tobool11.not, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end10
  tail call fastcc void @moduleFreeKeyIterator(ptr noundef nonnull %key)
  %.pre = load ptr, ptr %value, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10
  %3 = phi ptr [ %.pre, %if.then12 ], [ %0, %if.end10 ]
  %cmp15 = icmp ne i32 %where, 0
  %cond = zext i1 %cmp15 to i32
  %call16 = tail call ptr @listTypePop(ptr noundef %3, i32 noundef %cond) #32
  %call17 = tail call ptr @getDecodedObject(ptr noundef %call16) #32
  tail call void @decrRefCount(ptr noundef %call16) #32
  %call18 = tail call i32 @moduleDelKeyIfEmpty(ptr noundef nonnull %key), !range !22
  %tobool19.not = icmp eq i32 %call18, 0
  br i1 %tobool19.not, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end13
  %4 = load ptr, ptr %value, align 8
  tail call void @listTypeTryConversion(ptr noundef %4, i32 noundef 2, ptr noundef nonnull @moduleFreeListIterator, ptr noundef nonnull %key) #32
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end13
  %5 = load ptr, ptr %key, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 7
  %6 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %6, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.end22
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 6
  %7 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 5
  %8 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %7, %8
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %7, 1
  %cmp4.i = icmp slt i32 %7, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 4
  %9 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %9, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %10 = phi i32 [ %7, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %11 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 4
  %idxprom.i = sext i32 %10 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %11, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %12 = load ptr, ptr %amqueue12.i, align 8
  %13 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %13 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %12, i64 %idxprom17.i
  store ptr %call17, ptr %arrayidx18.i, align 8
  %14 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %14, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end11.i, %if.end22, %if.then7, %if.then3, %if.then
  %retval.0 = phi ptr [ null, %if.then3 ], [ null, %if.then7 ], [ null, %if.then ], [ %call17, %if.end22 ], [ %call17, %if.end11.i ]
  ret ptr %retval.0
}

declare ptr @listTypePop(ptr noundef, i32 noundef) local_unnamed_addr #1

declare ptr @getDecodedObject(ptr noundef) local_unnamed_addr #1

declare void @listTypeTryConversion(ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ListGet(ptr noundef %key, i64 noundef %index) #0 {
entry:
  %call = tail call i32 @moduleListIteratorSeek(ptr noundef %key, i64 noundef %index, i32 noundef 1), !range !22
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %call2 = tail call ptr @listTypeGet(ptr noundef nonnull %u) #32
  %call3 = tail call ptr @getDecodedObject(ptr noundef %call2) #32
  tail call void @decrRefCount(ptr noundef %call2) #32
  %0 = load ptr, ptr %key, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 7
  %1 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %1, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 6
  %2 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 5
  %3 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %2, %3
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %2, 1
  %cmp4.i = icmp slt i32 %2, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 4
  %4 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %4, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %5 = phi i32 [ %2, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %6 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i64 0, i32 4
  %idxprom.i = sext i32 %5 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %7 = load ptr, ptr %amqueue12.i, align 8
  %8 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %8 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %7, i64 %idxprom17.i
  store ptr %call3, ptr %arrayidx18.i, align 8
  %9 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %9, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end11.i, %if.then, %entry
  %retval.0 = phi ptr [ null, %entry ], [ %call3, %if.then ], [ %call3, %if.end11.i ]
  ret ptr %retval.0
}

declare ptr @listTypeGet(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ListSet(ptr noundef %key, i64 noundef %index, ptr noundef %value) #0 {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %tobool.not = icmp eq ptr %value, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.end:                                           ; preds = %entry
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value1, align 8
  %tobool2.not = icmp eq ptr %0, null
  br i1 %tobool2.not, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 1
  br i1 %cmp.not, label %if.end6, label %if.then4

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %call5 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call5, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  call void @listTypeTryConversionAppend(ptr noundef nonnull %0, ptr noundef nonnull %value.addr, i32 noundef 0, i32 noundef 0, ptr noundef nonnull @moduleFreeListIterator, ptr noundef nonnull %key) #32
  %call8 = call i32 @moduleListIteratorSeek(ptr noundef nonnull %key, i64 noundef %index, i32 noundef 2), !range !22
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %return, label %if.then10

if.then10:                                        ; preds = %if.end6
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %1 = load ptr, ptr %value.addr, align 8
  call void @listTypeReplace(ptr noundef nonnull %u, ptr noundef %1) #32
  call fastcc void @moduleFreeKeyIterator(ptr noundef nonnull %key)
  br label %return

return:                                           ; preds = %if.end6, %if.then10, %if.then4, %if.then
  %retval.0 = phi i32 [ 1, %if.then4 ], [ 0, %if.then10 ], [ 1, %if.then ], [ 1, %if.end6 ]
  ret i32 %retval.0
}

declare void @listTypeReplace(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ListInsert(ptr noundef %key, i64 noundef %index, ptr noundef %value) #0 {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %tobool.not = icmp eq ptr %value, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %cmp.not = icmp eq ptr %key, null
  br i1 %cmp.not, label %if.end45, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value1, align 8
  %cmp2 = icmp eq ptr %0, null
  %1 = add i64 %index, 1
  %or.cond = icmp ult i64 %1, 2
  %or.cond27 = and i1 %or.cond, %cmp2
  br i1 %or.cond27, label %if.then6, label %land.lhs.true10

if.then6:                                         ; preds = %land.lhs.true
  %call7 = tail call i32 @RM_ListPush(ptr noundef nonnull %key, i32 noundef 1, ptr noundef nonnull %value), !range !22
  br label %return

land.lhs.true10:                                  ; preds = %land.lhs.true
  br i1 %cmp2, label %if.end45, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %land.lhs.true10
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp15 = icmp eq i32 %bf.clear, 1
  br i1 %cmp15, label %land.lhs.true16, label %land.lhs.true29

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %call18 = tail call i64 @listTypeLength(ptr noundef nonnull %0) #32
  %cmp19 = icmp eq i64 %call18, %index
  %cmp21 = icmp eq i64 %index, -1
  %or.cond1 = or i1 %cmp21, %cmp19
  br i1 %or.cond1, label %if.then22, label %land.lhs.true26

if.then22:                                        ; preds = %land.lhs.true16
  %call23 = tail call i32 @RM_ListPush(ptr noundef nonnull %key, i32 noundef 1, ptr noundef nonnull %value), !range !22
  br label %return

land.lhs.true26:                                  ; preds = %land.lhs.true16
  %.pre = load ptr, ptr %value1, align 8
  %cmp28.not = icmp eq ptr %.pre, null
  br i1 %cmp28.not, label %if.end45, label %land.lhs.true29

land.lhs.true29:                                  ; preds = %land.lhs.true13, %land.lhs.true26
  %2 = phi ptr [ %.pre, %land.lhs.true26 ], [ %0, %land.lhs.true13 ]
  %bf.load31 = load i32, ptr %2, align 8
  %bf.clear32 = and i32 %bf.load31, 15
  %cmp33 = icmp eq i32 %bf.clear32, 1
  br i1 %cmp33, label %land.lhs.true34, label %if.end45

land.lhs.true34:                                  ; preds = %land.lhs.true29
  %cmp35 = icmp eq i64 %index, 0
  br i1 %cmp35, label %if.then41, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %land.lhs.true34
  %call38 = tail call i64 @listTypeLength(ptr noundef nonnull %2) #32
  %3 = xor i64 %call38, %index
  %cmp40 = icmp eq i64 %3, -1
  br i1 %cmp40, label %if.then41, label %if.end45

if.then41:                                        ; preds = %lor.lhs.false36, %land.lhs.true34
  %call42 = tail call i32 @RM_ListPush(ptr noundef nonnull %key, i32 noundef 0, ptr noundef nonnull %value), !range !22
  br label %return

if.end45:                                         ; preds = %land.lhs.true10, %if.else, %land.lhs.true26, %land.lhs.true29, %lor.lhs.false36
  %value46 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %4 = load ptr, ptr %value46, align 8
  call void @listTypeTryConversionAppend(ptr noundef %4, ptr noundef nonnull %value.addr, i32 noundef 0, i32 noundef 0, ptr noundef nonnull @moduleFreeListIterator, ptr noundef %key) #32
  %call47 = call i32 @moduleListIteratorSeek(ptr noundef %key, i64 noundef %index, i32 noundef 2), !range !22
  %tobool48.not = icmp eq i32 %call47, 0
  br i1 %tobool48.not, label %return, label %if.then49

if.then49:                                        ; preds = %if.end45
  %index.lobit = lshr i64 %index, 63
  %cond = trunc i64 %index.lobit to i32
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %5 = load ptr, ptr %value.addr, align 8
  call void @listTypeInsert(ptr noundef nonnull %u, ptr noundef %5, i32 noundef %cond) #32
  call fastcc void @moduleFreeKeyIterator(ptr noundef nonnull %key)
  br label %return

return:                                           ; preds = %if.end45, %if.then49, %if.then41, %if.then22, %if.then6, %if.then
  %retval.0 = phi i32 [ %call7, %if.then6 ], [ %call23, %if.then22 ], [ %call42, %if.then41 ], [ 0, %if.then49 ], [ 1, %if.then ], [ 1, %if.end45 ]
  ret i32 %retval.0
}

declare void @listTypeInsert(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ListDelete(ptr noundef %key, i64 noundef %index) #0 {
entry:
  %call = tail call i32 @moduleListIteratorSeek(ptr noundef %key, i64 noundef %index, i32 noundef 2), !range !22
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %0 = load ptr, ptr %iter, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  tail call void @listTypeDelete(ptr noundef %0, ptr noundef nonnull %u) #32
  %call2 = tail call i32 @moduleDelKeyIfEmpty(ptr noundef %key), !range !22
  %tobool3.not = icmp eq i32 %call2, 0
  br i1 %tobool3.not, label %if.end, label %return

if.end:                                           ; preds = %if.then
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  tail call void @listTypeTryConversion(ptr noundef %1, i32 noundef 2, ptr noundef nonnull @moduleFreeListIterator, ptr noundef nonnull %key) #32
  %2 = load ptr, ptr %iter, align 8
  %tobool6.not = icmp eq ptr %2, null
  br i1 %tobool6.not, label %return, label %if.end8

if.end8:                                          ; preds = %if.end
  %call12 = tail call i32 @listTypeNext(ptr noundef nonnull %2, ptr noundef nonnull %u) #32
  %tobool13.not = icmp eq i32 %call12, 0
  br i1 %tobool13.not, label %if.else33, label %if.then14

if.then14:                                        ; preds = %if.end8
  %3 = load ptr, ptr %iter, align 8
  %direction = getelementptr inbounds %struct.listTypeIterator, ptr %3, i64 0, i32 2
  %4 = load i8, ptr %direction, align 1
  %cmp = icmp eq i8 %4, 0
  %index18 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  %5 = load i64, ptr %index18, align 8
  %cmp19 = icmp slt i64 %5, 0
  br i1 %cmp19, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.then14
  %not.cmp = xor i1 %cmp, true
  %conv23 = zext i1 %not.cmp to i64
  %add = add nsw i64 %5, %conv23
  store i64 %add, ptr %index18, align 8
  br label %return

if.else:                                          ; preds = %if.then14
  %conv28 = sext i1 %cmp to i64
  %add31 = add nsw i64 %5, %conv28
  store i64 %add31, ptr %index18, align 8
  br label %return

if.else33:                                        ; preds = %if.end8
  tail call fastcc void @moduleFreeKeyIterator(ptr noundef nonnull %key)
  br label %return

return:                                           ; preds = %entry, %if.else33, %if.else, %if.then21, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %if.end ], [ 0, %if.then21 ], [ 0, %if.else ], [ 0, %if.else33 ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @listTypeDelete(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local i32 @moduleZsetAddFlagsToCoreFlags(i32 noundef %flags) local_unnamed_addr #22 {
entry:
  %trunc = trunc i32 %flags to i3
  %rev = tail call i3 @llvm.bitreverse.i3(i3 %trunc)
  %mask = and i3 %rev, -2
  %retflags.1 = zext i3 %mask to i32
  %and6 = lshr i32 %flags, 2
  %retflags.2 = and i32 %and6, 24
  %retflags.3 = or disjoint i32 %retflags.2, %retflags.1
  ret i32 %retflags.3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local i32 @moduleZsetAddFlagsFromCoreFlags(i32 noundef %flags) local_unnamed_addr #22 {
entry:
  %retflags.1 = and i32 %flags, 12
  %and6 = shl i32 %flags, 4
  %0 = and i32 %and6, 16
  %retflags.2 = or disjoint i32 %0, %retflags.1
  ret i32 %retflags.2
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetAdd(ptr nocapture noundef %key, double noundef %score, ptr nocapture noundef readonly %ele, ptr noundef %flagsptr) #0 {
entry:
  %out_flags = alloca i32, align 4
  store i32 0, ptr %out_flags, align 4
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end.i, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end8, label %return

if.end.i:                                         ; preds = %if.end
  %call3.i = tail call ptr @createZsetListpackObject() #32
  %db.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %2 = load ptr, ptr %db.i, align 8
  %key8.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %3 = load ptr, ptr %key8.i, align 8
  tail call void @dbAdd(ptr noundef %2, ptr noundef %3, ptr noundef %call3.i) #32
  store ptr %call3.i, ptr %value, align 8
  %bf.load.i.i = load i32, ptr %call3.i, align 8
  %bf.clear.i.i = and i32 %bf.load.i.i, 15
  switch i32 %bf.clear.i.i, label %if.end8 [
    i32 3, label %sw.bb.i.i
    i32 6, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %u.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  store i32 0, ptr %u.i.i.i, align 8
  %current.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i.i, align 8
  %er.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i.i.i, align 8
  br label %if.end8

sw.bb1.i.i:                                       ; preds = %if.end.i
  %signalready.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 0, ptr %signalready.i.i, align 8
  br label %if.end8

if.end8:                                          ; preds = %sw.bb1.i.i, %sw.bb.i.i, %if.end.i, %land.lhs.true
  %4 = phi ptr [ %call3.i, %sw.bb1.i.i ], [ %call3.i, %sw.bb.i.i ], [ %call3.i, %if.end.i ], [ %1, %land.lhs.true ]
  %tobool9.not = icmp eq ptr %flagsptr, null
  br i1 %tobool9.not, label %if.end12, label %if.end12.thread

if.end12:                                         ; preds = %if.end8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %ele, i64 0, i32 2
  %5 = load ptr, ptr %ptr, align 8
  %call14 = call i32 @zsetAdd(ptr noundef nonnull %4, double noundef %score, ptr noundef %5, i32 noundef 0, ptr noundef nonnull %out_flags, ptr noundef null) #32
  %cmp15 = icmp eq i32 %call14, 0
  br i1 %cmp15, label %if.end19, label %return

if.end12.thread:                                  ; preds = %if.end8
  %6 = load i32, ptr %flagsptr, align 4
  %trunc.i = trunc i32 %6 to i3
  %rev.i = tail call i3 @llvm.bitreverse.i3(i3 %trunc.i)
  %mask.i = and i3 %rev.i, -2
  %retflags.1.i = zext i3 %mask.i to i32
  %and6.i = lshr i32 %6, 2
  %retflags.2.i = and i32 %and6.i, 24
  %retflags.3.i = or disjoint i32 %retflags.2.i, %retflags.1.i
  %ptr16 = getelementptr inbounds %struct.redisObject, ptr %ele, i64 0, i32 2
  %7 = load ptr, ptr %ptr16, align 8
  %call1417 = call i32 @zsetAdd(ptr noundef nonnull %4, double noundef %score, ptr noundef %7, i32 noundef %retflags.3.i, ptr noundef nonnull %out_flags, ptr noundef null) #32
  %cmp1518 = icmp eq i32 %call1417, 0
  br i1 %cmp1518, label %if.then18, label %if.then23

if.then18:                                        ; preds = %if.end12.thread
  store i32 0, ptr %flagsptr, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.end12, %if.then18
  %call20 = call i32 @moduleDelKeyIfEmpty(ptr noundef nonnull %key), !range !22
  br label %return

if.then23:                                        ; preds = %if.end12.thread
  %8 = load i32, ptr %out_flags, align 4
  %retflags.1.i12 = and i32 %8, 12
  %and6.i13 = shl i32 %8, 4
  %9 = and i32 %and6.i13, 16
  %retflags.2.i14 = or disjoint i32 %9, %retflags.1.i12
  store i32 %retflags.2.i14, ptr %flagsptr, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then23, %land.lhs.true, %entry, %if.end19
  %retval.0 = phi i32 [ 1, %if.end19 ], [ 1, %entry ], [ 1, %land.lhs.true ], [ 0, %if.then23 ], [ 0, %if.end12 ]
  ret i32 %retval.0
}

declare i32 @zsetAdd(ptr noundef, double noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetIncrby(ptr nocapture noundef %key, double noundef %score, ptr nocapture noundef readonly %ele, ptr noundef %flagsptr, ptr noundef %newscore) #0 {
entry:
  %out_flags = alloca i32, align 4
  store i32 0, ptr %out_flags, align 4
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end.i, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end8, label %return

if.end.i:                                         ; preds = %if.end
  %call3.i = tail call ptr @createZsetListpackObject() #32
  %db.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %2 = load ptr, ptr %db.i, align 8
  %key8.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %3 = load ptr, ptr %key8.i, align 8
  tail call void @dbAdd(ptr noundef %2, ptr noundef %3, ptr noundef %call3.i) #32
  store ptr %call3.i, ptr %value, align 8
  %bf.load.i.i = load i32, ptr %call3.i, align 8
  %bf.clear.i.i = and i32 %bf.load.i.i, 15
  switch i32 %bf.clear.i.i, label %if.end8 [
    i32 3, label %sw.bb.i.i
    i32 6, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %u.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  store i32 0, ptr %u.i.i.i, align 8
  %current.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i.i, align 8
  %er.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i.i.i, align 8
  br label %if.end8

sw.bb1.i.i:                                       ; preds = %if.end.i
  %signalready.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 0, ptr %signalready.i.i, align 8
  br label %if.end8

if.end8:                                          ; preds = %sw.bb1.i.i, %sw.bb.i.i, %if.end.i, %land.lhs.true
  %4 = phi ptr [ %call3.i, %sw.bb1.i.i ], [ %call3.i, %sw.bb.i.i ], [ %call3.i, %if.end.i ], [ %1, %land.lhs.true ]
  %tobool9.not = icmp eq ptr %flagsptr, null
  br i1 %tobool9.not, label %if.end12, label %if.end12.thread

if.end12:                                         ; preds = %if.end8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %ele, i64 0, i32 2
  %5 = load ptr, ptr %ptr, align 8
  %call14 = call i32 @zsetAdd(ptr noundef nonnull %4, double noundef %score, ptr noundef %5, i32 noundef 1, ptr noundef nonnull %out_flags, ptr noundef %newscore) #32
  %cmp15 = icmp eq i32 %call14, 0
  br i1 %cmp15, label %if.end19, label %return

if.end12.thread:                                  ; preds = %if.end8
  %6 = load i32, ptr %flagsptr, align 4
  %trunc.i = trunc i32 %6 to i3
  %rev.i = tail call i3 @llvm.bitreverse.i3(i3 %trunc.i)
  %retflags.1.i = zext i3 %rev.i to i32
  %and6.i = lshr i32 %6, 2
  %retflags.2.i = and i32 %and6.i, 24
  %retflags.3.i = or disjoint i32 %retflags.2.i, %retflags.1.i
  %7 = or i32 %retflags.3.i, 1
  %ptr17 = getelementptr inbounds %struct.redisObject, ptr %ele, i64 0, i32 2
  %8 = load ptr, ptr %ptr17, align 8
  %call1418 = call i32 @zsetAdd(ptr noundef nonnull %4, double noundef %score, ptr noundef %8, i32 noundef %7, ptr noundef nonnull %out_flags, ptr noundef %newscore) #32
  %cmp1519 = icmp eq i32 %call1418, 0
  br i1 %cmp1519, label %if.then18, label %if.then23

if.then18:                                        ; preds = %if.end12.thread
  store i32 0, ptr %flagsptr, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.end12, %if.then18
  %call20 = call i32 @moduleDelKeyIfEmpty(ptr noundef nonnull %key), !range !22
  br label %return

if.then23:                                        ; preds = %if.end12.thread
  %9 = load i32, ptr %out_flags, align 4
  %retflags.1.i13 = and i32 %9, 12
  %and6.i14 = shl i32 %9, 4
  %10 = and i32 %and6.i14, 16
  %retflags.2.i15 = or disjoint i32 %10, %retflags.1.i13
  store i32 %retflags.2.i15, ptr %flagsptr, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then23, %land.lhs.true, %entry, %if.end19
  %retval.0 = phi i32 [ 1, %if.end19 ], [ 1, %entry ], [ 1, %land.lhs.true ], [ 0, %if.then23 ], [ 0, %if.end12 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetRem(ptr nocapture noundef %key, ptr nocapture noundef readonly %ele, ptr noundef writeonly %deleted) #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %land.lhs.true7, label %return

land.lhs.true7:                                   ; preds = %land.lhs.true
  %ptr = getelementptr inbounds %struct.redisObject, ptr %ele, i64 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %call = tail call i32 @zsetDel(ptr noundef nonnull %1, ptr noundef %2) #32
  %tobool9.not = icmp eq i32 %call, 0
  br i1 %tobool9.not, label %if.else, label %if.then10

if.then10:                                        ; preds = %land.lhs.true7
  %tobool11.not = icmp eq ptr %deleted, null
  br i1 %tobool11.not, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.then10
  store i32 1, ptr %deleted, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then10
  %call14 = tail call i32 @moduleDelKeyIfEmpty(ptr noundef nonnull %key), !range !22
  br label %return

if.else:                                          ; preds = %if.end, %land.lhs.true7
  %tobool15.not = icmp eq ptr %deleted, null
  br i1 %tobool15.not, label %return, label %if.then16

if.then16:                                        ; preds = %if.else
  store i32 0, ptr %deleted, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then16, %if.else, %land.lhs.true, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 1, %land.lhs.true ], [ 0, %if.else ], [ 0, %if.then16 ], [ 0, %if.end13 ]
  ret i32 %retval.0
}

declare i32 @zsetDel(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetScore(ptr nocapture noundef readonly %key, ptr nocapture noundef readonly %ele, ptr noundef %score) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp2.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp2.not, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %ptr = getelementptr inbounds %struct.redisObject, ptr %ele, i64 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %call = tail call i32 @zsetScore(ptr noundef nonnull %0, ptr noundef %1, ptr noundef %score) #32
  %cmp6 = icmp eq i32 %call, -1
  %. = zext i1 %cmp6 to i32
  br label %return

return:                                           ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 1, %if.end ], [ %., %if.end4 ]
  ret i32 %retval.0
}

declare i32 @zsetScore(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_ZsetRangeStop(ptr noundef %key) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %1 = load i32, ptr %u, align 8
  %cmp2 = icmp eq i32 %1, 1
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %lrs = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  tail call void @zslFreeLexRange(ptr noundef nonnull %lrs) #32
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  store i32 0, ptr %u, align 8
  %current.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i, align 8
  %er.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end5
  ret void
}

declare void @zslFreeLexRange(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @RM_ZsetRangeEndReached(ptr nocapture noundef readonly %key) #11 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %er = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  %1 = load i32, ptr %er, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i32 [ %1, %if.end ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @zsetInitScoreRange(ptr noundef %key, double noundef %min, double noundef %max, i32 noundef %minex, i32 noundef %maxex, i32 noundef %first) local_unnamed_addr #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end.i, label %return

if.end.i:                                         ; preds = %lor.lhs.false
  %u.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %1 = load i32, ptr %u.i, align 8
  %cmp2.i = icmp eq i32 %1, 1
  br i1 %cmp2.i, label %if.then3.i, label %RM_ZsetRangeStop.exit

if.then3.i:                                       ; preds = %if.end.i
  %lrs.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  tail call void @zslFreeLexRange(ptr noundef nonnull %lrs.i) #32
  %.pre = load ptr, ptr %value, align 8
  br label %RM_ZsetRangeStop.exit

RM_ZsetRangeStop.exit:                            ; preds = %if.end.i, %if.then3.i
  %2 = phi ptr [ %0, %if.end.i ], [ %.pre, %if.then3.i ]
  %current.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i, align 8
  %er.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 2, ptr %u.i, align 8
  store i32 0, ptr %er.i.i, align 8
  %rs = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 1
  store double %min, ptr %rs, align 8
  %max5 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2
  store double %max, ptr %max5, align 8
  %minex6 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 %minex, ptr %minex6, align 8
  %maxex7 = getelementptr inbounds i8, ptr %key, i64 76
  store i32 %maxex, ptr %maxex7, align 4
  %bf.load9 = load i32, ptr %2, align 8
  %bf.lshr = lshr i32 %bf.load9, 4
  %bf.clear10 = and i32 %bf.lshr, 15
  switch i32 %bf.clear10, label %if.else37 [
    i32 11, label %if.then12
    i32 7, label %if.then24
  ]

if.then12:                                        ; preds = %RM_ZsetRangeStop.exit
  %tobool13.not = icmp eq i32 %first, 0
  %ptr16 = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %ptr16, align 8
  br i1 %tobool13.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then12
  %call = tail call ptr @zzlFirstInRange(ptr noundef %3, ptr noundef nonnull %rs) #32
  br label %if.end39

cond.false:                                       ; preds = %if.then12
  %call17 = tail call ptr @zzlLastInRange(ptr noundef %3, ptr noundef nonnull %rs) #32
  br label %if.end39

if.then24:                                        ; preds = %RM_ZsetRangeStop.exit
  %ptr26 = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %4 = load ptr, ptr %ptr26, align 8
  %zsl27 = getelementptr inbounds %struct.zset, ptr %4, i64 0, i32 1
  %5 = load ptr, ptr %zsl27, align 8
  %tobool28.not = icmp eq i32 %first, 0
  br i1 %tobool28.not, label %cond.false31, label %cond.true29

cond.true29:                                      ; preds = %if.then24
  %call30 = tail call ptr @zslNthInRange(ptr noundef %5, ptr noundef nonnull %rs, i64 noundef 0) #32
  br label %if.end39

cond.false31:                                     ; preds = %if.then24
  %call32 = tail call ptr @zslNthInRange(ptr noundef %5, ptr noundef nonnull %rs, i64 noundef -1) #32
  br label %if.end39

if.else37:                                        ; preds = %RM_ZsetRangeStop.exit
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 4886, ptr noundef nonnull @.str.45) #32
  tail call void @abort() #35
  unreachable

if.end39:                                         ; preds = %cond.true29, %cond.false31, %cond.true, %cond.false
  %6 = phi ptr [ %call, %cond.true ], [ %call17, %cond.false ], [ %call30, %cond.true29 ], [ %call32, %cond.false31 ]
  store ptr %6, ptr %current.i.i, align 8
  %cmp42 = icmp eq ptr %6, null
  br i1 %cmp42, label %if.then43, label %return

if.then43:                                        ; preds = %if.end39
  store i32 1, ptr %er.i.i, align 8
  br label %return

return:                                           ; preds = %if.end39, %if.then43, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 0, %if.then43 ], [ 0, %if.end39 ]
  ret i32 %retval.0
}

declare ptr @zzlFirstInRange(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @zzlLastInRange(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @zslNthInRange(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetFirstInScoreRange(ptr noundef %key, double noundef %min, double noundef %max, i32 noundef %minex, i32 noundef %maxex) #0 {
entry:
  %call = tail call i32 @zsetInitScoreRange(ptr noundef %key, double noundef %min, double noundef %max, i32 noundef %minex, i32 noundef %maxex, i32 noundef 1), !range !22
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetLastInScoreRange(ptr noundef %key, double noundef %min, double noundef %max, i32 noundef %minex, i32 noundef %maxex) #0 {
entry:
  %call = tail call i32 @zsetInitScoreRange(ptr noundef %key, double noundef %min, double noundef %max, i32 noundef %minex, i32 noundef %maxex, i32 noundef 0), !range !22
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @zsetInitLexRange(ptr noundef %key, ptr noundef %min, ptr noundef %max, i32 noundef %first) local_unnamed_addr #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end.i, label %return

if.end.i:                                         ; preds = %lor.lhs.false
  %u.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %1 = load i32, ptr %u.i, align 8
  %cmp2.i = icmp eq i32 %1, 1
  br i1 %cmp2.i, label %if.then3.i, label %RM_ZsetRangeStop.exit

if.then3.i:                                       ; preds = %if.end.i
  %lrs.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  tail call void @zslFreeLexRange(ptr noundef nonnull %lrs.i) #32
  br label %RM_ZsetRangeStop.exit

RM_ZsetRangeStop.exit:                            ; preds = %if.end.i, %if.then3.i
  store i32 0, ptr %u.i, align 8
  %current.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i, align 8
  %er = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 0, ptr %er, align 8
  %lrs = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  %call = tail call i32 @zslParseLexRange(ptr noundef %min, ptr noundef %max, ptr noundef nonnull %lrs) #32
  %cmp3 = icmp eq i32 %call, -1
  br i1 %cmp3, label %return, label %if.end5

if.end5:                                          ; preds = %RM_ZsetRangeStop.exit
  store i32 1, ptr %u.i, align 8
  %2 = load ptr, ptr %value, align 8
  %bf.load8 = load i32, ptr %2, align 8
  %bf.lshr = lshr i32 %bf.load8, 4
  %bf.clear9 = and i32 %bf.lshr, 15
  switch i32 %bf.clear9, label %if.else37 [
    i32 11, label %if.then11
    i32 7, label %if.then24
  ]

if.then11:                                        ; preds = %if.end5
  %tobool12.not = icmp eq i32 %first, 0
  %ptr16 = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %ptr16, align 8
  br i1 %tobool12.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then11
  %call14 = tail call ptr @zzlFirstInLexRange(ptr noundef %3, ptr noundef nonnull %lrs) #32
  br label %if.end39

cond.false:                                       ; preds = %if.then11
  %call17 = tail call ptr @zzlLastInLexRange(ptr noundef %3, ptr noundef nonnull %lrs) #32
  br label %if.end39

if.then24:                                        ; preds = %if.end5
  %ptr26 = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %4 = load ptr, ptr %ptr26, align 8
  %zsl27 = getelementptr inbounds %struct.zset, ptr %4, i64 0, i32 1
  %5 = load ptr, ptr %zsl27, align 8
  %tobool28.not = icmp eq i32 %first, 0
  br i1 %tobool28.not, label %cond.false31, label %cond.true29

cond.true29:                                      ; preds = %if.then24
  %call30 = tail call ptr @zslNthInLexRange(ptr noundef %5, ptr noundef nonnull %lrs, i64 noundef 0) #32
  br label %if.end39

cond.false31:                                     ; preds = %if.then24
  %call32 = tail call ptr @zslNthInLexRange(ptr noundef %5, ptr noundef nonnull %lrs, i64 noundef -1) #32
  br label %if.end39

if.else37:                                        ; preds = %if.end5
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 4950, ptr noundef nonnull @.str.45) #32
  tail call void @abort() #35
  unreachable

if.end39:                                         ; preds = %cond.true29, %cond.false31, %cond.true, %cond.false
  %6 = phi ptr [ %call14, %cond.true ], [ %call17, %cond.false ], [ %call30, %cond.true29 ], [ %call32, %cond.false31 ]
  store ptr %6, ptr %current.i.i, align 8
  %cmp42 = icmp eq ptr %6, null
  br i1 %cmp42, label %if.then43, label %return

if.then43:                                        ; preds = %if.end39
  store i32 1, ptr %er, align 8
  br label %return

return:                                           ; preds = %if.end39, %if.then43, %RM_ZsetRangeStop.exit, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %RM_ZsetRangeStop.exit ], [ 0, %if.then43 ], [ 0, %if.end39 ]
  ret i32 %retval.0
}

declare i32 @zslParseLexRange(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @zzlFirstInLexRange(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @zzlLastInLexRange(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @zslNthInLexRange(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetFirstInLexRange(ptr noundef %key, ptr noundef %min, ptr noundef %max) #0 {
entry:
  %call = tail call i32 @zsetInitLexRange(ptr noundef %key, ptr noundef %min, ptr noundef %max, i32 noundef 1), !range !22
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetLastInLexRange(ptr noundef %key, ptr noundef %min, ptr noundef %max) #0 {
entry:
  %call = tail call i32 @zsetInitLexRange(ptr noundef %key, ptr noundef %min, ptr noundef %max, i32 noundef 0), !range !22
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ZsetRangeCurrentElement(ptr nocapture noundef readonly %key, ptr noundef writeonly %score) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %current = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  %1 = load ptr, ptr %current, align 8
  %cmp2 = icmp eq ptr %1, null
  br i1 %cmp2, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear7 = and i32 %bf.lshr, 15
  switch i32 %bf.clear7, label %if.else35 [
    i32 11, label %if.then9
    i32 7, label %if.then24
  ]

if.then9:                                         ; preds = %if.end4
  %call = tail call ptr @lpGetObject(ptr noundef nonnull %1) #32
  %tobool12.not = icmp eq ptr %score, null
  br i1 %tobool12.not, label %if.end17, label %if.then13

if.then13:                                        ; preds = %if.then9
  %2 = load ptr, ptr %value, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call15 = tail call ptr @lpNext(ptr noundef %3, ptr noundef nonnull %1) #32
  %call16 = tail call double @zzlGetScore(ptr noundef %call15) #32
  store double %call16, ptr %score, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then13, %if.then9
  %call18 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call) #32
  br label %if.end37

if.then24:                                        ; preds = %if.end4
  %tobool27.not = icmp eq ptr %score, null
  br i1 %tobool27.not, label %if.end30, label %if.then28

if.then28:                                        ; preds = %if.then24
  %score29 = getelementptr inbounds %struct.zskiplistNode, ptr %1, i64 0, i32 1
  %4 = load double, ptr %score29, align 8
  store double %4, ptr %score, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.then24
  %5 = load ptr, ptr %1, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %5, i64 -1
  %6 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %6 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end30
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end30
  %add.ptr.i = getelementptr inbounds i8, ptr %5, i64 -3
  %7 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %7 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end30
  %add.ptr6.i = getelementptr inbounds i8, ptr %5, i64 -5
  %8 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %8 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end30
  %add.ptr10.i = getelementptr inbounds i8, ptr %5, i64 -9
  %9 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %9 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end30
  %add.ptr14.i = getelementptr inbounds i8, ptr %5, i64 -17
  %10 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end30, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %10, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end30 ]
  %call34 = tail call ptr @createStringObject(ptr noundef nonnull %5, i64 noundef %retval.0.i) #32
  br label %if.end37

if.else35:                                        ; preds = %if.end4
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 5001, ptr noundef nonnull @.str.45) #32
  tail call void @abort() #35
  unreachable

if.end37:                                         ; preds = %sdslen.exit, %if.end17
  %str.0 = phi ptr [ %call18, %if.end17 ], [ %call34, %sdslen.exit ]
  %11 = load ptr, ptr %key, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i64 0, i32 7
  %12 = load i32, ptr %flags.i, align 8
  %and.i17 = and i32 %12, 1
  %tobool.not.i = icmp eq i32 %and.i17, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.end37
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i64 0, i32 6
  %13 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i64 0, i32 5
  %14 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %13, %14
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %13, 1
  %cmp4.i = icmp slt i32 %13, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i64 0, i32 4
  %15 = load ptr, ptr %amqueue.i, align 8
  %conv.i18 = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i18, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %15, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %16 = phi i32 [ %13, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %17 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i64 0, i32 4
  %idxprom.i = sext i32 %16 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %17, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %18 = load ptr, ptr %amqueue12.i, align 8
  %19 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %19 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %18, i64 %idxprom17.i
  store ptr %str.0, ptr %arrayidx18.i, align 8
  %20 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %20, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end11.i, %if.end37, %if.end, %entry, %lor.lhs.false
  %retval.0 = phi ptr [ null, %lor.lhs.false ], [ null, %entry ], [ null, %if.end ], [ %str.0, %if.end37 ], [ %str.0, %if.end11.i ]
  ret ptr %retval.0
}

declare ptr @lpGetObject(ptr noundef) local_unnamed_addr #1

declare ptr @lpNext(ptr noundef, ptr noundef) local_unnamed_addr #1

declare double @zzlGetScore(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetRangeNext(ptr noundef %key) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %1 = load i32, ptr %u, align 8
  %tobool2.not = icmp eq i32 %1, 0
  br i1 %tobool2.not, label %return, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.end
  %current = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  %2 = load ptr, ptr %current, align 8
  %tobool5.not = icmp eq ptr %2, null
  br i1 %tobool5.not, label %return, label %if.end7

if.end7:                                          ; preds = %lor.lhs.false3
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear10 = and i32 %bf.lshr, 15
  switch i32 %bf.clear10, label %if.else95 [
    i32 11, label %if.then12
    i32 7, label %if.then58
  ]

if.then12:                                        ; preds = %if.end7
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call = tail call ptr @lpNext(ptr noundef %3, ptr noundef nonnull %2) #32
  %tobool16.not = icmp eq ptr %call, null
  br i1 %tobool16.not, label %if.then21, label %if.end19

if.end19:                                         ; preds = %if.then12
  %call18 = tail call ptr @lpNext(ptr noundef %3, ptr noundef nonnull %call) #32
  %cmp20 = icmp eq ptr %call18, null
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.then12, %if.end19
  %er = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er, align 8
  br label %return

if.else:                                          ; preds = %if.end19
  %4 = load i32, ptr %u, align 8
  switch i32 %4, label %if.end49 [
    i32 2, label %if.then26
    i32 1, label %if.then40
  ]

if.then26:                                        ; preds = %if.else
  %call27 = tail call ptr @lpNext(ptr noundef %3, ptr noundef nonnull %call18) #32
  %call28 = tail call double @zzlGetScore(ptr noundef %call27) #32
  %rs = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 1
  %call30 = tail call i32 @zslValueLteMax(double noundef %call28, ptr noundef nonnull %rs) #32
  %tobool31.not = icmp eq i32 %call30, 0
  br i1 %tobool31.not, label %if.then32, label %if.end49

if.then32:                                        ; preds = %if.then26
  %er34 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er34, align 8
  br label %return

if.then40:                                        ; preds = %if.else
  %lrs = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  %call42 = tail call i32 @zzlLexValueLteMax(ptr noundef nonnull %call18, ptr noundef nonnull %lrs) #32
  %tobool43.not = icmp eq i32 %call42, 0
  br i1 %tobool43.not, label %if.then44, label %if.end49

if.then44:                                        ; preds = %if.then40
  %er46 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er46, align 8
  br label %return

if.end49:                                         ; preds = %if.else, %if.then26, %if.then40
  store ptr %call18, ptr %current, align 8
  br label %return

if.then58:                                        ; preds = %if.end7
  %level = getelementptr inbounds %struct.zskiplistNode, ptr %2, i64 0, i32 3
  %5 = load ptr, ptr %level, align 8
  %cmp62 = icmp eq ptr %5, null
  br i1 %cmp62, label %if.then63, label %if.else66

if.then63:                                        ; preds = %if.then58
  %er65 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er65, align 8
  br label %return

if.else66:                                        ; preds = %if.then58
  %cmp69 = icmp eq i32 %1, 2
  br i1 %cmp69, label %land.lhs.true, label %if.else78

land.lhs.true:                                    ; preds = %if.else66
  %score70 = getelementptr inbounds %struct.zskiplistNode, ptr %5, i64 0, i32 1
  %6 = load double, ptr %score70, align 8
  %rs72 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 1
  %call73 = tail call i32 @zslValueLteMax(double noundef %6, ptr noundef nonnull %rs72) #32
  %tobool74.not = icmp eq i32 %call73, 0
  br i1 %tobool74.not, label %if.then75, label %land.lhs.true.if.else78_crit_edge

land.lhs.true.if.else78_crit_edge:                ; preds = %land.lhs.true
  %.pre = load i32, ptr %u, align 8
  br label %if.else78

if.then75:                                        ; preds = %land.lhs.true
  %er77 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er77, align 8
  br label %return

if.else78:                                        ; preds = %land.lhs.true.if.else78_crit_edge, %if.else66
  %7 = phi i32 [ %.pre, %land.lhs.true.if.else78_crit_edge ], [ %1, %if.else66 ]
  %cmp81 = icmp eq i32 %7, 1
  br i1 %cmp81, label %if.then82, label %if.end92

if.then82:                                        ; preds = %if.else78
  %8 = load ptr, ptr %5, align 8
  %lrs84 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  %call85 = tail call i32 @zslLexValueLteMax(ptr noundef %8, ptr noundef nonnull %lrs84) #32
  %tobool86.not = icmp eq i32 %call85, 0
  br i1 %tobool86.not, label %if.then87, label %if.end92

if.then87:                                        ; preds = %if.then82
  %er89 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er89, align 8
  br label %return

if.end92:                                         ; preds = %if.else78, %if.then82
  store ptr %5, ptr %current, align 8
  br label %return

if.else95:                                        ; preds = %if.end7
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 5067, ptr noundef nonnull @.str.45) #32
  tail call void @abort() #35
  unreachable

return:                                           ; preds = %if.end, %lor.lhs.false3, %entry, %lor.lhs.false, %if.end92, %if.then87, %if.then75, %if.then63, %if.end49, %if.then44, %if.then32, %if.then21
  %retval.0 = phi i32 [ 0, %if.then21 ], [ 1, %if.end49 ], [ 0, %if.then32 ], [ 0, %if.then44 ], [ 0, %if.then63 ], [ 1, %if.end92 ], [ 0, %if.then87 ], [ 0, %if.then75 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %lor.lhs.false3 ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare i32 @zslValueLteMax(double noundef, ptr noundef) local_unnamed_addr #1

declare i32 @zzlLexValueLteMax(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @zslLexValueLteMax(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ZsetRangePrev(ptr noundef %key) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 3
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %1 = load i32, ptr %u, align 8
  %tobool2.not = icmp eq i32 %1, 0
  br i1 %tobool2.not, label %return, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.end
  %current = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  %2 = load ptr, ptr %current, align 8
  %tobool5.not = icmp eq ptr %2, null
  br i1 %tobool5.not, label %return, label %if.end7

if.end7:                                          ; preds = %lor.lhs.false3
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear10 = and i32 %bf.lshr, 15
  switch i32 %bf.clear10, label %if.else95 [
    i32 11, label %if.then12
    i32 7, label %if.then58
  ]

if.then12:                                        ; preds = %if.end7
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call = tail call ptr @lpPrev(ptr noundef %3, ptr noundef nonnull %2) #32
  %tobool16.not = icmp eq ptr %call, null
  br i1 %tobool16.not, label %if.then21, label %if.end19

if.end19:                                         ; preds = %if.then12
  %call18 = tail call ptr @lpPrev(ptr noundef %3, ptr noundef nonnull %call) #32
  %cmp20 = icmp eq ptr %call18, null
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.then12, %if.end19
  %er = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er, align 8
  br label %return

if.else:                                          ; preds = %if.end19
  %4 = load i32, ptr %u, align 8
  switch i32 %4, label %if.end49 [
    i32 2, label %if.then26
    i32 1, label %if.then40
  ]

if.then26:                                        ; preds = %if.else
  %call27 = tail call ptr @lpNext(ptr noundef %3, ptr noundef nonnull %call18) #32
  %call28 = tail call double @zzlGetScore(ptr noundef %call27) #32
  %rs = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 1
  %call30 = tail call i32 @zslValueGteMin(double noundef %call28, ptr noundef nonnull %rs) #32
  %tobool31.not = icmp eq i32 %call30, 0
  br i1 %tobool31.not, label %if.then32, label %if.end49

if.then32:                                        ; preds = %if.then26
  %er34 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er34, align 8
  br label %return

if.then40:                                        ; preds = %if.else
  %lrs = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  %call42 = tail call i32 @zzlLexValueGteMin(ptr noundef nonnull %call18, ptr noundef nonnull %lrs) #32
  %tobool43.not = icmp eq i32 %call42, 0
  br i1 %tobool43.not, label %if.then44, label %if.end49

if.then44:                                        ; preds = %if.then40
  %er46 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er46, align 8
  br label %return

if.end49:                                         ; preds = %if.else, %if.then26, %if.then40
  store ptr %call18, ptr %current, align 8
  br label %return

if.then58:                                        ; preds = %if.end7
  %backward = getelementptr inbounds %struct.zskiplistNode, ptr %2, i64 0, i32 2
  %5 = load ptr, ptr %backward, align 8
  %cmp62 = icmp eq ptr %5, null
  br i1 %cmp62, label %if.then63, label %if.else66

if.then63:                                        ; preds = %if.then58
  %er65 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er65, align 8
  br label %return

if.else66:                                        ; preds = %if.then58
  %cmp69 = icmp eq i32 %1, 2
  br i1 %cmp69, label %land.lhs.true, label %if.else78

land.lhs.true:                                    ; preds = %if.else66
  %score70 = getelementptr inbounds %struct.zskiplistNode, ptr %5, i64 0, i32 1
  %6 = load double, ptr %score70, align 8
  %rs72 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 1
  %call73 = tail call i32 @zslValueGteMin(double noundef %6, ptr noundef nonnull %rs72) #32
  %tobool74.not = icmp eq i32 %call73, 0
  br i1 %tobool74.not, label %if.then75, label %land.lhs.true.if.else78_crit_edge

land.lhs.true.if.else78_crit_edge:                ; preds = %land.lhs.true
  %.pre = load i32, ptr %u, align 8
  br label %if.else78

if.then75:                                        ; preds = %land.lhs.true
  %er77 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er77, align 8
  br label %return

if.else78:                                        ; preds = %land.lhs.true.if.else78_crit_edge, %if.else66
  %7 = phi i32 [ %.pre, %land.lhs.true.if.else78_crit_edge ], [ %1, %if.else66 ]
  %cmp81 = icmp eq i32 %7, 1
  br i1 %cmp81, label %if.then82, label %if.end92

if.then82:                                        ; preds = %if.else78
  %8 = load ptr, ptr %5, align 8
  %lrs84 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 2
  %call85 = tail call i32 @zslLexValueGteMin(ptr noundef %8, ptr noundef nonnull %lrs84) #32
  %tobool86.not = icmp eq i32 %call85, 0
  br i1 %tobool86.not, label %if.then87, label %if.end92

if.then87:                                        ; preds = %if.then82
  %er89 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er89, align 8
  br label %return

if.end92:                                         ; preds = %if.else78, %if.then82
  store ptr %5, ptr %current, align 8
  br label %return

if.else95:                                        ; preds = %if.end7
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 5131, ptr noundef nonnull @.str.45) #32
  tail call void @abort() #35
  unreachable

return:                                           ; preds = %if.end, %lor.lhs.false3, %entry, %lor.lhs.false, %if.end92, %if.then87, %if.then75, %if.then63, %if.end49, %if.then44, %if.then32, %if.then21
  %retval.0 = phi i32 [ 0, %if.then21 ], [ 1, %if.end49 ], [ 0, %if.then32 ], [ 0, %if.then44 ], [ 0, %if.then63 ], [ 1, %if.end92 ], [ 0, %if.then87 ], [ 0, %if.then75 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %lor.lhs.false3 ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare ptr @lpPrev(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @zslValueGteMin(double noundef, ptr noundef) local_unnamed_addr #1

declare i32 @zzlLexValueGteMin(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @zslLexValueGteMin(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_HashSet(ptr noundef %key, i32 noundef %flags, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %argv = alloca [2 x ptr], align 16
  %tobool.not = icmp ne ptr %key, null
  %and = and i32 %flags, -24
  %tobool1.not = icmp eq i32 %and, 0
  %or.cond41 = and i1 %tobool.not, %tobool1.not
  br i1 %or.cond41, label %if.else, label %return.sink.split

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool2.not = icmp eq ptr %0, null
  br i1 %tobool2.not, label %if.else6, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 4
  br i1 %cmp.not, label %if.else6.thread, label %return.sink.split

if.else6:                                         ; preds = %if.else
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and7 = and i32 %1, 2
  %tobool8.not = icmp eq i32 %and7, 0
  br i1 %tobool8.not, label %return.sink.split, label %if.end.i

if.else6.thread:                                  ; preds = %land.lhs.true
  %mode42 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %2 = load i32, ptr %mode42, align 8
  %and743 = and i32 %2, 2
  %tobool8.not44 = icmp eq i32 %and743, 0
  br i1 %tobool8.not44, label %return.sink.split, label %if.end17

if.end.i:                                         ; preds = %if.else6
  %call5.i = tail call ptr @createHashObject() #32
  %db.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %3 = load ptr, ptr %db.i, align 8
  %key8.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %4 = load ptr, ptr %key8.i, align 8
  tail call void @dbAdd(ptr noundef %3, ptr noundef %4, ptr noundef %call5.i) #32
  store ptr %call5.i, ptr %value, align 8
  %bf.load.i.i = load i32, ptr %call5.i, align 8
  %bf.clear.i.i = and i32 %bf.load.i.i, 15
  switch i32 %bf.clear.i.i, label %if.end17 [
    i32 3, label %sw.bb.i.i
    i32 6, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %u.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  store i32 0, ptr %u.i.i.i, align 8
  %current.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i.i, align 8
  %er.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i.i.i, align 8
  br label %if.end17

sw.bb1.i.i:                                       ; preds = %if.end.i
  %signalready.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 0, ptr %signalready.i.i, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.else6.thread, %sw.bb1.i.i, %sw.bb.i.i, %if.end.i
  call void @llvm.va_start(ptr nonnull %ap)
  %and19 = and i32 %flags, 4
  %tobool20.not.not = icmp eq i32 %and19, 0
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag, ptr %ap, i64 0, i32 2
  %5 = getelementptr inbounds %struct.__va_list_tag, ptr %ap, i64 0, i32 3
  %and57 = and i32 %flags, 3
  %tobool58.not = icmp eq i32 %and57, 0
  %and62 = and i32 %flags, 2
  %tobool63 = icmp eq i32 %and62, 0
  %and67 = and i32 %flags, 1
  %tobool68 = icmp ne i32 %and67, 0
  %and19.lobit = lshr exact i32 %and19, 2
  %arrayinit.element = getelementptr inbounds ptr, ptr %argv, i64 1
  %tobool99.not = icmp ult i32 %flags, 16
  br i1 %tobool20.not.not, label %if.end17.split.us, label %if.end17.split

if.end17.split.us:                                ; preds = %if.end17
  br i1 %tobool58.not, label %while.body.outer.us.us, label %while.body.outer.us

while.body.outer.us.us:                           ; preds = %if.end17.split.us, %while.body.outer.backedge.us.us
  %count.0.ph.us.us = phi i32 [ %count.0.ph.be.us.us, %while.body.outer.backedge.us.us ], [ 0, %if.end17.split.us ]
  %gp_offset31.us.us.us.us = load i32, ptr %ap, align 16
  %fits_in_gp32.us.us.us.us = icmp ult i32 %gp_offset31.us.us.us.us, 41
  br i1 %fits_in_gp32.us.us.us.us, label %vaarg.in_reg33.us.us.us.us, label %vaarg.in_mem35.us.us.us.us

if.end87.us.us:                                   ; preds = %vaarg.end55.us.us.us.us
  store ptr %15, ptr %argv, align 16
  store ptr %19, ptr %arrayinit.element, align 8
  %6 = load ptr, ptr %value, align 8
  call void @hashTypeTryConversion(ptr noundef %6, ptr noundef nonnull %argv, i32 noundef 0, i32 noundef 1) #32
  %7 = load ptr, ptr %value, align 8
  %ptr95.us.us = getelementptr inbounds %struct.redisObject, ptr %15, i64 0, i32 2
  %8 = load ptr, ptr %ptr95.us.us, align 8
  %ptr96.us.us = getelementptr inbounds %struct.redisObject, ptr %19, i64 0, i32 2
  %9 = load ptr, ptr %ptr96.us.us, align 8
  %call97.us.us = call i32 @hashTypeSet(ptr noundef %7, ptr noundef %8, ptr noundef %9, i32 noundef %and19.lobit) #32
  %cond.us.us = select i1 %tobool99.not, i32 %call97.us.us, i32 1
  br label %while.body.outer.backedge.us.us

if.then79.us.us:                                  ; preds = %vaarg.end55.us.us.us.us
  %10 = load ptr, ptr %value, align 8
  %ptr81.us.us = getelementptr inbounds %struct.redisObject, ptr %15, i64 0, i32 2
  %11 = load ptr, ptr %ptr81.us.us, align 8
  %call82.us.us = call i32 @hashTypeDelete(ptr noundef %10, ptr noundef %11) #32
  br label %while.body.outer.backedge.us.us

while.body.outer.backedge.us.us:                  ; preds = %if.then79.us.us, %if.end87.us.us
  %cond.us.us.pn = phi i32 [ %cond.us.us, %if.end87.us.us ], [ %call82.us.us, %if.then79.us.us ]
  %count.0.ph.be.us.us = add nsw i32 %cond.us.us.pn, %count.0.ph.us.us
  br label %while.body.outer.us.us

vaarg.in_mem35.us.us.us.us:                       ; preds = %while.body.outer.us.us
  %overflow_arg_area37.us.us.us.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next38.us.us.us.us = getelementptr i8, ptr %overflow_arg_area37.us.us.us.us, i64 8
  store ptr %overflow_arg_area.next38.us.us.us.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end39.us.us.us.us

vaarg.in_reg33.us.us.us.us:                       ; preds = %while.body.outer.us.us
  %reg_save_area34.us.us.us.us = load ptr, ptr %5, align 16
  %12 = zext nneg i32 %gp_offset31.us.us.us.us to i64
  %13 = getelementptr i8, ptr %reg_save_area34.us.us.us.us, i64 %12
  %14 = add nuw nsw i32 %gp_offset31.us.us.us.us, 8
  store i32 %14, ptr %ap, align 16
  br label %vaarg.end39.us.us.us.us

vaarg.end39.us.us.us.us:                          ; preds = %vaarg.in_reg33.us.us.us.us, %vaarg.in_mem35.us.us.us.us
  %gp_offset47.us.us.us.us = phi i32 [ %14, %vaarg.in_reg33.us.us.us.us ], [ %gp_offset31.us.us.us.us, %vaarg.in_mem35.us.us.us.us ]
  %vaarg.addr40.us.us.us.us = phi ptr [ %13, %vaarg.in_reg33.us.us.us.us ], [ %overflow_arg_area37.us.us.us.us, %vaarg.in_mem35.us.us.us.us ]
  %15 = load ptr, ptr %vaarg.addr40.us.us.us.us, align 8
  %cmp41.us.us.us.us = icmp eq ptr %15, null
  br i1 %cmp41.us.us.us.us, label %while.end, label %if.end44.us.us.us.us

if.end44.us.us.us.us:                             ; preds = %vaarg.end39.us.us.us.us
  %fits_in_gp48.us.us.us.us = icmp ult i32 %gp_offset47.us.us.us.us, 41
  br i1 %fits_in_gp48.us.us.us.us, label %vaarg.in_reg49.us.us.us.us, label %vaarg.in_mem51.us.us.us.us

vaarg.in_mem51.us.us.us.us:                       ; preds = %if.end44.us.us.us.us
  %overflow_arg_area53.us.us.us.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next54.us.us.us.us = getelementptr i8, ptr %overflow_arg_area53.us.us.us.us, i64 8
  store ptr %overflow_arg_area.next54.us.us.us.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end55.us.us.us.us

vaarg.in_reg49.us.us.us.us:                       ; preds = %if.end44.us.us.us.us
  %reg_save_area50.us.us.us.us = load ptr, ptr %5, align 16
  %16 = zext nneg i32 %gp_offset47.us.us.us.us to i64
  %17 = getelementptr i8, ptr %reg_save_area50.us.us.us.us, i64 %16
  %18 = add nuw nsw i32 %gp_offset47.us.us.us.us, 8
  store i32 %18, ptr %ap, align 16
  br label %vaarg.end55.us.us.us.us

vaarg.end55.us.us.us.us:                          ; preds = %vaarg.in_reg49.us.us.us.us, %vaarg.in_mem51.us.us.us.us
  %vaarg.addr56.us.us.us.us = phi ptr [ %17, %vaarg.in_reg49.us.us.us.us ], [ %overflow_arg_area53.us.us.us.us, %vaarg.in_mem51.us.us.us.us ]
  %19 = load ptr, ptr %vaarg.addr56.us.us.us.us, align 8
  %cmp78.us.us = icmp eq ptr %19, inttoptr (i64 1 to ptr)
  br i1 %cmp78.us.us, label %if.then79.us.us, label %if.end87.us.us

while.body.outer.us:                              ; preds = %if.end17.split.us, %while.body.outer.backedge.us
  %count.0.ph.us = phi i32 [ %count.0.ph.be.us, %while.body.outer.backedge.us ], [ 0, %if.end17.split.us ]
  br i1 %tobool63, label %while.body.outer.split.us.split.us97.split.us, label %while.body.us.us

if.end87.us:                                      ; preds = %if.end77.split.us.split.us
  store ptr %.us-phi123, ptr %argv, align 16
  store ptr %.us-phi122, ptr %arrayinit.element, align 8
  %20 = load ptr, ptr %value, align 8
  call void @hashTypeTryConversion(ptr noundef %20, ptr noundef nonnull %argv, i32 noundef 0, i32 noundef 1) #32
  %21 = load ptr, ptr %value, align 8
  %ptr95.us = getelementptr inbounds %struct.redisObject, ptr %.us-phi123, i64 0, i32 2
  %22 = load ptr, ptr %ptr95.us, align 8
  %ptr96.us = getelementptr inbounds %struct.redisObject, ptr %.us-phi122, i64 0, i32 2
  %23 = load ptr, ptr %ptr96.us, align 8
  %call97.us = call i32 @hashTypeSet(ptr noundef %21, ptr noundef %22, ptr noundef %23, i32 noundef %and19.lobit) #32
  %cond.us = select i1 %tobool99.not, i32 %call97.us, i32 1
  br label %while.body.outer.backedge.us

if.then79.us:                                     ; preds = %if.end77.split.us.split.us
  %24 = load ptr, ptr %value, align 8
  %ptr81.us = getelementptr inbounds %struct.redisObject, ptr %.us-phi123, i64 0, i32 2
  %25 = load ptr, ptr %ptr81.us, align 8
  %call82.us = call i32 @hashTypeDelete(ptr noundef %24, ptr noundef %25) #32
  br label %while.body.outer.backedge.us

while.body.outer.backedge.us:                     ; preds = %if.then79.us, %if.end87.us
  %cond.us.pn = phi i32 [ %cond.us, %if.end87.us ], [ %call82.us, %if.then79.us ]
  %count.0.ph.be.us = add nsw i32 %cond.us.pn, %count.0.ph.us
  br label %while.body.outer.us

while.body.us.us:                                 ; preds = %while.body.outer.us, %vaarg.end55.us.us95
  %gp_offset31.us.us77 = load i32, ptr %ap, align 16
  %fits_in_gp32.us.us78 = icmp ult i32 %gp_offset31.us.us77, 41
  br i1 %fits_in_gp32.us.us78, label %vaarg.in_reg33.us.us82, label %vaarg.in_mem35.us.us79

vaarg.in_mem35.us.us79:                           ; preds = %while.body.us.us
  %overflow_arg_area37.us.us80 = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next38.us.us81 = getelementptr i8, ptr %overflow_arg_area37.us.us80, i64 8
  store ptr %overflow_arg_area.next38.us.us81, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end39.us.us84

vaarg.in_reg33.us.us82:                           ; preds = %while.body.us.us
  %reg_save_area34.us.us83 = load ptr, ptr %5, align 16
  %26 = zext nneg i32 %gp_offset31.us.us77 to i64
  %27 = getelementptr i8, ptr %reg_save_area34.us.us83, i64 %26
  %28 = add nuw nsw i32 %gp_offset31.us.us77, 8
  store i32 %28, ptr %ap, align 16
  br label %vaarg.end39.us.us84

vaarg.end39.us.us84:                              ; preds = %vaarg.in_reg33.us.us82, %vaarg.in_mem35.us.us79
  %gp_offset47.us.us88 = phi i32 [ %28, %vaarg.in_reg33.us.us82 ], [ %gp_offset31.us.us77, %vaarg.in_mem35.us.us79 ]
  %vaarg.addr40.us.us85 = phi ptr [ %27, %vaarg.in_reg33.us.us82 ], [ %overflow_arg_area37.us.us80, %vaarg.in_mem35.us.us79 ]
  %29 = load ptr, ptr %vaarg.addr40.us.us85, align 8
  %cmp41.us.us86 = icmp eq ptr %29, null
  br i1 %cmp41.us.us86, label %while.end, label %if.end44.us.us87

if.end44.us.us87:                                 ; preds = %vaarg.end39.us.us84
  %fits_in_gp48.us.us89 = icmp ult i32 %gp_offset47.us.us88, 41
  br i1 %fits_in_gp48.us.us89, label %vaarg.in_reg49.us.us93, label %vaarg.in_mem51.us.us90

vaarg.in_mem51.us.us90:                           ; preds = %if.end44.us.us87
  %overflow_arg_area53.us.us91 = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next54.us.us92 = getelementptr i8, ptr %overflow_arg_area53.us.us91, i64 8
  store ptr %overflow_arg_area.next54.us.us92, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end55.us.us95

vaarg.in_reg49.us.us93:                           ; preds = %if.end44.us.us87
  %reg_save_area50.us.us94 = load ptr, ptr %5, align 16
  %30 = zext nneg i32 %gp_offset47.us.us88 to i64
  %31 = getelementptr i8, ptr %reg_save_area50.us.us94, i64 %30
  %32 = add nuw nsw i32 %gp_offset47.us.us88, 8
  store i32 %32, ptr %ap, align 16
  br label %vaarg.end55.us.us95

vaarg.end55.us.us95:                              ; preds = %vaarg.in_reg49.us.us93, %vaarg.in_mem51.us.us90
  %vaarg.addr56.us.us96 = phi ptr [ %31, %vaarg.in_reg49.us.us93 ], [ %overflow_arg_area53.us.us91, %vaarg.in_mem51.us.us90 ]
  %33 = load ptr, ptr %vaarg.addr56.us.us96, align 8
  %34 = load ptr, ptr %value, align 8
  %ptr.us.us = getelementptr inbounds %struct.redisObject, ptr %29, i64 0, i32 2
  %35 = load ptr, ptr %ptr.us.us, align 8
  %call61.us.us = call i32 @hashTypeExists(ptr noundef %34, ptr noundef %35) #32
  %tobool65.us.us.not130 = icmp eq i32 %call61.us.us, 0
  %or.cond128 = or i1 %tobool68, %tobool65.us.us.not130
  br i1 %or.cond128, label %while.body.us.us, label %if.end77.split.us.split.us

if.end77.split.us.split.us:                       ; preds = %vaarg.end55.us.us95, %vaarg.end55.us.us95.us, %vaarg.end55.us.us95.us.us
  %.us-phi122 = phi ptr [ %43, %vaarg.end55.us.us95.us.us ], [ %53, %vaarg.end55.us.us95.us ], [ %33, %vaarg.end55.us.us95 ]
  %.us-phi123 = phi ptr [ %39, %vaarg.end55.us.us95.us.us ], [ %49, %vaarg.end55.us.us95.us ], [ %29, %vaarg.end55.us.us95 ]
  %cmp78.us = icmp eq ptr %.us-phi122, inttoptr (i64 1 to ptr)
  br i1 %cmp78.us, label %if.then79.us, label %if.end87.us

while.body.outer.split.us.split.us97.split.us:    ; preds = %while.body.outer.us
  br i1 %tobool68, label %while.body.us.us.us, label %while.body.outer.split.us.split.us97.split.us.split.us

while.body.outer.split.us.split.us97.split.us.split.us: ; preds = %while.body.outer.split.us.split.us97.split.us
  %gp_offset31.us.us77.us.us = load i32, ptr %ap, align 16
  %fits_in_gp32.us.us78.us.us = icmp ult i32 %gp_offset31.us.us77.us.us, 41
  br i1 %fits_in_gp32.us.us78.us.us, label %vaarg.in_reg33.us.us82.us.us, label %vaarg.in_mem35.us.us79.us.us

vaarg.in_mem35.us.us79.us.us:                     ; preds = %while.body.outer.split.us.split.us97.split.us.split.us
  %overflow_arg_area37.us.us80.us.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next38.us.us81.us.us = getelementptr i8, ptr %overflow_arg_area37.us.us80.us.us, i64 8
  store ptr %overflow_arg_area.next38.us.us81.us.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end39.us.us84.us.us

vaarg.in_reg33.us.us82.us.us:                     ; preds = %while.body.outer.split.us.split.us97.split.us.split.us
  %reg_save_area34.us.us83.us.us = load ptr, ptr %5, align 16
  %36 = zext nneg i32 %gp_offset31.us.us77.us.us to i64
  %37 = getelementptr i8, ptr %reg_save_area34.us.us83.us.us, i64 %36
  %38 = add nuw nsw i32 %gp_offset31.us.us77.us.us, 8
  store i32 %38, ptr %ap, align 16
  br label %vaarg.end39.us.us84.us.us

vaarg.end39.us.us84.us.us:                        ; preds = %vaarg.in_reg33.us.us82.us.us, %vaarg.in_mem35.us.us79.us.us
  %gp_offset47.us.us88.us.us = phi i32 [ %38, %vaarg.in_reg33.us.us82.us.us ], [ %gp_offset31.us.us77.us.us, %vaarg.in_mem35.us.us79.us.us ]
  %vaarg.addr40.us.us85.us.us = phi ptr [ %37, %vaarg.in_reg33.us.us82.us.us ], [ %overflow_arg_area37.us.us80.us.us, %vaarg.in_mem35.us.us79.us.us ]
  %39 = load ptr, ptr %vaarg.addr40.us.us85.us.us, align 8
  %cmp41.us.us86.us.us = icmp eq ptr %39, null
  br i1 %cmp41.us.us86.us.us, label %while.end, label %if.end44.us.us87.us.us

if.end44.us.us87.us.us:                           ; preds = %vaarg.end39.us.us84.us.us
  %fits_in_gp48.us.us89.us.us = icmp ult i32 %gp_offset47.us.us88.us.us, 41
  br i1 %fits_in_gp48.us.us89.us.us, label %vaarg.in_reg49.us.us93.us.us, label %vaarg.in_mem51.us.us90.us.us

vaarg.in_mem51.us.us90.us.us:                     ; preds = %if.end44.us.us87.us.us
  %overflow_arg_area53.us.us91.us.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next54.us.us92.us.us = getelementptr i8, ptr %overflow_arg_area53.us.us91.us.us, i64 8
  store ptr %overflow_arg_area.next54.us.us92.us.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end55.us.us95.us.us

vaarg.in_reg49.us.us93.us.us:                     ; preds = %if.end44.us.us87.us.us
  %reg_save_area50.us.us94.us.us = load ptr, ptr %5, align 16
  %40 = zext nneg i32 %gp_offset47.us.us88.us.us to i64
  %41 = getelementptr i8, ptr %reg_save_area50.us.us94.us.us, i64 %40
  %42 = add nuw nsw i32 %gp_offset47.us.us88.us.us, 8
  store i32 %42, ptr %ap, align 16
  br label %vaarg.end55.us.us95.us.us

vaarg.end55.us.us95.us.us:                        ; preds = %vaarg.in_reg49.us.us93.us.us, %vaarg.in_mem51.us.us90.us.us
  %vaarg.addr56.us.us96.us.us = phi ptr [ %41, %vaarg.in_reg49.us.us93.us.us ], [ %overflow_arg_area53.us.us91.us.us, %vaarg.in_mem51.us.us90.us.us ]
  %43 = load ptr, ptr %vaarg.addr56.us.us96.us.us, align 8
  %44 = load ptr, ptr %value, align 8
  %ptr.us.us.us.us = getelementptr inbounds %struct.redisObject, ptr %39, i64 0, i32 2
  %45 = load ptr, ptr %ptr.us.us.us.us, align 8
  %call61.us.us.us.us = call i32 @hashTypeExists(ptr noundef %44, ptr noundef %45) #32
  br label %if.end77.split.us.split.us

while.body.us.us.us:                              ; preds = %while.body.outer.split.us.split.us97.split.us, %vaarg.end55.us.us95.us
  %gp_offset31.us.us77.us = load i32, ptr %ap, align 16
  %fits_in_gp32.us.us78.us = icmp ult i32 %gp_offset31.us.us77.us, 41
  br i1 %fits_in_gp32.us.us78.us, label %vaarg.in_reg33.us.us82.us, label %vaarg.in_mem35.us.us79.us

vaarg.in_mem35.us.us79.us:                        ; preds = %while.body.us.us.us
  %overflow_arg_area37.us.us80.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next38.us.us81.us = getelementptr i8, ptr %overflow_arg_area37.us.us80.us, i64 8
  store ptr %overflow_arg_area.next38.us.us81.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end39.us.us84.us

vaarg.in_reg33.us.us82.us:                        ; preds = %while.body.us.us.us
  %reg_save_area34.us.us83.us = load ptr, ptr %5, align 16
  %46 = zext nneg i32 %gp_offset31.us.us77.us to i64
  %47 = getelementptr i8, ptr %reg_save_area34.us.us83.us, i64 %46
  %48 = add nuw nsw i32 %gp_offset31.us.us77.us, 8
  store i32 %48, ptr %ap, align 16
  br label %vaarg.end39.us.us84.us

vaarg.end39.us.us84.us:                           ; preds = %vaarg.in_reg33.us.us82.us, %vaarg.in_mem35.us.us79.us
  %gp_offset47.us.us88.us = phi i32 [ %48, %vaarg.in_reg33.us.us82.us ], [ %gp_offset31.us.us77.us, %vaarg.in_mem35.us.us79.us ]
  %vaarg.addr40.us.us85.us = phi ptr [ %47, %vaarg.in_reg33.us.us82.us ], [ %overflow_arg_area37.us.us80.us, %vaarg.in_mem35.us.us79.us ]
  %49 = load ptr, ptr %vaarg.addr40.us.us85.us, align 8
  %cmp41.us.us86.us = icmp eq ptr %49, null
  br i1 %cmp41.us.us86.us, label %while.end, label %if.end44.us.us87.us

if.end44.us.us87.us:                              ; preds = %vaarg.end39.us.us84.us
  %fits_in_gp48.us.us89.us = icmp ult i32 %gp_offset47.us.us88.us, 41
  br i1 %fits_in_gp48.us.us89.us, label %vaarg.in_reg49.us.us93.us, label %vaarg.in_mem51.us.us90.us

vaarg.in_mem51.us.us90.us:                        ; preds = %if.end44.us.us87.us
  %overflow_arg_area53.us.us91.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next54.us.us92.us = getelementptr i8, ptr %overflow_arg_area53.us.us91.us, i64 8
  store ptr %overflow_arg_area.next54.us.us92.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end55.us.us95.us

vaarg.in_reg49.us.us93.us:                        ; preds = %if.end44.us.us87.us
  %reg_save_area50.us.us94.us = load ptr, ptr %5, align 16
  %50 = zext nneg i32 %gp_offset47.us.us88.us to i64
  %51 = getelementptr i8, ptr %reg_save_area50.us.us94.us, i64 %50
  %52 = add nuw nsw i32 %gp_offset47.us.us88.us, 8
  store i32 %52, ptr %ap, align 16
  br label %vaarg.end55.us.us95.us

vaarg.end55.us.us95.us:                           ; preds = %vaarg.in_reg49.us.us93.us, %vaarg.in_mem51.us.us90.us
  %vaarg.addr56.us.us96.us = phi ptr [ %51, %vaarg.in_reg49.us.us93.us ], [ %overflow_arg_area53.us.us91.us, %vaarg.in_mem51.us.us90.us ]
  %53 = load ptr, ptr %vaarg.addr56.us.us96.us, align 8
  %54 = load ptr, ptr %value, align 8
  %ptr.us.us.us = getelementptr inbounds %struct.redisObject, ptr %49, i64 0, i32 2
  %55 = load ptr, ptr %ptr.us.us.us, align 8
  %call61.us.us.us = call i32 @hashTypeExists(ptr noundef %54, ptr noundef %55) #32
  %tobool65.us.us.us.not = icmp eq i32 %call61.us.us.us, 0
  br i1 %tobool65.us.us.us.not, label %if.end77.split.us.split.us, label %while.body.us.us.us

if.end17.split:                                   ; preds = %if.end17
  br i1 %tobool58.not, label %while.body.outer.us101, label %while.body.outer

while.body.outer.us101:                           ; preds = %if.end17.split, %while.body.outer.backedge.us117
  %count.0.ph.us102 = phi i32 [ %count.0.ph.be.us118, %while.body.outer.backedge.us117 ], [ 0, %if.end17.split ]
  %gp_offset.us.us = load i32, ptr %ap, align 16
  %fits_in_gp.us.us = icmp ult i32 %gp_offset.us.us, 41
  br i1 %fits_in_gp.us.us, label %vaarg.in_reg.us.us, label %vaarg.in_mem.us.us

if.end87.us103:                                   ; preds = %vaarg.end55.us60.us
  store ptr %call27.us.us, ptr %argv, align 16
  store ptr %69, ptr %arrayinit.element, align 8
  %56 = load ptr, ptr %value, align 8
  call void @hashTypeTryConversion(ptr noundef %56, ptr noundef nonnull %argv, i32 noundef 0, i32 noundef 1) #32
  %57 = load ptr, ptr %value, align 8
  %ptr95.us104 = getelementptr inbounds %struct.redisObject, ptr %call27.us.us, i64 0, i32 2
  %58 = load ptr, ptr %ptr95.us104, align 8
  %ptr96.us105 = getelementptr inbounds %struct.redisObject, ptr %69, i64 0, i32 2
  %59 = load ptr, ptr %ptr96.us105, align 8
  %call97.us106 = call i32 @hashTypeSet(ptr noundef %57, ptr noundef %58, ptr noundef %59, i32 noundef %and19.lobit) #32
  %cond.us107 = select i1 %tobool99.not, i32 %call97.us106, i32 1
  store ptr null, ptr %ptr95.us104, align 8
  br label %while.body.outer.backedge.us117

if.then79.us111:                                  ; preds = %vaarg.end55.us60.us
  %60 = load ptr, ptr %value, align 8
  %ptr81.us112 = getelementptr inbounds %struct.redisObject, ptr %call27.us.us, i64 0, i32 2
  %61 = load ptr, ptr %ptr81.us112, align 8
  %call82.us113 = call i32 @hashTypeDelete(ptr noundef %60, ptr noundef %61) #32
  br label %while.body.outer.backedge.us117

while.body.outer.backedge.us117:                  ; preds = %if.then79.us111, %if.end87.us103
  %cond.us107.pn = phi i32 [ %cond.us107, %if.end87.us103 ], [ %call82.us113, %if.then79.us111 ]
  call void @decrRefCount(ptr noundef nonnull %call27.us.us) #32
  %count.0.ph.be.us118 = add nsw i32 %cond.us107.pn, %count.0.ph.us102
  br label %while.body.outer.us101

vaarg.in_mem.us.us:                               ; preds = %while.body.outer.us101
  %overflow_arg_area.us.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next.us.us = getelementptr i8, ptr %overflow_arg_area.us.us, i64 8
  store ptr %overflow_arg_area.next.us.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end.us.us

vaarg.in_reg.us.us:                               ; preds = %while.body.outer.us101
  %reg_save_area.us.us = load ptr, ptr %5, align 16
  %62 = zext nneg i32 %gp_offset.us.us to i64
  %63 = getelementptr i8, ptr %reg_save_area.us.us, i64 %62
  %64 = add nuw nsw i32 %gp_offset.us.us, 8
  store i32 %64, ptr %ap, align 16
  br label %vaarg.end.us.us

vaarg.end.us.us:                                  ; preds = %vaarg.in_reg.us.us, %vaarg.in_mem.us.us
  %vaarg.addr.us.us = phi ptr [ %63, %vaarg.in_reg.us.us ], [ %overflow_arg_area.us.us, %vaarg.in_mem.us.us ]
  %65 = load ptr, ptr %vaarg.addr.us.us, align 8
  %cmp23.us.us = icmp eq ptr %65, null
  br i1 %cmp23.us.us, label %while.end, label %if.end25.us.us

if.end25.us.us:                                   ; preds = %vaarg.end.us.us
  %call26.us.us = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %65) #36
  %call27.us.us = call ptr @createRawStringObject(ptr noundef nonnull %65, i64 noundef %call26.us.us) #32
  %gp_offset47.us53.us = load i32, ptr %ap, align 16
  %fits_in_gp48.us54.us = icmp ult i32 %gp_offset47.us53.us, 41
  br i1 %fits_in_gp48.us54.us, label %vaarg.in_reg49.us58.us, label %vaarg.in_mem51.us55.us

vaarg.in_mem51.us55.us:                           ; preds = %if.end25.us.us
  %overflow_arg_area53.us56.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next54.us57.us = getelementptr i8, ptr %overflow_arg_area53.us56.us, i64 8
  store ptr %overflow_arg_area.next54.us57.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end55.us60.us

vaarg.in_reg49.us58.us:                           ; preds = %if.end25.us.us
  %reg_save_area50.us59.us = load ptr, ptr %5, align 16
  %66 = zext nneg i32 %gp_offset47.us53.us to i64
  %67 = getelementptr i8, ptr %reg_save_area50.us59.us, i64 %66
  %68 = add nuw nsw i32 %gp_offset47.us53.us, 8
  store i32 %68, ptr %ap, align 16
  br label %vaarg.end55.us60.us

vaarg.end55.us60.us:                              ; preds = %vaarg.in_reg49.us58.us, %vaarg.in_mem51.us55.us
  %vaarg.addr56.us61.us = phi ptr [ %67, %vaarg.in_reg49.us58.us ], [ %overflow_arg_area53.us56.us, %vaarg.in_mem51.us55.us ]
  %69 = load ptr, ptr %vaarg.addr56.us61.us, align 8
  %cmp78.us119 = icmp eq ptr %69, inttoptr (i64 1 to ptr)
  br i1 %cmp78.us119, label %if.then79.us111, label %if.end87.us103

while.body.outer:                                 ; preds = %if.end17.split, %while.body.outer.backedge
  %count.0.ph = phi i32 [ %count.0.ph.be, %while.body.outer.backedge ], [ 0, %if.end17.split ]
  br label %while.body

while.body:                                       ; preds = %while.body.outer, %if.then71
  %gp_offset = load i32, ptr %ap, align 16
  %fits_in_gp = icmp ult i32 %gp_offset, 41
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %while.body
  %reg_save_area = load ptr, ptr %5, align 16
  %70 = zext nneg i32 %gp_offset to i64
  %71 = getelementptr i8, ptr %reg_save_area, i64 %70
  %72 = add nuw nsw i32 %gp_offset, 8
  store i32 %72, ptr %ap, align 16
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %while.body
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i64 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %71, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %73 = load ptr, ptr %vaarg.addr, align 8
  %cmp23 = icmp eq ptr %73, null
  br i1 %cmp23, label %while.end, label %if.end25

if.end25:                                         ; preds = %vaarg.end
  %call26 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %73) #36
  %call27 = call ptr @createRawStringObject(ptr noundef nonnull %73, i64 noundef %call26) #32
  %gp_offset47 = load i32, ptr %ap, align 16
  %fits_in_gp48 = icmp ult i32 %gp_offset47, 41
  br i1 %fits_in_gp48, label %vaarg.in_reg49, label %vaarg.in_mem51

vaarg.in_reg49:                                   ; preds = %if.end25
  %reg_save_area50 = load ptr, ptr %5, align 16
  %74 = zext nneg i32 %gp_offset47 to i64
  %75 = getelementptr i8, ptr %reg_save_area50, i64 %74
  %76 = add nuw nsw i32 %gp_offset47, 8
  store i32 %76, ptr %ap, align 16
  br label %vaarg.end55

vaarg.in_mem51:                                   ; preds = %if.end25
  %overflow_arg_area53 = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next54 = getelementptr i8, ptr %overflow_arg_area53, i64 8
  store ptr %overflow_arg_area.next54, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end55

vaarg.end55:                                      ; preds = %vaarg.in_mem51, %vaarg.in_reg49
  %vaarg.addr56 = phi ptr [ %75, %vaarg.in_reg49 ], [ %overflow_arg_area53, %vaarg.in_mem51 ]
  %77 = load ptr, ptr %vaarg.addr56, align 8
  %78 = load ptr, ptr %value, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %call27, i64 0, i32 2
  %79 = load ptr, ptr %ptr, align 8
  %call61 = call i32 @hashTypeExists(ptr noundef %78, ptr noundef %79) #32
  %tobool65 = icmp ne i32 %call61, 0
  %or.cond = select i1 %tobool63, i1 true, i1 %tobool65
  %or.cond.not = xor i1 %or.cond, true
  %or.cond1 = select i1 %tobool68, i1 %tobool65, i1 false
  %or.cond129 = select i1 %or.cond.not, i1 true, i1 %or.cond1
  br i1 %or.cond129, label %if.then71, label %if.end77.split.split

if.then71:                                        ; preds = %vaarg.end55
  call void @decrRefCount(ptr noundef nonnull %call27) #32
  br label %while.body

if.end77.split.split:                             ; preds = %vaarg.end55
  %ptr.le = getelementptr inbounds %struct.redisObject, ptr %call27, i64 0, i32 2
  %cmp78 = icmp eq ptr %77, inttoptr (i64 1 to ptr)
  br i1 %cmp78, label %if.then79, label %if.end87

if.then79:                                        ; preds = %if.end77.split.split
  %80 = load ptr, ptr %value, align 8
  %81 = load ptr, ptr %ptr.le, align 8
  %call82 = call i32 @hashTypeDelete(ptr noundef %80, ptr noundef %81) #32
  br label %while.body.outer.backedge

while.body.outer.backedge:                        ; preds = %if.then79, %if.end87
  %cond.pn = phi i32 [ %cond, %if.end87 ], [ %call82, %if.then79 ]
  call void @decrRefCount(ptr noundef nonnull %call27) #32
  %count.0.ph.be = add nsw i32 %cond.pn, %count.0.ph
  br label %while.body.outer

if.end87:                                         ; preds = %if.end77.split.split
  store ptr %call27, ptr %argv, align 16
  store ptr %77, ptr %arrayinit.element, align 8
  %82 = load ptr, ptr %value, align 8
  call void @hashTypeTryConversion(ptr noundef %82, ptr noundef nonnull %argv, i32 noundef 0, i32 noundef 1) #32
  %83 = load ptr, ptr %value, align 8
  %84 = load ptr, ptr %ptr.le, align 8
  %ptr96 = getelementptr inbounds %struct.redisObject, ptr %77, i64 0, i32 2
  %85 = load ptr, ptr %ptr96, align 8
  %call97 = call i32 @hashTypeSet(ptr noundef %83, ptr noundef %84, ptr noundef %85, i32 noundef %and19.lobit) #32
  %cond = select i1 %tobool99.not, i32 %call97, i32 1
  store ptr null, ptr %ptr.le, align 8
  br label %while.body.outer.backedge

while.end:                                        ; preds = %vaarg.end, %vaarg.end.us.us, %vaarg.end39.us.us84.us.us, %vaarg.end39.us.us84, %vaarg.end39.us.us84.us, %vaarg.end39.us.us.us.us
  %.us-phi = phi i32 [ %count.0.ph.us.us, %vaarg.end39.us.us.us.us ], [ %count.0.ph.us, %vaarg.end39.us.us84.us ], [ %count.0.ph.us, %vaarg.end39.us.us84 ], [ %count.0.ph.us, %vaarg.end39.us.us84.us.us ], [ %count.0.ph.us102, %vaarg.end.us.us ], [ %count.0.ph, %vaarg.end ]
  call void @llvm.va_end(ptr nonnull %ap)
  %call107 = call i32 @moduleDelKeyIfEmpty(ptr noundef nonnull %key), !range !22
  %cmp108 = icmp eq i32 %.us-phi, 0
  br i1 %cmp108, label %return.sink.split, label %return

return.sink.split:                                ; preds = %while.end, %if.else6, %if.else6.thread, %land.lhs.true, %entry
  %.sink = phi i32 [ 22, %entry ], [ 95, %land.lhs.true ], [ 9, %if.else6.thread ], [ 9, %if.else6 ], [ 2, %while.end ]
  %call110 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call110, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %while.end
  %retval.0 = phi i32 [ %.us-phi, %while.end ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

declare ptr @createRawStringObject(ptr noundef, i64 noundef) local_unnamed_addr #1

declare i32 @hashTypeExists(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @hashTypeDelete(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @hashTypeTryConversion(ptr noundef, ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #1

declare i32 @hashTypeSet(ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_HashGet(ptr nocapture noundef readonly %key, i32 noundef %flags, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 4
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  call void @llvm.va_start(ptr nonnull %ap)
  %and = and i32 %flags, 4
  %tobool2.not = icmp eq i32 %and, 0
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag, ptr %ap, i64 0, i32 2
  %1 = getelementptr inbounds %struct.__va_list_tag, ptr %ap, i64 0, i32 3
  %and25 = and i32 %flags, 8
  %tobool26.not = icmp eq i32 %and25, 0
  br i1 %tobool26.not, label %while.body.us, label %if.end.split

while.body.us:                                    ; preds = %if.end, %while.body.us.backedge
  %gp_offset11.us = load i32, ptr %ap, align 16
  %fits_in_gp12.us = icmp ult i32 %gp_offset11.us, 41
  br i1 %tobool2.not, label %if.else.us, label %if.then3.us

if.then3.us:                                      ; preds = %while.body.us
  br i1 %fits_in_gp12.us, label %vaarg.in_reg.us, label %vaarg.in_mem.us

vaarg.in_mem.us:                                  ; preds = %if.then3.us
  %overflow_arg_area.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next.us = getelementptr i8, ptr %overflow_arg_area.us, i64 8
  store ptr %overflow_arg_area.next.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end.us

vaarg.in_reg.us:                                  ; preds = %if.then3.us
  %reg_save_area.us = load ptr, ptr %1, align 16
  %2 = zext nneg i32 %gp_offset11.us to i64
  %3 = getelementptr i8, ptr %reg_save_area.us, i64 %2
  %4 = add nuw nsw i32 %gp_offset11.us, 8
  store i32 %4, ptr %ap, align 16
  br label %vaarg.end.us

vaarg.end.us:                                     ; preds = %vaarg.in_reg.us, %vaarg.in_mem.us
  %vaarg.addr.us = phi ptr [ %3, %vaarg.in_reg.us ], [ %overflow_arg_area.us, %vaarg.in_mem.us ]
  %5 = load ptr, ptr %vaarg.addr.us, align 8
  %cmp5.us = icmp eq ptr %5, null
  br i1 %cmp5.us, label %while.end, label %if.end7.us

if.end7.us:                                       ; preds = %vaarg.end.us
  %call.us = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %5) #36
  %call8.us = call ptr @createRawStringObject(ptr noundef nonnull %5, i64 noundef %call.us) #32
  %gp_offset50.us.pre = load i32, ptr %ap, align 16
  br label %if.end24.us

if.else.us:                                       ; preds = %while.body.us
  br i1 %fits_in_gp12.us, label %vaarg.in_reg13.us, label %vaarg.in_mem15.us

vaarg.in_mem15.us:                                ; preds = %if.else.us
  %overflow_arg_area17.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next18.us = getelementptr i8, ptr %overflow_arg_area17.us, i64 8
  store ptr %overflow_arg_area.next18.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end19.us

vaarg.in_reg13.us:                                ; preds = %if.else.us
  %reg_save_area14.us = load ptr, ptr %1, align 16
  %6 = zext nneg i32 %gp_offset11.us to i64
  %7 = getelementptr i8, ptr %reg_save_area14.us, i64 %6
  %8 = add nuw nsw i32 %gp_offset11.us, 8
  store i32 %8, ptr %ap, align 16
  br label %vaarg.end19.us

vaarg.end19.us:                                   ; preds = %vaarg.in_reg13.us, %vaarg.in_mem15.us
  %gp_offset50.us50 = phi i32 [ %8, %vaarg.in_reg13.us ], [ %gp_offset11.us, %vaarg.in_mem15.us ]
  %vaarg.addr20.us = phi ptr [ %7, %vaarg.in_reg13.us ], [ %overflow_arg_area17.us, %vaarg.in_mem15.us ]
  %9 = load ptr, ptr %vaarg.addr20.us, align 8
  %cmp21.us = icmp eq ptr %9, null
  br i1 %cmp21.us, label %while.end, label %if.end24.us

if.end24.us:                                      ; preds = %vaarg.end19.us, %if.end7.us
  %gp_offset50.us = phi i32 [ %gp_offset50.us.pre, %if.end7.us ], [ %gp_offset50.us50, %vaarg.end19.us ]
  %field.0.us = phi ptr [ %call8.us, %if.end7.us ], [ %9, %vaarg.end19.us ]
  %fits_in_gp51.us = icmp ult i32 %gp_offset50.us, 41
  br i1 %fits_in_gp51.us, label %vaarg.in_reg52.us, label %vaarg.in_mem54.us

vaarg.in_mem54.us:                                ; preds = %if.end24.us
  %overflow_arg_area56.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next57.us = getelementptr i8, ptr %overflow_arg_area56.us, i64 8
  store ptr %overflow_arg_area.next57.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end58.us

vaarg.in_reg52.us:                                ; preds = %if.end24.us
  %reg_save_area53.us = load ptr, ptr %1, align 16
  %10 = zext nneg i32 %gp_offset50.us to i64
  %11 = getelementptr i8, ptr %reg_save_area53.us, i64 %10
  %12 = add nuw nsw i32 %gp_offset50.us, 8
  store i32 %12, ptr %ap, align 16
  br label %vaarg.end58.us

vaarg.end58.us:                                   ; preds = %vaarg.in_reg52.us, %vaarg.in_mem54.us
  %vaarg.addr59.us = phi ptr [ %11, %vaarg.in_reg52.us ], [ %overflow_arg_area56.us, %vaarg.in_mem54.us ]
  %13 = load ptr, ptr %vaarg.addr59.us, align 8
  %14 = load ptr, ptr %value, align 8
  %tobool61.not.us = icmp eq ptr %14, null
  br i1 %tobool61.not.us, label %if.else73.us, label %if.then62.us

if.then62.us:                                     ; preds = %vaarg.end58.us
  %ptr64.us = getelementptr inbounds %struct.redisObject, ptr %field.0.us, i64 0, i32 2
  %15 = load ptr, ptr %ptr64.us, align 8
  %call65.us = call ptr @hashTypeGetValueObject(ptr noundef nonnull %14, ptr noundef %15) #32
  store ptr %call65.us, ptr %13, align 8
  %tobool66.not.us = icmp eq ptr %call65.us, null
  br i1 %tobool66.not.us, label %if.end75.us, label %if.end69.us

if.end69.us:                                      ; preds = %if.then62.us
  %call68.us = call ptr @getDecodedObject(ptr noundef nonnull %call65.us) #32
  %16 = load ptr, ptr %13, align 8
  call void @decrRefCount(ptr noundef %16) #32
  store ptr %call68.us, ptr %13, align 8
  %tobool70.not.us = icmp eq ptr %call68.us, null
  br i1 %tobool70.not.us, label %if.end75.us, label %if.then71.us

if.then71.us:                                     ; preds = %if.end69.us
  %17 = load ptr, ptr %key, align 8
  %flags.i.us = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 7
  %18 = load i32, ptr %flags.i.us, align 8
  %and.i.us = and i32 %18, 1
  %tobool.not.i.us = icmp eq i32 %and.i.us, 0
  br i1 %tobool.not.i.us, label %if.end75.us, label %if.end.i.us

if.end.i.us:                                      ; preds = %if.then71.us
  %amqueue_used.i.us = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 6
  %19 = load i32, ptr %amqueue_used.i.us, align 4
  %amqueue_len.i.us = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 5
  %20 = load i32, ptr %amqueue_len.i.us, align 8
  %cmp.i.us = icmp eq i32 %19, %20
  br i1 %cmp.i.us, label %if.then1.i.us, label %if.end.if.end11_crit_edge.i.us

if.end.if.end11_crit_edge.i.us:                   ; preds = %if.end.i.us
  %amqueue12.phi.trans.insert.i.us = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 4
  %.pre.i.us = load ptr, ptr %amqueue12.phi.trans.insert.i.us, align 8
  br label %if.end11.i.us

if.then1.i.us:                                    ; preds = %if.end.i.us
  %mul.i.us = shl nsw i32 %19, 1
  %cmp4.i.us = icmp slt i32 %19, 8
  %spec.select.i.us = select i1 %cmp4.i.us, i32 16, i32 %mul.i.us
  store i32 %spec.select.i.us, ptr %amqueue_len.i.us, align 8
  %amqueue.i.us = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 4
  %21 = load ptr, ptr %amqueue.i.us, align 8
  %conv.i.us = sext i32 %spec.select.i.us to i64
  %mul9.i.us = shl nsw i64 %conv.i.us, 4
  %call.i.us = call ptr @zrealloc(ptr noundef %21, i64 noundef %mul9.i.us) #34
  store ptr %call.i.us, ptr %amqueue.i.us, align 8
  %.pre14.i.us = load i32, ptr %amqueue_used.i.us, align 4
  br label %if.end11.i.us

if.end11.i.us:                                    ; preds = %if.then1.i.us, %if.end.if.end11_crit_edge.i.us
  %22 = phi i32 [ %19, %if.end.if.end11_crit_edge.i.us ], [ %.pre14.i.us, %if.then1.i.us ]
  %23 = phi ptr [ %.pre.i.us, %if.end.if.end11_crit_edge.i.us ], [ %call.i.us, %if.then1.i.us ]
  %amqueue12.i.us = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 4
  %idxprom.i.us = sext i32 %22 to i64
  %type14.i.us = getelementptr inbounds %struct.AutoMemEntry, ptr %23, i64 %idxprom.i.us, i32 1
  store i32 1, ptr %type14.i.us, align 8
  %24 = load ptr, ptr %amqueue12.i.us, align 8
  %25 = load i32, ptr %amqueue_used.i.us, align 4
  %idxprom17.i.us = sext i32 %25 to i64
  %arrayidx18.i.us = getelementptr inbounds %struct.AutoMemEntry, ptr %24, i64 %idxprom17.i.us
  store ptr %call68.us, ptr %arrayidx18.i.us, align 8
  %26 = load i32, ptr %amqueue_used.i.us, align 4
  %inc.i.us = add nsw i32 %26, 1
  store i32 %inc.i.us, ptr %amqueue_used.i.us, align 4
  br label %if.end75.us

if.else73.us:                                     ; preds = %vaarg.end58.us
  store ptr null, ptr %13, align 8
  br label %if.end75.us

if.end75.us:                                      ; preds = %if.else73.us, %if.end11.i.us, %if.then71.us, %if.end69.us, %if.then62.us
  br i1 %tobool2.not, label %while.body.us.backedge, label %if.then78.us

if.then78.us:                                     ; preds = %if.end75.us
  call void @decrRefCount(ptr noundef %field.0.us) #32
  br label %while.body.us.backedge

while.body.us.backedge:                           ; preds = %if.then78.us, %if.end75.us
  br label %while.body.us

if.end.split:                                     ; preds = %if.end
  br i1 %tobool2.not, label %while.body.us28, label %while.body

while.body.us28:                                  ; preds = %if.end.split, %if.end75.us42
  %gp_offset11.us30 = load i32, ptr %ap, align 16
  %fits_in_gp12.us31 = icmp ult i32 %gp_offset11.us30, 41
  br i1 %fits_in_gp12.us31, label %vaarg.in_reg13.us35, label %vaarg.in_mem15.us32

vaarg.in_mem15.us32:                              ; preds = %while.body.us28
  %overflow_arg_area17.us33 = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next18.us34 = getelementptr i8, ptr %overflow_arg_area17.us33, i64 8
  store ptr %overflow_arg_area.next18.us34, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end19.us37

vaarg.in_reg13.us35:                              ; preds = %while.body.us28
  %reg_save_area14.us36 = load ptr, ptr %1, align 16
  %27 = zext nneg i32 %gp_offset11.us30 to i64
  %28 = getelementptr i8, ptr %reg_save_area14.us36, i64 %27
  %29 = add nuw nsw i32 %gp_offset11.us30, 8
  store i32 %29, ptr %ap, align 16
  br label %vaarg.end19.us37

vaarg.end19.us37:                                 ; preds = %vaarg.in_reg13.us35, %vaarg.in_mem15.us32
  %gp_offset30.us = phi i32 [ %29, %vaarg.in_reg13.us35 ], [ %gp_offset11.us30, %vaarg.in_mem15.us32 ]
  %vaarg.addr20.us38 = phi ptr [ %28, %vaarg.in_reg13.us35 ], [ %overflow_arg_area17.us33, %vaarg.in_mem15.us32 ]
  %30 = load ptr, ptr %vaarg.addr20.us38, align 8
  %cmp21.us39 = icmp eq ptr %30, null
  br i1 %cmp21.us39, label %while.end, label %if.end24.us40

if.end24.us40:                                    ; preds = %vaarg.end19.us37
  %fits_in_gp31.us = icmp ult i32 %gp_offset30.us, 41
  br i1 %fits_in_gp31.us, label %vaarg.in_reg32.us, label %vaarg.in_mem34.us

vaarg.in_mem34.us:                                ; preds = %if.end24.us40
  %overflow_arg_area36.us = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next37.us = getelementptr i8, ptr %overflow_arg_area36.us, i64 8
  store ptr %overflow_arg_area.next37.us, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end38.us

vaarg.in_reg32.us:                                ; preds = %if.end24.us40
  %reg_save_area33.us = load ptr, ptr %1, align 16
  %31 = zext nneg i32 %gp_offset30.us to i64
  %32 = getelementptr i8, ptr %reg_save_area33.us, i64 %31
  %33 = add nuw nsw i32 %gp_offset30.us, 8
  store i32 %33, ptr %ap, align 16
  br label %vaarg.end38.us

vaarg.end38.us:                                   ; preds = %vaarg.in_reg32.us, %vaarg.in_mem34.us
  %vaarg.addr39.us = phi ptr [ %32, %vaarg.in_reg32.us ], [ %overflow_arg_area36.us, %vaarg.in_mem34.us ]
  %34 = load ptr, ptr %vaarg.addr39.us, align 8
  %35 = load ptr, ptr %value, align 8
  %tobool41.not.us = icmp eq ptr %35, null
  br i1 %tobool41.not.us, label %if.end75.us42, label %if.then42.us

if.then42.us:                                     ; preds = %vaarg.end38.us
  %ptr.us = getelementptr inbounds %struct.redisObject, ptr %30, i64 0, i32 2
  %36 = load ptr, ptr %ptr.us, align 8
  %call44.us = call i32 @hashTypeExists(ptr noundef nonnull %35, ptr noundef %36) #32
  br label %if.end75.us42

if.end75.us42:                                    ; preds = %vaarg.end38.us, %if.then42.us
  %storemerge45 = phi i32 [ %call44.us, %if.then42.us ], [ 0, %vaarg.end38.us ]
  store i32 %storemerge45, ptr %34, align 4
  br label %while.body.us28

while.body:                                       ; preds = %if.end.split, %if.end75
  %gp_offset = load i32, ptr %ap, align 16
  %fits_in_gp = icmp ult i32 %gp_offset, 41
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %while.body
  %reg_save_area = load ptr, ptr %1, align 16
  %37 = zext nneg i32 %gp_offset to i64
  %38 = getelementptr i8, ptr %reg_save_area, i64 %37
  %39 = add nuw nsw i32 %gp_offset, 8
  store i32 %39, ptr %ap, align 16
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %while.body
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i64 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %38, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %40 = load ptr, ptr %vaarg.addr, align 8
  %cmp5 = icmp eq ptr %40, null
  br i1 %cmp5, label %while.end, label %if.end7

if.end7:                                          ; preds = %vaarg.end
  %call = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %40) #36
  %call8 = call ptr @createRawStringObject(ptr noundef nonnull %40, i64 noundef %call) #32
  %gp_offset30 = load i32, ptr %ap, align 16
  %fits_in_gp31 = icmp ult i32 %gp_offset30, 41
  br i1 %fits_in_gp31, label %vaarg.in_reg32, label %vaarg.in_mem34

vaarg.in_reg32:                                   ; preds = %if.end7
  %reg_save_area33 = load ptr, ptr %1, align 16
  %41 = zext nneg i32 %gp_offset30 to i64
  %42 = getelementptr i8, ptr %reg_save_area33, i64 %41
  %43 = add nuw nsw i32 %gp_offset30, 8
  store i32 %43, ptr %ap, align 16
  br label %vaarg.end38

vaarg.in_mem34:                                   ; preds = %if.end7
  %overflow_arg_area36 = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next37 = getelementptr i8, ptr %overflow_arg_area36, i64 8
  store ptr %overflow_arg_area.next37, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end38

vaarg.end38:                                      ; preds = %vaarg.in_mem34, %vaarg.in_reg32
  %vaarg.addr39 = phi ptr [ %42, %vaarg.in_reg32 ], [ %overflow_arg_area36, %vaarg.in_mem34 ]
  %44 = load ptr, ptr %vaarg.addr39, align 8
  %45 = load ptr, ptr %value, align 8
  %tobool41.not = icmp eq ptr %45, null
  br i1 %tobool41.not, label %if.end75, label %if.then42

if.then42:                                        ; preds = %vaarg.end38
  %ptr = getelementptr inbounds %struct.redisObject, ptr %call8, i64 0, i32 2
  %46 = load ptr, ptr %ptr, align 8
  %call44 = call i32 @hashTypeExists(ptr noundef nonnull %45, ptr noundef %46) #32
  br label %if.end75

if.end75:                                         ; preds = %vaarg.end38, %if.then42
  %storemerge = phi i32 [ %call44, %if.then42 ], [ 0, %vaarg.end38 ]
  store i32 %storemerge, ptr %44, align 4
  call void @decrRefCount(ptr noundef %call8) #32
  br label %while.body

while.end:                                        ; preds = %vaarg.end, %vaarg.end19.us37, %vaarg.end.us, %vaarg.end19.us
  call void @llvm.va_end(ptr nonnull %ap)
  br label %return

return:                                           ; preds = %land.lhs.true, %while.end
  %retval.0 = phi i32 [ 0, %while.end ], [ 1, %land.lhs.true ]
  ret i32 %retval.0
}

declare ptr @hashTypeGetValueObject(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StreamAdd(ptr noundef %key, i32 noundef %flags, ptr noundef %id, ptr noundef %argv, i64 noundef %numfields) #0 {
entry:
  %added_id = alloca %struct.streamID, align 16
  %use_id = alloca %struct.streamID, align 16
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %cmp = icmp eq i64 %numfields, 0
  %tobool1 = icmp ne ptr %argv, null
  %or.cond = or i1 %tobool1, %cmp
  %tobool3.not = icmp ult i32 %flags, 2
  %or.cond25 = and i1 %tobool3.not, %or.cond
  br i1 %or.cond25, label %lor.lhs.false4, label %if.then

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %tobool6 = icmp ne i32 %flags, 0
  %tobool8 = icmp ne ptr %id, null
  %or.cond1 = or i1 %tobool6, %tobool8
  br i1 %or.cond1, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false4, %lor.lhs.false, %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false4
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool9.not = icmp eq ptr %0, null
  br i1 %tobool9.not, label %if.else15, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp12.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp12.not, label %if.else15, label %if.then13

if.then13:                                        ; preds = %land.lhs.true10
  %call14 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call14, align 4
  br label %return

if.else15:                                        ; preds = %land.lhs.true10, %if.else
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and16 = and i32 %1, 2
  %tobool17.not = icmp eq i32 %and16, 0
  br i1 %tobool17.not, label %if.then18, label %if.else20

if.then18:                                        ; preds = %if.else15
  %call19 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call19, align 4
  br label %return

if.else20:                                        ; preds = %if.else15
  br i1 %tobool6, label %if.end31, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %if.else20
  %2 = load i64, ptr %id, align 8
  %cmp24 = icmp eq i64 %2, 0
  br i1 %cmp24, label %land.lhs.true25, label %if.end31

land.lhs.true25:                                  ; preds = %land.lhs.true23
  %seq = getelementptr inbounds %struct.RedisModuleStreamID, ptr %id, i64 0, i32 1
  %3 = load i64, ptr %seq, align 8
  %cmp26 = icmp eq i64 %3, 0
  br i1 %cmp26, label %if.then27, label %if.end31

if.then27:                                        ; preds = %land.lhs.true25
  %call28 = tail call ptr @__errno_location() #37
  store i32 33, ptr %call28, align 4
  br label %return

if.end31:                                         ; preds = %if.else20, %land.lhs.true23, %land.lhs.true25
  br i1 %tobool9.not, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  %call35 = tail call i32 @moduleCreateEmptyKey(ptr noundef nonnull %key, i32 noundef 7), !range !22
  %.pre = load ptr, ptr %value, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %4 = phi ptr [ %.pre, %if.then34 ], [ %0, %if.end31 ]
  %ptr = getelementptr inbounds %struct.redisObject, ptr %4, i64 0, i32 2
  %5 = load ptr, ptr %ptr, align 8
  %last_id = getelementptr inbounds %struct.stream, ptr %5, i64 0, i32 2
  %6 = load i64, ptr %last_id, align 8
  %cmp39 = icmp eq i64 %6, -1
  br i1 %cmp39, label %land.lhs.true40, label %if.end46

land.lhs.true40:                                  ; preds = %if.end36
  %seq42 = getelementptr inbounds %struct.stream, ptr %5, i64 0, i32 2, i32 1
  %7 = load i64, ptr %seq42, align 8
  %cmp43 = icmp eq i64 %7, -1
  br i1 %cmp43, label %if.then44, label %if.end46

if.then44:                                        ; preds = %land.lhs.true40
  %call45 = tail call ptr @__errno_location() #37
  store i32 27, ptr %call45, align 4
  br label %return

if.end46:                                         ; preds = %land.lhs.true40, %if.end36
  br i1 %tobool6, label %if.end54, label %if.then49

if.then49:                                        ; preds = %if.end46
  %8 = load <2 x i64>, ptr %id, align 8
  store <2 x i64> %8, ptr %use_id, align 16
  br label %if.end54

if.end54:                                         ; preds = %if.then49, %if.end46
  %use_id_ptr.0 = phi ptr [ null, %if.end46 ], [ %use_id, %if.then49 ]
  %call55 = call i32 @streamAppendItem(ptr noundef nonnull %5, ptr noundef %argv, i64 noundef %numfields, ptr noundef nonnull %added_id, ptr noundef %use_id_ptr.0, i32 noundef 1) #32
  %cmp56 = icmp eq i32 %call55, -1
  br i1 %cmp56, label %if.then57, label %if.end62

if.then57:                                        ; preds = %if.end54
  br i1 %tobool9.not, label %if.then59, label %return

if.then59:                                        ; preds = %if.then57
  %call60 = call i32 @moduleDelKeyIfEmpty(ptr noundef nonnull %key), !range !22
  br label %return

if.end62:                                         ; preds = %if.end54
  br i1 %tobool9.not, label %if.end65, label %if.then64

if.then64:                                        ; preds = %if.end62
  %signalready = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 1, ptr %signalready, align 8
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.end62
  br i1 %tobool8, label %if.then67, label %return

if.then67:                                        ; preds = %if.end65
  %9 = load <2 x i64>, ptr %added_id, align 16
  store <2 x i64> %9, ptr %id, align 8
  br label %return

return:                                           ; preds = %if.end65, %if.then67, %if.then57, %if.then59, %if.then44, %if.then27, %if.then18, %if.then13, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 1, %if.then13 ], [ 1, %if.then44 ], [ 1, %if.then27 ], [ 1, %if.then18 ], [ 1, %if.then59 ], [ 1, %if.then57 ], [ 0, %if.then67 ], [ 0, %if.end65 ]
  ret i32 %retval.0
}

declare i32 @streamAppendItem(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StreamDelete(ptr noundef readonly %key, ptr noundef readonly %id) #0 {
entry:
  %streamid = alloca %struct.streamID, align 16
  %tobool = icmp ne ptr %key, null
  %tobool1 = icmp ne ptr %id, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.else, label %return.sink.split

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool2.not = icmp eq ptr %0, null
  br i1 %tobool2.not, label %return.sink.split, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp.not, label %if.else7, label %return.sink.split

if.else7:                                         ; preds = %lor.lhs.false3
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool8.not = icmp eq i32 %and, 0
  br i1 %tobool8.not, label %return.sink.split, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %if.else7
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %2 = load ptr, ptr %iter, align 8
  %cmp10.not = icmp eq ptr %2, null
  br i1 %cmp10.not, label %if.end14, label %return.sink.split

if.end14:                                         ; preds = %lor.lhs.false9
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %4 = load <2 x i64>, ptr %id, align 8
  store <2 x i64> %4, ptr %streamid, align 16
  %call18 = call i32 @streamDeleteItem(ptr noundef %3, ptr noundef nonnull %streamid) #32
  %tobool19.not = icmp eq i32 %call18, 0
  br i1 %tobool19.not, label %return.sink.split, label %return

return.sink.split:                                ; preds = %if.end14, %if.else7, %lor.lhs.false9, %if.else, %lor.lhs.false3, %entry
  %.sink = phi i32 [ 22, %entry ], [ 95, %lor.lhs.false3 ], [ 95, %if.else ], [ 9, %lor.lhs.false9 ], [ 9, %if.else7 ], [ 2, %if.end14 ]
  %call22 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call22, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %if.end14
  %retval.0 = phi i32 [ 0, %if.end14 ], [ 1, %return.sink.split ]
  ret i32 %retval.0
}

declare i32 @streamDeleteItem(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StreamIteratorStart(ptr noundef %key, i32 noundef %flags, ptr noundef readonly %start, ptr noundef readonly %end) #0 {
entry:
  %lower = alloca %struct.streamID, align 16
  %upper = alloca %struct.streamID, align 16
  %tobool.not = icmp ne ptr %key, null
  %tobool1.not = icmp ult i32 %flags, 4
  %or.cond = and i1 %tobool.not, %tobool1.not
  br i1 %or.cond, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool2.not = icmp eq ptr %0, null
  br i1 %tobool2.not, label %if.then5, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp.not, label %if.else7, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false3, %if.else
  %call6 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call6, align 4
  br label %return

if.else7:                                         ; preds = %lor.lhs.false3
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %tobool8.not = icmp eq ptr %1, null
  br i1 %tobool8.not, label %if.end12, label %if.then9

if.then9:                                         ; preds = %if.else7
  %call10 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call10, align 4
  br label %return

if.end12:                                         ; preds = %if.else7
  %tobool13.not = icmp eq ptr %start, null
  br i1 %tobool13.not, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.end12
  %2 = load <2 x i64>, ptr %start, align 8
  store <2 x i64> %2, ptr %lower, align 16
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end12
  %tobool18.not = icmp eq ptr %end, null
  br i1 %tobool18.not, label %if.end25, label %if.then19

if.then19:                                        ; preds = %if.end17
  %3 = load <2 x i64>, ptr %end, align 8
  store <2 x i64> %3, ptr %upper, align 16
  br label %if.end25

if.end25:                                         ; preds = %if.then19, %if.end17
  %and26 = and i32 %flags, 1
  %tobool27.not = icmp eq i32 %and26, 0
  br i1 %tobool27.not, label %if.end40, label %if.then28

if.then28:                                        ; preds = %if.end25
  br i1 %tobool13.not, label %lor.lhs.false32, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then28
  %call30 = call i32 @streamIncrID(ptr noundef nonnull %lower) #32
  %cmp31.not = icmp eq i32 %call30, 0
  br i1 %cmp31.not, label %lor.lhs.false32, label %if.then37

lor.lhs.false32:                                  ; preds = %land.lhs.true, %if.then28
  br i1 %tobool18.not, label %if.end40, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %lor.lhs.false32
  %call35 = call i32 @streamDecrID(ptr noundef nonnull %upper) #32
  %cmp36.not = icmp eq i32 %call35, 0
  br i1 %cmp36.not, label %if.end40, label %if.then37

if.then37:                                        ; preds = %land.lhs.true34, %land.lhs.true
  %call38 = tail call ptr @__errno_location() #37
  store i32 33, ptr %call38, align 4
  br label %return

if.end40:                                         ; preds = %lor.lhs.false32, %land.lhs.true34, %if.end25
  %4 = load ptr, ptr %value, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %4, i64 0, i32 2
  %5 = load ptr, ptr %ptr, align 8
  %and42 = and i32 %flags, 2
  %call43 = call noalias dereferenceable_or_null(648) ptr @zmalloc(i64 noundef 648) #33
  %lower. = select i1 %tobool13.not, ptr null, ptr %lower
  %cond49 = select i1 %tobool18.not, ptr null, ptr %upper
  call void @streamIteratorStart(ptr noundef %call43, ptr noundef %5, ptr noundef %lower., ptr noundef %cond49, i32 noundef %and42) #32
  store ptr %call43, ptr %iter, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %u, i8 0, i64 24, i1 false)
  br label %return

return:                                           ; preds = %if.end40, %if.then37, %if.then9, %if.then5, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 1, %if.then5 ], [ 1, %if.then9 ], [ 1, %if.then37 ], [ 0, %if.end40 ]
  ret i32 %retval.0
}

declare i32 @streamIncrID(ptr noundef) local_unnamed_addr #1

declare i32 @streamDecrID(ptr noundef) local_unnamed_addr #1

declare void @streamIteratorStart(ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StreamIteratorStop(ptr noundef %key) #0 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp.not, label %if.else5, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call4, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %tobool6.not = icmp eq ptr %1, null
  br i1 %tobool6.not, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.else5
  %call8 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call8, align 4
  br label %return

if.end10:                                         ; preds = %if.else5
  tail call void @streamIteratorStop(ptr noundef nonnull %1) #32
  %2 = load ptr, ptr %iter, align 8
  tail call void @zfree(ptr noundef %2) #32
  store ptr null, ptr %iter, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then7, %if.then3, %if.then
  %retval.0 = phi i32 [ 1, %if.then3 ], [ 0, %if.end10 ], [ 1, %if.then7 ], [ 1, %if.then ]
  ret i32 %retval.0
}

declare void @streamIteratorStop(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StreamIteratorNextID(ptr noundef %key, ptr noundef writeonly %id, ptr noundef writeonly %numfields) #0 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp.not, label %if.else5, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call4, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %tobool6.not = icmp eq ptr %1, null
  br i1 %tobool6.not, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.else5
  %call8 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call8, align 4
  br label %return

if.end10:                                         ; preds = %if.else5
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %numfieldsleft = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2
  %call13 = tail call i32 @streamIteratorGetID(ptr noundef nonnull %1, ptr noundef nonnull %u, ptr noundef nonnull %numfieldsleft) #32
  %tobool14.not = icmp eq i32 %call13, 0
  br i1 %tobool14.not, label %if.else24, label %if.then15

if.then15:                                        ; preds = %if.end10
  %tobool16.not = icmp eq ptr %id, null
  br i1 %tobool16.not, label %if.end20, label %if.then17

if.then17:                                        ; preds = %if.then15
  %2 = load i64, ptr %u, align 8
  store i64 %2, ptr %id, align 8
  %seq = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 1
  %3 = load i64, ptr %seq, align 8
  %seq19 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %id, i64 0, i32 1
  store i64 %3, ptr %seq19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %if.then15
  %tobool21.not = icmp eq ptr %numfields, null
  br i1 %tobool21.not, label %return, label %if.then22

if.then22:                                        ; preds = %if.end20
  %4 = load i64, ptr %numfieldsleft, align 8
  store i64 %4, ptr %numfields, align 8
  br label %return

if.else24:                                        ; preds = %if.end10
  %call33 = tail call ptr @__errno_location() #37
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %u, i8 0, i64 24, i1 false)
  store i32 2, ptr %call33, align 4
  br label %return

return:                                           ; preds = %if.end20, %if.then22, %if.else24, %if.then7, %if.then3, %if.then
  %retval.0 = phi i32 [ 1, %if.then3 ], [ 1, %if.else24 ], [ 1, %if.then7 ], [ 1, %if.then ], [ 0, %if.then22 ], [ 0, %if.end20 ]
  ret i32 %retval.0
}

declare i32 @streamIteratorGetID(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StreamIteratorNextField(ptr noundef %key, ptr noundef writeonly %field_ptr, ptr noundef writeonly %value_ptr) #0 {
entry:
  %field = alloca ptr, align 8
  %value17 = alloca ptr, align 8
  %field_len = alloca i64, align 8
  %value_len = alloca i64, align 8
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp.not, label %if.else5, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call4, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %tobool6.not = icmp eq ptr %1, null
  br i1 %tobool6.not, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.else5
  %call8 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call8, align 4
  br label %return

if.else9:                                         ; preds = %if.else5
  %numfieldsleft = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2
  %2 = load i64, ptr %numfieldsleft, align 8
  %cmp10 = icmp slt i64 %2, 1
  br i1 %cmp10, label %if.then11, label %if.end15

if.then11:                                        ; preds = %if.else9
  %call12 = tail call ptr @__errno_location() #37
  store i32 2, ptr %call12, align 4
  br label %return

if.end15:                                         ; preds = %if.else9
  call void @streamIteratorGetField(ptr noundef nonnull %1, ptr noundef nonnull %field, ptr noundef nonnull %value17, ptr noundef nonnull %field_len, ptr noundef nonnull %value_len) #32
  %tobool18.not = icmp eq ptr %field_ptr, null
  br i1 %tobool18.not, label %if.end21, label %if.then19

if.then19:                                        ; preds = %if.end15
  %3 = load ptr, ptr %field, align 8
  %4 = load i64, ptr %field_len, align 8
  %call20 = call ptr @createRawStringObject(ptr noundef %3, i64 noundef %4) #32
  store ptr %call20, ptr %field_ptr, align 8
  %5 = load ptr, ptr %key, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 7
  %6 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %6, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end21, label %if.end.i

if.end.i:                                         ; preds = %if.then19
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 6
  %7 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 5
  %8 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %7, %8
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %7, 1
  %cmp4.i = icmp slt i32 %7, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 4
  %9 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = call ptr @zrealloc(ptr noundef %9, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %10 = phi i32 [ %7, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %11 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 4
  %idxprom.i = sext i32 %10 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %11, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %12 = load ptr, ptr %amqueue12.i, align 8
  %13 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %13 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %12, i64 %idxprom17.i
  store ptr %call20, ptr %arrayidx18.i, align 8
  %14 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %14, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.end11.i, %if.then19, %if.end15
  %tobool22.not = icmp eq ptr %value_ptr, null
  br i1 %tobool22.not, label %if.end26, label %if.then23

if.then23:                                        ; preds = %if.end21
  %15 = load ptr, ptr %value17, align 8
  %16 = load i64, ptr %value_len, align 8
  %call24 = call ptr @createRawStringObject(ptr noundef %15, i64 noundef %16) #32
  store ptr %call24, ptr %value_ptr, align 8
  %17 = load ptr, ptr %key, align 8
  %flags.i14 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 7
  %18 = load i32, ptr %flags.i14, align 8
  %and.i15 = and i32 %18, 1
  %tobool.not.i16 = icmp eq i32 %and.i15, 0
  br i1 %tobool.not.i16, label %if.end26, label %if.end.i17

if.end.i17:                                       ; preds = %if.then23
  %amqueue_used.i18 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 6
  %19 = load i32, ptr %amqueue_used.i18, align 4
  %amqueue_len.i19 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 5
  %20 = load i32, ptr %amqueue_len.i19, align 8
  %cmp.i20 = icmp eq i32 %19, %20
  br i1 %cmp.i20, label %if.then1.i31, label %if.end.if.end11_crit_edge.i21

if.end.if.end11_crit_edge.i21:                    ; preds = %if.end.i17
  %amqueue12.phi.trans.insert.i22 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 4
  %.pre.i23 = load ptr, ptr %amqueue12.phi.trans.insert.i22, align 8
  br label %if.end11.i24

if.then1.i31:                                     ; preds = %if.end.i17
  %mul.i32 = shl nsw i32 %19, 1
  %cmp4.i33 = icmp slt i32 %19, 8
  %spec.select.i34 = select i1 %cmp4.i33, i32 16, i32 %mul.i32
  store i32 %spec.select.i34, ptr %amqueue_len.i19, align 8
  %amqueue.i35 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 4
  %21 = load ptr, ptr %amqueue.i35, align 8
  %conv.i36 = sext i32 %spec.select.i34 to i64
  %mul9.i37 = shl nsw i64 %conv.i36, 4
  %call.i38 = call ptr @zrealloc(ptr noundef %21, i64 noundef %mul9.i37) #34
  store ptr %call.i38, ptr %amqueue.i35, align 8
  %.pre14.i39 = load i32, ptr %amqueue_used.i18, align 4
  br label %if.end11.i24

if.end11.i24:                                     ; preds = %if.then1.i31, %if.end.if.end11_crit_edge.i21
  %22 = phi i32 [ %19, %if.end.if.end11_crit_edge.i21 ], [ %.pre14.i39, %if.then1.i31 ]
  %23 = phi ptr [ %.pre.i23, %if.end.if.end11_crit_edge.i21 ], [ %call.i38, %if.then1.i31 ]
  %amqueue12.i25 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i64 0, i32 4
  %idxprom.i26 = sext i32 %22 to i64
  %type14.i27 = getelementptr inbounds %struct.AutoMemEntry, ptr %23, i64 %idxprom.i26, i32 1
  store i32 1, ptr %type14.i27, align 8
  %24 = load ptr, ptr %amqueue12.i25, align 8
  %25 = load i32, ptr %amqueue_used.i18, align 4
  %idxprom17.i28 = sext i32 %25 to i64
  %arrayidx18.i29 = getelementptr inbounds %struct.AutoMemEntry, ptr %24, i64 %idxprom17.i28
  store ptr %call24, ptr %arrayidx18.i29, align 8
  %26 = load i32, ptr %amqueue_used.i18, align 4
  %inc.i30 = add nsw i32 %26, 1
  store i32 %inc.i30, ptr %amqueue_used.i18, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.end11.i24, %if.then23, %if.end21
  %27 = load i64, ptr %numfieldsleft, align 8
  %dec = add nsw i64 %27, -1
  store i64 %dec, ptr %numfieldsleft, align 8
  br label %return

return:                                           ; preds = %if.end26, %if.then11, %if.then7, %if.then3, %if.then
  %retval.0 = phi i32 [ 1, %if.then3 ], [ 1, %if.then11 ], [ 0, %if.end26 ], [ 1, %if.then7 ], [ 1, %if.then ]
  ret i32 %retval.0
}

declare void @streamIteratorGetField(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StreamIteratorDelete(ptr noundef %key) #0 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp.not, label %if.else5, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call4, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool6.not = icmp eq i32 %and, 0
  br i1 %tobool6.not, label %if.then9, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %if.else5
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %2 = load ptr, ptr %iter, align 8
  %tobool8.not = icmp eq ptr %2, null
  br i1 %tobool8.not, label %if.then9, label %if.else11

if.then9:                                         ; preds = %lor.lhs.false7, %if.else5
  %call10 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call10, align 4
  br label %return

if.else11:                                        ; preds = %lor.lhs.false7
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %3 = load i64, ptr %u, align 8
  %cmp12 = icmp eq i64 %3, 0
  br i1 %cmp12, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.else11
  %seq = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 1
  %4 = load i64, ptr %seq, align 8
  %cmp15 = icmp eq i64 %4, 0
  br i1 %cmp15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %land.lhs.true
  %call17 = tail call ptr @__errno_location() #37
  store i32 2, ptr %call17, align 4
  br label %return

if.end20:                                         ; preds = %if.else11, %land.lhs.true
  tail call void @streamIteratorRemoveEntry(ptr noundef nonnull %2, ptr noundef nonnull %u) #32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %u, i8 0, i64 24, i1 false)
  br label %return

return:                                           ; preds = %if.end20, %if.then16, %if.then9, %if.then3, %if.then
  %retval.0 = phi i32 [ 1, %if.then3 ], [ 1, %if.then16 ], [ 0, %if.end20 ], [ 1, %if.then9 ], [ 1, %if.then ]
  ret i32 %retval.0
}

declare void @streamIteratorRemoveEntry(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_StreamTrimByLength(ptr noundef readonly %key, i32 noundef %flags, i64 noundef %length) #0 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %tobool1 = icmp ugt i32 %flags, 1
  %cmp = icmp slt i64 %length, 0
  %or.cond = or i1 %tobool1, %cmp
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool3.not = icmp eq ptr %0, null
  br i1 %tobool3.not, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp6.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp6.not, label %if.else9, label %if.then7

if.then7:                                         ; preds = %lor.lhs.false4, %if.else
  %call8 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call8, align 4
  br label %return

if.else9:                                         ; preds = %lor.lhs.false4
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and10 = and i32 %1, 2
  %tobool11.not = icmp eq i32 %and10, 0
  br i1 %tobool11.not, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.else9
  %call13 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call13, align 4
  br label %return

if.end15:                                         ; preds = %if.else9
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %call19 = tail call i64 @streamTrimByLength(ptr noundef %2, i64 noundef %length, i32 noundef %flags) #32
  br label %return

return:                                           ; preds = %if.end15, %if.then12, %if.then7, %if.then
  %retval.0 = phi i64 [ -1, %if.then ], [ -1, %if.then7 ], [ %call19, %if.end15 ], [ -1, %if.then12 ]
  ret i64 %retval.0
}

declare i64 @streamTrimByLength(ptr noundef, i64 noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_StreamTrimByID(ptr noundef readonly %key, i32 noundef %flags, ptr noundef readonly %id) #0 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %tobool1 = icmp ult i32 %flags, 2
  %tobool3 = icmp ne ptr %id, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool4.not = icmp eq ptr %0, null
  br i1 %tobool4.not, label %if.then7, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %if.else
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 6
  br i1 %cmp.not, label %if.else9, label %if.then7

if.then7:                                         ; preds = %lor.lhs.false5, %if.else
  %call8 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call8, align 4
  br label %return

if.else9:                                         ; preds = %lor.lhs.false5
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and10 = and i32 %1, 2
  %tobool11.not = icmp eq i32 %and10, 0
  br i1 %tobool11.not, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.else9
  %call13 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call13, align 4
  br label %return

if.end15:                                         ; preds = %if.else9
  %2 = load i64, ptr %id, align 8
  %seq19 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %id, i64 0, i32 1
  %3 = load i64, ptr %seq19, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %4 = load ptr, ptr %ptr, align 8
  %call21 = tail call i64 @streamTrimByID(ptr noundef %4, i64 %2, i64 %3, i32 noundef %flags) #32
  br label %return

return:                                           ; preds = %if.end15, %if.then12, %if.then7, %if.then
  %retval.0 = phi i64 [ -1, %if.then7 ], [ %call21, %if.end15 ], [ -1, %if.then12 ], [ -1, %if.then ]
  ret i64 %retval.0
}

declare i64 @streamTrimByID(ptr noundef, i64, i64, i32 noundef) local_unnamed_addr #1

declare i32 @callReplyType(ptr noundef) local_unnamed_addr #1

declare ptr @callReplyGetPrivateData(ptr noundef) local_unnamed_addr #1

declare void @freeCallReply(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyType(ptr noundef %reply) #0 {
entry:
  %call = tail call i32 @callReplyType(ptr noundef %reply) #32
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_CallReplyLength(ptr noundef %reply) #0 {
entry:
  %call = tail call i64 @callReplyGetLen(ptr noundef %reply) #32
  ret i64 %call
}

declare i64 @callReplyGetLen(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyArrayElement(ptr noundef %reply, i64 noundef %idx) #0 {
entry:
  %call = tail call ptr @callReplyGetArrayElement(ptr noundef %reply, i64 noundef %idx) #32
  ret ptr %call
}

declare ptr @callReplyGetArrayElement(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_CallReplyInteger(ptr noundef %reply) #0 {
entry:
  %call = tail call i64 @callReplyGetLongLong(ptr noundef %reply) #32
  ret i64 %call
}

declare i64 @callReplyGetLongLong(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local double @RM_CallReplyDouble(ptr noundef %reply) #0 {
entry:
  %call = tail call double @callReplyGetDouble(ptr noundef %reply) #32
  ret double %call
}

declare double @callReplyGetDouble(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyBigNumber(ptr noundef %reply, ptr noundef %len) #0 {
entry:
  %call = tail call ptr @callReplyGetBigNumber(ptr noundef %reply, ptr noundef %len) #32
  ret ptr %call
}

declare ptr @callReplyGetBigNumber(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyVerbatim(ptr noundef %reply, ptr noundef %len, ptr noundef %format) #0 {
entry:
  %call = tail call ptr @callReplyGetVerbatim(ptr noundef %reply, ptr noundef %len, ptr noundef %format) #32
  ret ptr %call
}

declare ptr @callReplyGetVerbatim(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyBool(ptr noundef %reply) #0 {
entry:
  %call = tail call i32 @callReplyGetBool(ptr noundef %reply) #32
  ret i32 %call
}

declare i32 @callReplyGetBool(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplySetElement(ptr noundef %reply, i64 noundef %idx) #0 {
entry:
  %call = tail call ptr @callReplyGetSetElement(ptr noundef %reply, i64 noundef %idx) #32
  ret ptr %call
}

declare ptr @callReplyGetSetElement(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyMapElement(ptr noundef %reply, i64 noundef %idx, ptr noundef %key, ptr noundef %val) #0 {
entry:
  %call = tail call i32 @callReplyGetMapElement(ptr noundef %reply, i64 noundef %idx, ptr noundef %key, ptr noundef %val) #32
  %cmp = icmp ne i32 %call, 0
  %. = zext i1 %cmp to i32
  ret i32 %.
}

declare i32 @callReplyGetMapElement(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyAttribute(ptr noundef %reply) #0 {
entry:
  %call = tail call ptr @callReplyGetAttribute(ptr noundef %reply) #32
  ret ptr %call
}

declare ptr @callReplyGetAttribute(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyAttributeElement(ptr noundef %reply, i64 noundef %idx, ptr noundef %key, ptr noundef %val) #0 {
entry:
  %call = tail call i32 @callReplyGetAttributeElement(ptr noundef %reply, i64 noundef %idx, ptr noundef %key, ptr noundef %val) #32
  %cmp = icmp ne i32 %call, 0
  %. = zext i1 %cmp to i32
  ret i32 %.
}

declare i32 @callReplyGetAttributeElement(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_CallReplyPromiseSetUnblockHandler(ptr noundef %reply, ptr noundef %on_unblock, ptr noundef %private_data) #0 {
entry:
  %call = tail call ptr @callReplyGetPrivateData(ptr noundef %reply) #32
  %on_unblocked = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %call, i64 0, i32 3
  store ptr %on_unblock, ptr %on_unblocked, align 8
  %private_data1 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %call, i64 0, i32 1
  store ptr %private_data, ptr %private_data1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_CallReplyPromiseAbort(ptr noundef %reply, ptr noundef writeonly %private_data) #0 {
entry:
  %call = tail call ptr @callReplyGetPrivateData(ptr noundef %reply) #32
  %c = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %call, i64 0, i32 4
  %0 = load ptr, ptr %c, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %and = and i64 %1, 16
  %tobool2.not = icmp eq i64 %and, 0
  br i1 %tobool2.not, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  %tobool5.not = icmp eq ptr %private_data, null
  br i1 %tobool5.not, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end4
  %private_data7 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %call, i64 0, i32 1
  %2 = load ptr, ptr %private_data7, align 8
  store ptr %2, ptr %private_data, align 8
  %.pre = load ptr, ptr %c, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %3 = phi ptr [ %.pre, %if.then6 ], [ %0, %if.end4 ]
  %private_data9 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %call, i64 0, i32 1
  store ptr null, ptr %private_data9, align 8
  %on_unblocked = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %call, i64 0, i32 3
  store ptr null, ptr %on_unblocked, align 8
  tail call void @unblockClient(ptr noundef %3, i32 noundef 0) #32
  %4 = load ptr, ptr %c, align 8
  tail call void @moduleReleaseTempClient(ptr noundef %4)
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end8
  %retval.0 = phi i32 [ 0, %if.end8 ], [ 1, %entry ], [ 1, %if.end ]
  ret i32 %retval.0
}

declare void @unblockClient(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyStringPtr(ptr noundef %reply, ptr noundef %len) #0 {
entry:
  %private_len = alloca i64, align 8
  %tobool.not = icmp eq ptr %len, null
  %spec.select = select i1 %tobool.not, ptr %private_len, ptr %len
  %call = call ptr @callReplyGetString(ptr noundef %reply, ptr noundef nonnull %spec.select) #32
  ret ptr %call
}

declare ptr @callReplyGetString(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromCallReply(ptr noundef %reply) #0 {
entry:
  %len = alloca i64, align 8
  %buf = alloca [64 x i8], align 16
  %call = tail call ptr @callReplyGetPrivateData(ptr noundef %reply) #32
  %call1 = tail call i32 @callReplyType(ptr noundef %reply) #32
  switch i32 %call1, label %return [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
    i32 2, label %sw.bb4
  ]

sw.bb:                                            ; preds = %entry, %entry
  %call2 = call ptr @callReplyGetString(ptr noundef %reply, ptr noundef nonnull %len) #32
  %0 = load i64, ptr %len, align 8
  %call.i = call ptr @createStringObject(ptr noundef %call2, i64 noundef %0) #32
  %cmp.not.i = icmp eq ptr %call, null
  br i1 %cmp.not.i, label %return, label %if.then.i

if.then.i:                                        ; preds = %sw.bb
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 7
  %1 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %1, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 6
  %2 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 5
  %3 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %2, %3
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %return.sink.split

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %2, 1
  %cmp4.i.i = icmp slt i32 %2, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 4
  %4 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = call ptr @zrealloc(ptr noundef %4, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %return.sink.split

sw.bb4:                                           ; preds = %entry
  %call6 = tail call i64 @callReplyGetLongLong(ptr noundef %reply) #32
  %call7 = call i32 @ll2string(ptr noundef nonnull %buf, i64 noundef 64, i64 noundef %call6) #32
  %conv = sext i32 %call7 to i64
  %call.i5 = call ptr @createStringObject(ptr noundef nonnull %buf, i64 noundef %conv) #32
  %cmp.not.i6 = icmp eq ptr %call, null
  br i1 %cmp.not.i6, label %return, label %if.then.i7

if.then.i7:                                       ; preds = %sw.bb4
  %flags.i.i8 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 7
  %5 = load i32, ptr %flags.i.i8, align 8
  %and.i.i9 = and i32 %5, 1
  %tobool.not.i.i10 = icmp eq i32 %and.i.i9, 0
  br i1 %tobool.not.i.i10, label %return, label %if.end.i.i11

if.end.i.i11:                                     ; preds = %if.then.i7
  %amqueue_used.i.i12 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 6
  %6 = load i32, ptr %amqueue_used.i.i12, align 4
  %amqueue_len.i.i13 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 5
  %7 = load i32, ptr %amqueue_len.i.i13, align 8
  %cmp.i.i14 = icmp eq i32 %6, %7
  br i1 %cmp.i.i14, label %if.then1.i.i25, label %if.end.if.end11_crit_edge.i.i15

if.end.if.end11_crit_edge.i.i15:                  ; preds = %if.end.i.i11
  %amqueue12.phi.trans.insert.i.i16 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 4
  %.pre.i.i17 = load ptr, ptr %amqueue12.phi.trans.insert.i.i16, align 8
  br label %return.sink.split

if.then1.i.i25:                                   ; preds = %if.end.i.i11
  %mul.i.i26 = shl nsw i32 %6, 1
  %cmp4.i.i27 = icmp slt i32 %6, 8
  %spec.select.i.i28 = select i1 %cmp4.i.i27, i32 16, i32 %mul.i.i26
  store i32 %spec.select.i.i28, ptr %amqueue_len.i.i13, align 8
  %amqueue.i.i29 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 4
  %8 = load ptr, ptr %amqueue.i.i29, align 8
  %conv.i.i30 = sext i32 %spec.select.i.i28 to i64
  %mul9.i.i31 = shl nsw i64 %conv.i.i30, 4
  %call.i.i32 = call ptr @zrealloc(ptr noundef %8, i64 noundef %mul9.i.i31) #34
  store ptr %call.i.i32, ptr %amqueue.i.i29, align 8
  %.pre14.i.i33 = load i32, ptr %amqueue_used.i.i12, align 4
  br label %return.sink.split

return.sink.split:                                ; preds = %if.end.if.end11_crit_edge.i.i15, %if.then1.i.i25, %if.end.if.end11_crit_edge.i.i, %if.then1.i.i
  %.sink38 = phi i32 [ %2, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ], [ %6, %if.end.if.end11_crit_edge.i.i15 ], [ %.pre14.i.i33, %if.then1.i.i25 ]
  %.sink = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ], [ %.pre.i.i17, %if.end.if.end11_crit_edge.i.i15 ], [ %call.i.i32, %if.then1.i.i25 ]
  %amqueue_used.i.i12.sink37 = phi ptr [ %amqueue_used.i.i, %if.end.if.end11_crit_edge.i.i ], [ %amqueue_used.i.i, %if.then1.i.i ], [ %amqueue_used.i.i12, %if.end.if.end11_crit_edge.i.i15 ], [ %amqueue_used.i.i12, %if.then1.i.i25 ]
  %call.i5.sink = phi ptr [ %call.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i, %if.then1.i.i ], [ %call.i5, %if.end.if.end11_crit_edge.i.i15 ], [ %call.i5, %if.then1.i.i25 ]
  %amqueue12.i.i19 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 4
  %idxprom.i.i20 = sext i32 %.sink38 to i64
  %type14.i.i21 = getelementptr inbounds %struct.AutoMemEntry, ptr %.sink, i64 %idxprom.i.i20, i32 1
  store i32 1, ptr %type14.i.i21, align 8
  %9 = load ptr, ptr %amqueue12.i.i19, align 8
  %10 = load i32, ptr %amqueue_used.i.i12.sink37, align 4
  %idxprom17.i.i22 = sext i32 %10 to i64
  %arrayidx18.i.i23 = getelementptr inbounds %struct.AutoMemEntry, ptr %9, i64 %idxprom17.i.i22
  store ptr %call.i5.sink, ptr %arrayidx18.i.i23, align 8
  %11 = load i32, ptr %amqueue_used.i.i12.sink37, align 4
  %inc.i.i24 = add nsw i32 %11, 1
  store i32 %inc.i.i24, ptr %amqueue_used.i.i12.sink37, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %if.then.i7, %sw.bb4, %if.then.i, %sw.bb, %entry
  %retval.0 = phi ptr [ null, %entry ], [ %call.i, %sw.bb ], [ %call.i, %if.then.i ], [ %call.i5, %sw.bb4 ], [ %call.i5, %if.then.i7 ], [ %call.i5.sink, %return.sink.split ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define dso_local void @RM_SetContextUser(ptr nocapture noundef writeonly %ctx, ptr noundef %user) #23 {
entry:
  %user1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 15
  store ptr %user, ptr %user1, align 8
  ret void
}

declare ptr @createStringObjectFromLongLongWithSds(i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Call(ptr noundef %ctx, ptr noundef %cmdname, ptr nocapture noundef readonly %fmt, ...) #0 {
entry:
  %argc = alloca i32, align 4
  %flags = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %err = alloca ptr, align 8
  %acl_errpos = alloca i32, align 4
  %error_code = alloca i32, align 4
  store i32 0, ptr %argc, align 4
  store i32 0, ptr %flags, align 4
  call void @llvm.va_start(ptr nonnull %ap)
  %call = call ptr @moduleCreateArgvFromUserFormat(ptr noundef %cmdname, ptr noundef %fmt, ptr noundef nonnull %argc, ptr noundef nonnull %flags, ptr noundef nonnull %ap)
  %0 = load i32, ptr %flags, align 4
  %and = and i32 %0, 1
  %and2 = and i32 %0, 256
  call void @llvm.va_end(ptr nonnull %ap)
  %1 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i = icmp eq i64 %1, 0
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %2 = load ptr, ptr @moduleTempClients, align 8
  %dec.i = add i64 %1, -1
  store i64 %dec.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i = getelementptr inbounds ptr, ptr %2, i64 %dec.i
  %3 = load ptr, ptr %arrayidx.i, align 8
  %4 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i = icmp ult i64 %dec.i, %4
  br i1 %cmp1.i, label %if.then2.i, label %moduleAllocTempClient.exit

if.then2.i:                                       ; preds = %if.then.i
  store i64 %dec.i, ptr @moduleTempClientMinCount, align 8
  br label %moduleAllocTempClient.exit

if.else.i:                                        ; preds = %entry
  %call.i = call ptr @createClient(ptr noundef null) #32
  %flags.i = getelementptr inbounds %struct.client, ptr %call.i, i64 0, i32 1
  %5 = load i64, ptr %flags.i, align 8
  %or.i = or i64 %5, 134217728
  store i64 %or.i, ptr %flags.i, align 8
  %user.i = getelementptr inbounds %struct.client, ptr %call.i, i64 0, i32 20
  store ptr null, ptr %user.i, align 8
  br label %moduleAllocTempClient.exit

moduleAllocTempClient.exit:                       ; preds = %if.then.i, %if.then2.i, %if.else.i
  %c.0.i = phi ptr [ %3, %if.then2.i ], [ %3, %if.then.i ], [ %call.i, %if.else.i ]
  %6 = load i32, ptr %flags, align 4
  %and5 = and i32 %6, 2048
  %tobool.not = icmp eq i32 %and5, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %moduleAllocTempClient.exit
  %flags6 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 1
  %7 = load i64, ptr %flags6, align 8
  %or = or i64 %7, 2199023255552
  store i64 %or, ptr %flags6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %moduleAllocTempClient.exit
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %8 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %8, i64 0, i32 4
  %9 = load ptr, ptr %db, align 8
  %db7 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 4
  store ptr %9, ptr %db7, align 8
  %argv8 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 12
  store ptr %call, ptr %argv8, align 8
  %10 = load i32, ptr %argc, align 4
  %argv_len = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 13
  store i32 %10, ptr %argv_len, align 8
  %argc9 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 11
  store i32 %10, ptr %argc9, align 8
  %resp = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 3
  store i32 2, ptr %resp, align 8
  %and10 = and i32 %6, 8
  %tobool11.not = icmp eq i32 %and10, 0
  br i1 %tobool11.not, label %if.else, label %if.end21.sink.split

if.else:                                          ; preds = %if.end
  %and14 = and i32 %6, 16
  %tobool15.not = icmp eq i32 %and14, 0
  br i1 %tobool15.not, label %if.end21, label %if.then16

if.then16:                                        ; preds = %if.else
  %11 = load ptr, ptr %client, align 8
  %resp18 = getelementptr inbounds %struct.client, ptr %11, i64 0, i32 3
  %12 = load i32, ptr %resp18, align 8
  br label %if.end21.sink.split

if.end21.sink.split:                              ; preds = %if.end, %if.then16
  %.sink = phi i32 [ %12, %if.then16 ], [ 3, %if.end ]
  store i32 %.sink, ptr %resp, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.end21.sink.split, %if.else
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %13 = load ptr, ptr %module, align 8
  %tobool22.not = icmp eq ptr %13, null
  br i1 %tobool22.not, label %if.end25, label %if.then23

if.then23:                                        ; preds = %if.end21
  %in_call = getelementptr inbounds %struct.RedisModule, ptr %13, i64 0, i32 10
  %14 = load i32, ptr %in_call, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %in_call, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end21
  %and26 = and i32 %6, 32
  %tobool27.not = icmp eq i32 %and26, 0
  br i1 %tobool27.not, label %if.end45, label %if.then28

if.then28:                                        ; preds = %if.end25
  %user29 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 15
  %15 = load ptr, ptr %user29, align 8
  %tobool30.not = icmp eq ptr %15, null
  br i1 %tobool30.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then28
  %16 = load ptr, ptr %client, align 8
  %user34 = getelementptr inbounds %struct.client, ptr %16, i64 0, i32 20
  br label %cond.end

cond.end:                                         ; preds = %if.then28, %cond.false
  %cond.in = phi ptr [ %user34, %cond.false ], [ %15, %if.then28 ]
  %cond = load ptr, ptr %cond.in, align 8
  %tobool35.not = icmp eq ptr %cond, null
  br i1 %tobool35.not, label %if.then36, label %if.end43

if.then36:                                        ; preds = %cond.end
  %call37 = tail call ptr @__errno_location() #37
  store i32 95, ptr %call37, align 4
  %tobool38.not = icmp eq i32 %and2, 0
  br i1 %tobool38.not, label %if.end400, label %if.then39

if.then39:                                        ; preds = %if.then36
  %call40 = call ptr @sdsnew(ptr noundef nonnull @.str.46) #32
  %call41 = call ptr @callReplyCreateError(ptr noundef %call40, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end43:                                         ; preds = %cond.end
  %user44 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 20
  store ptr %cond, ptr %user44, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.end43, %if.end25
  %user.0 = phi ptr [ %cond, %if.end43 ], [ null, %if.end25 ]
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.end45
  %call47 = tail call ptr @__errno_location() #37
  store i32 9, ptr %call47, align 4
  br label %if.end400

if.end48:                                         ; preds = %if.end45
  call void @moduleCallCommandFilters(ptr noundef nonnull %c.0.i)
  %17 = load ptr, ptr %argv8, align 8
  %18 = load i32, ptr %argc9, align 8
  %call51 = call ptr @lookupCommand(ptr noundef %17, i32 noundef %18) #32
  %realcmd = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 19
  store ptr %call51, ptr %realcmd, align 8
  %lastcmd = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 18
  store ptr %call51, ptr %lastcmd, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 17
  store ptr %call51, ptr %cmd, align 8
  %tobool52.not = icmp eq i32 %and2, 0
  %err. = select i1 %tobool52.not, ptr null, ptr %err
  %call57 = call i32 @commandCheckExistence(ptr noundef nonnull %c.0.i, ptr noundef %err.) #32
  %tobool58.not = icmp eq i32 %call57, 0
  br i1 %tobool58.not, label %if.then59, label %if.end65

if.then59:                                        ; preds = %if.end48
  %call60 = tail call ptr @__errno_location() #37
  store i32 2, ptr %call60, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then62

if.then62:                                        ; preds = %if.then59
  %19 = load ptr, ptr %err, align 8
  %call63 = call ptr @callReplyCreateError(ptr noundef %19, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end65:                                         ; preds = %if.end48
  %call71 = call i32 @commandCheckArity(ptr noundef nonnull %c.0.i, ptr noundef %err.) #32
  %tobool72.not = icmp eq i32 %call71, 0
  br i1 %tobool72.not, label %if.then73, label %if.end79

if.then73:                                        ; preds = %if.end65
  %call74 = tail call ptr @__errno_location() #37
  store i32 22, ptr %call74, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then76

if.then76:                                        ; preds = %if.then73
  %20 = load ptr, ptr %err, align 8
  %call77 = call ptr @callReplyCreateError(ptr noundef %20, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end79:                                         ; preds = %if.end65
  %call80 = call i64 @getCommandFlags(ptr noundef nonnull %c.0.i) #32
  %21 = load i32, ptr %flags, align 4
  %and81 = and i32 %21, 64
  %tobool82.not = icmp eq i32 %and81, 0
  %and84 = and i64 %call80, 64
  %tobool85.not = icmp eq i64 %and84, 0
  %or.cond127 = select i1 %tobool82.not, i1 true, i1 %tobool85.not
  br i1 %or.cond127, label %if.end97, label %if.then86

if.then86:                                        ; preds = %if.end79
  %call87 = tail call ptr @__errno_location() #37
  store i32 29, ptr %call87, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then89

if.then89:                                        ; preds = %if.then86
  %call91 = call ptr @sdsempty() #32
  %22 = load ptr, ptr %cmd, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %22, i64 0, i32 27
  %23 = load ptr, ptr %fullname, align 8
  %call93 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call91, ptr noundef nonnull @.str.47, ptr noundef %23) #32
  %call94 = call ptr @callReplyCreateError(ptr noundef %call93, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end97:                                         ; preds = %if.end79
  %and98 = and i32 %21, 512
  %tobool99 = icmp ne i32 %and98, 0
  %24 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 314), align 8
  %tobool100 = icmp ne i64 %24, 0
  %or.cond = select i1 %tobool99, i1 %tobool100, i1 false
  br i1 %or.cond, label %if.then101, label %if.else124

if.then101:                                       ; preds = %if.end97
  %and102 = and i64 %call80, 4
  %tobool103.not = icmp eq i64 %and102, 0
  br i1 %tobool103.not, label %if.end127, label %if.then104

if.then104:                                       ; preds = %if.then101
  %flags105 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %25 = load i32, ptr %flags105, align 8
  %and106 = and i32 %25, 16
  %tobool107.not = icmp eq i32 %and106, 0
  br i1 %tobool107.not, label %if.else111, label %if.then108

if.then108:                                       ; preds = %if.then104
  %call109 = call i32 @getMaxmemoryState(ptr noundef null, ptr noundef null, ptr noundef null, ptr noundef null) #32
  %cmp110 = icmp eq i32 %call109, -1
  %conv = zext i1 %cmp110 to i32
  br label %if.end112

if.else111:                                       ; preds = %if.then104
  %26 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 386), align 8
  br label %if.end112

if.end112:                                        ; preds = %if.else111, %if.then108
  %oom_state.0 = phi i32 [ %conv, %if.then108 ], [ %26, %if.else111 ]
  %tobool113.not = icmp eq i32 %oom_state.0, 0
  br i1 %tobool113.not, label %if.end112.if.end127_crit_edge, label %if.then114

if.end112.if.end127_crit_edge:                    ; preds = %if.end112
  %.pre = load i32, ptr %flags, align 4
  br label %if.end127

if.then114:                                       ; preds = %if.end112
  %call115 = tail call ptr @__errno_location() #37
  store i32 28, ptr %call115, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then117

if.then117:                                       ; preds = %if.then114
  %27 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 30), align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %27, i64 0, i32 2
  %28 = load ptr, ptr %ptr, align 8
  %call119 = call ptr @sdsdup(ptr noundef %28) #32
  %call120 = call ptr @callReplyCreateError(ptr noundef %call119, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.else124:                                       ; preds = %if.end97
  %flags125 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 1
  %29 = load i64, ptr %flags125, align 8
  %or126 = or i64 %29, 17592186044416
  store i64 %or126, ptr %flags125, align 8
  br label %if.end127

if.end127:                                        ; preds = %if.end112.if.end127_crit_edge, %if.then101, %if.else124
  %30 = phi i32 [ %.pre, %if.end112.if.end127_crit_edge ], [ %21, %if.then101 ], [ %21, %if.else124 ]
  %and128 = and i32 %30, 128
  %tobool129.not = icmp eq i32 %and128, 0
  %and131 = and i64 %call80, 1
  %tobool132.not = icmp eq i64 %and131, 0
  %or.cond128 = select i1 %tobool129.not, i1 true, i1 %tobool132.not
  br i1 %or.cond128, label %if.end145, label %if.then133

if.then133:                                       ; preds = %if.end127
  %call134 = tail call ptr @__errno_location() #37
  store i32 28, ptr %call134, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then136

if.then136:                                       ; preds = %if.then133
  %call138 = call ptr @sdsempty() #32
  %31 = load ptr, ptr %cmd, align 8
  %fullname140 = getelementptr inbounds %struct.redisCommand, ptr %31, i64 0, i32 27
  %32 = load ptr, ptr %fullname140, align 8
  %call141 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call138, ptr noundef nonnull @.str.48, ptr noundef %32) #32
  %call142 = call ptr @callReplyCreateError(ptr noundef %call141, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end145:                                        ; preds = %if.end127
  %and146 = and i32 %30, 64
  %tobool147.not = icmp eq i32 %and146, 0
  br i1 %tobool147.not, label %if.end217, label %if.then148

if.then148:                                       ; preds = %if.end145
  br i1 %tobool132.not, label %if.then148.if.end196_crit_edge, label %if.then151

if.then148.if.end196_crit_edge:                   ; preds = %if.then148
  %.pre138 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  br label %if.end196

if.then151:                                       ; preds = %if.then148
  %call152 = call i32 @checkGoodReplicasStatus() #32
  %tobool153.not = icmp eq i32 %call152, 0
  br i1 %tobool153.not, label %if.then154, label %if.end163

if.then154:                                       ; preds = %if.then151
  %call155 = tail call ptr @__errno_location() #37
  store i32 29, ptr %call155, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then157

if.then157:                                       ; preds = %if.then154
  %33 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 28), align 8
  %ptr159 = getelementptr inbounds %struct.redisObject, ptr %33, i64 0, i32 2
  %34 = load ptr, ptr %ptr159, align 8
  %call160 = call ptr @sdsdup(ptr noundef %34) #32
  %call161 = call ptr @callReplyCreateError(ptr noundef %call160, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end163:                                        ; preds = %if.then151
  %call164 = call i32 @writeCommandsDeniedByDiskError() #32
  %35 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %tobool165.not = icmp eq ptr %35, null
  br i1 %tobool165.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.end163
  %call166 = call i32 @mustObeyClient(ptr noundef nonnull %35) #32
  %tobool167 = icmp ne i32 %call166, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end163
  %36 = phi i1 [ false, %if.end163 ], [ %tobool167, %land.rhs ]
  %cmp168 = icmp eq i32 %call164, 0
  %or.cond2 = select i1 %cmp168, i1 true, i1 %36
  br i1 %or.cond2, label %if.end180, label %if.then172

if.then172:                                       ; preds = %land.end
  %call173 = tail call ptr @__errno_location() #37
  store i32 29, ptr %call173, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then175

if.then175:                                       ; preds = %if.then172
  %call177 = call ptr @writeCommandsGetDiskErrorMessage(i32 noundef %call164) #32
  %call178 = call ptr @callReplyCreateError(ptr noundef %call177, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end180:                                        ; preds = %land.end
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %tobool181 = icmp eq ptr %37, null
  %38 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 298), align 4
  %tobool183 = icmp eq i32 %38, 0
  %or.cond3.not126 = select i1 %tobool181, i1 true, i1 %tobool183
  %or.cond4 = select i1 %or.cond3.not126, i1 true, i1 %36
  br i1 %or.cond4, label %if.end196, label %if.then186

if.then186:                                       ; preds = %if.end180
  %call187 = tail call ptr @__errno_location() #37
  store i32 29, ptr %call187, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then189

if.then189:                                       ; preds = %if.then186
  %39 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 25), align 8
  %ptr191 = getelementptr inbounds %struct.redisObject, ptr %39, i64 0, i32 2
  %40 = load ptr, ptr %ptr191, align 8
  %call192 = call ptr @sdsdup(ptr noundef %40) #32
  %call193 = call ptr @callReplyCreateError(ptr noundef %call192, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end196:                                        ; preds = %if.then148.if.end196_crit_edge, %if.end180
  %41 = phi ptr [ %.pre138, %if.then148.if.end196_crit_edge ], [ %37, %if.end180 ]
  %tobool197 = icmp ne ptr %41, null
  %42 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  %cmp199 = icmp ne i32 %42, 12
  %or.cond5 = select i1 %tobool197, i1 %cmp199, i1 false
  %43 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 297), align 8
  %cmp202 = icmp eq i32 %43, 0
  %or.cond6 = select i1 %or.cond5, i1 %cmp202, i1 false
  %and205 = and i64 %call80, 1024
  %tobool206.not = icmp eq i64 %and205, 0
  %or.cond129 = select i1 %or.cond6, i1 %tobool206.not, i1 false
  br i1 %or.cond129, label %if.then207, label %if.end196.if.end217_crit_edge

if.end196.if.end217_crit_edge:                    ; preds = %if.end196
  %.pre139 = load i32, ptr %flags, align 4
  br label %if.end217

if.then207:                                       ; preds = %if.end196
  %call208 = tail call ptr @__errno_location() #37
  store i32 29, ptr %call208, align 4
  br i1 %tobool52.not, label %if.end400, label %if.then210

if.then210:                                       ; preds = %if.then207
  %44 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 24), align 8
  %ptr212 = getelementptr inbounds %struct.redisObject, ptr %44, i64 0, i32 2
  %45 = load ptr, ptr %ptr212, align 8
  %call213 = call ptr @sdsdup(ptr noundef %45) #32
  %call214 = call ptr @callReplyCreateError(ptr noundef %call213, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end217:                                        ; preds = %if.end196.if.end217_crit_edge, %if.end145
  %46 = phi i32 [ %.pre139, %if.end196.if.end217_crit_edge ], [ %30, %if.end145 ]
  %and218 = and i32 %46, 32
  %tobool219.not = icmp eq i32 %and218, 0
  br i1 %tobool219.not, label %if.end258, label %if.then220

if.then220:                                       ; preds = %if.end217
  %47 = load ptr, ptr %cmd, align 8
  %48 = load ptr, ptr %argv8, align 8
  %49 = load i32, ptr %argc9, align 8
  %call224 = call i32 @ACLCheckAllUserCommandPerm(ptr noundef %user.0, ptr noundef %47, ptr noundef %48, i32 noundef %49, ptr noundef nonnull %acl_errpos) #32
  switch i32 %call224, label %cond.false234 [
    i32 0, label %if.end258
    i32 1, label %cond.true230
  ]

cond.true230:                                     ; preds = %if.then220
  %50 = load ptr, ptr %cmd, align 8
  %fullname232 = getelementptr inbounds %struct.redisCommand, ptr %50, i64 0, i32 27
  br label %cond.end238

cond.false234:                                    ; preds = %if.then220
  %51 = load ptr, ptr %argv8, align 8
  %52 = load i32, ptr %acl_errpos, align 4
  %idxprom = sext i32 %52 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %51, i64 %idxprom
  %53 = load ptr, ptr %arrayidx, align 8
  %ptr236 = getelementptr inbounds %struct.redisObject, ptr %53, i64 0, i32 2
  br label %cond.end238

cond.end238:                                      ; preds = %cond.false234, %cond.true230
  %ptr236.sink = phi ptr [ %ptr236, %cond.false234 ], [ %fullname232, %cond.true230 ]
  %54 = load ptr, ptr %ptr236.sink, align 8
  %call237 = call ptr @sdsdup(ptr noundef %54) #32
  %55 = load ptr, ptr %client, align 8
  %user241 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 20
  %56 = load ptr, ptr %user241, align 8
  %57 = load ptr, ptr %56, align 8
  call void @addACLLogEntry(ptr noundef %55, i32 noundef %call224, i32 noundef 3, i32 noundef -1, ptr noundef %57, ptr noundef %call237) #32
  br i1 %tobool52.not, label %if.end255, label %if.then243

if.then243:                                       ; preds = %cond.end238
  %58 = load ptr, ptr %user241, align 8
  %59 = load ptr, ptr %cmd, align 8
  %60 = load ptr, ptr %argv8, align 8
  %61 = load i32, ptr %acl_errpos, align 4
  %idxprom247 = sext i32 %61 to i64
  %arrayidx248 = getelementptr inbounds ptr, ptr %60, i64 %idxprom247
  %62 = load ptr, ptr %arrayidx248, align 8
  %ptr249 = getelementptr inbounds %struct.redisObject, ptr %62, i64 0, i32 2
  %63 = load ptr, ptr %ptr249, align 8
  %call250 = call ptr @getAclErrorMessage(i32 noundef %call224, ptr noundef %58, ptr noundef %59, ptr noundef %63, i32 noundef 0) #32
  %call252 = call ptr @sdsempty() #32
  %call253 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call252, ptr noundef nonnull @.str.49, ptr noundef %call250) #32
  call void @sdsfree(ptr noundef %call250) #32
  %call254 = call ptr @callReplyCreateError(ptr noundef %call253, ptr noundef nonnull %ctx) #32
  br label %if.end255

if.end255:                                        ; preds = %if.then243, %cond.end238
  %reply.0 = phi ptr [ %call254, %if.then243 ], [ null, %cond.end238 ]
  %call256 = tail call ptr @__errno_location() #37
  store i32 13, ptr %call256, align 4
  br label %cleanup

if.end258:                                        ; preds = %if.then220, %if.end217
  %64 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool259.not = icmp eq i32 %64, 0
  br i1 %tobool259.not, label %if.end317, label %land.lhs.true260

land.lhs.true260:                                 ; preds = %if.end258
  %65 = load ptr, ptr %client, align 8
  %call262 = call i32 @mustObeyClient(ptr noundef %65) #32
  %tobool263.not = icmp eq i32 %call262, 0
  br i1 %tobool263.not, label %if.then264, label %if.end317

if.then264:                                       ; preds = %land.lhs.true260
  %flags265 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 1
  %66 = load i64, ptr %flags265, align 8
  %and266 = and i64 %66, -131585
  store i64 %and266, ptr %flags265, align 8
  %67 = load ptr, ptr %client, align 8
  %flags268 = getelementptr inbounds %struct.client, ptr %67, i64 0, i32 1
  %68 = load i64, ptr %flags268, align 8
  %and269 = and i64 %68, 131584
  %or271 = or disjoint i64 %and269, %and266
  store i64 %or271, ptr %flags265, align 8
  %69 = load ptr, ptr %cmd, align 8
  %70 = load ptr, ptr %argv8, align 8
  %71 = load i32, ptr %argc9, align 8
  %call275 = call ptr @getNodeByQuery(ptr noundef nonnull %c.0.i, ptr noundef %69, ptr noundef %70, i32 noundef %71, ptr noundef null, ptr noundef nonnull %error_code) #32
  %call276 = call ptr @getMyClusterNode() #32
  %cmp277.not = icmp eq ptr %call275, %call276
  br i1 %cmp277.not, label %if.end317, label %if.then279

if.then279:                                       ; preds = %if.then264
  %72 = load i32, ptr %error_code, align 4
  switch i32 %72, label %if.else304 [
    i32 7, label %if.then283
    i32 5, label %if.then295
  ]

if.then283:                                       ; preds = %if.then279
  br i1 %tobool52.not, label %if.end311, label %if.then285

if.then285:                                       ; preds = %if.then283
  %call286 = call ptr @sdsempty() #32
  %73 = load ptr, ptr %cmd, align 8
  %fullname288 = getelementptr inbounds %struct.redisCommand, ptr %73, i64 0, i32 27
  %74 = load ptr, ptr %fullname288, align 8
  %call289 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call286, ptr noundef nonnull @.str.50, ptr noundef %74) #32
  br label %if.end311

if.then295:                                       ; preds = %if.then279
  br i1 %tobool52.not, label %if.end311, label %if.then297

if.then297:                                       ; preds = %if.then295
  %call298 = call ptr @sdsempty() #32
  %75 = load ptr, ptr %cmd, align 8
  %fullname300 = getelementptr inbounds %struct.redisCommand, ptr %75, i64 0, i32 27
  %76 = load ptr, ptr %fullname300, align 8
  %call301 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call298, ptr noundef nonnull @.str.51, ptr noundef %76) #32
  br label %if.end311

if.else304:                                       ; preds = %if.then279
  br i1 %tobool52.not, label %if.end311, label %if.then306

if.then306:                                       ; preds = %if.else304
  %call307 = call ptr @sdsnew(ptr noundef nonnull @.str.52) #32
  br label %if.end311

if.end311:                                        ; preds = %if.else304, %if.then306, %if.then295, %if.then297, %if.then283, %if.then285
  %.sink141 = phi i32 [ 30, %if.then285 ], [ 30, %if.then283 ], [ 100, %if.then297 ], [ 100, %if.then295 ], [ 1, %if.then306 ], [ 1, %if.else304 ]
  %msg280.3 = phi ptr [ %call289, %if.then285 ], [ null, %if.then283 ], [ %call301, %if.then297 ], [ null, %if.then295 ], [ %call307, %if.then306 ], [ null, %if.else304 ]
  %call303 = tail call ptr @__errno_location() #37
  store i32 %.sink141, ptr %call303, align 4
  %tobool312.not = icmp eq ptr %msg280.3, null
  br i1 %tobool312.not, label %if.end400, label %if.then313

if.then313:                                       ; preds = %if.end311
  %call314 = call ptr @callReplyCreateError(ptr noundef nonnull %msg280.3, ptr noundef nonnull %ctx) #32
  br label %cleanup

if.end317:                                        ; preds = %if.then264, %land.lhs.true260, %if.end258
  %77 = load i32, ptr %flags, align 4
  %and318 = and i32 %77, 1024
  %tobool319.not = icmp eq i32 %and318, 0
  br i1 %tobool319.not, label %if.end321, label %if.end400

if.end321:                                        ; preds = %if.end317
  %78 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 249), align 8
  %tobool322 = icmp ne i32 %and, 0
  %tobool324 = icmp ne i32 %78, 0
  %79 = select i1 %tobool322, i1 %tobool324, i1 false
  %land.ext326 = zext i1 %79 to i32
  store i32 %land.ext326, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 249), align 8
  br i1 %tobool322, label %if.then328, label %if.end339

if.then328:                                       ; preds = %if.end321
  %and329 = and i32 %77, 2
  %tobool330.not = icmp eq i32 %and329, 0
  %spec.select = select i1 %tobool330.not, i32 9, i32 8
  %and334 = lshr i32 %77, 1
  %80 = and i32 %and334, 2
  %81 = or disjoint i32 %spec.select, %80
  %spec.select130 = xor i32 %81, 2
  br label %if.end339

if.end339:                                        ; preds = %if.then328, %if.end321
  %call_flags.1 = phi i32 [ 8, %if.end321 ], [ %spec.select130, %if.then328 ]
  call void @call(ptr noundef nonnull %c.0.i, i32 noundef %call_flags.1) #32
  store i32 %78, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 249), align 8
  %flags340 = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 1
  %82 = load i64, ptr %flags340, align 8
  %and341 = and i64 %82, 16
  %tobool342.not = icmp eq i64 %and341, 0
  br i1 %tobool342.not, label %if.else388, label %if.then343

if.then343:                                       ; preds = %if.end339
  %83 = load i32, ptr %flags, align 4
  %and344 = and i32 %83, 2048
  %tobool345.not = icmp eq i32 %and344, 0
  br i1 %tobool345.not, label %cond.false350, label %cond.end351

cond.false350:                                    ; preds = %if.then343
  call void @_serverAssert(ptr noundef nonnull @.str.53, ptr noundef nonnull @.str.2, i32 noundef 6520) #32
  call void @abort() #35
  unreachable

cond.end351:                                      ; preds = %if.then343
  %84 = load ptr, ptr %module, align 8
  %tobool353.not = icmp eq ptr %84, null
  br i1 %tobool353.not, label %cond.false361, label %cond.end362

cond.false361:                                    ; preds = %cond.end351
  call void @_serverAssert(ptr noundef nonnull @.str.54, ptr noundef nonnull @.str.2, i32 noundef 6521) #32
  call void @abort() #35
  unreachable

cond.end362:                                      ; preds = %cond.end351
  %call363 = call noalias dereferenceable_or_null(48) ptr @zmalloc(i64 noundef 48) #33
  %85 = load ptr, ptr %module, align 8
  %flags368 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %86 = load i32, ptr %flags368, align 8
  %and369 = and i32 %86, 1
  %tobool370.not = icmp eq i32 %and369, 0
  %cond374 = select i1 %tobool370.not, ptr null, ptr %ctx
  store i64 2, ptr %call363, align 8
  %.compoundliteral.sroa.2.0..sroa_idx = getelementptr inbounds i8, ptr %call363, i64 8
  store ptr null, ptr %.compoundliteral.sroa.2.0..sroa_idx, align 8
  %.compoundliteral.sroa.3.0..sroa_idx = getelementptr inbounds i8, ptr %call363, i64 16
  store ptr %85, ptr %.compoundliteral.sroa.3.0..sroa_idx, align 8
  %.compoundliteral.sroa.4.0..sroa_idx = getelementptr inbounds i8, ptr %call363, i64 24
  store ptr null, ptr %.compoundliteral.sroa.4.0..sroa_idx, align 8
  %.compoundliteral.sroa.5.0..sroa_idx = getelementptr inbounds i8, ptr %call363, i64 32
  store ptr %c.0.i, ptr %.compoundliteral.sroa.5.0..sroa_idx, align 8
  %.compoundliteral.sroa.6.0..sroa_idx = getelementptr inbounds i8, ptr %call363, i64 40
  store ptr %cond374, ptr %.compoundliteral.sroa.6.0..sroa_idx, align 8
  %call375 = call ptr @callReplyCreatePromise(ptr noundef nonnull %call363) #32
  %async_rm_call_handle = getelementptr inbounds %struct.client, ptr %c.0.i, i64 0, i32 55, i32 8
  store ptr %call363, ptr %async_rm_call_handle, align 8
  %and376 = and i32 %call_flags.1, 1
  %tobool377.not = icmp eq i32 %and376, 0
  br i1 %tobool377.not, label %if.then378, label %if.end381

if.then378:                                       ; preds = %cond.end362
  %87 = load i64, ptr %flags340, align 8
  %or380 = or i64 %87, 281474976710656
  store i64 %or380, ptr %flags340, align 8
  br label %if.end381

if.end381:                                        ; preds = %if.then378, %cond.end362
  %and382 = and i32 %call_flags.1, 2
  %tobool383.not = icmp eq i32 %and382, 0
  br i1 %tobool383.not, label %if.then384, label %cleanup

if.then384:                                       ; preds = %if.end381
  %88 = load i64, ptr %flags340, align 8
  %or386 = or i64 %88, 562949953421312
  store i64 %or386, ptr %flags340, align 8
  br label %cleanup

if.else388:                                       ; preds = %if.end339
  %flags389 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %89 = load i32, ptr %flags389, align 8
  %and390 = and i32 %89, 1
  %tobool391.not = icmp eq i32 %and390, 0
  %cond395 = select i1 %tobool391.not, ptr null, ptr %ctx
  %call396 = call fastcc ptr @moduleParseReply(ptr noundef nonnull %c.0.i, ptr noundef %cond395)
  br label %cleanup

cleanup:                                          ; preds = %if.end381, %if.then384, %if.else388, %if.then313, %if.then210, %if.then189, %if.then175, %if.then157, %if.then136, %if.then117, %if.then89, %if.then76, %if.then62, %if.then39, %if.end255
  %reply.1 = phi ptr [ %call94, %if.then89 ], [ %call120, %if.then117 ], [ %call142, %if.then136 ], [ %reply.0, %if.end255 ], [ %call396, %if.else388 ], [ %call314, %if.then313 ], [ %call214, %if.then210 ], [ %call193, %if.then189 ], [ %call178, %if.then175 ], [ %call161, %if.then157 ], [ %call77, %if.then76 ], [ %call63, %if.then62 ], [ %call41, %if.then39 ], [ %call375, %if.then384 ], [ %call375, %if.end381 ]
  %c.0 = phi ptr [ %c.0.i, %if.then89 ], [ %c.0.i, %if.then117 ], [ %c.0.i, %if.then136 ], [ %c.0.i, %if.end255 ], [ %c.0.i, %if.else388 ], [ %c.0.i, %if.then313 ], [ %c.0.i, %if.then210 ], [ %c.0.i, %if.then189 ], [ %c.0.i, %if.then175 ], [ %c.0.i, %if.then157 ], [ %c.0.i, %if.then76 ], [ %c.0.i, %if.then62 ], [ %c.0.i, %if.then39 ], [ null, %if.then384 ], [ null, %if.end381 ]
  %tobool398.not = icmp eq ptr %reply.1, null
  br i1 %tobool398.not, label %if.end400, label %if.then399

if.then399:                                       ; preds = %cleanup
  %flags.i131 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %90 = load i32, ptr %flags.i131, align 8
  %and.i = and i32 %90, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end400, label %if.end.i

if.end.i:                                         ; preds = %if.then399
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %91 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %92 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %91, %92
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %91, 1
  %cmp4.i = icmp slt i32 %91, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %93 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i132 = call ptr @zrealloc(ptr noundef %93, i64 noundef %mul9.i) #34
  store ptr %call.i132, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %94 = phi i32 [ %91, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %95 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i132, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %94 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %95, i64 %idxprom.i, i32 1
  store i32 2, ptr %type14.i, align 8
  %96 = load ptr, ptr %amqueue12.i, align 8
  %97 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %97 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %96, i64 %idxprom17.i
  store ptr %reply.1, ptr %arrayidx18.i, align 8
  %98 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %98, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %if.end400

if.end400:                                        ; preds = %if.then36, %if.then59, %if.then73, %if.then154, %if.then172, %if.then186, %if.then207, %if.end311, %if.end317, %if.then133, %if.then114, %if.then86, %if.then46, %if.end11.i, %if.then399, %cleanup
  %c.0137 = phi ptr [ %c.0, %cleanup ], [ %c.0, %if.then399 ], [ %c.0, %if.end11.i ], [ %c.0.i, %if.then46 ], [ %c.0.i, %if.then86 ], [ %c.0.i, %if.then114 ], [ %c.0.i, %if.then133 ], [ %c.0.i, %if.end317 ], [ %c.0.i, %if.end311 ], [ %c.0.i, %if.then207 ], [ %c.0.i, %if.then186 ], [ %c.0.i, %if.then172 ], [ %c.0.i, %if.then154 ], [ %c.0.i, %if.then73 ], [ %c.0.i, %if.then59 ], [ %c.0.i, %if.then36 ]
  %reply.1136 = phi ptr [ null, %cleanup ], [ %reply.1, %if.then399 ], [ %reply.1, %if.end11.i ], [ null, %if.then46 ], [ null, %if.then86 ], [ null, %if.then114 ], [ null, %if.then133 ], [ null, %if.end317 ], [ null, %if.end311 ], [ null, %if.then207 ], [ null, %if.then186 ], [ null, %if.then172 ], [ null, %if.then154 ], [ null, %if.then73 ], [ null, %if.then59 ], [ null, %if.then36 ]
  %99 = load ptr, ptr %module, align 8
  %tobool402.not = icmp eq ptr %99, null
  br i1 %tobool402.not, label %if.end406, label %if.then403

if.then403:                                       ; preds = %if.end400
  %in_call405 = getelementptr inbounds %struct.RedisModule, ptr %99, i64 0, i32 10
  %100 = load i32, ptr %in_call405, align 4
  %dec = add nsw i32 %100, -1
  store i32 %dec, ptr %in_call405, align 4
  br label %if.end406

if.end406:                                        ; preds = %if.then403, %if.end400
  %tobool407.not = icmp eq ptr %c.0137, null
  br i1 %tobool407.not, label %if.end409, label %if.then408

if.then408:                                       ; preds = %if.end406
  call void @moduleReleaseTempClient(ptr noundef nonnull %c.0137)
  br label %if.end409

if.end409:                                        ; preds = %if.then408, %if.end406
  ret ptr %reply.1136
}

declare ptr @callReplyCreateError(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleCallCommandFilters(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %filter = alloca %struct.RedisModuleCommandFilterCtx, align 8
  %0 = load ptr, ptr @moduleCommandFilters, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @listRewind(ptr noundef nonnull %0, ptr noundef nonnull %li) #32
  %argv1 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %2 = load ptr, ptr %argv1, align 8
  store ptr %2, ptr %filter, align 8
  %argv_len = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i64 0, i32 1
  %argv_len2 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 13
  %3 = load i32, ptr %argv_len2, align 8
  store i32 %3, ptr %argv_len, align 8
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i64 0, i32 2
  %argc3 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %4 = load i32, ptr %argc3, align 8
  store i32 %4, ptr %argc, align 4
  %c4 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i64 0, i32 3
  store ptr %c, ptr %c4, align 8
  %call9 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not10 = icmp eq ptr %call9, null
  br i1 %tobool.not10, label %while.end, label %while.body

while.body:                                       ; preds = %if.end, %while.cond.backedge
  %call11 = phi ptr [ %call, %while.cond.backedge ], [ %call9, %if.end ]
  %value = getelementptr inbounds %struct.listNode, ptr %call11, i64 0, i32 2
  %5 = load ptr, ptr %value, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %5, i64 0, i32 2
  %6 = load i32, ptr %flags, align 8
  %and = and i32 %6, 1
  %tobool5.not = icmp eq i32 %and, 0
  br i1 %tobool5.not, label %if.end8, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body
  %7 = load ptr, ptr %5, align 8
  %in_call = getelementptr inbounds %struct.RedisModule, ptr %7, i64 0, i32 10
  %8 = load i32, ptr %in_call, align 4
  %tobool6.not = icmp eq i32 %8, 0
  br i1 %tobool6.not, label %if.end8, label %while.cond.backedge

if.end8:                                          ; preds = %land.lhs.true, %while.body
  %callback = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %5, i64 0, i32 1
  %9 = load ptr, ptr %callback, align 8
  call void %9(ptr noundef nonnull %filter) #32
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.end8, %land.lhs.true
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end.loopexit, label %while.body, !llvm.loop !35

while.end.loopexit:                               ; preds = %while.cond.backedge
  %.pre = load ptr, ptr %filter, align 8
  %.pre12 = load i32, ptr %argv_len, align 8
  %.pre13 = load i32, ptr %argc, align 4
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %if.end
  %10 = phi i32 [ %.pre13, %while.end.loopexit ], [ %4, %if.end ]
  %11 = phi i32 [ %.pre12, %while.end.loopexit ], [ %3, %if.end ]
  %12 = phi ptr [ %.pre, %while.end.loopexit ], [ %2, %if.end ]
  store ptr %12, ptr %argv1, align 8
  store i32 %11, ptr %argv_len2, align 8
  store i32 %10, ptr %argc3, align 8
  br label %return

return:                                           ; preds = %entry, %while.end
  ret void
}

declare ptr @lookupCommand(ptr noundef, i32 noundef) local_unnamed_addr #1

declare i32 @commandCheckExistence(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @commandCheckArity(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i64 @getCommandFlags(ptr noundef) local_unnamed_addr #1

declare ptr @sdscatfmt(ptr noundef, ptr noundef, ...) local_unnamed_addr #1

declare i32 @checkGoodReplicasStatus() local_unnamed_addr #1

declare i32 @writeCommandsDeniedByDiskError() local_unnamed_addr #1

declare i32 @mustObeyClient(ptr noundef) local_unnamed_addr #1

declare ptr @writeCommandsGetDiskErrorMessage(i32 noundef) local_unnamed_addr #1

declare i32 @ACLCheckAllUserCommandPerm(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

declare void @addACLLogEntry(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @getAclErrorMessage(i32 noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

declare ptr @getNodeByQuery(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @getMyClusterNode() local_unnamed_addr #1

declare void @call(ptr noundef, i32 noundef) local_unnamed_addr #1

declare ptr @callReplyCreatePromise(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyProto(ptr noundef %reply, ptr noundef %len) #0 {
entry:
  %call = tail call ptr @callReplyGetProto(ptr noundef %reply, ptr noundef %len) #32
  ret ptr %call
}

; Function Attrs: nofree nounwind memory(read, inaccessiblemem: none) uwtable
define dso_local i64 @moduleTypeEncodeId(ptr nocapture noundef readonly %name, i32 noundef %encver) local_unnamed_addr #24 {
entry:
  %0 = load ptr, ptr @ModuleTypeNameCharSet, align 8
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %name) #36
  %cmp.not = icmp ne i64 %call, 9
  %or.cond = icmp ugt i32 %encver, 1023
  %or.cond10 = or i1 %or.cond, %cmp.not
  br i1 %or.cond10, label %return, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %sub.ptr.rhs.cast = ptrtoint ptr %0 to i64
  br label %for.body

for.body:                                         ; preds = %for.cond.preheader, %if.end8
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %if.end8 ]
  %id.013 = phi i64 [ 0, %for.cond.preheader ], [ %or, %if.end8 ]
  %arrayidx = getelementptr inbounds i8, ptr %name, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %1 to i32
  %call6 = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %0, i32 noundef %conv) #36
  %tobool.not = icmp eq ptr %call6, null
  br i1 %tobool.not, label %return, label %if.end8

if.end8:                                          ; preds = %for.body
  %sub.ptr.lhs.cast = ptrtoint ptr %call6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %shl = shl i64 %id.013, 6
  %or = or i64 %sub.ptr.sub, %shl
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 9
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !36

for.end:                                          ; preds = %if.end8
  %shl9 = shl i64 %or, 10
  %conv10 = zext nneg i32 %encver to i64
  %or11 = add nuw nsw i64 %shl9, %conv10
  br label %return

return:                                           ; preds = %for.body, %entry, %for.end
  %retval.0 = phi i64 [ %or11, %for.end ], [ 0, %entry ], [ 0, %for.body ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strchr(ptr noundef, i32 noundef) local_unnamed_addr #8

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeLookupModuleByNameInternal(ptr nocapture noundef readonly %name, i32 noundef %ignore_case) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %0) #32
  %call111 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not12 = icmp eq ptr %call111, null
  br i1 %cmp.not12, label %return, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %tobool6.not = icmp eq i32 %ignore_case, 0
  br i1 %tobool6.not, label %while.body.us, label %while.body

while.body.us:                                    ; preds = %while.body.lr.ph, %while.cond.loopexit.us
  %call113.us = phi ptr [ %call1.us, %while.cond.loopexit.us ], [ %call111, %while.body.lr.ph ]
  %call2.us = call ptr @dictGetVal(ptr noundef nonnull %call113.us) #32
  %types.us = getelementptr inbounds %struct.RedisModule, ptr %call2.us, i64 0, i32 4
  %1 = load ptr, ptr %types.us, align 8
  call void @listRewind(ptr noundef %1, ptr noundef nonnull %li) #32
  %call47.us = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not8.us = icmp eq ptr %call47.us, null
  br i1 %tobool.not8.us, label %while.cond.loopexit.us, label %while.body5.us.us

while.cond.loopexit.us:                           ; preds = %if.end.us.us, %while.body.us
  %call1.us = call ptr @dictNext(ptr noundef %call) #32
  %cmp.not.us = icmp eq ptr %call1.us, null
  br i1 %cmp.not.us, label %return, label %while.body.us, !llvm.loop !37

while.body5.us.us:                                ; preds = %while.body.us, %if.end.us.us
  %call49.us.us = phi ptr [ %call4.us.us, %if.end.us.us ], [ %call47.us, %while.body.us ]
  %value.us.us = getelementptr inbounds %struct.listNode, ptr %call49.us.us, i64 0, i32 2
  %2 = load ptr, ptr %value.us.us, align 8
  %name7.us.us = getelementptr inbounds %struct.RedisModuleType, ptr %2, i64 0, i32 20
  %bcmp.us.us = call i32 @bcmp(ptr noundef nonnull dereferenceable(10) %name, ptr noundef nonnull dereferenceable(10) %name7.us.us, i64 10)
  %cmp9.us.us = icmp eq i32 %bcmp.us.us, 0
  br i1 %cmp9.us.us, label %return, label %if.end.us.us

if.end.us.us:                                     ; preds = %while.body5.us.us
  %call4.us.us = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not.us.us = icmp eq ptr %call4.us.us, null
  br i1 %tobool.not.us.us, label %while.cond.loopexit.us, label %while.body5.us.us, !llvm.loop !38

while.cond.loopexit:                              ; preds = %if.end, %while.body
  %call1 = call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %return, label %while.body, !llvm.loop !37

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.loopexit
  %call113 = phi ptr [ %call1, %while.cond.loopexit ], [ %call111, %while.body.lr.ph ]
  %call2 = call ptr @dictGetVal(ptr noundef nonnull %call113) #32
  %types = getelementptr inbounds %struct.RedisModule, ptr %call2, i64 0, i32 4
  %3 = load ptr, ptr %types, align 8
  call void @listRewind(ptr noundef %3, ptr noundef nonnull %li) #32
  %call47 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not8 = icmp eq ptr %call47, null
  br i1 %tobool.not8, label %while.cond.loopexit, label %while.body5

while.body5:                                      ; preds = %while.body, %if.end
  %call49 = phi ptr [ %call4, %if.end ], [ %call47, %while.body ]
  %value = getelementptr inbounds %struct.listNode, ptr %call49, i64 0, i32 2
  %4 = load ptr, ptr %value, align 8
  %name12 = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 20
  %call14 = call i32 @strcasecmp(ptr noundef %name, ptr noundef nonnull %name12) #36
  %tobool15.not = icmp eq i32 %call14, 0
  br i1 %tobool15.not, label %return, label %if.end

if.end:                                           ; preds = %while.body5
  %call4 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call4, null
  br i1 %tobool.not, label %while.cond.loopexit, label %while.body5, !llvm.loop !38

return:                                           ; preds = %while.cond.loopexit, %while.body5, %while.cond.loopexit.us, %while.body5.us.us, %entry
  %retval.0 = phi ptr [ null, %entry ], [ %2, %while.body5.us.us ], [ null, %while.cond.loopexit.us ], [ %4, %while.body5 ], [ null, %while.cond.loopexit ]
  call void @dictReleaseIterator(ptr noundef %call) #32
  ret ptr %retval.0
}

declare ptr @dictGetIterator(ptr noundef) local_unnamed_addr #1

declare ptr @dictNext(ptr noundef) local_unnamed_addr #1

declare void @listRewind(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @listNext(ptr noundef) local_unnamed_addr #1

declare void @dictReleaseIterator(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeLookupModuleByName(ptr nocapture noundef readonly %name) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @moduleTypeLookupModuleByNameInternal(ptr noundef %name, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeLookupModuleByNameIgnoreCase(ptr nocapture noundef readonly %name) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @moduleTypeLookupModuleByNameInternal(ptr noundef %name, i32 noundef 1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeLookupModuleByID(i64 noundef %id) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load ptr, ptr getelementptr inbounds ([3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 0, i32 1), align 8
  %cmp1.not28 = icmp eq ptr %0, null
  br i1 %cmp1.not28, label %for.end, label %for.body

land.rhs:                                         ; preds = %for.inc
  %mt = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %indvars.iv.next, i32 1
  %1 = load ptr, ptr %mt, align 8
  %cmp1.not = icmp eq ptr %1, null
  br i1 %cmp1.not, label %land.rhs.for.end_crit_edge, label %for.body, !llvm.loop !39

for.body:                                         ; preds = %entry, %land.rhs
  %2 = phi ptr [ %1, %land.rhs ], [ %0, %entry ]
  %indvars.iv29 = phi i64 [ %indvars.iv.next, %land.rhs ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %indvars.iv29
  %3 = load i64, ptr %arrayidx, align 16
  %cmp5 = icmp eq i64 %3, %id
  br i1 %cmp5, label %return, label %for.inc

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv29, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 3
  br i1 %exitcond.not, label %for.end.loopexit, label %land.rhs, !llvm.loop !39

land.rhs.for.end_crit_edge:                       ; preds = %land.rhs
  %cmp.le = icmp ult i64 %indvars.iv29, 2
  %4 = and i64 %indvars.iv.next, 4294967295
  br label %for.end

for.end.loopexit:                                 ; preds = %for.inc
  %cmp.le43 = icmp ult i64 %indvars.iv29, 2
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %land.rhs.for.end_crit_edge, %entry
  %j.0.lcssa = phi i64 [ %4, %land.rhs.for.end_crit_edge ], [ 0, %entry ], [ 3, %for.end.loopexit ]
  %cmp.lcssa = phi i1 [ %cmp.le, %land.rhs.for.end_crit_edge ], [ true, %entry ], [ %cmp.le43, %for.end.loopexit ]
  %5 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %5) #32
  %call1019 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp1120.not = icmp eq ptr %call1019, null
  br i1 %cmp1120.not, label %while.end24.thread, label %while.body

while.end24.thread:                               ; preds = %for.end
  tail call void @dictReleaseIterator(ptr noundef %call) #32
  br label %return

while.body:                                       ; preds = %for.end, %while.end
  %call1021 = phi ptr [ %call10, %while.end ], [ %call1019, %for.end ]
  %call15 = call ptr @dictGetVal(ptr noundef nonnull %call1021) #32
  %types = getelementptr inbounds %struct.RedisModule, ptr %call15, i64 0, i32 4
  %6 = load ptr, ptr %types, align 8
  call void @listRewind(ptr noundef %6, ptr noundef nonnull %li) #32
  br label %while.cond16

while.cond16:                                     ; preds = %while.body18, %while.body
  %call17 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call17, null
  br i1 %tobool.not, label %while.end, label %while.body18

while.body18:                                     ; preds = %while.cond16
  %value = getelementptr inbounds %struct.listNode, ptr %call17, i64 0, i32 2
  %7 = load ptr, ptr %value, align 8
  %8 = load i64, ptr %7, align 8
  %cmp21.unshifted = xor i64 %8, %id
  %cmp21 = icmp ult i64 %cmp21.unshifted, 1024
  br i1 %cmp21, label %while.end, label %while.cond16, !llvm.loop !40

while.end:                                        ; preds = %while.body18, %while.cond16
  %mt9.1 = phi ptr [ null, %while.cond16 ], [ %7, %while.body18 ]
  %call10 = call ptr @dictNext(ptr noundef %call) #32
  %cmp11 = icmp ne ptr %call10, null
  %cmp13 = icmp eq ptr %mt9.1, null
  %9 = and i1 %cmp13, %cmp11
  br i1 %9, label %while.body, label %while.end24, !llvm.loop !41

while.end24:                                      ; preds = %while.end
  call void @dictReleaseIterator(ptr noundef %call) #32
  %tobool25 = icmp ne ptr %mt9.1, null
  %or.cond = and i1 %cmp.lcssa, %tobool25
  br i1 %or.cond, label %if.then27, label %return

if.then27:                                        ; preds = %while.end24
  %arrayidx29 = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %j.0.lcssa
  store i64 %id, ptr %arrayidx29, align 16
  %mt33 = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %j.0.lcssa, i32 1
  store ptr %mt9.1, ptr %mt33, align 8
  br label %return

return:                                           ; preds = %for.body, %while.end24.thread, %while.end24, %if.then27
  %retval.0 = phi ptr [ %mt9.1, %if.then27 ], [ %mt9.1, %while.end24 ], [ null, %while.end24.thread ], [ %2, %for.body ]
  ret ptr %retval.0
}

; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local void @moduleTypeNameByID(ptr nocapture noundef writeonly %name, i64 noundef %moduleid) local_unnamed_addr #16 {
entry:
  %0 = load ptr, ptr @ModuleTypeNameCharSet, align 8
  %arrayidx = getelementptr inbounds i8, ptr %name, i64 9
  store i8 0, ptr %arrayidx, align 1
  %add.ptr = getelementptr inbounds i8, ptr %name, i64 8
  %shr = lshr i64 %moduleid, 10
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %j.07 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %p.06 = phi ptr [ %add.ptr, %entry ], [ %incdec.ptr, %for.body ]
  %moduleid.addr.05 = phi i64 [ %shr, %entry ], [ %shr2, %for.body ]
  %and = and i64 %moduleid.addr.05, 63
  %arrayidx1 = getelementptr inbounds i8, ptr %0, i64 %and
  %1 = load i8, ptr %arrayidx1, align 1
  %incdec.ptr = getelementptr inbounds i8, ptr %p.06, i64 -1
  store i8 %1, ptr %p.06, align 1
  %shr2 = lshr i64 %moduleid.addr.05, 6
  %inc = add nuw nsw i32 %j.07, 1
  %exitcond.not = icmp eq i32 %inc, 9
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !42

for.end:                                          ; preds = %for.body
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @moduleTypeModuleName(ptr noundef readonly %mt) local_unnamed_addr #11 {
entry:
  %tobool.not = icmp eq ptr %mt, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %module = getelementptr inbounds %struct.RedisModuleType, ptr %mt, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %name = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %name, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi ptr [ %1, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleNameFromCommand(ptr nocapture noundef readonly %cmd) local_unnamed_addr #0 {
entry:
  %proc = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 12
  %0 = load ptr, ptr %proc, align 8
  %cmp = icmp eq ptr %0, @RedisModuleCommandDispatcher
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.56, ptr noundef nonnull @.str.2, i32 noundef 6724) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 32
  %1 = load ptr, ptr %module_cmd, align 8
  %2 = load ptr, ptr %1, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %2, i64 0, i32 1
  %3 = load ptr, ptr %name, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeDupOrReply(ptr noundef %c, ptr noundef %fromkey, ptr noundef %tokey, i32 noundef %todb, ptr nocapture noundef readonly %value) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleKeyOptCtx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %value, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %1 = load ptr, ptr %0, align 8
  %copy = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 10
  %2 = load ptr, ptr %copy, align 8
  %tobool.not = icmp eq ptr %2, null
  %copy2 = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 17
  %3 = load ptr, ptr %copy2, align 8
  %tobool1.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  br i1 %tobool1.not, label %if.then, label %if.then3

if.then:                                          ; preds = %land.lhs.true
  tail call void @addReplyError(ptr noundef %c, ptr noundef nonnull @.str.57) #32
  br label %return

if.end:                                           ; preds = %entry
  br i1 %tobool1.not, label %if.else, label %if.then3

if.then3:                                         ; preds = %land.lhs.true, %if.end
  store ptr %fromkey, ptr %ctx, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 1
  store ptr %tokey, ptr %to_key, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 2
  %db = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 4
  %4 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %4, i64 0, i32 6
  %5 = load i32, ptr %id, align 8
  store i32 %5, ptr %from_dbid, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 3
  store i32 %todb, ptr %to_dbid, align 4
  %value5 = getelementptr inbounds %struct.moduleValue, ptr %0, i64 0, i32 1
  %6 = load ptr, ptr %value5, align 8
  %call = call ptr %3(ptr noundef nonnull %ctx, ptr noundef %6) #32
  br label %if.end9

if.else:                                          ; preds = %if.end
  %value7 = getelementptr inbounds %struct.moduleValue, ptr %0, i64 0, i32 1
  %7 = load ptr, ptr %value7, align 8
  %call8 = tail call ptr %2(ptr noundef %fromkey, ptr noundef %tokey, ptr noundef %7) #32
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then3
  %newval.0 = phi ptr [ %call, %if.then3 ], [ %call8, %if.else ]
  %tobool10.not = icmp eq ptr %newval.0, null
  br i1 %tobool10.not, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  call void @addReplyError(ptr noundef %c, ptr noundef nonnull @.str.58) #32
  br label %return

if.end12:                                         ; preds = %if.end9
  %call13 = call ptr @createModuleObject(ptr noundef nonnull %1, ptr noundef nonnull %newval.0) #32
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then
  %retval.0 = phi ptr [ %call13, %if.end12 ], [ null, %if.then11 ], [ null, %if.then ]
  ret ptr %retval.0
}

declare void @addReplyError(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @createModuleObject(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_CreateDataType(ptr nocapture noundef readonly %ctx, ptr nocapture noundef readonly %name, i32 noundef %encver, ptr nocapture noundef readonly %typemethods_ptr) #0 {
entry:
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 18
  %1 = load i32, ptr %onload, align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr @ModuleTypeNameCharSet, align 8
  %call.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %name) #36
  %cmp.not.i = icmp ne i64 %call.i, 9
  %or.cond.i = icmp ugt i32 %encver, 1023
  %or.cond10.i = or i1 %or.cond.i, %cmp.not.i
  br i1 %or.cond10.i, label %return, label %for.cond.preheader.i

for.cond.preheader.i:                             ; preds = %if.end
  %sub.ptr.rhs.cast.i = ptrtoint ptr %2 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %if.end8.i, %for.cond.preheader.i
  %indvars.iv.i = phi i64 [ 0, %for.cond.preheader.i ], [ %indvars.iv.next.i, %if.end8.i ]
  %id.013.i = phi i64 [ 0, %for.cond.preheader.i ], [ %or.i, %if.end8.i ]
  %arrayidx.i = getelementptr inbounds i8, ptr %name, i64 %indvars.iv.i
  %3 = load i8, ptr %arrayidx.i, align 1
  %conv.i = sext i8 %3 to i32
  %call6.i = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %2, i32 noundef %conv.i) #36
  %tobool.not.i = icmp eq ptr %call6.i, null
  br i1 %tobool.not.i, label %return, label %if.end8.i

if.end8.i:                                        ; preds = %for.body.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %call6.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %shl.i = shl i64 %id.013.i, 6
  %or.i = or i64 %sub.ptr.sub.i, %shl.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 9
  br i1 %exitcond.not.i, label %moduleTypeEncodeId.exit, label %for.body.i, !llvm.loop !36

moduleTypeEncodeId.exit:                          ; preds = %if.end8.i
  %shl9.i = shl i64 %or.i, 10
  %conv10.i = zext nneg i32 %encver to i64
  %or11.i = add nuw nsw i64 %shl9.i, %conv10.i
  %cmp = icmp eq i64 %or11.i, 0
  br i1 %cmp, label %return, label %if.end2

if.end2:                                          ; preds = %moduleTypeEncodeId.exit
  %call.i50 = tail call ptr @moduleTypeLookupModuleByNameInternal(ptr noundef nonnull %name, i32 noundef 0)
  %cmp4.not = icmp eq ptr %call.i50, null
  br i1 %cmp4.not, label %if.end6, label %return

if.end6:                                          ; preds = %if.end2
  %4 = load i64, ptr %typemethods_ptr, align 8
  %cmp7 = icmp eq i64 %4, 0
  br i1 %cmp7, label %return, label %if.end9

if.end9:                                          ; preds = %if.end6
  %call10 = tail call noalias dereferenceable_or_null(168) ptr @zcalloc(i64 noundef 168) #33
  store i64 %or11.i, ptr %call10, align 8
  %5 = load ptr, ptr %module, align 8
  %module13 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 1
  store ptr %5, ptr %module13, align 8
  %rdb_load = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 1
  %rdb_load14 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 2
  %6 = load <2 x ptr>, ptr %rdb_load, align 8
  store <2 x ptr> %6, ptr %rdb_load14, align 8
  %aof_rewrite = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 3
  %aof_rewrite16 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 4
  %7 = load <2 x ptr>, ptr %aof_rewrite, align 8
  store <2 x ptr> %7, ptr %aof_rewrite16, align 8
  %digest = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 5
  %digest18 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 6
  %8 = load <2 x ptr>, ptr %digest, align 8
  store <2 x ptr> %8, ptr %digest18, align 8
  %9 = load i64, ptr %typemethods_ptr, align 8
  %cmp20 = icmp ugt i64 %9, 1
  br i1 %cmp20, label %if.end27, label %if.end54

if.end27:                                         ; preds = %if.end9
  %v2 = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 7
  %aux_load22 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 12
  %10 = load <2 x ptr>, ptr %v2, align 8
  store <2 x ptr> %10, ptr %aux_load22, align 8
  %aux_save_triggers = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 7, i32 2
  %11 = load i32, ptr %aux_save_triggers, align 8
  %aux_save_triggers26 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 19
  store i32 %11, ptr %aux_save_triggers26, align 8
  %cmp29.not = icmp eq i64 %9, 2
  br i1 %cmp29.not, label %if.end54, label %if.end38

if.end38:                                         ; preds = %if.end27
  %v3 = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 8
  %free_effort31 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 8
  %12 = load <2 x ptr>, ptr %v3, align 8
  store <2 x ptr> %12, ptr %free_effort31, align 8
  %copy = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 8, i32 2
  %copy35 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 10
  %13 = load <2 x ptr>, ptr %copy, align 8
  store <2 x ptr> %13, ptr %copy35, align 8
  %cmp40 = icmp ugt i64 %9, 3
  br i1 %cmp40, label %if.end49, label %if.end54

if.end49:                                         ; preds = %if.end38
  %v4 = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 9
  %mem_usage242 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 14
  %unlink2 = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 9, i32 2
  %unlink244 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 16
  %14 = load <2 x ptr>, ptr %v4, align 8
  store <2 x ptr> %14, ptr %mem_usage242, align 8
  %15 = load <2 x ptr>, ptr %unlink2, align 8
  store <2 x ptr> %15, ptr %unlink244, align 8
  %cmp51.not = icmp eq i64 %9, 4
  br i1 %cmp51.not, label %if.end54, label %if.then52

if.then52:                                        ; preds = %if.end49
  %v5 = getelementptr inbounds %struct.typemethods, ptr %typemethods_ptr, i64 0, i32 10
  %16 = load ptr, ptr %v5, align 8
  %aux_save253 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 18
  store ptr %16, ptr %aux_save253, align 8
  br label %if.end54

if.end54:                                         ; preds = %if.end9, %if.end27, %if.end38, %if.then52, %if.end49
  %name55 = getelementptr inbounds %struct.RedisModuleType, ptr %call10, i64 0, i32 20
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 4 dereferenceable(10) %name55, ptr noundef nonnull align 1 dereferenceable(10) %name, i64 10, i1 false)
  %types = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 4
  %17 = load ptr, ptr %types, align 8
  %call57 = tail call ptr @listAddNodeTail(ptr noundef %17, ptr noundef nonnull %call10) #32
  br label %return

return:                                           ; preds = %for.body.i, %if.end, %if.end6, %if.end2, %moduleTypeEncodeId.exit, %entry, %if.end54
  %retval.0 = phi ptr [ %call10, %if.end54 ], [ null, %entry ], [ null, %moduleTypeEncodeId.exit ], [ null, %if.end2 ], [ null, %if.end6 ], [ null, %if.end ], [ null, %for.body.i ]
  ret ptr %retval.0
}

declare ptr @listAddNodeTail(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ModuleTypeSetValue(ptr nocapture noundef %key, ptr noundef %mt, ptr noundef %value) #0 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end.i, label %return

if.end.i:                                         ; preds = %lor.lhs.false
  %value.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %2 = load ptr, ptr %value.i, align 8
  %tobool1.not.i = icmp eq ptr %2, null
  br i1 %tobool1.not.i, label %RM_DeleteKey.exit, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %db.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %3 = load ptr, ptr %db.i, align 8
  %key3.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %4 = load ptr, ptr %key3.i, align 8
  %call.i = tail call i32 @dbDelete(ptr noundef %3, ptr noundef %4) #32
  store ptr null, ptr %value.i, align 8
  br label %RM_DeleteKey.exit

RM_DeleteKey.exit:                                ; preds = %if.end.i, %if.then2.i
  %call2 = tail call ptr @createModuleObject(ptr noundef %mt, ptr noundef %value) #32
  %5 = load ptr, ptr %key, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %7 = load ptr, ptr %db, align 8
  %key3 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %8 = load ptr, ptr %key3, align 8
  tail call void @setKey(ptr noundef %6, ptr noundef %7, ptr noundef %8, ptr noundef %call2, i32 noundef 2) #32
  tail call void @decrRefCount(ptr noundef %call2) #32
  store ptr %call2, ptr %value.i, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %RM_DeleteKey.exit
  %retval.0 = phi i32 [ 0, %RM_DeleteKey.exit ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @RM_ModuleTypeGetType(ptr noundef readonly %key) #11 {
entry:
  %cmp = icmp eq ptr %key, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %0, null
  br i1 %cmp1, label %return, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false
  %bf.load.i = load i32, ptr %0, align 8
  %bf.clear.i = and i32 %bf.load.i, 15
  %cond = icmp eq i32 %bf.clear.i, 5
  br i1 %cond, label %if.end, label %return

if.end:                                           ; preds = %if.end.i
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %2 = load ptr, ptr %1, align 8
  br label %return

return:                                           ; preds = %if.end.i, %entry, %lor.lhs.false, %if.end
  %retval.0 = phi ptr [ %2, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ], [ null, %if.end.i ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @RM_ModuleTypeGetValue(ptr noundef readonly %key) #11 {
entry:
  %cmp = icmp eq ptr %key, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %0, null
  br i1 %cmp1, label %return, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false
  %bf.load.i = load i32, ptr %0, align 8
  %bf.clear.i = and i32 %bf.load.i, 15
  %cond = icmp eq i32 %bf.clear.i, 5
  br i1 %cond, label %if.end, label %return

if.end:                                           ; preds = %if.end.i
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %value5 = getelementptr inbounds %struct.moduleValue, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %value5, align 8
  br label %return

return:                                           ; preds = %if.end.i, %entry, %lor.lhs.false, %if.end
  %retval.0 = phi ptr [ %2, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ], [ null, %if.end.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleRDBLoadError(ptr nocapture noundef %io) local_unnamed_addr #0 {
entry:
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %0 = load ptr, ptr %type, align 8
  %module = getelementptr inbounds %struct.RedisModuleType, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %options = getelementptr inbounds %struct.RedisModule, ptr %1, i64 0, i32 12
  %2 = load i32, ptr %options, align 4
  %and = and i32 %2, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  store i32 1, ptr %error, align 8
  ret void

if.end:                                           ; preds = %entry
  %name = getelementptr inbounds %struct.RedisModule, ptr %1, i64 0, i32 1
  %3 = load ptr, ptr %name, align 8
  %4 = load i64, ptr %io, align 8
  %key = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  %5 = load ptr, ptr %key, align 8
  %tobool5.not = icmp eq ptr %5, null
  br i1 %tobool5.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.end
  %ptr = getelementptr inbounds %struct.redisObject, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %ptr, align 8
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi ptr [ %6, %cond.true ], [ @.str.60, %if.end ]
  %name4 = getelementptr inbounds %struct.RedisModuleType, ptr %0, i64 0, i32 20
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 7011, ptr noundef nonnull @.str.59, ptr noundef %3, ptr noundef nonnull %name4, i64 noundef %4, ptr noundef %cond) #32
  tail call void @abort() #35
  unreachable
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleAllDatatypesHandleErrors() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %0) #32
  %call14 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not5 = icmp eq ptr %call14, null
  br i1 %cmp.not5, label %return, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call16 = phi ptr [ %call1, %if.end ], [ %call14, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call16) #32
  %types = getelementptr inbounds %struct.RedisModule, ptr %call2, i64 0, i32 4
  %1 = load ptr, ptr %types, align 8
  %len = getelementptr inbounds %struct.list, ptr %1, i64 0, i32 5
  %2 = load i64, ptr %len, align 8
  %tobool.not = icmp eq i64 %2, 0
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body
  %options = getelementptr inbounds %struct.RedisModule, ptr %call2, i64 0, i32 12
  %3 = load i32, ptr %options, align 4
  %and = and i32 %3, 1
  %tobool3.not = icmp eq i32 %and, 0
  br i1 %tobool3.not, label %return, label %if.end

if.end:                                           ; preds = %land.lhs.true, %while.body
  %call1 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %return, label %while.body, !llvm.loop !43

return:                                           ; preds = %if.end, %land.lhs.true, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %land.lhs.true ], [ 1, %if.end ]
  tail call void @dictReleaseIterator(ptr noundef %call) #32
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleAllModulesHandleReplAsyncLoad() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %0) #32
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call1 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %return, label %while.body

while.body:                                       ; preds = %while.cond
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call1) #32
  %options = getelementptr inbounds %struct.RedisModule, ptr %call2, i64 0, i32 12
  %1 = load i32, ptr %options, align 4
  %and = and i32 %1, 4
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %while.cond, !llvm.loop !44

return:                                           ; preds = %while.cond, %while.body
  %retval.0 = phi i32 [ 0, %while.body ], [ 1, %while.cond ]
  tail call void @dictReleaseIterator(ptr noundef %call) #32
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_IsIOError(ptr nocapture noundef readonly %io) #6 {
entry:
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveUnsigned(ptr nocapture noundef %io, i64 noundef %value) #0 {
entry:
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %pre_flush_buffer.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 7
  %1 = load ptr, ptr %pre_flush_buffer.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %if.end2, label %if.end.i

if.end.i:                                         ; preds = %if.end
  store ptr null, ptr %pre_flush_buffer.i, align 8
  %rio.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %2 = load ptr, ptr %rio.i, align 8
  %arrayidx.i.i = getelementptr inbounds i8, ptr %1, i64 -1
  %3 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %3 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %1, i64 -3
  %4 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %4 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end.i
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %1, i64 -5
  %5 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %5 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end.i
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %1, i64 -9
  %6 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %6 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end.i
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %1, i64 -17
  %7 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end.i
  %retval.0.i.i = phi i64 [ %7, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end.i ]
  %call5.i = tail call i64 @rdbWriteRaw(ptr noundef %2, ptr noundef nonnull %1, i64 noundef %retval.0.i.i) #32
  tail call void @sdsfree(ptr noundef nonnull %1) #32
  %cmp.i = icmp sgt i64 %call5.i, -1
  br i1 %cmp.i, label %if.then6.i, label %flushRedisModuleIOBuffer.exit

if.then6.i:                                       ; preds = %sdslen.exit.i
  %8 = load i64, ptr %io, align 8
  %add.i = add i64 %8, %call5.i
  store i64 %add.i, ptr %io, align 8
  br label %flushRedisModuleIOBuffer.exit

flushRedisModuleIOBuffer.exit:                    ; preds = %sdslen.exit.i, %if.then6.i
  %9 = and i64 %call5.i, 4294967295
  %cmp = icmp eq i64 %9, 4294967295
  br i1 %cmp, label %saveerr, label %if.end2

if.end2:                                          ; preds = %if.end, %flushRedisModuleIOBuffer.exit
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %10 = load ptr, ptr %rio, align 8
  %call3 = tail call i32 @rdbSaveLen(ptr noundef %10, i64 noundef 2) #32
  %cmp4 = icmp eq i32 %call3, -1
  br i1 %cmp4, label %saveerr, label %if.end6

if.end6:                                          ; preds = %if.end2
  %conv = sext i32 %call3 to i64
  %11 = load i64, ptr %io, align 8
  %add = add i64 %11, %conv
  store i64 %add, ptr %io, align 8
  %12 = load ptr, ptr %rio, align 8
  %call8 = tail call i32 @rdbSaveLen(ptr noundef %12, i64 noundef %value) #32
  %cmp9 = icmp eq i32 %call8, -1
  br i1 %cmp9, label %saveerr, label %if.end12

if.end12:                                         ; preds = %if.end6
  %conv13 = sext i32 %call8 to i64
  %13 = load i64, ptr %io, align 8
  %add15 = add i64 %13, %conv13
  store i64 %add15, ptr %io, align 8
  br label %return

saveerr:                                          ; preds = %if.end6, %if.end2, %flushRedisModuleIOBuffer.exit
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %entry, %saveerr, %if.end12
  ret void
}

declare i32 @rdbSaveLen(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_LoadUnsigned(ptr nocapture noundef %io) #0 {
entry:
  %value = alloca i64, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %1 = load ptr, ptr %rio, align 8
  %call = tail call i64 @rdbLoadLen(ptr noundef %1, ptr noundef null) #32
  %cmp.not = icmp eq i64 %call, 2
  br i1 %cmp.not, label %if.end2, label %loaderr

if.end2:                                          ; preds = %if.end
  %2 = load ptr, ptr %rio, align 8
  %call5 = call i32 @rdbLoadLenByRef(ptr noundef %2, ptr noundef null, ptr noundef nonnull %value) #32
  %cmp6 = icmp eq i32 %call5, -1
  br i1 %cmp6, label %loaderr, label %if.end8

if.end8:                                          ; preds = %if.end2
  %3 = load i64, ptr %value, align 8
  br label %return

loaderr:                                          ; preds = %if.end2, %if.end
  %type.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %4 = load ptr, ptr %type.i, align 8
  %module.i = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 1
  %5 = load ptr, ptr %module.i, align 8
  %options.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 12
  %6 = load i32, ptr %options.i, align 4
  %and.i = and i32 %6, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %moduleRDBLoadError.exit

if.end.i:                                         ; preds = %loaderr
  %name.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 1
  %7 = load ptr, ptr %name.i, align 8
  %8 = load i64, ptr %io, align 8
  %key.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  %9 = load ptr, ptr %key.i, align 8
  %tobool5.not.i = icmp eq ptr %9, null
  br i1 %tobool5.not.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end.i
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %ptr.i, align 8
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.end.i
  %cond.i = phi ptr [ %10, %cond.true.i ], [ @.str.60, %if.end.i ]
  %name4.i = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 20
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 7011, ptr noundef nonnull @.str.59, ptr noundef %7, ptr noundef nonnull %name4.i, i64 noundef %8, ptr noundef %cond.i) #32
  call void @abort() #35
  unreachable

moduleRDBLoadError.exit:                          ; preds = %loaderr
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %entry, %moduleRDBLoadError.exit, %if.end8
  %retval.0 = phi i64 [ 0, %moduleRDBLoadError.exit ], [ %3, %if.end8 ], [ 0, %entry ]
  ret i64 %retval.0
}

declare i64 @rdbLoadLen(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @rdbLoadLenByRef(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveSigned(ptr nocapture noundef %io, i64 noundef %value) #0 {
entry:
  tail call void @RM_SaveUnsigned(ptr noundef %io, i64 noundef %value)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_LoadSigned(ptr nocapture noundef %io) #0 {
entry:
  %call = tail call i64 @RM_LoadUnsigned(ptr noundef %io)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveString(ptr nocapture noundef %io, ptr noundef %s) #0 {
entry:
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %pre_flush_buffer.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 7
  %1 = load ptr, ptr %pre_flush_buffer.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %if.end2, label %if.end.i

if.end.i:                                         ; preds = %if.end
  store ptr null, ptr %pre_flush_buffer.i, align 8
  %rio.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %2 = load ptr, ptr %rio.i, align 8
  %arrayidx.i.i = getelementptr inbounds i8, ptr %1, i64 -1
  %3 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %3 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %1, i64 -3
  %4 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %4 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end.i
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %1, i64 -5
  %5 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %5 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end.i
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %1, i64 -9
  %6 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %6 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end.i
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %1, i64 -17
  %7 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end.i
  %retval.0.i.i = phi i64 [ %7, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end.i ]
  %call5.i = tail call i64 @rdbWriteRaw(ptr noundef %2, ptr noundef nonnull %1, i64 noundef %retval.0.i.i) #32
  tail call void @sdsfree(ptr noundef nonnull %1) #32
  %cmp.i = icmp sgt i64 %call5.i, -1
  br i1 %cmp.i, label %if.then6.i, label %flushRedisModuleIOBuffer.exit

if.then6.i:                                       ; preds = %sdslen.exit.i
  %8 = load i64, ptr %io, align 8
  %add.i = add i64 %8, %call5.i
  store i64 %add.i, ptr %io, align 8
  br label %flushRedisModuleIOBuffer.exit

flushRedisModuleIOBuffer.exit:                    ; preds = %sdslen.exit.i, %if.then6.i
  %9 = and i64 %call5.i, 4294967295
  %cmp = icmp eq i64 %9, 4294967295
  br i1 %cmp, label %saveerr, label %if.end2

if.end2:                                          ; preds = %if.end, %flushRedisModuleIOBuffer.exit
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %10 = load ptr, ptr %rio, align 8
  %call3 = tail call i32 @rdbSaveLen(ptr noundef %10, i64 noundef 5) #32
  %cmp4 = icmp eq i32 %call3, -1
  br i1 %cmp4, label %saveerr, label %if.end7

if.end7:                                          ; preds = %if.end2
  %conv = sext i32 %call3 to i64
  %11 = load i64, ptr %io, align 8
  %add = add i64 %11, %conv
  store i64 %add, ptr %io, align 8
  %12 = load ptr, ptr %rio, align 8
  %call9 = tail call i64 @rdbSaveStringObject(ptr noundef %12, ptr noundef %s) #32
  %cmp10 = icmp eq i64 %call9, -1
  br i1 %cmp10, label %saveerr, label %if.end13

if.end13:                                         ; preds = %if.end7
  %13 = load i64, ptr %io, align 8
  %add15 = add i64 %13, %call9
  store i64 %add15, ptr %io, align 8
  br label %return

saveerr:                                          ; preds = %if.end7, %if.end2, %flushRedisModuleIOBuffer.exit
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %entry, %saveerr, %if.end13
  ret void
}

declare i64 @rdbSaveStringObject(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveStringBuffer(ptr nocapture noundef %io, ptr noundef %str, i64 noundef %len) #0 {
entry:
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %pre_flush_buffer.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 7
  %1 = load ptr, ptr %pre_flush_buffer.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %if.end2, label %if.end.i

if.end.i:                                         ; preds = %if.end
  store ptr null, ptr %pre_flush_buffer.i, align 8
  %rio.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %2 = load ptr, ptr %rio.i, align 8
  %arrayidx.i.i = getelementptr inbounds i8, ptr %1, i64 -1
  %3 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %3 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %1, i64 -3
  %4 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %4 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end.i
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %1, i64 -5
  %5 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %5 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end.i
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %1, i64 -9
  %6 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %6 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end.i
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %1, i64 -17
  %7 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end.i
  %retval.0.i.i = phi i64 [ %7, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end.i ]
  %call5.i = tail call i64 @rdbWriteRaw(ptr noundef %2, ptr noundef nonnull %1, i64 noundef %retval.0.i.i) #32
  tail call void @sdsfree(ptr noundef nonnull %1) #32
  %cmp.i = icmp sgt i64 %call5.i, -1
  br i1 %cmp.i, label %if.then6.i, label %flushRedisModuleIOBuffer.exit

if.then6.i:                                       ; preds = %sdslen.exit.i
  %8 = load i64, ptr %io, align 8
  %add.i = add i64 %8, %call5.i
  store i64 %add.i, ptr %io, align 8
  br label %flushRedisModuleIOBuffer.exit

flushRedisModuleIOBuffer.exit:                    ; preds = %sdslen.exit.i, %if.then6.i
  %9 = and i64 %call5.i, 4294967295
  %cmp = icmp eq i64 %9, 4294967295
  br i1 %cmp, label %saveerr, label %if.end2

if.end2:                                          ; preds = %if.end, %flushRedisModuleIOBuffer.exit
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %10 = load ptr, ptr %rio, align 8
  %call3 = tail call i32 @rdbSaveLen(ptr noundef %10, i64 noundef 5) #32
  %cmp4 = icmp eq i32 %call3, -1
  br i1 %cmp4, label %saveerr, label %if.end7

if.end7:                                          ; preds = %if.end2
  %conv = sext i32 %call3 to i64
  %11 = load i64, ptr %io, align 8
  %add = add i64 %11, %conv
  store i64 %add, ptr %io, align 8
  %12 = load ptr, ptr %rio, align 8
  %call9 = tail call i64 @rdbSaveRawString(ptr noundef %12, ptr noundef %str, i64 noundef %len) #32
  %cmp10 = icmp eq i64 %call9, -1
  br i1 %cmp10, label %saveerr, label %if.end13

if.end13:                                         ; preds = %if.end7
  %13 = load i64, ptr %io, align 8
  %add15 = add i64 %13, %call9
  store i64 %add15, ptr %io, align 8
  br label %return

saveerr:                                          ; preds = %if.end7, %if.end2, %flushRedisModuleIOBuffer.exit
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %entry, %saveerr, %if.end13
  ret void
}

declare i64 @rdbSaveRawString(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleLoadString(ptr nocapture noundef %io, i32 noundef %plain, ptr noundef %lenptr) local_unnamed_addr #0 {
entry:
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %1 = load ptr, ptr %rio, align 8
  %call = tail call i64 @rdbLoadLen(ptr noundef %1, ptr noundef null) #32
  %cmp.not = icmp eq i64 %call, 5
  br i1 %cmp.not, label %if.end2, label %loaderr

if.end2:                                          ; preds = %if.end
  %2 = load ptr, ptr %rio, align 8
  %tobool4.not = icmp eq i32 %plain, 0
  %cond = select i1 %tobool4.not, i32 0, i32 2
  %call5 = tail call ptr @rdbGenericLoadStringObject(ptr noundef %2, i32 noundef %cond, ptr noundef %lenptr) #32
  %cmp6 = icmp eq ptr %call5, null
  br i1 %cmp6, label %loaderr, label %return

loaderr:                                          ; preds = %if.end2, %if.end
  %type.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %3 = load ptr, ptr %type.i, align 8
  %module.i = getelementptr inbounds %struct.RedisModuleType, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %module.i, align 8
  %options.i = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 12
  %5 = load i32, ptr %options.i, align 4
  %and.i = and i32 %5, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %moduleRDBLoadError.exit

if.end.i:                                         ; preds = %loaderr
  %name.i = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 1
  %6 = load ptr, ptr %name.i, align 8
  %7 = load i64, ptr %io, align 8
  %key.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  %8 = load ptr, ptr %key.i, align 8
  %tobool5.not.i = icmp eq ptr %8, null
  br i1 %tobool5.not.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end.i
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %8, i64 0, i32 2
  %9 = load ptr, ptr %ptr.i, align 8
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.end.i
  %cond.i = phi ptr [ %9, %cond.true.i ], [ @.str.60, %if.end.i ]
  %name4.i = getelementptr inbounds %struct.RedisModuleType, ptr %3, i64 0, i32 20
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 7011, ptr noundef nonnull @.str.59, ptr noundef %6, ptr noundef nonnull %name4.i, i64 noundef %7, ptr noundef %cond.i) #32
  tail call void @abort() #35
  unreachable

moduleRDBLoadError.exit:                          ; preds = %loaderr
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %if.end2, %entry, %moduleRDBLoadError.exit
  %retval.0 = phi ptr [ null, %moduleRDBLoadError.exit ], [ null, %entry ], [ %call5, %if.end2 ]
  ret ptr %retval.0
}

declare ptr @rdbGenericLoadStringObject(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_LoadString(ptr nocapture noundef %io) #0 {
entry:
  %error.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error.i, align 8
  %tobool.not.i = icmp eq i32 %0, 0
  br i1 %tobool.not.i, label %if.end.i, label %moduleLoadString.exit

if.end.i:                                         ; preds = %entry
  %rio.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %1 = load ptr, ptr %rio.i, align 8
  %call.i = tail call i64 @rdbLoadLen(ptr noundef %1, ptr noundef null) #32
  %cmp.not.i = icmp eq i64 %call.i, 5
  br i1 %cmp.not.i, label %if.end2.i, label %loaderr.i

if.end2.i:                                        ; preds = %if.end.i
  %2 = load ptr, ptr %rio.i, align 8
  %call5.i = tail call ptr @rdbGenericLoadStringObject(ptr noundef %2, i32 noundef 0, ptr noundef null) #32
  %cmp6.i = icmp eq ptr %call5.i, null
  br i1 %cmp6.i, label %loaderr.i, label %moduleLoadString.exit

loaderr.i:                                        ; preds = %if.end2.i, %if.end.i
  %type.i.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %3 = load ptr, ptr %type.i.i, align 8
  %module.i.i = getelementptr inbounds %struct.RedisModuleType, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %module.i.i, align 8
  %options.i.i = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 12
  %5 = load i32, ptr %options.i.i, align 4
  %and.i.i = and i32 %5, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %moduleRDBLoadError.exit.i

if.end.i.i:                                       ; preds = %loaderr.i
  %name.i.i = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 1
  %6 = load ptr, ptr %name.i.i, align 8
  %7 = load i64, ptr %io, align 8
  %key.i.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  %8 = load ptr, ptr %key.i.i, align 8
  %tobool5.not.i.i = icmp eq ptr %8, null
  br i1 %tobool5.not.i.i, label %cond.end.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.end.i.i
  %ptr.i.i = getelementptr inbounds %struct.redisObject, ptr %8, i64 0, i32 2
  %9 = load ptr, ptr %ptr.i.i, align 8
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.true.i.i, %if.end.i.i
  %cond.i.i = phi ptr [ %9, %cond.true.i.i ], [ @.str.60, %if.end.i.i ]
  %name4.i.i = getelementptr inbounds %struct.RedisModuleType, ptr %3, i64 0, i32 20
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 7011, ptr noundef nonnull @.str.59, ptr noundef %6, ptr noundef nonnull %name4.i.i, i64 noundef %7, ptr noundef %cond.i.i) #32
  tail call void @abort() #35
  unreachable

moduleRDBLoadError.exit.i:                        ; preds = %loaderr.i
  store i32 1, ptr %error.i, align 8
  br label %moduleLoadString.exit

moduleLoadString.exit:                            ; preds = %entry, %if.end2.i, %moduleRDBLoadError.exit.i
  %retval.0.i = phi ptr [ null, %moduleRDBLoadError.exit.i ], [ null, %entry ], [ %call5.i, %if.end2.i ]
  ret ptr %retval.0.i
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_LoadStringBuffer(ptr nocapture noundef %io, ptr noundef %lenptr) #0 {
entry:
  %error.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error.i, align 8
  %tobool.not.i = icmp eq i32 %0, 0
  br i1 %tobool.not.i, label %if.end.i, label %moduleLoadString.exit

if.end.i:                                         ; preds = %entry
  %rio.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %1 = load ptr, ptr %rio.i, align 8
  %call.i = tail call i64 @rdbLoadLen(ptr noundef %1, ptr noundef null) #32
  %cmp.not.i = icmp eq i64 %call.i, 5
  br i1 %cmp.not.i, label %if.end2.i, label %loaderr.i

if.end2.i:                                        ; preds = %if.end.i
  %2 = load ptr, ptr %rio.i, align 8
  %call5.i = tail call ptr @rdbGenericLoadStringObject(ptr noundef %2, i32 noundef 2, ptr noundef %lenptr) #32
  %cmp6.i = icmp eq ptr %call5.i, null
  br i1 %cmp6.i, label %loaderr.i, label %moduleLoadString.exit

loaderr.i:                                        ; preds = %if.end2.i, %if.end.i
  %type.i.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %3 = load ptr, ptr %type.i.i, align 8
  %module.i.i = getelementptr inbounds %struct.RedisModuleType, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %module.i.i, align 8
  %options.i.i = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 12
  %5 = load i32, ptr %options.i.i, align 4
  %and.i.i = and i32 %5, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %moduleRDBLoadError.exit.i

if.end.i.i:                                       ; preds = %loaderr.i
  %name.i.i = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 1
  %6 = load ptr, ptr %name.i.i, align 8
  %7 = load i64, ptr %io, align 8
  %key.i.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  %8 = load ptr, ptr %key.i.i, align 8
  %tobool5.not.i.i = icmp eq ptr %8, null
  br i1 %tobool5.not.i.i, label %cond.end.i.i, label %cond.true.i.i

cond.true.i.i:                                    ; preds = %if.end.i.i
  %ptr.i.i = getelementptr inbounds %struct.redisObject, ptr %8, i64 0, i32 2
  %9 = load ptr, ptr %ptr.i.i, align 8
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.true.i.i, %if.end.i.i
  %cond.i.i = phi ptr [ %9, %cond.true.i.i ], [ @.str.60, %if.end.i.i ]
  %name4.i.i = getelementptr inbounds %struct.RedisModuleType, ptr %3, i64 0, i32 20
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 7011, ptr noundef nonnull @.str.59, ptr noundef %6, ptr noundef nonnull %name4.i.i, i64 noundef %7, ptr noundef %cond.i.i) #32
  tail call void @abort() #35
  unreachable

moduleRDBLoadError.exit.i:                        ; preds = %loaderr.i
  store i32 1, ptr %error.i, align 8
  br label %moduleLoadString.exit

moduleLoadString.exit:                            ; preds = %entry, %if.end2.i, %moduleRDBLoadError.exit.i
  %retval.0.i = phi ptr [ null, %moduleRDBLoadError.exit.i ], [ null, %entry ], [ %call5.i, %if.end2.i ]
  ret ptr %retval.0.i
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveDouble(ptr nocapture noundef %io, double noundef %value) #0 {
entry:
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %pre_flush_buffer.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 7
  %1 = load ptr, ptr %pre_flush_buffer.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %if.end2, label %if.end.i

if.end.i:                                         ; preds = %if.end
  store ptr null, ptr %pre_flush_buffer.i, align 8
  %rio.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %2 = load ptr, ptr %rio.i, align 8
  %arrayidx.i.i = getelementptr inbounds i8, ptr %1, i64 -1
  %3 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %3 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %1, i64 -3
  %4 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %4 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end.i
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %1, i64 -5
  %5 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %5 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end.i
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %1, i64 -9
  %6 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %6 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end.i
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %1, i64 -17
  %7 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end.i
  %retval.0.i.i = phi i64 [ %7, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end.i ]
  %call5.i = tail call i64 @rdbWriteRaw(ptr noundef %2, ptr noundef nonnull %1, i64 noundef %retval.0.i.i) #32
  tail call void @sdsfree(ptr noundef nonnull %1) #32
  %cmp.i = icmp sgt i64 %call5.i, -1
  br i1 %cmp.i, label %if.then6.i, label %flushRedisModuleIOBuffer.exit

if.then6.i:                                       ; preds = %sdslen.exit.i
  %8 = load i64, ptr %io, align 8
  %add.i = add i64 %8, %call5.i
  store i64 %add.i, ptr %io, align 8
  br label %flushRedisModuleIOBuffer.exit

flushRedisModuleIOBuffer.exit:                    ; preds = %sdslen.exit.i, %if.then6.i
  %9 = and i64 %call5.i, 4294967295
  %cmp = icmp eq i64 %9, 4294967295
  br i1 %cmp, label %saveerr, label %if.end2

if.end2:                                          ; preds = %if.end, %flushRedisModuleIOBuffer.exit
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %10 = load ptr, ptr %rio, align 8
  %call3 = tail call i32 @rdbSaveLen(ptr noundef %10, i64 noundef 4) #32
  %cmp4 = icmp eq i32 %call3, -1
  br i1 %cmp4, label %saveerr, label %if.end6

if.end6:                                          ; preds = %if.end2
  %conv = sext i32 %call3 to i64
  %11 = load i64, ptr %io, align 8
  %add = add i64 %11, %conv
  store i64 %add, ptr %io, align 8
  %12 = load ptr, ptr %rio, align 8
  %call8 = tail call i32 @rdbSaveBinaryDoubleValue(ptr noundef %12, double noundef %value) #32
  %cmp9 = icmp eq i32 %call8, -1
  br i1 %cmp9, label %saveerr, label %if.end12

if.end12:                                         ; preds = %if.end6
  %conv13 = sext i32 %call8 to i64
  %13 = load i64, ptr %io, align 8
  %add15 = add i64 %13, %conv13
  store i64 %add15, ptr %io, align 8
  br label %return

saveerr:                                          ; preds = %if.end6, %if.end2, %flushRedisModuleIOBuffer.exit
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %entry, %saveerr, %if.end12
  ret void
}

declare i32 @rdbSaveBinaryDoubleValue(ptr noundef, double noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local double @RM_LoadDouble(ptr nocapture noundef %io) #0 {
entry:
  %value = alloca double, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %1 = load ptr, ptr %rio, align 8
  %call = tail call i64 @rdbLoadLen(ptr noundef %1, ptr noundef null) #32
  %cmp.not = icmp eq i64 %call, 4
  br i1 %cmp.not, label %if.end2, label %loaderr

if.end2:                                          ; preds = %if.end
  %2 = load ptr, ptr %rio, align 8
  %call5 = call i32 @rdbLoadBinaryDoubleValue(ptr noundef %2, ptr noundef nonnull %value) #32
  %cmp6 = icmp eq i32 %call5, -1
  br i1 %cmp6, label %loaderr, label %if.end8

if.end8:                                          ; preds = %if.end2
  %3 = load double, ptr %value, align 8
  br label %return

loaderr:                                          ; preds = %if.end2, %if.end
  %type.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %4 = load ptr, ptr %type.i, align 8
  %module.i = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 1
  %5 = load ptr, ptr %module.i, align 8
  %options.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 12
  %6 = load i32, ptr %options.i, align 4
  %and.i = and i32 %6, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %moduleRDBLoadError.exit

if.end.i:                                         ; preds = %loaderr
  %name.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 1
  %7 = load ptr, ptr %name.i, align 8
  %8 = load i64, ptr %io, align 8
  %key.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  %9 = load ptr, ptr %key.i, align 8
  %tobool5.not.i = icmp eq ptr %9, null
  br i1 %tobool5.not.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end.i
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %ptr.i, align 8
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.end.i
  %cond.i = phi ptr [ %10, %cond.true.i ], [ @.str.60, %if.end.i ]
  %name4.i = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 20
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 7011, ptr noundef nonnull @.str.59, ptr noundef %7, ptr noundef nonnull %name4.i, i64 noundef %8, ptr noundef %cond.i) #32
  call void @abort() #35
  unreachable

moduleRDBLoadError.exit:                          ; preds = %loaderr
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %entry, %moduleRDBLoadError.exit, %if.end8
  %retval.0 = phi double [ 0.000000e+00, %moduleRDBLoadError.exit ], [ %3, %if.end8 ], [ 0.000000e+00, %entry ]
  ret double %retval.0
}

declare i32 @rdbLoadBinaryDoubleValue(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveFloat(ptr nocapture noundef %io, float noundef %value) #0 {
entry:
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %pre_flush_buffer.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 7
  %1 = load ptr, ptr %pre_flush_buffer.i, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %if.end2, label %if.end.i

if.end.i:                                         ; preds = %if.end
  store ptr null, ptr %pre_flush_buffer.i, align 8
  %rio.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %2 = load ptr, ptr %rio.i, align 8
  %arrayidx.i.i = getelementptr inbounds i8, ptr %1, i64 -1
  %3 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %3 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %1, i64 -3
  %4 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %4 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end.i
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %1, i64 -5
  %5 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %5 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end.i
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %1, i64 -9
  %6 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %6 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end.i
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %1, i64 -17
  %7 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end.i
  %retval.0.i.i = phi i64 [ %7, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end.i ]
  %call5.i = tail call i64 @rdbWriteRaw(ptr noundef %2, ptr noundef nonnull %1, i64 noundef %retval.0.i.i) #32
  tail call void @sdsfree(ptr noundef nonnull %1) #32
  %cmp.i = icmp sgt i64 %call5.i, -1
  br i1 %cmp.i, label %if.then6.i, label %flushRedisModuleIOBuffer.exit

if.then6.i:                                       ; preds = %sdslen.exit.i
  %8 = load i64, ptr %io, align 8
  %add.i = add i64 %8, %call5.i
  store i64 %add.i, ptr %io, align 8
  br label %flushRedisModuleIOBuffer.exit

flushRedisModuleIOBuffer.exit:                    ; preds = %sdslen.exit.i, %if.then6.i
  %9 = and i64 %call5.i, 4294967295
  %cmp = icmp eq i64 %9, 4294967295
  br i1 %cmp, label %saveerr, label %if.end2

if.end2:                                          ; preds = %if.end, %flushRedisModuleIOBuffer.exit
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %10 = load ptr, ptr %rio, align 8
  %call3 = tail call i32 @rdbSaveLen(ptr noundef %10, i64 noundef 3) #32
  %cmp4 = icmp eq i32 %call3, -1
  br i1 %cmp4, label %saveerr, label %if.end6

if.end6:                                          ; preds = %if.end2
  %conv = sext i32 %call3 to i64
  %11 = load i64, ptr %io, align 8
  %add = add i64 %11, %conv
  store i64 %add, ptr %io, align 8
  %12 = load ptr, ptr %rio, align 8
  %call8 = tail call i32 @rdbSaveBinaryFloatValue(ptr noundef %12, float noundef %value) #32
  %cmp9 = icmp eq i32 %call8, -1
  br i1 %cmp9, label %saveerr, label %if.end12

if.end12:                                         ; preds = %if.end6
  %conv13 = sext i32 %call8 to i64
  %13 = load i64, ptr %io, align 8
  %add15 = add i64 %13, %conv13
  store i64 %add15, ptr %io, align 8
  br label %return

saveerr:                                          ; preds = %if.end6, %if.end2, %flushRedisModuleIOBuffer.exit
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %entry, %saveerr, %if.end12
  ret void
}

declare i32 @rdbSaveBinaryFloatValue(ptr noundef, float noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local float @RM_LoadFloat(ptr nocapture noundef %io) #0 {
entry:
  %value = alloca float, align 4
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %1 = load ptr, ptr %rio, align 8
  %call = tail call i64 @rdbLoadLen(ptr noundef %1, ptr noundef null) #32
  %cmp.not = icmp eq i64 %call, 3
  br i1 %cmp.not, label %if.end2, label %loaderr

if.end2:                                          ; preds = %if.end
  %2 = load ptr, ptr %rio, align 8
  %call5 = call i32 @rdbLoadBinaryFloatValue(ptr noundef %2, ptr noundef nonnull %value) #32
  %cmp6 = icmp eq i32 %call5, -1
  br i1 %cmp6, label %loaderr, label %if.end8

if.end8:                                          ; preds = %if.end2
  %3 = load float, ptr %value, align 4
  br label %return

loaderr:                                          ; preds = %if.end2, %if.end
  %type.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %4 = load ptr, ptr %type.i, align 8
  %module.i = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 1
  %5 = load ptr, ptr %module.i, align 8
  %options.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 12
  %6 = load i32, ptr %options.i, align 4
  %and.i = and i32 %6, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %moduleRDBLoadError.exit

if.end.i:                                         ; preds = %loaderr
  %name.i = getelementptr inbounds %struct.RedisModule, ptr %5, i64 0, i32 1
  %7 = load ptr, ptr %name.i, align 8
  %8 = load i64, ptr %io, align 8
  %key.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  %9 = load ptr, ptr %key.i, align 8
  %tobool5.not.i = icmp eq ptr %9, null
  br i1 %tobool5.not.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end.i
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %ptr.i, align 8
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.end.i
  %cond.i = phi ptr [ %10, %cond.true.i ], [ @.str.60, %if.end.i ]
  %name4.i = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 20
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.2, i32 noundef 7011, ptr noundef nonnull @.str.59, ptr noundef %7, ptr noundef nonnull %name4.i, i64 noundef %8, ptr noundef %cond.i) #32
  call void @abort() #35
  unreachable

moduleRDBLoadError.exit:                          ; preds = %loaderr
  store i32 1, ptr %error, align 8
  br label %return

return:                                           ; preds = %entry, %moduleRDBLoadError.exit, %if.end8
  %retval.0 = phi float [ 0.000000e+00, %moduleRDBLoadError.exit ], [ %3, %if.end8 ], [ 0.000000e+00, %entry ]
  ret float %retval.0
}

declare i32 @rdbLoadBinaryFloatValue(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveLongDouble(ptr nocapture noundef %io, x86_fp80 noundef %value) #0 {
entry:
  %buf = alloca [5120 x i8], align 16
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = call i32 @ld2string(ptr noundef nonnull %buf, i64 noundef 5120, x86_fp80 noundef %value, i32 noundef 2) #32
  %conv = sext i32 %call to i64
  call void @RM_SaveStringBuffer(ptr noundef nonnull %io, ptr noundef nonnull %buf, i64 noundef %conv)
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local x86_fp80 @RM_LoadLongDouble(ptr nocapture noundef %io) #0 {
entry:
  %value = alloca x86_fp80, align 16
  %len = alloca i64, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = call ptr @RM_LoadStringBuffer(ptr noundef nonnull %io, ptr noundef nonnull %len)
  %tobool1.not = icmp eq ptr %call, null
  br i1 %tobool1.not, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %1 = load i64, ptr %len, align 8
  %call4 = call i32 @string2ld(ptr noundef nonnull %call, i64 noundef %1, ptr noundef nonnull %value) #32
  call void @zfree(ptr noundef nonnull %call) #32
  %2 = load x86_fp80, ptr %value, align 16
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi x86_fp80 [ %2, %if.end3 ], [ 0xK00000000000000000000, %entry ], [ 0xK00000000000000000000, %if.end ]
  ret x86_fp80 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i64 @rdbSaveModulesAux(ptr noundef %rdb, i32 noundef %when) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %0) #32
  %call120 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not21 = icmp eq ptr %call120, null
  br i1 %cmp.not21, label %return, label %while.body

while.cond.loopexit:                              ; preds = %while.cond3.outer, %if.then, %while.body
  %total_written.1.ph.lcssa9 = phi i64 [ %total_written.022, %while.body ], [ %total_written.1.ph17, %if.then ], [ %add, %while.cond3.outer ]
  %call1 = call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %return, label %while.body, !llvm.loop !45

while.body:                                       ; preds = %entry, %while.cond.loopexit
  %call123 = phi ptr [ %call1, %while.cond.loopexit ], [ %call120, %entry ]
  %total_written.022 = phi i64 [ %total_written.1.ph.lcssa9, %while.cond.loopexit ], [ 0, %entry ]
  %call2 = call ptr @dictGetVal(ptr noundef nonnull %call123) #32
  %types = getelementptr inbounds %struct.RedisModule, ptr %call2, i64 0, i32 4
  %1 = load ptr, ptr %types, align 8
  call void @listRewind(ptr noundef %1, ptr noundef nonnull %li) #32
  %call41115 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not1216 = icmp eq ptr %call41115, null
  br i1 %tobool.not1216, label %while.cond.loopexit, label %while.body5.lr.ph

while.cond3.outer:                                ; preds = %if.end
  %add = add i64 %call9, %total_written.1.ph17
  %call411 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not12 = icmp eq ptr %call411, null
  br i1 %tobool.not12, label %while.cond.loopexit, label %while.body5.lr.ph, !llvm.loop !46

while.body5.lr.ph:                                ; preds = %while.body, %while.cond3.outer
  %call41118 = phi ptr [ %call411, %while.cond3.outer ], [ %call41115, %while.body ]
  %total_written.1.ph17 = phi i64 [ %add, %while.cond3.outer ], [ %total_written.022, %while.body ]
  br label %while.body5

while.body5:                                      ; preds = %while.body5.lr.ph, %if.then
  %call413 = phi ptr [ %call41118, %while.body5.lr.ph ], [ %call4, %if.then ]
  %value = getelementptr inbounds %struct.listNode, ptr %call413, i64 0, i32 2
  %2 = load ptr, ptr %value, align 8
  %aux_save = getelementptr inbounds %struct.RedisModuleType, ptr %2, i64 0, i32 13
  %3 = load ptr, ptr %aux_save, align 8
  %tobool6.not = icmp eq ptr %3, null
  br i1 %tobool6.not, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %while.body5
  %aux_save2 = getelementptr inbounds %struct.RedisModuleType, ptr %2, i64 0, i32 18
  %4 = load ptr, ptr %aux_save2, align 8
  %tobool7.not = icmp eq ptr %4, null
  br i1 %tobool7.not, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %while.body5
  %aux_save_triggers = getelementptr inbounds %struct.RedisModuleType, ptr %2, i64 0, i32 19
  %5 = load i32, ptr %aux_save_triggers, align 8
  %and = and i32 %5, %when
  %tobool8.not = icmp eq i32 %and, 0
  br i1 %tobool8.not, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %call4 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call4, null
  br i1 %tobool.not, label %while.cond.loopexit, label %while.body5, !llvm.loop !46

if.end:                                           ; preds = %lor.lhs.false
  %call9 = call i64 @rdbSaveSingleModuleAux(ptr noundef %rdb, i32 noundef %when, ptr noundef nonnull %2) #32
  %cmp10 = icmp eq i64 %call9, -1
  br i1 %cmp10, label %return, label %while.cond3.outer

return:                                           ; preds = %while.cond.loopexit, %if.end, %entry
  %retval.0 = phi i64 [ 0, %entry ], [ -1, %if.end ], [ %total_written.1.ph.lcssa9, %while.cond.loopexit ]
  call void @dictReleaseIterator(ptr noundef %call) #32
  ret i64 %retval.0
}

declare i64 @rdbSaveSingleModuleAux(ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_DigestAddStringBuffer(ptr noundef %md, ptr noundef %ele, i64 noundef %len) #0 {
entry:
  tail call void @mixDigest(ptr noundef %md, ptr noundef %ele, i64 noundef %len) #32
  ret void
}

declare void @mixDigest(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_DigestAddLongLong(ptr noundef %md, i64 noundef %ll) #0 {
entry:
  %buf = alloca [21 x i8], align 16
  %call = call i32 @ll2string(ptr noundef nonnull %buf, i64 noundef 21, i64 noundef %ll) #32
  %conv = sext i32 %call to i64
  call void @mixDigest(ptr noundef %md, ptr noundef nonnull %buf, i64 noundef %conv) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_DigestEndSequence(ptr noundef %md) #0 {
entry:
  %x = getelementptr inbounds %struct.RedisModuleDigest, ptr %md, i64 0, i32 1
  tail call void @xorDigest(ptr noundef nonnull %x, ptr noundef %md, i64 noundef 20) #32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(20) %md, i8 0, i64 20, i1 false)
  ret void
}

declare void @xorDigest(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_LoadDataTypeFromStringEncver(ptr nocapture noundef readonly %str, ptr noundef %mt, i32 noundef %encver) #0 {
entry:
  %payload = alloca %struct._rio, align 8
  %io = alloca %struct.RedisModuleIO, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  call void @rioInitWithBuffer(ptr noundef nonnull %payload, ptr noundef %0) #32
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  store ptr %payload, ptr %rio, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  store ptr %mt, ptr %type, align 8
  store i64 0, ptr %io, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  store i32 0, ptr %error, align 8
  %key = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  store ptr null, ptr %key, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 6
  store i32 -1, ptr %dbid, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 4
  store ptr null, ptr %ctx, align 8
  %pre_flush_buffer = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 7
  store ptr null, ptr %pre_flush_buffer, align 8
  %rdb_load = getelementptr inbounds %struct.RedisModuleType, ptr %mt, i64 0, i32 2
  %1 = load ptr, ptr %rdb_load, align 8
  %call = call ptr %1(ptr noundef nonnull %io, i32 noundef %encver) #32
  %2 = load ptr, ptr %ctx, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @moduleFreeContext(ptr noundef nonnull %2)
  %3 = load ptr, ptr %ctx, align 8
  call void @zfree(ptr noundef %3) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %call
}

declare void @rioInitWithBuffer(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_LoadDataTypeFromString(ptr nocapture noundef readonly %str, ptr noundef %mt) #0 {
entry:
  %payload.i = alloca %struct._rio, align 8
  %io.i = alloca %struct.RedisModuleIO, align 8
  call void @llvm.lifetime.start.p0(i64 112, ptr nonnull %payload.i)
  call void @llvm.lifetime.start.p0(i64 64, ptr nonnull %io.i)
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %str, i64 0, i32 2
  %0 = load ptr, ptr %ptr.i, align 8
  call void @rioInitWithBuffer(ptr noundef nonnull %payload.i, ptr noundef %0) #32
  %rio.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io.i, i64 0, i32 1
  store ptr %payload.i, ptr %rio.i, align 8
  %type.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io.i, i64 0, i32 2
  store ptr %mt, ptr %type.i, align 8
  store i64 0, ptr %io.i, align 8
  %error.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io.i, i64 0, i32 3
  store i32 0, ptr %error.i, align 8
  %key.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io.i, i64 0, i32 5
  store ptr null, ptr %key.i, align 8
  %dbid.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io.i, i64 0, i32 6
  store i32 -1, ptr %dbid.i, align 8
  %ctx.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io.i, i64 0, i32 4
  store ptr null, ptr %ctx.i, align 8
  %pre_flush_buffer.i = getelementptr inbounds %struct.RedisModuleIO, ptr %io.i, i64 0, i32 7
  store ptr null, ptr %pre_flush_buffer.i, align 8
  %rdb_load.i = getelementptr inbounds %struct.RedisModuleType, ptr %mt, i64 0, i32 2
  %1 = load ptr, ptr %rdb_load.i, align 8
  %call.i = call ptr %1(ptr noundef nonnull %io.i, i32 noundef 0) #32
  %2 = load ptr, ptr %ctx.i, align 8
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %RM_LoadDataTypeFromStringEncver.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  call void @moduleFreeContext(ptr noundef nonnull %2)
  %3 = load ptr, ptr %ctx.i, align 8
  call void @zfree(ptr noundef %3) #32
  br label %RM_LoadDataTypeFromStringEncver.exit

RM_LoadDataTypeFromStringEncver.exit:             ; preds = %entry, %if.then.i
  call void @llvm.lifetime.end.p0(i64 112, ptr nonnull %payload.i)
  call void @llvm.lifetime.end.p0(i64 64, ptr nonnull %io.i)
  ret ptr %call.i
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_SaveDataTypeToString(ptr noundef %ctx, ptr noundef %data, ptr noundef %mt) #0 {
entry:
  %payload = alloca %struct._rio, align 8
  %io = alloca %struct.RedisModuleIO, align 8
  %call = tail call ptr @sdsempty() #32
  call void @rioInitWithBuffer(ptr noundef nonnull %payload, ptr noundef %call) #32
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  store ptr %payload, ptr %rio, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  store ptr %mt, ptr %type, align 8
  store i64 0, ptr %io, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  store i32 0, ptr %error, align 8
  %key = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  store ptr null, ptr %key, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 6
  store i32 -1, ptr %dbid, align 8
  %ctx1 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 4
  store ptr null, ptr %ctx1, align 8
  %pre_flush_buffer = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 7
  store ptr null, ptr %pre_flush_buffer, align 8
  %rdb_save = getelementptr inbounds %struct.RedisModuleType, ptr %mt, i64 0, i32 3
  %0 = load ptr, ptr %rdb_save, align 8
  call void %0(ptr noundef nonnull %io, ptr noundef %data) #32
  %1 = load ptr, ptr %ctx1, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @moduleFreeContext(ptr noundef nonnull %1)
  %2 = load ptr, ptr %ctx1, align 8
  call void @zfree(ptr noundef %2) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr %error, align 8
  %tobool6.not = icmp eq i32 %3, 0
  br i1 %tobool6.not, label %if.else, label %return

if.else:                                          ; preds = %if.end
  %io8 = getelementptr inbounds %struct._rio, ptr %payload, i64 0, i32 9
  %4 = load ptr, ptr %io8, align 8
  %call9 = call ptr @createObject(i32 noundef 0, ptr noundef %4) #32
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %return, label %if.then10

if.then10:                                        ; preds = %if.else
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %5 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %5, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then10
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %6 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %7 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %6, %7
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %6, 1
  %cmp4.i = icmp slt i32 %6, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %8 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = call ptr @zrealloc(ptr noundef %8, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %9 = phi i32 [ %6, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %10 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %9 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %10, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %11 = load ptr, ptr %amqueue12.i, align 8
  %12 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %12 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %11, i64 %idxprom17.i
  store ptr %call9, ptr %arrayidx18.i, align 8
  %13 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %13, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end11.i, %if.then10, %if.else, %if.end
  %retval.0 = phi ptr [ null, %if.end ], [ %call9, %if.else ], [ %call9, %if.then10 ], [ %call9, %if.end11.i ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetKeyNameFromDigest(ptr nocapture noundef readonly %dig) #6 {
entry:
  %key = getelementptr inbounds %struct.RedisModuleDigest, ptr %dig, i64 0, i32 2
  %0 = load ptr, ptr %key, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_GetDbIdFromDigest(ptr nocapture noundef readonly %dig) #6 {
entry:
  %dbid = getelementptr inbounds %struct.RedisModuleDigest, ptr %dig, i64 0, i32 3
  %0 = load i32, ptr %dbid, align 8
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_EmitAOF(ptr nocapture noundef %io, ptr noundef %cmdname, ptr noundef %fmt, ...) #0 {
entry:
  %argc = alloca i32, align 4
  %flags = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 3
  %0 = load i32, ptr %error, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %argc, align 4
  store i32 0, ptr %flags, align 4
  %call = tail call ptr @lookupCommandByCString(ptr noundef %cmdname) #32
  %tobool1.not = icmp eq ptr %call, null
  br i1 %tobool1.not, label %do.body, label %if.end7

do.body:                                          ; preds = %if.end
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %1, 3
  br i1 %cmp, label %do.end, label %if.end4

if.end4:                                          ; preds = %do.body
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %2 = load ptr, ptr %type, align 8
  %name = getelementptr inbounds %struct.RedisModuleType, ptr %2, i64 0, i32 20
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.61, ptr noundef nonnull %name, ptr noundef %cmdname) #32
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end4
  store i32 1, ptr %error, align 8
  %call6 = tail call ptr @__errno_location() #37
  store i32 22, ptr %call6, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  call void @llvm.va_start(ptr nonnull %ap)
  %call10 = call ptr @moduleCreateArgvFromUserFormat(ptr noundef %cmdname, ptr noundef %fmt, ptr noundef nonnull %argc, ptr noundef nonnull %flags, ptr noundef nonnull %ap)
  call void @llvm.va_end(ptr nonnull %ap)
  %cmp12 = icmp eq ptr %call10, null
  br i1 %cmp12, label %do.body14, label %if.end24

do.body14:                                        ; preds = %if.end7
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp15 = icmp sgt i32 %3, 3
  br i1 %cmp15, label %do.end21, label %if.end17

if.end17:                                         ; preds = %do.body14
  %type18 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %4 = load ptr, ptr %type18, align 8
  %name19 = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 20
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.62, ptr noundef nonnull %name19, ptr noundef %fmt) #32
  br label %do.end21

do.end21:                                         ; preds = %do.body14, %if.end17
  store i32 1, ptr %error, align 8
  %call23 = tail call ptr @__errno_location() #37
  store i32 22, ptr %call23, align 4
  br label %return

if.end24:                                         ; preds = %if.end7
  %5 = load i32, ptr %error, align 8
  %tobool26.not = icmp eq i32 %5, 0
  br i1 %tobool26.not, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %if.end24
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  %6 = load ptr, ptr %rio, align 8
  %7 = load i32, ptr %argc, align 4
  %conv = sext i32 %7 to i64
  %call27 = call i64 @rioWriteBulkCount(ptr noundef %6, i8 noundef signext 42, i64 noundef %conv) #32
  %cmp28 = icmp eq i64 %call27, 0
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %land.lhs.true
  store i32 1, ptr %error, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %land.lhs.true, %if.end24
  %8 = load i32, ptr %argc, align 4
  %cmp3320 = icmp sgt i32 %8, 0
  br i1 %cmp3320, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.end32
  %rio38 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %if.end44
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %if.end44 ]
  %9 = load i32, ptr %error, align 8
  %tobool36.not = icmp eq i32 %9, 0
  br i1 %tobool36.not, label %land.lhs.true37, label %if.end44

land.lhs.true37:                                  ; preds = %for.body
  %10 = load ptr, ptr %rio38, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %call10, i64 %indvars.iv
  %11 = load ptr, ptr %arrayidx, align 8
  %call39 = call i32 @rioWriteBulkObject(ptr noundef %10, ptr noundef %11) #32
  %cmp40 = icmp eq i32 %call39, 0
  br i1 %cmp40, label %if.then42, label %if.end44

if.then42:                                        ; preds = %land.lhs.true37
  store i32 1, ptr %error, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %land.lhs.true37, %for.body
  %arrayidx46 = getelementptr inbounds ptr, ptr %call10, i64 %indvars.iv
  %12 = load ptr, ptr %arrayidx46, align 8
  call void @decrRefCount(ptr noundef %12) #32
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %13 = load i32, ptr %argc, align 4
  %14 = sext i32 %13 to i64
  %cmp33 = icmp slt i64 %indvars.iv.next, %14
  br i1 %cmp33, label %for.body, label %for.end, !llvm.loop !47

for.end:                                          ; preds = %if.end44, %if.end32
  call void @zfree(ptr noundef nonnull %call10) #32
  br label %return

return:                                           ; preds = %entry, %for.end, %do.end21, %do.end
  ret void
}

declare i64 @rioWriteBulkCount(ptr noundef, i8 noundef signext, i64 noundef) local_unnamed_addr #1

declare i32 @rioWriteBulkObject(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetContextFromIO(ptr nocapture noundef %io) #0 {
entry:
  %ctx = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 4
  %0 = load ptr, ptr %ctx, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = tail call noalias dereferenceable_or_null(120) ptr @zmalloc(i64 noundef 120) #33
  store ptr %call, ptr %ctx, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %1 = load ptr, ptr %type, align 8
  %module = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %3 = getelementptr inbounds i8, ptr %call, i64 16
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %3, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %call, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 1
  store ptr %2, ptr %module1.i, align 8
  %4 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %4, 0
  %5 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %5() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %6
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %7, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %8 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 14
  store i64 %add.sink.i, ptr %8, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %9 = load ptr, ptr %ctx, align 8
  br label %return

return:                                           ; preds = %entry, %moduleCreateContext.exit
  %retval.0 = phi ptr [ %9, %moduleCreateContext.exit ], [ %0, %entry ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetKeyNameFromIO(ptr nocapture noundef readonly %io) #6 {
entry:
  %key = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 5
  %0 = load ptr, ptr %key, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetKeyNameFromModuleKey(ptr noundef readonly %key) #6 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %key1 = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %key1, align 8
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi ptr [ %0, %cond.true ], [ null, %entry ]
  ret ptr %cond
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @RM_GetDbIdFromModuleKey(ptr noundef readonly %key) #11 {
entry:
  %tobool.not = icmp eq ptr %key, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %0 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %0, i64 0, i32 6
  %1 = load i32, ptr %id, align 8
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi i32 [ %1, %cond.true ], [ -1, %entry ]
  ret i32 %cond
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_GetDbIdFromIO(ptr nocapture noundef readonly %io) #6 {
entry:
  %dbid = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 6
  %0 = load i32, ptr %dbid, align 8
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleLogRaw(ptr noundef readonly %module, ptr nocapture noundef readonly %levelstr, ptr nocapture noundef readonly %fmt, ptr noundef %ap) local_unnamed_addr #0 {
entry:
  %msg = alloca [1024 x i8], align 16
  %call = tail call i32 @strcasecmp(ptr noundef %levelstr, ptr noundef nonnull @.str.63) #36
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end15, label %if.else

if.else:                                          ; preds = %entry
  %call1 = tail call i32 @strcasecmp(ptr noundef %levelstr, ptr noundef nonnull @.str.64) #36
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.end15, label %if.else4

if.else4:                                         ; preds = %if.else
  %call5 = tail call i32 @strcasecmp(ptr noundef %levelstr, ptr noundef nonnull @.str.65) #36
  %tobool6.not = icmp eq i32 %call5, 0
  br i1 %tobool6.not, label %if.end15, label %if.else8

if.else8:                                         ; preds = %if.else4
  %call9 = tail call i32 @strcasecmp(ptr noundef %levelstr, ptr noundef nonnull @.str.66) #36
  %tobool10.not = icmp eq i32 %call9, 0
  %. = select i1 %tobool10.not, i32 3, i32 1
  br label %if.end15

if.end15:                                         ; preds = %if.else8, %if.else4, %if.else, %entry
  %level.0 = phi i32 [ 0, %entry ], [ 1, %if.else ], [ 2, %if.else4 ], [ %., %if.else8 ]
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp slt i32 %level.0, %0
  br i1 %cmp, label %return, label %if.end17

if.end17:                                         ; preds = %if.end15
  %tobool18.not = icmp eq ptr %module, null
  br i1 %tobool18.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.end17
  %name = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 1
  %1 = load ptr, ptr %name, align 8
  br label %cond.end

cond.end:                                         ; preds = %if.end17, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ @.str.68, %if.end17 ]
  %call19 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %msg, i64 noundef 1024, ptr noundef nonnull @.str.67, ptr noundef %cond) #32
  %conv = sext i32 %call19 to i64
  %add.ptr = getelementptr inbounds i8, ptr %msg, i64 %conv
  %sub = sub nsw i64 1024, %conv
  %call21 = call i32 @vsnprintf(ptr noundef nonnull %add.ptr, i64 noundef %sub, ptr noundef %fmt, ptr noundef %ap) #32
  call void @serverLogRaw(i32 noundef %level.0, ptr noundef nonnull %msg) #32
  br label %return

return:                                           ; preds = %if.end15, %cond.end
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @vsnprintf(ptr nocapture noundef, i64 noundef, ptr nocapture noundef readonly, ptr noundef) local_unnamed_addr #20

declare void @serverLogRaw(i32 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_Log(ptr noundef readonly %ctx, ptr nocapture noundef readonly %levelstr, ptr nocapture noundef readonly %fmt, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.va_start(ptr nonnull %ap)
  %tobool.not = icmp eq ptr %ctx, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi ptr [ %0, %cond.true ], [ null, %entry ]
  call void @moduleLogRaw(ptr noundef %cond, ptr noundef %levelstr, ptr noundef %fmt, ptr noundef nonnull %ap)
  call void @llvm.va_end(ptr nonnull %ap)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_LogIOError(ptr nocapture noundef readonly %io, ptr nocapture noundef readonly %levelstr, ptr nocapture noundef readonly %fmt, ...) #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.va_start(ptr nonnull %ap)
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i64 0, i32 2
  %0 = load ptr, ptr %type, align 8
  %module = getelementptr inbounds %struct.RedisModuleType, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %module, align 8
  call void @moduleLogRaw(ptr noundef %1, ptr noundef %levelstr, ptr noundef %fmt, ptr noundef nonnull %ap)
  call void @llvm.va_end(ptr nonnull %ap)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM__Assert(ptr noundef %estr, ptr noundef %file, i32 noundef %line) #0 {
entry:
  tail call void @_serverAssert(ptr noundef %estr, ptr noundef %file, i32 noundef %line) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_LatencyAddSample(ptr noundef %event, i64 noundef %latency) #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %cmp.not = icmp sgt i64 %0, %latency
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @latencyAddSample(ptr noundef %event, i64 noundef %latency) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @latencyAddSample(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @unblockClientFromModule(ptr nocapture noundef readonly %c) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %module_blocked_handle = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55, i32 7
  %0 = load ptr, ptr %module_blocked_handle, align 8
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 5
  %1 = load ptr, ptr %disconnect_callback, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %3 = getelementptr inbounds i8, ptr %ctx, i64 16
  %4 = getelementptr inbounds i8, ptr %ctx, i64 24
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %4, i8 0, i64 96, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %2, ptr %module1.i, align 8
  %5 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %5, 0
  %6 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %6() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.then
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %7
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.then
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %8, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %9, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 7
  %10 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 10
  store ptr %10, ptr %blocked_privdata, align 8
  %11 = load ptr, ptr %0, align 8
  store ptr %11, ptr %3, align 8
  %12 = load ptr, ptr %disconnect_callback, align 8
  call void %12(ptr noundef nonnull %ctx, ptr noundef nonnull %0) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %if.end

if.end:                                           ; preds = %moduleCreateContext.exit, %entry
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 11
  %13 = load i32, ptr %blocked_on_keys, align 4
  %tobool3.not = icmp eq i32 %13, 0
  br i1 %tobool3.not, label %if.end6, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 12
  %14 = load i32, ptr %unblocked, align 8
  %tobool4.not = icmp eq i32 %14, 0
  br i1 %tobool4.not, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  %15 = load ptr, ptr %module_blocked_handle, align 8
  %call.i.i = call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  %blocked_on_keys.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %15, i64 0, i32 11
  %16 = load i32, ptr %blocked_on_keys.i.i, align 4
  %tobool.not.i.i = icmp eq i32 %16, 0
  br i1 %tobool.not.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %if.then5
  %privdata1.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %15, i64 0, i32 7
  store ptr null, ptr %privdata1.i.i, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i, %if.then5
  %unblocked.i.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %15, i64 0, i32 12
  store i32 1, ptr %unblocked.i.i, align 8
  %17 = load ptr, ptr @moduleUnblockedClients, align 8
  %len.i.i = getelementptr inbounds %struct.list, ptr %17, i64 0, i32 5
  %18 = load i64, ptr %len.i.i, align 8
  %cmp.i.i = icmp eq i64 %18, 0
  br i1 %cmp.i.i, label %if.then2.i.i, label %moduleUnblockClient.exit

if.then2.i.i:                                     ; preds = %if.end.i.i
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 41, i64 1), align 4
  %call3.i.i = call i64 @write(i32 noundef %19, ptr noundef nonnull @.str.76, i64 noundef 1) #32
  %.pre.i.i = load ptr, ptr @moduleUnblockedClients, align 8
  br label %moduleUnblockClient.exit

moduleUnblockClient.exit:                         ; preds = %if.end.i.i, %if.then2.i.i
  %20 = phi ptr [ %.pre.i.i, %if.then2.i.i ], [ %17, %if.end.i.i ]
  %call8.i.i = call ptr @listAddNodeTail(ptr noundef %20, ptr noundef nonnull %15) #32
  %call9.i.i = call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  br label %if.end6

if.end6:                                          ; preds = %moduleUnblockClient.exit, %land.lhs.true, %if.end
  store ptr null, ptr %0, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnblockClient(ptr nocapture noundef readonly %c) local_unnamed_addr #0 {
entry:
  %module_blocked_handle = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55, i32 7
  %0 = load ptr, ptr %module_blocked_handle, align 8
  %call.i = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  %blocked_on_keys.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 11
  %1 = load i32, ptr %blocked_on_keys.i, align 4
  %tobool.not.i = icmp eq i32 %1, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %entry
  %privdata1.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 7
  store ptr null, ptr %privdata1.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %entry
  %unblocked.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 12
  store i32 1, ptr %unblocked.i, align 8
  %2 = load ptr, ptr @moduleUnblockedClients, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %2, i64 0, i32 5
  %3 = load i64, ptr %len.i, align 8
  %cmp.i = icmp eq i64 %3, 0
  br i1 %cmp.i, label %if.then2.i, label %moduleUnblockClientByHandle.exit

if.then2.i:                                       ; preds = %if.end.i
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 41, i64 1), align 4
  %call3.i = tail call i64 @write(i32 noundef %4, ptr noundef nonnull @.str.76, i64 noundef 1) #32
  %.pre.i = load ptr, ptr @moduleUnblockedClients, align 8
  br label %moduleUnblockClientByHandle.exit

moduleUnblockClientByHandle.exit:                 ; preds = %if.end.i, %if.then2.i
  %5 = phi ptr [ %.pre.i, %if.then2.i ], [ %2, %if.end.i ]
  %call8.i = tail call ptr @listAddNodeTail(ptr noundef %5, ptr noundef nonnull %0) #32
  %call9.i = tail call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @moduleBlockClient(ptr nocapture noundef readonly %ctx, ptr noundef %reply_callback, ptr noundef %auth_reply_callback, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef %keys, i32 noundef %numkeys, ptr noundef %privdata, i32 noundef %flags) local_unnamed_addr #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %call = tail call i32 @scriptIsRunning() #32
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 30), align 4
  %call1 = tail call noalias dereferenceable_or_null(112) ptr @zmalloc(i64 noundef 112) #33
  %module_blocked_handle = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 55, i32 7
  store ptr %call1, ptr %module_blocked_handle, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %2, i64 0, i32 13
  %3 = load i32, ptr %blocked_clients, align 8
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %blocked_clients, align 8
  %tobool = icmp ne i32 %call, 0
  %tobool4 = icmp ne i32 %1, 0
  %or.cond = select i1 %tobool, i1 true, i1 %tobool4
  %cond = select i1 %or.cond, ptr null, ptr %0
  store ptr %cond, ptr %call1, align 8
  %4 = load ptr, ptr %module, align 8
  %module7 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 1
  store ptr %4, ptr %module7, align 8
  %reply_callback8 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 2
  store ptr %reply_callback, ptr %reply_callback8, align 8
  %auth_reply_cb = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 3
  store ptr %auth_reply_callback, ptr %auth_reply_cb, align 8
  %timeout_callback9 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 4
  store ptr %timeout_callback, ptr %timeout_callback9, align 8
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 5
  store ptr null, ptr %disconnect_callback, align 8
  %free_privdata10 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 6
  store ptr %free_privdata, ptr %free_privdata10, align 8
  %privdata11 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 7
  store ptr %privdata, ptr %privdata11, align 8
  %5 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i = icmp eq i64 %5, 0
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %6 = load ptr, ptr @moduleTempClients, align 8
  %dec.i = add i64 %5, -1
  store i64 %dec.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i = getelementptr inbounds ptr, ptr %6, i64 %dec.i
  %7 = load ptr, ptr %arrayidx.i, align 8
  %8 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i = icmp ult i64 %dec.i, %8
  br i1 %cmp1.i, label %if.then2.i, label %moduleAllocTempClient.exit

if.then2.i:                                       ; preds = %if.then.i
  store i64 %dec.i, ptr @moduleTempClientMinCount, align 8
  br label %moduleAllocTempClient.exit

if.else.i:                                        ; preds = %entry
  %call.i = tail call ptr @createClient(ptr noundef null) #32
  %flags.i = getelementptr inbounds %struct.client, ptr %call.i, i64 0, i32 1
  %9 = load i64, ptr %flags.i, align 8
  %or.i = or i64 %9, 134217728
  store i64 %or.i, ptr %flags.i, align 8
  %user.i = getelementptr inbounds %struct.client, ptr %call.i, i64 0, i32 20
  store ptr null, ptr %user.i, align 8
  %.pr.pre = load i64, ptr @moduleTempClientCount, align 8
  br label %moduleAllocTempClient.exit

moduleAllocTempClient.exit:                       ; preds = %if.then2.i, %if.else.i, %if.then.i
  %10 = phi i64 [ %dec.i, %if.then.i ], [ %.pr.pre, %if.else.i ], [ %dec.i, %if.then2.i ]
  %c.0.i = phi ptr [ %7, %if.then.i ], [ %call.i, %if.else.i ], [ %7, %if.then2.i ]
  %reply_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 9
  store ptr %c.0.i, ptr %reply_client, align 8
  %cmp.not.i50 = icmp eq i64 %10, 0
  br i1 %cmp.not.i50, label %if.else.i57, label %if.then.i51

if.then.i51:                                      ; preds = %moduleAllocTempClient.exit
  %11 = load ptr, ptr @moduleTempClients, align 8
  %dec.i52 = add i64 %10, -1
  store i64 %dec.i52, ptr @moduleTempClientCount, align 8
  %arrayidx.i53 = getelementptr inbounds ptr, ptr %11, i64 %dec.i52
  %12 = load ptr, ptr %arrayidx.i53, align 8
  %13 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i54 = icmp ult i64 %dec.i52, %13
  br i1 %cmp1.i54, label %if.then2.i56, label %moduleAllocTempClient.exit62

if.then2.i56:                                     ; preds = %if.then.i51
  store i64 %dec.i52, ptr @moduleTempClientMinCount, align 8
  br label %moduleAllocTempClient.exit62

if.else.i57:                                      ; preds = %moduleAllocTempClient.exit
  %call.i58 = tail call ptr @createClient(ptr noundef null) #32
  %flags.i59 = getelementptr inbounds %struct.client, ptr %call.i58, i64 0, i32 1
  %14 = load i64, ptr %flags.i59, align 8
  %or.i60 = or i64 %14, 134217728
  store i64 %or.i60, ptr %flags.i59, align 8
  %user.i61 = getelementptr inbounds %struct.client, ptr %call.i58, i64 0, i32 20
  store ptr null, ptr %user.i61, align 8
  br label %moduleAllocTempClient.exit62

moduleAllocTempClient.exit62:                     ; preds = %if.then.i51, %if.then2.i56, %if.else.i57
  %c.0.i55 = phi ptr [ %12, %if.then2.i56 ], [ %12, %if.then.i51 ], [ %call.i58, %if.else.i57 ]
  %thread_safe_ctx_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 8
  store ptr %c.0.i55, ptr %thread_safe_ctx_client, align 8
  %15 = load ptr, ptr %call1, align 8
  %tobool15.not = icmp eq ptr %15, null
  br i1 %tobool15.not, label %if.end, label %if.then

if.then:                                          ; preds = %moduleAllocTempClient.exit62
  %resp = getelementptr inbounds %struct.client, ptr %15, i64 0, i32 3
  %16 = load i32, ptr %resp, align 8
  %17 = load ptr, ptr %reply_client, align 8
  %resp18 = getelementptr inbounds %struct.client, ptr %17, i64 0, i32 3
  store i32 %16, ptr %resp18, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %moduleAllocTempClient.exit62
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %18 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %18, i64 0, i32 6
  %19 = load i32, ptr %id, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 10
  store i32 %19, ptr %dbid, align 8
  %cmp = icmp ne ptr %keys, null
  %conv = zext i1 %cmp to i32
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 11
  store i32 %conv, ptr %blocked_on_keys, align 4
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 12
  store i32 0, ptr %unblocked, align 8
  %background_timer = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %call1, i64 0, i32 13
  %timeout = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 55, i32 1
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %background_timer, i8 0, i64 16, i1 false)
  store i64 0, ptr %timeout, align 8
  %tobool20.not = icmp eq i64 %timeout_ms, 0
  br i1 %tobool20.not, label %if.end31, label %if.then21

if.then21:                                        ; preds = %if.end
  %call22 = tail call i64 @mstime() #32
  %sub = sub nsw i64 9223372036854775807, %call22
  %cmp23 = icmp slt i64 %sub, %timeout_ms
  br i1 %cmp23, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.then21
  store ptr null, ptr %module_blocked_handle, align 8
  tail call void @addReplyError(ptr noundef nonnull %0, ptr noundef nonnull @.str.69) #32
  br label %return

if.end28:                                         ; preds = %if.then21
  %add = add nsw i64 %call22, %timeout_ms
  store i64 %add, ptr %timeout, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end28, %if.end
  %20 = phi i64 [ %add, %if.end28 ], [ 0, %if.end ]
  br i1 %or.cond, label %if.then35, label %if.else

if.then35:                                        ; preds = %if.end31
  store ptr null, ptr %module_blocked_handle, align 8
  %cond39 = select i1 %tobool, ptr @.str.70, ptr @.str.71
  tail call void @addReplyError(ptr noundef nonnull %0, ptr noundef nonnull %cond39) #32
  br label %return

if.else:                                          ; preds = %if.end31
  %flags40 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %21 = load i32, ptr %flags40, align 8
  %and = and i32 %21, 4
  %tobool41.not = icmp eq i32 %and, 0
  br i1 %tobool41.not, label %if.else45, label %if.then42

if.then42:                                        ; preds = %if.else
  store ptr null, ptr %module_blocked_handle, align 8
  tail call void @addReplyError(ptr noundef nonnull %0, ptr noundef nonnull @.str.72) #32
  br label %return

if.else45:                                        ; preds = %if.else
  %tobool46.not = icmp eq ptr %auth_reply_callback, null
  br i1 %tobool46.not, label %land.lhs.true, label %if.else52

land.lhs.true:                                    ; preds = %if.else45
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 67
  %22 = load ptr, ptr %module_auth_ctx, align 8
  %cmp47.not = icmp eq ptr %22, null
  br i1 %cmp47.not, label %if.else52, label %if.then49

if.then49:                                        ; preds = %land.lhs.true
  store ptr null, ptr %module_blocked_handle, align 8
  tail call void @addReplyError(ptr noundef nonnull %0, ptr noundef nonnull @.str.73) #32
  br label %return

if.else52:                                        ; preds = %land.lhs.true, %if.else45
  br i1 %cmp, label %if.then54, label %if.else58

if.then54:                                        ; preds = %if.else52
  %and57 = and i32 %flags, 1
  tail call void @blockForKeys(ptr noundef nonnull %0, i32 noundef 4, ptr noundef nonnull %keys, i32 noundef %numkeys, i64 noundef %20, i32 noundef %and57) #32
  br label %return

if.else58:                                        ; preds = %if.else52
  tail call void @blockClient(ptr noundef nonnull %0, i32 noundef 4) #32
  br label %return

return:                                           ; preds = %if.then35, %if.then49, %if.else58, %if.then54, %if.then42, %if.then25
  ret ptr %call1
}

declare void @blockForKeys(ptr noundef, i32 noundef, ptr noundef, i32 noundef, i64 noundef, i32 noundef) local_unnamed_addr #1

declare void @blockClient(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_RegisterAuthCallback(ptr nocapture noundef readonly %ctx, ptr noundef %cb) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #33
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  store ptr %0, ptr %call, align 8
  %auth_cb = getelementptr inbounds %struct.RedisModuleAuthCtx, ptr %call, i64 0, i32 1
  store ptr %cb, ptr %auth_cb, align 8
  %1 = load ptr, ptr @moduleAuthCallbacks, align 8
  %call2 = tail call ptr @listAddNodeHead(ptr noundef %1, ptr noundef nonnull %call) #32
  ret void
}

declare ptr @listAddNodeHead(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleInvokeFreePrivDataCallback(ptr noundef readnone %c, ptr nocapture noundef readonly %bc) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 7
  %0 = load ptr, ptr %privdata, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %free_privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 6
  %1 = load ptr, ptr %free_privdata, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %cmp = icmp eq ptr %c, null
  %cond = select i1 %cmp, i32 32, i32 0
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 1
  %2 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef nonnull %ctx, ptr noundef %2, i32 noundef %cond)
  %3 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 10
  store ptr %3, ptr %blocked_privdata, align 8
  %4 = load ptr, ptr %bc, align 8
  %client3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  store ptr %4, ptr %client3, align 8
  %5 = load ptr, ptr %free_privdata, align 8
  call void %5(ptr noundef nonnull %ctx, ptr noundef %3) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnregisterAuthCBs(ptr noundef readnone %module) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load ptr, ptr @moduleAuthCallbacks, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #32
  %call3 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not4 = icmp eq ptr %call3, null
  br i1 %tobool.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call5 = phi ptr [ %call, %if.end ], [ %call3, %entry ]
  %value = getelementptr inbounds %struct.listNode, ptr %call5, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp = icmp eq ptr %2, %module
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %3 = load ptr, ptr @moduleAuthCallbacks, align 8
  call void @listDelNode(ptr noundef %3, ptr noundef nonnull %call5) #32
  call void @zfree(ptr noundef nonnull %1) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !48

while.end:                                        ; preds = %if.end, %entry
  ret void
}

declare void @listDelNode(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @attemptNextAuthCb(ptr noundef %c, ptr noundef %username, ptr noundef %password, ptr noundef %err) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 67
  %0 = load ptr, ptr %module_auth_ctx, align 8
  %cmp = icmp eq ptr %0, null
  %1 = load ptr, ptr @moduleAuthCallbacks, align 8
  call void @listRewind(ptr noundef %1, ptr noundef nonnull %li) #32
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %2 = getelementptr inbounds i8, ptr %ctx, i64 16
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %moduleCreateContext.exit, %entry
  %handle_next_callback.0.shrunk.ph = phi i1 [ true, %moduleCreateContext.exit ], [ %cmp, %entry ]
  %result.0.ph = phi i32 [ %call6, %moduleCreateContext.exit ], [ 1, %entry ]
  %call12 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not13 = icmp eq ptr %call12, null
  br i1 %tobool.not13, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond.outer, %if.then
  %call15 = phi ptr [ %call, %if.then ], [ %call12, %while.cond.outer ]
  %handle_next_callback.0.shrunk14 = phi i1 [ %cmp3, %if.then ], [ %handle_next_callback.0.shrunk.ph, %while.cond.outer ]
  %value = getelementptr inbounds %struct.listNode, ptr %call15, i64 0, i32 2
  %4 = load ptr, ptr %value, align 8
  br i1 %handle_next_callback.0.shrunk14, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %5 = load ptr, ptr %module_auth_ctx, align 8
  %cmp3 = icmp eq ptr %4, %5
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !49

if.end:                                           ; preds = %while.body
  %6 = load i64, ptr %flags, align 8
  %and = and i64 %6, -140737488355329
  store i64 %and, ptr %flags, align 8
  %7 = load ptr, ptr %4, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  store ptr %7, ptr %module1.i, align 8
  %8 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %8, 0
  %9 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = call i64 %9() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %10
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %11, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  store i64 %add.sink.i, ptr %3, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  store ptr %c, ptr %2, align 8
  store ptr null, ptr %err, align 8
  store ptr %4, ptr %module_auth_ctx, align 8
  %auth_cb = getelementptr inbounds %struct.RedisModuleAuthCtx, ptr %4, i64 0, i32 1
  %12 = load ptr, ptr %auth_cb, align 8
  %call6 = call i32 %12(ptr noundef nonnull %ctx, ptr noundef %username, ptr noundef %password, ptr noundef nonnull %err) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %while.end, label %while.cond.outer, !llvm.loop !49

while.end:                                        ; preds = %moduleCreateContext.exit, %while.cond.outer, %if.then
  %result.1 = phi i32 [ %result.0.ph, %if.then ], [ %result.0.ph, %while.cond.outer ], [ 0, %moduleCreateContext.exit ]
  ret i32 %result.1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @attemptBlockedAuthReplyCallback(ptr noundef %c, ptr noundef %username, ptr noundef %password, ptr noundef %err) local_unnamed_addr #0 {
entry:
  %ctx.i = alloca %struct.RedisModuleCtx, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %module_blocked_client = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 66
  %0 = load ptr, ptr %module_blocked_client, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  store ptr %c, ptr %0, align 8
  %auth_reply_cb = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 3
  %1 = load ptr, ptr %auth_reply_cb, align 8
  %tobool2.not = icmp eq ptr %1, null
  br i1 %tobool2.not, label %if.end7, label %if.then3

if.then3:                                         ; preds = %if.end
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %3 = getelementptr inbounds i8, ptr %ctx, i64 16
  %4 = getelementptr inbounds i8, ptr %ctx, i64 32
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %4, i8 0, i64 88, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %2, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 4, ptr %flags.i, align 8
  %5 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %5, 0
  %6 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %6() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.then3
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %7
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.then3
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %8, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %9, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 7
  %10 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 10
  store ptr %10, ptr %blocked_privdata, align 8
  %blocked_ready_key = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 11
  store ptr null, ptr %blocked_ready_key, align 8
  %11 = load ptr, ptr %0, align 8
  store ptr %11, ptr %3, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  store ptr %0, ptr %blocked_client, align 8
  %12 = load ptr, ptr %auth_reply_cb, align 8
  %call = call i32 %12(ptr noundef nonnull %ctx, ptr noundef %username, ptr noundef %password, ptr noundef %err) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %if.end7

if.end7:                                          ; preds = %moduleCreateContext.exit, %if.end
  %result.0 = phi i32 [ %call, %moduleCreateContext.exit ], [ 1, %if.end ]
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %ctx.i)
  %privdata.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 7
  %13 = load ptr, ptr %privdata.i, align 8
  %tobool.not.i = icmp eq ptr %13, null
  br i1 %tobool.not.i, label %moduleInvokeFreePrivDataCallback.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end7
  %free_privdata.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 6
  %14 = load ptr, ptr %free_privdata.i, align 8
  %tobool1.not.i = icmp eq ptr %14, null
  br i1 %tobool1.not.i, label %moduleInvokeFreePrivDataCallback.exit, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %module.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 1
  %15 = load ptr, ptr %module.i, align 8
  call void @moduleCreateContext(ptr noundef nonnull %ctx.i, ptr noundef %15, i32 noundef 0)
  %16 = load ptr, ptr %privdata.i, align 8
  %blocked_privdata.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.i, i64 0, i32 10
  store ptr %16, ptr %blocked_privdata.i, align 8
  %17 = load ptr, ptr %0, align 8
  %client3.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.i, i64 0, i32 2
  store ptr %17, ptr %client3.i, align 8
  %18 = load ptr, ptr %free_privdata.i, align 8
  call void %18(ptr noundef nonnull %ctx.i, ptr noundef %16) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx.i)
  br label %moduleInvokeFreePrivDataCallback.exit

moduleInvokeFreePrivDataCallback.exit:            ; preds = %if.end7, %land.lhs.true.i, %if.then.i
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %ctx.i)
  store ptr null, ptr %module_blocked_client, align 8
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 14
  %19 = load i64, ptr %background_duration, align 8
  %lastcmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 18
  %20 = load ptr, ptr %lastcmd, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %20, i64 0, i32 22
  %21 = load i64, ptr %microseconds, align 8
  %add = add i64 %21, %19
  store i64 %add, ptr %microseconds, align 8
  %module9 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 1
  %22 = load ptr, ptr %module9, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %22, i64 0, i32 13
  %23 = load i32, ptr %blocked_clients, align 8
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %blocked_clients, align 8
  call void @zfree(ptr noundef nonnull %0) #32
  br label %return

return:                                           ; preds = %entry, %moduleInvokeFreePrivDataCallback.exit
  %retval.0 = phi i32 [ %result.0, %moduleInvokeFreePrivDataCallback.exit ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @checkModuleAuthentication(ptr noundef %c, ptr noundef %username, ptr noundef %password, ptr noundef %err) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @moduleAuthCallbacks, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len, align 8
  %tobool.not = icmp eq i64 %1, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call i32 @attemptBlockedAuthReplyCallback(ptr noundef %c, ptr noundef %username, ptr noundef %password, ptr noundef %err)
  %cmp = icmp eq i32 %call, 1
  br i1 %cmp, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %call2 = tail call i32 @attemptNextAuthCb(ptr noundef %c, ptr noundef %username, ptr noundef %password, ptr noundef %err)
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %result.0 = phi i32 [ %call2, %if.then1 ], [ %call, %if.end ]
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %2 = load i64, ptr %flags, align 8
  %and = and i64 %2, 16
  %tobool4.not = icmp eq i64 %and, 0
  br i1 %tobool4.not, label %if.end9, label %if.then5

if.then5:                                         ; preds = %if.end3
  %cmp6 = icmp eq i32 %result.0, 0
  br i1 %cmp6, label %return, label %cond.false

cond.false:                                       ; preds = %if.then5
  tail call void @_serverAssert(ptr noundef nonnull @.str.74, ptr noundef nonnull @.str.2, i32 noundef 7949) #32
  tail call void @abort() #35
  unreachable

if.end9:                                          ; preds = %if.end3
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 67
  store ptr null, ptr %module_auth_ctx, align 8
  %cmp10 = icmp eq i32 %result.0, 1
  br i1 %cmp10, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end9
  %and14 = and i64 %2, -140737488355345
  store i64 %and14, ptr %flags, align 8
  br label %return

if.end15:                                         ; preds = %if.end9
  %and17 = and i64 %2, 140737488355328
  %tobool18.not = icmp eq i64 %and17, 0
  br i1 %tobool18.not, label %if.end25, label %if.then19

if.then19:                                        ; preds = %if.end15
  %and21 = and i64 %2, -140737488355345
  store i64 %and21, ptr %flags, align 8
  %authenticated = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 34
  %3 = load i32, ptr %authenticated, align 8
  %tobool22.not = icmp eq i32 %3, 0
  br i1 %tobool22.not, label %if.end25, label %return

if.end25:                                         ; preds = %if.then19, %if.end15
  br label %return

return:                                           ; preds = %if.then19, %if.then5, %entry, %if.end25, %if.then12
  %retval.0 = phi i32 [ 2, %if.then12 ], [ 1, %if.end25 ], [ 2, %entry ], [ 3, %if.then5 ], [ 0, %if.then19 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleTryServeClientBlockedOnKey(ptr nocapture noundef readonly %c, ptr noundef %key) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %module_blocked_handle = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55, i32 7
  %0 = load ptr, ptr %module_blocked_handle, align 8
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 12
  %1 = load i32, ptr %unblocked, align 8
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %3 = getelementptr inbounds i8, ptr %ctx, i64 16
  %4 = getelementptr inbounds i8, ptr %ctx, i64 32
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %4, i8 0, i64 88, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %2, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 4, ptr %flags.i, align 8
  %5 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %5, 0
  %6 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %6() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %7
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %8, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %9, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %blocked_ready_key = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 11
  store ptr %key, ptr %blocked_ready_key, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 7
  %10 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 10
  store ptr %10, ptr %blocked_privdata, align 8
  %11 = load ptr, ptr %0, align 8
  store ptr %11, ptr %3, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  store ptr %0, ptr %blocked_client, align 8
  %reply_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 2
  %12 = load ptr, ptr %reply_callback, align 8
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %13 = load ptr, ptr %argv, align 8
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %14 = load i32, ptr %argc, align 8
  %call = call i32 %12(ptr noundef nonnull %ctx, ptr noundef %13, i32 noundef %14) #32
  %cmp = icmp eq i32 %call, 0
  %spec.select = zext i1 %cmp to i32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %return

return:                                           ; preds = %entry, %moduleCreateContext.exit
  %retval.0 = phi i32 [ %spec.select, %moduleCreateContext.exit ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_BlockClient(ptr nocapture noundef readonly %ctx, ptr noundef %reply_callback, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms) #0 {
entry:
  %call = tail call ptr @moduleBlockClient(ptr noundef %ctx, ptr noundef %reply_callback, ptr noundef null, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef null, i32 noundef 0, ptr noundef null, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_BlockClientOnAuth(ptr nocapture noundef readonly %ctx, ptr noundef %reply_callback, ptr noundef %free_privdata) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 67
  %1 = load ptr, ptr %module_auth_ctx, align 8
  %cmp.not = icmp eq ptr %1, null
  br i1 %cmp.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @addReplyError(ptr noundef nonnull %0, ptr noundef nonnull @.str.75) #32
  br label %return

if.end:                                           ; preds = %entry
  %call = tail call ptr @moduleBlockClient(ptr noundef nonnull %ctx, ptr noundef null, ptr noundef %reply_callback, ptr noundef null, ptr noundef %free_privdata, i64 noundef 0, ptr noundef null, i32 noundef 0, ptr noundef null, i32 noundef 0)
  %2 = load ptr, ptr %client, align 8
  %flags = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 1
  %3 = load i64, ptr %flags, align 8
  %and = and i64 %3, 16
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %return, label %if.then3

if.then3:                                         ; preds = %if.end
  %or = or i64 %3, 1073741824
  store i64 %or, ptr %flags, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then3, %if.then
  %retval.0 = phi ptr [ null, %if.then ], [ %call, %if.then3 ], [ %call, %if.end ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_BlockClientGetPrivateData(ptr nocapture noundef readonly %blocked_client) #6 {
entry:
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %blocked_client, i64 0, i32 7
  %0 = load ptr, ptr %privdata, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define dso_local void @RM_BlockClientSetPrivateData(ptr nocapture noundef writeonly %blocked_client, ptr noundef %private_data) #23 {
entry:
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %blocked_client, i64 0, i32 7
  store ptr %private_data, ptr %privdata, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_BlockClientOnKeys(ptr nocapture noundef readonly %ctx, ptr noundef %reply_callback, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef %keys, i32 noundef %numkeys, ptr noundef %privdata) #0 {
entry:
  %call = tail call ptr @moduleBlockClient(ptr noundef %ctx, ptr noundef %reply_callback, ptr noundef null, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef %keys, i32 noundef %numkeys, ptr noundef %privdata, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_BlockClientOnKeysWithFlags(ptr nocapture noundef readonly %ctx, ptr noundef %reply_callback, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef %keys, i32 noundef %numkeys, ptr noundef %privdata, i32 noundef %flags) #0 {
entry:
  %call = tail call ptr @moduleBlockClient(ptr noundef %ctx, ptr noundef %reply_callback, ptr noundef null, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef %keys, i32 noundef %numkeys, ptr noundef %privdata, i32 noundef %flags)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SignalKeyAsReady(ptr nocapture noundef readonly %ctx, ptr noundef %key) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db, align 8
  tail call void @signalKeyAsReady(ptr noundef %1, ptr noundef %key, i32 noundef 5) #32
  ret void
}

declare void @signalKeyAsReady(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleUnblockClientByHandle(ptr noundef %bc, ptr noundef %privdata) local_unnamed_addr #0 {
entry:
  %call = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 11
  %0 = load i32, ptr %blocked_on_keys, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %privdata1 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 7
  store ptr %privdata, ptr %privdata1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 12
  store i32 1, ptr %unblocked, align 8
  %1 = load ptr, ptr @moduleUnblockedClients, align 8
  %len = getelementptr inbounds %struct.list, ptr %1, i64 0, i32 5
  %2 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 41, i64 1), align 4
  %call3 = tail call i64 @write(i32 noundef %3, ptr noundef nonnull @.str.76, i64 noundef 1) #32
  %.pre = load ptr, ptr @moduleUnblockedClients, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then2, %if.end
  %4 = phi ptr [ %.pre, %if.then2 ], [ %1, %if.end ]
  %call8 = tail call ptr @listAddNodeTail(ptr noundef %4, ptr noundef nonnull %bc) #32
  %call9 = tail call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_lock(ptr noundef) local_unnamed_addr #25

; Function Attrs: nofree
declare noundef i64 @write(i32 noundef, ptr nocapture noundef readonly, i64 noundef) local_unnamed_addr #26

; Function Attrs: nounwind
declare i32 @pthread_mutex_unlock(ptr noundef) local_unnamed_addr #25

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @moduleClientIsBlockedOnKeys(ptr nocapture noundef readonly %c) local_unnamed_addr #11 {
entry:
  %module_blocked_handle = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55, i32 7
  %0 = load ptr, ptr %module_blocked_handle, align 8
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 11
  %1 = load i32, ptr %blocked_on_keys, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_UnblockClient(ptr noundef %bc, ptr noundef %privdata) #0 {
entry:
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 11
  %0 = load i32, ptr %blocked_on_keys, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end9, label %if.then

if.then:                                          ; preds = %entry
  %timeout_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 4
  %1 = load ptr, ptr %timeout_callback, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %if.then
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 12
  %2 = load i32, ptr %unblocked, align 8
  %tobool2.not = icmp eq i32 %2, 0
  br i1 %tobool2.not, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %bc, align 8
  %tobool5.not = icmp eq ptr %3, null
  br i1 %tobool5.not, label %if.end9, label %if.then6

if.then6:                                         ; preds = %if.end4
  tail call void @moduleBlockedClientTimedOut(ptr noundef nonnull %3)
  br label %if.end9

if.end9:                                          ; preds = %if.end4, %if.then6, %entry
  %call.i = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  %4 = load i32, ptr %blocked_on_keys, align 4
  %tobool.not.i = icmp eq i32 %4, 0
  br i1 %tobool.not.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %if.end9
  %privdata1.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 7
  store ptr %privdata, ptr %privdata1.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.end9
  %unblocked.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 12
  store i32 1, ptr %unblocked.i, align 8
  %5 = load ptr, ptr @moduleUnblockedClients, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %5, i64 0, i32 5
  %6 = load i64, ptr %len.i, align 8
  %cmp.i = icmp eq i64 %6, 0
  br i1 %cmp.i, label %if.then2.i, label %moduleUnblockClientByHandle.exit

if.then2.i:                                       ; preds = %if.end.i
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 41, i64 1), align 4
  %call3.i = tail call i64 @write(i32 noundef %7, ptr noundef nonnull @.str.76, i64 noundef 1) #32
  %.pre.i = load ptr, ptr @moduleUnblockedClients, align 8
  br label %moduleUnblockClientByHandle.exit

moduleUnblockClientByHandle.exit:                 ; preds = %if.end.i, %if.then2.i
  %8 = phi ptr [ %.pre.i, %if.then2.i ], [ %5, %if.end.i ]
  %call8.i = tail call ptr @listAddNodeTail(ptr noundef %8, ptr noundef nonnull %bc) #32
  %call9.i = tail call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  br label %return

return:                                           ; preds = %if.end, %if.then, %moduleUnblockClientByHandle.exit
  %retval.0 = phi i32 [ 0, %moduleUnblockClientByHandle.exit ], [ 1, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleBlockedClientTimedOut(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %module_blocked_handle = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55, i32 7
  %0 = load ptr, ptr %module_blocked_handle, align 8
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 12
  %1 = load i32, ptr %unblocked, align 8
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %3 = getelementptr inbounds i8, ptr %ctx, i64 16
  %4 = getelementptr inbounds i8, ptr %ctx, i64 32
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %4, i8 0, i64 88, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %2, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 8, ptr %flags.i, align 8
  %5 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %5, 0
  %6 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %6() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %7
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %8, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %9, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %10 = load ptr, ptr %0, align 8
  store ptr %10, ptr %3, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  store ptr %0, ptr %blocked_client, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 7
  %11 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 10
  store ptr %11, ptr %blocked_privdata, align 8
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  %timeout_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 4
  %13 = load ptr, ptr %timeout_callback, align 8
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %14 = load ptr, ptr %argv, align 8
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %15 = load i32, ptr %argc, align 8
  %call = call i32 %13(ptr noundef nonnull %ctx, ptr noundef %14, i32 noundef %15) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 14
  %16 = load i64, ptr %background_duration, align 8
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  %cmp = icmp ne i64 %17, %12
  %conv = zext i1 %cmp to i32
  call void @updateStatsOnUnblock(ptr noundef nonnull %c, i64 noundef %16, i64 noundef 0, i32 noundef %conv) #32
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i64 0, i32 5
  store ptr null, ptr %disconnect_callback, align 8
  br label %return

return:                                           ; preds = %entry, %moduleCreateContext.exit
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_AbortBlock(ptr noundef %bc) #0 {
entry:
  %reply_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 2
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 5
  store ptr null, ptr %disconnect_callback, align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %reply_callback, i8 0, i64 16, i1 false)
  %call = tail call i32 @RM_UnblockClient(ptr noundef %bc, ptr noundef null), !range !22
  ret i32 %call
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define dso_local void @RM_SetDisconnectCallback(ptr nocapture noundef writeonly %bc, ptr noundef %callback) #23 {
entry:
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 5
  store ptr %callback, ptr %disconnect_callback, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleHandleBlockedClients() local_unnamed_addr #0 {
entry:
  %ctx.i42 = alloca %struct.RedisModuleCtx, align 8
  %ctx.i = alloca %struct.RedisModuleCtx, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %call = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  %0 = load ptr, ptr @moduleUnblockedClients, align 8
  %len72 = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len72, align 8
  %tobool.not73 = icmp eq i64 %1, 0
  br i1 %tobool.not73, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %2 = getelementptr inbounds i8, ptr %ctx, i64 16
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 10
  %blocked_ready_key = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 11
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %blocked_privdata.i50 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.i42, i64 0, i32 10
  %client3.i51 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.i42, i64 0, i32 2
  %4 = getelementptr inbounds i8, ptr %ctx.i, i64 16
  %module1.i53 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.i, i64 0, i32 1
  %flags.i54 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.i, i64 0, i32 7
  %5 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.i, i64 0, i32 14
  %blocked_privdata.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx.i, i64 0, i32 10
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end51
  %6 = phi ptr [ %0, %while.body.lr.ph ], [ %57, %if.end51 ]
  %7 = load ptr, ptr %6, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %value, align 8
  %9 = load ptr, ptr %8, align 8
  call void @listDelNode(ptr noundef nonnull %6, ptr noundef %7) #32
  %call1 = call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  %tobool2.not = icmp eq ptr %9, null
  br i1 %tobool2.not, label %if.end.split, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 11
  %11 = load i32, ptr %blocked_on_keys, align 4
  %tobool3.not = icmp eq i32 %11, 0
  br i1 %tobool3.not, label %land.lhs.true4, label %land.lhs.true12

land.lhs.true4:                                   ; preds = %land.lhs.true
  %reply_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 2
  %12 = load ptr, ptr %reply_callback, align 8
  %tobool5.not = icmp eq ptr %12, null
  br i1 %tobool5.not, label %land.lhs.true12, label %if.then

if.then:                                          ; preds = %land.lhs.true4
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 1
  %13 = load ptr, ptr %module, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  store ptr %13, ptr %module1.i, align 8
  store i32 4, ptr %flags.i, align 8
  %14 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %14, 0
  %15 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = call i64 %15() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.then
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %16
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.then
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %17, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  store i64 %add.sink.i, ptr %3, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 7
  %18 = load ptr, ptr %privdata, align 8
  store ptr %18, ptr %blocked_privdata, align 8
  store ptr null, ptr %blocked_ready_key, align 8
  %19 = load ptr, ptr %8, align 8
  store ptr %19, ptr %2, align 8
  store ptr %8, ptr %blocked_client, align 8
  %20 = load ptr, ptr @getMonotonicUs, align 8
  %call.i = call i64 %20() #32
  %21 = load ptr, ptr %reply_callback, align 8
  %argv = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 12
  %22 = load ptr, ptr %argv, align 8
  %argc = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 11
  %23 = load i32, ptr %argc, align 8
  %call9 = call i32 %21(ptr noundef nonnull %ctx, ptr noundef %22, i32 noundef %23) #32
  %24 = load ptr, ptr @getMonotonicUs, align 8
  %call.i41 = call i64 %24() #32
  %sub.i = sub i64 %call.i41, %call.i
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %land.lhs.true12

if.end.split:                                     ; preds = %while.body
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %ctx.i)
  %privdata.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 7
  %25 = load ptr, ptr %privdata.i, align 8
  %tobool.not.i = icmp eq ptr %25, null
  br i1 %tobool.not.i, label %if.end28, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end.split
  %free_privdata.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 6
  %26 = load ptr, ptr %free_privdata.i, align 8
  %tobool1.not.i = icmp eq ptr %26, null
  br i1 %tobool1.not.i, label %if.end28, label %if.then.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %module.i = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 1
  %27 = load ptr, ptr %module.i, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %4, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx.i, align 8
  store ptr %27, ptr %module1.i53, align 8
  store i32 32, ptr %flags.i54, align 8
  %28 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i55 = icmp eq i32 %28, 0
  %29 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i56 = call i64 %29() #32
  br i1 %tobool8.not.i55, label %if.else11.i62, label %if.then9.i57

if.then9.i57:                                     ; preds = %if.then.i
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i58 = sdiv i32 1000000, %30
  %conv.i59 = sext i32 %div.i58 to i64
  %add.i60 = add i64 %call12.i56, %conv.i59
  br label %moduleCreateContext.exit65

if.else11.i62:                                    ; preds = %if.then.i
  %31 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i63 = mul nsw i64 %31, 1000
  %add13.i64 = add i64 %mul.i63, %call12.i56
  br label %moduleCreateContext.exit65

moduleCreateContext.exit65:                       ; preds = %if.then9.i57, %if.else11.i62
  %add.sink.i61 = phi i64 [ %add13.i64, %if.else11.i62 ], [ %add.i60, %if.then9.i57 ]
  store i64 %add.sink.i61, ptr %5, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %32 = load ptr, ptr %privdata.i, align 8
  store ptr %32, ptr %blocked_privdata.i, align 8
  %33 = load ptr, ptr %8, align 8
  store ptr %33, ptr %4, align 8
  %34 = load ptr, ptr %free_privdata.i, align 8
  call void %34(ptr noundef nonnull %ctx.i, ptr noundef %32) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx.i)
  br label %if.end28

land.lhs.true12:                                  ; preds = %moduleCreateContext.exit, %land.lhs.true4, %land.lhs.true
  %reply_us.0.ph = phi i64 [ 0, %land.lhs.true4 ], [ %sub.i, %moduleCreateContext.exit ], [ 0, %land.lhs.true ]
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 67
  %35 = load ptr, ptr %module_auth_ctx, align 8
  %cmp.not = icmp eq ptr %35, null
  br i1 %cmp.not, label %land.lhs.true12.split, label %if.then13

land.lhs.true12.split:                            ; preds = %land.lhs.true12
  call void @llvm.lifetime.start.p0(i64 120, ptr nonnull %ctx.i42)
  %privdata.i43 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 7
  %36 = load ptr, ptr %privdata.i43, align 8
  %tobool.not.i44 = icmp eq ptr %36, null
  br i1 %tobool.not.i44, label %moduleInvokeFreePrivDataCallback.exit52, label %land.lhs.true.i45

land.lhs.true.i45:                                ; preds = %land.lhs.true12.split
  %free_privdata.i46 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 6
  %37 = load ptr, ptr %free_privdata.i46, align 8
  %tobool1.not.i47 = icmp eq ptr %37, null
  br i1 %tobool1.not.i47, label %moduleInvokeFreePrivDataCallback.exit52, label %if.then.i48

if.then.i48:                                      ; preds = %land.lhs.true.i45
  %module.i49 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 1
  %38 = load ptr, ptr %module.i49, align 8
  call void @moduleCreateContext(ptr noundef nonnull %ctx.i42, ptr noundef %38, i32 noundef 0)
  %39 = load ptr, ptr %privdata.i43, align 8
  store ptr %39, ptr %blocked_privdata.i50, align 8
  %40 = load ptr, ptr %8, align 8
  store ptr %40, ptr %client3.i51, align 8
  %41 = load ptr, ptr %free_privdata.i46, align 8
  call void %41(ptr noundef nonnull %ctx.i42, ptr noundef %39) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx.i42)
  br label %moduleInvokeFreePrivDataCallback.exit52

moduleInvokeFreePrivDataCallback.exit52:          ; preds = %land.lhs.true12.split, %land.lhs.true.i45, %if.then.i48
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %ctx.i42)
  br label %if.then16

if.then13:                                        ; preds = %land.lhs.true12
  %module_blocked_client = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 66
  store ptr %8, ptr %module_blocked_client, align 8
  br label %if.then16

if.then16:                                        ; preds = %moduleInvokeFreePrivDataCallback.exit52, %if.then13
  %reply_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 9
  %42 = load ptr, ptr %reply_client, align 8
  call void @AddReplyFromClient(ptr noundef nonnull %9, ptr noundef %42) #32
  %43 = load ptr, ptr %reply_client, align 8
  call void @moduleReleaseTempClient(ptr noundef %43)
  %thread_safe_ctx_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 8
  %44 = load ptr, ptr %thread_safe_ctx_client, align 8
  call void @moduleReleaseTempClient(ptr noundef %44)
  %45 = load ptr, ptr %module_auth_ctx, align 8
  %cmp22.not = icmp eq ptr %45, null
  br i1 %cmp22.not, label %land.lhs.true23, label %if.then31

land.lhs.true23:                                  ; preds = %if.then16
  %46 = load i32, ptr %blocked_on_keys, align 4
  %tobool25.not = icmp eq i32 %46, 0
  br i1 %tobool25.not, label %if.then26, label %if.then31

if.then26:                                        ; preds = %land.lhs.true23
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 14
  %47 = load i64, ptr %background_duration, align 8
  %48 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  %cmp27 = icmp ne i64 %48, %10
  %conv = zext i1 %cmp27 to i32
  call void @updateStatsOnUnblock(ptr noundef nonnull %9, i64 noundef %47, i64 noundef %reply_us.0.ph, i32 noundef %conv) #32
  br label %if.then31

if.end28:                                         ; preds = %moduleCreateContext.exit65, %land.lhs.true.i, %if.end.split
  call void @llvm.lifetime.end.p0(i64 120, ptr nonnull %ctx.i)
  %reply_client18.c = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 9
  %49 = load ptr, ptr %reply_client18.c, align 8
  call void @moduleReleaseTempClient(ptr noundef %49)
  %thread_safe_ctx_client.c = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 8
  %50 = load ptr, ptr %thread_safe_ctx_client.c, align 8
  call void @moduleReleaseTempClient(ptr noundef %50)
  br label %if.then49

if.then31:                                        ; preds = %if.then26, %land.lhs.true23, %if.then16
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 5
  store ptr null, ptr %disconnect_callback, align 8
  call void @unblockClient(ptr noundef nonnull %9, i32 noundef 1) #32
  %51 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %woff = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 56
  store i64 %51, ptr %woff, align 8
  %52 = load ptr, ptr %module_auth_ctx, align 8
  %cmp33.not = icmp eq ptr %52, null
  br i1 %cmp33.not, label %land.lhs.true35, label %if.end51

land.lhs.true35:                                  ; preds = %if.then31
  %call36 = call i32 @clientHasPendingReplies(ptr noundef nonnull %9) #32
  %tobool37.not = icmp eq i32 %call36, 0
  br i1 %tobool37.not, label %land.lhs.true45, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %land.lhs.true35
  %flags = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 1
  %53 = load i64, ptr %flags, align 8
  %and = and i64 %53, 2097152
  %tobool39.not = icmp eq i64 %and, 0
  br i1 %tobool39.not, label %if.then40, label %land.lhs.true45

if.then40:                                        ; preds = %land.lhs.true38
  %or = or disjoint i64 %53, 2097152
  store i64 %or, ptr %flags, align 8
  %54 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 57), align 8
  %clients_pending_write_node = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 79
  call void @listLinkNodeHead(ptr noundef %54, ptr noundef nonnull %clients_pending_write_node) #32
  br label %land.lhs.true45

land.lhs.true45:                                  ; preds = %if.then40, %land.lhs.true38, %land.lhs.true35
  %.pr = load ptr, ptr %module_auth_ctx, align 8
  %cmp47.not = icmp eq ptr %.pr, null
  br i1 %cmp47.not, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.end28, %land.lhs.true45
  %module50 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i64 0, i32 1
  %55 = load ptr, ptr %module50, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %55, i64 0, i32 13
  %56 = load i32, ptr %blocked_clients, align 8
  %dec = add nsw i32 %56, -1
  store i32 %dec, ptr %blocked_clients, align 8
  call void @zfree(ptr noundef nonnull %8) #32
  br label %if.end51

if.end51:                                         ; preds = %if.then31, %if.then49, %land.lhs.true45
  %call52 = call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  %57 = load ptr, ptr @moduleUnblockedClients, align 8
  %len = getelementptr inbounds %struct.list, ptr %57, i64 0, i32 5
  %58 = load i64, ptr %len, align 8
  %tobool.not = icmp eq i64 %58, 0
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !50

while.end:                                        ; preds = %if.end51, %entry
  %call53 = call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleUnblockedClientsMutex) #32
  ret void
}

declare void @AddReplyFromClient(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @updateStatsOnUnblock(ptr noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #1

declare i32 @clientHasPendingReplies(ptr noundef) local_unnamed_addr #1

declare void @listLinkNodeHead(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @moduleBlockedClientMayTimeout(ptr nocapture noundef readonly %c) local_unnamed_addr #11 {
entry:
  %bstate = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55
  %0 = load i32, ptr %bstate, align 8
  %cmp.not = icmp eq i32 %0, 4
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %module_blocked_handle = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 55, i32 7
  %1 = load ptr, ptr %module_blocked_handle, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %return, label %land.rhs

land.rhs:                                         ; preds = %if.end
  %timeout_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %timeout_callback, align 8
  %cmp2 = icmp ne ptr %2, null
  %3 = zext i1 %cmp2 to i32
  br label %return

return:                                           ; preds = %if.end, %land.rhs, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %if.end ], [ %3, %land.rhs ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_IsBlockedReplyRequest(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = lshr i32 %0, 2
  %and.lobit = and i32 %and, 1
  ret i32 %and.lobit
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_IsBlockedTimeoutRequest(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = lshr i32 %0, 3
  %and.lobit = and i32 %and, 1
  ret i32 %and.lobit
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetBlockedClientPrivateData(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 10
  %0 = load ptr, ptr %blocked_privdata, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetBlockedClientReadyKey(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %blocked_ready_key = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 11
  %0 = load ptr, ptr %blocked_ready_key, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetBlockedClientHandle(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 3
  %0 = load ptr, ptr %blocked_client, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_BlockedClientDisconnected(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags, align 8
  %and = lshr i32 %0, 5
  %and.lobit = and i32 %and, 1
  ret i32 %and.lobit
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_GetThreadSafeContext(ptr noundef %bc) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(120) ptr @zmalloc(i64 noundef 120) #33
  %tobool.not = icmp eq ptr %bc, null
  br i1 %tobool.not, label %if.then.split, label %cond.end.split

cond.end.split:                                   ; preds = %entry
  %module1 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 1
  %0 = load ptr, ptr %module1, align 8
  %1 = getelementptr inbounds i8, ptr %call, i64 16
  %2 = getelementptr inbounds i8, ptr %call, i64 32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 88, i1 false)
  store ptr @RM_GetApi, ptr %call, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 1
  store ptr %0, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 7
  store i32 16, ptr %flags.i, align 8
  %3 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %3, 0
  %4 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %4() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %cond.end.split
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %5
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %if.then4

if.else11.i:                                      ; preds = %cond.end.split
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %6, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %if.then4

if.then.split:                                    ; preds = %entry
  %7 = getelementptr inbounds i8, ptr %call, i64 16
  %8 = getelementptr inbounds i8, ptr %call, i64 24
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %8, i8 0, i64 96, i1 false)
  store ptr @RM_GetApi, ptr %call, align 8
  %module1.i17 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 1
  store ptr null, ptr %module1.i17, align 8
  %flags.i18 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 7
  store i32 144, ptr %flags.i18, align 8
  %call5.i = tail call ptr @createClient(ptr noundef null) #32
  store ptr %call5.i, ptr %7, align 8
  %9 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i19 = icmp eq i32 %9, 0
  %10 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i20 = tail call i64 %10() #32
  br i1 %tobool8.not.i19, label %if.else11.i26, label %if.then9.i21

if.then9.i21:                                     ; preds = %if.then.split
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i22 = sdiv i32 1000000, %11
  %conv.i23 = sext i32 %div.i22 to i64
  %add.i24 = add i64 %call12.i20, %conv.i23
  br label %if.end.thread

if.else11.i26:                                    ; preds = %if.then.split
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i27 = mul nsw i64 %12, 1000
  %add13.i28 = add i64 %mul.i27, %call12.i20
  br label %if.end.thread

if.end.thread:                                    ; preds = %if.else11.i26, %if.then9.i21
  %add.sink.i25 = phi i64 [ %add13.i28, %if.else11.i26 ], [ %add.i24, %if.then9.i21 ]
  %13 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 14
  store i64 %add.sink.i25, ptr %13, align 8
  br label %if.end17

if.then4:                                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %14 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 14
  store i64 %add.sink.i, ptr %14, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 3
  store ptr %bc, ptr %blocked_client, align 8
  %thread_safe_ctx_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 8
  %15 = load ptr, ptr %thread_safe_ctx_client, align 8
  store ptr %15, ptr %1, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %bc, i64 0, i32 10
  %16 = load i32, ptr %dbid, align 8
  %call6 = tail call i32 @selectDb(ptr noundef %15, i32 noundef %16) #32
  %17 = load ptr, ptr %bc, align 8
  %tobool8.not = icmp eq ptr %17, null
  br i1 %tobool8.not, label %if.end17, label %if.then9

if.then9:                                         ; preds = %if.then4
  %18 = load i64, ptr %17, align 8
  store i64 %18, ptr %15, align 8
  %19 = load ptr, ptr %bc, align 8
  %resp = getelementptr inbounds %struct.client, ptr %19, i64 0, i32 3
  %20 = load i32, ptr %resp, align 8
  %resp15 = getelementptr inbounds %struct.client, ptr %15, i64 0, i32 3
  store i32 %20, ptr %resp15, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.end.thread, %if.then4, %if.then9
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_GetDetachedThreadSafeContext(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(120) ptr @zmalloc(i64 noundef 120) #33
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %1 = getelementptr inbounds i8, ptr %call, i64 16
  %2 = getelementptr inbounds i8, ptr %call, i64 24
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 96, i1 false)
  store ptr @RM_GetApi, ptr %call, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 1
  store ptr %0, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 7
  store i32 144, ptr %flags.i, align 8
  %call5.i = tail call ptr @createClient(ptr noundef null) #32
  store ptr %call5.i, ptr %1, align 8
  %3 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %3, 0
  %4 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %4() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %entry
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %5
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %entry
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %6, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %7 = getelementptr inbounds %struct.RedisModuleCtx, ptr %call, i64 0, i32 14
  store i64 %add.sink.i, ptr %7, align 8
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeThreadSafeContext(ptr noundef %ctx) #0 {
entry:
  tail call void @moduleFreeContext(ptr noundef %ctx)
  tail call void @zfree(ptr noundef %ctx) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleGILAfterLock() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.77, ptr noundef nonnull @.str.2, i32 noundef 8501) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ThreadSafeContextLock(ptr nocapture readnone %ctx) #0 {
entry:
  %call.i = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleGIL) #32
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %moduleGILAfterLock.exit, label %cond.false.i

cond.false.i:                                     ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.77, ptr noundef nonnull @.str.2, i32 noundef 8501) #32
  tail call void @abort() #35
  unreachable

moduleGILAfterLock.exit:                          ; preds = %entry
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleAcquireGIL() local_unnamed_addr #0 {
entry:
  %call = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleGIL) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ThreadSafeContextTryLock(ptr nocapture readnone %ctx) #0 {
entry:
  %call.i = tail call i32 @pthread_mutex_trylock(ptr noundef nonnull @moduleGIL) #32
  %cmp.not = icmp eq i32 %call.i, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = tail call ptr @__errno_location() #37
  store i32 %call.i, ptr %call1, align 4
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %cmp.i = icmp eq i32 %0, 0
  br i1 %cmp.i, label %moduleGILAfterLock.exit, label %cond.false.i

cond.false.i:                                     ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.77, ptr noundef nonnull @.str.2, i32 noundef 8501) #32
  tail call void @abort() #35
  unreachable

moduleGILAfterLock.exit:                          ; preds = %if.end
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  br label %return

return:                                           ; preds = %moduleGILAfterLock.exit, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 0, %moduleGILAfterLock.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleTryAcquireGIL() local_unnamed_addr #0 {
entry:
  %call = tail call i32 @pthread_mutex_trylock(ptr noundef nonnull @moduleGIL) #32
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleGILBeforeUnlock() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.78, ptr noundef nonnull @.str.2, i32 noundef 8538) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  tail call void @exitExecutionUnit() #32
  tail call void @postExecutionUnitOperations() #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ThreadSafeContextUnlock(ptr nocapture readnone %ctx) #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %cmp.i = icmp eq i32 %0, 1
  br i1 %cmp.i, label %moduleGILBeforeUnlock.exit, label %cond.false.i

cond.false.i:                                     ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.78, ptr noundef nonnull @.str.2, i32 noundef 8538) #32
  tail call void @abort() #35
  unreachable

moduleGILBeforeUnlock.exit:                       ; preds = %entry
  tail call void @exitExecutionUnit() #32
  tail call void @postExecutionUnitOperations() #32
  %call.i = tail call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleGIL) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleReleaseGIL() local_unnamed_addr #0 {
entry:
  %call = tail call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleGIL) #32
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_trylock(ptr noundef) local_unnamed_addr #25

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SubscribeToKeyspaceEvents(ptr nocapture noundef readonly %ctx, i32 noundef %types, ptr noundef %callback) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(24) ptr @zmalloc(i64 noundef 24) #33
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  store ptr %0, ptr %call, align 8
  %event_mask = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %call, i64 0, i32 2
  store i32 %types, ptr %event_mask, align 8
  %notify_callback = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %call, i64 0, i32 1
  store ptr %callback, ptr %notify_callback, align 8
  %active = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %call, i64 0, i32 3
  store i32 0, ptr %active, align 4
  %1 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  %call2 = tail call ptr @listAddNodeTail(ptr noundef %1, ptr noundef nonnull %call) #32
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local void @firePostExecutionUnitJobs() local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  tail call void @enterExecutionUnit(i32 noundef 0, i64 noundef 0) #32
  %0 = load ptr, ptr @modulePostExecUnitJobs, align 8
  %len9 = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len9, align 8
  %cmp.not10 = icmp eq i64 %1, 0
  br i1 %cmp.not10, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %2 = getelementptr inbounds i8, ptr %ctx, i64 16
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end
  %4 = phi ptr [ %0, %while.body.lr.ph ], [ %23, %if.end ]
  %5 = load ptr, ptr %4, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %value, align 8
  call void @listDelNode(ptr noundef nonnull %4, ptr noundef %5) #32
  %7 = load ptr, ptr %6, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  store ptr %7, ptr %module1.i, align 8
  store i32 64, ptr %flags.i, align 8
  %8 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i.i = icmp eq i64 %8, 0
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %while.body
  %9 = load ptr, ptr @moduleTempClients, align 8
  %dec.i.i = add i64 %8, -1
  store i64 %dec.i.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %9, i64 %dec.i.i
  %10 = load ptr, ptr %arrayidx.i.i, align 8
  %11 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i.i = icmp ult i64 %dec.i.i, %11
  br i1 %cmp1.i.i, label %if.then2.i.i, label %if.end7.sink.split.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  store i64 %dec.i.i, ptr @moduleTempClientMinCount, align 8
  br label %if.end7.sink.split.i

if.else.i.i:                                      ; preds = %while.body
  %call.i.i = call ptr @createClient(ptr noundef null) #32
  %flags.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 1
  %12 = load i64, ptr %flags.i.i, align 8
  %or.i.i = or i64 %12, 134217728
  store i64 %or.i.i, ptr %flags.i.i, align 8
  %user.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 20
  store ptr null, ptr %user.i.i, align 8
  br label %if.end7.sink.split.i

if.end7.sink.split.i:                             ; preds = %if.else.i.i, %if.then2.i.i, %if.then.i.i
  %call5.sink.i = phi ptr [ %10, %if.then2.i.i ], [ %10, %if.then.i.i ], [ %call.i.i, %if.else.i.i ]
  store ptr %call5.sink.i, ptr %2, align 8
  %13 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %13, 0
  %14 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = call i64 %14() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end7.sink.split.i
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %15
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end7.sink.split.i
  %16 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %16, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  store i64 %add.sink.i, ptr %3, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %17 = load ptr, ptr %2, align 8
  %dbid = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %6, i64 0, i32 4
  %18 = load i32, ptr %dbid, align 8
  %call = call i32 @selectDb(ptr noundef %17, i32 noundef %18) #32
  %callback = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %6, i64 0, i32 1
  %19 = load ptr, ptr %callback, align 8
  %pd = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %6, i64 0, i32 2
  %20 = load ptr, ptr %pd, align 8
  call void %19(ptr noundef nonnull %ctx, ptr noundef %20) #32
  %free_pd = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %6, i64 0, i32 3
  %21 = load ptr, ptr %free_pd, align 8
  %tobool.not = icmp eq ptr %21, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %moduleCreateContext.exit
  %22 = load ptr, ptr %pd, align 8
  call void %21(ptr noundef %22) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %moduleCreateContext.exit
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  call void @zfree(ptr noundef nonnull %6) #32
  %23 = load ptr, ptr @modulePostExecUnitJobs, align 8
  %len = getelementptr inbounds %struct.list, ptr %23, i64 0, i32 5
  %24 = load i64, ptr %len, align 8
  %cmp.not = icmp eq i64 %24, 0
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !51

while.end:                                        ; preds = %if.end, %entry
  call void @exitExecutionUnit() #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_AddPostNotificationJob(ptr nocapture noundef readonly %ctx, ptr noundef %callback, ptr noundef %privdata, ptr noundef %free_privdata) #0 {
entry:
  %0 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %tobool1 = icmp ne ptr %1, null
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 298), align 4
  %tobool2 = icmp ne i32 %2, 0
  %or.cond = select i1 %tobool1, i1 %tobool2, i1 false
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call = tail call noalias dereferenceable_or_null(40) ptr @zmalloc(i64 noundef 40) #33
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %3 = load ptr, ptr %module, align 8
  store ptr %3, ptr %call, align 8
  %callback4 = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %call, i64 0, i32 1
  store ptr %callback, ptr %callback4, align 8
  %pd = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %call, i64 0, i32 2
  store ptr %privdata, ptr %pd, align 8
  %free_pd = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %call, i64 0, i32 3
  store ptr %free_privdata, ptr %free_pd, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %4 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %4, i64 0, i32 4
  %5 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %5, i64 0, i32 6
  %6 = load i32, ptr %id, align 8
  %dbid = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %call, i64 0, i32 4
  store i32 %6, ptr %dbid, align 8
  %7 = load ptr, ptr @modulePostExecUnitJobs, align 8
  %call5 = tail call ptr @listAddNodeTail(ptr noundef %7, ptr noundef nonnull %call) #32
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable
define dso_local i32 @RM_GetNotifyKeyspaceEvents() #13 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 359), align 8
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_NotifyKeyspaceEvent(ptr noundef readonly %ctx, i32 noundef %type, ptr noundef %event, ptr noundef %key) #0 {
entry:
  %tobool.not = icmp eq ptr %ctx, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %db = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %1, i64 0, i32 6
  %2 = load i32, ptr %id, align 8
  tail call void @notifyKeyspaceEvent(i32 noundef %type, ptr noundef %event, ptr noundef %key, i32 noundef %2) #32
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @notifyKeyspaceEvent(i32 noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleNotifyKeyspaceEvent(i32 noundef %type, ptr noundef %event, ptr noundef %key, i32 noundef %dbid) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %0 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  tail call void @enterExecutionUnit(i32 noundef 0, i64 noundef 0) #32
  %2 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  call void @listRewind(ptr noundef %2, ptr noundef nonnull %li) #32
  %and = and i32 %type, -4
  %call10 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not11 = icmp eq ptr %call10, null
  br i1 %tobool.not11, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end
  %3 = getelementptr inbounds i8, ptr %ctx, i64 16
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %4 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end13
  %call12 = phi ptr [ %call10, %while.body.lr.ph ], [ %call, %if.end13 ]
  %value = getelementptr inbounds %struct.listNode, ptr %call12, i64 0, i32 2
  %5 = load ptr, ptr %value, align 8
  %event_mask = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %5, i64 0, i32 2
  %6 = load i32, ptr %event_mask, align 8
  %and1 = and i32 %6, %and
  %tobool2.not = icmp eq i32 %and1, 0
  br i1 %tobool2.not, label %if.end13, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body
  %active = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %5, i64 0, i32 3
  %7 = load i32, ptr %active, align 4
  %cmp3 = icmp eq i32 %7, 0
  %.pre = load ptr, ptr %5, align 8
  br i1 %cmp3, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %options = getelementptr inbounds %struct.RedisModule, ptr %.pre, i64 0, i32 12
  %8 = load i32, ptr %options, align 4
  %and4 = and i32 %8, 8
  %tobool5.not = icmp eq i32 %and4, 0
  br i1 %tobool5.not, label %if.end13, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false, %land.lhs.true
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %3, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  store ptr %.pre, ptr %module1.i, align 8
  store i32 64, ptr %flags.i, align 8
  %9 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i.i = icmp eq i64 %9, 0
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then6
  %10 = load ptr, ptr @moduleTempClients, align 8
  %dec.i.i = add i64 %9, -1
  store i64 %dec.i.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %10, i64 %dec.i.i
  %11 = load ptr, ptr %arrayidx.i.i, align 8
  %12 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i.i = icmp ult i64 %dec.i.i, %12
  br i1 %cmp1.i.i, label %if.then2.i.i, label %if.end7.sink.split.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  store i64 %dec.i.i, ptr @moduleTempClientMinCount, align 8
  br label %if.end7.sink.split.i

if.else.i.i:                                      ; preds = %if.then6
  %call.i.i = call ptr @createClient(ptr noundef null) #32
  %flags.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 1
  %13 = load i64, ptr %flags.i.i, align 8
  %or.i.i = or i64 %13, 134217728
  store i64 %or.i.i, ptr %flags.i.i, align 8
  %user.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 20
  store ptr null, ptr %user.i.i, align 8
  br label %if.end7.sink.split.i

if.end7.sink.split.i:                             ; preds = %if.else.i.i, %if.then2.i.i, %if.then.i.i
  %call5.sink.i = phi ptr [ %11, %if.then2.i.i ], [ %11, %if.then.i.i ], [ %call.i.i, %if.else.i.i ]
  store ptr %call5.sink.i, ptr %3, align 8
  %14 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %14, 0
  %15 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = call i64 %15() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end7.sink.split.i
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %16
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end7.sink.split.i
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %17, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  store i64 %add.sink.i, ptr %4, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %18 = load ptr, ptr %3, align 8
  %call8 = call i32 @selectDb(ptr noundef %18, i32 noundef %dbid) #32
  %19 = load i32, ptr %active, align 4
  store i32 1, ptr %active, align 4
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  %inc = add nsw i32 %20, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  %notify_callback = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %5, i64 0, i32 1
  %21 = load ptr, ptr %notify_callback, align 8
  %call11 = call i32 %21(ptr noundef nonnull %ctx, i32 noundef %and, ptr noundef %event, ptr noundef %key) #32
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  %dec = add nsw i32 %22, -1
  store i32 %dec, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  store i32 %19, ptr %active, align 4
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %if.end13

if.end13:                                         ; preds = %moduleCreateContext.exit, %lor.lhs.false, %while.body
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !52

while.end:                                        ; preds = %if.end13, %if.end
  call void @exitExecutionUnit() #32
  br label %return

return:                                           ; preds = %entry, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnsubscribeNotifications(ptr noundef readnone %module) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #32
  %call3 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not4 = icmp eq ptr %call3, null
  br i1 %tobool.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call5 = phi ptr [ %call, %if.end ], [ %call3, %entry ]
  %value = getelementptr inbounds %struct.listNode, ptr %call5, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp = icmp eq ptr %2, %module
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %3 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  call void @listDelNode(ptr noundef %3, ptr noundef nonnull %call5) #32
  call void @zfree(ptr noundef nonnull %1) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !53

while.end:                                        ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleCallClusterReceivers(ptr noundef %sender_id, i64 noundef %module_id, i8 noundef zeroext %type, ptr noundef %payload, i32 noundef %len) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %idxprom = zext i8 %type to i64
  %arrayidx = getelementptr inbounds [255 x ptr], ptr @clusterReceivers, i64 0, i64 %idxprom
  %r.07 = load ptr, ptr %arrayidx, align 8
  %tobool.not8 = icmp eq ptr %r.07, null
  br i1 %tobool.not8, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %r.09 = phi ptr [ %r.0, %if.end ], [ %r.07, %entry ]
  %0 = load i64, ptr %r.09, align 8
  %cmp = icmp eq i64 %0, %module_id
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %module = getelementptr inbounds %struct.moduleClusterReceiver, ptr %r.09, i64 0, i32 2
  %1 = load ptr, ptr %module, align 8
  %2 = getelementptr inbounds i8, ptr %ctx, i64 16
  %3 = getelementptr inbounds i8, ptr %ctx, i64 24
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %3, i8 0, i64 96, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr %1, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 64, ptr %flags.i, align 8
  %4 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i.i = icmp eq i64 %4, 0
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then
  %5 = load ptr, ptr @moduleTempClients, align 8
  %dec.i.i = add i64 %4, -1
  store i64 %dec.i.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %5, i64 %dec.i.i
  %6 = load ptr, ptr %arrayidx.i.i, align 8
  %7 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i.i = icmp ult i64 %dec.i.i, %7
  br i1 %cmp1.i.i, label %if.then2.i.i, label %if.end7.sink.split.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  store i64 %dec.i.i, ptr @moduleTempClientMinCount, align 8
  br label %if.end7.sink.split.i

if.else.i.i:                                      ; preds = %if.then
  %call.i.i = tail call ptr @createClient(ptr noundef null) #32
  %flags.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 1
  %8 = load i64, ptr %flags.i.i, align 8
  %or.i.i = or i64 %8, 134217728
  store i64 %or.i.i, ptr %flags.i.i, align 8
  %user.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 20
  store ptr null, ptr %user.i.i, align 8
  br label %if.end7.sink.split.i

if.end7.sink.split.i:                             ; preds = %if.else.i.i, %if.then2.i.i, %if.then.i.i
  %call5.sink.i = phi ptr [ %6, %if.then2.i.i ], [ %6, %if.then.i.i ], [ %call.i.i, %if.else.i.i ]
  store ptr %call5.sink.i, ptr %2, align 8
  %9 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %9, 0
  %10 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %10() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end7.sink.split.i
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %11
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end7.sink.split.i
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %12, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %13 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %13, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %callback = getelementptr inbounds %struct.moduleClusterReceiver, ptr %r.09, i64 0, i32 1
  %14 = load ptr, ptr %callback, align 8
  call void %14(ptr noundef nonnull %ctx, ptr noundef %sender_id, i8 noundef zeroext %type, ptr noundef %payload, i32 noundef %len) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %while.end

if.end:                                           ; preds = %while.body
  %next = getelementptr inbounds %struct.moduleClusterReceiver, ptr %r.09, i64 0, i32 3
  %r.0 = load ptr, ptr %next, align 8
  %tobool.not = icmp eq ptr %r.0, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !54

while.end:                                        ; preds = %if.end, %entry, %moduleCreateContext.exit
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_RegisterClusterMessageReceiver(ptr nocapture noundef readonly %ctx, i8 noundef zeroext %type, ptr noundef %callback) #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end31, label %if.end

if.end:                                           ; preds = %entry
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %name, align 8
  %3 = load ptr, ptr @ModuleTypeNameCharSet, align 8
  %call.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %2) #36
  %cmp.not.i.not = icmp eq i64 %call.i, 9
  br i1 %cmp.not.i.not, label %for.cond.preheader.i, label %moduleTypeEncodeId.exit

for.cond.preheader.i:                             ; preds = %if.end
  %sub.ptr.rhs.cast.i = ptrtoint ptr %3 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %if.end8.i, %for.cond.preheader.i
  %indvars.iv.i = phi i64 [ 0, %for.cond.preheader.i ], [ %indvars.iv.next.i, %if.end8.i ]
  %id.013.i = phi i64 [ 0, %for.cond.preheader.i ], [ %or.i, %if.end8.i ]
  %arrayidx.i = getelementptr inbounds i8, ptr %2, i64 %indvars.iv.i
  %4 = load i8, ptr %arrayidx.i, align 1
  %conv.i = sext i8 %4 to i32
  %call6.i = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %3, i32 noundef %conv.i) #36
  %tobool.not.i = icmp eq ptr %call6.i, null
  br i1 %tobool.not.i, label %moduleTypeEncodeId.exit, label %if.end8.i

if.end8.i:                                        ; preds = %for.body.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %call6.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %shl.i = shl i64 %id.013.i, 6
  %or.i = or i64 %sub.ptr.sub.i, %shl.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 9
  br i1 %exitcond.not.i, label %for.end.i, label %for.body.i, !llvm.loop !36

for.end.i:                                        ; preds = %if.end8.i
  %shl9.i = shl i64 %or.i, 10
  br label %moduleTypeEncodeId.exit

moduleTypeEncodeId.exit:                          ; preds = %for.body.i, %if.end, %for.end.i
  %retval.0.i = phi i64 [ %shl9.i, %for.end.i ], [ 0, %if.end ], [ 0, %for.body.i ]
  %idxprom = zext i8 %type to i64
  %arrayidx = getelementptr inbounds [255 x ptr], ptr @clusterReceivers, i64 0, i64 %idxprom
  %r.024 = load ptr, ptr %arrayidx, align 8
  %tobool1.not25 = icmp eq ptr %r.024, null
  br i1 %tobool1.not25, label %while.end, label %while.body.preheader

while.body.preheader:                             ; preds = %moduleTypeEncodeId.exit
  %5 = load i64, ptr %r.024, align 8
  %cmp34 = icmp eq i64 %5, %retval.0.i
  br i1 %cmp34, label %if.then3, label %if.end17

while.body:                                       ; preds = %if.end17
  %6 = load i64, ptr %r.0, align 8
  %cmp = icmp eq i64 %6, %retval.0.i
  br i1 %cmp, label %if.then3, label %if.end17, !llvm.loop !55

if.then3:                                         ; preds = %while.body, %while.body.preheader
  %r.027.lcssa = phi ptr [ %r.024, %while.body.preheader ], [ %r.0, %while.body ]
  %prev.026.lcssa = phi ptr [ null, %while.body.preheader ], [ %r.02735, %while.body ]
  %tobool4.not = icmp eq ptr %callback, null
  br i1 %tobool4.not, label %if.else, label %if.then5

if.then5:                                         ; preds = %if.then3
  %callback6 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %r.027.lcssa, i64 0, i32 1
  store ptr %callback, ptr %callback6, align 8
  br label %if.end31

if.else:                                          ; preds = %if.then3
  %tobool7.not = icmp eq ptr %prev.026.lcssa, null
  %next11 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %r.027.lcssa, i64 0, i32 3
  %7 = load ptr, ptr %next11, align 8
  %r.024.prev.026.lcssa = select i1 %tobool7.not, ptr %r.024, ptr %prev.026.lcssa
  %next14 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %r.024.prev.026.lcssa, i64 0, i32 3
  store ptr %7, ptr %next14, align 8
  tail call void @zfree(ptr noundef nonnull %r.027.lcssa) #32
  br label %if.end31

if.end17:                                         ; preds = %while.body.preheader, %while.body
  %r.02735 = phi ptr [ %r.0, %while.body ], [ %r.024, %while.body.preheader ]
  %next18 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %r.02735, i64 0, i32 3
  %r.0 = load ptr, ptr %next18, align 8
  %tobool1.not = icmp eq ptr %r.0, null
  br i1 %tobool1.not, label %while.end, label %while.body, !llvm.loop !55

while.end:                                        ; preds = %if.end17, %moduleTypeEncodeId.exit
  %tobool19.not = icmp eq ptr %callback, null
  br i1 %tobool19.not, label %if.end31, label %if.then20

if.then20:                                        ; preds = %while.end
  %call21 = tail call noalias dereferenceable_or_null(32) ptr @zmalloc(i64 noundef 32) #33
  store i64 %retval.0.i, ptr %call21, align 8
  %8 = load ptr, ptr %module, align 8
  %module24 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %call21, i64 0, i32 2
  store ptr %8, ptr %module24, align 8
  %callback25 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %call21, i64 0, i32 1
  store ptr %callback, ptr %callback25, align 8
  %9 = load ptr, ptr %arrayidx, align 8
  %next28 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %call21, i64 0, i32 3
  store ptr %9, ptr %next28, align 8
  store ptr %call21, ptr %arrayidx, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then5, %if.else, %entry, %if.then20, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SendClusterMessage(ptr nocapture noundef readonly %ctx, ptr noundef %target_id, i8 noundef zeroext %type, ptr noundef %msg, i32 noundef %len) #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %name, align 8
  %3 = load ptr, ptr @ModuleTypeNameCharSet, align 8
  %call.i = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %2) #36
  %cmp.not.i.not = icmp eq i64 %call.i, 9
  br i1 %cmp.not.i.not, label %for.cond.preheader.i, label %moduleTypeEncodeId.exit

for.cond.preheader.i:                             ; preds = %if.end
  %sub.ptr.rhs.cast.i = ptrtoint ptr %3 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %if.end8.i, %for.cond.preheader.i
  %indvars.iv.i = phi i64 [ 0, %for.cond.preheader.i ], [ %indvars.iv.next.i, %if.end8.i ]
  %id.013.i = phi i64 [ 0, %for.cond.preheader.i ], [ %or.i, %if.end8.i ]
  %arrayidx.i = getelementptr inbounds i8, ptr %2, i64 %indvars.iv.i
  %4 = load i8, ptr %arrayidx.i, align 1
  %conv.i = sext i8 %4 to i32
  %call6.i = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %3, i32 noundef %conv.i) #36
  %tobool.not.i = icmp eq ptr %call6.i, null
  br i1 %tobool.not.i, label %moduleTypeEncodeId.exit, label %if.end8.i

if.end8.i:                                        ; preds = %for.body.i
  %sub.ptr.lhs.cast.i = ptrtoint ptr %call6.i to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, %sub.ptr.rhs.cast.i
  %shl.i = shl i64 %id.013.i, 6
  %or.i = or i64 %sub.ptr.sub.i, %shl.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 9
  br i1 %exitcond.not.i, label %for.end.i, label %for.body.i, !llvm.loop !36

for.end.i:                                        ; preds = %if.end8.i
  %shl9.i = shl i64 %or.i, 10
  br label %moduleTypeEncodeId.exit

moduleTypeEncodeId.exit:                          ; preds = %for.body.i, %if.end, %for.end.i
  %retval.0.i = phi i64 [ %shl9.i, %for.end.i ], [ 0, %if.end ], [ 0, %for.body.i ]
  %call1 = tail call i32 @clusterSendModuleMessageToTarget(ptr noundef %target_id, i64 noundef %retval.0.i, i8 noundef zeroext %type, ptr noundef %msg, i32 noundef %len) #32
  %cmp = icmp ne i32 %call1, 0
  %. = zext i1 %cmp to i32
  br label %return

return:                                           ; preds = %moduleTypeEncodeId.exit, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ %., %moduleTypeEncodeId.exit ]
  ret i32 %retval.0
}

declare i32 @clusterSendModuleMessageToTarget(ptr noundef, i64 noundef, i8 noundef zeroext, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetClusterNodesList(ptr nocapture readnone %ctx, ptr noundef %numnodes) #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call ptr @getClusterNodesList(ptr noundef %numnodes) #32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi ptr [ %call, %if.end ], [ null, %entry ]
  ret ptr %retval.0
}

declare ptr @getClusterNodesList(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeClusterNodesList(ptr noundef %ids) #0 {
entry:
  %cmp = icmp eq ptr %ids, null
  br i1 %cmp, label %return, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %0 = load ptr, ptr %ids, align 8
  %tobool.not6 = icmp eq ptr %0, null
  br i1 %tobool.not6, label %for.end, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.cond.preheader ]
  %1 = phi ptr [ %2, %for.body ], [ %0, %for.cond.preheader ]
  tail call void @zfree(ptr noundef nonnull %1) #32
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  %arrayidx = getelementptr inbounds ptr, ptr %ids, i64 %indvars.iv.next
  %2 = load ptr, ptr %arrayidx, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %for.end, label %for.body, !llvm.loop !56

for.end:                                          ; preds = %for.body, %for.cond.preheader
  tail call void @zfree(ptr noundef nonnull %ids) #32
  br label %return

return:                                           ; preds = %entry, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetMyClusterID() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call ptr @getMyClusterId() #32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi ptr [ %call, %if.end ], [ null, %entry ]
  ret ptr %retval.0
}

declare ptr @getMyClusterId() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_GetClusterSize() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call i32 @getClusterSize() #32
  %conv = sext i32 %call to i64
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i64 [ %conv, %if.end ], [ 0, %entry ]
  ret i64 %retval.0
}

declare i32 @getClusterSize() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_GetClusterNodeInfo(ptr nocapture readnone %ctx, ptr noundef %id, ptr noundef %ip, ptr noundef writeonly %master_id, ptr noundef writeonly %port, ptr noundef %flags) #0 {
entry:
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %id) #36
  %conv = trunc i64 %call to i32
  %call1 = tail call ptr @clusterLookupNode(ptr noundef %id, i32 noundef %conv) #32
  %cmp = icmp eq ptr %call1, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %call3 = tail call i32 @clusterNodePending(ptr noundef nonnull %call1) #32
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %tobool4.not = icmp eq ptr %ip, null
  br i1 %tobool4.not, label %if.end8, label %if.then5

if.then5:                                         ; preds = %if.end
  %call6 = tail call ptr @clusterNodeIp(ptr noundef nonnull %call1) #32
  %call7 = tail call i64 @redis_strlcpy(ptr noundef nonnull %ip, ptr noundef %call6, i64 noundef 46) #32
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  %tobool9.not = icmp eq ptr %master_id, null
  br i1 %tobool9.not, label %if.end19, label %if.then10

if.then10:                                        ; preds = %if.end8
  %call11 = tail call i32 @clusterNodeIsSlave(ptr noundef nonnull %call1) #32
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then10
  %call13 = tail call ptr @clusterNodeGetSlaveof(ptr noundef nonnull %call1) #32
  %tobool14.not = icmp eq ptr %call13, null
  br i1 %tobool14.not, label %if.else, label %if.then15

if.then15:                                        ; preds = %land.lhs.true
  %call16 = tail call ptr @clusterNodeGetSlaveof(ptr noundef nonnull %call1) #32
  %call17 = tail call ptr @clusterNodeGetName(ptr noundef %call16) #32
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(40) %master_id, ptr noundef nonnull align 1 dereferenceable(40) %call17, i64 40, i1 false)
  br label %if.end19

if.else:                                          ; preds = %land.lhs.true, %if.then10
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(40) %master_id, i8 0, i64 40, i1 false)
  br label %if.end19

if.end19:                                         ; preds = %if.then15, %if.else, %if.end8
  %tobool20.not = icmp eq ptr %port, null
  br i1 %tobool20.not, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.end19
  %call22 = tail call i32 @getNodeDefaultClientPort(ptr noundef nonnull %call1) #32
  store i32 %call22, ptr %port, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  %tobool24.not = icmp eq ptr %flags, null
  br i1 %tobool24.not, label %return, label %if.then25

if.then25:                                        ; preds = %if.end23
  store i32 0, ptr %flags, align 4
  %call26 = tail call i32 @clusterNodeIsMyself(ptr noundef nonnull %call1) #32
  %tobool27.not = icmp eq i32 %call26, 0
  br i1 %tobool27.not, label %if.end29, label %if.then28

if.then28:                                        ; preds = %if.then25
  %0 = load i32, ptr %flags, align 4
  %or = or i32 %0, 1
  store i32 %or, ptr %flags, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.then25
  %call30 = tail call i32 @clusterNodeIsMaster(ptr noundef nonnull %call1) #32
  %tobool31.not = icmp eq i32 %call30, 0
  br i1 %tobool31.not, label %if.end34, label %if.then32

if.then32:                                        ; preds = %if.end29
  %1 = load i32, ptr %flags, align 4
  %or33 = or i32 %1, 2
  store i32 %or33, ptr %flags, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end29
  %call35 = tail call i32 @clusterNodeIsSlave(ptr noundef nonnull %call1) #32
  %tobool36.not = icmp eq i32 %call35, 0
  br i1 %tobool36.not, label %if.end39, label %if.then37

if.then37:                                        ; preds = %if.end34
  %2 = load i32, ptr %flags, align 4
  %or38 = or i32 %2, 4
  store i32 %or38, ptr %flags, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %if.end34
  %call40 = tail call i32 @clusterNodeTimedOut(ptr noundef nonnull %call1) #32
  %tobool41.not = icmp eq i32 %call40, 0
  br i1 %tobool41.not, label %if.end44, label %if.then42

if.then42:                                        ; preds = %if.end39
  %3 = load i32, ptr %flags, align 4
  %or43 = or i32 %3, 8
  store i32 %or43, ptr %flags, align 4
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %if.end39
  %call45 = tail call i32 @clusterNodeIsFailing(ptr noundef nonnull %call1) #32
  %tobool46.not = icmp eq i32 %call45, 0
  br i1 %tobool46.not, label %if.end49, label %if.then47

if.then47:                                        ; preds = %if.end44
  %4 = load i32, ptr %flags, align 4
  %or48 = or i32 %4, 16
  store i32 %or48, ptr %flags, align 4
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %if.end44
  %call50 = tail call i32 @clusterNodeIsNoFailover(ptr noundef nonnull %call1) #32
  %tobool51.not = icmp eq i32 %call50, 0
  br i1 %tobool51.not, label %return, label %if.then52

if.then52:                                        ; preds = %if.end49
  %5 = load i32, ptr %flags, align 4
  %or53 = or i32 %5, 32
  store i32 %or53, ptr %flags, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.then52, %if.end49, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 0, %if.end49 ], [ 0, %if.then52 ], [ 0, %if.end23 ]
  ret i32 %retval.0
}

declare ptr @clusterLookupNode(ptr noundef, i32 noundef) local_unnamed_addr #1

declare i32 @clusterNodePending(ptr noundef) local_unnamed_addr #1

declare i64 @redis_strlcpy(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

declare ptr @clusterNodeIp(ptr noundef) local_unnamed_addr #1

declare i32 @clusterNodeIsSlave(ptr noundef) local_unnamed_addr #1

declare ptr @clusterNodeGetSlaveof(ptr noundef) local_unnamed_addr #1

declare ptr @clusterNodeGetName(ptr noundef) local_unnamed_addr #1

declare i32 @getNodeDefaultClientPort(ptr noundef) local_unnamed_addr #1

declare i32 @clusterNodeIsMyself(ptr noundef) local_unnamed_addr #1

declare i32 @clusterNodeIsMaster(ptr noundef) local_unnamed_addr #1

declare i32 @clusterNodeTimedOut(ptr noundef) local_unnamed_addr #1

declare i32 @clusterNodeIsFailing(ptr noundef) local_unnamed_addr #1

declare i32 @clusterNodeIsNoFailover(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) uwtable
define dso_local void @RM_SetClusterFlags(ptr nocapture readnone %ctx, i64 noundef %flags) #27 {
entry:
  %and = and i64 %flags, 2
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  %or = or i32 %0, 2
  store i32 %or, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %and1 = and i64 %flags, 4
  %tobool2.not = icmp eq i64 %and1, 0
  br i1 %tobool2.not, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  %or4 = or i32 %1, 4
  store i32 %or4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleTimerHandler(ptr nocapture readnone %eventLoop, i64 %id, ptr nocapture readnone %clientData) #0 {
entry:
  %ri = alloca %struct.raxIterator, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %0 = load ptr, ptr @Timers, align 8
  call void @raxStart(ptr noundef nonnull %ri, ptr noundef %0) #32
  %call = call i64 @ustime() #32
  %call18 = call i32 @raxSeek(ptr noundef nonnull %ri, ptr noundef nonnull @.str.79, ptr noundef null, i64 noundef 0) #32
  %call29 = call i32 @raxNext(ptr noundef nonnull %ri) #32
  %tobool.not10 = icmp eq i32 %call29, 0
  br i1 %tobool.not10, label %while.end, label %if.end.lr.ph

if.end.lr.ph:                                     ; preds = %entry
  %key = getelementptr inbounds %struct.raxIterator, ptr %ri, i64 0, i32 2
  %data = getelementptr inbounds %struct.raxIterator, ptr %ri, i64 0, i32 3
  %1 = getelementptr inbounds i8, ptr %ctx, i64 16
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  %key_len = getelementptr inbounds %struct.raxIterator, ptr %ri, i64 0, i32 4
  br label %if.end

if.end:                                           ; preds = %if.end.lr.ph, %moduleCreateContext.exit
  %3 = load ptr, ptr %key, align 8
  %expiretime.0.copyload = load i64, ptr %3, align 1
  %call3 = call i64 @intrev64(i64 noundef %expiretime.0.copyload) #32
  %cmp.not = icmp ult i64 %call, %call3
  br i1 %cmp.not, label %if.else, label %if.then4

if.then4:                                         ; preds = %if.end
  %4 = load ptr, ptr %data, align 8
  %5 = load ptr, ptr %4, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %1, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  store ptr %5, ptr %module1.i, align 8
  store i32 64, ptr %flags.i, align 8
  %6 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i.i = icmp eq i64 %6, 0
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then4
  %7 = load ptr, ptr @moduleTempClients, align 8
  %dec.i.i = add i64 %6, -1
  store i64 %dec.i.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %7, i64 %dec.i.i
  %8 = load ptr, ptr %arrayidx.i.i, align 8
  %9 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i.i = icmp ult i64 %dec.i.i, %9
  br i1 %cmp1.i.i, label %if.then2.i.i, label %if.end7.sink.split.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  store i64 %dec.i.i, ptr @moduleTempClientMinCount, align 8
  br label %if.end7.sink.split.i

if.else.i.i:                                      ; preds = %if.then4
  %call.i.i = call ptr @createClient(ptr noundef null) #32
  %flags.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 1
  %10 = load i64, ptr %flags.i.i, align 8
  %or.i.i = or i64 %10, 134217728
  store i64 %or.i.i, ptr %flags.i.i, align 8
  %user.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 20
  store ptr null, ptr %user.i.i, align 8
  br label %if.end7.sink.split.i

if.end7.sink.split.i:                             ; preds = %if.else.i.i, %if.then2.i.i, %if.then.i.i
  %call5.sink.i = phi ptr [ %8, %if.then2.i.i ], [ %8, %if.then.i.i ], [ %call.i.i, %if.else.i.i ]
  store ptr %call5.sink.i, ptr %1, align 8
  %11 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %11, 0
  %12 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = call i64 %12() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end7.sink.split.i
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %13
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end7.sink.split.i
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %14, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  store i64 %add.sink.i, ptr %2, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %15 = load ptr, ptr %1, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleTimer, ptr %4, i64 0, i32 3
  %16 = load i32, ptr %dbid, align 8
  %call5 = call i32 @selectDb(ptr noundef %15, i32 noundef %16) #32
  %callback = getelementptr inbounds %struct.RedisModuleTimer, ptr %4, i64 0, i32 1
  %17 = load ptr, ptr %callback, align 8
  %data6 = getelementptr inbounds %struct.RedisModuleTimer, ptr %4, i64 0, i32 2
  %18 = load ptr, ptr %data6, align 8
  call void %17(ptr noundef nonnull %ctx, ptr noundef %18) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %19 = load ptr, ptr @Timers, align 8
  %20 = load ptr, ptr %key, align 8
  %21 = load i64, ptr %key_len, align 8
  %call8 = call i32 @raxRemove(ptr noundef %19, ptr noundef %20, i64 noundef %21, ptr noundef null) #32
  call void @zfree(ptr noundef nonnull %4) #32
  %call1 = call i32 @raxSeek(ptr noundef nonnull %ri, ptr noundef nonnull @.str.79, ptr noundef null, i64 noundef 0) #32
  %call2 = call i32 @raxNext(ptr noundef nonnull %ri) #32
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %while.end, label %if.end

if.else:                                          ; preds = %if.end
  %call9 = call i64 @ustime() #32
  %sub = sub nsw i64 %call3, %call9
  %div = sdiv i64 %sub, 1000
  br label %while.end

while.end:                                        ; preds = %moduleCreateContext.exit, %entry, %if.else
  %next_period.0 = phi i64 [ %div, %if.else ], [ 0, %entry ], [ 0, %moduleCreateContext.exit ]
  call void @raxStop(ptr noundef nonnull %ri) #32
  %22 = load ptr, ptr @Timers, align 8
  %call14 = call i64 @raxSize(ptr noundef %22) #32
  %cmp15.not = icmp eq i64 %call14, 0
  br i1 %cmp15.not, label %if.else17, label %if.then16

if.then16:                                        ; preds = %while.end
  %spec.store.select = call i64 @llvm.smax.i64(i64 %next_period.0, i64 1)
  %conv = trunc i64 %spec.store.select to i32
  br label %return

if.else17:                                        ; preds = %while.end
  store i64 -1, ptr @aeTimer, align 8
  br label %return

return:                                           ; preds = %if.else17, %if.then16
  %retval.0 = phi i32 [ %conv, %if.then16 ], [ -1, %if.else17 ]
  ret i32 %retval.0
}

declare void @raxStart(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @raxSeek(ptr noundef, ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

declare i32 @raxNext(ptr noundef) local_unnamed_addr #1

declare i64 @intrev64(i64 noundef) local_unnamed_addr #1

declare i32 @raxRemove(ptr noundef, ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

declare void @raxStop(ptr noundef) local_unnamed_addr #1

declare i64 @raxSize(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_CreateTimer(ptr nocapture noundef readonly %ctx, i64 noundef %period, ptr noundef %callback, ptr noundef %data) #0 {
entry:
  %key = alloca i64, align 8
  %ri = alloca %struct.raxIterator, align 8
  %call = tail call noalias dereferenceable_or_null(32) ptr @zmalloc(i64 noundef 32) #33
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  store ptr %0, ptr %call, align 8
  %callback2 = getelementptr inbounds %struct.RedisModuleTimer, ptr %call, i64 0, i32 1
  store ptr %callback, ptr %callback2, align 8
  %data3 = getelementptr inbounds %struct.RedisModuleTimer, ptr %call, i64 0, i32 2
  store ptr %data, ptr %data3, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %db = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %2, i64 0, i32 6
  %3 = load i32, ptr %id, align 8
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ 0, %entry ]
  %dbid = getelementptr inbounds %struct.RedisModuleTimer, ptr %call, i64 0, i32 3
  store i32 %cond, ptr %dbid, align 8
  %call5 = tail call i64 @ustime() #32
  %mul = mul nsw i64 %period, 1000
  %add = add nsw i64 %call5, %mul
  br label %while.body

while.body:                                       ; preds = %while.body, %cond.end
  %expiretime.0 = phi i64 [ %add, %cond.end ], [ %inc, %while.body ]
  %call6 = call i64 @intrev64(i64 noundef %expiretime.0) #32
  store i64 %call6, ptr %key, align 8
  %4 = load ptr, ptr @Timers, align 8
  %call7 = call i32 @raxFind(ptr noundef %4, ptr noundef nonnull %key, i64 noundef 8, ptr noundef null) #32
  %tobool8.not = icmp eq i32 %call7, 0
  %inc = add i64 %expiretime.0, 1
  br i1 %tobool8.not, label %if.then, label %while.body

if.then:                                          ; preds = %while.body
  %5 = load ptr, ptr @Timers, align 8
  %call9 = call i32 @raxInsert(ptr noundef %5, ptr noundef nonnull %key, i64 noundef 8, ptr noundef nonnull %call, ptr noundef null) #32
  %6 = load i64, ptr @aeTimer, align 8
  %cmp.not = icmp eq i64 %6, -1
  br i1 %cmp.not, label %if.then21, label %if.then10

if.then10:                                        ; preds = %if.then
  %7 = load ptr, ptr @Timers, align 8
  call void @raxStart(ptr noundef nonnull %ri, ptr noundef %7) #32
  %call11 = call i32 @raxSeek(ptr noundef nonnull %ri, ptr noundef nonnull @.str.79, ptr noundef null, i64 noundef 0) #32
  %call12 = call i32 @raxNext(ptr noundef nonnull %ri) #32
  %key13 = getelementptr inbounds %struct.raxIterator, ptr %ri, i64 0, i32 2
  %8 = load ptr, ptr %key13, align 8
  %bcmp = call i32 @bcmp(ptr noundef nonnull dereferenceable(8) %8, ptr noundef nonnull dereferenceable(8) %key, i64 8)
  %cmp15 = icmp eq i32 %bcmp, 0
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.then10
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %10 = load i64, ptr @aeTimer, align 8
  %call17 = call i32 @aeDeleteTimeEvent(ptr noundef %9, i64 noundef %10) #32
  store i64 -1, ptr @aeTimer, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then10, %if.then16
  call void @raxStop(ptr noundef nonnull %ri) #32
  %.pr = load i64, ptr @aeTimer, align 8
  %cmp20 = icmp eq i64 %.pr, -1
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.then, %if.end19
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call22 = call i64 @aeCreateTimeEvent(ptr noundef %11, i64 noundef %period, ptr noundef nonnull @moduleTimerHandler, ptr noundef null, ptr noundef null) #32
  store i64 %call22, ptr @aeTimer, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  %12 = load i64, ptr %key, align 8
  ret i64 %12
}

declare i32 @raxFind(ptr noundef, ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

declare i32 @raxInsert(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @aeDeleteTimeEvent(ptr noundef, i64 noundef) local_unnamed_addr #1

declare i64 @aeCreateTimeEvent(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_StopTimer(ptr nocapture noundef readonly %ctx, i64 noundef %id, ptr noundef writeonly %data) #0 {
entry:
  %id.addr = alloca i64, align 8
  %result = alloca ptr, align 8
  store i64 %id, ptr %id.addr, align 8
  %0 = load ptr, ptr @Timers, align 8
  %call = call i32 @raxFind(ptr noundef %0, ptr noundef nonnull %id.addr, i64 noundef 8, ptr noundef nonnull %result) #32
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %result, align 8
  %2 = load ptr, ptr %1, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %3 = load ptr, ptr %module1, align 8
  %cmp.not = icmp eq ptr %2, %3
  br i1 %cmp.not, label %if.end3, label %return

if.end3:                                          ; preds = %if.end
  %tobool4.not = icmp eq ptr %data, null
  br i1 %tobool4.not, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end3
  %data6 = getelementptr inbounds %struct.RedisModuleTimer, ptr %1, i64 0, i32 2
  %4 = load ptr, ptr %data6, align 8
  store ptr %4, ptr %data, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %5 = load ptr, ptr @Timers, align 8
  %call8 = call i32 @raxRemove(ptr noundef %5, ptr noundef nonnull %id.addr, i64 noundef 8, ptr noundef null) #32
  call void @zfree(ptr noundef nonnull %1) #32
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end7
  %retval.0 = phi i32 [ 0, %if.end7 ], [ 1, %entry ], [ 1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_GetTimerInfo(ptr nocapture noundef readonly %ctx, i64 noundef %id, ptr noundef writeonly %remaining, ptr noundef writeonly %data) #0 {
entry:
  %id.addr = alloca i64, align 8
  %result = alloca ptr, align 8
  store i64 %id, ptr %id.addr, align 8
  %0 = load ptr, ptr @Timers, align 8
  %call = call i32 @raxFind(ptr noundef %0, ptr noundef nonnull %id.addr, i64 noundef 8, ptr noundef nonnull %result) #32
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %result, align 8
  %2 = load ptr, ptr %1, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %3 = load ptr, ptr %module1, align 8
  %cmp.not = icmp eq ptr %2, %3
  br i1 %cmp.not, label %if.end3, label %return

if.end3:                                          ; preds = %if.end
  %tobool4.not = icmp eq ptr %remaining, null
  br i1 %tobool4.not, label %if.end11, label %if.then5

if.then5:                                         ; preds = %if.end3
  %4 = load i64, ptr %id.addr, align 8
  %call6 = call i64 @intrev64(i64 noundef %4) #32
  %call7 = call i64 @ustime() #32
  %sub = sub i64 %call6, %call7
  %spec.store.select = call i64 @llvm.smax.i64(i64 %sub, i64 0)
  %div = udiv i64 %spec.store.select, 1000
  store i64 %div, ptr %remaining, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %if.end3
  %tobool12.not = icmp eq ptr %data, null
  br i1 %tobool12.not, label %return, label %if.then13

if.then13:                                        ; preds = %if.end11
  %data14 = getelementptr inbounds %struct.RedisModuleTimer, ptr %1, i64 0, i32 2
  %5 = load ptr, ptr %data14, align 8
  store ptr %5, ptr %data, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then13, %if.end, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 1, %if.end ], [ 0, %if.then13 ], [ 0, %if.end11 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleHoldsTimer(ptr noundef readnone %module) local_unnamed_addr #0 {
entry:
  %iter = alloca %struct.raxIterator, align 8
  %0 = load ptr, ptr @Timers, align 8
  call void @raxStart(ptr noundef nonnull %iter, ptr noundef %0) #32
  %call = call i32 @raxSeek(ptr noundef nonnull %iter, ptr noundef nonnull @.str.79, ptr noundef null, i64 noundef 0) #32
  %data = getelementptr inbounds %struct.raxIterator, ptr %iter, i64 0, i32 3
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call1 = call i32 @raxNext(ptr noundef nonnull %iter) #32
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %data, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp = icmp eq ptr %2, %module
  br i1 %cmp, label %while.end, label %while.cond, !llvm.loop !57

while.end:                                        ; preds = %while.body, %while.cond
  %found.0 = phi i32 [ 0, %while.cond ], [ 1, %while.body ]
  call void @raxStop(ptr noundef nonnull %iter) #32
  ret i32 %found.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_EventLoopAdd(i32 noundef %fd, i32 noundef %mask, ptr noundef %func, ptr noundef %user_data) #0 {
entry:
  %cmp = icmp slt i32 %fd, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call = tail call i32 @aeGetSetSize(ptr noundef %0) #32
  %cmp1.not = icmp sgt i32 %call, %fd
  br i1 %cmp1.not, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call2 = tail call ptr @__errno_location() #37
  store i32 34, ptr %call2, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %tobool.not = icmp ne ptr %func, null
  %tobool4.not = icmp ult i32 %mask, 4
  %or.cond = and i1 %tobool4.not, %tobool.not
  br i1 %or.cond, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %call6 = tail call ptr @__errno_location() #37
  store i32 22, ptr %call6, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call8 = tail call ptr @aeGetFileClientData(ptr noundef %1, i32 noundef %fd) #32
  %tobool9.not = icmp eq ptr %call8, null
  br i1 %tobool9.not, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end7
  %call11 = tail call noalias dereferenceable_or_null(24) ptr @zcalloc(i64 noundef 24) #33
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end7
  %data.0 = phi ptr [ %call8, %if.end7 ], [ %call11, %if.then10 ]
  %and13 = and i32 %mask, 1
  %tobool14.not = icmp eq i32 %and13, 0
  %eventLoopCbWritable.eventLoopCbReadable = select i1 %tobool14.not, ptr @eventLoopCbWritable, ptr @eventLoopCbReadable
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call18 = tail call i32 @aeCreateFileEvent(ptr noundef %2, i32 noundef %fd, i32 noundef %mask, ptr noundef nonnull %eventLoopCbWritable.eventLoopCbReadable, ptr noundef %data.0) #32
  %cmp19.not = icmp eq i32 %call18, 0
  br i1 %cmp19.not, label %if.end25, label %if.then20

if.then20:                                        ; preds = %if.end12
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call21 = tail call i32 @aeGetFileEvents(ptr noundef %3, i32 noundef %fd) #32
  %cmp22 = icmp eq i32 %call21, 0
  br i1 %cmp22, label %if.then23, label %return

if.then23:                                        ; preds = %if.then20
  tail call void @zfree(ptr noundef %data.0) #32
  br label %return

if.end25:                                         ; preds = %if.end12
  %user_data26 = getelementptr inbounds %struct.EventLoopData, ptr %data.0, i64 0, i32 2
  store ptr %user_data, ptr %user_data26, align 8
  br i1 %tobool14.not, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.end25
  store ptr %func, ptr %data.0, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end25
  %tobool32.not = icmp ult i32 %mask, 2
  br i1 %tobool32.not, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.end30
  %wFunc = getelementptr inbounds %struct.EventLoopData, ptr %data.0, i64 0, i32 1
  store ptr %func, ptr %wFunc, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end30
  %call35 = tail call ptr @__errno_location() #37
  store i32 0, ptr %call35, align 4
  br label %return

return:                                           ; preds = %if.then20, %if.then23, %if.end34, %if.then5, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 1, %if.then5 ], [ 0, %if.end34 ], [ 1, %if.then23 ], [ 1, %if.then20 ]
  ret i32 %retval.0
}

declare i32 @aeGetSetSize(ptr noundef) local_unnamed_addr #1

declare ptr @aeGetFileClientData(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal void @eventLoopCbReadable(ptr nocapture readnone %ae, i32 noundef %fd, ptr nocapture noundef readonly %user_data, i32 noundef %ae_mask) #0 {
entry:
  %0 = load ptr, ptr %user_data, align 8
  %user_data1 = getelementptr inbounds %struct.EventLoopData, ptr %user_data, i64 0, i32 2
  %1 = load ptr, ptr %user_data1, align 8
  %mask.1.i = and i32 %ae_mask, 3
  tail call void %0(i32 noundef %fd, ptr noundef %1, i32 noundef %mask.1.i) #32
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @eventLoopCbWritable(ptr nocapture readnone %ae, i32 noundef %fd, ptr nocapture noundef readonly %user_data, i32 noundef %ae_mask) #0 {
entry:
  %wFunc = getelementptr inbounds %struct.EventLoopData, ptr %user_data, i64 0, i32 1
  %0 = load ptr, ptr %wFunc, align 8
  %user_data1 = getelementptr inbounds %struct.EventLoopData, ptr %user_data, i64 0, i32 2
  %1 = load ptr, ptr %user_data1, align 8
  %mask.1.i = and i32 %ae_mask, 3
  tail call void %0(i32 noundef %fd, ptr noundef %1, i32 noundef %mask.1.i) #32
  ret void
}

declare i32 @aeCreateFileEvent(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @aeGetFileEvents(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_EventLoopDel(i32 noundef %fd, i32 noundef %mask) #0 {
entry:
  %cmp = icmp slt i32 %fd, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call = tail call i32 @aeGetSetSize(ptr noundef %0) #32
  %cmp1.not = icmp sgt i32 %call, %fd
  br i1 %cmp1.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %tobool.not = icmp ult i32 %mask, 4
  br i1 %tobool.not, label %if.end5, label %return

if.end5:                                          ; preds = %if.end
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call6 = tail call ptr @aeGetFileClientData(ptr noundef %1, i32 noundef %fd) #32
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  tail call void @aeDeleteFileEvent(ptr noundef %2, i32 noundef %fd, i32 noundef %mask) #32
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call8 = tail call i32 @aeGetFileEvents(ptr noundef %3, i32 noundef %fd) #32
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %return

if.then10:                                        ; preds = %if.end5
  tail call void @zfree(ptr noundef %call6) #32
  br label %return

return:                                           ; preds = %if.end5, %if.then10, %if.end, %entry, %lor.lhs.false
  %.sink = phi i32 [ 34, %lor.lhs.false ], [ 34, %entry ], [ 22, %if.end ], [ 0, %if.then10 ], [ 0, %if.end5 ]
  %retval.0 = phi i32 [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %if.end ], [ 0, %if.then10 ], [ 0, %if.end5 ]
  %call12 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call12, align 4
  ret i32 %retval.0
}

declare void @aeDeleteFileEvent(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_EventLoopAddOneShot(ptr noundef %func, ptr noundef %user_data) #0 {
entry:
  %tobool.not = icmp eq ptr %func, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call1 = tail call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #33
  store ptr %func, ptr %call1, align 8
  %user_data3 = getelementptr inbounds %struct.EventLoopOneShot, ptr %call1, i64 0, i32 1
  store ptr %user_data, ptr %user_data3, align 8
  %call4 = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleEventLoopMutex) #32
  %0 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %tobool5.not = icmp eq ptr %0, null
  br i1 %tobool5.not, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %call7 = tail call ptr @listCreate() #32
  store ptr %call7, ptr @moduleEventLoopOneShots, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %1 = phi ptr [ %call7, %if.then6 ], [ %0, %if.end ]
  %call9 = tail call ptr @listAddNodeTail(ptr noundef %1, ptr noundef nonnull %call1) #32
  %call10 = tail call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleEventLoopMutex) #32
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 41, i64 1), align 4
  %call11 = tail call i64 @write(i32 noundef %2, ptr noundef nonnull @.str.76, i64 noundef 1) #32
  br label %return

return:                                           ; preds = %entry, %if.end8
  %.sink = phi i32 [ 0, %if.end8 ], [ 22, %entry ]
  %retval.0 = phi i32 [ 0, %if.end8 ], [ 1, %entry ]
  %call14 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call14, align 4
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleNotifyUserChanged(ptr nocapture noundef %c) local_unnamed_addr #0 {
entry:
  %auth_callback = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 68
  %0 = load ptr, ptr %auth_callback, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %c, align 8
  %auth_callback_privdata = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 69
  %2 = load ptr, ptr %auth_callback_privdata, align 8
  tail call void %0(i64 noundef %1, ptr noundef %2) #32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %auth_callback, i8 0, i64 24, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @revokeClientAuthentication(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %auth_callback.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 68
  %0 = load ptr, ptr %auth_callback.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %moduleNotifyUserChanged.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %1 = load i64, ptr %c, align 8
  %auth_callback_privdata.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 69
  %2 = load ptr, ptr %auth_callback_privdata.i, align 8
  tail call void %0(i64 noundef %1, ptr noundef %2) #32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %auth_callback.i, i8 0, i64 24, i1 false)
  br label %moduleNotifyUserChanged.exit

moduleNotifyUserChanged.exit:                     ; preds = %entry, %if.then.i
  %3 = load ptr, ptr @DefaultUser, align 8
  %user = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 20
  store ptr %3, ptr %user, align 8
  %authenticated = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 34
  store i32 0, ptr %authenticated, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %cmp = icmp eq ptr %4, %c
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %moduleNotifyUserChanged.exit
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %5 = load i64, ptr %flags, align 8
  %or = or i64 %5, 1099511627776
  store i64 %or, ptr %flags, align 8
  br label %if.end

if.else:                                          ; preds = %moduleNotifyUserChanged.exit
  tail call void @freeClientAsync(ptr noundef nonnull %c) #32
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare void @freeClientAsync(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noalias noundef ptr @RM_CreateModuleUser(ptr noundef %name) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #33
  %call1 = tail call ptr @ACLCreateUnlinkedUser() #32
  store ptr %call1, ptr %call, align 8
  %free_user = getelementptr inbounds %struct.RedisModuleUser, ptr %call, i64 0, i32 1
  store i32 1, ptr %free_user, align 8
  %0 = load ptr, ptr %call1, align 8
  tail call void @sdsfree(ptr noundef %0) #32
  %call4 = tail call ptr @sdsnew(ptr noundef %name) #32
  store ptr %call4, ptr %call1, align 8
  ret ptr %call
}

declare ptr @ACLCreateUnlinkedUser() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_FreeModuleUser(ptr noundef %user) #0 {
entry:
  %free_user = getelementptr inbounds %struct.RedisModuleUser, ptr %user, i64 0, i32 1
  %0 = load i32, ptr %free_user, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %user, align 8
  tail call void @ACLFreeUserAndKillClients(ptr noundef %1) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  tail call void @zfree(ptr noundef nonnull %user) #32
  ret i32 0
}

declare void @ACLFreeUserAndKillClients(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetModuleUserACL(ptr nocapture noundef readonly %user, ptr noundef %acl) #0 {
entry:
  %0 = load ptr, ptr %user, align 8
  %call = tail call i32 @ACLSetUser(ptr noundef %0, ptr noundef %acl, i64 noundef -1) #32
  ret i32 %call
}

declare i32 @ACLSetUser(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SetModuleUserACLString(ptr noundef %ctx, ptr noundef readonly %user, ptr noundef %acl, ptr noundef writeonly %error) #0 {
entry:
  %argc = alloca i32, align 4
  %cmp.not = icmp eq ptr %user, null
  br i1 %cmp.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.80, ptr noundef nonnull @.str.2, i32 noundef 9553) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %call = call ptr @sdssplitargs(ptr noundef %acl, ptr noundef nonnull %argc) #32
  %0 = load ptr, ptr %user, align 8
  %1 = load i32, ptr %argc, align 4
  %call3 = call ptr @ACLStringSetUser(ptr noundef %0, ptr noundef null, ptr noundef %call, i32 noundef %1) #32
  %2 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %call, i32 noundef %2) #32
  %tobool4.not = icmp eq ptr %call3, null
  br i1 %tobool4.not, label %return, label %if.then

if.then:                                          ; preds = %cond.end
  %tobool5.not = icmp eq ptr %error, null
  br i1 %tobool5.not, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.then
  %call7 = call ptr @createObject(i32 noundef 0, ptr noundef nonnull %call3) #32
  store ptr %call7, ptr %error, align 8
  %cmp8.not = icmp eq ptr %ctx, null
  br i1 %cmp8.not, label %return, label %if.then10

if.then10:                                        ; preds = %if.then6
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %3 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %3, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then10
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %4 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %5 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %4, %5
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %4, 1
  %cmp4.i = icmp slt i32 %4, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %6 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = call ptr @zrealloc(ptr noundef %6, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %7 = phi i32 [ %4, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %8 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %7 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %9 = load ptr, ptr %amqueue12.i, align 8
  %10 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %10 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %9, i64 %idxprom17.i
  store ptr %call7, ptr %arrayidx18.i, align 8
  %11 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %11, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

if.else:                                          ; preds = %if.then
  call void @sdsfree(ptr noundef nonnull %call3) #32
  br label %return

return:                                           ; preds = %if.end11.i, %if.then10, %cond.end, %if.else, %if.then6
  %retval.0 = phi i32 [ 1, %if.then6 ], [ 1, %if.else ], [ 0, %cond.end ], [ 1, %if.then10 ], [ 1, %if.end11.i ]
  ret i32 %retval.0
}

declare ptr @sdssplitargs(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @ACLStringSetUser(ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetModuleUserACLString(ptr noundef readonly %user) #0 {
entry:
  %cmp.not = icmp eq ptr %user, null
  br i1 %cmp.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.80, ptr noundef nonnull @.str.2, i32 noundef 9580) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %0 = load ptr, ptr %user, align 8
  %call = tail call ptr @ACLDescribeUser(ptr noundef %0) #32
  ret ptr %call
}

declare ptr @ACLDescribeUser(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetCurrentUserName(ptr nocapture noundef %ctx) #0 {
entry:
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %user = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 20
  %1 = load ptr, ptr %user, align 8
  %2 = load ptr, ptr %1, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %2, i64 -1
  %3 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %3 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %if.then.i [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %if.then.i

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %2, i64 -3
  %4 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %4 to i64
  br label %if.then.i

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %2, i64 -5
  %5 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %5 to i64
  br label %if.then.i

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %2, i64 -9
  %6 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %6 to i64
  br label %if.then.i

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %2, i64 -17
  %7 = load i64, ptr %add.ptr14.i, align 1
  br label %if.then.i

if.then.i:                                        ; preds = %sw.bb13.i, %sw.bb9.i, %sw.bb5.i, %sw.bb3.i, %sw.bb.i, %entry
  %retval.0.i = phi i64 [ %7, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call.i = tail call ptr @createStringObject(ptr noundef nonnull %2, i64 noundef %retval.0.i) #32
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %8 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %8, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %RM_CreateString.exit, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %9 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %10 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %9, %10
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %if.end11.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %9, 1
  %cmp4.i.i = icmp slt i32 %9, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %11 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = tail call ptr @zrealloc(ptr noundef %11, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then1.i.i, %if.end.if.end11_crit_edge.i.i
  %12 = phi i32 [ %9, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ]
  %13 = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ]
  %amqueue12.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i.i = sext i32 %12 to i64
  %type14.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %13, i64 %idxprom.i.i, i32 1
  store i32 1, ptr %type14.i.i, align 8
  %14 = load ptr, ptr %amqueue12.i.i, align 8
  %15 = load i32, ptr %amqueue_used.i.i, align 4
  %idxprom17.i.i = sext i32 %15 to i64
  %arrayidx18.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %14, i64 %idxprom17.i.i
  store ptr %call.i, ptr %arrayidx18.i.i, align 8
  %16 = load i32, ptr %amqueue_used.i.i, align 4
  %inc.i.i = add nsw i32 %16, 1
  store i32 %inc.i.i, ptr %amqueue_used.i.i, align 4
  br label %RM_CreateString.exit

RM_CreateString.exit:                             ; preds = %if.then.i, %if.end11.i.i
  ret ptr %call.i
}

; Function Attrs: nounwind uwtable
define dso_local noalias noundef ptr @RM_GetModuleUserFromUserName(ptr nocapture noundef readonly %name) #0 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %name, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call2 = tail call ptr @ACLGetUserByName(ptr noundef nonnull %0, i64 noundef %retval.0.i) #32
  %cmp = icmp eq ptr %call2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %sdslen.exit
  %call3 = tail call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #33
  store ptr %call2, ptr %call3, align 8
  %free_user = getelementptr inbounds %struct.RedisModuleUser, ptr %call3, i64 0, i32 1
  store i32 0, ptr %free_user, align 8
  br label %return

return:                                           ; preds = %sdslen.exit, %if.end
  %retval.0 = phi ptr [ %call3, %if.end ], [ null, %sdslen.exit ]
  ret ptr %retval.0
}

declare ptr @ACLGetUserByName(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ACLCheckCommandPermissions(ptr nocapture noundef readonly %user, ptr noundef %argv, i32 noundef %argc) #0 {
entry:
  %keyidxptr = alloca i32, align 4
  %call = tail call ptr @lookupCommand(ptr noundef %argv, i32 noundef %argc) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return.sink.split, label %if.end

if.end:                                           ; preds = %entry
  %0 = load ptr, ptr %user, align 8
  %call3 = call i32 @ACLCheckAllUserCommandPerm(ptr noundef %0, ptr noundef nonnull %call, ptr noundef %argv, i32 noundef %argc, ptr noundef nonnull %keyidxptr) #32
  %cmp4.not = icmp eq i32 %call3, 0
  br i1 %cmp4.not, label %return, label %return.sink.split

return.sink.split:                                ; preds = %if.end, %entry
  %.sink = phi i32 [ 2, %entry ], [ 13, %if.end ]
  %call6 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call6, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ACLCheckKeyPermissions(ptr nocapture noundef readonly %user, ptr nocapture noundef readonly %key, i32 noundef %flags) #0 {
entry:
  %0 = and i32 %flags, -241
  %cmp.not = icmp eq i32 %0, 0
  br i1 %cmp.not, label %if.end, label %return.sink.split

if.end:                                           ; preds = %entry
  %conv = zext nneg i32 %flags to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %if.end
  %indvars.iv.i = phi i64 [ 0, %if.end ], [ %indvars.iv.next.i, %for.inc.i ]
  %out.06.i = phi i64 [ 0, %if.end ], [ %out.1.i, %for.inc.i ]
  %arrayidx7.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 1
  %1 = load i64, ptr %arrayidx7.i, align 8
  %and.i = and i64 %1, %conv
  %tobool8.not.i = icmp eq i64 %and.i, 0
  br i1 %tobool8.not.i, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %arrayidx12.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 0
  %2 = load i64, ptr %arrayidx12.i, align 16
  %or.i = or i64 %2, %out.06.i
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %for.body.i
  %out.1.i = phi i64 [ %or.i, %if.then.i ], [ %out.06.i, %for.body.i ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i, 11
  br i1 %exitcond.i, label %moduleConvertKeySpecsFlags.exit, label %for.body.i, !llvm.loop !13

moduleConvertKeySpecsFlags.exit:                  ; preds = %for.inc.i
  %conv2 = trunc i64 %out.1.i to i32
  %3 = load ptr, ptr %user, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %4 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %4, i64 -1
  %5 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %5 to i32
  %and.i4 = and i32 %conv.i, 7
  switch i32 %and.i4, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %moduleConvertKeySpecsFlags.exit
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %moduleConvertKeySpecsFlags.exit
  %add.ptr.i = getelementptr inbounds i8, ptr %4, i64 -3
  %6 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %6 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %moduleConvertKeySpecsFlags.exit
  %add.ptr6.i = getelementptr inbounds i8, ptr %4, i64 -5
  %7 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %7 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %moduleConvertKeySpecsFlags.exit
  %add.ptr10.i = getelementptr inbounds i8, ptr %4, i64 -9
  %8 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %8 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %moduleConvertKeySpecsFlags.exit
  %add.ptr14.i = getelementptr inbounds i8, ptr %4, i64 -17
  %9 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %moduleConvertKeySpecsFlags.exit, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %9, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %moduleConvertKeySpecsFlags.exit ]
  %conv6 = trunc i64 %retval.0.i to i32
  %call7 = tail call i32 @ACLUserCheckKeyPerm(ptr noundef %3, ptr noundef nonnull %4, i32 noundef %conv6, i32 noundef %conv2) #32
  %cmp8.not = icmp eq i32 %call7, 0
  br i1 %cmp8.not, label %return, label %return.sink.split

return.sink.split:                                ; preds = %sdslen.exit, %entry
  %.sink = phi i32 [ 22, %entry ], [ 13, %sdslen.exit ]
  %call11 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call11, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %sdslen.exit
  %retval.0 = phi i32 [ 0, %sdslen.exit ], [ 1, %return.sink.split ]
  ret i32 %retval.0
}

declare i32 @ACLUserCheckKeyPerm(ptr noundef, ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ACLCheckChannelPermissions(ptr nocapture noundef readonly %user, ptr nocapture noundef readonly %ch, i32 noundef %flags) #0 {
entry:
  %cmp.not = icmp ult i32 %flags, 16
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call ptr @__errno_location() #37
  store i32 22, ptr %call, align 4
  br label %return

if.end:                                           ; preds = %entry
  %tobool.not = icmp ult i32 %flags, 8
  br i1 %tobool.not, label %if.end3, label %return

if.end3:                                          ; preds = %if.end
  %0 = and i32 %flags, 1
  %1 = load ptr, ptr %user, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %ch, i64 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %call8 = tail call i32 @ACLUserCheckChannelPerm(ptr noundef %1, ptr noundef %2, i32 noundef %0) #32
  %cmp9.not = icmp ne i32 %call8, 0
  %. = zext i1 %cmp9.not to i32
  br label %return

return:                                           ; preds = %if.end3, %if.end, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 0, %if.end ], [ %., %if.end3 ]
  ret i32 %retval.0
}

declare i32 @ACLUserCheckChannelPerm(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @moduleGetACLLogEntryReason(i32 noundef %reason) local_unnamed_addr #22 {
entry:
  %0 = icmp ult i32 %reason, 4
  br i1 %0, label %switch.lookup, label %sw.epilog

switch.lookup:                                    ; preds = %entry
  %1 = zext nneg i32 %reason to i64
  %switch.gep = getelementptr inbounds [4 x i32], ptr @switch.table.RM_ACLAddLogEntryByUserName, i64 0, i64 %1
  %switch.load = load i32, ptr %switch.gep, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %switch.lookup, %entry
  %acl_reason.0 = phi i32 [ 0, %entry ], [ %switch.load, %switch.lookup ]
  ret i32 %acl_reason.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ACLAddLogEntry(ptr nocapture noundef readonly %ctx, ptr nocapture noundef readonly %user, ptr nocapture noundef readonly %object, i32 noundef %reason) #0 {
entry:
  %0 = icmp ult i32 %reason, 4
  br i1 %0, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %entry
  %1 = zext nneg i32 %reason to i64
  %switch.gep = getelementptr inbounds [4 x i32], ptr @switch.table.RM_ACLAddLogEntryByUserName, i64 0, i64 %1
  %switch.load = load i32, ptr %switch.gep, align 4
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %client, align 8
  %3 = load ptr, ptr %user, align 8
  %4 = load ptr, ptr %3, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %object, i64 0, i32 2
  %5 = load ptr, ptr %ptr, align 8
  %call2 = tail call ptr @sdsdup(ptr noundef %5) #32
  tail call void @addACLLogEntry(ptr noundef %2, i32 noundef %switch.load, i32 noundef 3, i32 noundef -1, ptr noundef %4, ptr noundef %call2) #32
  br label %return

return:                                           ; preds = %entry, %switch.lookup
  %retval.0 = phi i32 [ 0, %switch.lookup ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ACLAddLogEntryByUserName(ptr nocapture noundef readonly %ctx, ptr nocapture noundef readonly %username, ptr nocapture noundef readonly %object, i32 noundef %reason) #0 {
entry:
  %0 = icmp ult i32 %reason, 4
  br i1 %0, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %entry
  %1 = zext nneg i32 %reason to i64
  %switch.gep = getelementptr inbounds [4 x i32], ptr @switch.table.RM_ACLAddLogEntryByUserName, i64 0, i64 %1
  %switch.load = load i32, ptr %switch.gep, align 4
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %client, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %username, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %object, i64 0, i32 2
  %4 = load ptr, ptr %ptr1, align 8
  %call2 = tail call ptr @sdsdup(ptr noundef %4) #32
  tail call void @addACLLogEntry(ptr noundef %2, i32 noundef %switch.load, i32 noundef 3, i32 noundef -1, ptr noundef %3, ptr noundef %call2) #32
  br label %return

return:                                           ; preds = %entry, %switch.lookup
  %retval.0 = phi i32 [ 0, %switch.lookup ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_AuthenticateClientWithUser(ptr nocapture noundef readonly %ctx, ptr nocapture noundef readonly %module_user, ptr noundef %callback, ptr noundef %privdata, ptr noundef writeonly %client_id) #0 {
entry:
  %0 = load ptr, ptr %module_user, align 8
  %flags.i = getelementptr inbounds %struct.user, ptr %0, i64 0, i32 1
  %1 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %1, 2
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %authenticateClientWithUser.exit

if.end.i:                                         ; preds = %entry
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %client.i, align 8
  %tobool1.not.i = icmp eq ptr %2, null
  br i1 %tobool1.not.i, label %authenticateClientWithUser.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end.i
  %flags3.i = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 1
  %3 = load i64, ptr %flags3.i, align 8
  %and4.i = and i64 %3, 134217728
  %tobool5.not.i = icmp eq i64 %and4.i, 0
  br i1 %tobool5.not.i, label %if.end7.i, label %authenticateClientWithUser.exit

if.end7.i:                                        ; preds = %lor.lhs.false.i
  %auth_callback.i.i = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 68
  %4 = load ptr, ptr %auth_callback.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %4, null
  br i1 %tobool.not.i.i, label %moduleNotifyUserChanged.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end7.i
  %5 = load i64, ptr %2, align 8
  %auth_callback_privdata.i.i = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 69
  %6 = load ptr, ptr %auth_callback_privdata.i.i, align 8
  tail call void %4(i64 noundef %5, ptr noundef %6) #32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %auth_callback.i.i, i8 0, i64 24, i1 false)
  %.pre.i = load ptr, ptr %client.i, align 8
  br label %moduleNotifyUserChanged.exit.i

moduleNotifyUserChanged.exit.i:                   ; preds = %if.then.i.i, %if.end7.i
  %7 = phi ptr [ %2, %if.end7.i ], [ %.pre.i, %if.then.i.i ]
  %user10.i = getelementptr inbounds %struct.client, ptr %7, i64 0, i32 20
  store ptr %0, ptr %user10.i, align 8
  %8 = load ptr, ptr %client.i, align 8
  %authenticated.i = getelementptr inbounds %struct.client, ptr %8, i64 0, i32 34
  store i32 1, ptr %authenticated.i, align 8
  %9 = load ptr, ptr %client.i, align 8
  %module_auth_ctx.i = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 67
  %10 = load ptr, ptr %module_auth_ctx.i, align 8
  %cmp.not.i = icmp eq ptr %10, null
  br i1 %cmp.not.i, label %if.end16.i, label %if.then13.i

if.then13.i:                                      ; preds = %moduleNotifyUserChanged.exit.i
  %flags15.i = getelementptr inbounds %struct.client, ptr %9, i64 0, i32 1
  %11 = load i64, ptr %flags15.i, align 8
  %or.i = or i64 %11, 140737488355328
  store i64 %or.i, ptr %flags15.i, align 8
  br label %if.end16.i

if.end16.i:                                       ; preds = %if.then13.i, %moduleNotifyUserChanged.exit.i
  %tobool17.not.i = icmp eq ptr %callback, null
  br i1 %tobool17.not.i, label %if.end22.i, label %if.then18.i

if.then18.i:                                      ; preds = %if.end16.i
  %12 = load ptr, ptr %client.i, align 8
  %auth_callback.i = getelementptr inbounds %struct.client, ptr %12, i64 0, i32 68
  store ptr %callback, ptr %auth_callback.i, align 8
  %13 = load ptr, ptr %client.i, align 8
  %auth_callback_privdata.i = getelementptr inbounds %struct.client, ptr %13, i64 0, i32 69
  store ptr %privdata, ptr %auth_callback_privdata.i, align 8
  %module.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %14 = load ptr, ptr %module.i, align 8
  %15 = load ptr, ptr %client.i, align 8
  %auth_module.i = getelementptr inbounds %struct.client, ptr %15, i64 0, i32 70
  store ptr %14, ptr %auth_module.i, align 8
  br label %if.end22.i

if.end22.i:                                       ; preds = %if.then18.i, %if.end16.i
  %tobool23.not.i = icmp eq ptr %client_id, null
  br i1 %tobool23.not.i, label %authenticateClientWithUser.exit, label %if.then24.i

if.then24.i:                                      ; preds = %if.end22.i
  %16 = load ptr, ptr %client.i, align 8
  %17 = load i64, ptr %16, align 8
  store i64 %17, ptr %client_id, align 8
  br label %authenticateClientWithUser.exit

authenticateClientWithUser.exit:                  ; preds = %entry, %if.end.i, %lor.lhs.false.i, %if.end22.i, %if.then24.i
  %retval.0.i = phi i32 [ 1, %entry ], [ 1, %lor.lhs.false.i ], [ 1, %if.end.i ], [ 0, %if.then24.i ], [ 0, %if.end22.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_AuthenticateClientWithACLUser(ptr nocapture noundef readonly %ctx, ptr noundef %name, i64 noundef %len, ptr noundef %callback, ptr noundef %privdata, ptr noundef writeonly %client_id) #0 {
entry:
  %call = tail call ptr @ACLGetUserByName(ptr noundef %name, i64 noundef %len) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %flags.i = getelementptr inbounds %struct.user, ptr %call, i64 0, i32 1
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 2
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %return

if.end.i:                                         ; preds = %if.end
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %1 = load ptr, ptr %client.i, align 8
  %tobool1.not.i = icmp eq ptr %1, null
  br i1 %tobool1.not.i, label %return, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.end.i
  %flags3.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 1
  %2 = load i64, ptr %flags3.i, align 8
  %and4.i = and i64 %2, 134217728
  %tobool5.not.i = icmp eq i64 %and4.i, 0
  br i1 %tobool5.not.i, label %if.end7.i, label %return

if.end7.i:                                        ; preds = %lor.lhs.false.i
  %auth_callback.i.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 68
  %3 = load ptr, ptr %auth_callback.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %3, null
  br i1 %tobool.not.i.i, label %moduleNotifyUserChanged.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end7.i
  %4 = load i64, ptr %1, align 8
  %auth_callback_privdata.i.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 69
  %5 = load ptr, ptr %auth_callback_privdata.i.i, align 8
  tail call void %3(i64 noundef %4, ptr noundef %5) #32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %auth_callback.i.i, i8 0, i64 24, i1 false)
  %.pre.i = load ptr, ptr %client.i, align 8
  br label %moduleNotifyUserChanged.exit.i

moduleNotifyUserChanged.exit.i:                   ; preds = %if.then.i.i, %if.end7.i
  %6 = phi ptr [ %1, %if.end7.i ], [ %.pre.i, %if.then.i.i ]
  %user10.i = getelementptr inbounds %struct.client, ptr %6, i64 0, i32 20
  store ptr %call, ptr %user10.i, align 8
  %7 = load ptr, ptr %client.i, align 8
  %authenticated.i = getelementptr inbounds %struct.client, ptr %7, i64 0, i32 34
  store i32 1, ptr %authenticated.i, align 8
  %8 = load ptr, ptr %client.i, align 8
  %module_auth_ctx.i = getelementptr inbounds %struct.client, ptr %8, i64 0, i32 67
  %9 = load ptr, ptr %module_auth_ctx.i, align 8
  %cmp.not.i = icmp eq ptr %9, null
  br i1 %cmp.not.i, label %if.end16.i, label %if.then13.i

if.then13.i:                                      ; preds = %moduleNotifyUserChanged.exit.i
  %flags15.i = getelementptr inbounds %struct.client, ptr %8, i64 0, i32 1
  %10 = load i64, ptr %flags15.i, align 8
  %or.i = or i64 %10, 140737488355328
  store i64 %or.i, ptr %flags15.i, align 8
  br label %if.end16.i

if.end16.i:                                       ; preds = %if.then13.i, %moduleNotifyUserChanged.exit.i
  %tobool17.not.i = icmp eq ptr %callback, null
  br i1 %tobool17.not.i, label %if.end22.i, label %if.then18.i

if.then18.i:                                      ; preds = %if.end16.i
  %11 = load ptr, ptr %client.i, align 8
  %auth_callback.i = getelementptr inbounds %struct.client, ptr %11, i64 0, i32 68
  store ptr %callback, ptr %auth_callback.i, align 8
  %12 = load ptr, ptr %client.i, align 8
  %auth_callback_privdata.i = getelementptr inbounds %struct.client, ptr %12, i64 0, i32 69
  store ptr %privdata, ptr %auth_callback_privdata.i, align 8
  %module.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %13 = load ptr, ptr %module.i, align 8
  %14 = load ptr, ptr %client.i, align 8
  %auth_module.i = getelementptr inbounds %struct.client, ptr %14, i64 0, i32 70
  store ptr %13, ptr %auth_module.i, align 8
  br label %if.end22.i

if.end22.i:                                       ; preds = %if.then18.i, %if.end16.i
  %tobool23.not.i = icmp eq ptr %client_id, null
  br i1 %tobool23.not.i, label %return, label %if.then24.i

if.then24.i:                                      ; preds = %if.end22.i
  %15 = load ptr, ptr %client.i, align 8
  %16 = load i64, ptr %15, align 8
  store i64 %16, ptr %client_id, align 8
  br label %return

return:                                           ; preds = %if.then24.i, %if.end22.i, %lor.lhs.false.i, %if.end.i, %if.end, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 1, %if.end ], [ 1, %lor.lhs.false.i ], [ 1, %if.end.i ], [ 0, %if.then24.i ], [ 0, %if.end22.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_DeauthenticateAndCloseClient(ptr nocapture readnone %ctx, i64 noundef %client_id) #0 {
entry:
  %call = tail call ptr @lookupClientByID(i64 noundef %client_id) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %auth_callback.i.i = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 68
  %0 = load ptr, ptr %auth_callback.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %0, null
  br i1 %tobool.not.i.i, label %moduleNotifyUserChanged.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end
  %1 = load i64, ptr %call, align 8
  %auth_callback_privdata.i.i = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 69
  %2 = load ptr, ptr %auth_callback_privdata.i.i, align 8
  tail call void %0(i64 noundef %1, ptr noundef %2) #32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %auth_callback.i.i, i8 0, i64 24, i1 false)
  br label %moduleNotifyUserChanged.exit.i

moduleNotifyUserChanged.exit.i:                   ; preds = %if.then.i.i, %if.end
  %3 = load ptr, ptr @DefaultUser, align 8
  %user.i = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 20
  store ptr %3, ptr %user.i, align 8
  %authenticated.i = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 34
  store i32 0, ptr %authenticated.i, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %cmp.i = icmp eq ptr %4, %call
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %moduleNotifyUserChanged.exit.i
  %flags.i = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 1
  %5 = load i64, ptr %flags.i, align 8
  %or.i = or i64 %5, 1099511627776
  store i64 %or.i, ptr %flags.i, align 8
  br label %return

if.else.i:                                        ; preds = %moduleNotifyUserChanged.exit.i
  tail call void @freeClientAsync(ptr noundef nonnull %call) #32
  br label %return

return:                                           ; preds = %if.else.i, %if.then.i, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %if.then.i ], [ 0, %if.else.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_RedactClientCommandArgument(ptr noundef readonly %ctx, i32 noundef %pos) #0 {
entry:
  %tobool.not = icmp eq ptr %ctx, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %tobool1 = icmp eq ptr %0, null
  %cmp = icmp slt i32 %pos, 1
  %or.cond = or i1 %cmp, %tobool1
  br i1 %or.cond, label %return, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %argc = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 11
  %1 = load i32, ptr %argc, align 8
  %cmp5.not = icmp sgt i32 %1, %pos
  br i1 %cmp5.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false3
  tail call void @redactClientCommandArgument(ptr noundef nonnull %0, i32 noundef %pos) #32
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %lor.lhs.false3, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %lor.lhs.false3 ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @redactClientCommandArgument(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetClientCertificate(ptr noundef %ctx, i64 noundef %client_id) #0 {
entry:
  %call = tail call ptr @lookupClientByID(i64 noundef %client_id) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conn = getelementptr inbounds %struct.client, ptr %call, i64 0, i32 2
  %0 = load ptr, ptr %conn, align 8
  %1 = load ptr, ptr %0, align 8
  %get_peer_cert.i = getelementptr inbounds %struct.ConnectionType, ptr %1, i64 0, i32 27
  %2 = load ptr, ptr %get_peer_cert.i, align 8
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %return, label %connGetPeerCert.exit

connGetPeerCert.exit:                             ; preds = %if.end
  %call.i = tail call ptr %2(ptr noundef nonnull %0) #32
  %tobool.not = icmp eq ptr %call.i, null
  br i1 %tobool.not, label %return, label %if.end3

if.end3:                                          ; preds = %connGetPeerCert.exit
  %call4 = tail call ptr @createObject(i32 noundef 0, ptr noundef nonnull %call.i) #32
  %cmp5.not = icmp eq ptr %ctx, null
  br i1 %cmp5.not, label %return, label %if.then6

if.then6:                                         ; preds = %if.end3
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %3 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %3, 1
  %tobool.not.i5 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i5, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then6
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %4 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %5 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %4, %5
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %4, 1
  %cmp4.i = icmp slt i32 %4, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %6 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i6 = tail call ptr @zrealloc(ptr noundef %6, i64 noundef %mul9.i) #34
  store ptr %call.i6, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %7 = phi i32 [ %4, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %8 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i6, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %7 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %9 = load ptr, ptr %amqueue12.i, align 8
  %10 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %10 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %9, i64 %idxprom17.i
  store ptr %call4, ptr %arrayidx18.i, align 8
  %11 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %11, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end, %if.end11.i, %if.then6, %if.end3, %connGetPeerCert.exit, %entry
  %retval.0 = phi ptr [ null, %entry ], [ null, %connGetPeerCert.exit ], [ %call4, %if.end3 ], [ %call4, %if.then6 ], [ %call4, %if.end11.i ], [ null, %if.end ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_CreateDict(ptr noundef %ctx) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(8) ptr @zmalloc(i64 noundef 8) #33
  %call1 = tail call ptr @raxNew() #32
  store ptr %call1, ptr %call, align 8
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %1, %2
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %1, 1
  %cmp4.i = icmp slt i32 %1, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %5 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %4 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i, i32 1
  store i32 4, ptr %type14.i, align 8
  %6 = load ptr, ptr %amqueue12.i, align 8
  %7 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %7 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i
  store ptr %call, ptr %arrayidx18.i, align 8
  %8 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %8, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %if.end

if.end:                                           ; preds = %if.end11.i, %if.then, %entry
  ret ptr %call
}

declare ptr @raxNew() local_unnamed_addr #1

declare void @raxFree(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_DictSize(ptr nocapture noundef readonly %d) #0 {
entry:
  %0 = load ptr, ptr %d, align 8
  %call = tail call i64 @raxSize(ptr noundef %0) #32
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictSetC(ptr nocapture noundef readonly %d, ptr noundef %key, i64 noundef %keylen, ptr noundef %ptr) #0 {
entry:
  %0 = load ptr, ptr %d, align 8
  %call = tail call i32 @raxTryInsert(ptr noundef %0, ptr noundef %key, i64 noundef %keylen, ptr noundef %ptr, ptr noundef null) #32
  %cmp = icmp ne i32 %call, 1
  %cond = zext i1 %cmp to i32
  ret i32 %cond
}

declare i32 @raxTryInsert(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictReplaceC(ptr nocapture noundef readonly %d, ptr noundef %key, i64 noundef %keylen, ptr noundef %ptr) #0 {
entry:
  %0 = load ptr, ptr %d, align 8
  %call = tail call i32 @raxInsert(ptr noundef %0, ptr noundef %key, i64 noundef %keylen, ptr noundef %ptr, ptr noundef null) #32
  %cmp = icmp ne i32 %call, 1
  %cond = zext i1 %cmp to i32
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictSet(ptr nocapture noundef readonly %d, ptr nocapture noundef readonly %key, ptr noundef %ptr) #0 {
entry:
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr1, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %6 = load ptr, ptr %d, align 8
  %call.i = tail call i32 @raxTryInsert(ptr noundef %6, ptr noundef nonnull %0, i64 noundef %retval.0.i, ptr noundef %ptr, ptr noundef null) #32
  %cmp.i = icmp ne i32 %call.i, 1
  %cond.i = zext i1 %cmp.i to i32
  ret i32 %cond.i
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictReplace(ptr nocapture noundef readonly %d, ptr nocapture noundef readonly %key, ptr noundef %ptr) #0 {
entry:
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr1, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %6 = load ptr, ptr %d, align 8
  %call.i = tail call i32 @raxInsert(ptr noundef %6, ptr noundef nonnull %0, i64 noundef %retval.0.i, ptr noundef %ptr, ptr noundef null) #32
  %cmp.i = icmp ne i32 %call.i, 1
  %cond.i = zext i1 %cmp.i to i32
  ret i32 %cond.i
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictGetC(ptr nocapture noundef readonly %d, ptr noundef %key, i64 noundef %keylen, ptr noundef writeonly %nokey) #0 {
entry:
  %res = alloca ptr, align 8
  store ptr null, ptr %res, align 8
  %0 = load ptr, ptr %d, align 8
  %call = call i32 @raxFind(ptr noundef %0, ptr noundef %key, i64 noundef %keylen, ptr noundef nonnull %res) #32
  %tobool.not = icmp eq ptr %nokey, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %tobool1.not = icmp eq i32 %call, 0
  %lnot.ext = zext i1 %tobool1.not to i32
  store i32 %lnot.ext, ptr %nokey, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %res, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictGet(ptr nocapture noundef readonly %d, ptr nocapture noundef readonly %key, ptr noundef writeonly %nokey) #0 {
entry:
  %res.i = alloca ptr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %res.i)
  store ptr null, ptr %res.i, align 8
  %6 = load ptr, ptr %d, align 8
  %call.i = call i32 @raxFind(ptr noundef %6, ptr noundef nonnull %0, i64 noundef %retval.0.i, ptr noundef nonnull %res.i) #32
  %tobool.not.i = icmp eq ptr %nokey, null
  br i1 %tobool.not.i, label %RM_DictGetC.exit, label %if.then.i

if.then.i:                                        ; preds = %sdslen.exit
  %tobool1.not.i = icmp eq i32 %call.i, 0
  %lnot.ext.i = zext i1 %tobool1.not.i to i32
  store i32 %lnot.ext.i, ptr %nokey, align 4
  br label %RM_DictGetC.exit

RM_DictGetC.exit:                                 ; preds = %sdslen.exit, %if.then.i
  %7 = load ptr, ptr %res.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %res.i)
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictDelC(ptr nocapture noundef readonly %d, ptr noundef %key, i64 noundef %keylen, ptr noundef %oldval) #0 {
entry:
  %0 = load ptr, ptr %d, align 8
  %call = tail call i32 @raxRemove(ptr noundef %0, ptr noundef %key, i64 noundef %keylen, ptr noundef %oldval) #32
  %tobool.not = icmp eq i32 %call, 0
  %cond = zext i1 %tobool.not to i32
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictDel(ptr nocapture noundef readonly %d, ptr nocapture noundef readonly %key, ptr noundef %oldval) #0 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %6 = load ptr, ptr %d, align 8
  %call.i = tail call i32 @raxRemove(ptr noundef %6, ptr noundef nonnull %0, i64 noundef %retval.0.i, ptr noundef %oldval) #32
  %tobool.not.i = icmp eq i32 %call.i, 0
  %cond.i = zext i1 %tobool.not.i to i32
  ret i32 %cond.i
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_DictIteratorStartC(ptr noundef %d, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(488) ptr @zmalloc(i64 noundef 488) #33
  store ptr %d, ptr %call, align 8
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %call, i64 0, i32 1
  %0 = load ptr, ptr %d, align 8
  tail call void @raxStart(ptr noundef nonnull %ri, ptr noundef %0) #32
  %call2 = tail call i32 @raxSeek(ptr noundef nonnull %ri, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #32
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_DictIteratorStart(ptr noundef %d, ptr noundef %op, ptr nocapture noundef readonly %key) #0 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call.i = tail call noalias dereferenceable_or_null(488) ptr @zmalloc(i64 noundef 488) #33
  store ptr %d, ptr %call.i, align 8
  %ri.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %call.i, i64 0, i32 1
  %6 = load ptr, ptr %d, align 8
  tail call void @raxStart(ptr noundef nonnull %ri.i, ptr noundef %6) #32
  %call2.i = tail call i32 @raxSeek(ptr noundef nonnull %ri.i, ptr noundef %op, ptr noundef nonnull %0, i64 noundef %retval.0.i) #32
  ret ptr %call.i
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_DictIteratorStop(ptr noundef %di) #0 {
entry:
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  tail call void @raxStop(ptr noundef nonnull %ri) #32
  tail call void @zfree(ptr noundef %di) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictIteratorReseekC(ptr noundef %di, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #0 {
entry:
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  %call = tail call i32 @raxSeek(ptr noundef nonnull %ri, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #32
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictIteratorReseek(ptr noundef %di, ptr noundef %op, ptr nocapture noundef readonly %key) #0 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %ri.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  %call.i = tail call i32 @raxSeek(ptr noundef nonnull %ri.i, ptr noundef %op, ptr noundef nonnull %0, i64 noundef %retval.0.i) #32
  ret i32 %call.i
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictNextC(ptr noundef %di, ptr noundef writeonly %keylen, ptr noundef writeonly %dataptr) #0 {
entry:
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  %call = tail call i32 @raxNext(ptr noundef nonnull %ri) #32
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1.not = icmp eq ptr %keylen, null
  br i1 %tobool1.not, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %key_len = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 4
  %0 = load i64, ptr %key_len, align 8
  store i64 %0, ptr %keylen, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %tobool5.not = icmp eq ptr %dataptr, null
  br i1 %tobool5.not, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end4
  %data = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 3
  %1 = load ptr, ptr %data, align 8
  store ptr %1, ptr %dataptr, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %key = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 2
  %2 = load ptr, ptr %key, align 8
  br label %return

return:                                           ; preds = %entry, %if.end8
  %retval.0 = phi ptr [ %2, %if.end8 ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictPrevC(ptr noundef %di, ptr noundef writeonly %keylen, ptr noundef writeonly %dataptr) #0 {
entry:
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  %call = tail call i32 @raxPrev(ptr noundef nonnull %ri) #32
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool1.not = icmp eq ptr %keylen, null
  br i1 %tobool1.not, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %key_len = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 4
  %0 = load i64, ptr %key_len, align 8
  store i64 %0, ptr %keylen, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %tobool5.not = icmp eq ptr %dataptr, null
  br i1 %tobool5.not, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end4
  %data = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 3
  %1 = load ptr, ptr %data, align 8
  store ptr %1, ptr %dataptr, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %key = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 2
  %2 = load ptr, ptr %key, align 8
  br label %return

return:                                           ; preds = %entry, %if.end8
  %retval.0 = phi ptr [ %2, %if.end8 ], [ null, %entry ]
  ret ptr %retval.0
}

declare i32 @raxPrev(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictNext(ptr noundef %ctx, ptr noundef %di, ptr noundef writeonly %dataptr) #0 {
entry:
  %ri.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  %call.i = tail call i32 @raxNext(ptr noundef nonnull %ri.i) #32
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %entry
  %key_len.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 4
  %0 = load i64, ptr %key_len.i, align 8
  %tobool5.not.i = icmp eq ptr %dataptr, null
  br i1 %tobool5.not.i, label %RM_DictNextC.exit, label %if.then6.i

if.then6.i:                                       ; preds = %if.end.i
  %data.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 3
  %1 = load ptr, ptr %data.i, align 8
  store ptr %1, ptr %dataptr, align 8
  br label %RM_DictNextC.exit

RM_DictNextC.exit:                                ; preds = %if.end.i, %if.then6.i
  %key.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 2
  %2 = load ptr, ptr %key.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %RM_DictNextC.exit
  %call.i2 = tail call ptr @createStringObject(ptr noundef nonnull %2, i64 noundef %0) #32
  %cmp.not.i = icmp eq ptr %ctx, null
  br i1 %cmp.not.i, label %return, label %if.then.i

if.then.i:                                        ; preds = %if.end
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %3 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %3, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %4 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %5 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %4, %5
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %if.end11.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %4, 1
  %cmp4.i.i = icmp slt i32 %4, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %6 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = tail call ptr @zrealloc(ptr noundef %6, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then1.i.i, %if.end.if.end11_crit_edge.i.i
  %7 = phi i32 [ %4, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ]
  %8 = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ]
  %amqueue12.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i.i = sext i32 %7 to i64
  %type14.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom.i.i, i32 1
  store i32 1, ptr %type14.i.i, align 8
  %9 = load ptr, ptr %amqueue12.i.i, align 8
  %10 = load i32, ptr %amqueue_used.i.i, align 4
  %idxprom17.i.i = sext i32 %10 to i64
  %arrayidx18.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %9, i64 %idxprom17.i.i
  store ptr %call.i2, ptr %arrayidx18.i.i, align 8
  %11 = load i32, ptr %amqueue_used.i.i, align 4
  %inc.i.i = add nsw i32 %11, 1
  store i32 %inc.i.i, ptr %amqueue_used.i.i, align 4
  br label %return

return:                                           ; preds = %entry, %if.end11.i.i, %if.then.i, %if.end, %RM_DictNextC.exit
  %retval.0 = phi ptr [ null, %RM_DictNextC.exit ], [ %call.i2, %if.end ], [ %call.i2, %if.then.i ], [ %call.i2, %if.end11.i.i ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictPrev(ptr noundef %ctx, ptr noundef %di, ptr noundef writeonly %dataptr) #0 {
entry:
  %ri.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  %call.i = tail call i32 @raxPrev(ptr noundef nonnull %ri.i) #32
  %tobool.not.i = icmp eq i32 %call.i, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %entry
  %key_len.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 4
  %0 = load i64, ptr %key_len.i, align 8
  %tobool5.not.i = icmp eq ptr %dataptr, null
  br i1 %tobool5.not.i, label %RM_DictPrevC.exit, label %if.then6.i

if.then6.i:                                       ; preds = %if.end.i
  %data.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 3
  %1 = load ptr, ptr %data.i, align 8
  store ptr %1, ptr %dataptr, align 8
  br label %RM_DictPrevC.exit

RM_DictPrevC.exit:                                ; preds = %if.end.i, %if.then6.i
  %key.i = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1, i32 2
  %2 = load ptr, ptr %key.i, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %RM_DictPrevC.exit
  %call.i2 = tail call ptr @createStringObject(ptr noundef nonnull %2, i64 noundef %0) #32
  %cmp.not.i = icmp eq ptr %ctx, null
  br i1 %cmp.not.i, label %return, label %if.then.i

if.then.i:                                        ; preds = %if.end
  %flags.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %3 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %3, 1
  %tobool.not.i.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i.i, label %return, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  %amqueue_used.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %4 = load i32, ptr %amqueue_used.i.i, align 4
  %amqueue_len.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %5 = load i32, ptr %amqueue_len.i.i, align 8
  %cmp.i.i = icmp eq i32 %4, %5
  br i1 %cmp.i.i, label %if.then1.i.i, label %if.end.if.end11_crit_edge.i.i

if.end.if.end11_crit_edge.i.i:                    ; preds = %if.end.i.i
  %amqueue12.phi.trans.insert.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i.i = load ptr, ptr %amqueue12.phi.trans.insert.i.i, align 8
  br label %if.end11.i.i

if.then1.i.i:                                     ; preds = %if.end.i.i
  %mul.i.i = shl nsw i32 %4, 1
  %cmp4.i.i = icmp slt i32 %4, 8
  %spec.select.i.i = select i1 %cmp4.i.i, i32 16, i32 %mul.i.i
  store i32 %spec.select.i.i, ptr %amqueue_len.i.i, align 8
  %amqueue.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %6 = load ptr, ptr %amqueue.i.i, align 8
  %conv.i.i = sext i32 %spec.select.i.i to i64
  %mul9.i.i = shl nsw i64 %conv.i.i, 4
  %call.i.i = tail call ptr @zrealloc(ptr noundef %6, i64 noundef %mul9.i.i) #34
  store ptr %call.i.i, ptr %amqueue.i.i, align 8
  %.pre14.i.i = load i32, ptr %amqueue_used.i.i, align 4
  br label %if.end11.i.i

if.end11.i.i:                                     ; preds = %if.then1.i.i, %if.end.if.end11_crit_edge.i.i
  %7 = phi i32 [ %4, %if.end.if.end11_crit_edge.i.i ], [ %.pre14.i.i, %if.then1.i.i ]
  %8 = phi ptr [ %.pre.i.i, %if.end.if.end11_crit_edge.i.i ], [ %call.i.i, %if.then1.i.i ]
  %amqueue12.i.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i.i = sext i32 %7 to i64
  %type14.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom.i.i, i32 1
  store i32 1, ptr %type14.i.i, align 8
  %9 = load ptr, ptr %amqueue12.i.i, align 8
  %10 = load i32, ptr %amqueue_used.i.i, align 4
  %idxprom17.i.i = sext i32 %10 to i64
  %arrayidx18.i.i = getelementptr inbounds %struct.AutoMemEntry, ptr %9, i64 %idxprom17.i.i
  store ptr %call.i2, ptr %arrayidx18.i.i, align 8
  %11 = load i32, ptr %amqueue_used.i.i, align 4
  %inc.i.i = add nsw i32 %11, 1
  store i32 %inc.i.i, ptr %amqueue_used.i.i, align 4
  br label %return

return:                                           ; preds = %entry, %if.end11.i.i, %if.then.i, %if.end, %RM_DictPrevC.exit
  %retval.0 = phi ptr [ null, %RM_DictPrevC.exit ], [ %call.i2, %if.end ], [ %call.i2, %if.then.i ], [ %call.i2, %if.end11.i.i ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictCompareC(ptr noundef %di, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #0 {
entry:
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  %call = tail call i32 @raxEOF(ptr noundef nonnull %ri) #32
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call2 = tail call i32 @raxCompare(ptr noundef nonnull %ri, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #32
  %tobool3.not = icmp eq i32 %call2, 0
  %cond = zext i1 %tobool3.not to i32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %cond, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare i32 @raxEOF(ptr noundef) local_unnamed_addr #1

declare i32 @raxCompare(ptr noundef, ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictCompare(ptr noundef %di, ptr noundef %op, ptr nocapture noundef readonly %key) #0 {
entry:
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %di, i64 0, i32 1
  %call = tail call i32 @raxEOF(ptr noundef nonnull %ri) #32
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end ]
  %call4 = tail call i32 @raxCompare(ptr noundef nonnull %ri, ptr noundef %op, ptr noundef nonnull %0, i64 noundef %retval.0.i) #32
  %tobool5.not = icmp eq i32 %call4, 0
  %cond = zext i1 %tobool5.not to i32
  br label %return

return:                                           ; preds = %entry, %sdslen.exit
  %retval.0 = phi i32 [ %cond, %sdslen.exit ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_InfoAddSection(ptr nocapture noundef %ctx, ptr noundef %name) #0 {
entry:
  %0 = load ptr, ptr %ctx, align 8
  %name1 = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %name1, align 8
  %call = tail call ptr @sdsdup(ptr noundef %1) #32
  %cmp.not = icmp eq ptr %name, null
  br i1 %cmp.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %char0 = load i8, ptr %name, align 1
  %cmp3.not = icmp eq i8 %char0, 0
  br i1 %cmp3.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call4 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call, ptr noundef nonnull @.str.81, ptr noundef nonnull %name) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %full_name.0 = phi ptr [ %call4, %if.then ], [ %call, %land.lhs.true ], [ %call, %entry ]
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %in_dict_field, align 8
  %tobool.not = icmp eq i32 %2, 0
  br i1 %tobool.not, label %if.end7, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %info.i = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %3 = load ptr, ptr %info.i, align 8
  %arrayidx.i.i = getelementptr inbounds i8, ptr %3, i64 -1
  %4 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %4 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %3, i64 -3
  %5 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %5 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end.i
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %3, i64 -5
  %6 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %6 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end.i
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %3, i64 -9
  %7 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %7 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end.i
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %3, i64 -17
  %8 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end.i
  %retval.0.i.i = phi i64 [ %8, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end.i ]
  %9 = getelementptr i8, ptr %3, i64 %retval.0.i.i
  %arrayidx.i = getelementptr i8, ptr %9, i64 -1
  %10 = load i8, ptr %arrayidx.i, align 1
  %cmp.i = icmp eq i8 %10, 44
  br i1 %cmp.i, label %if.then3.i, label %RM_InfoEndDictField.exit

if.then3.i:                                       ; preds = %sdslen.exit.i
  tail call void @sdsIncrLen(ptr noundef nonnull %3, i64 noundef -1) #32
  %.pre.i = load ptr, ptr %info.i, align 8
  br label %RM_InfoEndDictField.exit

RM_InfoEndDictField.exit:                         ; preds = %sdslen.exit.i, %if.then3.i
  %11 = phi ptr [ %.pre.i, %if.then3.i ], [ %3, %sdslen.exit.i ]
  %call7.i = tail call ptr @sdscat(ptr noundef %11, ptr noundef nonnull @.str.36) #32
  store ptr %call7.i, ptr %info.i, align 8
  store i32 0, ptr %in_dict_field, align 8
  br label %if.end7

if.end7:                                          ; preds = %RM_InfoEndDictField.exit, %if.end
  %requested_sections = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 1
  %12 = load ptr, ptr %requested_sections, align 8
  %tobool8.not = icmp eq ptr %12, null
  br i1 %tobool8.not, label %if.end22, label %if.then9

if.then9:                                         ; preds = %if.end7
  %tobool10.not = icmp eq ptr %full_name.0, null
  br i1 %tobool10.not, label %land.lhs.true14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then9
  %call12 = tail call ptr @dictFind(ptr noundef nonnull %12, ptr noundef nonnull %full_name.0) #32
  %tobool13.not = icmp eq ptr %call12, null
  br i1 %tobool13.not, label %lor.lhs.false.land.lhs.true14_crit_edge, label %if.end22

lor.lhs.false.land.lhs.true14_crit_edge:          ; preds = %lor.lhs.false
  %.pre = load ptr, ptr %requested_sections, align 8
  br label %land.lhs.true14

land.lhs.true14:                                  ; preds = %lor.lhs.false.land.lhs.true14_crit_edge, %if.then9
  %13 = phi ptr [ %.pre, %lor.lhs.false.land.lhs.true14_crit_edge ], [ %12, %if.then9 ]
  %14 = load ptr, ptr %ctx, align 8
  %name17 = getelementptr inbounds %struct.RedisModule, ptr %14, i64 0, i32 1
  %15 = load ptr, ptr %name17, align 8
  %call18 = tail call ptr @dictFind(ptr noundef %13, ptr noundef %15) #32
  %tobool19.not = icmp eq ptr %call18, null
  br i1 %tobool19.not, label %if.then20, label %if.end22

if.then20:                                        ; preds = %land.lhs.true14
  tail call void @sdsfree(ptr noundef %full_name.0) #32
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 4
  store i32 0, ptr %in_section, align 4
  br label %return

if.end22:                                         ; preds = %lor.lhs.false, %land.lhs.true14, %if.end7
  %sections = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 3
  %16 = load i32, ptr %sections, align 8
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %sections, align 8
  %tobool23.not = icmp eq i32 %16, 0
  %info28.phi.trans.insert = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %.pre21 = load ptr, ptr %info28.phi.trans.insert, align 8
  br i1 %tobool23.not, label %if.end27, label %if.then24

if.then24:                                        ; preds = %if.end22
  %call25 = tail call ptr @sdscat(ptr noundef %.pre21, ptr noundef nonnull @.str.36) #32
  store ptr %call25, ptr %info28.phi.trans.insert, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.end22, %if.then24
  %17 = phi ptr [ %call25, %if.then24 ], [ %.pre21, %if.end22 ]
  %info28 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %call29 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %17, ptr noundef nonnull @.str.82, ptr noundef %full_name.0) #32
  store ptr %call29, ptr %info28, align 8
  %in_section31 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 4
  store i32 1, ptr %in_section31, align 4
  tail call void @sdsfree(ptr noundef %full_name.0) #32
  br label %return

return:                                           ; preds = %if.end27, %if.then20
  %retval.0 = phi i32 [ 0, %if.end27 ], [ 1, %if.then20 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_InfoEndDictField(ptr nocapture noundef %ctx) #0 {
entry:
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 5
  %0 = load i32, ptr %in_dict_field, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %1 = load ptr, ptr %info, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end ]
  %7 = getelementptr i8, ptr %1, i64 %retval.0.i
  %arrayidx = getelementptr i8, ptr %7, i64 -1
  %8 = load i8, ptr %arrayidx, align 1
  %cmp = icmp eq i8 %8, 44
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %sdslen.exit
  tail call void @sdsIncrLen(ptr noundef nonnull %1, i64 noundef -1) #32
  %.pre = load ptr, ptr %info, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %sdslen.exit
  %9 = phi ptr [ %.pre, %if.then3 ], [ %1, %sdslen.exit ]
  %call7 = tail call ptr @sdscat(ptr noundef %9, ptr noundef nonnull @.str.36) #32
  store ptr %call7, ptr %info, align 8
  store i32 0, ptr %in_dict_field, align 8
  br label %return

return:                                           ; preds = %entry, %if.end5
  %retval.0 = phi i32 [ 0, %if.end5 ], [ 1, %entry ]
  ret i32 %retval.0
}

declare ptr @sdscat(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_InfoBeginDictField(ptr nocapture noundef %ctx, ptr noundef %name) #0 {
entry:
  %tmpmodname = alloca ptr, align 8
  %tmpname = alloca ptr, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 4
  %0 = load i32, ptr %in_section, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 5
  %1 = load i32, ptr %in_dict_field, align 8
  %tobool1.not = icmp eq i32 %1, 0
  %info.phi.trans.insert = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %.pre = load ptr, ptr %info.phi.trans.insert, align 8
  br i1 %tobool1.not, label %if.end3, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %arrayidx.i.i = getelementptr inbounds i8, ptr %.pre, i64 -1
  %2 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %2 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %.pre, i64 -3
  %3 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %3 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end.i
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %.pre, i64 -5
  %4 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %4 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end.i
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %.pre, i64 -9
  %5 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %5 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end.i
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %.pre, i64 -17
  %6 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end.i
  %retval.0.i.i = phi i64 [ %6, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end.i ]
  %7 = getelementptr i8, ptr %.pre, i64 %retval.0.i.i
  %arrayidx.i = getelementptr i8, ptr %7, i64 -1
  %8 = load i8, ptr %arrayidx.i, align 1
  %cmp.i = icmp eq i8 %8, 44
  br i1 %cmp.i, label %if.then3.i, label %RM_InfoEndDictField.exit

if.then3.i:                                       ; preds = %sdslen.exit.i
  tail call void @sdsIncrLen(ptr noundef nonnull %.pre, i64 noundef -1) #32
  %.pre.i = load ptr, ptr %info.phi.trans.insert, align 8
  br label %RM_InfoEndDictField.exit

RM_InfoEndDictField.exit:                         ; preds = %sdslen.exit.i, %if.then3.i
  %9 = phi ptr [ %.pre.i, %if.then3.i ], [ %.pre, %sdslen.exit.i ]
  %call7.i = tail call ptr @sdscat(ptr noundef %9, ptr noundef nonnull @.str.36) #32
  store ptr %call7.i, ptr %info.phi.trans.insert, align 8
  store i32 0, ptr %in_dict_field, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.end, %RM_InfoEndDictField.exit
  %10 = phi ptr [ %call7.i, %RM_InfoEndDictField.exit ], [ %.pre, %if.end ]
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %11 = load ptr, ptr %ctx, align 8
  %name4 = getelementptr inbounds %struct.RedisModule, ptr %11, i64 0, i32 1
  %12 = load ptr, ptr %name4, align 8
  %call7 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %12) #36
  %call8 = call ptr @getSafeInfoString(ptr noundef %12, i64 noundef %call7, ptr noundef nonnull %tmpmodname) #32
  %call9 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %name) #36
  %call10 = call ptr @getSafeInfoString(ptr noundef %name, i64 noundef %call9, ptr noundef nonnull %tmpname) #32
  %call11 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %10, ptr noundef nonnull @.str.83, ptr noundef %call8, ptr noundef %call10) #32
  store ptr %call11, ptr %info, align 8
  %13 = load ptr, ptr %tmpmodname, align 8
  %cmp.not = icmp eq ptr %13, null
  br i1 %cmp.not, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end3
  call void @zfree(ptr noundef nonnull %13) #32
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end3
  %14 = load ptr, ptr %tmpname, align 8
  %cmp15.not = icmp eq ptr %14, null
  br i1 %cmp15.not, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end14
  call void @zfree(ptr noundef nonnull %14) #32
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end14
  store i32 1, ptr %in_dict_field, align 8
  br label %return

return:                                           ; preds = %entry, %if.end17
  %retval.0 = phi i32 [ 0, %if.end17 ], [ 1, %entry ]
  ret i32 %retval.0
}

declare ptr @getSafeInfoString(ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

declare void @sdsIncrLen(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_InfoAddFieldString(ptr nocapture noundef %ctx, ptr noundef %field, ptr nocapture noundef readonly %value) #0 {
entry:
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 4
  %0 = load i32, ptr %in_section, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 5
  %1 = load i32, ptr %in_dict_field, align 8
  %tobool1.not = icmp eq i32 %1, 0
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %info5, align 8
  br i1 %tobool1.not, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %ptr = getelementptr inbounds %struct.redisObject, ptr %value, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %2, ptr noundef nonnull @.str.84, ptr noundef %field, ptr noundef %3) #32
  br label %return.sink.split

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %ctx, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 1
  %5 = load ptr, ptr %name, align 8
  %ptr6 = getelementptr inbounds %struct.redisObject, ptr %value, i64 0, i32 2
  %6 = load ptr, ptr %ptr6, align 8
  %call7 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %2, ptr noundef nonnull @.str.85, ptr noundef %5, ptr noundef %field, ptr noundef %6) #32
  br label %return.sink.split

return.sink.split:                                ; preds = %if.then2, %if.end4
  %call7.sink = phi ptr [ %call7, %if.end4 ], [ %call, %if.then2 ]
  store ptr %call7.sink, ptr %info5, align 8
  br label %return

return:                                           ; preds = %return.sink.split, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_InfoAddFieldCString(ptr nocapture noundef %ctx, ptr noundef %field, ptr noundef %value) #0 {
entry:
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 4
  %0 = load i32, ptr %in_section, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 5
  %1 = load i32, ptr %in_dict_field, align 8
  %tobool1.not = icmp eq i32 %1, 0
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %info5, align 8
  br i1 %tobool1.not, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %call = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %2, ptr noundef nonnull @.str.86, ptr noundef %field, ptr noundef %value) #32
  br label %return.sink.split

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %ctx, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %name, align 8
  %call6 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %2, ptr noundef nonnull @.str.87, ptr noundef %4, ptr noundef %field, ptr noundef %value) #32
  br label %return.sink.split

return.sink.split:                                ; preds = %if.then2, %if.end4
  %call6.sink = phi ptr [ %call6, %if.end4 ], [ %call, %if.then2 ]
  store ptr %call6.sink, ptr %info5, align 8
  br label %return

return:                                           ; preds = %return.sink.split, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_InfoAddFieldDouble(ptr nocapture noundef %ctx, ptr noundef %field, double noundef %value) #0 {
entry:
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 4
  %0 = load i32, ptr %in_section, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 5
  %1 = load i32, ptr %in_dict_field, align 8
  %tobool1.not = icmp eq i32 %1, 0
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %info5, align 8
  br i1 %tobool1.not, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %call = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %2, ptr noundef nonnull @.str.88, ptr noundef %field, double noundef %value) #32
  br label %return.sink.split

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %ctx, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %name, align 8
  %call6 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %2, ptr noundef nonnull @.str.89, ptr noundef %4, ptr noundef %field, double noundef %value) #32
  br label %return.sink.split

return.sink.split:                                ; preds = %if.then2, %if.end4
  %call6.sink = phi ptr [ %call6, %if.end4 ], [ %call, %if.then2 ]
  store ptr %call6.sink, ptr %info5, align 8
  br label %return

return:                                           ; preds = %return.sink.split, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

declare ptr @sdscatprintf(ptr noundef, ptr noundef, ...) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_InfoAddFieldLongLong(ptr nocapture noundef %ctx, ptr noundef %field, i64 noundef %value) #0 {
entry:
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 4
  %0 = load i32, ptr %in_section, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 5
  %1 = load i32, ptr %in_dict_field, align 8
  %tobool1.not = icmp eq i32 %1, 0
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %info5, align 8
  br i1 %tobool1.not, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %call = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %2, ptr noundef nonnull @.str.90, ptr noundef %field, i64 noundef %value) #32
  br label %return.sink.split

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %ctx, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %name, align 8
  %call6 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %2, ptr noundef nonnull @.str.91, ptr noundef %4, ptr noundef %field, i64 noundef %value) #32
  br label %return.sink.split

return.sink.split:                                ; preds = %if.then2, %if.end4
  %call6.sink = phi ptr [ %call6, %if.end4 ], [ %call, %if.then2 ]
  store ptr %call6.sink, ptr %info5, align 8
  br label %return

return:                                           ; preds = %return.sink.split, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_InfoAddFieldULongLong(ptr nocapture noundef %ctx, ptr noundef %field, i64 noundef %value) #0 {
entry:
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 4
  %0 = load i32, ptr %in_section, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 5
  %1 = load i32, ptr %in_dict_field, align 8
  %tobool1.not = icmp eq i32 %1, 0
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %ctx, i64 0, i32 2
  %2 = load ptr, ptr %info5, align 8
  br i1 %tobool1.not, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %call = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %2, ptr noundef nonnull @.str.92, ptr noundef %field, i64 noundef %value) #32
  br label %return.sink.split

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %ctx, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %3, i64 0, i32 1
  %4 = load ptr, ptr %name, align 8
  %call6 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %2, ptr noundef nonnull @.str.93, ptr noundef %4, ptr noundef %field, i64 noundef %value) #32
  br label %return.sink.split

return.sink.split:                                ; preds = %if.then2, %if.end4
  %call6.sink = phi ptr [ %call6, %if.end4 ], [ %call, %if.then2 ]
  store ptr %call6.sink, ptr %info5, align 8
  br label %return

return:                                           ; preds = %return.sink.split, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define dso_local noundef i32 @RM_RegisterInfoFunc(ptr nocapture noundef readonly %ctx, ptr noundef %cb) #14 {
entry:
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %info_cb = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 14
  store ptr %cb, ptr %info_cb, align 8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @modulesCollectInfo(ptr noundef %info, ptr noundef %sections_dict, i32 noundef %for_crash_report, i32 noundef %sections) local_unnamed_addr #0 {
entry:
  %info_ctx = alloca %struct.RedisModuleInfoCtx, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %0) #32
  %requested_sections = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i64 0, i32 1
  %info4 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i64 0, i32 2
  %sections5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i64 0, i32 3
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i64 0, i32 4
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i64 0, i32 5
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %if.end11, %entry
  %sections.addr.0.ph = phi i32 [ %12, %if.end11 ], [ %sections, %entry ]
  %info.addr.0.ph = phi ptr [ %11, %if.end11 ], [ %info, %entry ]
  br label %while.cond

while.cond:                                       ; preds = %while.cond.outer, %while.body
  %call1 = call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %call2 = call ptr @dictGetVal(ptr noundef nonnull %call1) #32
  %info_cb = getelementptr inbounds %struct.RedisModule, ptr %call2, i64 0, i32 14
  %1 = load ptr, ptr %info_cb, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %while.cond, label %if.end, !llvm.loop !58

if.end:                                           ; preds = %while.body
  store ptr %call2, ptr %info_ctx, align 8
  store ptr %sections_dict, ptr %requested_sections, align 8
  store ptr %info.addr.0.ph, ptr %info4, align 8
  store i32 %sections.addr.0.ph, ptr %sections5, align 8
  store i32 0, ptr %in_section, align 4
  store i32 0, ptr %in_dict_field, align 8
  call void %1(ptr noundef nonnull %info_ctx, i32 noundef %for_crash_report) #32
  %2 = load i32, ptr %in_dict_field, align 8
  %tobool8.not = icmp eq i32 %2, 0
  %.pre = load ptr, ptr %info4, align 8
  br i1 %tobool8.not, label %if.end11, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %arrayidx.i.i = getelementptr inbounds i8, ptr %.pre, i64 -1
  %3 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %3 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end.i
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end.i
  %add.ptr.i.i = getelementptr inbounds i8, ptr %.pre, i64 -3
  %4 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %4 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end.i
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %.pre, i64 -5
  %5 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %5 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end.i
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %.pre, i64 -9
  %6 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %6 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end.i
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %.pre, i64 -17
  %7 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end.i
  %retval.0.i.i = phi i64 [ %7, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end.i ]
  %8 = getelementptr i8, ptr %.pre, i64 %retval.0.i.i
  %arrayidx.i = getelementptr i8, ptr %8, i64 -1
  %9 = load i8, ptr %arrayidx.i, align 1
  %cmp.i = icmp eq i8 %9, 44
  br i1 %cmp.i, label %if.then3.i, label %RM_InfoEndDictField.exit

if.then3.i:                                       ; preds = %sdslen.exit.i
  call void @sdsIncrLen(ptr noundef nonnull %.pre, i64 noundef -1) #32
  %.pre.i = load ptr, ptr %info4, align 8
  br label %RM_InfoEndDictField.exit

RM_InfoEndDictField.exit:                         ; preds = %sdslen.exit.i, %if.then3.i
  %10 = phi ptr [ %.pre.i, %if.then3.i ], [ %.pre, %sdslen.exit.i ]
  %call7.i = call ptr @sdscat(ptr noundef %10, ptr noundef nonnull @.str.36) #32
  store ptr %call7.i, ptr %info4, align 8
  store i32 0, ptr %in_dict_field, align 8
  br label %if.end11

if.end11:                                         ; preds = %RM_InfoEndDictField.exit, %if.end
  %11 = phi ptr [ %call7.i, %RM_InfoEndDictField.exit ], [ %.pre, %if.end ]
  %12 = load i32, ptr %sections5, align 8
  br label %while.cond.outer, !llvm.loop !58

while.end:                                        ; preds = %while.cond
  call void @dictReleaseIterator(ptr noundef %call) #32
  ret ptr %info.addr.0.ph
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_GetServerInfo(ptr noundef %ctx, ptr noundef %section) #0 {
entry:
  %all = alloca i32, align 4
  %everything = alloca i32, align 4
  %argv = alloca [1 x ptr], align 8
  %totlines = alloca i32, align 4
  %call = tail call noalias dereferenceable_or_null(8) ptr @zmalloc(i64 noundef 8) #33
  %call1 = tail call ptr @raxNew() #32
  store ptr %call1, ptr %call, align 8
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %if.end, label %if.end.i

if.end.i:                                         ; preds = %if.then
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %1 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %2 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %1, %2
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %1, 1
  %cmp4.i = icmp slt i32 %1, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %3 = load ptr, ptr %amqueue.i, align 8
  %conv.i = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i, 4
  %call.i = tail call ptr @zrealloc(ptr noundef %3, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %4 = phi i32 [ %1, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %5 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %4 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %5, i64 %idxprom.i, i32 1
  store i32 5, ptr %type14.i, align 8
  %6 = load ptr, ptr %amqueue12.i, align 8
  %7 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %7 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %6, i64 %idxprom17.i
  store ptr %call, ptr %arrayidx18.i, align 8
  %8 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %8, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %if.end

if.end:                                           ; preds = %if.end11.i, %if.then, %entry
  store i32 0, ptr %all, align 4
  store i32 0, ptr %everything, align 4
  %tobool.not = icmp ne ptr %section, null
  br i1 %tobool.not, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %call2 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %section) #36
  %call3 = tail call ptr @createStringObject(ptr noundef nonnull %section, i64 noundef %call2) #32
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi ptr [ %call3, %cond.true ], [ null, %if.end ]
  store ptr %cond, ptr %argv, align 8
  %cond5 = zext i1 %tobool.not to i32
  %call6 = call ptr @genInfoSectionDict(ptr noundef nonnull %argv, i32 noundef %cond5, ptr noundef null, ptr noundef nonnull %all, ptr noundef nonnull %everything) #32
  %9 = load i32, ptr %all, align 4
  %10 = load i32, ptr %everything, align 4
  %call7 = call ptr @genRedisInfoString(ptr noundef %call6, i32 noundef %9, i32 noundef %10) #32
  %arrayidx.i = getelementptr inbounds i8, ptr %call7, i64 -1
  %11 = load i8, ptr %arrayidx.i, align 1
  %conv.i23 = zext i8 %11 to i32
  %and.i24 = and i32 %conv.i23, 7
  switch i32 %and.i24, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %cond.end
  %shr.i = lshr i32 %conv.i23, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %cond.end
  %add.ptr.i = getelementptr inbounds i8, ptr %call7, i64 -3
  %12 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %12 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %cond.end
  %add.ptr6.i = getelementptr inbounds i8, ptr %call7, i64 -5
  %13 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %13 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %cond.end
  %add.ptr10.i = getelementptr inbounds i8, ptr %call7, i64 -9
  %14 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %14 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %cond.end
  %add.ptr14.i = getelementptr inbounds i8, ptr %call7, i64 -17
  %15 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %cond.end, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %15, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %cond.end ]
  %call9 = call ptr @sdssplitlen(ptr noundef nonnull %call7, i64 noundef %retval.0.i, ptr noundef nonnull @.str.36, i32 noundef 2, ptr noundef nonnull %totlines) #32
  %16 = load i32, ptr %totlines, align 4
  %cmp1044 = icmp sgt i32 %16, 0
  br i1 %cmp1044, label %for.body, label %for.end

for.body:                                         ; preds = %sdslen.exit, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %sdslen.exit ]
  %arrayidx11 = getelementptr inbounds ptr, ptr %call9, i64 %indvars.iv
  %17 = load ptr, ptr %arrayidx11, align 8
  %18 = load i8, ptr %17, align 1
  %cmp13 = icmp eq i8 %18, 35
  br i1 %cmp13, label %for.inc, label %if.end16

if.end16:                                         ; preds = %for.body
  %call17 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %17, i32 noundef 58) #36
  %tobool18.not = icmp eq ptr %call17, null
  br i1 %tobool18.not, label %for.inc, label %if.end20

if.end20:                                         ; preds = %if.end16
  %19 = ptrtoint ptr %call17 to i64
  %20 = ptrtoint ptr %17 to i64
  %sub = sub nsw i64 %19, %20
  %add.ptr = getelementptr inbounds i8, ptr %call17, i64 1
  %arrayidx.i25 = getelementptr inbounds i8, ptr %17, i64 -1
  %21 = load i8, ptr %arrayidx.i25, align 1
  %conv.i26 = zext i8 %21 to i32
  %and.i27 = and i32 %conv.i26, 7
  switch i32 %and.i27, label %sdslen.exit43 [
    i32 0, label %sw.bb.i40
    i32 1, label %sw.bb3.i37
    i32 2, label %sw.bb5.i34
    i32 3, label %sw.bb9.i31
    i32 4, label %sw.bb13.i28
  ]

sw.bb.i40:                                        ; preds = %if.end20
  %shr.i41 = lshr i32 %conv.i26, 3
  %conv2.i42 = zext nneg i32 %shr.i41 to i64
  br label %sdslen.exit43

sw.bb3.i37:                                       ; preds = %if.end20
  %add.ptr.i38 = getelementptr inbounds i8, ptr %17, i64 -3
  %22 = load i8, ptr %add.ptr.i38, align 1
  %conv4.i39 = zext i8 %22 to i64
  br label %sdslen.exit43

sw.bb5.i34:                                       ; preds = %if.end20
  %add.ptr6.i35 = getelementptr inbounds i8, ptr %17, i64 -5
  %23 = load i16, ptr %add.ptr6.i35, align 1
  %conv8.i36 = zext i16 %23 to i64
  br label %sdslen.exit43

sw.bb9.i31:                                       ; preds = %if.end20
  %add.ptr10.i32 = getelementptr inbounds i8, ptr %17, i64 -9
  %24 = load i32, ptr %add.ptr10.i32, align 1
  %conv12.i33 = zext i32 %24 to i64
  br label %sdslen.exit43

sw.bb13.i28:                                      ; preds = %if.end20
  %add.ptr14.i29 = getelementptr inbounds i8, ptr %17, i64 -17
  %25 = load i64, ptr %add.ptr14.i29, align 1
  br label %sdslen.exit43

sdslen.exit43:                                    ; preds = %if.end20, %sw.bb.i40, %sw.bb3.i37, %sw.bb5.i34, %sw.bb9.i31, %sw.bb13.i28
  %retval.0.i30 = phi i64 [ %25, %sw.bb13.i28 ], [ %conv12.i33, %sw.bb9.i31 ], [ %conv8.i36, %sw.bb5.i34 ], [ %conv4.i39, %sw.bb3.i37 ], [ %conv2.i42, %sw.bb.i40 ], [ 0, %if.end20 ]
  %26 = xor i64 %sub, -1
  %sub24 = add i64 %retval.0.i30, %26
  %call25 = call ptr @sdsnewlen(ptr noundef nonnull %add.ptr, i64 noundef %sub24) #32
  %27 = load ptr, ptr %call, align 8
  %call27 = call i32 @raxTryInsert(ptr noundef %27, ptr noundef nonnull %17, i64 noundef %sub, ptr noundef %call25, ptr noundef null) #32
  %tobool28.not = icmp eq i32 %call27, 0
  br i1 %tobool28.not, label %if.then29, label %for.inc

if.then29:                                        ; preds = %sdslen.exit43
  call void @sdsfree(ptr noundef %call25) #32
  br label %for.inc

for.inc:                                          ; preds = %sdslen.exit43, %if.then29, %if.end16, %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %28 = load i32, ptr %totlines, align 4
  %29 = sext i32 %28 to i64
  %cmp10 = icmp slt i64 %indvars.iv.next, %29
  br i1 %cmp10, label %for.body, label %for.end, !llvm.loop !59

for.end:                                          ; preds = %for.inc, %sdslen.exit
  call void @sdsfree(ptr noundef %call7) #32
  %30 = load i32, ptr %totlines, align 4
  call void @sdsfreesplitres(ptr noundef %call9, i32 noundef %30) #32
  call void @releaseInfoSectionDict(ptr noundef %call6) #32
  %31 = load ptr, ptr %argv, align 8
  %tobool32.not = icmp eq ptr %31, null
  br i1 %tobool32.not, label %if.end35, label %if.then33

if.then33:                                        ; preds = %for.end
  call void @decrRefCount(ptr noundef nonnull %31) #32
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %for.end
  ret ptr %call
}

declare ptr @genInfoSectionDict(ptr noundef, i32 noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @genRedisInfoString(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #1

declare void @releaseInfoSectionDict(ptr noundef) local_unnamed_addr #1

declare void @raxFreeWithCallback(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ServerInfoGetField(ptr noundef %ctx, ptr nocapture noundef readonly %data, ptr noundef %field) #0 {
entry:
  %result = alloca ptr, align 8
  %0 = load ptr, ptr %data, align 8
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %field) #36
  %call1 = call i32 @raxFind(ptr noundef %0, ptr noundef %field, i64 noundef %call, ptr noundef nonnull %result) #32
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %result, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end ]
  %call3 = call ptr @createStringObject(ptr noundef nonnull %1, i64 noundef %retval.0.i) #32
  %cmp.not = icmp eq ptr %ctx, null
  br i1 %cmp.not, label %return, label %if.then4

if.then4:                                         ; preds = %sdslen.exit
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %7 = load i32, ptr %flags.i, align 8
  %and.i5 = and i32 %7, 1
  %tobool.not.i = icmp eq i32 %and.i5, 0
  br i1 %tobool.not.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %if.then4
  %amqueue_used.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 6
  %8 = load i32, ptr %amqueue_used.i, align 4
  %amqueue_len.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 5
  %9 = load i32, ptr %amqueue_len.i, align 8
  %cmp.i = icmp eq i32 %8, %9
  br i1 %cmp.i, label %if.then1.i, label %if.end.if.end11_crit_edge.i

if.end.if.end11_crit_edge.i:                      ; preds = %if.end.i
  %amqueue12.phi.trans.insert.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %.pre.i = load ptr, ptr %amqueue12.phi.trans.insert.i, align 8
  br label %if.end11.i

if.then1.i:                                       ; preds = %if.end.i
  %mul.i = shl nsw i32 %8, 1
  %cmp4.i = icmp slt i32 %8, 8
  %spec.select.i = select i1 %cmp4.i, i32 16, i32 %mul.i
  store i32 %spec.select.i, ptr %amqueue_len.i, align 8
  %amqueue.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %10 = load ptr, ptr %amqueue.i, align 8
  %conv.i6 = sext i32 %spec.select.i to i64
  %mul9.i = shl nsw i64 %conv.i6, 4
  %call.i = call ptr @zrealloc(ptr noundef %10, i64 noundef %mul9.i) #34
  store ptr %call.i, ptr %amqueue.i, align 8
  %.pre14.i = load i32, ptr %amqueue_used.i, align 4
  br label %if.end11.i

if.end11.i:                                       ; preds = %if.then1.i, %if.end.if.end11_crit_edge.i
  %11 = phi i32 [ %8, %if.end.if.end11_crit_edge.i ], [ %.pre14.i, %if.then1.i ]
  %12 = phi ptr [ %.pre.i, %if.end.if.end11_crit_edge.i ], [ %call.i, %if.then1.i ]
  %amqueue12.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 4
  %idxprom.i = sext i32 %11 to i64
  %type14.i = getelementptr inbounds %struct.AutoMemEntry, ptr %12, i64 %idxprom.i, i32 1
  store i32 1, ptr %type14.i, align 8
  %13 = load ptr, ptr %amqueue12.i, align 8
  %14 = load i32, ptr %amqueue_used.i, align 4
  %idxprom17.i = sext i32 %14 to i64
  %arrayidx18.i = getelementptr inbounds %struct.AutoMemEntry, ptr %13, i64 %idxprom17.i
  store ptr %call3, ptr %arrayidx18.i, align 8
  %15 = load i32, ptr %amqueue_used.i, align 4
  %inc.i = add nsw i32 %15, 1
  store i32 %inc.i, ptr %amqueue_used.i, align 4
  br label %return

return:                                           ; preds = %if.end11.i, %if.then4, %sdslen.exit, %entry
  %retval.0 = phi ptr [ null, %entry ], [ %call3, %sdslen.exit ], [ %call3, %if.then4 ], [ %call3, %if.end11.i ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ServerInfoGetFieldC(ptr nocapture noundef readonly %data, ptr noundef %field) #0 {
entry:
  %result = alloca ptr, align 8
  store ptr null, ptr %result, align 8
  %0 = load ptr, ptr %data, align 8
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %field) #36
  %call1 = call i32 @raxFind(ptr noundef %0, ptr noundef %field, i64 noundef %call, ptr noundef nonnull %result) #32
  %1 = load ptr, ptr %result, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_ServerInfoGetFieldSigned(ptr nocapture noundef readonly %data, ptr noundef %field, ptr noundef writeonly %out_err) #0 {
entry:
  %ll = alloca i64, align 8
  %result = alloca ptr, align 8
  %0 = load ptr, ptr %data, align 8
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %field) #36
  %call1 = call i32 @raxFind(ptr noundef %0, ptr noundef %field, i64 noundef %call, ptr noundef nonnull %result) #32
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %tobool2.not = icmp eq ptr %out_err, null
  br i1 %tobool2.not, label %return, label %if.then3

if.then3:                                         ; preds = %if.then
  store i32 1, ptr %out_err, align 4
  br label %return

if.end4:                                          ; preds = %entry
  %1 = load ptr, ptr %result, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end4
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end4
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end4
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end4
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end4
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end4, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end4 ]
  %call6 = call i32 @string2ll(ptr noundef nonnull %1, i64 noundef %retval.0.i, ptr noundef nonnull %ll) #32
  %tobool7.not = icmp eq i32 %call6, 0
  %tobool9.not = icmp eq ptr %out_err, null
  br i1 %tobool7.not, label %if.then8, label %if.end12

if.then8:                                         ; preds = %sdslen.exit
  br i1 %tobool9.not, label %return, label %if.then10

if.then10:                                        ; preds = %if.then8
  store i32 1, ptr %out_err, align 4
  br label %return

if.end12:                                         ; preds = %sdslen.exit
  br i1 %tobool9.not, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end12
  store i32 0, ptr %out_err, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end12
  %7 = load i64, ptr %ll, align 8
  br label %return

return:                                           ; preds = %if.then8, %if.then10, %if.then, %if.then3, %if.end15
  %retval.0 = phi i64 [ %7, %if.end15 ], [ 0, %if.then3 ], [ 0, %if.then ], [ 0, %if.then10 ], [ 0, %if.then8 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_ServerInfoGetFieldUnsigned(ptr nocapture noundef readonly %data, ptr noundef %field, ptr noundef writeonly %out_err) #0 {
entry:
  %ll = alloca i64, align 8
  %result = alloca ptr, align 8
  %0 = load ptr, ptr %data, align 8
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %field) #36
  %call1 = call i32 @raxFind(ptr noundef %0, ptr noundef %field, i64 noundef %call, ptr noundef nonnull %result) #32
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %tobool2.not = icmp eq ptr %out_err, null
  br i1 %tobool2.not, label %return, label %if.then3

if.then3:                                         ; preds = %if.then
  store i32 1, ptr %out_err, align 4
  br label %return

if.end4:                                          ; preds = %entry
  %1 = load ptr, ptr %result, align 8
  %call5 = call i32 @string2ull(ptr noundef %1, ptr noundef nonnull %ll) #32
  %tobool6.not = icmp eq i32 %call5, 0
  %tobool8.not = icmp eq ptr %out_err, null
  br i1 %tobool6.not, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end4
  br i1 %tobool8.not, label %return, label %if.then9

if.then9:                                         ; preds = %if.then7
  store i32 1, ptr %out_err, align 4
  br label %return

if.end11:                                         ; preds = %if.end4
  br i1 %tobool8.not, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end11
  store i32 0, ptr %out_err, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end11
  %2 = load i64, ptr %ll, align 8
  br label %return

return:                                           ; preds = %if.then7, %if.then9, %if.then, %if.then3, %if.end14
  %retval.0 = phi i64 [ %2, %if.end14 ], [ 0, %if.then3 ], [ 0, %if.then ], [ 0, %if.then9 ], [ 0, %if.then7 ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local double @RM_ServerInfoGetFieldDouble(ptr nocapture noundef readonly %data, ptr noundef %field, ptr noundef writeonly %out_err) #0 {
entry:
  %dbl = alloca double, align 8
  %result = alloca ptr, align 8
  %0 = load ptr, ptr %data, align 8
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %field) #36
  %call1 = call i32 @raxFind(ptr noundef %0, ptr noundef %field, i64 noundef %call, ptr noundef nonnull %result) #32
  %tobool.not = icmp eq i32 %call1, 0
  br i1 %tobool.not, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %tobool2.not = icmp eq ptr %out_err, null
  br i1 %tobool2.not, label %return, label %if.then3

if.then3:                                         ; preds = %if.then
  store i32 1, ptr %out_err, align 4
  br label %return

if.end4:                                          ; preds = %entry
  %1 = load ptr, ptr %result, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end4
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end4
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end4
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end4
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end4
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end4, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end4 ]
  %call6 = call i32 @string2d(ptr noundef nonnull %1, i64 noundef %retval.0.i, ptr noundef nonnull %dbl) #32
  %tobool7.not = icmp eq i32 %call6, 0
  %tobool9.not = icmp eq ptr %out_err, null
  br i1 %tobool7.not, label %if.then8, label %if.end12

if.then8:                                         ; preds = %sdslen.exit
  br i1 %tobool9.not, label %return, label %if.then10

if.then10:                                        ; preds = %if.then8
  store i32 1, ptr %out_err, align 4
  br label %return

if.end12:                                         ; preds = %sdslen.exit
  br i1 %tobool9.not, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end12
  store i32 0, ptr %out_err, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end12
  %7 = load double, ptr %dbl, align 8
  br label %return

return:                                           ; preds = %if.then8, %if.then10, %if.then, %if.then3, %if.end15
  %retval.0 = phi double [ %7, %if.end15 ], [ 0.000000e+00, %if.then3 ], [ 0.000000e+00, %if.then ], [ 0.000000e+00, %if.then10 ], [ 0.000000e+00, %if.then8 ]
  ret double %retval.0
}

declare i32 @string2d(ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_GetRandomBytes(ptr noundef %dst, i64 noundef %len) #0 {
entry:
  tail call void @getRandomBytes(ptr noundef %dst, i64 noundef %len) #32
  ret void
}

declare void @getRandomBytes(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_GetRandomHexChars(ptr noundef %dst, i64 noundef %len) #0 {
entry:
  tail call void @getRandomHexChars(ptr noundef %dst, i64 noundef %len) #32
  ret void
}

declare void @getRandomHexChars(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ExportSharedAPI(ptr nocapture noundef readonly %ctx, ptr noundef %apiname, ptr noundef %func) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #33
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %call, i64 0, i32 1
  store ptr %0, ptr %module1, align 8
  store ptr %func, ptr %call, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 38), align 8
  %call3 = tail call i32 @dictAdd(ptr noundef %1, ptr noundef %apiname, ptr noundef nonnull %call) #32
  %cmp.not = icmp eq i32 %call3, 0
  br i1 %cmp.not, label %return, label %if.then

if.then:                                          ; preds = %entry
  tail call void @zfree(ptr noundef nonnull %call) #32
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ 1, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetSharedAPI(ptr nocapture noundef readonly %ctx, ptr noundef %apiname) #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 38), align 8
  %call = tail call ptr @dictFind(ptr noundef %0, ptr noundef %apiname) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call1 = tail call ptr @dictGetVal(ptr noundef nonnull %call) #32
  %module = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %call1, i64 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %1, i64 0, i32 5
  %2 = load ptr, ptr %usedby, align 8
  %module2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %3 = load ptr, ptr %module2, align 8
  %call3 = tail call ptr @listSearchKey(ptr noundef %2, ptr noundef %3) #32
  %cmp4 = icmp eq ptr %call3, null
  br i1 %cmp4, label %if.then5, label %if.end13

if.then5:                                         ; preds = %if.end
  %4 = load ptr, ptr %module, align 8
  %usedby7 = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 5
  %5 = load ptr, ptr %usedby7, align 8
  %6 = load ptr, ptr %module2, align 8
  %call9 = tail call ptr @listAddNodeTail(ptr noundef %5, ptr noundef %6) #32
  %7 = load ptr, ptr %module2, align 8
  %using = getelementptr inbounds %struct.RedisModule, ptr %7, i64 0, i32 6
  %8 = load ptr, ptr %using, align 8
  %9 = load ptr, ptr %module, align 8
  %call12 = tail call ptr @listAddNodeTail(ptr noundef %8, ptr noundef %9) #32
  br label %if.end13

if.end13:                                         ; preds = %if.then5, %if.end
  %10 = load ptr, ptr %call1, align 8
  br label %return

return:                                           ; preds = %entry, %if.end13
  %retval.0 = phi ptr [ %10, %if.end13 ], [ null, %entry ]
  ret ptr %retval.0
}

declare ptr @listSearchKey(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleUnregisterSharedAPI(ptr noundef readnone %module) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 38), align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %0) #32
  %call15 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not6 = icmp eq ptr %call15, null
  br i1 %cmp.not6, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call18 = phi ptr [ %call1, %if.end ], [ %call15, %entry ]
  %count.07 = phi i32 [ %count.1, %if.end ], [ 0, %entry ]
  %call2 = tail call ptr @dictGetKey(ptr noundef nonnull %call18) #32
  %call3 = tail call ptr @dictGetVal(ptr noundef nonnull %call18) #32
  %module4 = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %call3, i64 0, i32 1
  %1 = load ptr, ptr %module4, align 8
  %cmp5 = icmp eq ptr %1, %module
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 38), align 8
  %call6 = tail call i32 @dictDelete(ptr noundef %2, ptr noundef %call2) #32
  tail call void @zfree(ptr noundef nonnull %call3) #32
  %inc = add nsw i32 %count.07, 1
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %count.1 = phi i32 [ %inc, %if.then ], [ %count.07, %while.body ]
  %call1 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !60

while.end:                                        ; preds = %if.end, %entry
  %count.0.lcssa = phi i32 [ 0, %entry ], [ %count.1, %if.end ]
  tail call void @dictReleaseIterator(ptr noundef %call) #32
  ret i32 %count.0.lcssa
}

declare ptr @dictGetSafeIterator(ptr noundef) local_unnamed_addr #1

declare ptr @dictGetKey(ptr noundef) local_unnamed_addr #1

declare i32 @dictDelete(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleUnregisterUsedAPI(ptr noundef %module) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %using = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 6
  %0 = load ptr, ptr %using, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #32
  %call5 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not6 = icmp eq ptr %call5, null
  br i1 %tobool.not6, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call8 = phi ptr [ %call, %if.end ], [ %call5, %entry ]
  %count.07 = phi i32 [ %count.1, %if.end ], [ 0, %entry ]
  %value = getelementptr inbounds %struct.listNode, ptr %call8, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %1, i64 0, i32 5
  %2 = load ptr, ptr %usedby, align 8
  %call2 = call ptr @listSearchKey(ptr noundef %2, ptr noundef %module) #32
  %tobool3.not = icmp eq ptr %call2, null
  br i1 %tobool3.not, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %3 = load ptr, ptr %usedby, align 8
  call void @listDelNode(ptr noundef %3, ptr noundef nonnull %call2) #32
  %inc = add nsw i32 %count.07, 1
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %count.1 = phi i32 [ %inc, %if.then ], [ %count.07, %while.body ]
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !61

while.end:                                        ; preds = %if.end, %entry
  %count.0.lcssa = phi i32 [ 0, %entry ], [ %count.1, %if.end ]
  ret i32 %count.0.lcssa
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleUnregisterFilters(ptr nocapture noundef readonly %module) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 7
  %0 = load ptr, ptr %filters, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #32
  %call4 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not5 = icmp eq ptr %call4, null
  br i1 %tobool.not5, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call7 = phi ptr [ %call, %if.end ], [ %call4, %entry ]
  %count.06 = phi i32 [ %count.1, %if.end ], [ 0, %entry ]
  %value = getelementptr inbounds %struct.listNode, ptr %call7, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %2 = load ptr, ptr @moduleCommandFilters, align 8
  %call2 = call ptr @listSearchKey(ptr noundef %2, ptr noundef %1) #32
  %tobool3.not = icmp eq ptr %call2, null
  br i1 %tobool3.not, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %3 = load ptr, ptr @moduleCommandFilters, align 8
  call void @listDelNode(ptr noundef %3, ptr noundef nonnull %call2) #32
  %inc = add nsw i32 %count.06, 1
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %count.1 = phi i32 [ %inc, %if.then ], [ %count.06, %while.body ]
  call void @zfree(ptr noundef %1) #32
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !62

while.end:                                        ; preds = %if.end, %entry
  %count.0.lcssa = phi i32 [ 0, %entry ], [ %count.1, %if.end ]
  ret i32 %count.0.lcssa
}

; Function Attrs: nounwind uwtable
define dso_local noundef ptr @RM_RegisterCommandFilter(ptr nocapture noundef readonly %ctx, ptr noundef %callback, i32 noundef %flags) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(24) ptr @zmalloc(i64 noundef 24) #33
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  store ptr %0, ptr %call, align 8
  %callback2 = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %call, i64 0, i32 1
  store ptr %callback, ptr %callback2, align 8
  %flags3 = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %call, i64 0, i32 2
  store i32 %flags, ptr %flags3, align 8
  %1 = load ptr, ptr @moduleCommandFilters, align 8
  %call4 = tail call ptr @listAddNodeTail(ptr noundef %1, ptr noundef nonnull %call) #32
  %2 = load ptr, ptr %module, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %2, i64 0, i32 7
  %3 = load ptr, ptr %filters, align 8
  %call6 = tail call ptr @listAddNodeTail(ptr noundef %3, ptr noundef nonnull %call) #32
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_UnregisterCommandFilter(ptr nocapture noundef readonly %ctx, ptr noundef %filter) #0 {
entry:
  %0 = load ptr, ptr %filter, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %1 = load ptr, ptr %module1, align 8
  %cmp.not = icmp eq ptr %0, %1
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr @moduleCommandFilters, align 8
  %call = tail call ptr @listSearchKey(ptr noundef %2, ptr noundef nonnull %filter) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr @moduleCommandFilters, align 8
  tail call void @listDelNode(ptr noundef %3, ptr noundef nonnull %call) #32
  %4 = load ptr, ptr %module1, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %4, i64 0, i32 7
  %5 = load ptr, ptr %filters, align 8
  %call5 = tail call ptr @listSearchKey(ptr noundef %5, ptr noundef nonnull %filter) #32
  %tobool6.not = icmp eq ptr %call5, null
  br i1 %tobool6.not, label %return, label %if.end8

if.end8:                                          ; preds = %if.end3
  %6 = load ptr, ptr %module1, align 8
  %filters10 = getelementptr inbounds %struct.RedisModule, ptr %6, i64 0, i32 7
  %7 = load ptr, ptr %filters10, align 8
  tail call void @listDelNode(ptr noundef %7, ptr noundef nonnull %call5) #32
  tail call void @zfree(ptr noundef nonnull %filter) #32
  br label %return

return:                                           ; preds = %if.end3, %if.end, %entry, %if.end8
  %retval.0 = phi i32 [ 0, %if.end8 ], [ 1, %entry ], [ 1, %if.end ], [ 1, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_CommandFilterArgsCount(ptr nocapture noundef readonly %fctx) #6 {
entry:
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %fctx, i64 0, i32 2
  %0 = load i32, ptr %argc, align 4
  ret i32 %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @RM_CommandFilterArgGet(ptr nocapture noundef readonly %fctx, i32 noundef %pos) #11 {
entry:
  %cmp = icmp slt i32 %pos, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %fctx, i64 0, i32 2
  %0 = load i32, ptr %argc, align 4
  %cmp1.not = icmp sgt i32 %0, %pos
  br i1 %cmp1.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %1 = load ptr, ptr %fctx, align 8
  %idxprom = zext nneg i32 %pos to i64
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi ptr [ %2, %if.end ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_CommandFilterArgInsert(ptr nocapture noundef %fctx, i32 noundef %pos, ptr noundef %arg) #0 {
entry:
  %cmp = icmp slt i32 %pos, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %fctx, i64 0, i32 2
  %0 = load i32, ptr %argc, align 4
  %cmp1 = icmp slt i32 %0, %pos
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %argv_len = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %fctx, i64 0, i32 1
  %1 = load i32, ptr %argv_len, align 8
  %cmp3.not = icmp sgt i32 %1, %0
  br i1 %cmp3.not, label %if.end10, label %if.then4

if.then4:                                         ; preds = %if.end
  %add = add nuw nsw i32 %0, 1
  store i32 %add, ptr %argv_len, align 8
  %2 = load ptr, ptr %fctx, align 8
  %conv = zext nneg i32 %add to i64
  %mul = shl nuw nsw i64 %conv, 3
  %call = tail call ptr @zrealloc(ptr noundef %2, i64 noundef %mul) #34
  store ptr %call, ptr %fctx, align 8
  %.pre = load i32, ptr %argc, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then4, %if.end
  %3 = phi i32 [ %.pre, %if.then4 ], [ %0, %if.end ]
  %cmp1219 = icmp sgt i32 %3, %pos
  br i1 %cmp1219, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %if.end10
  %4 = zext nneg i32 %3 to i64
  %5 = zext nneg i32 %pos to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ %4, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %6 = load ptr, ptr %fctx, align 8
  %7 = getelementptr ptr, ptr %6, i64 %indvars.iv
  %arrayidx = getelementptr ptr, ptr %7, i64 -1
  %8 = load ptr, ptr %arrayidx, align 8
  store ptr %8, ptr %7, align 8
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %cmp12 = icmp sgt i64 %indvars.iv.next, %5
  br i1 %cmp12, label %for.body, label %for.end, !llvm.loop !63

for.end:                                          ; preds = %for.body, %if.end10
  %9 = load ptr, ptr %fctx, align 8
  %idxprom19 = zext nneg i32 %pos to i64
  %arrayidx20 = getelementptr inbounds ptr, ptr %9, i64 %idxprom19
  store ptr %arg, ptr %arrayidx20, align 8
  %10 = load i32, ptr %argc, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %argc, align 4
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_CommandFilterArgReplace(ptr nocapture noundef readonly %fctx, i32 noundef %pos, ptr noundef %arg) #0 {
entry:
  %cmp = icmp slt i32 %pos, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %fctx, i64 0, i32 2
  %0 = load i32, ptr %argc, align 4
  %cmp1.not = icmp sgt i32 %0, %pos
  br i1 %cmp1.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %1 = load ptr, ptr %fctx, align 8
  %idxprom = zext nneg i32 %pos to i64
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  tail call void @decrRefCount(ptr noundef %2) #32
  %3 = load ptr, ptr %fctx, align 8
  %arrayidx4 = getelementptr inbounds ptr, ptr %3, i64 %idxprom
  store ptr %arg, ptr %arrayidx4, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_CommandFilterArgDelete(ptr nocapture noundef %fctx, i32 noundef %pos) #0 {
entry:
  %cmp = icmp slt i32 %pos, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %fctx, i64 0, i32 2
  %0 = load i32, ptr %argc, align 4
  %cmp1.not = icmp sgt i32 %0, %pos
  br i1 %cmp1.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %1 = load ptr, ptr %fctx, align 8
  %idxprom = zext nneg i32 %pos to i64
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  tail call void @decrRefCount(ptr noundef %2) #32
  %3 = load i32, ptr %argc, align 4
  %sub12 = add nsw i32 %3, -1
  %cmp313 = icmp sgt i32 %sub12, %pos
  br i1 %cmp313, label %for.body, label %for.end

for.body:                                         ; preds = %if.end, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ %idxprom, %if.end ]
  %4 = load ptr, ptr %fctx, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %arrayidx6 = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv.next
  %5 = load ptr, ptr %arrayidx6, align 8
  %arrayidx9 = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv
  store ptr %5, ptr %arrayidx9, align 8
  %6 = load i32, ptr %argc, align 4
  %sub = add nsw i32 %6, -1
  %7 = trunc i64 %indvars.iv.next to i32
  %cmp3 = icmp sgt i32 %sub, %7
  br i1 %cmp3, label %for.body, label %for.end, !llvm.loop !64

for.end:                                          ; preds = %for.body, %if.end
  %sub.lcssa = phi i32 [ %sub12, %if.end ], [ %sub, %for.body ]
  store i32 %sub.lcssa, ptr %argc, align 4
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ 1, %lor.lhs.false ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i64 @RM_CommandFilterGetClientId(ptr nocapture noundef readonly %fctx) #11 {
entry:
  %c = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %fctx, i64 0, i32 3
  %0 = load ptr, ptr %c, align 8
  %1 = load i64, ptr %0, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MallocSize(ptr noundef %ptr) #0 {
entry:
  %call = tail call i64 @je_malloc_usable_size(ptr noundef %ptr) #32
  ret i64 %call
}

; Function Attrs: nounwind
declare i64 @je_malloc_usable_size(ptr noundef) local_unnamed_addr #25

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MallocUsableSize(ptr noundef %ptr) #0 {
entry:
  %call = tail call i64 @je_malloc_usable_size(ptr noundef %ptr) #32
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MallocSizeString(ptr noundef %str) #0 {
entry:
  %bf.load = load i32, ptr %str, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp eq i32 %bf.clear, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.94, ptr noundef nonnull @.str.2, i32 noundef 10835) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %call = tail call i64 @getStringObjectSdsUsedMemory(ptr noundef nonnull %str) #32
  %add = add i64 %call, 16
  ret i64 %add
}

declare i64 @getStringObjectSdsUsedMemory(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i64 @RM_MallocSizeDict(ptr nocapture noundef readonly %dict) #11 {
entry:
  %0 = load ptr, ptr %dict, align 8
  %numnodes = getelementptr inbounds %struct.rax, ptr %0, i64 0, i32 2
  %1 = load i64, ptr %numnodes, align 8
  %reass.mul = mul i64 %1, 244
  %add5 = add i64 %reass.mul, 32
  ret i64 %add5
}

; Function Attrs: nounwind uwtable
define dso_local float @RM_GetUsedMemoryRatio() #0 {
entry:
  %level = alloca float, align 4
  %call = call i32 @getMaxmemoryState(ptr noundef null, ptr noundef null, ptr noundef null, ptr noundef nonnull %level) #32
  %0 = load float, ptr %level, align 4
  ret float %0
}

; Function Attrs: nounwind uwtable
define dso_local noalias noundef ptr @RM_ScanCursorCreate() #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #33
  store i64 0, ptr %call, align 8
  %done = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %call, i64 0, i32 1
  store i32 0, ptr %done, align 8
  ret ptr %call
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable
define dso_local void @RM_ScanCursorRestart(ptr nocapture noundef writeonly %cursor) #23 {
entry:
  store i64 0, ptr %cursor, align 8
  %done = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %cursor, i64 0, i32 1
  store i32 0, ptr %done, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ScanCursorDestroy(ptr noundef %cursor) #0 {
entry:
  tail call void @zfree(ptr noundef %cursor) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_Scan(ptr noundef %ctx, ptr nocapture noundef %cursor, ptr noundef %fn, ptr noundef %privdata) #0 {
entry:
  %data = alloca %struct.ScanCBData, align 8
  %done = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %cursor, i64 0, i32 1
  %0 = load i32, ptr %done, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  store ptr %ctx, ptr %data, align 8
  %user_data = getelementptr inbounds %struct.ScanCBData, ptr %data, i64 0, i32 1
  store ptr %privdata, ptr %user_data, align 8
  %fn2 = getelementptr inbounds %struct.ScanCBData, ptr %data, i64 0, i32 2
  store ptr %fn, ptr %fn2, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %db, align 8
  %3 = load i64, ptr %cursor, align 8
  %call4 = call i64 @dbScan(ptr noundef %2, i32 noundef 0, i64 noundef %3, i32 noundef -1, ptr noundef nonnull @moduleScanCallback, ptr noundef null, ptr noundef nonnull %data) #32
  store i64 %call4, ptr %cursor, align 8
  %cmp = icmp eq i64 %call4, 0
  br i1 %cmp, label %if.then7, label %return

if.then7:                                         ; preds = %if.end
  store i32 1, ptr %done, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then7, %entry
  %.sink = phi i32 [ 2, %entry ], [ 0, %if.then7 ], [ 0, %if.end ]
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %if.then7 ], [ 1, %if.end ]
  %call10 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call10, align 4
  ret i32 %retval.0
}

declare i64 @dbScan(ptr noundef, i32 noundef, i64 noundef, i32 noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal void @moduleScanCallback(ptr nocapture noundef readonly %privdata, ptr noundef %de) #0 {
entry:
  %kp = alloca %struct.RedisModuleKey, align 8
  %call = tail call ptr @dictGetKey(ptr noundef %de) #32
  %call1 = tail call ptr @dictGetVal(ptr noundef %de) #32
  %call2 = tail call ptr @sdsdup(ptr noundef %call) #32
  %call3 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call2) #32
  %0 = getelementptr inbounds i8, ptr %kp, i64 40
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(128) %0, i8 0, i64 88, i1 false)
  %1 = load ptr, ptr %privdata, align 8
  store ptr %1, ptr %kp, align 8
  %client.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %client.i, align 8
  %db.i = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 4
  %3 = load ptr, ptr %db.i, align 8
  %db2.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 1
  store ptr %3, ptr %db2.i, align 8
  %key.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 2
  store ptr %call3, ptr %key.i, align 8
  tail call void @incrRefCount(ptr noundef %call3) #32
  %value3.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 3
  store ptr %call1, ptr %value3.i, align 8
  %iter.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 4
  store ptr null, ptr %iter.i, align 8
  %mode4.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 5
  store i32 1, ptr %mode4.i, align 8
  %tobool.not.i = icmp eq ptr %call1, null
  br i1 %tobool.not.i, label %moduleInitKey.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %bf.load.i.i = load i32, ptr %call1, align 8
  %bf.clear.i.i = and i32 %bf.load.i.i, 15
  switch i32 %bf.clear.i.i, label %moduleInitKey.exit [
    i32 3, label %sw.bb.i.i
    i32 6, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i
  %u.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 6
  store i32 0, ptr %u.i.i.i, align 8
  %current.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  store ptr null, ptr %current.i.i.i, align 8
  %er.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 6, i32 0, i32 1
  store i32 1, ptr %er.i.i.i, align 8
  br label %moduleInitKey.exit

sw.bb1.i.i:                                       ; preds = %if.then.i
  %signalready.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %kp, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  store i32 0, ptr %signalready.i.i, align 8
  br label %moduleInitKey.exit

moduleInitKey.exit:                               ; preds = %entry, %if.then.i, %sw.bb.i.i, %sw.bb1.i.i
  %fn = getelementptr inbounds %struct.ScanCBData, ptr %privdata, i64 0, i32 2
  %4 = load ptr, ptr %fn, align 8
  %5 = load ptr, ptr %privdata, align 8
  %user_data = getelementptr inbounds %struct.ScanCBData, ptr %privdata, i64 0, i32 1
  %6 = load ptr, ptr %user_data, align 8
  call void %4(ptr noundef %5, ptr noundef %call3, ptr noundef nonnull %kp, ptr noundef %6) #32
  call fastcc void @moduleCloseKey(ptr noundef nonnull %kp)
  call void @decrRefCount(ptr noundef %call3) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ScanKey(ptr noundef %key, ptr nocapture noundef %cursor, ptr noundef %fn, ptr noundef %privdata) #0 {
entry:
  %data = alloca %struct.ScanKeyCBData, align 8
  %vlen = alloca i32, align 4
  %vll = alloca i64, align 8
  %cmp = icmp eq ptr %key, null
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %0, null
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %return [
    i32 2, label %if.then4
    i32 4, label %if.then13
    i32 3, label %if.then25
  ]

if.then4:                                         ; preds = %if.end
  %1 = and i32 %bf.load, 240
  %cmp7 = icmp eq i32 %1, 32
  br i1 %cmp7, label %if.then8, label %if.end37

if.then8:                                         ; preds = %if.then4
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  br label %if.end37.sink.split

if.then13:                                        ; preds = %if.end
  %2 = and i32 %bf.load, 240
  %cmp17 = icmp eq i32 %2, 32
  br i1 %cmp17, label %if.then18, label %if.end37

if.then18:                                        ; preds = %if.then13
  %ptr19 = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  br label %if.end37.sink.split

if.then25:                                        ; preds = %if.end
  %3 = and i32 %bf.load, 240
  %cmp29 = icmp eq i32 %3, 112
  br i1 %cmp29, label %if.then30, label %if.end37

if.then30:                                        ; preds = %if.then25
  %ptr31 = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %4 = load ptr, ptr %ptr31, align 8
  br label %if.end37.sink.split

if.end37.sink.split:                              ; preds = %if.then8, %if.then30, %if.then18
  %ptr19.sink = phi ptr [ %ptr19, %if.then18 ], [ %4, %if.then30 ], [ %ptr, %if.then8 ]
  %5 = load ptr, ptr %ptr19.sink, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.end37.sink.split, %if.then13, %if.then25, %if.then4
  %ht.0 = phi ptr [ null, %if.then4 ], [ null, %if.then13 ], [ null, %if.then25 ], [ %5, %if.end37.sink.split ]
  %done = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %cursor, i64 0, i32 1
  %6 = load i32, ptr %done, align 8
  %tobool.not = icmp eq i32 %6, 0
  br i1 %tobool.not, label %if.end40, label %return

if.end40:                                         ; preds = %if.end37
  %tobool41.not = icmp eq ptr %ht.0, null
  br i1 %tobool41.not, label %if.else53, label %if.then42

if.then42:                                        ; preds = %if.end40
  store ptr %key, ptr %data, align 8
  %user_data = getelementptr inbounds %struct.ScanKeyCBData, ptr %data, i64 0, i32 1
  store ptr %privdata, ptr %user_data, align 8
  %fn44 = getelementptr inbounds %struct.ScanKeyCBData, ptr %data, i64 0, i32 2
  store ptr %fn, ptr %fn44, align 8
  %7 = load i64, ptr %cursor, align 8
  %call46 = call i64 @dictScan(ptr noundef nonnull %ht.0, i64 noundef %7, ptr noundef nonnull @moduleScanKeyCallback, ptr noundef nonnull %data) #32
  store i64 %call46, ptr %cursor, align 8
  %cmp49 = icmp eq i64 %call46, 0
  br i1 %cmp49, label %if.end103.sink.split, label %return

if.else53:                                        ; preds = %if.end40
  switch i32 %bf.clear, label %return [
    i32 2, label %if.then57
    i32 3, label %if.then72
    i32 4, label %if.then72
  ]

if.then57:                                        ; preds = %if.else53
  %call58 = tail call ptr @setTypeInitIterator(ptr noundef nonnull %0) #32
  %call5947 = tail call ptr @setTypeNextObject(ptr noundef %call58) #32
  %cmp60.not48 = icmp eq ptr %call5947, null
  br i1 %cmp60.not48, label %while.end, label %while.body

while.body:                                       ; preds = %if.then57, %while.body
  %call5949 = phi ptr [ %call59, %while.body ], [ %call5947, %if.then57 ]
  %call61 = tail call ptr @createObject(i32 noundef 0, ptr noundef nonnull %call5949) #32
  tail call void %fn(ptr noundef nonnull %key, ptr noundef %call61, ptr noundef null, ptr noundef %privdata) #32
  tail call void @decrRefCount(ptr noundef %call61) #32
  %call59 = tail call ptr @setTypeNextObject(ptr noundef %call58) #32
  %cmp60.not = icmp eq ptr %call59, null
  br i1 %cmp60.not, label %while.end, label %while.body, !llvm.loop !65

while.end:                                        ; preds = %while.body, %if.then57
  tail call void @setTypeReleaseIterator(ptr noundef %call58) #32
  br label %if.end103.sink.split.sink.split

if.then72:                                        ; preds = %if.else53, %if.else53
  %ptr73 = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %8 = load ptr, ptr %ptr73, align 8
  %call74 = tail call ptr @lpSeek(ptr noundef %8, i64 noundef 0) #32
  %tobool76.not45 = icmp eq ptr %call74, null
  br i1 %tobool76.not45, label %if.end103.sink.split.sink.split, label %while.body77

while.body77:                                     ; preds = %if.then72, %cond.end94
  %p.046 = phi ptr [ %call97, %cond.end94 ], [ %call74, %if.then72 ]
  %call78 = call ptr @lpGetValue(ptr noundef nonnull %p.046, ptr noundef nonnull %vlen, ptr noundef nonnull %vll) #32
  %cmp80.not = icmp eq ptr %call78, null
  br i1 %cmp80.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %while.body77
  %9 = load i32, ptr %vlen, align 4
  %conv = zext i32 %9 to i64
  %call81 = call ptr @createStringObject(ptr noundef nonnull %call78, i64 noundef %conv) #32
  br label %cond.end

cond.false:                                       ; preds = %while.body77
  %10 = load i64, ptr %vll, align 8
  %call82 = call ptr @createStringObjectFromLongLongWithSds(i64 noundef %10) #32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call81, %cond.true ], [ %call82, %cond.false ]
  %11 = load ptr, ptr %ptr73, align 8
  %call84 = call ptr @lpNext(ptr noundef %11, ptr noundef nonnull %p.046) #32
  %call85 = call ptr @lpGetValue(ptr noundef %call84, ptr noundef nonnull %vlen, ptr noundef nonnull %vll) #32
  %cmp87.not = icmp eq ptr %call85, null
  br i1 %cmp87.not, label %cond.false92, label %cond.true89

cond.true89:                                      ; preds = %cond.end
  %12 = load i32, ptr %vlen, align 4
  %conv90 = zext i32 %12 to i64
  %call91 = call ptr @createStringObject(ptr noundef nonnull %call85, i64 noundef %conv90) #32
  br label %cond.end94

cond.false92:                                     ; preds = %cond.end
  %13 = load i64, ptr %vll, align 8
  %call93 = call ptr @createStringObjectFromLongLongWithSds(i64 noundef %13) #32
  br label %cond.end94

cond.end94:                                       ; preds = %cond.false92, %cond.true89
  %cond95 = phi ptr [ %call91, %cond.true89 ], [ %call93, %cond.false92 ]
  call void %fn(ptr noundef nonnull %key, ptr noundef %cond, ptr noundef %cond95, ptr noundef %privdata) #32
  %14 = load ptr, ptr %ptr73, align 8
  %call97 = call ptr @lpNext(ptr noundef %14, ptr noundef %call84) #32
  call void @decrRefCount(ptr noundef %cond) #32
  call void @decrRefCount(ptr noundef %cond95) #32
  %tobool76.not = icmp eq ptr %call97, null
  br i1 %tobool76.not, label %if.end103.sink.split.sink.split, label %while.body77, !llvm.loop !66

if.end103.sink.split.sink.split:                  ; preds = %cond.end94, %if.then72, %while.end
  store i64 1, ptr %cursor, align 8
  br label %if.end103.sink.split

if.end103.sink.split:                             ; preds = %if.end103.sink.split.sink.split, %if.then42
  store i32 1, ptr %done, align 8
  br label %return

return:                                           ; preds = %if.then42, %if.else53, %if.end103.sink.split, %if.end37, %if.end, %entry, %lor.lhs.false
  %.sink = phi i32 [ 22, %lor.lhs.false ], [ 22, %entry ], [ 22, %if.end ], [ 2, %if.end37 ], [ 0, %if.end103.sink.split ], [ 0, %if.else53 ], [ 0, %if.then42 ]
  %retval.0 = phi i32 [ 0, %lor.lhs.false ], [ 0, %entry ], [ 0, %if.end ], [ 0, %if.end37 ], [ 0, %if.end103.sink.split ], [ 1, %if.else53 ], [ 1, %if.then42 ]
  %call104 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call104, align 4
  ret i32 %retval.0
}

declare i64 @dictScan(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal void @moduleScanKeyCallback(ptr nocapture noundef readonly %privdata, ptr noundef %de) #0 {
entry:
  %call = tail call ptr @dictGetKey(ptr noundef %de) #32
  %0 = load ptr, ptr %privdata, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i64 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %call, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %call, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %call, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %call, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %call, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call3 = tail call ptr @createStringObject(ptr noundef nonnull %call, i64 noundef %retval.0.i) #32
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %if.end21 [
    i32 3, label %if.then16
    i32 4, label %if.then8
  ]

if.then8:                                         ; preds = %sdslen.exit
  %call9 = tail call ptr @dictGetVal(ptr noundef %de) #32
  %arrayidx.i13 = getelementptr inbounds i8, ptr %call9, i64 -1
  %7 = load i8, ptr %arrayidx.i13, align 1
  %conv.i14 = zext i8 %7 to i32
  %and.i15 = and i32 %conv.i14, 7
  switch i32 %and.i15, label %sdslen.exit31 [
    i32 0, label %sw.bb.i28
    i32 1, label %sw.bb3.i25
    i32 2, label %sw.bb5.i22
    i32 3, label %sw.bb9.i19
    i32 4, label %sw.bb13.i16
  ]

sw.bb.i28:                                        ; preds = %if.then8
  %shr.i29 = lshr i32 %conv.i14, 3
  %conv2.i30 = zext nneg i32 %shr.i29 to i64
  br label %sdslen.exit31

sw.bb3.i25:                                       ; preds = %if.then8
  %add.ptr.i26 = getelementptr inbounds i8, ptr %call9, i64 -3
  %8 = load i8, ptr %add.ptr.i26, align 1
  %conv4.i27 = zext i8 %8 to i64
  br label %sdslen.exit31

sw.bb5.i22:                                       ; preds = %if.then8
  %add.ptr6.i23 = getelementptr inbounds i8, ptr %call9, i64 -5
  %9 = load i16, ptr %add.ptr6.i23, align 1
  %conv8.i24 = zext i16 %9 to i64
  br label %sdslen.exit31

sw.bb9.i19:                                       ; preds = %if.then8
  %add.ptr10.i20 = getelementptr inbounds i8, ptr %call9, i64 -9
  %10 = load i32, ptr %add.ptr10.i20, align 1
  %conv12.i21 = zext i32 %10 to i64
  br label %sdslen.exit31

sw.bb13.i16:                                      ; preds = %if.then8
  %add.ptr14.i17 = getelementptr inbounds i8, ptr %call9, i64 -17
  %11 = load i64, ptr %add.ptr14.i17, align 1
  br label %sdslen.exit31

sdslen.exit31:                                    ; preds = %if.then8, %sw.bb.i28, %sw.bb3.i25, %sw.bb5.i22, %sw.bb9.i19, %sw.bb13.i16
  %retval.0.i18 = phi i64 [ %11, %sw.bb13.i16 ], [ %conv12.i21, %sw.bb9.i19 ], [ %conv8.i24, %sw.bb5.i22 ], [ %conv4.i27, %sw.bb3.i25 ], [ %conv2.i30, %sw.bb.i28 ], [ 0, %if.then8 ]
  %call11 = tail call ptr @createStringObject(ptr noundef nonnull %call9, i64 noundef %retval.0.i18) #32
  br label %if.end21

if.then16:                                        ; preds = %sdslen.exit
  %call18 = tail call ptr @dictGetVal(ptr noundef %de) #32
  %12 = load double, ptr %call18, align 8
  %conv = fpext double %12 to x86_fp80
  %call19 = tail call ptr @createStringObjectFromLongDouble(x86_fp80 noundef %conv, i32 noundef 0) #32
  br label %if.end21

if.end21:                                         ; preds = %sdslen.exit, %sdslen.exit31, %if.then16
  %value4.0 = phi ptr [ %call11, %sdslen.exit31 ], [ %call19, %if.then16 ], [ null, %sdslen.exit ]
  %fn = getelementptr inbounds %struct.ScanKeyCBData, ptr %privdata, i64 0, i32 2
  %13 = load ptr, ptr %fn, align 8
  %14 = load ptr, ptr %privdata, align 8
  %user_data = getelementptr inbounds %struct.ScanKeyCBData, ptr %privdata, i64 0, i32 1
  %15 = load ptr, ptr %user_data, align 8
  tail call void %13(ptr noundef %14, ptr noundef %call3, ptr noundef %value4.0, ptr noundef %15) #32
  tail call void @decrRefCount(ptr noundef %call3) #32
  %tobool.not = icmp eq ptr %value4.0, null
  br i1 %tobool.not, label %if.end24, label %if.then23

if.then23:                                        ; preds = %if.end21
  tail call void @decrRefCount(ptr noundef nonnull %value4.0) #32
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end21
  ret void
}

declare ptr @setTypeInitIterator(ptr noundef) local_unnamed_addr #1

declare ptr @setTypeNextObject(ptr noundef) local_unnamed_addr #1

declare void @setTypeReleaseIterator(ptr noundef) local_unnamed_addr #1

declare ptr @lpSeek(ptr noundef, i64 noundef) local_unnamed_addr #1

declare ptr @lpGetValue(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_Fork(ptr noundef %cb, ptr noundef %user_data) #0 {
entry:
  %call = tail call i32 @redisFork(i32 noundef 4) #32
  switch i32 %call, label %if.else8 [
    i32 0, label %if.then
    i32 -1, label %do.body
  ]

if.then:                                          ; preds = %entry
  %call1 = tail call i32 @redisSetProcTitle(ptr noundef nonnull @.str.95) #32
  br label %if.end15

do.body:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp4 = icmp sgt i32 %0, 3
  br i1 %cmp4, label %if.end15, label %if.end

if.end:                                           ; preds = %do.body
  %call6 = tail call ptr @__errno_location() #37
  %1 = load i32, ptr %call6, align 4
  %call7 = tail call ptr @strerror(i32 noundef %1) #32
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.96, ptr noundef %call7) #32
  br label %if.end15

if.else8:                                         ; preds = %entry
  store ptr %cb, ptr @moduleForkInfo.0, align 8
  store ptr %user_data, ptr @moduleForkInfo.1, align 8
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp10 = icmp sgt i32 %2, 1
  br i1 %cmp10, label %if.end15, label %if.end12

if.end12:                                         ; preds = %if.else8
  %conv = sext i32 %call to i64
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.97, i64 noundef %conv) #32
  br label %if.end15

if.end15:                                         ; preds = %do.body, %if.end, %if.else8, %if.end12, %if.then
  ret i32 %call
}

declare i32 @redisFork(i32 noundef) local_unnamed_addr #1

declare i32 @redisSetProcTitle(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) local_unnamed_addr #25

; Function Attrs: nounwind uwtable
define dso_local void @RM_SendChildHeartbeat(double noundef %progress) #0 {
entry:
  tail call void @sendChildInfoGeneric(i32 noundef 0, i64 noundef 0, double noundef %progress, ptr noundef nonnull @.str.98) #32
  ret void
}

declare void @sendChildInfoGeneric(i32 noundef, i64 noundef, double noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_ExitFromChild(i32 noundef %retcode) #0 {
entry:
  tail call void @sendChildCowInfo(i32 noundef 3, ptr noundef nonnull @.str.98) #32
  tail call void @exitFromChild(i32 noundef %retcode) #32
  ret i32 0
}

declare void @sendChildCowInfo(i32 noundef, ptr noundef) local_unnamed_addr #1

declare void @exitFromChild(i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @TerminateModuleForkChild(i32 noundef %child_pid, i32 noundef %wait) local_unnamed_addr #0 {
entry:
  %statloc = alloca i32, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  %cmp.not = icmp eq i32 %0, 4
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp1.not = icmp eq i32 %1, %child_pid
  %or.cond2 = select i1 %cmp.not, i1 %cmp1.not, i1 false
  br i1 %or.cond2, label %do.body, label %return

do.body:                                          ; preds = %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2 = icmp sgt i32 %2, 1
  br i1 %cmp2, label %do.end, label %if.end4

if.end4:                                          ; preds = %do.body
  %conv = sext i32 %child_pid to i64
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.99, i64 noundef %conv) #32
  %.pre = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end4
  %3 = phi i32 [ %child_pid, %do.body ], [ %.pre, %if.end4 ]
  %call = tail call i32 @kill(i32 noundef %3, i32 noundef 10) #32
  %cmp5 = icmp ne i32 %call, -1
  %tobool = icmp ne i32 %wait, 0
  %or.cond = and i1 %tobool, %cmp5
  br i1 %or.cond, label %while.cond.preheader, label %if.end11

while.cond.preheader:                             ; preds = %do.end
  %.pre1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  br label %while.cond

while.cond:                                       ; preds = %while.cond.preheader, %while.cond
  %4 = phi i32 [ %.pre1, %while.cond.preheader ], [ %5, %while.cond ]
  %call8 = call i32 @waitpid(i32 noundef %4, ptr noundef nonnull %statloc, i32 noundef 0) #32
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp9.not = icmp eq i32 %call8, %5
  br i1 %cmp9.not, label %if.end11, label %while.cond, !llvm.loop !67

if.end11:                                         ; preds = %while.cond, %do.end
  call void @resetChildState() #32
  store ptr null, ptr @moduleForkInfo.0, align 8
  store ptr null, ptr @moduleForkInfo.1, align 8
  br label %return

return:                                           ; preds = %entry, %if.end11
  %retval.0 = phi i32 [ 0, %if.end11 ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare i32 @kill(i32 noundef, i32 noundef) local_unnamed_addr #25

declare i32 @waitpid(i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

declare void @resetChildState() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_KillForkChild(i32 noundef %child_pid) #0 {
entry:
  %statloc.i = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %statloc.i)
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  %cmp.not.i = icmp eq i32 %0, 4
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp1.not.i = icmp eq i32 %1, %child_pid
  %or.cond2.i = select i1 %cmp.not.i, i1 %cmp1.not.i, i1 false
  br i1 %or.cond2.i, label %do.body.i, label %TerminateModuleForkChild.exit

do.body.i:                                        ; preds = %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2.i = icmp sgt i32 %2, 1
  br i1 %cmp2.i, label %do.end.i, label %if.end4.i

if.end4.i:                                        ; preds = %do.body.i
  %conv.i = sext i32 %child_pid to i64
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.99, i64 noundef %conv.i) #32
  %.pre.i = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  br label %do.end.i

do.end.i:                                         ; preds = %if.end4.i, %do.body.i
  %3 = phi i32 [ %child_pid, %do.body.i ], [ %.pre.i, %if.end4.i ]
  %call.i = tail call i32 @kill(i32 noundef %3, i32 noundef 10) #32
  %cmp5.i.not = icmp eq i32 %call.i, -1
  br i1 %cmp5.i.not, label %.loopexit, label %while.cond.preheader.i

while.cond.preheader.i:                           ; preds = %do.end.i
  %.pre1.i = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.cond.i, %while.cond.preheader.i
  %4 = phi i32 [ %.pre1.i, %while.cond.preheader.i ], [ %5, %while.cond.i ]
  %call8.i = call i32 @waitpid(i32 noundef %4, ptr noundef nonnull %statloc.i, i32 noundef 0) #32
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp9.not.i = icmp eq i32 %call8.i, %5
  br i1 %cmp9.not.i, label %.loopexit, label %while.cond.i, !llvm.loop !67

TerminateModuleForkChild.exit:                    ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %statloc.i)
  br label %6

.loopexit:                                        ; preds = %while.cond.i, %do.end.i
  call void @resetChildState() #32
  store ptr null, ptr @moduleForkInfo.0, align 8
  store ptr null, ptr @moduleForkInfo.1, align 8
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %statloc.i)
  br label %6

6:                                                ; preds = %TerminateModuleForkChild.exit, %.loopexit
  %7 = phi i32 [ 0, %.loopexit ], [ 1, %TerminateModuleForkChild.exit ]
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define dso_local void @ModuleForkDoneHandler(i32 noundef %exitcode, i32 noundef %bysignal) local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %0, 2
  br i1 %cmp, label %do.end, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %conv = sext i32 %1 to i64
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.100, i64 noundef %conv, i32 noundef %exitcode, i32 noundef %bysignal) #32
  br label %do.end

do.end:                                           ; preds = %entry, %if.end
  %2 = load ptr, ptr @moduleForkInfo.0, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %if.end2, label %if.then1

if.then1:                                         ; preds = %do.end
  %3 = load ptr, ptr @moduleForkInfo.1, align 8
  tail call void %2(i32 noundef %exitcode, i32 noundef %bysignal, ptr noundef %3) #32
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %do.end
  store ptr null, ptr @moduleForkInfo.0, align 8
  store ptr null, ptr @moduleForkInfo.1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_SubscribeToServerEvent(ptr nocapture noundef readonly %ctx, i64 %event.coerce0, i64 %event.coerce1, ptr noundef %callback) #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %cmp = icmp eq ptr %0, null
  %cmp1 = icmp ugt i64 %event.coerce0, 17
  %or.cond = select i1 %cmp, i1 true, i1 %cmp1
  br i1 %or.cond, label %return, label %if.end3

if.end3:                                          ; preds = %entry
  %arrayidx = getelementptr inbounds [18 x i64], ptr @moduleEventVersions, i64 0, i64 %event.coerce0
  %1 = load i64, ptr %arrayidx, align 8
  %cmp5 = icmp ult i64 %1, %event.coerce1
  br i1 %cmp5, label %return, label %if.end7

if.end7:                                          ; preds = %if.end3
  %2 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listRewind(ptr noundef %2, ptr noundef nonnull %li) #32
  %call18 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not19 = icmp eq ptr %call18, null
  br i1 %tobool.not19, label %if.end23, label %while.body

while.body:                                       ; preds = %if.end7, %if.end16
  %call20 = phi ptr [ %call, %if.end16 ], [ %call18, %if.end7 ]
  %value = getelementptr inbounds %struct.listNode, ptr %call20, i64 0, i32 2
  %3 = load ptr, ptr %value, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = load ptr, ptr %module, align 8
  %cmp10 = icmp eq ptr %4, %5
  br i1 %cmp10, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %while.body
  %event11 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %3, i64 0, i32 1
  %6 = load i64, ptr %event11, align 8
  %cmp14 = icmp eq i64 %6, %event.coerce0
  br i1 %cmp14, label %if.then18, label %if.end16

if.end16:                                         ; preds = %land.lhs.true, %while.body
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %if.end23, label %while.body, !llvm.loop !68

if.then18:                                        ; preds = %land.lhs.true
  %cmp19 = icmp eq ptr %callback, null
  br i1 %cmp19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.then18
  %7 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listDelNode(ptr noundef %7, ptr noundef nonnull %call20) #32
  call void @zfree(ptr noundef nonnull %3) #32
  br label %return

if.else:                                          ; preds = %if.then18
  %callback21 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %3, i64 0, i32 2
  store ptr %callback, ptr %callback21, align 8
  br label %return

if.end23:                                         ; preds = %if.end16, %if.end7
  %call24 = call noalias dereferenceable_or_null(32) ptr @zmalloc(i64 noundef 32) #33
  %8 = load ptr, ptr %module, align 8
  store ptr %8, ptr %call24, align 8
  %event27 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %call24, i64 0, i32 1
  store i64 %event.coerce0, ptr %event27, align 8
  %event.sroa.5.0.event27.sroa_idx = getelementptr inbounds %struct.RedisModuleEventListener, ptr %call24, i64 0, i32 1, i32 1
  store i64 %event.coerce1, ptr %event.sroa.5.0.event27.sroa_idx, align 8
  %callback28 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %call24, i64 0, i32 2
  store ptr %callback, ptr %callback28, align 8
  %9 = load ptr, ptr @RedisModule_EventListeners, align 8
  %call29 = call ptr @listAddNodeTail(ptr noundef %9, ptr noundef nonnull %call24) #32
  br label %return

return:                                           ; preds = %if.then20, %if.else, %if.end3, %entry, %if.end23
  %retval.0 = phi i32 [ 0, %if.end23 ], [ 1, %entry ], [ 1, %if.end3 ], [ 0, %if.else ], [ 0, %if.then20 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @RM_IsSubEventSupported(i64 %event.coerce0, i64 %event.coerce1, i64 noundef %subevent) #22 {
entry:
  switch i64 %event.coerce0, label %return [
    i64 0, label %sw.bb
    i64 1, label %sw.bb1
    i64 2, label %sw.bb4
    i64 3, label %sw.bb7
    i64 4, label %sw.bb10
    i64 5, label %sw.bb13
    i64 6, label %sw.bb16
    i64 7, label %sw.bb19
    i64 8, label %sw.bb22
    i64 9, label %sw.bb25
    i64 10, label %sw.bb28
    i64 11, label %sw.bb31
    i64 14, label %sw.bb34
    i64 13, label %sw.bb37
    i64 15, label %sw.bb40
    i64 16, label %sw.bb43
    i64 17, label %sw.bb46
  ]

sw.bb:                                            ; preds = %entry
  %cmp = icmp slt i64 %subevent, 2
  %conv = zext i1 %cmp to i32
  br label %return

sw.bb1:                                           ; preds = %entry
  %cmp2 = icmp slt i64 %subevent, 6
  %conv3 = zext i1 %cmp2 to i32
  br label %return

sw.bb4:                                           ; preds = %entry
  %cmp5 = icmp slt i64 %subevent, 2
  %conv6 = zext i1 %cmp5 to i32
  br label %return

sw.bb7:                                           ; preds = %entry
  %cmp8 = icmp slt i64 %subevent, 5
  %conv9 = zext i1 %cmp8 to i32
  br label %return

sw.bb10:                                          ; preds = %entry
  %cmp11 = icmp slt i64 %subevent, 2
  %conv12 = zext i1 %cmp11 to i32
  br label %return

sw.bb13:                                          ; preds = %entry
  %subevent.lobit18 = lshr i64 %subevent, 63
  %conv15 = trunc i64 %subevent.lobit18 to i32
  br label %return

sw.bb16:                                          ; preds = %entry
  %cmp17 = icmp slt i64 %subevent, 2
  %conv18 = zext i1 %cmp17 to i32
  br label %return

sw.bb19:                                          ; preds = %entry
  %cmp20 = icmp slt i64 %subevent, 2
  %conv21 = zext i1 %cmp20 to i32
  br label %return

sw.bb22:                                          ; preds = %entry
  %subevent.lobit17 = lshr i64 %subevent, 63
  %conv24 = trunc i64 %subevent.lobit17 to i32
  br label %return

sw.bb25:                                          ; preds = %entry
  %cmp26 = icmp slt i64 %subevent, 2
  %conv27 = zext i1 %cmp26 to i32
  br label %return

sw.bb28:                                          ; preds = %entry
  %cmp29 = icmp slt i64 %subevent, 2
  %conv30 = zext i1 %cmp29 to i32
  br label %return

sw.bb31:                                          ; preds = %entry
  %subevent.lobit = lshr i64 %subevent, 63
  %conv33 = trunc i64 %subevent.lobit to i32
  br label %return

sw.bb34:                                          ; preds = %entry
  %cmp35 = icmp slt i64 %subevent, 3
  %conv36 = zext i1 %cmp35 to i32
  br label %return

sw.bb37:                                          ; preds = %entry
  %cmp38 = icmp slt i64 %subevent, 2
  %conv39 = zext i1 %cmp38 to i32
  br label %return

sw.bb40:                                          ; preds = %entry
  %cmp41 = icmp slt i64 %subevent, 2
  %conv42 = zext i1 %cmp41 to i32
  br label %return

sw.bb43:                                          ; preds = %entry
  %cmp44 = icmp slt i64 %subevent, 1
  %conv45 = zext i1 %cmp44 to i32
  br label %return

sw.bb46:                                          ; preds = %entry
  %cmp47 = icmp slt i64 %subevent, 4
  %conv48 = zext i1 %cmp47 to i32
  br label %return

return:                                           ; preds = %entry, %sw.bb46, %sw.bb43, %sw.bb40, %sw.bb37, %sw.bb34, %sw.bb31, %sw.bb28, %sw.bb25, %sw.bb22, %sw.bb19, %sw.bb16, %sw.bb13, %sw.bb10, %sw.bb7, %sw.bb4, %sw.bb1, %sw.bb
  %retval.0 = phi i32 [ %conv48, %sw.bb46 ], [ %conv45, %sw.bb43 ], [ %conv42, %sw.bb40 ], [ %conv39, %sw.bb37 ], [ %conv36, %sw.bb34 ], [ %conv33, %sw.bb31 ], [ %conv30, %sw.bb28 ], [ %conv27, %sw.bb25 ], [ %conv24, %sw.bb22 ], [ %conv21, %sw.bb19 ], [ %conv18, %sw.bb16 ], [ %conv15, %sw.bb13 ], [ %conv12, %sw.bb10 ], [ %conv9, %sw.bb7 ], [ %conv6, %sw.bb4 ], [ %conv3, %sw.bb1 ], [ %conv, %sw.bb ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleFireServerEvent(i64 noundef %eid, i32 noundef %subid, ptr noundef %data) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %civ1 = alloca %struct.RedisModuleClientInfo, align 8
  %riv1 = alloca %struct.RedisModuleReplicationInfo, align 8
  %mcv1 = alloca %struct.RedisModuleModuleChange, align 8
  %key = alloca %struct.RedisModuleKey, align 8
  %ki = alloca %struct.RedisModuleKeyInfo, align 8
  %0 = load ptr, ptr @RedisModule_EventListeners, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %while.end, label %if.end

if.end:                                           ; preds = %entry
  call void @listRewind(ptr noundef nonnull %0, ptr noundef nonnull %li) #32
  %call54 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not55 = icmp eq ptr %call54, null
  br i1 %tobool.not55, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end
  %cmp3 = icmp eq i64 %eid, 4
  %2 = getelementptr inbounds i8, ptr %ctx, i64 16
  %module1.i36 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %flags.i37 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  %3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  %key7 = getelementptr inbounds %struct.RedisModuleKeyInfo, ptr %ki, i64 0, i32 1
  %key80 = getelementptr inbounds %struct.KeyInfo, ptr %data, i64 0, i32 1
  %value81 = getelementptr inbounds %struct.KeyInfo, ptr %data, i64 0, i32 2
  %mode = getelementptr inbounds %struct.KeyInfo, ptr %data, i64 0, i32 3
  %db2.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 1
  %key.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 2
  %value3.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %iter.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %mode4.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %signalready.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 1
  %u.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6
  %current.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 0, i32 2, i32 6
  %er.i.i.i = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 6, i32 0, i32 1
  %module_name = getelementptr inbounds %struct.RedisModuleModuleChange, ptr %mcv1, i64 0, i32 1
  %module_version = getelementptr inbounds %struct.RedisModuleModuleChange, ptr %mcv1, i64 0, i32 2
  %dbnum = getelementptr inbounds %struct.RedisModuleFlushInfo, ptr %data, i64 0, i32 2
  %4 = getelementptr inbounds i8, ptr %riv1, i64 8
  %masterhost.i = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %riv1, i64 0, i32 2
  %masterport.i = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %riv1, i64 0, i32 3
  %replid1.i = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %riv1, i64 0, i32 4
  %replid2.i = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %riv1, i64 0, i32 5
  %repl1_offset.i = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %riv1, i64 0, i32 6
  %conv93 = sext i32 %subid to i64
  %cmp96 = icmp eq i64 %eid, 17
  br i1 %cmp3, label %while.body.us, label %while.body

while.body.us:                                    ; preds = %while.body.lr.ph, %if.end100.us
  %call56.us = phi ptr [ %call.us, %if.end100.us ], [ %call54, %while.body.lr.ph ]
  %value.us = getelementptr inbounds %struct.listNode, ptr %call56.us, i64 0, i32 2
  %5 = load ptr, ptr %value.us, align 8
  %event.us = getelementptr inbounds %struct.RedisModuleEventListener, ptr %5, i64 0, i32 1
  %6 = load i64, ptr %event.us, align 8
  %cmp1.us = icmp eq i64 %6, 4
  br i1 %cmp1.us, label %if.then2.us, label %if.end100.us

if.then2.us:                                      ; preds = %while.body.us
  %7 = load ptr, ptr %5, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  store ptr %7, ptr %module1.i36, align 8
  %8 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i.us = icmp eq i32 %8, 0
  %9 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i.us = call i64 %9() #32
  br i1 %tobool8.not.i.us, label %if.else11.i.us, label %if.then9.i.us

if.then9.i.us:                                    ; preds = %if.then2.us
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i.us = sdiv i32 1000000, %10
  %conv.i.us = sext i32 %div.i.us to i64
  %add.i.us = add i64 %call12.i.us, %conv.i.us
  br label %if.then9.us

if.else11.i.us:                                   ; preds = %if.then2.us
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i.us = mul nsw i64 %11, 1000
  %add13.i.us = add i64 %mul.i.us, %call12.i.us
  br label %if.then9.us

if.then9.us:                                      ; preds = %if.else11.i.us, %if.then9.i.us
  %add.sink.i.us = phi i64 [ %add13.i.us, %if.else11.i.us ], [ %add.i.us, %if.then9.i.us ]
  store i64 %add.sink.i.us, ptr %3, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  store ptr %data, ptr %2, align 8
  %dataver.us = getelementptr inbounds %struct.RedisModuleEventListener, ptr %5, i64 0, i32 1, i32 1
  %12 = load i64, ptr %dataver.us, align 8
  %conv.us = trunc i64 %12 to i32
  %call11.us = call i32 @modulePopulateClientInfoStructure(ptr noundef nonnull %civ1, ptr noundef %data, i32 noundef %conv.us), !range !22
  %cmp12.us = icmp eq i32 %call11.us, 0
  br i1 %cmp12.us, label %if.end90.us, label %cond.false

if.end90.us:                                      ; preds = %if.then9.us
  %13 = load ptr, ptr %5, align 8
  %in_hook.us = getelementptr inbounds %struct.RedisModule, ptr %13, i64 0, i32 11
  %14 = load i32, ptr %in_hook.us, align 8
  %inc.us = add nsw i32 %14, 1
  store i32 %inc.us, ptr %in_hook.us, align 8
  %callback.us = getelementptr inbounds %struct.RedisModuleEventListener, ptr %5, i64 0, i32 2
  %15 = load ptr, ptr %callback.us, align 8
  %16 = load i64, ptr %event.us, align 8
  %17 = load i64, ptr %dataver.us, align 8
  call void %15(ptr noundef nonnull %ctx, i64 %16, i64 %17, i64 noundef %conv93, ptr noundef nonnull %civ1) #32
  %18 = load ptr, ptr %5, align 8
  %in_hook95.us = getelementptr inbounds %struct.RedisModule, ptr %18, i64 0, i32 11
  %19 = load i32, ptr %in_hook95.us, align 8
  %dec.us = add nsw i32 %19, -1
  store i32 %dec.us, ptr %in_hook95.us, align 8
  br i1 %cmp96, label %if.then98.us, label %if.end99.us

if.then98.us:                                     ; preds = %if.end90.us
  call fastcc void @moduleCloseKey(ptr noundef nonnull %key)
  br label %if.end99.us

if.end99.us:                                      ; preds = %if.then98.us, %if.end90.us
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %if.end100.us

if.end100.us:                                     ; preds = %if.end99.us, %while.body.us
  %call.us = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not.us = icmp eq ptr %call.us, null
  br i1 %tobool.not.us, label %while.end, label %while.body.us, !llvm.loop !69

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %call56 = phi ptr [ %call, %while.cond.backedge ], [ %call54, %while.body.lr.ph ]
  %value = getelementptr inbounds %struct.listNode, ptr %call56, i64 0, i32 2
  %20 = load ptr, ptr %value, align 8
  %event = getelementptr inbounds %struct.RedisModuleEventListener, ptr %20, i64 0, i32 1
  %21 = load i64, ptr %event, align 8
  %cmp1 = icmp eq i64 %21, %eid
  br i1 %cmp1, label %if.then2, label %while.cond.backedge

if.then2:                                         ; preds = %while.body
  %22 = load ptr, ptr %20, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %2, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  store ptr %22, ptr %module1.i36, align 8
  store i32 64, ptr %flags.i37, align 8
  %23 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i.i = icmp eq i64 %23, 0
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.then2
  %24 = load ptr, ptr @moduleTempClients, align 8
  %dec.i.i = add i64 %23, -1
  store i64 %dec.i.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %24, i64 %dec.i.i
  %25 = load ptr, ptr %arrayidx.i.i, align 8
  %26 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i.i = icmp ult i64 %dec.i.i, %26
  br i1 %cmp1.i.i, label %if.then2.i.i, label %if.end7.sink.split.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  store i64 %dec.i.i, ptr @moduleTempClientMinCount, align 8
  br label %if.end7.sink.split.i

if.else.i.i:                                      ; preds = %if.then2
  %call.i.i = call ptr @createClient(ptr noundef null) #32
  %flags.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 1
  %27 = load i64, ptr %flags.i.i, align 8
  %or.i.i = or i64 %27, 134217728
  store i64 %or.i.i, ptr %flags.i.i, align 8
  %user.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 20
  store ptr null, ptr %user.i.i, align 8
  br label %if.end7.sink.split.i

if.end7.sink.split.i:                             ; preds = %if.else.i.i, %if.then2.i.i, %if.then.i.i
  %call5.sink.i = phi ptr [ %25, %if.then2.i.i ], [ %25, %if.then.i.i ], [ %call.i.i, %if.else.i.i ]
  store ptr %call5.sink.i, ptr %2, align 8
  %28 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i38 = icmp eq i32 %28, 0
  %29 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i39 = call i64 %29() #32
  br i1 %tobool8.not.i38, label %if.else11.i45, label %if.then9.i40

if.then9.i40:                                     ; preds = %if.end7.sink.split.i
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i41 = sdiv i32 1000000, %30
  %conv.i42 = sext i32 %div.i41 to i64
  %add.i43 = add i64 %call12.i39, %conv.i42
  br label %if.else17

if.else11.i45:                                    ; preds = %if.end7.sink.split.i
  %31 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i46 = mul nsw i64 %31, 1000
  %add13.i47 = add i64 %mul.i46, %call12.i39
  br label %if.else17

cond.false:                                       ; preds = %if.then9.us
  call void @_serverAssert(ptr noundef nonnull @.str.101, ptr noundef nonnull @.str.2, i32 noundef 11683) #32
  call void @abort() #35
  unreachable

if.else17:                                        ; preds = %if.then9.i40, %if.else11.i45
  %add.sink.i44 = phi i64 [ %add13.i47, %if.else11.i45 ], [ %add.i43, %if.then9.i40 ]
  store i64 %add.sink.i44, ptr %3, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  store i64 1, ptr %ki, align 8
  store ptr %key, ptr %key7, align 8
  switch i64 %eid, label %if.end90.fold.split [
    i64 0, label %if.then20
    i64 2, label %if.then39
    i64 9, label %if.then50
    i64 10, label %if.end90
    i64 8, label %if.end90
    i64 11, label %if.end90
    i64 16, label %if.end90
    i64 17, label %if.then76
  ]

if.then20:                                        ; preds = %if.else17
  %dataver22 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %20, i64 0, i32 1, i32 1
  %32 = load i64, ptr %dataver22, align 8
  %33 = and i64 %32, 4294967295
  %cmp.not.i = icmp eq i64 %33, 1
  br i1 %cmp.not.i, label %modulePopulateReplicationInfoStructure.exit.thread, label %cond.false34

modulePopulateReplicationInfoStructure.exit.thread: ; preds = %if.then20
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(64) %4, i8 0, i64 24, i1 false)
  store i64 1, ptr %riv1, align 8
  %34 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp1.i = icmp eq ptr %34, null
  %conv2.i = zext i1 %cmp1.i to i32
  store i32 %conv2.i, ptr %4, align 8
  %cond.i = select i1 %cmp1.i, ptr @.str.41, ptr %34
  store ptr %cond.i, ptr %masterhost.i, align 8
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 284), align 8
  store i32 %35, ptr %masterport.i, align 8
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 260), ptr %replid1.i, align 8
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 261), ptr %replid2.i, align 8
  %36 = load <2 x i64>, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  store <2 x i64> %36, ptr %repl1_offset.i, align 8
  br label %if.end90

cond.false34:                                     ; preds = %if.then20
  call void @_serverAssert(ptr noundef nonnull @.str.102, ptr noundef nonnull @.str.2, i32 noundef 11686) #32
  call void @abort() #35
  unreachable

if.then39:                                        ; preds = %if.else17
  %37 = load i32, ptr %dbnum, align 4
  %cmp40.not = icmp eq i32 %37, -1
  br i1 %cmp40.not, label %if.end90, label %if.then42

if.then42:                                        ; preds = %if.then39
  %38 = load ptr, ptr %2, align 8
  %call45 = call i32 @selectDb(ptr noundef %38, i32 noundef %37) #32
  br label %if.end90

if.then50:                                        ; preds = %if.else17
  %39 = load ptr, ptr %20, align 8
  %cmp52 = icmp eq ptr %39, %data
  br i1 %cmp52, label %while.cond.backedge.sink.split, label %if.end55

while.cond.backedge.sink.split:                   ; preds = %if.then50, %if.end90, %if.then98
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %while.cond.backedge.sink.split, %while.body
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !69

if.end55:                                         ; preds = %if.then50
  store i64 1, ptr %mcv1, align 8
  %40 = load ptr, ptr %key80, align 8
  store ptr %40, ptr %module_name, align 8
  %41 = load i32, ptr %value81, align 8
  store i32 %41, ptr %module_version, align 8
  br label %if.end90

if.then76:                                        ; preds = %if.else17
  %42 = load ptr, ptr %2, align 8
  %43 = load i32, ptr %data, align 8
  %call79 = call i32 @selectDb(ptr noundef %42, i32 noundef %43) #32
  %44 = load ptr, ptr %key80, align 8
  %45 = load ptr, ptr %value81, align 8
  %46 = load i32, ptr %mode, align 8
  store ptr %ctx, ptr %key, align 8
  %47 = load ptr, ptr %2, align 8
  %db.i = getelementptr inbounds %struct.client, ptr %47, i64 0, i32 4
  %48 = load ptr, ptr %db.i, align 8
  store ptr %48, ptr %db2.i, align 8
  store ptr %44, ptr %key.i, align 8
  call void @incrRefCount(ptr noundef %44) #32
  store ptr %45, ptr %value3.i, align 8
  store ptr null, ptr %iter.i, align 8
  store i32 %46, ptr %mode4.i, align 8
  %tobool.not.i49 = icmp eq ptr %45, null
  br i1 %tobool.not.i49, label %if.end90, label %if.then.i

if.then.i:                                        ; preds = %if.then76
  %bf.load.i.i = load i32, ptr %45, align 8
  %bf.clear.i.i = and i32 %bf.load.i.i, 15
  switch i32 %bf.clear.i.i, label %if.end90 [
    i32 3, label %sw.bb.i.i
    i32 6, label %sw.bb1.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then.i
  store i32 0, ptr %u.i.i.i, align 8
  store ptr null, ptr %current.i.i.i, align 8
  store i32 1, ptr %er.i.i.i, align 8
  br label %if.end90

sw.bb1.i.i:                                       ; preds = %if.then.i
  store i32 0, ptr %signalready.i.i, align 8
  br label %if.end90

if.end90.fold.split:                              ; preds = %if.else17
  br label %if.end90

if.end90:                                         ; preds = %sw.bb1.i.i, %sw.bb.i.i, %if.then.i, %if.then76, %modulePopulateReplicationInfoStructure.exit.thread, %if.else17, %if.else17, %if.else17, %if.else17, %if.end90.fold.split, %if.end55, %if.then39, %if.then42
  %moduledata.0 = phi ptr [ %data, %if.then42 ], [ %data, %if.then39 ], [ %mcv1, %if.end55 ], [ %data, %if.else17 ], [ %data, %if.else17 ], [ %data, %if.else17 ], [ %data, %if.else17 ], [ null, %if.end90.fold.split ], [ %riv1, %modulePopulateReplicationInfoStructure.exit.thread ], [ %ki, %if.then76 ], [ %ki, %if.then.i ], [ %ki, %sw.bb.i.i ], [ %ki, %sw.bb1.i.i ]
  %49 = load ptr, ptr %20, align 8
  %in_hook = getelementptr inbounds %struct.RedisModule, ptr %49, i64 0, i32 11
  %50 = load i32, ptr %in_hook, align 8
  %inc = add nsw i32 %50, 1
  store i32 %inc, ptr %in_hook, align 8
  %callback = getelementptr inbounds %struct.RedisModuleEventListener, ptr %20, i64 0, i32 2
  %51 = load ptr, ptr %callback, align 8
  %52 = load i64, ptr %event, align 8
  %53 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %20, i64 0, i32 1, i32 1
  %54 = load i64, ptr %53, align 8
  call void %51(ptr noundef nonnull %ctx, i64 %52, i64 %54, i64 noundef %conv93, ptr noundef %moduledata.0) #32
  %55 = load ptr, ptr %20, align 8
  %in_hook95 = getelementptr inbounds %struct.RedisModule, ptr %55, i64 0, i32 11
  %56 = load i32, ptr %in_hook95, align 8
  %dec = add nsw i32 %56, -1
  store i32 %dec, ptr %in_hook95, align 8
  br i1 %cmp96, label %if.then98, label %while.cond.backedge.sink.split

if.then98:                                        ; preds = %if.end90
  call fastcc void @moduleCloseKey(ptr noundef nonnull %key)
  br label %while.cond.backedge.sink.split

while.end:                                        ; preds = %while.cond.backedge, %if.end100.us, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnsubscribeAllServerEvents(ptr noundef readnone %module) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #32
  %call3 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not4 = icmp eq ptr %call3, null
  br i1 %tobool.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call5 = phi ptr [ %call, %if.end ], [ %call3, %entry ]
  %value = getelementptr inbounds %struct.listNode, ptr %call5, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp = icmp eq ptr %2, %module
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %3 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listDelNode(ptr noundef %3, ptr noundef nonnull %call5) #32
  call void @zfree(ptr noundef nonnull %1) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !70

while.end:                                        ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @processModuleLoadingProgressEvent(i32 noundef %is_aof) local_unnamed_addr #0 {
entry:
  %fi = alloca %struct.RedisModuleLoadingProgressInfo, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %1 = load i64, ptr @processModuleLoadingProgressEvent.next_event, align 8
  %cmp.not = icmp slt i64 %0, %1
  br i1 %cmp.not, label %if.end6, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 83), align 8
  %tobool.not = icmp eq i64 %2, 0
  br i1 %tobool.not, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 85), align 8
  %shl = shl i64 %3, 10
  %div = sdiv i64 %shl, %2
  %conv = trunc i64 %div to i32
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %progress.0 = phi i32 [ %conv, %if.then1 ], [ -1, %if.then ]
  store i64 1, ptr %fi, align 8
  %hz = getelementptr inbounds %struct.RedisModuleLoadingProgressInfo, ptr %fi, i64 0, i32 1
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  store i32 %4, ptr %hz, align 8
  %progress2 = getelementptr inbounds %struct.RedisModuleLoadingProgressInfo, ptr %fi, i64 0, i32 2
  store i32 %progress.0, ptr %progress2, align 4
  %tobool3.not = icmp ne i32 %is_aof, 0
  %cond = zext i1 %tobool3.not to i32
  call void @moduleFireServerEvent(i64 noundef 10, i32 noundef %cond, ptr noundef nonnull %fi)
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div4 = sdiv i32 1000000, %5
  %conv5 = sext i32 %div4 to i64
  %add = add nsw i64 %0, %conv5
  store i64 %add, ptr @processModuleLoadingProgressEvent.next_event, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleNotifyKeyUnlink(ptr noundef %key, ptr noundef %val, i32 noundef %dbid, i32 noundef %flags) local_unnamed_addr #0 {
entry:
  %info = alloca %struct.KeyInfo, align 8
  %ctx = alloca %struct.RedisModuleKeyOptCtx, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  %conv13 = zext i32 %flags to i64
  %and = and i64 %conv13, 2
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.else, label %if.end11

if.else:                                          ; preds = %entry
  %and2 = and i64 %conv13, 4
  %tobool3.not = icmp eq i64 %and2, 0
  br i1 %tobool3.not, label %if.else5, label %if.end11

if.else5:                                         ; preds = %if.else
  %and7 = and i64 %conv13, 8
  %tobool8.not = icmp eq i64 %and7, 0
  %spec.select = select i1 %tobool8.not, i32 0, i32 3
  br label %if.end11

if.end11:                                         ; preds = %if.else5, %if.else, %entry
  %subevent.0 = phi i32 [ 1, %entry ], [ 2, %if.else ], [ %spec.select, %if.else5 ]
  store i32 %dbid, ptr %info, align 8
  %key12 = getelementptr inbounds %struct.KeyInfo, ptr %info, i64 0, i32 1
  store ptr %key, ptr %key12, align 8
  %value = getelementptr inbounds %struct.KeyInfo, ptr %info, i64 0, i32 2
  store ptr %val, ptr %value, align 8
  %mode = getelementptr inbounds %struct.KeyInfo, ptr %info, i64 0, i32 3
  store i32 1, ptr %mode, align 8
  call void @moduleFireServerEvent(i64 noundef 17, i32 noundef %subevent.0, ptr noundef nonnull %info)
  %bf.load = load i32, ptr %val, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp eq i32 %bf.clear, 5
  br i1 %cmp, label %if.then14, label %if.end28

if.then14:                                        ; preds = %if.end11
  %ptr = getelementptr inbounds %struct.redisObject, ptr %val, i64 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %2 = load ptr, ptr %1, align 8
  %unlink2 = getelementptr inbounds %struct.RedisModuleType, ptr %2, i64 0, i32 16
  %3 = load ptr, ptr %unlink2, align 8
  %cmp15.not = icmp eq ptr %3, null
  br i1 %cmp15.not, label %if.else20, label %if.then17

if.then17:                                        ; preds = %if.then14
  store ptr %key, ptr %ctx, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 1
  store ptr null, ptr %to_key, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 2
  store i32 %dbid, ptr %from_dbid, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 3
  store i32 -1, ptr %to_dbid, align 4
  %value19 = getelementptr inbounds %struct.moduleValue, ptr %1, i64 0, i32 1
  %4 = load ptr, ptr %value19, align 8
  call void %3(ptr noundef nonnull %ctx, ptr noundef %4) #32
  br label %if.end28

if.else20:                                        ; preds = %if.then14
  %unlink = getelementptr inbounds %struct.RedisModuleType, ptr %2, i64 0, i32 9
  %5 = load ptr, ptr %unlink, align 8
  %cmp21.not = icmp eq ptr %5, null
  br i1 %cmp21.not, label %if.end28, label %if.then23

if.then23:                                        ; preds = %if.else20
  %value25 = getelementptr inbounds %struct.moduleValue, ptr %1, i64 0, i32 1
  %6 = load ptr, ptr %value25, align 8
  call void %5(ptr noundef %key, ptr noundef %6) #32
  br label %if.end28

if.end28:                                         ; preds = %if.then17, %if.then23, %if.else20, %if.end11
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  %dec = add nsw i32 %7, -1
  store i32 %dec, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @moduleGetFreeEffort(ptr noundef %key, ptr nocapture noundef readonly %val, i32 noundef %dbid) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleKeyOptCtx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %val, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %1 = load ptr, ptr %0, align 8
  %free_effort2 = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 15
  %2 = load ptr, ptr %free_effort2, align 8
  %cmp.not = icmp eq ptr %2, null
  br i1 %cmp.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store ptr %key, ptr %ctx, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 1
  store ptr null, ptr %to_key, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 2
  store i32 %dbid, ptr %from_dbid, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 3
  store i32 -1, ptr %to_dbid, align 4
  %value = getelementptr inbounds %struct.moduleValue, ptr %0, i64 0, i32 1
  %3 = load ptr, ptr %value, align 8
  %call = call i64 %2(ptr noundef nonnull %ctx, ptr noundef %3) #32
  br label %if.end7

if.else:                                          ; preds = %entry
  %free_effort = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 8
  %4 = load ptr, ptr %free_effort, align 8
  %cmp2.not = icmp eq ptr %4, null
  br i1 %cmp2.not, label %if.end7, label %if.then3

if.then3:                                         ; preds = %if.else
  %value5 = getelementptr inbounds %struct.moduleValue, ptr %0, i64 0, i32 1
  %5 = load ptr, ptr %value5, align 8
  %call6 = tail call i64 %4(ptr noundef %key, ptr noundef %5) #32
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then3, %if.then
  %effort.0 = phi i64 [ %call, %if.then ], [ %call6, %if.then3 ], [ 1, %if.else ]
  ret i64 %effort.0
}

; Function Attrs: nounwind uwtable
define dso_local i64 @moduleGetMemUsage(ptr noundef %key, ptr nocapture noundef readonly %val, i64 noundef %sample_size, i32 noundef %dbid) local_unnamed_addr #0 {
entry:
  %ctx = alloca %struct.RedisModuleKeyOptCtx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %val, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %1 = load ptr, ptr %0, align 8
  %mem_usage2 = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 14
  %2 = load ptr, ptr %mem_usage2, align 8
  %cmp.not = icmp eq ptr %2, null
  br i1 %cmp.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store ptr %key, ptr %ctx, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 1
  store ptr null, ptr %to_key, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 2
  store i32 %dbid, ptr %from_dbid, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i64 0, i32 3
  store i32 -1, ptr %to_dbid, align 4
  %value = getelementptr inbounds %struct.moduleValue, ptr %0, i64 0, i32 1
  %3 = load ptr, ptr %value, align 8
  %call = call i64 %2(ptr noundef nonnull %ctx, ptr noundef %3, i64 noundef %sample_size) #32
  br label %if.end7

if.else:                                          ; preds = %entry
  %mem_usage = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 5
  %4 = load ptr, ptr %mem_usage, align 8
  %cmp2.not = icmp eq ptr %4, null
  br i1 %cmp2.not, label %if.end7, label %if.then3

if.then3:                                         ; preds = %if.else
  %value5 = getelementptr inbounds %struct.moduleValue, ptr %0, i64 0, i32 1
  %5 = load ptr, ptr %value5, align 8
  %call6 = tail call i64 %4(ptr noundef %5) #32
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then3, %if.then
  %size.0 = phi i64 [ %call, %if.then ], [ %call6, %if.then3 ], [ 0, %if.else ]
  ret i64 %size.0
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dictCStringKeyHash(ptr noundef %key) #0 {
entry:
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %key) #36
  %call1 = tail call i64 @dictGenHashFunction(ptr noundef %key, i64 noundef %call) #32
  ret i64 %call1
}

declare i64 @dictGenHashFunction(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @dictCStringKeyCompare(ptr nocapture readnone %d, ptr nocapture noundef readonly %key1, ptr nocapture noundef readonly %key2) #7 {
entry:
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %key1, ptr noundef nonnull dereferenceable(1) %key2) #36
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i32 @strcmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #8

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleRegisterApi(ptr noundef %funcname, ptr noundef %funcptr) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call = tail call i32 @dictAdd(ptr noundef %0, ptr noundef %funcname, ptr noundef %funcptr) #32
  ret i32 %call
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local void @moduleInitModulesSystemLast() local_unnamed_addr #22 {
entry:
  ret void
}

declare i64 @dictSdsCaseHash(ptr noundef) #1

declare i32 @dictSdsKeyCaseCompare(ptr noundef, ptr noundef, ptr noundef) #1

declare void @dictSdsDestructor(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleInitModulesSystem() local_unnamed_addr #0 {
entry:
  %call = tail call ptr @listCreate() #32
  store ptr %call, ptr @moduleUnblockedClients, align 8
  %call1 = tail call ptr @listCreate() #32
  store ptr %call1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 40), align 8
  %call2 = tail call ptr @dictCreate(ptr noundef nonnull @sdsKeyValueHashDictType) #32
  store ptr %call2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  %call3 = tail call ptr @dictCreate(ptr noundef nonnull @modulesDictType) #32
  store ptr %call3, ptr @modules, align 8
  %call4 = tail call ptr @listCreate() #32
  store ptr %call4, ptr @moduleAuthCallbacks, align 8
  %call5 = tail call ptr @listCreate() #32
  store ptr %call5, ptr @moduleKeyspaceSubscribers, align 8
  %call6 = tail call ptr @listCreate() #32
  store ptr %call6, ptr @modulePostExecUnitJobs, align 8
  %call7 = tail call ptr @listCreate() #32
  store ptr %call7, ptr @moduleCommandFilters, align 8
  tail call void @moduleRegisterCoreAPI()
  %call8 = tail call i32 @anetPipe(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 41), i32 noundef 526336, i32 noundef 526336) #32
  %cmp = icmp eq i32 %call8, -1
  br i1 %cmp, label %do.body, label %if.end13

do.body:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp9 = icmp sgt i32 %0, 3
  br i1 %cmp9, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %call11 = tail call ptr @__errno_location() #37
  %1 = load i32, ptr %call11, align 4
  %call12 = tail call ptr @strerror(i32 noundef %1) #32
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.103, ptr noundef %call12) #32
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end13:                                         ; preds = %entry
  %call14 = tail call ptr @raxNew() #32
  store ptr %call14, ptr @Timers, align 8
  %call15 = tail call ptr @listCreate() #32
  store ptr %call15, ptr @RedisModule_EventListeners, align 8
  %call16 = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleGIL) #32
  ret void
}

declare ptr @dictCreate(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleRegisterCoreAPI() local_unnamed_addr #0 {
entry:
  %call = tail call ptr @dictCreate(ptr noundef nonnull @moduleAPIDictType) #32
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call1 = tail call ptr @dictCreate(ptr noundef nonnull @moduleAPIDictType) #32
  store ptr %call1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 38), align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i = tail call i32 @dictAdd(ptr noundef %0, ptr noundef nonnull @.str.170, ptr noundef nonnull @RM_Alloc) #32
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i1 = tail call i32 @dictAdd(ptr noundef %1, ptr noundef nonnull @.str.171, ptr noundef nonnull @RM_TryAlloc) #32
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i2 = tail call i32 @dictAdd(ptr noundef %2, ptr noundef nonnull @.str.172, ptr noundef nonnull @RM_Calloc) #32
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i3 = tail call i32 @dictAdd(ptr noundef %3, ptr noundef nonnull @.str.173, ptr noundef nonnull @RM_Realloc) #32
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i4 = tail call i32 @dictAdd(ptr noundef %4, ptr noundef nonnull @.str.174, ptr noundef nonnull @RM_Free) #32
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i5 = tail call i32 @dictAdd(ptr noundef %5, ptr noundef nonnull @.str.175, ptr noundef nonnull @RM_Strdup) #32
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i6 = tail call i32 @dictAdd(ptr noundef %6, ptr noundef nonnull @.str.176, ptr noundef nonnull @RM_CreateCommand) #32
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i7 = tail call i32 @dictAdd(ptr noundef %7, ptr noundef nonnull @.str.177, ptr noundef nonnull @RM_GetCommand) #32
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i8 = tail call i32 @dictAdd(ptr noundef %8, ptr noundef nonnull @.str.178, ptr noundef nonnull @RM_CreateSubcommand) #32
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i9 = tail call i32 @dictAdd(ptr noundef %9, ptr noundef nonnull @.str.179, ptr noundef nonnull @RM_SetCommandInfo) #32
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i10 = tail call i32 @dictAdd(ptr noundef %10, ptr noundef nonnull @.str.180, ptr noundef nonnull @RM_SetCommandACLCategories) #32
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i11 = tail call i32 @dictAdd(ptr noundef %11, ptr noundef nonnull @.str.181, ptr noundef nonnull @RM_AddACLCategory) #32
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i12 = tail call i32 @dictAdd(ptr noundef %12, ptr noundef nonnull @.str.182, ptr noundef nonnull @RM_SetModuleAttribs) #32
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i13 = tail call i32 @dictAdd(ptr noundef %13, ptr noundef nonnull @.str.183, ptr noundef nonnull @RM_IsModuleNameBusy) #32
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i14 = tail call i32 @dictAdd(ptr noundef %14, ptr noundef nonnull @.str.184, ptr noundef nonnull @RM_WrongArity) #32
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i15 = tail call i32 @dictAdd(ptr noundef %15, ptr noundef nonnull @.str.185, ptr noundef nonnull @RM_ReplyWithLongLong) #32
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i16 = tail call i32 @dictAdd(ptr noundef %16, ptr noundef nonnull @.str.186, ptr noundef nonnull @RM_ReplyWithError) #32
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i17 = tail call i32 @dictAdd(ptr noundef %17, ptr noundef nonnull @.str.187, ptr noundef nonnull @RM_ReplyWithErrorFormat) #32
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i18 = tail call i32 @dictAdd(ptr noundef %18, ptr noundef nonnull @.str.188, ptr noundef nonnull @RM_ReplyWithSimpleString) #32
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i19 = tail call i32 @dictAdd(ptr noundef %19, ptr noundef nonnull @.str.189, ptr noundef nonnull @RM_ReplyWithArray) #32
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i20 = tail call i32 @dictAdd(ptr noundef %20, ptr noundef nonnull @.str.190, ptr noundef nonnull @RM_ReplyWithMap) #32
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i21 = tail call i32 @dictAdd(ptr noundef %21, ptr noundef nonnull @.str.191, ptr noundef nonnull @RM_ReplyWithSet) #32
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i22 = tail call i32 @dictAdd(ptr noundef %22, ptr noundef nonnull @.str.192, ptr noundef nonnull @RM_ReplyWithAttribute) #32
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i23 = tail call i32 @dictAdd(ptr noundef %23, ptr noundef nonnull @.str.193, ptr noundef nonnull @RM_ReplyWithNullArray) #32
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i24 = tail call i32 @dictAdd(ptr noundef %24, ptr noundef nonnull @.str.194, ptr noundef nonnull @RM_ReplyWithEmptyArray) #32
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i25 = tail call i32 @dictAdd(ptr noundef %25, ptr noundef nonnull @.str.195, ptr noundef nonnull @RM_ReplySetArrayLength) #32
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i26 = tail call i32 @dictAdd(ptr noundef %26, ptr noundef nonnull @.str.196, ptr noundef nonnull @RM_ReplySetMapLength) #32
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i27 = tail call i32 @dictAdd(ptr noundef %27, ptr noundef nonnull @.str.197, ptr noundef nonnull @RM_ReplySetSetLength) #32
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i28 = tail call i32 @dictAdd(ptr noundef %28, ptr noundef nonnull @.str.198, ptr noundef nonnull @RM_ReplySetAttributeLength) #32
  %29 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i29 = tail call i32 @dictAdd(ptr noundef %29, ptr noundef nonnull @.str.199, ptr noundef nonnull @RM_ReplyWithString) #32
  %30 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i30 = tail call i32 @dictAdd(ptr noundef %30, ptr noundef nonnull @.str.200, ptr noundef nonnull @RM_ReplyWithEmptyString) #32
  %31 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i31 = tail call i32 @dictAdd(ptr noundef %31, ptr noundef nonnull @.str.201, ptr noundef nonnull @RM_ReplyWithVerbatimString) #32
  %32 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i32 = tail call i32 @dictAdd(ptr noundef %32, ptr noundef nonnull @.str.202, ptr noundef nonnull @RM_ReplyWithVerbatimStringType) #32
  %33 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i33 = tail call i32 @dictAdd(ptr noundef %33, ptr noundef nonnull @.str.203, ptr noundef nonnull @RM_ReplyWithStringBuffer) #32
  %34 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i34 = tail call i32 @dictAdd(ptr noundef %34, ptr noundef nonnull @.str.204, ptr noundef nonnull @RM_ReplyWithCString) #32
  %35 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i35 = tail call i32 @dictAdd(ptr noundef %35, ptr noundef nonnull @.str.205, ptr noundef nonnull @RM_ReplyWithNull) #32
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i36 = tail call i32 @dictAdd(ptr noundef %36, ptr noundef nonnull @.str.206, ptr noundef nonnull @RM_ReplyWithBool) #32
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i37 = tail call i32 @dictAdd(ptr noundef %37, ptr noundef nonnull @.str.207, ptr noundef nonnull @RM_ReplyWithCallReply) #32
  %38 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i38 = tail call i32 @dictAdd(ptr noundef %38, ptr noundef nonnull @.str.208, ptr noundef nonnull @RM_ReplyWithDouble) #32
  %39 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i39 = tail call i32 @dictAdd(ptr noundef %39, ptr noundef nonnull @.str.209, ptr noundef nonnull @RM_ReplyWithBigNumber) #32
  %40 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i40 = tail call i32 @dictAdd(ptr noundef %40, ptr noundef nonnull @.str.210, ptr noundef nonnull @RM_ReplyWithLongDouble) #32
  %41 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i41 = tail call i32 @dictAdd(ptr noundef %41, ptr noundef nonnull @.str.211, ptr noundef nonnull @RM_GetSelectedDb) #32
  %42 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i42 = tail call i32 @dictAdd(ptr noundef %42, ptr noundef nonnull @.str.212, ptr noundef nonnull @RM_SelectDb) #32
  %43 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i43 = tail call i32 @dictAdd(ptr noundef %43, ptr noundef nonnull @.str.213, ptr noundef nonnull @RM_KeyExists) #32
  %44 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i44 = tail call i32 @dictAdd(ptr noundef %44, ptr noundef nonnull @.str.214, ptr noundef nonnull @RM_OpenKey) #32
  %45 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i45 = tail call i32 @dictAdd(ptr noundef %45, ptr noundef nonnull @.str.215, ptr noundef nonnull @RM_GetOpenKeyModesAll) #32
  %46 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i46 = tail call i32 @dictAdd(ptr noundef %46, ptr noundef nonnull @.str.216, ptr noundef nonnull @RM_CloseKey) #32
  %47 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i47 = tail call i32 @dictAdd(ptr noundef %47, ptr noundef nonnull @.str.217, ptr noundef nonnull @RM_KeyType) #32
  %48 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i48 = tail call i32 @dictAdd(ptr noundef %48, ptr noundef nonnull @.str.218, ptr noundef nonnull @RM_ValueLength) #32
  %49 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i49 = tail call i32 @dictAdd(ptr noundef %49, ptr noundef nonnull @.str.219, ptr noundef nonnull @RM_ListPush) #32
  %50 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i50 = tail call i32 @dictAdd(ptr noundef %50, ptr noundef nonnull @.str.220, ptr noundef nonnull @RM_ListPop) #32
  %51 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i51 = tail call i32 @dictAdd(ptr noundef %51, ptr noundef nonnull @.str.221, ptr noundef nonnull @RM_ListGet) #32
  %52 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i52 = tail call i32 @dictAdd(ptr noundef %52, ptr noundef nonnull @.str.222, ptr noundef nonnull @RM_ListSet) #32
  %53 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i53 = tail call i32 @dictAdd(ptr noundef %53, ptr noundef nonnull @.str.223, ptr noundef nonnull @RM_ListInsert) #32
  %54 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i54 = tail call i32 @dictAdd(ptr noundef %54, ptr noundef nonnull @.str.224, ptr noundef nonnull @RM_ListDelete) #32
  %55 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i55 = tail call i32 @dictAdd(ptr noundef %55, ptr noundef nonnull @.str.225, ptr noundef nonnull @RM_StringToLongLong) #32
  %56 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i56 = tail call i32 @dictAdd(ptr noundef %56, ptr noundef nonnull @.str.226, ptr noundef nonnull @RM_StringToULongLong) #32
  %57 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i57 = tail call i32 @dictAdd(ptr noundef %57, ptr noundef nonnull @.str.227, ptr noundef nonnull @RM_StringToDouble) #32
  %58 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i58 = tail call i32 @dictAdd(ptr noundef %58, ptr noundef nonnull @.str.228, ptr noundef nonnull @RM_StringToLongDouble) #32
  %59 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i59 = tail call i32 @dictAdd(ptr noundef %59, ptr noundef nonnull @.str.229, ptr noundef nonnull @RM_StringToStreamID) #32
  %60 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i60 = tail call i32 @dictAdd(ptr noundef %60, ptr noundef nonnull @.str.230, ptr noundef nonnull @RM_Call) #32
  %61 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i61 = tail call i32 @dictAdd(ptr noundef %61, ptr noundef nonnull @.str.231, ptr noundef nonnull @RM_CallReplyProto) #32
  %62 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i62 = tail call i32 @dictAdd(ptr noundef %62, ptr noundef nonnull @.str.232, ptr noundef nonnull @RM_FreeCallReply) #32
  %63 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i63 = tail call i32 @dictAdd(ptr noundef %63, ptr noundef nonnull @.str.233, ptr noundef nonnull @RM_CallReplyInteger) #32
  %64 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i64 = tail call i32 @dictAdd(ptr noundef %64, ptr noundef nonnull @.str.234, ptr noundef nonnull @RM_CallReplyDouble) #32
  %65 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i65 = tail call i32 @dictAdd(ptr noundef %65, ptr noundef nonnull @.str.235, ptr noundef nonnull @RM_CallReplyBigNumber) #32
  %66 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i66 = tail call i32 @dictAdd(ptr noundef %66, ptr noundef nonnull @.str.236, ptr noundef nonnull @RM_CallReplyVerbatim) #32
  %67 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i67 = tail call i32 @dictAdd(ptr noundef %67, ptr noundef nonnull @.str.237, ptr noundef nonnull @RM_CallReplyBool) #32
  %68 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i68 = tail call i32 @dictAdd(ptr noundef %68, ptr noundef nonnull @.str.238, ptr noundef nonnull @RM_CallReplySetElement) #32
  %69 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i69 = tail call i32 @dictAdd(ptr noundef %69, ptr noundef nonnull @.str.239, ptr noundef nonnull @RM_CallReplyMapElement) #32
  %70 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i70 = tail call i32 @dictAdd(ptr noundef %70, ptr noundef nonnull @.str.240, ptr noundef nonnull @RM_CallReplyAttributeElement) #32
  %71 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i71 = tail call i32 @dictAdd(ptr noundef %71, ptr noundef nonnull @.str.241, ptr noundef nonnull @RM_CallReplyPromiseSetUnblockHandler) #32
  %72 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i72 = tail call i32 @dictAdd(ptr noundef %72, ptr noundef nonnull @.str.242, ptr noundef nonnull @RM_CallReplyPromiseAbort) #32
  %73 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i73 = tail call i32 @dictAdd(ptr noundef %73, ptr noundef nonnull @.str.243, ptr noundef nonnull @RM_CallReplyAttribute) #32
  %74 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i74 = tail call i32 @dictAdd(ptr noundef %74, ptr noundef nonnull @.str.244, ptr noundef nonnull @RM_CallReplyType) #32
  %75 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i75 = tail call i32 @dictAdd(ptr noundef %75, ptr noundef nonnull @.str.245, ptr noundef nonnull @RM_CallReplyLength) #32
  %76 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i76 = tail call i32 @dictAdd(ptr noundef %76, ptr noundef nonnull @.str.246, ptr noundef nonnull @RM_CallReplyArrayElement) #32
  %77 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i77 = tail call i32 @dictAdd(ptr noundef %77, ptr noundef nonnull @.str.247, ptr noundef nonnull @RM_CallReplyStringPtr) #32
  %78 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i78 = tail call i32 @dictAdd(ptr noundef %78, ptr noundef nonnull @.str.248, ptr noundef nonnull @RM_CreateStringFromCallReply) #32
  %79 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i79 = tail call i32 @dictAdd(ptr noundef %79, ptr noundef nonnull @.str.249, ptr noundef nonnull @RM_CreateString) #32
  %80 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i80 = tail call i32 @dictAdd(ptr noundef %80, ptr noundef nonnull @.str.250, ptr noundef nonnull @RM_CreateStringFromLongLong) #32
  %81 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i81 = tail call i32 @dictAdd(ptr noundef %81, ptr noundef nonnull @.str.251, ptr noundef nonnull @RM_CreateStringFromULongLong) #32
  %82 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i82 = tail call i32 @dictAdd(ptr noundef %82, ptr noundef nonnull @.str.252, ptr noundef nonnull @RM_CreateStringFromDouble) #32
  %83 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i83 = tail call i32 @dictAdd(ptr noundef %83, ptr noundef nonnull @.str.253, ptr noundef nonnull @RM_CreateStringFromLongDouble) #32
  %84 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i84 = tail call i32 @dictAdd(ptr noundef %84, ptr noundef nonnull @.str.254, ptr noundef nonnull @RM_CreateStringFromString) #32
  %85 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i85 = tail call i32 @dictAdd(ptr noundef %85, ptr noundef nonnull @.str.255, ptr noundef nonnull @RM_CreateStringFromStreamID) #32
  %86 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i86 = tail call i32 @dictAdd(ptr noundef %86, ptr noundef nonnull @.str.256, ptr noundef nonnull @RM_CreateStringPrintf) #32
  %87 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i87 = tail call i32 @dictAdd(ptr noundef %87, ptr noundef nonnull @.str.257, ptr noundef nonnull @RM_FreeString) #32
  %88 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i88 = tail call i32 @dictAdd(ptr noundef %88, ptr noundef nonnull @.str.258, ptr noundef nonnull @RM_StringPtrLen) #32
  %89 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i89 = tail call i32 @dictAdd(ptr noundef %89, ptr noundef nonnull @.str.259, ptr noundef nonnull @RM_AutoMemory) #32
  %90 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i90 = tail call i32 @dictAdd(ptr noundef %90, ptr noundef nonnull @.str.260, ptr noundef nonnull @RM_Replicate) #32
  %91 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i91 = tail call i32 @dictAdd(ptr noundef %91, ptr noundef nonnull @.str.261, ptr noundef nonnull @RM_ReplicateVerbatim) #32
  %92 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i92 = tail call i32 @dictAdd(ptr noundef %92, ptr noundef nonnull @.str.262, ptr noundef nonnull @RM_DeleteKey) #32
  %93 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i93 = tail call i32 @dictAdd(ptr noundef %93, ptr noundef nonnull @.str.263, ptr noundef nonnull @RM_UnlinkKey) #32
  %94 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i94 = tail call i32 @dictAdd(ptr noundef %94, ptr noundef nonnull @.str.264, ptr noundef nonnull @RM_StringSet) #32
  %95 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i95 = tail call i32 @dictAdd(ptr noundef %95, ptr noundef nonnull @.str.265, ptr noundef nonnull @RM_StringDMA) #32
  %96 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i96 = tail call i32 @dictAdd(ptr noundef %96, ptr noundef nonnull @.str.266, ptr noundef nonnull @RM_StringTruncate) #32
  %97 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i97 = tail call i32 @dictAdd(ptr noundef %97, ptr noundef nonnull @.str.267, ptr noundef nonnull @RM_SetExpire) #32
  %98 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i98 = tail call i32 @dictAdd(ptr noundef %98, ptr noundef nonnull @.str.268, ptr noundef nonnull @RM_GetExpire) #32
  %99 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i99 = tail call i32 @dictAdd(ptr noundef %99, ptr noundef nonnull @.str.269, ptr noundef nonnull @RM_SetAbsExpire) #32
  %100 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i100 = tail call i32 @dictAdd(ptr noundef %100, ptr noundef nonnull @.str.270, ptr noundef nonnull @RM_GetAbsExpire) #32
  %101 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i101 = tail call i32 @dictAdd(ptr noundef %101, ptr noundef nonnull @.str.271, ptr noundef nonnull @RM_ResetDataset) #32
  %102 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i102 = tail call i32 @dictAdd(ptr noundef %102, ptr noundef nonnull @.str.272, ptr noundef nonnull @RM_DbSize) #32
  %103 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i103 = tail call i32 @dictAdd(ptr noundef %103, ptr noundef nonnull @.str.273, ptr noundef nonnull @RM_RandomKey) #32
  %104 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i104 = tail call i32 @dictAdd(ptr noundef %104, ptr noundef nonnull @.str.274, ptr noundef nonnull @RM_ZsetAdd) #32
  %105 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i105 = tail call i32 @dictAdd(ptr noundef %105, ptr noundef nonnull @.str.275, ptr noundef nonnull @RM_ZsetIncrby) #32
  %106 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i106 = tail call i32 @dictAdd(ptr noundef %106, ptr noundef nonnull @.str.276, ptr noundef nonnull @RM_ZsetScore) #32
  %107 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i107 = tail call i32 @dictAdd(ptr noundef %107, ptr noundef nonnull @.str.277, ptr noundef nonnull @RM_ZsetRem) #32
  %108 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i108 = tail call i32 @dictAdd(ptr noundef %108, ptr noundef nonnull @.str.278, ptr noundef nonnull @RM_ZsetRangeStop) #32
  %109 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i109 = tail call i32 @dictAdd(ptr noundef %109, ptr noundef nonnull @.str.279, ptr noundef nonnull @RM_ZsetFirstInScoreRange) #32
  %110 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i110 = tail call i32 @dictAdd(ptr noundef %110, ptr noundef nonnull @.str.280, ptr noundef nonnull @RM_ZsetLastInScoreRange) #32
  %111 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i111 = tail call i32 @dictAdd(ptr noundef %111, ptr noundef nonnull @.str.281, ptr noundef nonnull @RM_ZsetFirstInLexRange) #32
  %112 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i112 = tail call i32 @dictAdd(ptr noundef %112, ptr noundef nonnull @.str.282, ptr noundef nonnull @RM_ZsetLastInLexRange) #32
  %113 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i113 = tail call i32 @dictAdd(ptr noundef %113, ptr noundef nonnull @.str.283, ptr noundef nonnull @RM_ZsetRangeCurrentElement) #32
  %114 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i114 = tail call i32 @dictAdd(ptr noundef %114, ptr noundef nonnull @.str.284, ptr noundef nonnull @RM_ZsetRangeNext) #32
  %115 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i115 = tail call i32 @dictAdd(ptr noundef %115, ptr noundef nonnull @.str.285, ptr noundef nonnull @RM_ZsetRangePrev) #32
  %116 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i116 = tail call i32 @dictAdd(ptr noundef %116, ptr noundef nonnull @.str.286, ptr noundef nonnull @RM_ZsetRangeEndReached) #32
  %117 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i117 = tail call i32 @dictAdd(ptr noundef %117, ptr noundef nonnull @.str.287, ptr noundef nonnull @RM_HashSet) #32
  %118 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i118 = tail call i32 @dictAdd(ptr noundef %118, ptr noundef nonnull @.str.288, ptr noundef nonnull @RM_HashGet) #32
  %119 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i119 = tail call i32 @dictAdd(ptr noundef %119, ptr noundef nonnull @.str.289, ptr noundef nonnull @RM_StreamAdd) #32
  %120 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i120 = tail call i32 @dictAdd(ptr noundef %120, ptr noundef nonnull @.str.290, ptr noundef nonnull @RM_StreamDelete) #32
  %121 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i121 = tail call i32 @dictAdd(ptr noundef %121, ptr noundef nonnull @.str.291, ptr noundef nonnull @RM_StreamIteratorStart) #32
  %122 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i122 = tail call i32 @dictAdd(ptr noundef %122, ptr noundef nonnull @.str.292, ptr noundef nonnull @RM_StreamIteratorStop) #32
  %123 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i123 = tail call i32 @dictAdd(ptr noundef %123, ptr noundef nonnull @.str.293, ptr noundef nonnull @RM_StreamIteratorNextID) #32
  %124 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i124 = tail call i32 @dictAdd(ptr noundef %124, ptr noundef nonnull @.str.294, ptr noundef nonnull @RM_StreamIteratorNextField) #32
  %125 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i125 = tail call i32 @dictAdd(ptr noundef %125, ptr noundef nonnull @.str.295, ptr noundef nonnull @RM_StreamIteratorDelete) #32
  %126 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i126 = tail call i32 @dictAdd(ptr noundef %126, ptr noundef nonnull @.str.296, ptr noundef nonnull @RM_StreamTrimByLength) #32
  %127 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i127 = tail call i32 @dictAdd(ptr noundef %127, ptr noundef nonnull @.str.297, ptr noundef nonnull @RM_StreamTrimByID) #32
  %128 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i128 = tail call i32 @dictAdd(ptr noundef %128, ptr noundef nonnull @.str.298, ptr noundef nonnull @RM_IsKeysPositionRequest) #32
  %129 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i129 = tail call i32 @dictAdd(ptr noundef %129, ptr noundef nonnull @.str.299, ptr noundef nonnull @RM_KeyAtPos) #32
  %130 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i130 = tail call i32 @dictAdd(ptr noundef %130, ptr noundef nonnull @.str.300, ptr noundef nonnull @RM_KeyAtPosWithFlags) #32
  %131 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i131 = tail call i32 @dictAdd(ptr noundef %131, ptr noundef nonnull @.str.301, ptr noundef nonnull @RM_IsChannelsPositionRequest) #32
  %132 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i132 = tail call i32 @dictAdd(ptr noundef %132, ptr noundef nonnull @.str.302, ptr noundef nonnull @RM_ChannelAtPosWithFlags) #32
  %133 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i133 = tail call i32 @dictAdd(ptr noundef %133, ptr noundef nonnull @.str.303, ptr noundef nonnull @RM_GetClientId) #32
  %134 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i134 = tail call i32 @dictAdd(ptr noundef %134, ptr noundef nonnull @.str.304, ptr noundef nonnull @RM_GetClientUserNameById) #32
  %135 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i135 = tail call i32 @dictAdd(ptr noundef %135, ptr noundef nonnull @.str.305, ptr noundef nonnull @RM_GetContextFlags) #32
  %136 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i136 = tail call i32 @dictAdd(ptr noundef %136, ptr noundef nonnull @.str.306, ptr noundef nonnull @RM_AvoidReplicaTraffic) #32
  %137 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i137 = tail call i32 @dictAdd(ptr noundef %137, ptr noundef nonnull @.str.307, ptr noundef nonnull @RM_PoolAlloc) #32
  %138 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i138 = tail call i32 @dictAdd(ptr noundef %138, ptr noundef nonnull @.str.308, ptr noundef nonnull @RM_CreateDataType) #32
  %139 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i139 = tail call i32 @dictAdd(ptr noundef %139, ptr noundef nonnull @.str.309, ptr noundef nonnull @RM_ModuleTypeSetValue) #32
  %140 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i140 = tail call i32 @dictAdd(ptr noundef %140, ptr noundef nonnull @.str.310, ptr noundef nonnull @RM_ModuleTypeReplaceValue) #32
  %141 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i141 = tail call i32 @dictAdd(ptr noundef %141, ptr noundef nonnull @.str.311, ptr noundef nonnull @RM_ModuleTypeGetType) #32
  %142 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i142 = tail call i32 @dictAdd(ptr noundef %142, ptr noundef nonnull @.str.312, ptr noundef nonnull @RM_ModuleTypeGetValue) #32
  %143 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i143 = tail call i32 @dictAdd(ptr noundef %143, ptr noundef nonnull @.str.313, ptr noundef nonnull @RM_IsIOError) #32
  %144 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i144 = tail call i32 @dictAdd(ptr noundef %144, ptr noundef nonnull @.str.314, ptr noundef nonnull @RM_SetModuleOptions) #32
  %145 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i145 = tail call i32 @dictAdd(ptr noundef %145, ptr noundef nonnull @.str.315, ptr noundef nonnull @RM_SignalModifiedKey) #32
  %146 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i146 = tail call i32 @dictAdd(ptr noundef %146, ptr noundef nonnull @.str.316, ptr noundef nonnull @RM_SaveUnsigned) #32
  %147 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i147 = tail call i32 @dictAdd(ptr noundef %147, ptr noundef nonnull @.str.317, ptr noundef nonnull @RM_LoadUnsigned) #32
  %148 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i148 = tail call i32 @dictAdd(ptr noundef %148, ptr noundef nonnull @.str.318, ptr noundef nonnull @RM_SaveSigned) #32
  %149 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i149 = tail call i32 @dictAdd(ptr noundef %149, ptr noundef nonnull @.str.319, ptr noundef nonnull @RM_LoadSigned) #32
  %150 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i150 = tail call i32 @dictAdd(ptr noundef %150, ptr noundef nonnull @.str.320, ptr noundef nonnull @RM_SaveString) #32
  %151 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i151 = tail call i32 @dictAdd(ptr noundef %151, ptr noundef nonnull @.str.321, ptr noundef nonnull @RM_SaveStringBuffer) #32
  %152 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i152 = tail call i32 @dictAdd(ptr noundef %152, ptr noundef nonnull @.str.322, ptr noundef nonnull @RM_LoadString) #32
  %153 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i153 = tail call i32 @dictAdd(ptr noundef %153, ptr noundef nonnull @.str.323, ptr noundef nonnull @RM_LoadStringBuffer) #32
  %154 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i154 = tail call i32 @dictAdd(ptr noundef %154, ptr noundef nonnull @.str.324, ptr noundef nonnull @RM_SaveDouble) #32
  %155 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i155 = tail call i32 @dictAdd(ptr noundef %155, ptr noundef nonnull @.str.325, ptr noundef nonnull @RM_LoadDouble) #32
  %156 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i156 = tail call i32 @dictAdd(ptr noundef %156, ptr noundef nonnull @.str.326, ptr noundef nonnull @RM_SaveFloat) #32
  %157 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i157 = tail call i32 @dictAdd(ptr noundef %157, ptr noundef nonnull @.str.327, ptr noundef nonnull @RM_LoadFloat) #32
  %158 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i158 = tail call i32 @dictAdd(ptr noundef %158, ptr noundef nonnull @.str.328, ptr noundef nonnull @RM_SaveLongDouble) #32
  %159 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i159 = tail call i32 @dictAdd(ptr noundef %159, ptr noundef nonnull @.str.329, ptr noundef nonnull @RM_LoadLongDouble) #32
  %160 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i160 = tail call i32 @dictAdd(ptr noundef %160, ptr noundef nonnull @.str.330, ptr noundef nonnull @RM_SaveDataTypeToString) #32
  %161 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i161 = tail call i32 @dictAdd(ptr noundef %161, ptr noundef nonnull @.str.331, ptr noundef nonnull @RM_LoadDataTypeFromString) #32
  %162 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i162 = tail call i32 @dictAdd(ptr noundef %162, ptr noundef nonnull @.str.332, ptr noundef nonnull @RM_LoadDataTypeFromStringEncver) #32
  %163 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i163 = tail call i32 @dictAdd(ptr noundef %163, ptr noundef nonnull @.str.333, ptr noundef nonnull @RM_EmitAOF) #32
  %164 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i164 = tail call i32 @dictAdd(ptr noundef %164, ptr noundef nonnull @.str.334, ptr noundef nonnull @RM_Log) #32
  %165 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i165 = tail call i32 @dictAdd(ptr noundef %165, ptr noundef nonnull @.str.335, ptr noundef nonnull @RM_LogIOError) #32
  %166 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i166 = tail call i32 @dictAdd(ptr noundef %166, ptr noundef nonnull @.str.336, ptr noundef nonnull @RM__Assert) #32
  %167 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i167 = tail call i32 @dictAdd(ptr noundef %167, ptr noundef nonnull @.str.337, ptr noundef nonnull @RM_LatencyAddSample) #32
  %168 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i168 = tail call i32 @dictAdd(ptr noundef %168, ptr noundef nonnull @.str.338, ptr noundef nonnull @RM_StringAppendBuffer) #32
  %169 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i169 = tail call i32 @dictAdd(ptr noundef %169, ptr noundef nonnull @.str.339, ptr noundef nonnull @RM_TrimStringAllocation) #32
  %170 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i170 = tail call i32 @dictAdd(ptr noundef %170, ptr noundef nonnull @.str.340, ptr noundef nonnull @RM_RetainString) #32
  %171 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i171 = tail call i32 @dictAdd(ptr noundef %171, ptr noundef nonnull @.str.341, ptr noundef nonnull @RM_HoldString) #32
  %172 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i172 = tail call i32 @dictAdd(ptr noundef %172, ptr noundef nonnull @.str.342, ptr noundef nonnull @RM_StringCompare) #32
  %173 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i173 = tail call i32 @dictAdd(ptr noundef %173, ptr noundef nonnull @.str.343, ptr noundef nonnull @RM_GetContextFromIO) #32
  %174 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i174 = tail call i32 @dictAdd(ptr noundef %174, ptr noundef nonnull @.str.344, ptr noundef nonnull @RM_GetKeyNameFromIO) #32
  %175 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i175 = tail call i32 @dictAdd(ptr noundef %175, ptr noundef nonnull @.str.345, ptr noundef nonnull @RM_GetKeyNameFromModuleKey) #32
  %176 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i176 = tail call i32 @dictAdd(ptr noundef %176, ptr noundef nonnull @.str.346, ptr noundef nonnull @RM_GetDbIdFromModuleKey) #32
  %177 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i177 = tail call i32 @dictAdd(ptr noundef %177, ptr noundef nonnull @.str.347, ptr noundef nonnull @RM_GetDbIdFromIO) #32
  %178 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i178 = tail call i32 @dictAdd(ptr noundef %178, ptr noundef nonnull @.str.348, ptr noundef nonnull @RM_GetKeyNameFromOptCtx) #32
  %179 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i179 = tail call i32 @dictAdd(ptr noundef %179, ptr noundef nonnull @.str.349, ptr noundef nonnull @RM_GetToKeyNameFromOptCtx) #32
  %180 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i180 = tail call i32 @dictAdd(ptr noundef %180, ptr noundef nonnull @.str.350, ptr noundef nonnull @RM_GetDbIdFromOptCtx) #32
  %181 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i181 = tail call i32 @dictAdd(ptr noundef %181, ptr noundef nonnull @.str.351, ptr noundef nonnull @RM_GetToDbIdFromOptCtx) #32
  %182 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i182 = tail call i32 @dictAdd(ptr noundef %182, ptr noundef nonnull @.str.352, ptr noundef nonnull @RM_GetKeyNameFromDefragCtx) #32
  %183 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i183 = tail call i32 @dictAdd(ptr noundef %183, ptr noundef nonnull @.str.353, ptr noundef nonnull @RM_GetDbIdFromDefragCtx) #32
  %184 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i184 = tail call i32 @dictAdd(ptr noundef %184, ptr noundef nonnull @.str.354, ptr noundef nonnull @RM_GetKeyNameFromDigest) #32
  %185 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i185 = tail call i32 @dictAdd(ptr noundef %185, ptr noundef nonnull @.str.355, ptr noundef nonnull @RM_GetDbIdFromDigest) #32
  %186 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i186 = tail call i32 @dictAdd(ptr noundef %186, ptr noundef nonnull @.str.356, ptr noundef nonnull @RM_BlockClient) #32
  %187 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i187 = tail call i32 @dictAdd(ptr noundef %187, ptr noundef nonnull @.str.357, ptr noundef nonnull @RM_BlockClientGetPrivateData) #32
  %188 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i188 = tail call i32 @dictAdd(ptr noundef %188, ptr noundef nonnull @.str.358, ptr noundef nonnull @RM_BlockClientSetPrivateData) #32
  %189 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i189 = tail call i32 @dictAdd(ptr noundef %189, ptr noundef nonnull @.str.359, ptr noundef nonnull @RM_BlockClientOnAuth) #32
  %190 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i190 = tail call i32 @dictAdd(ptr noundef %190, ptr noundef nonnull @.str.360, ptr noundef nonnull @RM_UnblockClient) #32
  %191 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i191 = tail call i32 @dictAdd(ptr noundef %191, ptr noundef nonnull @.str.361, ptr noundef nonnull @RM_IsBlockedReplyRequest) #32
  %192 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i192 = tail call i32 @dictAdd(ptr noundef %192, ptr noundef nonnull @.str.362, ptr noundef nonnull @RM_IsBlockedTimeoutRequest) #32
  %193 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i193 = tail call i32 @dictAdd(ptr noundef %193, ptr noundef nonnull @.str.363, ptr noundef nonnull @RM_GetBlockedClientPrivateData) #32
  %194 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i194 = tail call i32 @dictAdd(ptr noundef %194, ptr noundef nonnull @.str.364, ptr noundef nonnull @RM_AbortBlock) #32
  %195 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i195 = tail call i32 @dictAdd(ptr noundef %195, ptr noundef nonnull @.str.365, ptr noundef nonnull @RM_Milliseconds) #32
  %196 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i196 = tail call i32 @dictAdd(ptr noundef %196, ptr noundef nonnull @.str.366, ptr noundef nonnull @RM_MonotonicMicroseconds) #32
  %197 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i197 = tail call i32 @dictAdd(ptr noundef %197, ptr noundef nonnull @.str.367, ptr noundef nonnull @RM_Microseconds) #32
  %198 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i198 = tail call i32 @dictAdd(ptr noundef %198, ptr noundef nonnull @.str.368, ptr noundef nonnull @RM_CachedMicroseconds) #32
  %199 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i199 = tail call i32 @dictAdd(ptr noundef %199, ptr noundef nonnull @.str.369, ptr noundef nonnull @RM_BlockedClientMeasureTimeStart) #32
  %200 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i200 = tail call i32 @dictAdd(ptr noundef %200, ptr noundef nonnull @.str.370, ptr noundef nonnull @RM_BlockedClientMeasureTimeEnd) #32
  %201 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i201 = tail call i32 @dictAdd(ptr noundef %201, ptr noundef nonnull @.str.371, ptr noundef nonnull @RM_GetThreadSafeContext) #32
  %202 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i202 = tail call i32 @dictAdd(ptr noundef %202, ptr noundef nonnull @.str.372, ptr noundef nonnull @RM_GetDetachedThreadSafeContext) #32
  %203 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i203 = tail call i32 @dictAdd(ptr noundef %203, ptr noundef nonnull @.str.373, ptr noundef nonnull @RM_FreeThreadSafeContext) #32
  %204 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i204 = tail call i32 @dictAdd(ptr noundef %204, ptr noundef nonnull @.str.374, ptr noundef nonnull @RM_ThreadSafeContextLock) #32
  %205 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i205 = tail call i32 @dictAdd(ptr noundef %205, ptr noundef nonnull @.str.375, ptr noundef nonnull @RM_ThreadSafeContextTryLock) #32
  %206 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i206 = tail call i32 @dictAdd(ptr noundef %206, ptr noundef nonnull @.str.376, ptr noundef nonnull @RM_ThreadSafeContextUnlock) #32
  %207 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i207 = tail call i32 @dictAdd(ptr noundef %207, ptr noundef nonnull @.str.377, ptr noundef nonnull @RM_DigestAddStringBuffer) #32
  %208 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i208 = tail call i32 @dictAdd(ptr noundef %208, ptr noundef nonnull @.str.378, ptr noundef nonnull @RM_DigestAddLongLong) #32
  %209 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i209 = tail call i32 @dictAdd(ptr noundef %209, ptr noundef nonnull @.str.379, ptr noundef nonnull @RM_DigestEndSequence) #32
  %210 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i210 = tail call i32 @dictAdd(ptr noundef %210, ptr noundef nonnull @.str.380, ptr noundef nonnull @RM_NotifyKeyspaceEvent) #32
  %211 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i211 = tail call i32 @dictAdd(ptr noundef %211, ptr noundef nonnull @.str.381, ptr noundef nonnull @RM_GetNotifyKeyspaceEvents) #32
  %212 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i212 = tail call i32 @dictAdd(ptr noundef %212, ptr noundef nonnull @.str.382, ptr noundef nonnull @RM_SubscribeToKeyspaceEvents) #32
  %213 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i213 = tail call i32 @dictAdd(ptr noundef %213, ptr noundef nonnull @.str.383, ptr noundef nonnull @RM_AddPostNotificationJob) #32
  %214 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i214 = tail call i32 @dictAdd(ptr noundef %214, ptr noundef nonnull @.str.384, ptr noundef nonnull @RM_RegisterClusterMessageReceiver) #32
  %215 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i215 = tail call i32 @dictAdd(ptr noundef %215, ptr noundef nonnull @.str.385, ptr noundef nonnull @RM_SendClusterMessage) #32
  %216 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i216 = tail call i32 @dictAdd(ptr noundef %216, ptr noundef nonnull @.str.386, ptr noundef nonnull @RM_GetClusterNodeInfo) #32
  %217 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i217 = tail call i32 @dictAdd(ptr noundef %217, ptr noundef nonnull @.str.387, ptr noundef nonnull @RM_GetClusterNodesList) #32
  %218 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i218 = tail call i32 @dictAdd(ptr noundef %218, ptr noundef nonnull @.str.388, ptr noundef nonnull @RM_FreeClusterNodesList) #32
  %219 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i219 = tail call i32 @dictAdd(ptr noundef %219, ptr noundef nonnull @.str.389, ptr noundef nonnull @RM_CreateTimer) #32
  %220 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i220 = tail call i32 @dictAdd(ptr noundef %220, ptr noundef nonnull @.str.390, ptr noundef nonnull @RM_StopTimer) #32
  %221 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i221 = tail call i32 @dictAdd(ptr noundef %221, ptr noundef nonnull @.str.391, ptr noundef nonnull @RM_GetTimerInfo) #32
  %222 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i222 = tail call i32 @dictAdd(ptr noundef %222, ptr noundef nonnull @.str.392, ptr noundef nonnull @RM_GetMyClusterID) #32
  %223 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i223 = tail call i32 @dictAdd(ptr noundef %223, ptr noundef nonnull @.str.393, ptr noundef nonnull @RM_GetClusterSize) #32
  %224 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i224 = tail call i32 @dictAdd(ptr noundef %224, ptr noundef nonnull @.str.394, ptr noundef nonnull @RM_GetRandomBytes) #32
  %225 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i225 = tail call i32 @dictAdd(ptr noundef %225, ptr noundef nonnull @.str.395, ptr noundef nonnull @RM_GetRandomHexChars) #32
  %226 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i226 = tail call i32 @dictAdd(ptr noundef %226, ptr noundef nonnull @.str.396, ptr noundef nonnull @RM_BlockedClientDisconnected) #32
  %227 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i227 = tail call i32 @dictAdd(ptr noundef %227, ptr noundef nonnull @.str.397, ptr noundef nonnull @RM_SetDisconnectCallback) #32
  %228 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i228 = tail call i32 @dictAdd(ptr noundef %228, ptr noundef nonnull @.str.398, ptr noundef nonnull @RM_GetBlockedClientHandle) #32
  %229 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i229 = tail call i32 @dictAdd(ptr noundef %229, ptr noundef nonnull @.str.399, ptr noundef nonnull @RM_SetClusterFlags) #32
  %230 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i230 = tail call i32 @dictAdd(ptr noundef %230, ptr noundef nonnull @.str.400, ptr noundef nonnull @RM_CreateDict) #32
  %231 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i231 = tail call i32 @dictAdd(ptr noundef %231, ptr noundef nonnull @.str.401, ptr noundef nonnull @RM_FreeDict) #32
  %232 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i232 = tail call i32 @dictAdd(ptr noundef %232, ptr noundef nonnull @.str.402, ptr noundef nonnull @RM_DictSize) #32
  %233 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i233 = tail call i32 @dictAdd(ptr noundef %233, ptr noundef nonnull @.str.403, ptr noundef nonnull @RM_DictSetC) #32
  %234 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i234 = tail call i32 @dictAdd(ptr noundef %234, ptr noundef nonnull @.str.404, ptr noundef nonnull @RM_DictReplaceC) #32
  %235 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i235 = tail call i32 @dictAdd(ptr noundef %235, ptr noundef nonnull @.str.405, ptr noundef nonnull @RM_DictSet) #32
  %236 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i236 = tail call i32 @dictAdd(ptr noundef %236, ptr noundef nonnull @.str.406, ptr noundef nonnull @RM_DictReplace) #32
  %237 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i237 = tail call i32 @dictAdd(ptr noundef %237, ptr noundef nonnull @.str.407, ptr noundef nonnull @RM_DictGetC) #32
  %238 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i238 = tail call i32 @dictAdd(ptr noundef %238, ptr noundef nonnull @.str.408, ptr noundef nonnull @RM_DictGet) #32
  %239 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i239 = tail call i32 @dictAdd(ptr noundef %239, ptr noundef nonnull @.str.409, ptr noundef nonnull @RM_DictDelC) #32
  %240 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i240 = tail call i32 @dictAdd(ptr noundef %240, ptr noundef nonnull @.str.410, ptr noundef nonnull @RM_DictDel) #32
  %241 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i241 = tail call i32 @dictAdd(ptr noundef %241, ptr noundef nonnull @.str.411, ptr noundef nonnull @RM_DictIteratorStartC) #32
  %242 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i242 = tail call i32 @dictAdd(ptr noundef %242, ptr noundef nonnull @.str.412, ptr noundef nonnull @RM_DictIteratorStart) #32
  %243 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i243 = tail call i32 @dictAdd(ptr noundef %243, ptr noundef nonnull @.str.413, ptr noundef nonnull @RM_DictIteratorStop) #32
  %244 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i244 = tail call i32 @dictAdd(ptr noundef %244, ptr noundef nonnull @.str.414, ptr noundef nonnull @RM_DictIteratorReseekC) #32
  %245 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i245 = tail call i32 @dictAdd(ptr noundef %245, ptr noundef nonnull @.str.415, ptr noundef nonnull @RM_DictIteratorReseek) #32
  %246 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i246 = tail call i32 @dictAdd(ptr noundef %246, ptr noundef nonnull @.str.416, ptr noundef nonnull @RM_DictNextC) #32
  %247 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i247 = tail call i32 @dictAdd(ptr noundef %247, ptr noundef nonnull @.str.417, ptr noundef nonnull @RM_DictPrevC) #32
  %248 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i248 = tail call i32 @dictAdd(ptr noundef %248, ptr noundef nonnull @.str.418, ptr noundef nonnull @RM_DictNext) #32
  %249 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i249 = tail call i32 @dictAdd(ptr noundef %249, ptr noundef nonnull @.str.419, ptr noundef nonnull @RM_DictPrev) #32
  %250 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i250 = tail call i32 @dictAdd(ptr noundef %250, ptr noundef nonnull @.str.420, ptr noundef nonnull @RM_DictCompareC) #32
  %251 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i251 = tail call i32 @dictAdd(ptr noundef %251, ptr noundef nonnull @.str.421, ptr noundef nonnull @RM_DictCompare) #32
  %252 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i252 = tail call i32 @dictAdd(ptr noundef %252, ptr noundef nonnull @.str.422, ptr noundef nonnull @RM_ExportSharedAPI) #32
  %253 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i253 = tail call i32 @dictAdd(ptr noundef %253, ptr noundef nonnull @.str.423, ptr noundef nonnull @RM_GetSharedAPI) #32
  %254 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i254 = tail call i32 @dictAdd(ptr noundef %254, ptr noundef nonnull @.str.424, ptr noundef nonnull @RM_RegisterCommandFilter) #32
  %255 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i255 = tail call i32 @dictAdd(ptr noundef %255, ptr noundef nonnull @.str.425, ptr noundef nonnull @RM_UnregisterCommandFilter) #32
  %256 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i256 = tail call i32 @dictAdd(ptr noundef %256, ptr noundef nonnull @.str.426, ptr noundef nonnull @RM_CommandFilterArgsCount) #32
  %257 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i257 = tail call i32 @dictAdd(ptr noundef %257, ptr noundef nonnull @.str.427, ptr noundef nonnull @RM_CommandFilterArgGet) #32
  %258 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i258 = tail call i32 @dictAdd(ptr noundef %258, ptr noundef nonnull @.str.428, ptr noundef nonnull @RM_CommandFilterArgInsert) #32
  %259 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i259 = tail call i32 @dictAdd(ptr noundef %259, ptr noundef nonnull @.str.429, ptr noundef nonnull @RM_CommandFilterArgReplace) #32
  %260 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i260 = tail call i32 @dictAdd(ptr noundef %260, ptr noundef nonnull @.str.430, ptr noundef nonnull @RM_CommandFilterArgDelete) #32
  %261 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i261 = tail call i32 @dictAdd(ptr noundef %261, ptr noundef nonnull @.str.431, ptr noundef nonnull @RM_CommandFilterGetClientId) #32
  %262 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i262 = tail call i32 @dictAdd(ptr noundef %262, ptr noundef nonnull @.str.432, ptr noundef nonnull @RM_Fork) #32
  %263 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i263 = tail call i32 @dictAdd(ptr noundef %263, ptr noundef nonnull @.str.433, ptr noundef nonnull @RM_SendChildHeartbeat) #32
  %264 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i264 = tail call i32 @dictAdd(ptr noundef %264, ptr noundef nonnull @.str.434, ptr noundef nonnull @RM_ExitFromChild) #32
  %265 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i265 = tail call i32 @dictAdd(ptr noundef %265, ptr noundef nonnull @.str.435, ptr noundef nonnull @RM_KillForkChild) #32
  %266 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i266 = tail call i32 @dictAdd(ptr noundef %266, ptr noundef nonnull @.str.436, ptr noundef nonnull @RM_RegisterInfoFunc) #32
  %267 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i267 = tail call i32 @dictAdd(ptr noundef %267, ptr noundef nonnull @.str.437, ptr noundef nonnull @RM_InfoAddSection) #32
  %268 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i268 = tail call i32 @dictAdd(ptr noundef %268, ptr noundef nonnull @.str.438, ptr noundef nonnull @RM_InfoBeginDictField) #32
  %269 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i269 = tail call i32 @dictAdd(ptr noundef %269, ptr noundef nonnull @.str.439, ptr noundef nonnull @RM_InfoEndDictField) #32
  %270 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i270 = tail call i32 @dictAdd(ptr noundef %270, ptr noundef nonnull @.str.440, ptr noundef nonnull @RM_InfoAddFieldString) #32
  %271 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i271 = tail call i32 @dictAdd(ptr noundef %271, ptr noundef nonnull @.str.441, ptr noundef nonnull @RM_InfoAddFieldCString) #32
  %272 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i272 = tail call i32 @dictAdd(ptr noundef %272, ptr noundef nonnull @.str.442, ptr noundef nonnull @RM_InfoAddFieldDouble) #32
  %273 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i273 = tail call i32 @dictAdd(ptr noundef %273, ptr noundef nonnull @.str.443, ptr noundef nonnull @RM_InfoAddFieldLongLong) #32
  %274 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i274 = tail call i32 @dictAdd(ptr noundef %274, ptr noundef nonnull @.str.444, ptr noundef nonnull @RM_InfoAddFieldULongLong) #32
  %275 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i275 = tail call i32 @dictAdd(ptr noundef %275, ptr noundef nonnull @.str.445, ptr noundef nonnull @RM_GetServerInfo) #32
  %276 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i276 = tail call i32 @dictAdd(ptr noundef %276, ptr noundef nonnull @.str.446, ptr noundef nonnull @RM_FreeServerInfo) #32
  %277 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i277 = tail call i32 @dictAdd(ptr noundef %277, ptr noundef nonnull @.str.447, ptr noundef nonnull @RM_ServerInfoGetField) #32
  %278 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i278 = tail call i32 @dictAdd(ptr noundef %278, ptr noundef nonnull @.str.448, ptr noundef nonnull @RM_ServerInfoGetFieldC) #32
  %279 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i279 = tail call i32 @dictAdd(ptr noundef %279, ptr noundef nonnull @.str.449, ptr noundef nonnull @RM_ServerInfoGetFieldSigned) #32
  %280 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i280 = tail call i32 @dictAdd(ptr noundef %280, ptr noundef nonnull @.str.450, ptr noundef nonnull @RM_ServerInfoGetFieldUnsigned) #32
  %281 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i281 = tail call i32 @dictAdd(ptr noundef %281, ptr noundef nonnull @.str.451, ptr noundef nonnull @RM_ServerInfoGetFieldDouble) #32
  %282 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i282 = tail call i32 @dictAdd(ptr noundef %282, ptr noundef nonnull @.str.452, ptr noundef nonnull @RM_GetClientInfoById) #32
  %283 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i283 = tail call i32 @dictAdd(ptr noundef %283, ptr noundef nonnull @.str.453, ptr noundef nonnull @RM_GetClientNameById) #32
  %284 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i284 = tail call i32 @dictAdd(ptr noundef %284, ptr noundef nonnull @.str.454, ptr noundef nonnull @RM_SetClientNameById) #32
  %285 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i285 = tail call i32 @dictAdd(ptr noundef %285, ptr noundef nonnull @.str.455, ptr noundef nonnull @RM_PublishMessage) #32
  %286 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i286 = tail call i32 @dictAdd(ptr noundef %286, ptr noundef nonnull @.str.456, ptr noundef nonnull @RM_PublishMessageShard) #32
  %287 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i287 = tail call i32 @dictAdd(ptr noundef %287, ptr noundef nonnull @.str.457, ptr noundef nonnull @RM_SubscribeToServerEvent) #32
  %288 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i288 = tail call i32 @dictAdd(ptr noundef %288, ptr noundef nonnull @.str.458, ptr noundef nonnull @RM_SetLRU) #32
  %289 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i289 = tail call i32 @dictAdd(ptr noundef %289, ptr noundef nonnull @.str.459, ptr noundef nonnull @RM_GetLRU) #32
  %290 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i290 = tail call i32 @dictAdd(ptr noundef %290, ptr noundef nonnull @.str.460, ptr noundef nonnull @RM_SetLFU) #32
  %291 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i291 = tail call i32 @dictAdd(ptr noundef %291, ptr noundef nonnull @.str.461, ptr noundef nonnull @RM_GetLFU) #32
  %292 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i292 = tail call i32 @dictAdd(ptr noundef %292, ptr noundef nonnull @.str.462, ptr noundef nonnull @RM_BlockClientOnKeys) #32
  %293 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i293 = tail call i32 @dictAdd(ptr noundef %293, ptr noundef nonnull @.str.463, ptr noundef nonnull @RM_BlockClientOnKeysWithFlags) #32
  %294 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i294 = tail call i32 @dictAdd(ptr noundef %294, ptr noundef nonnull @.str.464, ptr noundef nonnull @RM_SignalKeyAsReady) #32
  %295 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i295 = tail call i32 @dictAdd(ptr noundef %295, ptr noundef nonnull @.str.465, ptr noundef nonnull @RM_GetBlockedClientReadyKey) #32
  %296 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i296 = tail call i32 @dictAdd(ptr noundef %296, ptr noundef nonnull @.str.466, ptr noundef nonnull @RM_GetUsedMemoryRatio) #32
  %297 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i297 = tail call i32 @dictAdd(ptr noundef %297, ptr noundef nonnull @.str.467, ptr noundef nonnull @RM_MallocSize) #32
  %298 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i298 = tail call i32 @dictAdd(ptr noundef %298, ptr noundef nonnull @.str.468, ptr noundef nonnull @RM_MallocUsableSize) #32
  %299 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i299 = tail call i32 @dictAdd(ptr noundef %299, ptr noundef nonnull @.str.469, ptr noundef nonnull @RM_MallocSizeString) #32
  %300 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i300 = tail call i32 @dictAdd(ptr noundef %300, ptr noundef nonnull @.str.470, ptr noundef nonnull @RM_MallocSizeDict) #32
  %301 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i301 = tail call i32 @dictAdd(ptr noundef %301, ptr noundef nonnull @.str.471, ptr noundef nonnull @RM_ScanCursorCreate) #32
  %302 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i302 = tail call i32 @dictAdd(ptr noundef %302, ptr noundef nonnull @.str.472, ptr noundef nonnull @RM_ScanCursorDestroy) #32
  %303 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i303 = tail call i32 @dictAdd(ptr noundef %303, ptr noundef nonnull @.str.473, ptr noundef nonnull @RM_ScanCursorRestart) #32
  %304 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i304 = tail call i32 @dictAdd(ptr noundef %304, ptr noundef nonnull @.str.474, ptr noundef nonnull @RM_Scan) #32
  %305 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i305 = tail call i32 @dictAdd(ptr noundef %305, ptr noundef nonnull @.str.475, ptr noundef nonnull @RM_ScanKey) #32
  %306 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i306 = tail call i32 @dictAdd(ptr noundef %306, ptr noundef nonnull @.str.476, ptr noundef nonnull @RM_CreateModuleUser) #32
  %307 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i307 = tail call i32 @dictAdd(ptr noundef %307, ptr noundef nonnull @.str.477, ptr noundef nonnull @RM_SetContextUser) #32
  %308 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i308 = tail call i32 @dictAdd(ptr noundef %308, ptr noundef nonnull @.str.478, ptr noundef nonnull @RM_SetModuleUserACL) #32
  %309 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i309 = tail call i32 @dictAdd(ptr noundef %309, ptr noundef nonnull @.str.479, ptr noundef nonnull @RM_SetModuleUserACLString) #32
  %310 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i310 = tail call i32 @dictAdd(ptr noundef %310, ptr noundef nonnull @.str.480, ptr noundef nonnull @RM_GetModuleUserACLString) #32
  %311 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i311 = tail call i32 @dictAdd(ptr noundef %311, ptr noundef nonnull @.str.481, ptr noundef nonnull @RM_GetCurrentUserName) #32
  %312 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i312 = tail call i32 @dictAdd(ptr noundef %312, ptr noundef nonnull @.str.482, ptr noundef nonnull @RM_GetModuleUserFromUserName) #32
  %313 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i313 = tail call i32 @dictAdd(ptr noundef %313, ptr noundef nonnull @.str.483, ptr noundef nonnull @RM_ACLCheckCommandPermissions) #32
  %314 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i314 = tail call i32 @dictAdd(ptr noundef %314, ptr noundef nonnull @.str.484, ptr noundef nonnull @RM_ACLCheckKeyPermissions) #32
  %315 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i315 = tail call i32 @dictAdd(ptr noundef %315, ptr noundef nonnull @.str.485, ptr noundef nonnull @RM_ACLCheckChannelPermissions) #32
  %316 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i316 = tail call i32 @dictAdd(ptr noundef %316, ptr noundef nonnull @.str.486, ptr noundef nonnull @RM_ACLAddLogEntry) #32
  %317 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i317 = tail call i32 @dictAdd(ptr noundef %317, ptr noundef nonnull @.str.487, ptr noundef nonnull @RM_ACLAddLogEntryByUserName) #32
  %318 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i318 = tail call i32 @dictAdd(ptr noundef %318, ptr noundef nonnull @.str.488, ptr noundef nonnull @RM_FreeModuleUser) #32
  %319 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i319 = tail call i32 @dictAdd(ptr noundef %319, ptr noundef nonnull @.str.489, ptr noundef nonnull @RM_DeauthenticateAndCloseClient) #32
  %320 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i320 = tail call i32 @dictAdd(ptr noundef %320, ptr noundef nonnull @.str.490, ptr noundef nonnull @RM_AuthenticateClientWithACLUser) #32
  %321 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i321 = tail call i32 @dictAdd(ptr noundef %321, ptr noundef nonnull @.str.491, ptr noundef nonnull @RM_AuthenticateClientWithUser) #32
  %322 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i322 = tail call i32 @dictAdd(ptr noundef %322, ptr noundef nonnull @.str.492, ptr noundef nonnull @RM_GetContextFlagsAll) #32
  %323 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i323 = tail call i32 @dictAdd(ptr noundef %323, ptr noundef nonnull @.str.493, ptr noundef nonnull @RM_GetModuleOptionsAll) #32
  %324 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i324 = tail call i32 @dictAdd(ptr noundef %324, ptr noundef nonnull @.str.494, ptr noundef nonnull @RM_GetKeyspaceNotificationFlagsAll) #32
  %325 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i325 = tail call i32 @dictAdd(ptr noundef %325, ptr noundef nonnull @.str.495, ptr noundef nonnull @RM_IsSubEventSupported) #32
  %326 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i326 = tail call i32 @dictAdd(ptr noundef %326, ptr noundef nonnull @.str.496, ptr noundef nonnull @RM_GetServerVersion) #32
  %327 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i327 = tail call i32 @dictAdd(ptr noundef %327, ptr noundef nonnull @.str.497, ptr noundef nonnull @RM_GetClientCertificate) #32
  %328 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i328 = tail call i32 @dictAdd(ptr noundef %328, ptr noundef nonnull @.str.498, ptr noundef nonnull @RM_RedactClientCommandArgument) #32
  %329 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i329 = tail call i32 @dictAdd(ptr noundef %329, ptr noundef nonnull @.str.499, ptr noundef nonnull @RM_GetCommandKeys) #32
  %330 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i330 = tail call i32 @dictAdd(ptr noundef %330, ptr noundef nonnull @.str.500, ptr noundef nonnull @RM_GetCommandKeysWithFlags) #32
  %331 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i331 = tail call i32 @dictAdd(ptr noundef %331, ptr noundef nonnull @.str.501, ptr noundef nonnull @RM_GetCurrentCommandName) #32
  %332 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i332 = tail call i32 @dictAdd(ptr noundef %332, ptr noundef nonnull @.str.502, ptr noundef nonnull @RM_GetTypeMethodVersion) #32
  %333 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i333 = tail call i32 @dictAdd(ptr noundef %333, ptr noundef nonnull @.str.503, ptr noundef nonnull @RM_RegisterDefragFunc) #32
  %334 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i334 = tail call i32 @dictAdd(ptr noundef %334, ptr noundef nonnull @.str.504, ptr noundef nonnull @RM_DefragAlloc) #32
  %335 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i335 = tail call i32 @dictAdd(ptr noundef %335, ptr noundef nonnull @.str.505, ptr noundef nonnull @RM_DefragRedisModuleString) #32
  %336 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i336 = tail call i32 @dictAdd(ptr noundef %336, ptr noundef nonnull @.str.506, ptr noundef nonnull @RM_DefragShouldStop) #32
  %337 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i337 = tail call i32 @dictAdd(ptr noundef %337, ptr noundef nonnull @.str.507, ptr noundef nonnull @RM_DefragCursorSet) #32
  %338 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i338 = tail call i32 @dictAdd(ptr noundef %338, ptr noundef nonnull @.str.508, ptr noundef nonnull @RM_DefragCursorGet) #32
  %339 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i339 = tail call i32 @dictAdd(ptr noundef %339, ptr noundef nonnull @.str.509, ptr noundef nonnull @RM_EventLoopAdd) #32
  %340 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i340 = tail call i32 @dictAdd(ptr noundef %340, ptr noundef nonnull @.str.510, ptr noundef nonnull @RM_EventLoopDel) #32
  %341 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i341 = tail call i32 @dictAdd(ptr noundef %341, ptr noundef nonnull @.str.511, ptr noundef nonnull @RM_EventLoopAddOneShot) #32
  %342 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i342 = tail call i32 @dictAdd(ptr noundef %342, ptr noundef nonnull @.str.512, ptr noundef nonnull @RM_Yield) #32
  %343 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i343 = tail call i32 @dictAdd(ptr noundef %343, ptr noundef nonnull @.str.513, ptr noundef nonnull @RM_RegisterBoolConfig) #32
  %344 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i344 = tail call i32 @dictAdd(ptr noundef %344, ptr noundef nonnull @.str.514, ptr noundef nonnull @RM_RegisterNumericConfig) #32
  %345 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i345 = tail call i32 @dictAdd(ptr noundef %345, ptr noundef nonnull @.str.515, ptr noundef nonnull @RM_RegisterStringConfig) #32
  %346 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i346 = tail call i32 @dictAdd(ptr noundef %346, ptr noundef nonnull @.str.516, ptr noundef nonnull @RM_RegisterEnumConfig) #32
  %347 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i347 = tail call i32 @dictAdd(ptr noundef %347, ptr noundef nonnull @.str.517, ptr noundef nonnull @RM_LoadConfigs) #32
  %348 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i348 = tail call i32 @dictAdd(ptr noundef %348, ptr noundef nonnull @.str.518, ptr noundef nonnull @RM_RegisterAuthCallback) #32
  %349 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i349 = tail call i32 @dictAdd(ptr noundef %349, ptr noundef nonnull @.str.519, ptr noundef nonnull @RM_RdbStreamCreateFromFile) #32
  %350 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i350 = tail call i32 @dictAdd(ptr noundef %350, ptr noundef nonnull @.str.520, ptr noundef nonnull @RM_RdbStreamFree) #32
  %351 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i351 = tail call i32 @dictAdd(ptr noundef %351, ptr noundef nonnull @.str.521, ptr noundef nonnull @RM_RdbLoad) #32
  %352 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 37), align 8
  %call.i352 = tail call i32 @dictAdd(ptr noundef %352, ptr noundef nonnull @.str.522, ptr noundef nonnull @RM_RdbSave) #32
  ret void
}

declare i32 @anetPipe(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @modulesCron() local_unnamed_addr #0 {
entry:
  %0 = load i64, ptr @moduleTempClientCount, align 8
  %cmp16 = icmp ne i64 %0, 0
  %1 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp27 = icmp ugt i64 %1, 8
  %or.cond18 = select i1 %cmp16, i1 %cmp27, i1 false
  br i1 %or.cond18, label %while.body, label %while.end

while.body:                                       ; preds = %entry, %while.body
  %2 = phi i64 [ %6, %while.body ], [ %0, %entry ]
  %iteration.09 = phi i32 [ %dec3, %while.body ], [ 50, %entry ]
  %3 = load ptr, ptr @moduleTempClients, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr @moduleTempClientCount, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %dec
  %4 = load ptr, ptr %arrayidx, align 8
  tail call void @freeClient(ptr noundef %4) #32
  %dec3 = add nsw i32 %iteration.09, -1
  %5 = load i64, ptr @moduleTempClientMinCount, align 8
  %dec4 = add i64 %5, -1
  store i64 %dec4, ptr @moduleTempClientMinCount, align 8
  %cmp = icmp ugt i32 %iteration.09, 1
  %6 = load i64, ptr @moduleTempClientCount, align 8
  %cmp1 = icmp ne i64 %6, 0
  %or.cond = select i1 %cmp, i1 %cmp1, i1 false
  %cmp2 = icmp ugt i64 %dec4, 8
  %or.cond1 = select i1 %or.cond, i1 %cmp2, i1 false
  br i1 %or.cond1, label %while.body, label %while.end, !llvm.loop !71

while.end:                                        ; preds = %while.body, %entry
  %.lcssa = phi i64 [ %0, %entry ], [ %6, %while.body ]
  store i64 %.lcssa, ptr @moduleTempClientMinCount, align 8
  %7 = load i64, ptr @moduleTempClientCap, align 8
  %cmp5 = icmp ugt i64 %7, 32
  %mul = shl i64 %.lcssa, 2
  %cmp7 = icmp ugt i64 %7, %mul
  %or.cond5 = select i1 %cmp5, i1 %cmp7, i1 false
  br i1 %or.cond5, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %div4 = lshr i64 %7, 2
  store i64 %div4, ptr @moduleTempClientCap, align 8
  %8 = load ptr, ptr @moduleTempClients, align 8
  %mul8 = shl i64 %div4, 3
  %call = tail call ptr @zrealloc(ptr noundef %8, i64 noundef %mul8) #34
  store ptr %call, ptr @moduleTempClients, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleLoadQueueEntryFree(ptr noundef %loadmod) local_unnamed_addr #0 {
entry:
  %tobool.not = icmp eq ptr %loadmod, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %0 = load ptr, ptr %loadmod, align 8
  tail call void @sdsfree(ptr noundef %0) #32
  %argc = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %loadmod, i64 0, i32 1
  %1 = load i32, ptr %argc, align 8
  %cmp8 = icmp sgt i32 %1, 0
  br i1 %cmp8, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.end
  %argv = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %loadmod, i64 0, i32 2
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %2 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 %indvars.iv
  %3 = load ptr, ptr %arrayidx, align 8
  tail call void @decrRefCount(ptr noundef %3) #32
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %4 = load i32, ptr %argc, align 8
  %5 = sext i32 %4 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %5
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !72

for.end:                                          ; preds = %for.body, %if.end
  %argv1 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %loadmod, i64 0, i32 2
  %6 = load ptr, ptr %argv1, align 8
  tail call void @zfree(ptr noundef %6) #32
  tail call void @zfree(ptr noundef nonnull %loadmod) #32
  br label %return

return:                                           ; preds = %entry, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleRemoveConfigs(ptr nocapture noundef readonly %module) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 8
  %0 = load ptr, ptr %module_configs, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #32
  %call3 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not4 = icmp eq ptr %call3, null
  br i1 %tobool.not4, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %name = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 1
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.body
  %call5 = phi ptr [ %call3, %while.body.lr.ph ], [ %call, %while.body ]
  %value = getelementptr inbounds %struct.listNode, ptr %call5, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %2 = load ptr, ptr %name, align 8
  %call1 = call ptr @sdsnew(ptr noundef %2) #32
  %call2 = call ptr @sdscat(ptr noundef %call1, ptr noundef nonnull @.str.104) #32
  %3 = load ptr, ptr %1, align 8
  %call4 = call ptr @sdscat(ptr noundef %call2, ptr noundef %3) #32
  call void @removeConfig(ptr noundef %call4) #32
  call void @sdsfree(ptr noundef %call4) #32
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !73

while.end:                                        ; preds = %while.body, %entry
  ret void
}

declare void @removeConfig(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleRemoveCateogires(ptr nocapture noundef readonly %module) local_unnamed_addr #0 {
entry:
  %num_acl_categories_added = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 19
  %0 = load i64, ptr %num_acl_categories_added, align 8
  %tobool.not = icmp eq i64 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @ACLCleanupCategoriesOnFailure(i64 noundef %0) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @ACLCleanupCategoriesOnFailure(i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleLoadFromQueue() local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 40), align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #32
  %call6 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not7 = icmp eq ptr %call6, null
  br i1 %tobool.not7, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %moduleLoadQueueEntryFree.exit
  %call8 = phi ptr [ %call, %moduleLoadQueueEntryFree.exit ], [ %call6, %entry ]
  %value = getelementptr inbounds %struct.listNode, ptr %call8, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %2 = load ptr, ptr %1, align 8
  %argv = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %1, i64 0, i32 2
  %3 = load ptr, ptr %argv, align 8
  %argc = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %1, i64 0, i32 1
  %4 = load i32, ptr %argc, align 8
  %call1 = call i32 @moduleLoad(ptr noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 0), !range !74
  %cmp = icmp eq i32 %call1, -1
  br i1 %cmp, label %do.body, label %if.end.i

do.body:                                          ; preds = %while.body
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2 = icmp sgt i32 %5, 3
  br i1 %cmp2, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %6 = load ptr, ptr %1, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.105, ptr noundef %6) #32
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  call void @exit(i32 noundef 1) #35
  unreachable

if.end.i:                                         ; preds = %while.body
  %7 = load ptr, ptr %1, align 8
  call void @sdsfree(ptr noundef %7) #32
  %8 = load i32, ptr %argc, align 8
  %cmp8.i = icmp sgt i32 %8, 0
  br i1 %cmp8.i, label %for.body.i, label %moduleLoadQueueEntryFree.exit

for.body.i:                                       ; preds = %if.end.i, %for.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %if.end.i ]
  %9 = load ptr, ptr %argv, align 8
  %arrayidx.i = getelementptr inbounds ptr, ptr %9, i64 %indvars.iv.i
  %10 = load ptr, ptr %arrayidx.i, align 8
  call void @decrRefCount(ptr noundef %10) #32
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %11 = load i32, ptr %argc, align 8
  %12 = sext i32 %11 to i64
  %cmp.i = icmp slt i64 %indvars.iv.next.i, %12
  br i1 %cmp.i, label %for.body.i, label %moduleLoadQueueEntryFree.exit, !llvm.loop !72

moduleLoadQueueEntryFree.exit:                    ; preds = %for.body.i, %if.end.i
  %13 = load ptr, ptr %argv, align 8
  call void @zfree(ptr noundef %13) #32
  call void @zfree(ptr noundef nonnull %1) #32
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 40), align 8
  call void @listDelNode(ptr noundef %14, ptr noundef nonnull %call8) #32
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !75

while.end:                                        ; preds = %moduleLoadQueueEntryFree.exit, %entry
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %15, i64 0, i32 2
  %16 = load i64, ptr %ht_used, align 8
  %arrayidx7 = getelementptr inbounds %struct.dict, ptr %15, i64 0, i32 2, i64 1
  %17 = load i64, ptr %arrayidx7, align 8
  %add = sub i64 0, %17
  %tobool8.not = icmp eq i64 %16, %add
  br i1 %tobool8.not, label %if.end15, label %do.body10

do.body10:                                        ; preds = %while.end
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp11 = icmp sgt i32 %18, 3
  br i1 %cmp11, label %do.end14, label %if.end13

if.end13:                                         ; preds = %do.body10
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.106) #32
  br label %do.end14

do.end14:                                         ; preds = %do.body10, %if.end13
  call void @exit(i32 noundef 1) #35
  unreachable

if.end15:                                         ; preds = %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleLoad(ptr noundef %path, ptr noundef %module_argv, i32 noundef %module_argc, i32 noundef %is_loadex) local_unnamed_addr #0 {
entry:
  %st = alloca %struct.stat, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %call = call i32 @stat64(ptr noundef %path, ptr noundef nonnull %st) #32
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %st_mode = getelementptr inbounds %struct.stat, ptr %st, i64 0, i32 3
  %0 = load i32, ptr %st_mode, align 8
  %and = and i32 %0, 73
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %do.body, label %if.end5

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2 = icmp sgt i32 %1, 3
  br i1 %cmp2, label %return, label %if.end

if.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.114, ptr noundef %path) #32
  br label %return

if.end5:                                          ; preds = %if.then, %entry
  %call6 = tail call ptr @dlopen(ptr noundef %path, i32 noundef 2) #32
  %cmp7 = icmp eq ptr %call6, null
  br i1 %cmp7, label %do.body9, label %if.end15

do.body9:                                         ; preds = %if.end5
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp10 = icmp sgt i32 %2, 3
  br i1 %cmp10, label %return, label %if.end12

if.end12:                                         ; preds = %do.body9
  %call13 = tail call ptr @dlerror() #32
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.115, ptr noundef %path, ptr noundef %call13) #32
  br label %return

if.end15:                                         ; preds = %if.end5
  %call16 = tail call ptr @dlsym(ptr noundef nonnull %call6, ptr noundef nonnull @.str.116) #32
  %cmp17 = icmp eq ptr %call16, null
  br i1 %cmp17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end15
  %call19 = tail call i32 @dlclose(ptr noundef nonnull %call6) #32
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp21 = icmp sgt i32 %3, 3
  br i1 %cmp21, label %return, label %if.end23

if.end23:                                         ; preds = %if.then18
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.117, ptr noundef %path) #32
  br label %return

if.end25:                                         ; preds = %if.end15
  %4 = getelementptr inbounds i8, ptr %ctx, i64 16
  %5 = getelementptr inbounds i8, ptr %ctx, i64 24
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %5, i8 0, i64 96, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  store ptr null, ptr %module1.i, align 8
  %flags.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 7
  store i32 64, ptr %flags.i, align 8
  %6 = load i64, ptr @moduleTempClientCount, align 8
  %cmp.not.i.i = icmp eq i64 %6, 0
  br i1 %cmp.not.i.i, label %if.else.i.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %if.end25
  %7 = load ptr, ptr @moduleTempClients, align 8
  %dec.i.i = add i64 %6, -1
  store i64 %dec.i.i, ptr @moduleTempClientCount, align 8
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %7, i64 %dec.i.i
  %8 = load ptr, ptr %arrayidx.i.i, align 8
  %9 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1.i.i = icmp ult i64 %dec.i.i, %9
  br i1 %cmp1.i.i, label %if.then2.i.i, label %if.end7.sink.split.i

if.then2.i.i:                                     ; preds = %if.then.i.i
  store i64 %dec.i.i, ptr @moduleTempClientMinCount, align 8
  br label %if.end7.sink.split.i

if.else.i.i:                                      ; preds = %if.end25
  %call.i.i = tail call ptr @createClient(ptr noundef null) #32
  %flags.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 1
  %10 = load i64, ptr %flags.i.i, align 8
  %or.i.i = or i64 %10, 134217728
  store i64 %or.i.i, ptr %flags.i.i, align 8
  %user.i.i = getelementptr inbounds %struct.client, ptr %call.i.i, i64 0, i32 20
  store ptr null, ptr %user.i.i, align 8
  br label %if.end7.sink.split.i

if.end7.sink.split.i:                             ; preds = %if.else.i.i, %if.then2.i.i, %if.then.i.i
  %call5.sink.i = phi ptr [ %8, %if.then2.i.i ], [ %8, %if.then.i.i ], [ %call.i.i, %if.else.i.i ]
  store ptr %call5.sink.i, ptr %4, align 8
  %11 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %11, 0
  %12 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = tail call i64 %12() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %if.end7.sink.split.i
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %13
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %if.end7.sink.split.i
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %14, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  %15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  store i64 %add.sink.i, ptr %15, align 8
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %call26 = call i32 %call16(ptr noundef nonnull %ctx, ptr noundef %module_argv, i32 noundef %module_argc) #32
  %cmp27 = icmp eq i32 %call26, 1
  br i1 %cmp27, label %do.body29, label %if.end41

do.body29:                                        ; preds = %moduleCreateContext.exit
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp30 = icmp sgt i32 %16, 3
  br i1 %cmp30, label %do.end33, label %if.end32

if.end32:                                         ; preds = %do.body29
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.118, ptr noundef %path) #32
  br label %do.end33

do.end33:                                         ; preds = %do.body29, %if.end32
  %17 = load ptr, ptr %module1.i, align 8
  %tobool34.not = icmp eq ptr %17, null
  br i1 %tobool34.not, label %if.end39, label %if.then35

if.then35:                                        ; preds = %do.end33
  call void @moduleUnregisterCleanup(ptr noundef nonnull %17)
  %18 = load ptr, ptr %module1.i, align 8
  %num_acl_categories_added.i = getelementptr inbounds %struct.RedisModule, ptr %18, i64 0, i32 19
  %19 = load i64, ptr %num_acl_categories_added.i, align 8
  %tobool.not.i = icmp eq i64 %19, 0
  br i1 %tobool.not.i, label %moduleRemoveCateogires.exit, label %if.then.i

if.then.i:                                        ; preds = %if.then35
  call void @ACLCleanupCategoriesOnFailure(i64 noundef %19) #32
  %.pre30 = load ptr, ptr %module1.i, align 8
  br label %moduleRemoveCateogires.exit

moduleRemoveCateogires.exit:                      ; preds = %if.then35, %if.then.i
  %20 = phi ptr [ %18, %if.then35 ], [ %.pre30, %if.then.i ]
  call void @moduleFreeModuleStructure(ptr noundef %20)
  br label %if.end39

if.end39:                                         ; preds = %moduleRemoveCateogires.exit, %do.end33
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %call40 = call i32 @dlclose(ptr noundef nonnull %call6) #32
  br label %return

if.end41:                                         ; preds = %moduleCreateContext.exit
  %21 = load ptr, ptr @modules, align 8
  %22 = load ptr, ptr %module1.i, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %22, i64 0, i32 1
  %23 = load ptr, ptr %name, align 8
  %call44 = call i32 @dictAdd(ptr noundef %21, ptr noundef %23, ptr noundef %22) #32
  %24 = load ptr, ptr %module1.i, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %24, i64 0, i32 13
  store i32 0, ptr %blocked_clients, align 8
  store ptr %call6, ptr %24, align 8
  %call48 = call noalias dereferenceable_or_null(24) ptr @zmalloc(i64 noundef 24) #33
  %25 = load ptr, ptr %module1.i, align 8
  %loadmod = getelementptr inbounds %struct.RedisModule, ptr %25, i64 0, i32 16
  store ptr %call48, ptr %loadmod, align 8
  %call50 = call ptr @sdsnew(ptr noundef %path) #32
  %26 = load ptr, ptr %module1.i, align 8
  %loadmod52 = getelementptr inbounds %struct.RedisModule, ptr %26, i64 0, i32 16
  %27 = load ptr, ptr %loadmod52, align 8
  store ptr %call50, ptr %27, align 8
  %tobool54.not = icmp eq i32 %module_argc, 0
  br i1 %tobool54.not, label %cond.end.thread, label %cond.end

cond.end.thread:                                  ; preds = %if.end41
  %28 = load ptr, ptr %module1.i, align 8
  %loadmod5733 = getelementptr inbounds %struct.RedisModule, ptr %28, i64 0, i32 16
  %29 = load ptr, ptr %loadmod5733, align 8
  %argv34 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %29, i64 0, i32 2
  store ptr null, ptr %argv34, align 8
  %30 = load ptr, ptr %loadmod5733, align 8
  %argc35 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %30, i64 0, i32 1
  store i32 %module_argc, ptr %argc35, align 8
  br label %for.end

cond.end:                                         ; preds = %if.end41
  %conv = sext i32 %module_argc to i64
  %mul = shl nsw i64 %conv, 3
  %call55 = call noalias ptr @zmalloc(i64 noundef %mul) #33
  %31 = load ptr, ptr %module1.i, align 8
  %loadmod57 = getelementptr inbounds %struct.RedisModule, ptr %31, i64 0, i32 16
  %32 = load ptr, ptr %loadmod57, align 8
  %argv = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %32, i64 0, i32 2
  store ptr %call55, ptr %argv, align 8
  %33 = load ptr, ptr %loadmod57, align 8
  %argc = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %33, i64 0, i32 1
  store i32 %module_argc, ptr %argc, align 8
  %cmp6024 = icmp sgt i32 %module_argc, 0
  br i1 %cmp6024, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %cond.end
  %wide.trip.count = zext nneg i32 %module_argc to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds ptr, ptr %module_argv, i64 %indvars.iv
  %34 = load ptr, ptr %arrayidx, align 8
  %35 = load ptr, ptr %module1.i, align 8
  %loadmod63 = getelementptr inbounds %struct.RedisModule, ptr %35, i64 0, i32 16
  %36 = load ptr, ptr %loadmod63, align 8
  %argv64 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %36, i64 0, i32 2
  %37 = load ptr, ptr %argv64, align 8
  %arrayidx66 = getelementptr inbounds ptr, ptr %37, i64 %indvars.iv
  store ptr %34, ptr %arrayidx66, align 8
  %38 = load ptr, ptr %module1.i, align 8
  %loadmod68 = getelementptr inbounds %struct.RedisModule, ptr %38, i64 0, i32 16
  %39 = load ptr, ptr %loadmod68, align 8
  %argv69 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %39, i64 0, i32 2
  %40 = load ptr, ptr %argv69, align 8
  %arrayidx71 = getelementptr inbounds ptr, ptr %40, i64 %indvars.iv
  %41 = load ptr, ptr %arrayidx71, align 8
  call void @incrRefCount(ptr noundef %41) #32
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !76

for.end:                                          ; preds = %for.body, %cond.end.thread, %cond.end
  %42 = load ptr, ptr %module1.i, align 8
  %num_commands_with_acl_categories = getelementptr inbounds %struct.RedisModule, ptr %42, i64 0, i32 17
  %43 = load i32, ptr %num_commands_with_acl_categories, align 8
  %tobool73.not = icmp eq i32 %43, 0
  br i1 %tobool73.not, label %do.body76, label %if.then74

if.then74:                                        ; preds = %for.end
  call void @ACLRecomputeCommandBitsFromCommandRulesAllUsers() #32
  %.pre27.pre = load ptr, ptr %module1.i, align 8
  br label %do.body76

do.body76:                                        ; preds = %for.end, %if.then74
  %.pre27 = phi ptr [ %42, %for.end ], [ %.pre27.pre, %if.then74 ]
  %44 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp77 = icmp sgt i32 %44, 2
  br i1 %cmp77, label %do.end83, label %if.end80

if.end80:                                         ; preds = %do.body76
  %name82 = getelementptr inbounds %struct.RedisModule, ptr %.pre27, i64 0, i32 1
  %45 = load ptr, ptr %name82, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.119, ptr noundef %45, ptr noundef %path) #32
  %.pre = load ptr, ptr %module1.i, align 8
  br label %do.end83

do.end83:                                         ; preds = %do.body76, %if.end80
  %46 = phi ptr [ %.pre27, %do.body76 ], [ %.pre, %if.end80 ]
  %onload85 = getelementptr inbounds %struct.RedisModule, ptr %46, i64 0, i32 18
  store i32 0, ptr %onload85, align 4
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %46, i64 0, i32 8
  %47 = load ptr, ptr %module_configs, align 8
  %len = getelementptr inbounds %struct.list, ptr %47, i64 0, i32 5
  %48 = load i64, ptr %len, align 8
  %tobool87.not = icmp eq i64 %48, 0
  br i1 %tobool87.not, label %if.end91, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.end83
  %configs_initialized = getelementptr inbounds %struct.RedisModule, ptr %46, i64 0, i32 9
  %49 = load i32, ptr %configs_initialized, align 8
  %tobool89.not = icmp eq i32 %49, 0
  br i1 %tobool89.not, label %if.then90, label %if.end91

if.then90:                                        ; preds = %land.lhs.true
  call void @serverLogRaw(i32 noundef 3, ptr noundef nonnull @.str.120) #32
  br label %if.end91

if.end91:                                         ; preds = %if.then90, %land.lhs.true, %do.end83
  %tobool100.not = phi i1 [ true, %land.lhs.true ], [ false, %if.then90 ], [ true, %do.end83 ]
  %tobool92.not = icmp eq i32 %is_loadex, 0
  br i1 %tobool92.not, label %if.end99, label %land.lhs.true93

land.lhs.true93:                                  ; preds = %if.end91
  %50 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %50, i64 0, i32 2
  %51 = load i64, ptr %ht_used, align 8
  %arrayidx96 = getelementptr inbounds %struct.dict, ptr %50, i64 0, i32 2, i64 1
  %52 = load i64, ptr %arrayidx96, align 8
  %add = sub i64 0, %52
  %tobool97.not = icmp eq i64 %51, %add
  br i1 %tobool97.not, label %if.end99, label %if.end99.thread

if.end99.thread:                                  ; preds = %land.lhs.true93
  call void @serverLogRaw(i32 noundef 3, ptr noundef nonnull @.str.121) #32
  %.pre28 = load ptr, ptr %module1.i, align 8
  br label %if.then101

if.end99:                                         ; preds = %land.lhs.true93, %if.end91
  %.pre29 = load ptr, ptr %module1.i, align 8
  br i1 %tobool100.not, label %if.end105, label %if.then101

if.then101:                                       ; preds = %if.end99.thread, %if.end99
  %53 = phi ptr [ %.pre28, %if.end99.thread ], [ %.pre29, %if.end99 ]
  %name103 = getelementptr inbounds %struct.RedisModule, ptr %53, i64 0, i32 1
  %54 = load ptr, ptr %name103, align 8
  %call104 = call i32 @moduleUnload(ptr noundef %54, ptr noundef null), !range !74
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %return

if.end105:                                        ; preds = %if.end99
  call void @moduleFireServerEvent(i64 noundef 9, i32 noundef 0, ptr noundef %.pre29)
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %return

return:                                           ; preds = %if.end23, %if.then18, %if.end12, %do.body9, %if.end, %do.body, %if.end105, %if.then101, %if.end39
  %retval.0 = phi i32 [ -1, %if.end39 ], [ -1, %if.then101 ], [ 0, %if.end105 ], [ -1, %do.body ], [ -1, %if.end ], [ -1, %do.body9 ], [ -1, %if.end12 ], [ -1, %if.then18 ], [ -1, %if.end23 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleFreeModuleStructure(ptr noundef %module) local_unnamed_addr #0 {
entry:
  %types = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 4
  %0 = load ptr, ptr %types, align 8
  tail call void @listRelease(ptr noundef %0) #32
  %filters = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 7
  %1 = load ptr, ptr %filters, align 8
  tail call void @listRelease(ptr noundef %1) #32
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 5
  %2 = load ptr, ptr %usedby, align 8
  tail call void @listRelease(ptr noundef %2) #32
  %using = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 6
  %3 = load ptr, ptr %using, align 8
  tail call void @listRelease(ptr noundef %3) #32
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 8
  %4 = load ptr, ptr %module_configs, align 8
  tail call void @listRelease(ptr noundef %4) #32
  %name = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 1
  %5 = load ptr, ptr %name, align 8
  tail call void @sdsfree(ptr noundef %5) #32
  %loadmod = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 16
  %6 = load ptr, ptr %loadmod, align 8
  %tobool.not.i = icmp eq ptr %6, null
  br i1 %tobool.not.i, label %moduleLoadQueueEntryFree.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %7 = load ptr, ptr %6, align 8
  tail call void @sdsfree(ptr noundef %7) #32
  %argc.i = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %6, i64 0, i32 1
  %8 = load i32, ptr %argc.i, align 8
  %cmp8.i = icmp sgt i32 %8, 0
  br i1 %cmp8.i, label %for.body.lr.ph.i, label %for.end.i

for.body.lr.ph.i:                                 ; preds = %if.end.i
  %argv.i = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %6, i64 0, i32 2
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %9 = load ptr, ptr %argv.i, align 8
  %arrayidx.i = getelementptr inbounds ptr, ptr %9, i64 %indvars.iv.i
  %10 = load ptr, ptr %arrayidx.i, align 8
  tail call void @decrRefCount(ptr noundef %10) #32
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %11 = load i32, ptr %argc.i, align 8
  %12 = sext i32 %11 to i64
  %cmp.i = icmp slt i64 %indvars.iv.next.i, %12
  br i1 %cmp.i, label %for.body.i, label %for.end.i, !llvm.loop !72

for.end.i:                                        ; preds = %for.body.i, %if.end.i
  %argv1.i = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %6, i64 0, i32 2
  %13 = load ptr, ptr %argv1.i, align 8
  tail call void @zfree(ptr noundef %13) #32
  tail call void @zfree(ptr noundef nonnull %6) #32
  br label %moduleLoadQueueEntryFree.exit

moduleLoadQueueEntryFree.exit:                    ; preds = %entry, %for.end.i
  tail call void @zfree(ptr noundef %module) #32
  ret void
}

declare void @listRelease(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleFreeArgs(ptr noundef %args, i32 noundef %num_args) local_unnamed_addr #0 {
entry:
  %cmp20 = icmp sgt i32 %num_args, 0
  br i1 %cmp20, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext nneg i32 %num_args to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv
  %0 = load ptr, ptr %arrayidx, align 8
  tail call void @zfree(ptr noundef %0) #32
  %token = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 3
  %1 = load ptr, ptr %token, align 8
  tail call void @zfree(ptr noundef %1) #32
  %summary = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 4
  %2 = load ptr, ptr %summary, align 8
  tail call void @zfree(ptr noundef %2) #32
  %since = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 5
  %3 = load ptr, ptr %since, align 8
  tail call void @zfree(ptr noundef %3) #32
  %deprecated_since = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 7
  %4 = load ptr, ptr %deprecated_since, align 8
  tail call void @zfree(ptr noundef %4) #32
  %display_text = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 10
  %5 = load ptr, ptr %display_text, align 8
  tail call void @zfree(ptr noundef %5) #32
  %subargs = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 9
  %6 = load ptr, ptr %subargs, align 8
  %tobool.not = icmp eq ptr %6, null
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %num_args18 = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 8
  %7 = load i32, ptr %num_args18, align 8
  tail call void @moduleFreeArgs(ptr noundef nonnull %6, i32 noundef %7)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !77

for.end:                                          ; preds = %for.inc, %entry
  tail call void @zfree(ptr noundef %args) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleFreeCommand(ptr noundef %module, ptr nocapture noundef %cmd) local_unnamed_addr #0 {
entry:
  %proc = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 12
  %0 = load ptr, ptr %proc, align 8
  %cmp.not = icmp eq ptr %0, @RedisModuleCommandDispatcher
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 32
  %1 = load ptr, ptr %module_cmd, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp2.not = icmp eq ptr %2, %module
  br i1 %cmp2.not, label %for.cond.preheader, label %return

for.cond.preheader:                               ; preds = %if.end
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 17
  %3 = load i32, ptr %key_specs_num, align 8
  %cmp554 = icmp sgt i32 %3, 0
  br i1 %cmp554, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 16
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %4 = load ptr, ptr %key_specs, align 8
  %arrayidx = getelementptr inbounds %struct.keySpec, ptr %4, i64 %indvars.iv
  %5 = load ptr, ptr %arrayidx, align 8
  %tobool.not = icmp eq ptr %5, null
  br i1 %tobool.not, label %if.end11, label %if.then6

if.then6:                                         ; preds = %for.body
  tail call void @zfree(ptr noundef nonnull %5) #32
  %.pre = load ptr, ptr %key_specs, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then6, %for.body
  %6 = phi ptr [ %.pre, %if.then6 ], [ %4, %for.body ]
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %6, i64 %indvars.iv, i32 2
  %7 = load i32, ptr %begin_search_type, align 8
  %cmp15 = icmp eq i32 %7, 3
  br i1 %cmp15, label %if.then16, label %for.inc

if.then16:                                        ; preds = %if.end11
  %bs = getelementptr inbounds %struct.keySpec, ptr %6, i64 %indvars.iv, i32 3
  %8 = load ptr, ptr %bs, align 8
  tail call void @zfree(ptr noundef %8) #32
  br label %for.inc

for.inc:                                          ; preds = %if.end11, %if.then16
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %9 = load i32, ptr %key_specs_num, align 8
  %10 = sext i32 %9 to i64
  %cmp5 = icmp slt i64 %indvars.iv.next, %10
  br i1 %cmp5, label %for.body, label %for.end, !llvm.loop !78

for.end:                                          ; preds = %for.inc, %for.cond.preheader
  %key_specs21 = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 16
  %11 = load ptr, ptr %key_specs21, align 8
  tail call void @zfree(ptr noundef %11) #32
  %tips = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 10
  %12 = load ptr, ptr %tips, align 8
  %tobool24.not56 = icmp eq ptr %12, null
  br i1 %tobool24.not56, label %for.end35, label %land.rhs

land.rhs:                                         ; preds = %for.end, %for.body29
  %indvars.iv67 = phi i64 [ %indvars.iv.next68, %for.body29 ], [ 0, %for.end ]
  %13 = phi ptr [ %15, %for.body29 ], [ %12, %for.end ]
  %arrayidx27 = getelementptr inbounds ptr, ptr %13, i64 %indvars.iv67
  %14 = load ptr, ptr %arrayidx27, align 8
  %tobool28.not = icmp eq ptr %14, null
  br i1 %tobool28.not, label %for.end35, label %for.body29

for.body29:                                       ; preds = %land.rhs
  tail call void @zfree(ptr noundef nonnull %14) #32
  %indvars.iv.next68 = add nuw i64 %indvars.iv67, 1
  %15 = load ptr, ptr %tips, align 8
  %tobool24.not = icmp eq ptr %15, null
  br i1 %tobool24.not, label %for.end35, label %land.rhs, !llvm.loop !79

for.end35:                                        ; preds = %land.rhs, %for.body29, %for.end
  %.lcssa53 = phi ptr [ null, %for.end ], [ null, %for.body29 ], [ %13, %land.rhs ]
  tail call void @zfree(ptr noundef %.lcssa53) #32
  %history = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 8
  %16 = load ptr, ptr %history, align 8
  %tobool39.not59 = icmp eq ptr %16, null
  br i1 %tobool39.not59, label %for.end56, label %land.rhs40

land.rhs40:                                       ; preds = %for.end35, %for.body46
  %indvars.iv70 = phi i64 [ %indvars.iv.next71, %for.body46 ], [ 0, %for.end35 ]
  %17 = phi ptr [ %21, %for.body46 ], [ %16, %for.end35 ]
  %arrayidx43 = getelementptr inbounds %struct.commandHistory, ptr %17, i64 %indvars.iv70
  %18 = load ptr, ptr %arrayidx43, align 8
  %tobool44.not = icmp eq ptr %18, null
  br i1 %tobool44.not, label %for.end56, label %for.body46

for.body46:                                       ; preds = %land.rhs40
  tail call void @zfree(ptr noundef nonnull %18) #32
  %19 = load ptr, ptr %history, align 8
  %changes = getelementptr inbounds %struct.commandHistory, ptr %19, i64 %indvars.iv70, i32 1
  %20 = load ptr, ptr %changes, align 8
  tail call void @zfree(ptr noundef %20) #32
  %indvars.iv.next71 = add nuw i64 %indvars.iv70, 1
  %21 = load ptr, ptr %history, align 8
  %tobool39.not = icmp eq ptr %21, null
  br i1 %tobool39.not, label %for.end56, label %land.rhs40, !llvm.loop !80

for.end56:                                        ; preds = %land.rhs40, %for.body46, %for.end35
  %.lcssa = phi ptr [ null, %for.end35 ], [ null, %for.body46 ], [ %17, %land.rhs40 ]
  tail call void @zfree(ptr noundef %.lcssa) #32
  %summary = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 1
  %22 = load ptr, ptr %summary, align 8
  tail call void @zfree(ptr noundef %22) #32
  %since58 = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 3
  %23 = load ptr, ptr %since58, align 8
  tail call void @zfree(ptr noundef %23) #32
  %deprecated_since = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 6
  %24 = load ptr, ptr %deprecated_since, align 8
  tail call void @zfree(ptr noundef %24) #32
  %complexity = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 2
  %25 = load ptr, ptr %complexity, align 8
  tail call void @zfree(ptr noundef %25) #32
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 28
  %26 = load ptr, ptr %latency_histogram, align 8
  %tobool59.not = icmp eq ptr %26, null
  br i1 %tobool59.not, label %if.end63, label %if.then60

if.then60:                                        ; preds = %for.end56
  tail call void @hdr_close(ptr noundef nonnull %26) #32
  store ptr null, ptr %latency_histogram, align 8
  br label %if.end63

if.end63:                                         ; preds = %if.then60, %for.end56
  %args = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 21
  %27 = load ptr, ptr %args, align 8
  %num_args = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 19
  %28 = load i32, ptr %num_args, align 8
  tail call void @moduleFreeArgs(ptr noundef %27, i32 noundef %28)
  tail call void @zfree(ptr noundef nonnull %1) #32
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 30
  %29 = load ptr, ptr %subcommands_dict, align 8
  %tobool64.not = icmp eq ptr %29, null
  br i1 %tobool64.not, label %return, label %if.then65

if.then65:                                        ; preds = %if.end63
  %call = tail call ptr @dictGetSafeIterator(ptr noundef nonnull %29) #32
  %call6763 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp68.not64 = icmp eq ptr %call6763, null
  br i1 %cmp68.not64, label %while.end, label %while.body

while.body:                                       ; preds = %if.then65, %while.cond.backedge
  %call6765 = phi ptr [ %call67, %while.cond.backedge ], [ %call6763, %if.then65 ]
  %call69 = tail call ptr @dictGetVal(ptr noundef nonnull %call6765) #32
  %call70 = tail call i32 @moduleFreeCommand(ptr noundef %module, ptr noundef %call69), !range !74
  %cmp71.not = icmp eq i32 %call70, 0
  br i1 %cmp71.not, label %if.end73, label %while.cond.backedge

if.end73:                                         ; preds = %while.body
  %30 = load ptr, ptr %subcommands_dict, align 8
  %31 = load ptr, ptr %call69, align 8
  %call75 = tail call i32 @dictDelete(ptr noundef %30, ptr noundef %31) #32
  %cmp76 = icmp eq i32 %call75, 0
  br i1 %cmp76, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end73
  tail call void @_serverAssert(ptr noundef nonnull @.str.107, ptr noundef nonnull @.str.2, i32 noundef 12095) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.end73
  %32 = load ptr, ptr %call69, align 8
  tail call void @sdsfree(ptr noundef %32) #32
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %call69, i64 0, i32 27
  %33 = load ptr, ptr %fullname, align 8
  tail call void @sdsfree(ptr noundef %33) #32
  tail call void @zfree(ptr noundef nonnull %call69) #32
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %cond.end, %while.body
  %call67 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp68.not = icmp eq ptr %call67, null
  br i1 %cmp68.not, label %while.end, label %while.body, !llvm.loop !81

while.end:                                        ; preds = %while.cond.backedge, %if.then65
  tail call void @dictReleaseIterator(ptr noundef %call) #32
  %34 = load ptr, ptr %subcommands_dict, align 8
  tail call void @dictRelease(ptr noundef %34) #32
  br label %return

return:                                           ; preds = %if.end63, %while.end, %if.end, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ -1, %if.end ], [ 0, %while.end ], [ 0, %if.end63 ]
  ret i32 %retval.0
}

declare void @hdr_close(ptr noundef) local_unnamed_addr #1

declare void @dictRelease(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnregisterCommands(ptr noundef %module) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %0) #32
  %call17 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not8 = icmp eq ptr %call17, null
  br i1 %cmp.not8, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.cond.backedge
  %call19 = phi ptr [ %call1, %while.cond.backedge ], [ %call17, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call19) #32
  %call3 = tail call i32 @moduleFreeCommand(ptr noundef %module, ptr noundef %call2), !range !74
  %cmp4.not = icmp eq i32 %call3, 0
  br i1 %cmp4.not, label %if.end, label %while.cond.backedge

if.end:                                           ; preds = %while.body
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 27
  %2 = load ptr, ptr %fullname, align 8
  %call5 = tail call i32 @dictDelete(ptr noundef %1, ptr noundef %2) #32
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.108, ptr noundef nonnull @.str.2, i32 noundef 12115) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.end
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 13), align 8
  %4 = load ptr, ptr %fullname, align 8
  %call9 = tail call i32 @dictDelete(ptr noundef %3, ptr noundef %4) #32
  %cmp10 = icmp eq i32 %call9, 0
  br i1 %cmp10, label %cond.end20, label %cond.false19

cond.false19:                                     ; preds = %cond.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.109, ptr noundef nonnull @.str.2, i32 noundef 12116) #32
  tail call void @abort() #35
  unreachable

cond.end20:                                       ; preds = %cond.end
  %5 = load ptr, ptr %call2, align 8
  tail call void @sdsfree(ptr noundef %5) #32
  %6 = load ptr, ptr %fullname, align 8
  tail call void @sdsfree(ptr noundef %6) #32
  tail call void @zfree(ptr noundef nonnull %call2) #32
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %cond.end20, %while.body
  %call1 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !82

while.end:                                        ; preds = %while.cond.backedge, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @parseLoadexArguments(ptr nocapture noundef %module_argv, ptr nocapture noundef %module_argc) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr %module_argv, align 8
  %1 = load i32, ptr %module_argc, align 4
  %cmp.not29 = icmp sgt i32 %1, 0
  br i1 %cmp.not29, label %for.body, label %if.then37

for.body:                                         ; preds = %entry, %if.end19
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end19 ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call = tail call i32 @strcasecmp(ptr noundef %3, ptr noundef nonnull @.str.110) #36
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %4 = add nuw nsw i64 %indvars.iv, 2
  %5 = trunc i64 %4 to i32
  %cmp1.not = icmp sgt i32 %1, %5
  br i1 %cmp1.not, label %if.end5, label %do.body

do.body:                                          ; preds = %if.then
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3 = icmp sgt i32 %6, 2
  br i1 %cmp3, label %return, label %if.end

if.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.111) #32
  br label %return

if.end5:                                          ; preds = %if.then
  %arrayidx8 = getelementptr ptr, ptr %arrayidx, i64 1
  %7 = load ptr, ptr %arrayidx8, align 8
  %ptr9 = getelementptr inbounds %struct.redisObject, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %ptr9, align 8
  %call10 = tail call ptr @sdsdup(ptr noundef %8) #32
  %arrayidx13 = getelementptr inbounds ptr, ptr %0, i64 %4
  %9 = load ptr, ptr %arrayidx13, align 8
  %ptr14 = getelementptr inbounds %struct.redisObject, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %ptr14, align 8
  %call15 = tail call ptr @sdsdup(ptr noundef %10) #32
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  %call16 = tail call i32 @dictReplace(ptr noundef %11, ptr noundef %call10, ptr noundef %call15) #32
  %tobool17.not = icmp eq i32 %call16, 0
  br i1 %tobool17.not, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end5
  tail call void @sdsfree(ptr noundef %call10) #32
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end5
  %indvars.iv.next = add nuw i64 %indvars.iv, 3
  %12 = trunc i64 %indvars.iv.next to i32
  %cmp.not = icmp sgt i32 %1, %12
  br i1 %cmp.not, label %for.body, label %if.then37, !llvm.loop !83

if.else:                                          ; preds = %for.body
  %call21 = tail call i32 @strcasecmp(ptr noundef %3, ptr noundef nonnull @.str.112) #36
  %tobool22.not = icmp eq i32 %call21, 0
  br i1 %tobool22.not, label %if.then23, label %do.body29

if.then23:                                        ; preds = %if.else
  %13 = trunc i64 %indvars.iv to i32
  %inc = add nuw nsw i32 %13, 1
  %cmp24.not = icmp slt i32 %inc, %1
  br i1 %cmp24.not, label %if.else26, label %if.then25

if.then25:                                        ; preds = %if.then23
  store ptr null, ptr %module_argv, align 8
  store i32 0, ptr %module_argc, align 4
  br label %return

if.else26:                                        ; preds = %if.then23
  %idx.ext = zext nneg i32 %inc to i64
  %add.ptr = getelementptr inbounds ptr, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %module_argv, align 8
  %sub = sub nsw i32 %1, %inc
  store i32 %sub, ptr %module_argc, align 4
  br label %return

do.body29:                                        ; preds = %if.else
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp30 = icmp sgt i32 %14, 2
  br i1 %cmp30, label %return, label %if.end32

if.end32:                                         ; preds = %do.body29
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.113, ptr noundef %3) #32
  br label %return

if.then37:                                        ; preds = %if.end19, %entry
  store ptr null, ptr %module_argv, align 8
  store i32 0, ptr %module_argc, align 4
  br label %return

return:                                           ; preds = %if.else26, %if.then25, %if.then37, %if.end32, %do.body29, %if.end, %do.body
  %retval.0 = phi i32 [ 1, %do.body ], [ 1, %if.end ], [ 1, %do.body29 ], [ 1, %if.end32 ], [ 0, %if.then37 ], [ 0, %if.then25 ], [ 0, %if.else26 ]
  ret i32 %retval.0
}

declare i32 @dictReplace(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnregisterCleanup(ptr noundef %module) local_unnamed_addr #0 {
entry:
  %li.i35 = alloca %struct.listIter, align 8
  %li.i24 = alloca %struct.listIter, align 8
  %li.i16 = alloca %struct.listIter, align 8
  %li.i9 = alloca %struct.listIter, align 8
  %li.i = alloca %struct.listIter, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i)
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li.i) #32
  %call3.i = call ptr @listNext(ptr noundef nonnull %li.i) #32
  %cmp.not4.i = icmp eq ptr %call3.i, null
  br i1 %cmp.not4.i, label %moduleFreeAuthenticatedClients.exit, label %while.body.i

while.body.i:                                     ; preds = %entry, %while.cond.backedge.i
  %call5.i = phi ptr [ %call.i, %while.cond.backedge.i ], [ %call3.i, %entry ]
  %value.i = getelementptr inbounds %struct.listNode, ptr %call5.i, i64 0, i32 2
  %1 = load ptr, ptr %value.i, align 8
  %auth_module.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 70
  %2 = load ptr, ptr %auth_module.i, align 8
  %tobool.not.i = icmp ne ptr %2, null
  %cmp3.i = icmp eq ptr %2, %module
  %or.cond.i = and i1 %tobool.not.i, %cmp3.i
  br i1 %or.cond.i, label %if.then4.i, label %while.cond.backedge.i

if.then4.i:                                       ; preds = %while.body.i
  %auth_callback.i.i.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 68
  %3 = load ptr, ptr %auth_callback.i.i.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %3, null
  br i1 %tobool.not.i.i.i, label %moduleNotifyUserChanged.exit.i.i, label %if.then.i.i.i

if.then.i.i.i:                                    ; preds = %if.then4.i
  %4 = load i64, ptr %1, align 8
  %auth_callback_privdata.i.i.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 69
  %5 = load ptr, ptr %auth_callback_privdata.i.i.i, align 8
  call void %3(i64 noundef %4, ptr noundef %5) #32
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %auth_callback.i.i.i, i8 0, i64 24, i1 false)
  br label %moduleNotifyUserChanged.exit.i.i

moduleNotifyUserChanged.exit.i.i:                 ; preds = %if.then.i.i.i, %if.then4.i
  %6 = load ptr, ptr @DefaultUser, align 8
  %user.i.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 20
  store ptr %6, ptr %user.i.i, align 8
  %authenticated.i.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 34
  store i32 0, ptr %authenticated.i.i, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %cmp.i.i = icmp eq ptr %7, %1
  br i1 %cmp.i.i, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %moduleNotifyUserChanged.exit.i.i
  %flags.i.i = getelementptr inbounds %struct.client, ptr %1, i64 0, i32 1
  %8 = load i64, ptr %flags.i.i, align 8
  %or.i.i = or i64 %8, 1099511627776
  store i64 %or.i.i, ptr %flags.i.i, align 8
  br label %while.cond.backedge.i

if.else.i.i:                                      ; preds = %moduleNotifyUserChanged.exit.i.i
  call void @freeClientAsync(ptr noundef nonnull %1) #32
  br label %while.cond.backedge.i

while.cond.backedge.i:                            ; preds = %if.else.i.i, %if.then.i.i, %while.body.i
  %call.i = call ptr @listNext(ptr noundef nonnull %li.i) #32
  %cmp.not.i = icmp eq ptr %call.i, null
  br i1 %cmp.not.i, label %moduleFreeAuthenticatedClients.exit, label %while.body.i, !llvm.loop !84

moduleFreeAuthenticatedClients.exit:              ; preds = %while.cond.backedge.i, %entry
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  call void @moduleUnregisterCommands(ptr noundef %module)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i9)
  %9 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  call void @listRewind(ptr noundef %9, ptr noundef nonnull %li.i9) #32
  %call3.i10 = call ptr @listNext(ptr noundef nonnull %li.i9) #32
  %tobool.not4.i = icmp eq ptr %call3.i10, null
  br i1 %tobool.not4.i, label %moduleUnsubscribeNotifications.exit, label %while.body.i11

while.body.i11:                                   ; preds = %moduleFreeAuthenticatedClients.exit, %if.end.i
  %call5.i12 = phi ptr [ %call.i14, %if.end.i ], [ %call3.i10, %moduleFreeAuthenticatedClients.exit ]
  %value.i13 = getelementptr inbounds %struct.listNode, ptr %call5.i12, i64 0, i32 2
  %10 = load ptr, ptr %value.i13, align 8
  %11 = load ptr, ptr %10, align 8
  %cmp.i = icmp eq ptr %11, %module
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %while.body.i11
  %12 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  call void @listDelNode(ptr noundef %12, ptr noundef nonnull %call5.i12) #32
  call void @zfree(ptr noundef nonnull %10) #32
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %while.body.i11
  %call.i14 = call ptr @listNext(ptr noundef nonnull %li.i9) #32
  %tobool.not.i15 = icmp eq ptr %call.i14, null
  br i1 %tobool.not.i15, label %moduleUnsubscribeNotifications.exit, label %while.body.i11, !llvm.loop !53

moduleUnsubscribeNotifications.exit:              ; preds = %if.end.i, %moduleFreeAuthenticatedClients.exit
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i9)
  %call = call i32 @moduleUnregisterSharedAPI(ptr noundef %module)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i16)
  %using.i = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 6
  %13 = load ptr, ptr %using.i, align 8
  call void @listRewind(ptr noundef %13, ptr noundef nonnull %li.i16) #32
  %call5.i17 = call ptr @listNext(ptr noundef nonnull %li.i16) #32
  %tobool.not6.i = icmp eq ptr %call5.i17, null
  br i1 %tobool.not6.i, label %moduleUnregisterUsedAPI.exit, label %while.body.i18

while.body.i18:                                   ; preds = %moduleUnsubscribeNotifications.exit, %if.end.i21
  %call8.i = phi ptr [ %call.i22, %if.end.i21 ], [ %call5.i17, %moduleUnsubscribeNotifications.exit ]
  %value.i19 = getelementptr inbounds %struct.listNode, ptr %call8.i, i64 0, i32 2
  %14 = load ptr, ptr %value.i19, align 8
  %usedby.i = getelementptr inbounds %struct.RedisModule, ptr %14, i64 0, i32 5
  %15 = load ptr, ptr %usedby.i, align 8
  %call2.i = call ptr @listSearchKey(ptr noundef %15, ptr noundef %module) #32
  %tobool3.not.i = icmp eq ptr %call2.i, null
  br i1 %tobool3.not.i, label %if.end.i21, label %if.then.i20

if.then.i20:                                      ; preds = %while.body.i18
  %16 = load ptr, ptr %usedby.i, align 8
  call void @listDelNode(ptr noundef %16, ptr noundef nonnull %call2.i) #32
  br label %if.end.i21

if.end.i21:                                       ; preds = %if.then.i20, %while.body.i18
  %call.i22 = call ptr @listNext(ptr noundef nonnull %li.i16) #32
  %tobool.not.i23 = icmp eq ptr %call.i22, null
  br i1 %tobool.not.i23, label %moduleUnregisterUsedAPI.exit, label %while.body.i18, !llvm.loop !61

moduleUnregisterUsedAPI.exit:                     ; preds = %if.end.i21, %moduleUnsubscribeNotifications.exit
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i16)
  %call2 = call i32 @moduleUnregisterFilters(ptr noundef %module)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i24)
  %17 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listRewind(ptr noundef %17, ptr noundef nonnull %li.i24) #32
  %call3.i25 = call ptr @listNext(ptr noundef nonnull %li.i24) #32
  %tobool.not4.i26 = icmp eq ptr %call3.i25, null
  br i1 %tobool.not4.i26, label %moduleUnsubscribeAllServerEvents.exit, label %while.body.i27

while.body.i27:                                   ; preds = %moduleUnregisterUsedAPI.exit, %if.end.i31
  %call5.i28 = phi ptr [ %call.i32, %if.end.i31 ], [ %call3.i25, %moduleUnregisterUsedAPI.exit ]
  %value.i29 = getelementptr inbounds %struct.listNode, ptr %call5.i28, i64 0, i32 2
  %18 = load ptr, ptr %value.i29, align 8
  %19 = load ptr, ptr %18, align 8
  %cmp.i30 = icmp eq ptr %19, %module
  br i1 %cmp.i30, label %if.then.i34, label %if.end.i31

if.then.i34:                                      ; preds = %while.body.i27
  %20 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listDelNode(ptr noundef %20, ptr noundef nonnull %call5.i28) #32
  call void @zfree(ptr noundef nonnull %18) #32
  br label %if.end.i31

if.end.i31:                                       ; preds = %if.then.i34, %while.body.i27
  %call.i32 = call ptr @listNext(ptr noundef nonnull %li.i24) #32
  %tobool.not.i33 = icmp eq ptr %call.i32, null
  br i1 %tobool.not.i33, label %moduleUnsubscribeAllServerEvents.exit, label %while.body.i27, !llvm.loop !70

moduleUnsubscribeAllServerEvents.exit:            ; preds = %if.end.i31, %moduleUnregisterUsedAPI.exit
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i24)
  call void @moduleRemoveConfigs(ptr noundef %module)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i35)
  %21 = load ptr, ptr @moduleAuthCallbacks, align 8
  call void @listRewind(ptr noundef %21, ptr noundef nonnull %li.i35) #32
  %call3.i36 = call ptr @listNext(ptr noundef nonnull %li.i35) #32
  %tobool.not4.i37 = icmp eq ptr %call3.i36, null
  br i1 %tobool.not4.i37, label %moduleUnregisterAuthCBs.exit, label %while.body.i38

while.body.i38:                                   ; preds = %moduleUnsubscribeAllServerEvents.exit, %if.end.i42
  %call5.i39 = phi ptr [ %call.i43, %if.end.i42 ], [ %call3.i36, %moduleUnsubscribeAllServerEvents.exit ]
  %value.i40 = getelementptr inbounds %struct.listNode, ptr %call5.i39, i64 0, i32 2
  %22 = load ptr, ptr %value.i40, align 8
  %23 = load ptr, ptr %22, align 8
  %cmp.i41 = icmp eq ptr %23, %module
  br i1 %cmp.i41, label %if.then.i45, label %if.end.i42

if.then.i45:                                      ; preds = %while.body.i38
  %24 = load ptr, ptr @moduleAuthCallbacks, align 8
  call void @listDelNode(ptr noundef %24, ptr noundef nonnull %call5.i39) #32
  call void @zfree(ptr noundef nonnull %22) #32
  br label %if.end.i42

if.end.i42:                                       ; preds = %if.then.i45, %while.body.i38
  %call.i43 = call ptr @listNext(ptr noundef nonnull %li.i35) #32
  %tobool.not.i44 = icmp eq ptr %call.i43, null
  br i1 %tobool.not.i44, label %moduleUnregisterAuthCBs.exit, label %while.body.i38, !llvm.loop !48

moduleUnregisterAuthCBs.exit:                     ; preds = %if.end.i42, %moduleUnsubscribeAllServerEvents.exit
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i35)
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @stat64(ptr nocapture noundef readonly, ptr nocapture noundef) local_unnamed_addr #20

; Function Attrs: nounwind
declare ptr @dlopen(ptr noundef, i32 noundef) local_unnamed_addr #25

; Function Attrs: nounwind
declare ptr @dlerror() local_unnamed_addr #25

; Function Attrs: nounwind
declare ptr @dlsym(ptr noundef, ptr noundef) local_unnamed_addr #25

; Function Attrs: nounwind
declare i32 @dlclose(ptr noundef) local_unnamed_addr #25

declare void @ACLRecomputeCommandBitsFromCommandRulesAllUsers() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleUnload(ptr noundef %name, ptr nocapture noundef writeonly %errmsg) local_unnamed_addr #0 {
entry:
  %iter.i = alloca %struct.raxIterator, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictFetchValue(ptr noundef %0, ptr noundef %name) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr @.str.122, ptr %errmsg, align 8
  br label %return

if.else:                                          ; preds = %entry
  %types = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 4
  %1 = load ptr, ptr %types, align 8
  %len = getelementptr inbounds %struct.list, ptr %1, i64 0, i32 5
  %2 = load i64, ptr %len, align 8
  %tobool.not = icmp eq i64 %2, 0
  br i1 %tobool.not, label %if.else2, label %if.then1

if.then1:                                         ; preds = %if.else
  store ptr @.str.123, ptr %errmsg, align 8
  br label %return

if.else2:                                         ; preds = %if.else
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 5
  %3 = load ptr, ptr %usedby, align 8
  %len3 = getelementptr inbounds %struct.list, ptr %3, i64 0, i32 5
  %4 = load i64, ptr %len3, align 8
  %tobool4.not = icmp eq i64 %4, 0
  br i1 %tobool4.not, label %if.else6, label %if.then5

if.then5:                                         ; preds = %if.else2
  store ptr @.str.124, ptr %errmsg, align 8
  br label %return

if.else6:                                         ; preds = %if.else2
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 13
  %5 = load i32, ptr %blocked_clients, align 8
  %tobool7.not = icmp eq i32 %5, 0
  br i1 %tobool7.not, label %if.else9, label %if.then8

if.then8:                                         ; preds = %if.else6
  store ptr @.str.125, ptr %errmsg, align 8
  br label %return

if.else9:                                         ; preds = %if.else6
  call void @llvm.lifetime.start.p0(i64 480, ptr nonnull %iter.i)
  %6 = load ptr, ptr @Timers, align 8
  call void @raxStart(ptr noundef nonnull %iter.i, ptr noundef %6) #32
  %call.i = call i32 @raxSeek(ptr noundef nonnull %iter.i, ptr noundef nonnull @.str.79, ptr noundef null, i64 noundef 0) #32
  %data.i = getelementptr inbounds %struct.raxIterator, ptr %iter.i, i64 0, i32 3
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %if.else9
  %call1.i = call i32 @raxNext(ptr noundef nonnull %iter.i) #32
  %tobool.not.i = icmp eq i32 %call1.i, 0
  br i1 %tobool.not.i, label %if.end16, label %while.body.i

while.body.i:                                     ; preds = %while.cond.i
  %7 = load ptr, ptr %data.i, align 8
  %8 = load ptr, ptr %7, align 8
  %cmp.i = icmp eq ptr %8, %call
  br i1 %cmp.i, label %if.then12, label %while.cond.i, !llvm.loop !57

if.then12:                                        ; preds = %while.body.i
  call void @raxStop(ptr noundef nonnull %iter.i) #32
  call void @llvm.lifetime.end.p0(i64 480, ptr nonnull %iter.i)
  store ptr @.str.126, ptr %errmsg, align 8
  br label %return

if.end16:                                         ; preds = %while.cond.i
  call void @raxStop(ptr noundef nonnull %iter.i) #32
  call void @llvm.lifetime.end.p0(i64 480, ptr nonnull %iter.i)
  %9 = load ptr, ptr %call, align 8
  %call17 = call ptr @dlsym(ptr noundef %9, ptr noundef nonnull @.str.127) #32
  %tobool18.not = icmp eq ptr %call17, null
  br i1 %tobool18.not, label %if.end28, label %if.then19

if.then19:                                        ; preds = %if.end16
  call void @moduleCreateContext(ptr noundef nonnull %ctx, ptr noundef nonnull %call, i32 noundef 64)
  %call20 = call i32 %call17(ptr noundef nonnull %ctx) #32
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %cmp21 = icmp eq i32 %call20, 1
  br i1 %cmp21, label %do.body, label %if.end28

do.body:                                          ; preds = %if.then19
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp23 = icmp sgt i32 %10, 3
  br i1 %cmp23, label %do.end, label %if.end25

if.end25:                                         ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.128, ptr noundef %name) #32
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end25
  %call26 = tail call ptr @__errno_location() #37
  store i32 125, ptr %call26, align 4
  br label %return

if.end28:                                         ; preds = %if.then19, %if.end16
  call void @moduleUnregisterCleanup(ptr noundef nonnull %call)
  %11 = load ptr, ptr %call, align 8
  %call30 = call i32 @dlclose(ptr noundef %11) #32
  %cmp31 = icmp eq i32 %call30, -1
  br i1 %cmp31, label %if.then32, label %if.end43

if.then32:                                        ; preds = %if.end28
  %call33 = call ptr @dlerror() #32
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp38 = icmp sgt i32 %12, 3
  br i1 %cmp38, label %if.end43, label %if.end40

if.end40:                                         ; preds = %if.then32
  %cmp34 = icmp eq ptr %call33, null
  %spec.store.select = select i1 %cmp34, ptr @.str.129, ptr %call33
  %name41 = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 1
  %13 = load ptr, ptr %name41, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.130, ptr noundef %13, ptr noundef nonnull %spec.store.select) #32
  br label %if.end43

if.end43:                                         ; preds = %if.end40, %if.then32, %if.end28
  call void @moduleFireServerEvent(i64 noundef 9, i32 noundef 1, ptr noundef nonnull %call)
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp45 = icmp sgt i32 %14, 2
  br i1 %cmp45, label %do.end49, label %if.end47

if.end47:                                         ; preds = %if.end43
  %name48 = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 1
  %15 = load ptr, ptr %name48, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.131, ptr noundef %15) #32
  br label %do.end49

do.end49:                                         ; preds = %if.end43, %if.end47
  %16 = load ptr, ptr @modules, align 8
  %name50 = getelementptr inbounds %struct.RedisModule, ptr %call, i64 0, i32 1
  %17 = load ptr, ptr %name50, align 8
  %call51 = call i32 @dictDelete(ptr noundef %16, ptr noundef %17) #32
  store ptr null, ptr %name50, align 8
  call void @moduleFreeModuleStructure(ptr noundef nonnull %call)
  call void @ACLRecomputeCommandBitsFromCommandRulesAllUsers() #32
  br label %return

return:                                           ; preds = %do.end49, %do.end, %if.then12, %if.then8, %if.then5, %if.then1, %if.then
  %retval.0 = phi i32 [ -1, %if.then ], [ -1, %if.then1 ], [ -1, %if.then5 ], [ -1, %if.then8 ], [ -1, %if.then12 ], [ -1, %do.end ], [ 0, %do.end49 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @modulePipeReadable(ptr nocapture noundef readnone %el, i32 noundef %fd, ptr nocapture noundef readnone %privdata, i32 noundef %mask) local_unnamed_addr #0 {
entry:
  %buf = alloca [128 x i8], align 16
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %call = call i64 @read(i32 noundef %fd, ptr noundef nonnull %buf, i64 noundef 128) #32
  %cmp = icmp eq i64 %call, 128
  br i1 %cmp, label %while.cond, label %while.end, !llvm.loop !85

while.end:                                        ; preds = %while.cond
  %call.i = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleEventLoopMutex) #32
  %0 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %eventLoopHandleOneShotEvents.exit, label %while.cond.preheader.i

while.cond.preheader.i:                           ; preds = %while.end
  %len4.i = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len4.i, align 8
  %tobool1.not5.i = icmp eq i64 %1, 0
  br i1 %tobool1.not5.i, label %eventLoopHandleOneShotEvents.exit, label %while.body.i

while.body.i:                                     ; preds = %while.cond.preheader.i, %while.body.i
  %2 = phi ptr [ %7, %while.body.i ], [ %0, %while.cond.preheader.i ]
  %3 = load ptr, ptr %2, align 8
  %value.i = getelementptr inbounds %struct.listNode, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %value.i, align 8
  tail call void @listDelNode(ptr noundef nonnull %2, ptr noundef %3) #32
  %call2.i = tail call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleEventLoopMutex) #32
  %5 = load ptr, ptr %4, align 8
  %user_data.i = getelementptr inbounds %struct.EventLoopOneShot, ptr %4, i64 0, i32 1
  %6 = load ptr, ptr %user_data.i, align 8
  tail call void %5(ptr noundef %6) #32
  tail call void @zfree(ptr noundef nonnull %4) #32
  %call3.i = tail call i32 @pthread_mutex_lock(ptr noundef nonnull @moduleEventLoopMutex) #32
  %7 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %7, i64 0, i32 5
  %8 = load i64, ptr %len.i, align 8
  %tobool1.not.i = icmp eq i64 %8, 0
  br i1 %tobool1.not.i, label %eventLoopHandleOneShotEvents.exit, label %while.body.i, !llvm.loop !86

eventLoopHandleOneShotEvents.exit:                ; preds = %while.body.i, %while.end, %while.cond.preheader.i
  %call4.i = tail call i32 @pthread_mutex_unlock(ptr noundef nonnull @moduleEventLoopMutex) #32
  ret void
}

; Function Attrs: nofree
declare noundef i64 @read(i32 noundef, ptr nocapture noundef, i64 noundef) local_unnamed_addr #26

; Function Attrs: nounwind uwtable
define dso_local void @addReplyLoadedModules(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %0) #32
  %1 = load ptr, ptr @modules, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2
  %2 = load i64, ptr %ht_used, align 8
  %arrayidx2 = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2, i64 1
  %3 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %3, %2
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef %add) #32
  %call343 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not44 = icmp eq ptr %call343, null
  br i1 %cmp.not44, label %while.end, label %while.body

while.cond.loopexit:                              ; preds = %for.body, %sdslen.exit39
  %call3 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call3, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !87

while.body:                                       ; preds = %entry, %while.cond.loopexit
  %call345 = phi ptr [ %call3, %while.cond.loopexit ], [ %call343, %entry ]
  %call4 = tail call ptr @dictGetKey(ptr noundef nonnull %call345) #32
  %call5 = tail call ptr @dictGetVal(ptr noundef nonnull %call345) #32
  %loadmod = getelementptr inbounds %struct.RedisModule, ptr %call5, i64 0, i32 16
  %4 = load ptr, ptr %loadmod, align 8
  %5 = load ptr, ptr %4, align 8
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 4) #32
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.132) #32
  %arrayidx.i = getelementptr inbounds i8, ptr %call4, i64 -1
  %6 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %6 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %while.body
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %while.body
  %add.ptr.i = getelementptr inbounds i8, ptr %call4, i64 -3
  %7 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %7 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %while.body
  %add.ptr6.i = getelementptr inbounds i8, ptr %call4, i64 -5
  %8 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %8 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %while.body
  %add.ptr10.i = getelementptr inbounds i8, ptr %call4, i64 -9
  %9 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %9 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %while.body
  %add.ptr14.i = getelementptr inbounds i8, ptr %call4, i64 -17
  %10 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %while.body, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %10, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %while.body ]
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %call4, i64 noundef %retval.0.i) #32
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.133) #32
  %ver = getelementptr inbounds %struct.RedisModule, ptr %call5, i64 0, i32 2
  %11 = load i32, ptr %ver, align 8
  %conv = sext i32 %11 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv) #32
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.134) #32
  %arrayidx.i21 = getelementptr inbounds i8, ptr %5, i64 -1
  %12 = load i8, ptr %arrayidx.i21, align 1
  %conv.i22 = zext i8 %12 to i32
  %and.i23 = and i32 %conv.i22, 7
  switch i32 %and.i23, label %sdslen.exit39 [
    i32 0, label %sw.bb.i36
    i32 1, label %sw.bb3.i33
    i32 2, label %sw.bb5.i30
    i32 3, label %sw.bb9.i27
    i32 4, label %sw.bb13.i24
  ]

sw.bb.i36:                                        ; preds = %sdslen.exit
  %shr.i37 = lshr i32 %conv.i22, 3
  %conv2.i38 = zext nneg i32 %shr.i37 to i64
  br label %sdslen.exit39

sw.bb3.i33:                                       ; preds = %sdslen.exit
  %add.ptr.i34 = getelementptr inbounds i8, ptr %5, i64 -3
  %13 = load i8, ptr %add.ptr.i34, align 1
  %conv4.i35 = zext i8 %13 to i64
  br label %sdslen.exit39

sw.bb5.i30:                                       ; preds = %sdslen.exit
  %add.ptr6.i31 = getelementptr inbounds i8, ptr %5, i64 -5
  %14 = load i16, ptr %add.ptr6.i31, align 1
  %conv8.i32 = zext i16 %14 to i64
  br label %sdslen.exit39

sw.bb9.i27:                                       ; preds = %sdslen.exit
  %add.ptr10.i28 = getelementptr inbounds i8, ptr %5, i64 -9
  %15 = load i32, ptr %add.ptr10.i28, align 1
  %conv12.i29 = zext i32 %15 to i64
  br label %sdslen.exit39

sw.bb13.i24:                                      ; preds = %sdslen.exit
  %add.ptr14.i25 = getelementptr inbounds i8, ptr %5, i64 -17
  %16 = load i64, ptr %add.ptr14.i25, align 1
  br label %sdslen.exit39

sdslen.exit39:                                    ; preds = %sdslen.exit, %sw.bb.i36, %sw.bb3.i33, %sw.bb5.i30, %sw.bb9.i27, %sw.bb13.i24
  %retval.0.i26 = phi i64 [ %16, %sw.bb13.i24 ], [ %conv12.i29, %sw.bb9.i27 ], [ %conv8.i32, %sw.bb5.i30 ], [ %conv4.i35, %sw.bb3.i33 ], [ %conv2.i38, %sw.bb.i36 ], [ 0, %sdslen.exit ]
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %5, i64 noundef %retval.0.i26) #32
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.135) #32
  %17 = load ptr, ptr %loadmod, align 8
  %argc = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %17, i64 0, i32 1
  %18 = load i32, ptr %argc, align 8
  %conv10 = sext i32 %18 to i64
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef %conv10) #32
  %19 = load ptr, ptr %loadmod, align 8
  %argc1240 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %19, i64 0, i32 1
  %20 = load i32, ptr %argc1240, align 8
  %cmp1341 = icmp sgt i32 %20, 0
  br i1 %cmp1341, label %for.body, label %while.cond.loopexit

for.body:                                         ; preds = %sdslen.exit39, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %sdslen.exit39 ]
  %21 = phi ptr [ %24, %for.body ], [ %19, %sdslen.exit39 ]
  %argv = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %21, i64 0, i32 2
  %22 = load ptr, ptr %argv, align 8
  %arrayidx16 = getelementptr inbounds ptr, ptr %22, i64 %indvars.iv
  %23 = load ptr, ptr %arrayidx16, align 8
  tail call void @addReplyBulk(ptr noundef %c, ptr noundef %23) #32
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %24 = load ptr, ptr %loadmod, align 8
  %argc12 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %24, i64 0, i32 1
  %25 = load i32, ptr %argc12, align 8
  %26 = sext i32 %25 to i64
  %cmp13 = icmp slt i64 %indvars.iv.next, %26
  br i1 %cmp13, label %for.body, label %while.cond.loopexit, !llvm.loop !88

while.end:                                        ; preds = %while.cond.loopexit, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #32
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genModulesInfoStringRenderModulesList(ptr noundef %l) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  call void @listRewind(ptr noundef %l, ptr noundef nonnull %li) #32
  %call = call ptr @sdsnew(ptr noundef nonnull @.str.136) #32
  %call16 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not7 = icmp eq ptr %call16, null
  br i1 %tobool.not7, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %tail = getelementptr inbounds %struct.list, ptr %l, i64 0, i32 1
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end
  %call19 = phi ptr [ %call16, %while.body.lr.ph ], [ %call1, %if.end ]
  %output.08 = phi ptr [ %call, %while.body.lr.ph ], [ %output.1, %if.end ]
  %value = getelementptr inbounds %struct.listNode, ptr %call19, i64 0, i32 2
  %0 = load ptr, ptr %value, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 1
  %1 = load ptr, ptr %name, align 8
  %call2 = call ptr @sdscat(ptr noundef %output.08, ptr noundef %1) #32
  %2 = load ptr, ptr %tail, align 8
  %cmp.not = icmp eq ptr %call19, %2
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %call3 = call ptr @sdscat(ptr noundef %call2, ptr noundef nonnull @.str.137) #32
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %output.1 = phi ptr [ %call3, %if.then ], [ %call2, %while.body ]
  %call1 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call1, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !89

while.end:                                        ; preds = %if.end, %entry
  %output.0.lcssa = phi ptr [ %call, %entry ], [ %output.1, %if.end ]
  %call4 = call ptr @sdscat(ptr noundef %output.0.lcssa, ptr noundef nonnull @.str.138) #32
  ret ptr %call4
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genModulesInfoStringRenderModuleOptions(ptr nocapture noundef readonly %module) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @sdsnew(ptr noundef nonnull @.str.136) #32
  %options = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 12
  %0 = load i32, ptr %options, align 4
  %and = and i32 %0, 1
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = tail call ptr @sdscat(ptr noundef %call, ptr noundef nonnull @.str.139) #32
  %.pre = load i32, ptr %options, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = phi i32 [ %.pre, %if.then ], [ %0, %entry ]
  %output.0 = phi ptr [ %call1, %if.then ], [ %call, %entry ]
  %and3 = and i32 %1, 4
  %tobool4.not = icmp eq i32 %and3, 0
  br i1 %tobool4.not, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %call6 = tail call ptr @sdscat(ptr noundef %output.0, ptr noundef nonnull @.str.140) #32
  %.pre8 = load i32, ptr %options, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %2 = phi i32 [ %.pre8, %if.then5 ], [ %1, %if.end ]
  %output.1 = phi ptr [ %call6, %if.then5 ], [ %output.0, %if.end ]
  %and9 = and i32 %2, 2
  %tobool10.not = icmp eq i32 %and9, 0
  br i1 %tobool10.not, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end7
  %call12 = tail call ptr @sdscat(ptr noundef %output.1, ptr noundef nonnull @.str.141) #32
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end7
  %output.2 = phi ptr [ %call12, %if.then11 ], [ %output.1, %if.end7 ]
  %call14 = tail call ptr @sdstrim(ptr noundef %output.2, ptr noundef nonnull @.str.137) #32
  %call15 = tail call ptr @sdscat(ptr noundef %call14, ptr noundef nonnull @.str.138) #32
  ret ptr %call15
}

declare ptr @sdstrim(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @genModulesInfoString(ptr noundef %info) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %0) #32
  %call112 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not13 = icmp eq ptr %call112, null
  br i1 %cmp.not13, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body
  %call115 = phi ptr [ %call1, %while.body ], [ %call112, %entry ]
  %info.addr.014 = phi ptr [ %call9, %while.body ], [ %info, %entry ]
  %call2 = tail call ptr @dictGetKey(ptr noundef nonnull %call115) #32
  %call3 = tail call ptr @dictGetVal(ptr noundef nonnull %call115) #32
  %usedby4 = getelementptr inbounds %struct.RedisModule, ptr %call3, i64 0, i32 5
  %1 = load ptr, ptr %usedby4, align 8
  %call5 = tail call ptr @genModulesInfoStringRenderModulesList(ptr noundef %1)
  %using6 = getelementptr inbounds %struct.RedisModule, ptr %call3, i64 0, i32 6
  %2 = load ptr, ptr %using6, align 8
  %call7 = tail call ptr @genModulesInfoStringRenderModulesList(ptr noundef %2)
  %call8 = tail call ptr @genModulesInfoStringRenderModuleOptions(ptr noundef %call3)
  %ver = getelementptr inbounds %struct.RedisModule, ptr %call3, i64 0, i32 2
  %3 = load i32, ptr %ver, align 8
  %apiver = getelementptr inbounds %struct.RedisModule, ptr %call3, i64 0, i32 3
  %4 = load i32, ptr %apiver, align 4
  %filters = getelementptr inbounds %struct.RedisModule, ptr %call3, i64 0, i32 7
  %5 = load ptr, ptr %filters, align 8
  %len = getelementptr inbounds %struct.list, ptr %5, i64 0, i32 5
  %6 = load i64, ptr %len, align 8
  %conv = trunc i64 %6 to i32
  %call9 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %info.addr.014, ptr noundef nonnull @.str.142, ptr noundef %call2, i32 noundef %3, i32 noundef %4, i32 noundef %conv, ptr noundef %call5, ptr noundef %call7, ptr noundef %call8) #32
  tail call void @sdsfree(ptr noundef %call5) #32
  tail call void @sdsfree(ptr noundef %call7) #32
  tail call void @sdsfree(ptr noundef %call8) #32
  %call1 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !90

while.end:                                        ; preds = %while.body, %entry
  %info.addr.0.lcssa = phi ptr [ %info, %entry ], [ %call9, %while.body ]
  tail call void @dictReleaseIterator(ptr noundef %call) #32
  ret ptr %info.addr.0.lcssa
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isModuleConfigNameRegistered(ptr nocapture noundef readonly %module, ptr noundef %name) local_unnamed_addr #0 {
entry:
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 8
  %0 = load ptr, ptr %module_configs, align 8
  %call = tail call ptr @listSearchKey(ptr noundef %0, ptr noundef %name) #32
  %cmp = icmp ne ptr %call, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleVerifyConfigFlags(i32 noundef %flags, i32 noundef %type) local_unnamed_addr #0 {
entry:
  %conv = zext i32 %flags to i64
  %and = and i64 %conv, 4294966796
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %return.sink.split

if.end:                                           ; preds = %entry
  %cmp.not = icmp eq i32 %type, 1
  %and3 = and i64 %conv, 128
  %tobool4.not = icmp eq i64 %and3, 0
  %or.cond = or i1 %cmp.not, %tobool4.not
  br i1 %or.cond, label %if.end6, label %return.sink.split

if.end6:                                          ; preds = %if.end
  %cmp7.not = icmp eq i32 %type, 4
  %tobool12.not = icmp ult i32 %flags, 256
  %or.cond4 = or i1 %tobool12.not, %cmp7.not
  br i1 %or.cond4, label %return, label %return.sink.split

return.sink.split:                                ; preds = %if.end6, %if.end, %entry
  %.str.145.sink = phi ptr [ @.str.143, %entry ], [ @.str.144, %if.end ], [ @.str.145, %if.end6 ]
  tail call void @serverLogRaw(i32 noundef 3, ptr noundef nonnull %.str.145.sink) #32
  br label %return

return:                                           ; preds = %return.sink.split, %if.end6
  %retval.0 = phi i32 [ 0, %if.end6 ], [ 1, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @setModuleBoolConfig(ptr nocapture noundef readonly %config, i32 noundef %val, ptr nocapture noundef writeonly %err) local_unnamed_addr #0 {
entry:
  %error = alloca ptr, align 8
  store ptr null, ptr %error, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %config, i64 0, i32 3
  %0 = load ptr, ptr %set_fn, align 8
  %1 = load ptr, ptr %config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %config, i64 0, i32 1
  %2 = load ptr, ptr %privdata, align 8
  %call = call i32 %0(ptr noundef %1, i32 noundef %val, ptr noundef %2, ptr noundef nonnull %error) #32
  %3 = load ptr, ptr %error, align 8
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %propagateErrorString.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %ptr.i, align 8
  %call.i = call i64 @redis_strlcpy(ptr noundef nonnull @configerr, ptr noundef %4, i64 noundef 256) #32
  call void @decrRefCount(ptr noundef nonnull %3) #32
  store ptr @configerr, ptr %err, align 8
  br label %propagateErrorString.exit

propagateErrorString.exit:                        ; preds = %entry, %if.then.i
  %cmp = icmp eq i32 %call, 0
  %cond = zext i1 %cmp to i32
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @setModuleStringConfig(ptr nocapture noundef readonly %config, ptr noundef %strval, ptr nocapture noundef writeonly %err) local_unnamed_addr #0 {
entry:
  %error = alloca ptr, align 8
  store ptr null, ptr %error, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %strval, i64 -1
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %strval, i64 -3
  %1 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %1 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %strval, i64 -5
  %2 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %2 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %strval, i64 -9
  %3 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %3 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %strval, i64 -17
  %4 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %4, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call1 = tail call ptr @createStringObject(ptr noundef nonnull %strval, i64 noundef %retval.0.i) #32
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %config, i64 0, i32 3
  %5 = load ptr, ptr %set_fn, align 8
  %6 = load ptr, ptr %config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %config, i64 0, i32 1
  %7 = load ptr, ptr %privdata, align 8
  %call2 = call i32 %5(ptr noundef %6, ptr noundef %call1, ptr noundef %7, ptr noundef nonnull %error) #32
  %8 = load ptr, ptr %error, align 8
  %tobool.not.i = icmp eq ptr %8, null
  br i1 %tobool.not.i, label %propagateErrorString.exit, label %if.then.i

if.then.i:                                        ; preds = %sdslen.exit
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %8, i64 0, i32 2
  %9 = load ptr, ptr %ptr.i, align 8
  %call.i = call i64 @redis_strlcpy(ptr noundef nonnull @configerr, ptr noundef %9, i64 noundef 256) #32
  call void @decrRefCount(ptr noundef nonnull %8) #32
  store ptr @configerr, ptr %err, align 8
  br label %propagateErrorString.exit

propagateErrorString.exit:                        ; preds = %sdslen.exit, %if.then.i
  call void @decrRefCount(ptr noundef %call1) #32
  %cmp = icmp eq i32 %call2, 0
  %cond = zext i1 %cmp to i32
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @setModuleEnumConfig(ptr nocapture noundef readonly %config, i32 noundef %val, ptr nocapture noundef writeonly %err) local_unnamed_addr #0 {
entry:
  %error = alloca ptr, align 8
  store ptr null, ptr %error, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %config, i64 0, i32 3
  %0 = load ptr, ptr %set_fn, align 8
  %1 = load ptr, ptr %config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %config, i64 0, i32 1
  %2 = load ptr, ptr %privdata, align 8
  %call = call i32 %0(ptr noundef %1, i32 noundef %val, ptr noundef %2, ptr noundef nonnull %error) #32
  %3 = load ptr, ptr %error, align 8
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %propagateErrorString.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %ptr.i, align 8
  %call.i = call i64 @redis_strlcpy(ptr noundef nonnull @configerr, ptr noundef %4, i64 noundef 256) #32
  call void @decrRefCount(ptr noundef nonnull %3) #32
  store ptr @configerr, ptr %err, align 8
  br label %propagateErrorString.exit

propagateErrorString.exit:                        ; preds = %entry, %if.then.i
  %cmp = icmp eq i32 %call, 0
  %cond = zext i1 %cmp to i32
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @setModuleNumericConfig(ptr nocapture noundef readonly %config, i64 noundef %val, ptr nocapture noundef writeonly %err) local_unnamed_addr #0 {
entry:
  %error = alloca ptr, align 8
  store ptr null, ptr %error, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %config, i64 0, i32 3
  %0 = load ptr, ptr %set_fn, align 8
  %1 = load ptr, ptr %config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %config, i64 0, i32 1
  %2 = load ptr, ptr %privdata, align 8
  %call = call i32 %0(ptr noundef %1, i64 noundef %val, ptr noundef %2, ptr noundef nonnull %error) #32
  %3 = load ptr, ptr %error, align 8
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %propagateErrorString.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %ptr.i, align 8
  %call.i = call i64 @redis_strlcpy(ptr noundef nonnull @configerr, ptr noundef %4, i64 noundef 256) #32
  call void @decrRefCount(ptr noundef nonnull %3) #32
  store ptr @configerr, ptr %err, align 8
  br label %propagateErrorString.exit

propagateErrorString.exit:                        ; preds = %entry, %if.then.i
  %cmp = icmp eq i32 %call, 0
  %cond = zext i1 %cmp to i32
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getModuleBoolConfig(ptr nocapture noundef readonly %module_config) local_unnamed_addr #0 {
entry:
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 2
  %0 = load ptr, ptr %get_fn, align 8
  %1 = load ptr, ptr %module_config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 1
  %2 = load ptr, ptr %privdata, align 8
  %call = tail call i32 %0(ptr noundef %1, ptr noundef %2) #32
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @getModuleStringConfig(ptr nocapture noundef readonly %module_config) local_unnamed_addr #0 {
entry:
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 2
  %0 = load ptr, ptr %get_fn, align 8
  %1 = load ptr, ptr %module_config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 1
  %2 = load ptr, ptr %privdata, align 8
  %call = tail call ptr %0(ptr noundef %1, ptr noundef %2) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %ptr = getelementptr inbounds %struct.redisObject, ptr %call, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call1 = tail call ptr @sdsdup(ptr noundef %3) #32
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi ptr [ %call1, %cond.true ], [ null, %entry ]
  ret ptr %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getModuleEnumConfig(ptr nocapture noundef readonly %module_config) local_unnamed_addr #0 {
entry:
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 2
  %0 = load ptr, ptr %get_fn, align 8
  %1 = load ptr, ptr %module_config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 1
  %2 = load ptr, ptr %privdata, align 8
  %call = tail call i32 %0(ptr noundef %1, ptr noundef %2) #32
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @getModuleNumericConfig(ptr nocapture noundef readonly %module_config) local_unnamed_addr #0 {
entry:
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 2
  %0 = load ptr, ptr %get_fn, align 8
  %1 = load ptr, ptr %module_config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 1
  %2 = load ptr, ptr %privdata, align 8
  %call = tail call i64 %0(ptr noundef %1, ptr noundef %2) #32
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @loadModuleConfigs(ptr nocapture noundef %module) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %err = alloca ptr, align 8
  store ptr null, ptr %err, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 8
  %0 = load ptr, ptr %module_configs, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #32
  %call15 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not16 = icmp eq ptr %call15, null
  br i1 %tobool.not16, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %name = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 1
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end24
  %call17 = phi ptr [ %call15, %while.body.lr.ph ], [ %call, %if.end24 ]
  %value = getelementptr inbounds %struct.listNode, ptr %call17, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %call1 = call ptr @sdsempty() #32
  %2 = load ptr, ptr %name, align 8
  %3 = load ptr, ptr %1, align 8
  %call3 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call1, ptr noundef nonnull @.str.147, ptr noundef %2, ptr noundef %3) #32
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  %call4 = call ptr @dictFind(ptr noundef %4, ptr noundef %call3) #32
  %tobool5.not = icmp eq ptr %call4, null
  br i1 %tobool5.not, label %if.else, label %if.then

if.then:                                          ; preds = %while.body
  %call6 = call ptr @dictGetKey(ptr noundef nonnull %call4) #32
  %call7 = call ptr @dictGetVal(ptr noundef nonnull %call4) #32
  %call8 = call i32 @performModuleConfigSetFromName(ptr noundef %call6, ptr noundef %call7, ptr noundef nonnull %err) #32
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %do.body, label %if.end24

do.body:                                          ; preds = %if.then
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %5, 3
  br i1 %cmp, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %call12 = call ptr @dictGetKey(ptr noundef nonnull %call4) #32
  %6 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.148, ptr noundef %call12, ptr noundef %6) #32
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  call void @sdsfree(ptr noundef %call3) #32
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  call void @dictEmpty(ptr noundef %7, ptr noundef null) #32
  br label %return

if.else:                                          ; preds = %while.body
  %call14 = call i32 @performModuleConfigSetDefaultFromName(ptr noundef %call3, ptr noundef nonnull %err) #32
  %tobool15.not = icmp eq i32 %call14, 0
  br i1 %tobool15.not, label %do.body17, label %if.end24

do.body17:                                        ; preds = %if.else
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp18 = icmp sgt i32 %8, 3
  br i1 %cmp18, label %do.end22, label %if.end20

if.end20:                                         ; preds = %do.body17
  %9 = load ptr, ptr %1, align 8
  %10 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.149, ptr noundef %9, ptr noundef %10) #32
  br label %do.end22

do.end22:                                         ; preds = %do.body17, %if.end20
  call void @sdsfree(ptr noundef %call3) #32
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  call void @dictEmpty(ptr noundef %11, ptr noundef null) #32
  br label %return

if.end24:                                         ; preds = %if.else, %if.then
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  %call25 = call i32 @dictDelete(ptr noundef %12, ptr noundef %call3) #32
  call void @sdsfree(ptr noundef %call3) #32
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !91

while.end:                                        ; preds = %if.end24, %entry
  %configs_initialized = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 9
  store i32 1, ptr %configs_initialized, align 8
  br label %return

return:                                           ; preds = %while.end, %do.end22, %do.end
  %retval.0 = phi i32 [ 1, %do.end ], [ 1, %do.end22 ], [ 0, %while.end ]
  ret i32 %retval.0
}

declare i32 @performModuleConfigSetFromName(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @dictEmpty(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @performModuleConfigSetDefaultFromName(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @addModuleConfigApply(ptr noundef %module_configs, ptr noundef %module_config) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %apply_fn = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 4
  %0 = load ptr, ptr %apply_fn, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @listRewind(ptr noundef %module_configs, ptr noundef nonnull %li) #32
  %call6 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool1.not7 = icmp eq ptr %call6, null
  br i1 %tobool1.not7, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end
  %privdata4 = getelementptr inbounds %struct.ModuleConfig, ptr %module_config, i64 0, i32 1
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end7
  %call9 = phi ptr [ %call6, %while.body.lr.ph ], [ %call, %if.end7 ]
  %value = getelementptr inbounds %struct.listNode, ptr %call9, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %apply_fn2 = getelementptr inbounds %struct.ModuleConfig, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %apply_fn2, align 8
  %3 = load ptr, ptr %apply_fn, align 8
  %cmp = icmp eq ptr %2, %3
  br i1 %cmp, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %while.body
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %1, i64 0, i32 1
  %4 = load ptr, ptr %privdata, align 8
  %5 = load ptr, ptr %privdata4, align 8
  %cmp5 = icmp eq ptr %4, %5
  br i1 %cmp5, label %return, label %if.end7

if.end7:                                          ; preds = %land.lhs.true, %while.body
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool1.not = icmp eq ptr %call, null
  br i1 %tobool1.not, label %while.end, label %while.body, !llvm.loop !92

while.end:                                        ; preds = %if.end7, %if.end
  %call8 = call ptr @listAddNodeTail(ptr noundef %module_configs, ptr noundef nonnull %module_config) #32
  br label %return

return:                                           ; preds = %land.lhs.true, %entry, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleConfigApplyConfig(ptr noundef %module_configs, ptr nocapture noundef writeonly %err, ptr noundef writeonly %err_arg_name) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %error = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %len = getelementptr inbounds %struct.list, ptr %module_configs, i64 0, i32 5
  %0 = load i64, ptr %len, align 8
  %tobool.not = icmp eq i64 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  store ptr null, ptr %error, align 8
  call void @listRewind(ptr noundef nonnull %module_configs, ptr noundef nonnull %li) #32
  %call6 = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool1.not7 = icmp eq ptr %call6, null
  br i1 %tobool1.not7, label %return, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end
  %1 = getelementptr inbounds i8, ptr %ctx, i64 16
  %module1.i = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 14
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end8
  %call8 = phi ptr [ %call6, %while.body.lr.ph ], [ %call, %if.end8 ]
  %value = getelementptr inbounds %struct.listNode, ptr %call8, i64 0, i32 2
  %3 = load ptr, ptr %value, align 8
  %module = getelementptr inbounds %struct.ModuleConfig, ptr %3, i64 0, i32 5
  %4 = load ptr, ptr %module, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(120) %1, i8 0, i64 104, i1 false)
  store ptr @RM_GetApi, ptr %ctx, align 8
  store ptr %4, ptr %module1.i, align 8
  %5 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool8.not.i = icmp eq i32 %5, 0
  %6 = load ptr, ptr @getMonotonicUs, align 8
  %call12.i = call i64 %6() #32
  br i1 %tobool8.not.i, label %if.else11.i, label %if.then9.i

if.then9.i:                                       ; preds = %while.body
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div.i = sdiv i32 1000000, %7
  %conv.i = sext i32 %div.i to i64
  %add.i = add i64 %call12.i, %conv.i
  br label %moduleCreateContext.exit

if.else11.i:                                      ; preds = %while.body
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 385), align 8
  %mul.i = mul nsw i64 %8, 1000
  %add13.i = add i64 %mul.i, %call12.i
  br label %moduleCreateContext.exit

moduleCreateContext.exit:                         ; preds = %if.then9.i, %if.else11.i
  %add.sink.i = phi i64 [ %add13.i, %if.else11.i ], [ %add.i, %if.then9.i ]
  store i64 %add.sink.i, ptr %2, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #32
  %apply_fn = getelementptr inbounds %struct.ModuleConfig, ptr %3, i64 0, i32 4
  %9 = load ptr, ptr %apply_fn, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %3, i64 0, i32 1
  %10 = load ptr, ptr %privdata, align 8
  %call2 = call i32 %9(ptr noundef nonnull %ctx, ptr noundef %10, ptr noundef nonnull %error) #32
  %tobool3.not = icmp eq i32 %call2, 0
  br i1 %tobool3.not, label %if.end8, label %if.then4

if.then4:                                         ; preds = %moduleCreateContext.exit
  %tobool5.not = icmp eq ptr %err_arg_name, null
  br i1 %tobool5.not, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.then4
  %11 = load ptr, ptr %3, align 8
  store ptr %11, ptr %err_arg_name, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.then4
  %12 = load ptr, ptr %error, align 8
  %tobool.not.i = icmp eq ptr %12, null
  br i1 %tobool.not.i, label %propagateErrorString.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end7
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %12, i64 0, i32 2
  %13 = load ptr, ptr %ptr.i, align 8
  %call.i = call i64 @redis_strlcpy(ptr noundef nonnull @configerr, ptr noundef %13, i64 noundef 256) #32
  call void @decrRefCount(ptr noundef nonnull %12) #32
  store ptr @configerr, ptr %err, align 8
  br label %propagateErrorString.exit

propagateErrorString.exit:                        ; preds = %if.end7, %if.then.i
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  br label %return

if.end8:                                          ; preds = %moduleCreateContext.exit
  call void @moduleFreeContext(ptr noundef nonnull %ctx)
  %call = call ptr @listNext(ptr noundef nonnull %li) #32
  %tobool1.not = icmp eq ptr %call, null
  br i1 %tobool1.not, label %return, label %while.body, !llvm.loop !93

return:                                           ; preds = %if.end8, %if.end, %entry, %propagateErrorString.exit
  %retval.0 = phi i32 [ 0, %propagateErrorString.exit ], [ 1, %entry ], [ 1, %if.end ], [ 1, %if.end8 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noalias noundef ptr @createModuleConfig(ptr noundef %name, ptr noundef %apply_fn, ptr noundef %privdata, ptr noundef %module) local_unnamed_addr #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(48) ptr @zmalloc(i64 noundef 48) #33
  %call1 = tail call ptr @sdsnew(ptr noundef %name) #32
  store ptr %call1, ptr %call, align 8
  %apply_fn3 = getelementptr inbounds %struct.ModuleConfig, ptr %call, i64 0, i32 4
  store ptr %apply_fn, ptr %apply_fn3, align 8
  %privdata4 = getelementptr inbounds %struct.ModuleConfig, ptr %call, i64 0, i32 1
  store ptr %privdata, ptr %privdata4, align 8
  %module5 = getelementptr inbounds %struct.ModuleConfig, ptr %call, i64 0, i32 5
  store ptr %module, ptr %module5, align 8
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleConfigValidityCheck(ptr nocapture noundef readonly %module, ptr noundef %name, i32 noundef %flags, i32 noundef %type) local_unnamed_addr #0 {
entry:
  %onload = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 18
  %0 = load i32, ptr %onload, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return.sink.split, label %if.end

if.end:                                           ; preds = %entry
  %conv.i = zext i32 %flags to i64
  %and.i = and i64 %conv.i, 4294966796
  %tobool.not.i = icmp eq i64 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %moduleVerifyConfigFlags.exit

if.end.i:                                         ; preds = %if.end
  %cmp.not.i = icmp eq i32 %type, 1
  %and3.i = and i64 %conv.i, 128
  %tobool4.not.i = icmp eq i64 %and3.i, 0
  %or.cond.i = or i1 %cmp.not.i, %tobool4.not.i
  br i1 %or.cond.i, label %if.end6.i, label %moduleVerifyConfigFlags.exit

if.end6.i:                                        ; preds = %if.end.i
  %cmp7.not.i = icmp eq i32 %type, 4
  %tobool12.not.i = icmp ult i32 %flags, 256
  %or.cond4.i = or i1 %tobool12.not.i, %cmp7.not.i
  br i1 %or.cond4.i, label %lor.lhs.false, label %moduleVerifyConfigFlags.exit

moduleVerifyConfigFlags.exit:                     ; preds = %if.end, %if.end.i, %if.end6.i
  %.str.145.sink.i = phi ptr [ @.str.143, %if.end ], [ @.str.144, %if.end.i ], [ @.str.145, %if.end6.i ]
  tail call void @serverLogRaw(i32 noundef 3, ptr noundef nonnull %.str.145.sink.i) #32
  br label %return.sink.split

lor.lhs.false:                                    ; preds = %if.end6.i
  %1 = load i8, ptr %name, align 1
  %.fr1921.i = freeze i8 %1
  %cmp.i = icmp eq i8 %.fr1921.i, 0
  br i1 %cmp.i, label %return.sink.split, label %for.body.i

for.body.i:                                       ; preds = %lor.lhs.false, %for.inc.i
  %.fr1924.i = phi i8 [ %.fr19.i, %for.inc.i ], [ %.fr1921.i, %lor.lhs.false ]
  %i.023.i = phi i64 [ %inc.i, %for.inc.i ], [ 0, %lor.lhs.false ]
  %2 = and i8 %.fr1924.i, -33
  %3 = add i8 %2, -65
  %or.cond18.i = icmp ult i8 %3, 26
  %4 = add i8 %.fr1924.i, -48
  %or.cond2.i = icmp ult i8 %4, 10
  %or.cond.i4 = or i1 %or.cond2.i, %or.cond18.i
  br i1 %or.cond.i4, label %for.inc.i, label %switch.early.test.i

switch.early.test.i:                              ; preds = %for.body.i
  switch i8 %.fr1924.i, label %do.body.i [
    i8 95, label %for.inc.i
    i8 45, label %for.inc.i
  ]

do.body.i:                                        ; preds = %switch.early.test.i
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp38.i = icmp sgt i32 %5, 3
  br i1 %cmp38.i, label %return.sink.split, label %if.end41.i

if.end41.i:                                       ; preds = %do.body.i
  %conv3.le.i = sext i8 %.fr1924.i to i32
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.146, i32 noundef %conv3.le.i, ptr noundef nonnull %name) #32
  br label %return.sink.split

for.inc.i:                                        ; preds = %switch.early.test.i, %switch.early.test.i, %for.body.i
  %inc.i = add i64 %i.023.i, 1
  %arrayidx2.i = getelementptr inbounds i8, ptr %name, i64 %inc.i
  %6 = load i8, ptr %arrayidx2.i, align 1
  %.fr19.i = freeze i8 %6
  %cmp4.not.i = icmp eq i8 %.fr19.i, 0
  br i1 %cmp4.not.i, label %if.end7, label %for.body.i, !llvm.loop !16

if.end7:                                          ; preds = %for.inc.i
  %module_configs.i = getelementptr inbounds %struct.RedisModule, ptr %module, i64 0, i32 8
  %7 = load ptr, ptr %module_configs.i, align 8
  %call.i = tail call ptr @listSearchKey(ptr noundef %7, ptr noundef nonnull %name) #32
  %cmp.i6.not = icmp eq ptr %call.i, null
  br i1 %cmp.i6.not, label %return, label %do.body

do.body:                                          ; preds = %if.end7
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %8, 3
  br i1 %cmp, label %return.sink.split, label %if.end12

if.end12:                                         ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.150, ptr noundef nonnull %name) #32
  br label %return.sink.split

return.sink.split:                                ; preds = %if.end12, %do.body, %moduleVerifyConfigFlags.exit, %lor.lhs.false, %do.body.i, %if.end41.i, %entry
  %.sink = phi i32 [ 16, %entry ], [ 22, %if.end41.i ], [ 22, %do.body.i ], [ 22, %lor.lhs.false ], [ 22, %moduleVerifyConfigFlags.exit ], [ 114, %do.body ], [ 114, %if.end12 ]
  %call13 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call13, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %if.end7
  %retval.0 = phi i32 [ 0, %if.end7 ], [ 1, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @maskModuleConfigFlags(i32 noundef %flags) local_unnamed_addr #22 {
entry:
  %new_flags.4 = and i32 %flags, 113
  ret i32 %new_flags.4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @maskModuleNumericConfigFlags(i32 noundef %flags) local_unnamed_addr #22 {
entry:
  %0 = lshr i32 %flags, 7
  %.lobit = and i32 %0, 1
  ret i32 %.lobit
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @maskModuleEnumConfigFlags(i32 noundef %flags) local_unnamed_addr #22 {
entry:
  %0 = lshr i32 %flags, 5
  %spec.select = and i32 %0, 8
  ret i32 %spec.select
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_RegisterStringConfig(ptr nocapture noundef readonly %ctx, ptr noundef %name, ptr noundef %default_val, i32 noundef %flags, ptr noundef %getfn, ptr noundef %setfn, ptr noundef %applyfn, ptr noundef %privdata) #0 {
entry:
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module1, align 8
  %call = tail call i32 @moduleConfigValidityCheck(ptr noundef %0, ptr noundef %name, i32 noundef %flags, i32 noundef 1), !range !22
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call.i = tail call noalias dereferenceable_or_null(48) ptr @zmalloc(i64 noundef 48) #33
  %call1.i = tail call ptr @sdsnew(ptr noundef %name) #32
  store ptr %call1.i, ptr %call.i, align 8
  %apply_fn3.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 4
  store ptr %applyfn, ptr %apply_fn3.i, align 8
  %privdata4.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 1
  store ptr %privdata, ptr %privdata4.i, align 8
  %module5.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 5
  store ptr %0, ptr %module5.i, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 2
  store ptr %getfn, ptr %get_fn, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 3
  store ptr %setfn, ptr %set_fn, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 8
  %1 = load ptr, ptr %module_configs, align 8
  %call3 = tail call ptr @listAddNodeTail(ptr noundef %1, ptr noundef nonnull %call.i) #32
  %new_flags.4.i = and i32 %flags, 113
  %name5 = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 1
  %2 = load ptr, ptr %name5, align 8
  %tobool6.not = icmp eq ptr %default_val, null
  br i1 %tobool6.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.end
  %call7 = tail call ptr @sdsnew(ptr noundef nonnull %default_val) #32
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %if.end ]
  tail call void @addModuleStringConfig(ptr noundef %2, ptr noundef %name, i32 noundef %new_flags.4.i, ptr noundef nonnull %call.i, ptr noundef %cond) #32
  br label %return

return:                                           ; preds = %entry, %cond.end
  %retval.0 = phi i32 [ 0, %cond.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @addModuleStringConfig(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_RegisterBoolConfig(ptr nocapture noundef readonly %ctx, ptr noundef %name, i32 noundef %default_val, i32 noundef %flags, ptr noundef %getfn, ptr noundef %setfn, ptr noundef %applyfn, ptr noundef %privdata) #0 {
entry:
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module1, align 8
  %call = tail call i32 @moduleConfigValidityCheck(ptr noundef %0, ptr noundef %name, i32 noundef %flags, i32 noundef 0), !range !22
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call.i = tail call noalias dereferenceable_or_null(48) ptr @zmalloc(i64 noundef 48) #33
  %call1.i = tail call ptr @sdsnew(ptr noundef %name) #32
  store ptr %call1.i, ptr %call.i, align 8
  %apply_fn3.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 4
  store ptr %applyfn, ptr %apply_fn3.i, align 8
  %privdata4.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 1
  store ptr %privdata, ptr %privdata4.i, align 8
  %module5.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 5
  store ptr %0, ptr %module5.i, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 2
  store ptr %getfn, ptr %get_fn, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 3
  store ptr %setfn, ptr %set_fn, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 8
  %1 = load ptr, ptr %module_configs, align 8
  %call3 = tail call ptr @listAddNodeTail(ptr noundef %1, ptr noundef nonnull %call.i) #32
  %new_flags.4.i = and i32 %flags, 113
  %name5 = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 1
  %2 = load ptr, ptr %name5, align 8
  tail call void @addModuleBoolConfig(ptr noundef %2, ptr noundef %name, i32 noundef %new_flags.4.i, ptr noundef nonnull %call.i, i32 noundef %default_val) #32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @addModuleBoolConfig(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_RegisterEnumConfig(ptr nocapture noundef readonly %ctx, ptr noundef %name, i32 noundef %default_val, i32 noundef %flags, ptr nocapture noundef readonly %enum_values, ptr nocapture noundef readonly %int_values, i32 noundef %num_enum_vals, ptr noundef %getfn, ptr noundef %setfn, ptr noundef %applyfn, ptr noundef %privdata) #0 {
entry:
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module1, align 8
  %call = tail call i32 @moduleConfigValidityCheck(ptr noundef %0, ptr noundef %name, i32 noundef %flags, i32 noundef 4), !range !22
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call.i = tail call noalias dereferenceable_or_null(48) ptr @zmalloc(i64 noundef 48) #33
  %call1.i = tail call ptr @sdsnew(ptr noundef %name) #32
  store ptr %call1.i, ptr %call.i, align 8
  %apply_fn3.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 4
  store ptr %applyfn, ptr %apply_fn3.i, align 8
  %privdata4.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 1
  store ptr %privdata, ptr %privdata4.i, align 8
  %module5.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 5
  store ptr %0, ptr %module5.i, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 2
  store ptr %getfn, ptr %get_fn, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 3
  store ptr %setfn, ptr %set_fn, align 8
  %add = add nsw i32 %num_enum_vals, 1
  %conv = sext i32 %add to i64
  %mul = shl nsw i64 %conv, 4
  %call3 = tail call noalias ptr @zmalloc(i64 noundef %mul) #33
  %cmp24 = icmp sgt i32 %num_enum_vals, 0
  br i1 %cmp24, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %if.end
  %wide.trip.count = zext nneg i32 %num_enum_vals to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds ptr, ptr %enum_values, i64 %indvars.iv
  %1 = load ptr, ptr %arrayidx, align 8
  %call5 = tail call noalias ptr @zstrdup(ptr noundef %1) #32
  %arrayidx7 = getelementptr inbounds %struct.configEnum, ptr %call3, i64 %indvars.iv
  store ptr %call5, ptr %arrayidx7, align 8
  %arrayidx10 = getelementptr inbounds i32, ptr %int_values, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx10, align 4
  %val = getelementptr inbounds %struct.configEnum, ptr %call3, i64 %indvars.iv, i32 1
  store i32 %2, ptr %val, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !94

for.end:                                          ; preds = %for.body, %if.end
  %idxprom13 = sext i32 %num_enum_vals to i64
  %arrayidx14 = getelementptr inbounds %struct.configEnum, ptr %call3, i64 %idxprom13
  store ptr null, ptr %arrayidx14, align 8
  %val18 = getelementptr inbounds %struct.configEnum, ptr %call3, i64 %idxprom13, i32 1
  store i32 0, ptr %val18, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 8
  %3 = load ptr, ptr %module_configs, align 8
  %call19 = tail call ptr @listAddNodeTail(ptr noundef %3, ptr noundef nonnull %call.i) #32
  %new_flags.4.i = and i32 %flags, 113
  %4 = lshr i32 %flags, 5
  %spec.select.i = and i32 %4, 8
  %or = or disjoint i32 %spec.select.i, %new_flags.4.i
  %name22 = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 1
  %5 = load ptr, ptr %name22, align 8
  tail call void @addModuleEnumConfig(ptr noundef %5, ptr noundef %name, i32 noundef %or, ptr noundef nonnull %call.i, i32 noundef %default_val, ptr noundef %call3) #32
  br label %return

return:                                           ; preds = %entry, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @addModuleEnumConfig(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_RegisterNumericConfig(ptr nocapture noundef readonly %ctx, ptr noundef %name, i64 noundef %default_val, i32 noundef %flags, i64 noundef %min, i64 noundef %max, ptr noundef %getfn, ptr noundef %setfn, ptr noundef %applyfn, ptr noundef %privdata) #0 {
entry:
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module1, align 8
  %call = tail call i32 @moduleConfigValidityCheck(ptr noundef %0, ptr noundef %name, i32 noundef %flags, i32 noundef 1), !range !22
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call.i = tail call noalias dereferenceable_or_null(48) ptr @zmalloc(i64 noundef 48) #33
  %call1.i = tail call ptr @sdsnew(ptr noundef %name) #32
  store ptr %call1.i, ptr %call.i, align 8
  %apply_fn3.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 4
  store ptr %applyfn, ptr %apply_fn3.i, align 8
  %privdata4.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 1
  store ptr %privdata, ptr %privdata4.i, align 8
  %module5.i = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 5
  store ptr %0, ptr %module5.i, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 2
  store ptr %getfn, ptr %get_fn, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %call.i, i64 0, i32 3
  store ptr %setfn, ptr %set_fn, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 8
  %1 = load ptr, ptr %module_configs, align 8
  %call3 = tail call ptr @listAddNodeTail(ptr noundef %1, ptr noundef nonnull %call.i) #32
  %2 = lshr i32 %flags, 7
  %.lobit.i = and i32 %2, 1
  %new_flags.4.i = and i32 %flags, 113
  %name6 = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 1
  %3 = load ptr, ptr %name6, align 8
  tail call void @addModuleNumericConfig(ptr noundef %3, ptr noundef %name, i32 noundef %new_flags.4.i, ptr noundef nonnull %call.i, i64 noundef %default_val, i32 noundef %.lobit.i, i64 noundef %min, i64 noundef %max) #32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

declare void @addModuleNumericConfig(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i64 noundef, i32 noundef, i64 noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_LoadConfigs(ptr noundef readonly %ctx) #0 {
entry:
  %tobool.not = icmp eq ptr %ctx, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %onload = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 18
  %1 = load i32, ptr %onload, align 4
  %tobool4.not = icmp eq i32 %1, 0
  br i1 %tobool4.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false2
  %call = tail call i32 @loadModuleConfigs(ptr noundef nonnull %0), !range !22
  br label %return

return:                                           ; preds = %if.end, %entry, %lor.lhs.false, %lor.lhs.false2
  %retval.0 = phi i32 [ 1, %lor.lhs.false2 ], [ 1, %lor.lhs.false ], [ 1, %entry ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noalias noundef ptr @RM_RdbStreamCreateFromFile(ptr noundef %filename) #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #33
  store i32 1, ptr %call, align 8
  %call1 = tail call noalias ptr @zstrdup(ptr noundef %filename) #32
  %data = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %call, i64 0, i32 1
  store ptr %call1, ptr %data, align 8
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_RdbStreamFree(ptr noundef %stream) #0 {
entry:
  %0 = load i32, ptr %stream, align 8
  %cond = icmp eq i32 %0, 1
  br i1 %cond, label %sw.bb, label %sw.default

sw.bb:                                            ; preds = %entry
  %data = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %stream, i64 0, i32 1
  %1 = load ptr, ptr %data, align 8
  tail call void @zfree(ptr noundef %1) #32
  tail call void @zfree(ptr noundef nonnull %stream) #32
  ret void

sw.default:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.2, i32 noundef 12904) #32
  tail call void @abort() #35
  unreachable
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_RdbLoad(ptr nocapture readnone %ctx, ptr noundef readonly %stream, i32 noundef %flags) #0 {
entry:
  %tobool = icmp eq ptr %stream, null
  %cmp = icmp ne i32 %flags, 0
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp1.not = icmp eq ptr %0, null
  br i1 %cmp1.not, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  tail call void @disconnectSlaves() #32
  tail call void @freeReplicationBacklog() #32
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp5.not = icmp eq i32 %1, 0
  br i1 %cmp5.not, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  tail call void @stopAppendOnly() #32
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end4
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  %cmp8 = icmp eq i32 %2, 1
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  tail call void @killRDBChild() #32
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %call11 = tail call i64 @emptyData(i32 noundef -1, i32 noundef 0, ptr noundef null) #32
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %tobool12.not = icmp eq ptr %3, null
  br i1 %tobool12.not, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end10
  tail call void @protectClient(ptr noundef nonnull %3) #32
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %4 = load i32, ptr %stream, align 8
  %cmp15 = icmp eq i32 %4, 1
  br i1 %cmp15, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end14
  tail call void @_serverAssert(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 12956) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.end14
  %data = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %stream, i64 0, i32 1
  %5 = load ptr, ptr %data, align 8
  %call18 = tail call i32 @rdbLoad(ptr noundef %5, ptr noundef null, i32 noundef 0) #32
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %tobool19.not = icmp eq ptr %6, null
  br i1 %tobool19.not, label %if.end21, label %if.then20

if.then20:                                        ; preds = %cond.end
  tail call void @unprotectClient(ptr noundef nonnull %6) #32
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %cond.end
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp22.not = icmp eq i32 %7, 0
  br i1 %cmp22.not, label %if.end26, label %if.then24

if.then24:                                        ; preds = %if.end21
  %call25 = tail call i32 @startAppendOnly() #32
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %cmp27.not = icmp eq i32 %call18, 0
  br i1 %cmp27.not, label %return, label %if.then29

if.then29:                                        ; preds = %if.end26
  %cmp30 = icmp eq i32 %call18, 1
  %cond = select i1 %cmp30, i32 2, i32 5
  br label %return

return:                                           ; preds = %if.end26, %if.end, %entry, %if.then29
  %.sink = phi i32 [ %cond, %if.then29 ], [ 22, %entry ], [ 95, %if.end ], [ 0, %if.end26 ]
  %retval.0 = phi i32 [ 1, %if.then29 ], [ 1, %entry ], [ 1, %if.end ], [ 0, %if.end26 ]
  %call34 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call34, align 4
  ret i32 %retval.0
}

declare void @disconnectSlaves() local_unnamed_addr #1

declare void @freeReplicationBacklog() local_unnamed_addr #1

declare void @killRDBChild() local_unnamed_addr #1

declare i64 @emptyData(i32 noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

declare i32 @rdbLoad(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

declare i32 @startAppendOnly() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_RdbSave(ptr nocapture readnone %ctx, ptr noundef readonly %stream, i32 noundef %flags) #0 {
entry:
  %tobool = icmp eq ptr %stream, null
  %cmp = icmp ne i32 %flags, 0
  %or.cond = or i1 %tobool, %cmp
  br i1 %or.cond, label %return.sink.split, label %if.end

if.end:                                           ; preds = %entry
  %0 = load i32, ptr %stream, align 8
  %cmp1 = icmp eq i32 %0, 1
  br i1 %cmp1, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.152, ptr noundef nonnull @.str.2, i32 noundef 12992) #32
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.end
  %data = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %stream, i64 0, i32 1
  %1 = load ptr, ptr %data, align 8
  %call4 = tail call i32 @rdbSaveToFile(ptr noundef %1) #32
  %cmp5.not = icmp eq i32 %call4, 0
  br i1 %cmp5.not, label %return.sink.split, label %return

return.sink.split:                                ; preds = %cond.end, %entry
  %.sink = phi i32 [ 22, %entry ], [ 0, %cond.end ]
  %retval.0.ph = phi i32 [ 1, %entry ], [ 0, %cond.end ]
  %call9 = tail call ptr @__errno_location() #37
  store i32 %.sink, ptr %call9, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %cond.end
  %retval.0 = phi i32 [ 1, %cond.end ], [ %retval.0.ph, %return.sink.split ]
  ret i32 %retval.0
}

declare i32 @rdbSaveToFile(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %help = alloca [9 x ptr], align 16
  %argv30 = alloca ptr, align 8
  %argc31 = alloca i32, align 4
  %errmsg = alloca ptr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %0 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 1
  %1 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %3 = load i32, ptr %argc, align 8
  %cmp = icmp ne i32 %3, 2
  br i1 %cmp, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.153) #36
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %if.else23

if.then:                                          ; preds = %land.lhs.true
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(72) %help, ptr noundef nonnull align 16 dereferenceable(72) @__const.moduleCommand.help, i64 72, i1 false)
  call void @addReplyHelp(ptr noundef nonnull %c, ptr noundef nonnull %help) #32
  br label %if.end87

if.else:                                          ; preds = %entry
  %call1 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.162) #36
  %tobool2.not = icmp eq i32 %call1, 0
  %cmp5 = icmp sgt i32 %3, 2
  %or.cond = and i1 %cmp5, %tobool2.not
  br i1 %or.cond, label %if.then6, label %if.else23

if.then6:                                         ; preds = %if.else
  %cmp10.not = icmp eq i32 %3, 3
  %sub = add nsw i32 %3, -3
  %arrayidx14 = getelementptr inbounds ptr, ptr %0, i64 3
  %argv7.0 = select i1 %cmp10.not, ptr null, ptr %arrayidx14
  %arrayidx16 = getelementptr inbounds ptr, ptr %0, i64 2
  %4 = load ptr, ptr %arrayidx16, align 8
  %ptr17 = getelementptr inbounds %struct.redisObject, ptr %4, i64 0, i32 2
  %5 = load ptr, ptr %ptr17, align 8
  %call18 = tail call i32 @moduleLoad(ptr noundef %5, ptr noundef %argv7.0, i32 noundef %sub, i32 noundef 0), !range !74
  %cmp19 = icmp eq i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.then6
  %6 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %6) #32
  br label %if.end87

if.else21:                                        ; preds = %if.then6
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.163) #32
  br label %if.end87

if.else23:                                        ; preds = %land.lhs.true, %if.else
  %call24 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.164) #36
  %tobool25.not = icmp eq i32 %call24, 0
  %cmp28 = icmp sgt i32 %3, 2
  %or.cond33 = and i1 %cmp28, %tobool25.not
  br i1 %or.cond33, label %if.then29, label %if.else51

if.then29:                                        ; preds = %if.else23
  store ptr null, ptr %argv30, align 8
  store i32 0, ptr %argc31, align 4
  %cmp33 = icmp ugt i32 %3, 3
  br i1 %cmp33, label %if.then34, label %if.end39

if.then34:                                        ; preds = %if.then29
  %sub36 = add nsw i32 %3, -3
  store i32 %sub36, ptr %argc31, align 4
  %arrayidx38 = getelementptr inbounds ptr, ptr %0, i64 3
  store ptr %arrayidx38, ptr %argv30, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.then34, %if.then29
  %call40 = call i32 @parseLoadexArguments(ptr noundef nonnull %argv30, ptr noundef nonnull %argc31), !range !22
  %cmp41 = icmp eq i32 %call40, 0
  br i1 %cmp41, label %land.lhs.true42, label %if.else49

land.lhs.true42:                                  ; preds = %if.end39
  %7 = load ptr, ptr %argv, align 8
  %arrayidx44 = getelementptr inbounds ptr, ptr %7, i64 2
  %8 = load ptr, ptr %arrayidx44, align 8
  %ptr45 = getelementptr inbounds %struct.redisObject, ptr %8, i64 0, i32 2
  %9 = load ptr, ptr %ptr45, align 8
  %10 = load ptr, ptr %argv30, align 8
  %11 = load i32, ptr %argc31, align 4
  %call46 = tail call i32 @moduleLoad(ptr noundef %9, ptr noundef %10, i32 noundef %11, i32 noundef 1), !range !74
  %cmp47 = icmp eq i32 %call46, 0
  br i1 %cmp47, label %if.then48, label %if.else49

if.then48:                                        ; preds = %land.lhs.true42
  %12 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %12) #32
  br label %if.end87

if.else49:                                        ; preds = %land.lhs.true42, %if.end39
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 39), align 8
  tail call void @dictEmpty(ptr noundef %13, ptr noundef null) #32
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.163) #32
  br label %if.end87

if.else51:                                        ; preds = %if.else23
  %call52 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.165) #36
  %tobool53.not = icmp eq i32 %call52, 0
  %cmp56 = icmp eq i32 %3, 3
  %or.cond34 = and i1 %cmp56, %tobool53.not
  br i1 %or.cond34, label %if.then57, label %if.else75

if.then57:                                        ; preds = %if.else51
  store ptr null, ptr %errmsg, align 8
  %arrayidx59 = getelementptr inbounds ptr, ptr %0, i64 2
  %14 = load ptr, ptr %arrayidx59, align 8
  %ptr60 = getelementptr inbounds %struct.redisObject, ptr %14, i64 0, i32 2
  %15 = load ptr, ptr %ptr60, align 8
  %call61 = call i32 @moduleUnload(ptr noundef %15, ptr noundef nonnull %errmsg), !range !74
  %cmp62 = icmp eq i32 %call61, 0
  br i1 %cmp62, label %if.then63, label %if.else64

if.then63:                                        ; preds = %if.then57
  %16 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %16) #32
  br label %if.end87

if.else64:                                        ; preds = %if.then57
  %17 = load ptr, ptr %errmsg, align 8
  %cmp65 = icmp eq ptr %17, null
  %spec.store.select = select i1 %cmp65, ptr @.str.166, ptr %17
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.167, ptr noundef nonnull %spec.store.select) #32
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp68 = icmp sgt i32 %18, 3
  br i1 %cmp68, label %if.end87, label %if.end70

if.end70:                                         ; preds = %if.else64
  %19 = load ptr, ptr %argv, align 8
  %arrayidx72 = getelementptr inbounds ptr, ptr %19, i64 2
  %20 = load ptr, ptr %arrayidx72, align 8
  %ptr73 = getelementptr inbounds %struct.redisObject, ptr %20, i64 0, i32 2
  %21 = load ptr, ptr %ptr73, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.168, ptr noundef %21, ptr noundef nonnull %spec.store.select) #32
  br label %if.end87

if.else75:                                        ; preds = %if.else51
  %call76 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.169) #36
  %tobool77.not = icmp ne i32 %call76, 0
  %brmerge = or i1 %cmp, %tobool77.not
  br i1 %brmerge, label %if.else82, label %if.then81

if.then81:                                        ; preds = %if.else75
  tail call void @addReplyLoadedModules(ptr noundef nonnull %c)
  br label %if.end87

if.else82:                                        ; preds = %if.else75
  tail call void @addReplySubcommandSyntaxError(ptr noundef nonnull %c) #32
  br label %if.end87

if.end87:                                         ; preds = %if.else21, %if.then20, %if.then81, %if.end70, %if.else64, %if.then63, %if.then48, %if.else49, %if.else82, %if.then
  ret void
}

declare void @addReplyHelp(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @addReplySubcommandSyntaxError(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i64 @moduleCount() local_unnamed_addr #11 {
entry:
  %0 = load ptr, ptr @modules, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %0, i64 0, i32 2
  %1 = load i64, ptr %ht_used, align 8
  %arrayidx2 = getelementptr inbounds %struct.dict, ptr %0, i64 0, i32 2, i64 1
  %2 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %2, %1
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetLRU(ptr nocapture noundef readonly %key, i64 noundef %lru_idle) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp sgt i64 %lru_idle, -1
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %call = tail call i32 @LRU_CLOCK() #32
  %1 = zext i32 %call to i64
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi i64 [ %1, %cond.true ], [ 0, %if.end ]
  %call2 = tail call i32 @objectSetLRUOrLFU(ptr noundef nonnull %0, i64 noundef -1, i64 noundef %lru_idle, i64 noundef %cond, i32 noundef 1) #32
  %tobool3.not = icmp eq i32 %call2, 0
  %. = zext i1 %tobool3.not to i32
  br label %return

return:                                           ; preds = %cond.end, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ %., %cond.end ]
  ret i32 %retval.0
}

declare i32 @objectSetLRUOrLFU(ptr noundef, i64 noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #1

declare i32 @LRU_CLOCK() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_GetLRU(ptr nocapture noundef readonly %key, ptr nocapture noundef writeonly %lru_idle) #0 {
entry:
  store i64 -1, ptr %lru_idle, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 316), align 8
  %and = and i32 %1, 2
  %tobool1.not = icmp eq i32 %and, 0
  br i1 %tobool1.not, label %if.end3, label %return

if.end3:                                          ; preds = %if.end
  %call = tail call i64 @estimateObjectIdleTime(ptr noundef nonnull %0) #32
  store i64 %call, ptr %lru_idle, align 8
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi i32 [ 0, %if.end3 ], [ 1, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare i64 @estimateObjectIdleTime(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetLFU(ptr nocapture noundef readonly %key, i64 noundef %lfu_freq) #0 {
entry:
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call i32 @objectSetLRUOrLFU(ptr noundef nonnull %0, i64 noundef %lfu_freq, i64 noundef -1, i64 noundef 0, i32 noundef 1) #32
  %tobool2.not = icmp eq i32 %call, 0
  %. = zext i1 %tobool2.not to i32
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @RM_GetLFU(ptr nocapture noundef readonly %key, ptr nocapture noundef writeonly %lfu_freq) #0 {
entry:
  store i64 -1, ptr %lfu_freq, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %0 = load ptr, ptr %value, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 316), align 8
  %and = and i32 %1, 2
  %tobool1.not = icmp eq i32 %and, 0
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.end
  %call = tail call i64 @LFUDecrAndReturn(ptr noundef nonnull %0) #32
  store i64 %call, ptr %lfu_freq, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then2, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %if.then2 ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare i64 @LFUDecrAndReturn(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @RM_GetModuleOptionsAll() #22 {
entry:
  ret i32 15
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @RM_GetContextFlagsAll() #22 {
entry:
  ret i32 33554431
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @RM_GetKeyspaceNotificationFlagsAll() #22 {
entry:
  ret i32 32767
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @RM_GetServerVersion() #22 {
entry:
  ret i32 16777215
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @RM_GetTypeMethodVersion() #22 {
entry:
  ret i32 5
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable
define dso_local noundef i32 @RM_ModuleTypeReplaceValue(ptr nocapture noundef readonly %key, ptr noundef readnone %mt, ptr noundef %new_value, ptr noundef writeonly %old_value) #28 {
entry:
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 5
  %0 = load i32, ptr %mode, align 8
  %and = and i32 %0, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %key, i64 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %tobool2.not = icmp eq ptr %2, null
  br i1 %tobool2.not, label %return, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.end
  %bf.load = load i32, ptr %2, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp.not = icmp eq i32 %bf.clear, 5
  br i1 %cmp.not, label %if.end6, label %return

if.end6:                                          ; preds = %lor.lhs.false3
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %4 = load ptr, ptr %3, align 8
  %cmp8.not = icmp eq ptr %4, %mt
  br i1 %cmp8.not, label %if.end10, label %return

if.end10:                                         ; preds = %if.end6
  %tobool11.not = icmp eq ptr %old_value, null
  br i1 %tobool11.not, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.end10
  %value13 = getelementptr inbounds %struct.moduleValue, ptr %3, i64 0, i32 1
  %5 = load ptr, ptr %value13, align 8
  store ptr %5, ptr %old_value, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %value15 = getelementptr inbounds %struct.moduleValue, ptr %3, i64 0, i32 1
  store ptr %new_value, ptr %value15, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.end, %lor.lhs.false3, %entry, %lor.lhs.false, %if.end14
  %retval.0 = phi i32 [ 0, %if.end14 ], [ 1, %lor.lhs.false ], [ 1, %entry ], [ 1, %lor.lhs.false3 ], [ 1, %if.end ], [ 1, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noalias ptr @RM_GetCommandKeysWithFlags(ptr nocapture readnone %ctx, ptr noundef %argv, i32 noundef %argc, ptr nocapture noundef writeonly %num_keys, ptr noundef %out_flags) #0 {
entry:
  %result = alloca %struct.getKeysResult, align 8
  %call = tail call ptr @lookupCommand(ptr noundef %argv, i32 noundef %argc) #32
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call ptr @__errno_location() #37
  store i32 2, ptr %call1, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call2 = tail call i32 @doesCommandHaveKeys(ptr noundef nonnull %call) #32
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = tail call ptr @__errno_location() #37
  store i32 0, ptr %call4, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %arity = getelementptr inbounds %struct.redisCommand, ptr %call, i64 0, i32 13
  %0 = load i32, ptr %arity, align 8
  %cmp6 = icmp sgt i32 %0, 0
  %cmp8.not = icmp ne i32 %0, %argc
  %or.cond.not21 = and i1 %cmp6, %cmp8.not
  %sub = sub nsw i32 0, %0
  %cmp10 = icmp sgt i32 %sub, %argc
  %or.cond20 = select i1 %or.cond.not21, i1 true, i1 %cmp10
  br i1 %or.cond20, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end5
  %call12 = tail call ptr @__errno_location() #37
  store i32 22, ptr %call12, align 4
  br label %return

if.end13:                                         ; preds = %if.end5
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2064) %result, i8 0, i64 2064, i1 false)
  %1 = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 3
  store i32 256, ptr %1, align 4
  %call14 = call i32 @getKeysFromCommand(ptr noundef nonnull %call, ptr noundef %argv, i32 noundef %argc, ptr noundef nonnull %result) #32
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 2
  %2 = load i32, ptr %numkeys, align 8
  store i32 %2, ptr %num_keys, align 4
  %tobool16.not = icmp eq i32 %2, 0
  br i1 %tobool16.not, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end13
  %call18 = tail call ptr @__errno_location() #37
  store i32 0, ptr %call18, align 4
  call void @getKeysFreeResult(ptr noundef nonnull %result) #32
  br label %return

if.end19:                                         ; preds = %if.end13
  %conv = sext i32 %2 to i64
  %mul = shl nsw i64 %conv, 2
  %call21 = call noalias ptr @zmalloc(i64 noundef %mul) #33
  %tobool22.not = icmp eq ptr %out_flags, null
  br i1 %tobool22.not, label %if.end25, label %if.end25.thread

if.end25:                                         ; preds = %if.end19
  %3 = load i32, ptr %numkeys, align 8
  %cmp2722 = icmp sgt i32 %3, 0
  br i1 %cmp2722, label %for.body.lr.ph.split.us, label %return

if.end25.thread:                                  ; preds = %if.end19
  %call24 = call noalias ptr @zmalloc(i64 noundef %mul) #33
  store ptr %call24, ptr %out_flags, align 8
  %4 = load i32, ptr %numkeys, align 8
  %cmp272229 = icmp sgt i32 %4, 0
  br i1 %cmp272229, label %for.body.preheader, label %return

for.body.preheader:                               ; preds = %if.end25.thread
  %keys30 = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 1
  br label %for.body

for.body.lr.ph.split.us:                          ; preds = %if.end25
  %keys = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 1
  %5 = load ptr, ptr %keys, align 8
  %wide.trip.count = zext nneg i32 %3 to i64
  br label %for.body.us

for.body.us:                                      ; preds = %for.body.us, %for.body.lr.ph.split.us
  %indvars.iv26 = phi i64 [ %indvars.iv.next27, %for.body.us ], [ 0, %for.body.lr.ph.split.us ]
  %arrayidx.us = getelementptr inbounds %struct.keyReference, ptr %5, i64 %indvars.iv26
  %6 = load i32, ptr %arrayidx.us, align 4
  %arrayidx30.us = getelementptr inbounds i32, ptr %call21, i64 %indvars.iv26
  store i32 %6, ptr %arrayidx30.us, align 4
  %indvars.iv.next27 = add nuw nsw i64 %indvars.iv26, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next27, %wide.trip.count
  br i1 %exitcond.not, label %return, label %for.body.us, !llvm.loop !95

for.body:                                         ; preds = %for.body.preheader, %moduleConvertKeySpecsFlags.exit
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %moduleConvertKeySpecsFlags.exit ]
  %7 = load ptr, ptr %keys30, align 8
  %arrayidx = getelementptr inbounds %struct.keyReference, ptr %7, i64 %indvars.iv
  %8 = load i32, ptr %arrayidx, align 4
  %arrayidx30 = getelementptr inbounds i32, ptr %call21, i64 %indvars.iv
  store i32 %8, ptr %arrayidx30, align 4
  %flags = getelementptr inbounds %struct.keyReference, ptr %7, i64 %indvars.iv, i32 1
  %9 = load i32, ptr %flags, align 4
  %conv36 = sext i32 %9 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %for.body
  %indvars.iv.i = phi i64 [ 0, %for.body ], [ %indvars.iv.next.i, %for.inc.i ]
  %out.06.i = phi i64 [ 0, %for.body ], [ %out.1.i, %for.inc.i ]
  %arrayidx7.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 1
  %10 = load i64, ptr %arrayidx7.i, align 8
  %and.i = and i64 %10, %conv36
  %tobool8.not.i = icmp eq i64 %and.i, 0
  br i1 %tobool8.not.i, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %arrayidx12.i = getelementptr inbounds [12 x [2 x i64]], ptr @__const.moduleConvertKeySpecsFlags.map, i64 0, i64 %indvars.iv.i, i64 0
  %11 = load i64, ptr %arrayidx12.i, align 16
  %or.i = or i64 %11, %out.06.i
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %for.body.i
  %out.1.i = phi i64 [ %or.i, %if.then.i ], [ %out.06.i, %for.body.i ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i, 11
  br i1 %exitcond.i, label %moduleConvertKeySpecsFlags.exit, label %for.body.i, !llvm.loop !13

moduleConvertKeySpecsFlags.exit:                  ; preds = %for.inc.i
  %conv38 = trunc i64 %out.1.i to i32
  %12 = load ptr, ptr %out_flags, align 8
  %arrayidx40 = getelementptr inbounds i32, ptr %12, i64 %indvars.iv
  store i32 %conv38, ptr %arrayidx40, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %13 = load i32, ptr %numkeys, align 8
  %14 = sext i32 %13 to i64
  %cmp27 = icmp slt i64 %indvars.iv.next, %14
  br i1 %cmp27, label %for.body, label %return, !llvm.loop !95

return:                                           ; preds = %moduleConvertKeySpecsFlags.exit, %for.body.us, %if.end25.thread, %if.end25, %if.then17, %if.then11, %if.then3, %if.then
  %retval.0 = phi ptr [ null, %if.then ], [ null, %if.then11 ], [ null, %if.then17 ], [ null, %if.then3 ], [ %call21, %if.end25 ], [ %call21, %if.end25.thread ], [ %call21, %for.body.us ], [ %call21, %moduleConvertKeySpecsFlags.exit ]
  ret ptr %retval.0
}

declare i32 @doesCommandHaveKeys(ptr noundef) local_unnamed_addr #1

declare i32 @getKeysFromCommand(ptr noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

declare void @getKeysFreeResult(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noalias ptr @RM_GetCommandKeys(ptr nocapture readnone %ctx, ptr noundef %argv, i32 noundef %argc, ptr nocapture noundef writeonly %num_keys) #0 {
entry:
  %call = tail call ptr @RM_GetCommandKeysWithFlags(ptr poison, ptr noundef %argv, i32 noundef %argc, ptr noundef %num_keys, ptr noundef null)
  ret ptr %call
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @RM_GetCurrentCommandName(ptr noundef readonly %ctx) #11 {
entry:
  %tobool.not = icmp eq ptr %ctx, null
  br i1 %tobool.not, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %client, align 8
  %tobool1.not = icmp eq ptr %0, null
  br i1 %tobool1.not, label %return, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %cmd = getelementptr inbounds %struct.client, ptr %0, i64 0, i32 17
  %1 = load ptr, ptr %cmd, align 8
  %tobool4.not = icmp eq ptr %1, null
  br i1 %tobool4.not, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false2
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %1, i64 0, i32 27
  %2 = load ptr, ptr %fullname, align 8
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %lor.lhs.false2, %if.end
  %retval.0 = phi ptr [ %2, %if.end ], [ null, %lor.lhs.false2 ], [ null, %lor.lhs.false ], [ null, %entry ]
  ret ptr %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define dso_local noundef i32 @RM_RegisterDefragFunc(ptr nocapture noundef readonly %ctx, ptr noundef %cb) #14 {
entry:
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %module, align 8
  %defrag_cb = getelementptr inbounds %struct.RedisModule, ptr %0, i64 0, i32 15
  store ptr %cb, ptr %defrag_cb, align 8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DefragShouldStop(ptr nocapture noundef readonly %ctx) #0 {
entry:
  %0 = load i64, ptr %ctx, align 8
  %cmp.not = icmp eq i64 %0, 0
  br i1 %cmp.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %call = tail call i64 @ustime() #32
  %cmp2 = icmp slt i64 %0, %call
  %1 = zext i1 %cmp2 to i32
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %land.ext = phi i32 [ 0, %entry ], [ %1, %land.rhs ]
  ret i32 %land.ext
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable
define dso_local noundef i32 @RM_DefragCursorSet(ptr nocapture noundef readonly %ctx, i64 noundef %cursor) #14 {
entry:
  %cursor1 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %cursor1, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  store i64 %cursor, ptr %0, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define dso_local noundef i32 @RM_DefragCursorGet(ptr nocapture noundef readonly %ctx, ptr nocapture noundef writeonly %cursor) #19 {
entry:
  %cursor1 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %ctx, i64 0, i32 1
  %0 = load ptr, ptr %cursor1, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %0, align 8
  store i64 %1, ptr %cursor, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DefragAlloc(ptr nocapture readnone %ctx, ptr noundef %ptr) #0 {
entry:
  %call = tail call ptr @activeDefragAlloc(ptr noundef %ptr) #32
  ret ptr %call
}

declare ptr @activeDefragAlloc(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DefragRedisModuleString(ptr nocapture readnone %ctx, ptr noundef %str) #0 {
entry:
  %call = tail call ptr @activeDefragStringOb(ptr noundef %str) #32
  ret ptr %call
}

declare ptr @activeDefragStringOb(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleLateDefrag(ptr noundef %key, ptr nocapture noundef readonly %value, ptr noundef %cursor, i64 noundef %endtime, i32 noundef %dbid) local_unnamed_addr #0 {
entry:
  %defrag_ctx = alloca %struct.RedisModuleDefragCtx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %value, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %1 = load ptr, ptr %0, align 8
  store i64 %endtime, ptr %defrag_ctx, align 8
  %cursor2 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i64 0, i32 1
  store ptr %cursor, ptr %cursor2, align 8
  %key3 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i64 0, i32 2
  store ptr %key, ptr %key3, align 8
  %dbid4 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i64 0, i32 3
  store i32 %dbid, ptr %dbid4, align 8
  %defrag = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 11
  %2 = load ptr, ptr %defrag, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %if.then8, label %if.then

if.then:                                          ; preds = %entry
  %value6 = getelementptr inbounds %struct.moduleValue, ptr %0, i64 0, i32 1
  %call = call i32 %2(ptr noundef nonnull %defrag_ctx, ptr noundef %key, ptr noundef nonnull %value6) #32
  %3 = icmp eq i32 %call, 0
  br i1 %3, label %if.then8, label %return

if.then8:                                         ; preds = %entry, %if.then
  store i64 0, ptr %cursor, align 8
  br label %return

return:                                           ; preds = %if.then, %if.then8
  %retval.0 = phi i32 [ 0, %if.then8 ], [ 1, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @moduleDefragValue(ptr noundef %key, ptr nocapture noundef %value, i32 noundef %dbid) local_unnamed_addr #0 {
entry:
  %ctx.i = alloca %struct.RedisModuleKeyOptCtx, align 8
  %defrag_ctx = alloca %struct.RedisModuleDefragCtx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %value, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %1 = load ptr, ptr %0, align 8
  %call = tail call ptr @activeDefragAlloc(ptr noundef nonnull %0) #32
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr %call, ptr %ptr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mv.0 = phi ptr [ %call, %if.then ], [ %0, %entry ]
  %defrag = getelementptr inbounds %struct.RedisModuleType, ptr %1, i64 0, i32 11
  %2 = load ptr, ptr %defrag, align 8
  %tobool2.not = icmp eq ptr %2, null
  br i1 %tobool2.not, label %return, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ctx.i)
  %3 = load ptr, ptr %ptr, align 8
  %4 = load ptr, ptr %3, align 8
  %free_effort2.i = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 15
  %5 = load ptr, ptr %free_effort2.i, align 8
  %cmp.not.i = icmp eq ptr %5, null
  br i1 %cmp.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.end4
  store ptr %key, ptr %ctx.i, align 8
  %to_key.i = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx.i, i64 0, i32 1
  store ptr null, ptr %to_key.i, align 8
  %from_dbid.i = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx.i, i64 0, i32 2
  store i32 %dbid, ptr %from_dbid.i, align 8
  %to_dbid.i = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx.i, i64 0, i32 3
  store i32 -1, ptr %to_dbid.i, align 4
  %value.i = getelementptr inbounds %struct.moduleValue, ptr %3, i64 0, i32 1
  %6 = load ptr, ptr %value.i, align 8
  %call.i = call i64 %5(ptr noundef nonnull %ctx.i, ptr noundef %6) #32
  br label %moduleGetFreeEffort.exit

if.else.i:                                        ; preds = %if.end4
  %free_effort.i = getelementptr inbounds %struct.RedisModuleType, ptr %4, i64 0, i32 8
  %7 = load ptr, ptr %free_effort.i, align 8
  %cmp2.not.i = icmp eq ptr %7, null
  br i1 %cmp2.not.i, label %moduleGetFreeEffort.exit.thread, label %if.then3.i

moduleGetFreeEffort.exit.thread:                  ; preds = %if.else.i
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ctx.i)
  br label %9

if.then3.i:                                       ; preds = %if.else.i
  %value5.i = getelementptr inbounds %struct.moduleValue, ptr %3, i64 0, i32 1
  %8 = load ptr, ptr %value5.i, align 8
  %call6.i = tail call i64 %7(ptr noundef %key, ptr noundef %8) #32
  br label %moduleGetFreeEffort.exit

moduleGetFreeEffort.exit:                         ; preds = %if.then.i, %if.then3.i
  %effort.0.i = phi i64 [ %call.i, %if.then.i ], [ %call6.i, %if.then3.i ]
  %effort.0.i.fr = freeze i64 %effort.0.i
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ctx.i)
  %tobool6.not = icmp eq i64 %effort.0.i.fr, 0
  %spec.select = select i1 %tobool6.not, i64 -1, i64 %effort.0.i.fr
  br label %9

9:                                                ; preds = %moduleGetFreeEffort.exit, %moduleGetFreeEffort.exit.thread
  %10 = phi i64 [ 1, %moduleGetFreeEffort.exit.thread ], [ %spec.select, %moduleGetFreeEffort.exit ]
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 171), align 8
  %cmp = icmp ugt i64 %10, %11
  br i1 %cmp, label %return, label %if.end10

if.end10:                                         ; preds = %9
  %key11 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i64 0, i32 2
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %defrag_ctx, i8 0, i64 16, i1 false)
  store ptr %key, ptr %key11, align 8
  %dbid12 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i64 0, i32 3
  store i32 %dbid, ptr %dbid12, align 8
  %12 = load ptr, ptr %defrag, align 8
  %value14 = getelementptr inbounds %struct.moduleValue, ptr %mv.0, i64 0, i32 1
  %call15 = call i32 %12(ptr noundef nonnull %defrag_ctx, ptr noundef %key, ptr noundef nonnull %value14) #32
  br label %return

return:                                           ; preds = %9, %if.end, %if.end10
  %retval.0 = phi i32 [ 1, %if.end10 ], [ 1, %if.end ], [ 0, %9 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleDefragGlobals() local_unnamed_addr #0 {
entry:
  %defrag_ctx = alloca %struct.RedisModuleDefragCtx, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %0) #32
  %call13 = tail call ptr @dictNext(ptr noundef %call) #32
  %cmp.not4 = icmp eq ptr %call13, null
  br i1 %cmp.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.cond.backedge
  %call15 = phi ptr [ %call1, %while.cond.backedge ], [ %call13, %entry ]
  %call2 = call ptr @dictGetVal(ptr noundef nonnull %call15) #32
  %defrag_cb = getelementptr inbounds %struct.RedisModule, ptr %call2, i64 0, i32 15
  %1 = load ptr, ptr %defrag_cb, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %while.cond.backedge, label %if.end

if.end:                                           ; preds = %while.body
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %defrag_ctx, ptr noundef nonnull align 8 dereferenceable(32) @__const.moduleDefragGlobals.defrag_ctx, i64 32, i1 false)
  call void %1(ptr noundef nonnull %defrag_ctx) #32
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.end, %while.body
  %call1 = call ptr @dictNext(ptr noundef %call) #32
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !96

while.end:                                        ; preds = %while.cond.backedge, %entry
  call void @dictReleaseIterator(ptr noundef %call) #32
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @RM_GetKeyNameFromDefragCtx(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %key = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %ctx, i64 0, i32 2
  %0 = load ptr, ptr %key, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @RM_GetDbIdFromDefragCtx(ptr nocapture noundef readonly %ctx) #6 {
entry:
  %dbid = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %ctx, i64 0, i32 3
  %0 = load i32, ptr %dbid, align 8
  ret i32 %0
}

declare void @listTypeReleaseIterator(ptr noundef) local_unnamed_addr #1

declare ptr @callReplyCreate(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc noundef i32 @moduleValidateCommandArgs(ptr noundef readonly %args, ptr nocapture noundef readonly %version) unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %args, null
  br i1 %cmp, label %return, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %0 = getelementptr i8, ptr %version, i64 24
  %1 = load ptr, ptr %args, align 8
  %cmp1.not60 = icmp eq ptr %1, null
  br i1 %cmp1.not60, label %return, label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %2 = phi ptr [ %17, %for.inc ], [ %1, %for.cond.preheader ]
  %add.ptr.i63 = phi ptr [ %add.ptr.i, %for.inc ], [ %args, %for.cond.preheader ]
  %j.061 = phi i64 [ %inc, %for.inc ], [ 0, %for.cond.preheader ]
  %type = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i63, i64 0, i32 1
  %3 = load i32, ptr %type, align 8
  %switch37 = icmp ult i32 %3, 9
  br i1 %switch37, label %if.end13, label %do.body

do.body:                                          ; preds = %for.body
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp7 = icmp sgt i32 %4, 3
  br i1 %cmp7, label %return, label %if.end10

if.end10:                                         ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.532, ptr noundef nonnull %2, i32 noundef %3) #32
  br label %return

if.end13:                                         ; preds = %for.body
  switch i32 %3, label %if.else [
    i32 6, label %land.lhs.true
    i32 3, label %if.then30
  ]

land.lhs.true:                                    ; preds = %if.end13
  %token = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i63, i64 0, i32 3
  %5 = load ptr, ptr %token, align 8
  %tobool17.not = icmp eq ptr %5, null
  br i1 %tobool17.not, label %do.body19, label %if.else

do.body19:                                        ; preds = %land.lhs.true
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp20 = icmp sgt i32 %6, 3
  br i1 %cmp20, label %return, label %if.end23

if.end23:                                         ; preds = %do.body19
  %arrayidx = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %args, i64 %j.061
  %7 = load ptr, ptr %arrayidx, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.533, ptr noundef %7) #32
  br label %return

if.then30:                                        ; preds = %if.end13
  %key_spec_index = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i63, i64 0, i32 2
  %8 = load i32, ptr %key_spec_index, align 4
  %cmp31 = icmp slt i32 %8, 0
  br i1 %cmp31, label %do.body34, label %if.end58

do.body34:                                        ; preds = %if.then30
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp35 = icmp sgt i32 %9, 3
  br i1 %cmp35, label %return, label %if.end38

if.end38:                                         ; preds = %do.body34
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.534, ptr noundef nonnull %2) #32
  br label %return

if.else:                                          ; preds = %if.end13, %land.lhs.true
  %key_spec_index42 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i63, i64 0, i32 2
  %10 = load i32, ptr %key_spec_index42, align 4
  switch i32 %10, label %do.body50 [
    i32 -1, label %if.end58
    i32 0, label %if.end58
  ]

do.body50:                                        ; preds = %if.else
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp51 = icmp sgt i32 %11, 3
  br i1 %cmp51, label %return, label %if.end54

if.end54:                                         ; preds = %do.body50
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.535, ptr noundef nonnull %2) #32
  br label %return

if.end58:                                         ; preds = %if.else, %if.else, %if.then30
  %flags = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i63, i64 0, i32 6
  %12 = load i32, ptr %flags, align 8
  %tobool59.not = icmp ult i32 %12, 8
  br i1 %tobool59.not, label %if.end68, label %do.body61

do.body61:                                        ; preds = %if.end58
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp62 = icmp sgt i32 %13, 3
  br i1 %cmp62, label %return, label %if.end65

if.end65:                                         ; preds = %do.body61
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.536, ptr noundef nonnull %2) #32
  br label %return

if.end68:                                         ; preds = %if.end58
  %.off = add nsw i32 %3, -7
  %switch = icmp ult i32 %.off, 2
  %subargs = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %add.ptr.i63, i64 0, i32 8
  %14 = load ptr, ptr %subargs, align 8
  %cmp76 = icmp eq ptr %14, null
  br i1 %switch, label %if.then75, label %if.else92

if.then75:                                        ; preds = %if.end68
  br i1 %cmp76, label %do.body79, label %if.end86

do.body79:                                        ; preds = %if.then75
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp80 = icmp sgt i32 %15, 3
  br i1 %cmp80, label %return, label %if.end83

if.end83:                                         ; preds = %do.body79
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.537, ptr noundef nonnull %2) #32
  br label %return

if.end86:                                         ; preds = %if.then75
  %call88 = tail call fastcc i32 @moduleValidateCommandArgs(ptr noundef nonnull %14, ptr noundef nonnull %version), !range !22
  %tobool89.not = icmp eq i32 %call88, 0
  br i1 %tobool89.not, label %return, label %for.inc

if.else92:                                        ; preds = %if.end68
  br i1 %cmp76, label %for.inc, label %do.body97

do.body97:                                        ; preds = %if.else92
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp98 = icmp sgt i32 %16, 3
  br i1 %cmp98, label %return, label %if.end101

if.end101:                                        ; preds = %do.body97
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.538, ptr noundef nonnull %2) #32
  br label %return

for.inc:                                          ; preds = %if.end86, %if.else92
  %inc = add i64 %j.061, 1
  %version.val = load i64, ptr %0, align 8
  %sext = shl i64 %inc, 32
  %conv.i = ashr exact i64 %sext, 32
  %mul.i = mul i64 %conv.i, %version.val
  %add.ptr.i = getelementptr inbounds i8, ptr %args, i64 %mul.i
  %17 = load ptr, ptr %add.ptr.i, align 8
  %cmp1.not = icmp eq ptr %17, null
  br i1 %cmp1.not, label %return, label %for.body, !llvm.loop !97

return:                                           ; preds = %if.end86, %for.inc, %for.cond.preheader, %if.end101, %do.body97, %if.end83, %do.body79, %if.end65, %do.body61, %if.end54, %do.body50, %if.end38, %do.body34, %if.end23, %do.body19, %if.end10, %do.body, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %do.body ], [ 0, %if.end10 ], [ 0, %do.body19 ], [ 0, %if.end23 ], [ 0, %do.body34 ], [ 0, %if.end38 ], [ 0, %do.body50 ], [ 0, %if.end54 ], [ 0, %do.body61 ], [ 0, %if.end65 ], [ 0, %do.body79 ], [ 0, %if.end83 ], [ 0, %do.body97 ], [ 0, %if.end101 ], [ 1, %for.cond.preheader ], [ 0, %if.end86 ], [ 1, %for.inc ]
  ret i32 %retval.0
}

declare i64 @rdbWriteRaw(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

declare ptr @createStringObjectFromLongDouble(x86_fp80 noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #29

; Function Attrs: nofree nounwind willreturn memory(argmem: read)
declare i32 @bcmp(ptr nocapture, ptr nocapture, i64) local_unnamed_addr #30

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctpop.i64(i64) #29

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.usub.sat.i32(i32, i32) #29

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #29

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #29

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i3 @llvm.bitreverse.i3(i3) #29

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #31

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #31

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { mustprogress nofree nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { mustprogress nofree nounwind willreturn memory(argmem: read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress nofree nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { mustprogress nofree nosync nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { mustprogress nofree nounwind willreturn memory(read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { mustprogress nofree norecurse nosync nounwind willreturn memory(write, argmem: readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #16 = { nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #17 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #18 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #19 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #20 = { nofree nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #21 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: write, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #22 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #23 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #24 = { nofree nounwind memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #25 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #26 = { nofree "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #27 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #28 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #29 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #30 = { nofree nounwind willreturn memory(argmem: read) }
attributes #31 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #32 = { nounwind }
attributes #33 = { nounwind allocsize(0) }
attributes #34 = { nounwind allocsize(1) }
attributes #35 = { noreturn nounwind }
attributes #36 = { nounwind willreturn memory(read) }
attributes #37 = { nounwind willreturn memory(none) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = !{i64 0, i64 65}
!20 = !{i64 0, i64 4}
!21 = distinct !{!21, !6}
!22 = !{i32 0, i32 2}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = !{i32 -1, i32 1}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
!95 = distinct !{!95, !6}
!96 = distinct !{!96, !6}
!97 = distinct !{!97, !6}
