; ModuleID = 'bench/redis/original/server.ll'
source_filename = "bench/redis/original/server.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.redisServer = type { i32, i64, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i32, i64, i32, i32, i32, ptr, ptr, i32, i32, i64, ptr, ptr, ptr, ptr, [2 x i32], i32, i32, i32, i32, i32, [16 x ptr], i32, ptr, ptr, i32, [8 x %struct.connListener], i32, %struct.connListener, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i32, ptr, [3 x %struct.pause_event], [256 x i8], ptr, i64, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, ptr, i64, i64, i64, %struct.malloc_stats, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, [4 x i64], i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [7 x %struct.anon], i64, i64, i64, i64, i64, i64, [4 x %struct.durationStats], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i32, ptr, [3 x %struct.clientBufferLimitsConfig], i32, i32, ptr, i32, i32, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, ptr, i32, i64, i64, i64, i64, ptr, i32, ptr, i32, i32, i32, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, ptr, i32, i32, ptr, i32, i32, i32, [2 x i32], i32, %struct.redisOpArray, i32, ptr, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [41 x i8], [41 x i8], i64, i64, i64, i64, i32, i32, ptr, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, ptr, ptr, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, ptr, i32, ptr, i64, i32, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i64, i32, ptr, i32, i32, i64, i64, i32, i32, i32, i32, i32, i64, [3 x i32], i32, i32, i32, [9 x i32], ptr, ptr, i32, i64, ptr, ptr, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i32, i64, i64, i64, i64, i64, ptr, ptr, i32, ptr, i32, i32, i32, i64, i64, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i64, i32, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, i64, ptr, i32, %struct.aclInfo, i32, i64, i32, i32, i32, %struct.redisTLSContextConfig, ptr, ptr, ptr, ptr, ptr, i64, i32, ptr, i32, i32, i32, i64, i32, ptr }
%struct.connListener = type { [16 x i32], i32, ptr, i32, i32, ptr, ptr }
%struct.pause_event = type { i32, i64 }
%struct.malloc_stats = type { i64, i64, i64, i64, i64 }
%struct.anon = type { i64, i64, [16 x i64], i32 }
%struct.durationStats = type { i64, i64, i64 }
%struct.clientBufferLimitsConfig = type { i64, i64, i64 }
%struct.redisOpArray = type { ptr, i32, i32 }
%struct.aclInfo = type { i64, i64, i64, i64 }
%struct.redisTLSContextConfig = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32 }
%struct.dictType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.sharedObjectsStruct = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [4 x ptr], [4 x ptr], [4 x ptr], [4 x ptr], ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr], [10000 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], ptr, ptr }
%struct.redisCommand = type { ptr, ptr, ptr, ptr, i32, ptr, ptr, i32, ptr, i32, ptr, i32, ptr, i32, i64, i64, ptr, i32, ptr, i32, ptr, ptr, i64, i64, i64, i64, i32, ptr, ptr, %struct.keySpec, ptr, ptr, ptr }
%struct.keySpec = type { ptr, i64, i32, %union.anon, i32, %union.anon.2 }
%union.anon = type { %struct.anon.1 }
%struct.anon.1 = type { ptr, i32 }
%union.anon.2 = type { %struct.anon.3 }
%struct.anon.3 = type { i32, i32, i32 }
%struct.replyFlagNames = type { i64, ptr }
%struct.utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.rdbSaveInfo = type { i32, i32, [41 x i8], i64 }
%struct.timeval = type { i64, i64 }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, ptr }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.redisObject = type { i32, i32, ptr }
%struct.dict = type { ptr, [2 x ptr], [2 x i64], i64, i16, [2 x i8], [0 x ptr] }
%struct.list = type { ptr, ptr, ptr, ptr, ptr, i64 }
%struct.redisDb = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i64, i64, ptr, i32, [2 x %struct.dbDictState] }
%struct.dbDictState = type { i32, i32, i64, i64, ptr }
%struct.listNode = type { ptr, ptr, ptr }
%struct.client = type { i64, i64, ptr, i32, ptr, ptr, ptr, ptr, ptr, i64, i64, i32, ptr, i32, i32, ptr, i64, ptr, ptr, ptr, ptr, i32, i32, i64, ptr, i64, ptr, i64, i64, i64, i32, ptr, i64, i64, i32, i32, i32, i32, i64, i64, ptr, i64, i64, i64, i64, i64, i64, i64, i64, [41 x i8], i32, ptr, i32, i32, %struct.multiState, %struct.blockingState, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, i32, ptr, ptr, ptr, i64, %struct.listNode, i64, i64, i32, i64, ptr }
%struct.multiState = type { ptr, i32, i32, i32, i64, i32 }
%struct.blockingState = type { i32, i64, i32, ptr, i32, i32, i64, ptr, ptr }
%struct.clientMemUsageBucket = type { ptr, i64 }
%struct.listIter = type { ptr, i32 }
%struct.RedisModuleCronLoopInfo = type { i64, i32 }
%struct.saveparam = type { i64, i32 }
%struct.rlimit = type { i64, i64 }
%struct.sigaction = type { %union.anon.21, %struct.__sigset_t, i32, ptr }
%union.anon.21 = type { ptr }
%struct.__sigset_t = type { [16 x i64] }
%struct.ConnectionType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.redisOp = type { ptr, i32, i32, i32 }
%struct.redisCommandArg = type { ptr, i32, i32, ptr, ptr, ptr, i32, ptr, i32, ptr, ptr }
%struct.commandHistory = type { ptr, ptr }
%struct.getKeysResult = type { [256 x %struct.keyReference], ptr, i32, i32 }
%struct.keyReference = type { i32, i32 }
%struct.commandListFilter = type { i32, ptr, %struct.anon.5 }
%struct.anon.5 = type { i32, %union.anon.6 }
%union.anon.6 = type { i64 }
%struct.rusage = type { %struct.timeval, %struct.timeval, %union.anon.7, %union.anon.8, %union.anon.9, %union.anon.10, %union.anon.11, %union.anon.12, %union.anon.13, %union.anon.14, %union.anon.15, %union.anon.16, %union.anon.17, %union.anon.18, %union.anon.19, %union.anon.20 }
%union.anon.7 = type { i64 }
%union.anon.8 = type { i64 }
%union.anon.9 = type { i64 }
%union.anon.10 = type { i64 }
%union.anon.11 = type { i64 }
%union.anon.12 = type { i64 }
%union.anon.13 = type { i64 }
%union.anon.14 = type { i64 }
%union.anon.15 = type { i64 }
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.18 = type { i64 }
%union.anon.19 = type { i64 }
%union.anon.20 = type { i64 }
%struct.raxIterator = type { i32, ptr, ptr, ptr, i64, i64, [128 x i8], ptr, %struct.raxStack, ptr }
%struct.raxStack = type { ptr, i64, i64, [32 x ptr], i32 }
%struct.redisMemOverhead = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, float, float, float, i64, float, i64, float, i64, float, i64, i64, ptr }
%struct.replBacklog = type { ptr, i64, ptr, i64, i64 }
%struct.replBufBlock = type { i32, i64, i64, i64, i64, [0 x i8] }

@__const.serverLogRaw.syslogLevelMap = private unnamed_addr constant [4 x i32] [i32 7, i32 6, i32 5, i32 4], align 16
@.str = private unnamed_addr constant [5 x i8] c".-*#\00", align 1
@server = dso_local global %struct.redisServer zeroinitializer, align 8
@stdout = external local_unnamed_addr global ptr, align 8
@.str.1 = private unnamed_addr constant [2 x i8] c"a\00", align 1
@.str.2 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.3 = private unnamed_addr constant [19 x i8] c"%d %b %Y %H:%M:%S.\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"%03d\00", align 1
@.str.5 = private unnamed_addr constant [16 x i8] c"%d:%c %s %c %s\0A\00", align 1
@.str.6 = private unnamed_addr constant [18 x i8] c":signal-handler (\00", align 1
@.str.7 = private unnamed_addr constant [3 x i8] c") \00", align 1
@.str.8 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.9 = private unnamed_addr constant [9 x i8] c"server.c\00", align 1
@.str.10 = private unnamed_addr constant [24 x i8] c"Unknown string encoding\00", align 1
@objectKeyPointerValueDictType = dso_local global %struct.dictType { ptr @dictEncObjHash, ptr null, ptr null, ptr @dictEncObjKeyCompare, ptr @dictObjectDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@objectKeyHeapPointerValueDictType = dso_local local_unnamed_addr global %struct.dictType { ptr @dictEncObjHash, ptr null, ptr null, ptr @dictEncObjKeyCompare, ptr @dictObjectDestructor, ptr @dictVanillaFree, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@setDictType = dso_local local_unnamed_addr global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 3 }, align 8
@zsetDictType = dso_local local_unnamed_addr global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@dbDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr @dictObjectDestructor, ptr @dictExpandAllowed, ptr @dbDictRehashingStarted, ptr @dbDictRehashingCompleted, ptr @dbDictMetadataSize, i8 0 }, align 8
@dbExpiresDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr null, ptr null, ptr @dictExpandAllowed, ptr @dbExpiresRehashingStarted, ptr @dbExpiresRehashingCompleted, ptr @dbDictMetadataSize, i8 0 }, align 8
@commandTableDictType = dso_local global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@hashDictType = dso_local local_unnamed_addr global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@sdsReplyDictType = dso_local local_unnamed_addr global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@keylistDictType = dso_local global %struct.dictType { ptr @dictObjHash, ptr null, ptr null, ptr @dictObjKeyCompare, ptr @dictObjectDestructor, ptr @dictListDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@modulesDictType = dso_local local_unnamed_addr global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@migrateCacheDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@stringSetDictType = dso_local global %struct.dictType { ptr @dictCStrCaseHash, ptr null, ptr null, ptr @dictCStrKeyCaseCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@externalStringType = dso_local local_unnamed_addr global %struct.dictType { ptr @dictCStrCaseHash, ptr null, ptr null, ptr @dictCStrKeyCaseCompare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@sdsHashDictType = dso_local local_unnamed_addr global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr @dictVanillaFree, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@.str.11 = private unnamed_addr constant [27 x i8] c"Rehashing list length: %lu\00", align 1
@.str.12 = private unnamed_addr constant [4 x i8] c"RDB\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"AOF\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"LDB\00", align 1
@.str.15 = private unnamed_addr constant [7 x i8] c"MODULE\00", align 1
@.str.16 = private unnamed_addr constant [8 x i8] c"Unknown\00", align 1
@.str.17 = private unnamed_addr constant [61 x i8] c"(!new_buffer_size) || (new_buffer_size >= (size_t)c->bufpos)\00", align 1
@ClientsPeakMemInput = dso_local local_unnamed_addr global [8 x i64] zeroinitializer, align 16
@ClientsPeakMemOutput = dso_local local_unnamed_addr global [8 x i64] zeroinitializer, align 16
@io_threads_op = external local_unnamed_addr global i32, align 4
@.str.18 = private unnamed_addr constant [36 x i8] c"io_threads_op == IO_THREADS_OP_IDLE\00", align 1
@databasesCron.resize_db = internal unnamed_addr global i32 0, align 4
@.str.19 = private unnamed_addr constant [64 x i8] c"waitpid() returned an error: %s. child_type: %s, child_pid = %d\00", align 1
@.str.20 = private unnamed_addr constant [39 x i8] c"Unknown child type %d for child pid %d\00", align 1
@.str.21 = private unnamed_addr constant [48 x i8] c"Warning, detected child with unmatched pid: %ld\00", align 1
@getMonotonicUs = external local_unnamed_addr global ptr, align 8
@.str.22 = private unnamed_addr constant [51 x i8] c"DB %d: %lld keys (%lld volatile) in %lld slots HT.\00", align 1
@.str.23 = private unnamed_addr constant [55 x i8] c"%lu clients connected (%lu replicas), %zu bytes in use\00", align 1
@.str.24 = private unnamed_addr constant [36 x i8] c"%d changes in %d seconds. Saving...\00", align 1
@.str.25 = private unnamed_addr constant [53 x i8] c"Starting automatic rewriting of AOF on %lld%% growth\00", align 1
@.str.26 = private unnamed_addr constant [25 x i8] c"server.blocked_last_cron\00", align 1
@.str.27 = private unnamed_addr constant [19 x i8] c"while-blocked-cron\00", align 1
@.str.28 = private unnamed_addr constant [96 x i8] c"SIGTERM received but errors trying to shut down the server, check the logs for more information\00", align 1
@ProcessingEventsWhileBlocked = external local_unnamed_addr global i32, align 4
@.str.29 = private unnamed_addr constant [46 x i8] c"listLength(server.tracking_pending_keys) == 0\00", align 1
@.str.30 = private unnamed_addr constant [46 x i8] c"listLength(server.pending_push_messages) == 0\00", align 1
@.str.31 = private unnamed_addr constant [19 x i8] c"module-acquire-GIL\00", align 1
@.str.32 = private unnamed_addr constant [6 x i8] c"+OK\0D\0A\00", align 1
@shared = dso_local global %struct.sharedObjectsStruct zeroinitializer, align 8
@.str.33 = private unnamed_addr constant [7 x i8] c"$0\0D\0A\0D\0A\00", align 1
@.str.34 = private unnamed_addr constant [5 x i8] c":0\0D\0A\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c":1\0D\0A\00", align 1
@.str.36 = private unnamed_addr constant [5 x i8] c"*0\0D\0A\00", align 1
@.str.37 = private unnamed_addr constant [8 x i8] c"+PONG\0D\0A\00", align 1
@.str.38 = private unnamed_addr constant [10 x i8] c"+QUEUED\0D\0A\00", align 1
@.str.39 = private unnamed_addr constant [16 x i8] c"*2\0D\0A$1\0D\0A0\0D\0A*0\0D\0A\00", align 1
@.str.40 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.41 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.42 = private unnamed_addr constant [69 x i8] c"-WRONGTYPE Operation against a key holding the wrong kind of value\0D\0A\00", align 1
@.str.43 = private unnamed_addr constant [7 x i8] c"-ERR\0D\0A\00", align 1
@.str.44 = private unnamed_addr constant [19 x i8] c"-ERR no such key\0D\0A\00", align 1
@.str.45 = private unnamed_addr constant [20 x i8] c"-ERR syntax error\0D\0A\00", align 1
@.str.46 = private unnamed_addr constant [51 x i8] c"-ERR source and destination objects are the same\0D\0A\00", align 1
@.str.47 = private unnamed_addr constant [26 x i8] c"-ERR index out of range\0D\0A\00", align 1
@.str.48 = private unnamed_addr constant [49 x i8] c"-NOSCRIPT No matching script. Please use EVAL.\0D\0A\00", align 1
@.str.49 = private unnamed_addr constant [50 x i8] c"-LOADING Redis is loading the dataset in memory\0D\0A\00", align 1
@.str.50 = private unnamed_addr constant [90 x i8] c"-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\0D\0A\00", align 1
@.str.51 = private unnamed_addr constant [92 x i8] c"-BUSY Redis is busy running a script. You can only call FUNCTION KILL or SHUTDOWN NOSAVE.\0D\0A\00", align 1
@.str.52 = private unnamed_addr constant [48 x i8] c"-BUSY Redis is busy running a module command.\0D\0A\00", align 1
@.str.53 = private unnamed_addr constant [84 x i8] c"-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\0D\0A\00", align 1
@.str.54 = private unnamed_addr constant [344 x i8] c"-MISCONF Redis is configured to save RDB snapshots, but it's currently unable to persist to disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\0D\0A\00", align 1
@.str.55 = private unnamed_addr constant [57 x i8] c"-READONLY You can't write against a read only replica.\0D\0A\00", align 1
@.str.56 = private unnamed_addr constant [35 x i8] c"-NOAUTH Authentication required.\0D\0A\00", align 1
@.str.57 = private unnamed_addr constant [59 x i8] c"-OOM command not allowed when used memory > 'maxmemory'.\0D\0A\00", align 1
@.str.58 = private unnamed_addr constant [63 x i8] c"-EXECABORT Transaction discarded because of previous errors.\0D\0A\00", align 1
@.str.59 = private unnamed_addr constant [49 x i8] c"-NOREPLICAS Not enough good replicas to write.\0D\0A\00", align 1
@.str.60 = private unnamed_addr constant [43 x i8] c"-BUSYKEY Target key name already exists.\0D\0A\00", align 1
@.str.61 = private unnamed_addr constant [6 x i8] c"$-1\0D\0A\00", align 1
@.str.62 = private unnamed_addr constant [4 x i8] c"_\0D\0A\00", align 1
@.str.63 = private unnamed_addr constant [6 x i8] c"*-1\0D\0A\00", align 1
@.str.64 = private unnamed_addr constant [5 x i8] c"%0\0D\0A\00", align 1
@.str.65 = private unnamed_addr constant [5 x i8] c"~0\0D\0A\00", align 1
@.str.66 = private unnamed_addr constant [26 x i8] c"*2\0D\0A$6\0D\0ASELECT\0D\0A$%d\0D\0A%s\0D\0A\00", align 1
@.str.67 = private unnamed_addr constant [14 x i8] c"$7\0D\0Amessage\0D\0A\00", align 1
@.str.68 = private unnamed_addr constant [15 x i8] c"$8\0D\0Apmessage\0D\0A\00", align 1
@.str.69 = private unnamed_addr constant [16 x i8] c"$9\0D\0Asubscribe\0D\0A\00", align 1
@.str.70 = private unnamed_addr constant [19 x i8] c"$11\0D\0Aunsubscribe\0D\0A\00", align 1
@.str.71 = private unnamed_addr constant [18 x i8] c"$10\0D\0Assubscribe\0D\0A\00", align 1
@.str.72 = private unnamed_addr constant [20 x i8] c"$12\0D\0Asunsubscribe\0D\0A\00", align 1
@.str.73 = private unnamed_addr constant [15 x i8] c"$8\0D\0Asmessage\0D\0A\00", align 1
@.str.74 = private unnamed_addr constant [18 x i8] c"$10\0D\0Apsubscribe\0D\0A\00", align 1
@.str.75 = private unnamed_addr constant [20 x i8] c"$12\0D\0Apunsubscribe\0D\0A\00", align 1
@.str.76 = private unnamed_addr constant [4 x i8] c"DEL\00", align 1
@.str.77 = private unnamed_addr constant [7 x i8] c"UNLINK\00", align 1
@.str.78 = private unnamed_addr constant [5 x i8] c"RPOP\00", align 1
@.str.79 = private unnamed_addr constant [5 x i8] c"LPOP\00", align 1
@.str.80 = private unnamed_addr constant [6 x i8] c"LPUSH\00", align 1
@.str.81 = private unnamed_addr constant [10 x i8] c"RPOPLPUSH\00", align 1
@.str.82 = private unnamed_addr constant [6 x i8] c"LMOVE\00", align 1
@.str.83 = private unnamed_addr constant [7 x i8] c"BLMOVE\00", align 1
@.str.84 = private unnamed_addr constant [8 x i8] c"ZPOPMIN\00", align 1
@.str.85 = private unnamed_addr constant [8 x i8] c"ZPOPMAX\00", align 1
@.str.86 = private unnamed_addr constant [6 x i8] c"MULTI\00", align 1
@.str.87 = private unnamed_addr constant [5 x i8] c"EXEC\00", align 1
@.str.88 = private unnamed_addr constant [5 x i8] c"HSET\00", align 1
@.str.89 = private unnamed_addr constant [5 x i8] c"SREM\00", align 1
@.str.90 = private unnamed_addr constant [7 x i8] c"XGROUP\00", align 1
@.str.91 = private unnamed_addr constant [7 x i8] c"XCLAIM\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"SCRIPT\00", align 1
@.str.93 = private unnamed_addr constant [9 x i8] c"REPLCONF\00", align 1
@.str.94 = private unnamed_addr constant [10 x i8] c"PEXPIREAT\00", align 1
@.str.95 = private unnamed_addr constant [8 x i8] c"PEXPIRE\00", align 1
@.str.96 = private unnamed_addr constant [8 x i8] c"PERSIST\00", align 1
@.str.97 = private unnamed_addr constant [4 x i8] c"SET\00", align 1
@.str.98 = private unnamed_addr constant [5 x i8] c"EVAL\00", align 1
@.str.99 = private unnamed_addr constant [5 x i8] c"left\00", align 1
@.str.100 = private unnamed_addr constant [6 x i8] c"right\00", align 1
@.str.101 = private unnamed_addr constant [5 x i8] c"PXAT\00", align 1
@.str.102 = private unnamed_addr constant [5 x i8] c"TIME\00", align 1
@.str.103 = private unnamed_addr constant [11 x i8] c"RETRYCOUNT\00", align 1
@.str.104 = private unnamed_addr constant [6 x i8] c"FORCE\00", align 1
@.str.105 = private unnamed_addr constant [7 x i8] c"JUSTID\00", align 1
@.str.106 = private unnamed_addr constant [12 x i8] c"ENTRIESREAD\00", align 1
@.str.107 = private unnamed_addr constant [7 x i8] c"LASTID\00", align 1
@.str.108 = private unnamed_addr constant [8 x i8] c"default\00", align 1
@.str.109 = private unnamed_addr constant [5 x i8] c"ping\00", align 1
@.str.110 = private unnamed_addr constant [6 x i8] c"SETID\00", align 1
@.str.111 = private unnamed_addr constant [8 x i8] c"KEEPTTL\00", align 1
@.str.112 = private unnamed_addr constant [7 x i8] c"ABSTTL\00", align 1
@.str.113 = private unnamed_addr constant [5 x i8] c"LOAD\00", align 1
@.str.114 = private unnamed_addr constant [15 x i8] c"CREATECONSUMER\00", align 1
@.str.115 = private unnamed_addr constant [7 x i8] c"GETACK\00", align 1
@.str.116 = private unnamed_addr constant [2 x i8] c"*\00", align 1
@.str.117 = private unnamed_addr constant [2 x i8] c"=\00", align 1
@.str.118 = private unnamed_addr constant [11 x i8] c"(redacted)\00", align 1
@.str.119 = private unnamed_addr constant [6 x i8] c"*%d\0D\0A\00", align 1
@.str.120 = private unnamed_addr constant [6 x i8] c"$%d\0D\0A\00", align 1
@.str.121 = private unnamed_addr constant [7 x i8] c"%%%d\0D\0A\00", align 1
@.str.122 = private unnamed_addr constant [6 x i8] c"~%d\0D\0A\00", align 1
@.str.123 = private unnamed_addr constant [10 x i8] c"minstring\00", align 1
@.str.124 = private unnamed_addr constant [10 x i8] c"maxstring\00", align 1
@.str.125 = private unnamed_addr constant [5 x i8] c"-::*\00", align 1
@clientBufferLimitsDefaults = external local_unnamed_addr global [3 x %struct.clientBufferLimitsConfig], align 16
@configOOMScoreAdjValuesDefaults = external local_unnamed_addr global [3 x i32], align 4
@R_Zero = dso_local local_unnamed_addr global double 0.000000e+00, align 8
@R_PosInf = dso_local local_unnamed_addr global double 0.000000e+00, align 8
@R_NegInf = dso_local local_unnamed_addr global double 0.000000e+00, align 8
@R_Nan = dso_local local_unnamed_addr global double 0.000000e+00, align 8
@.str.126 = private unnamed_addr constant [61 x i8] c"Can't restart: this process has no permissions to execute %s\00", align 1
@.str.127 = private unnamed_addr constant [56 x i8] c"Can't restart: configuration rewrite process failed: %s\00", align 1
@.str.128 = private unnamed_addr constant [44 x i8] c"Can't restart: error preparing for shutdown\00", align 1
@environ = external local_unnamed_addr global ptr, align 8
@.str.129 = private unnamed_addr constant [55 x i8] c"process_class >= 0 && process_class < CONFIG_OOM_COUNT\00", align 1
@setOOMScoreAdj.oom_score_adjusted_by_redis = internal unnamed_addr global i1 false, align 4
@setOOMScoreAdj.oom_score_adj_base = internal unnamed_addr global i32 0, align 4
@.str.130 = private unnamed_addr constant [25 x i8] c"/proc/self/oom_score_adj\00", align 1
@.str.131 = private unnamed_addr constant [33 x i8] c"Unable to read oom_score_adj: %s\00", align 1
@.str.132 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.133 = private unnamed_addr constant [34 x i8] c"Unable to write oom_score_adj: %s\00", align 1
@.str.134 = private unnamed_addr constant [117 x i8] c"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.\00", align 1
@.str.135 = private unnamed_addr constant [136 x i8] c"Your current 'ulimit -n' of %llu is not enough for the server to start. Please increase your open file limit to at least %llu. Exiting.\00", align 1
@.str.136 = private unnamed_addr constant [77 x i8] c"You requested maxclients of %d requiring at least %llu max file descriptors.\00", align 1
@.str.137 = private unnamed_addr constant [69 x i8] c"Server can't set maximum open files to %llu because of OS error: %s.\00", align 1
@.str.138 = private unnamed_addr constant [152 x i8] c"Current maximum open files is %llu. maxclients has been reduced to %d to compensate for low ulimit. If you need higher maxclients increase 'ulimit -n'.\00", align 1
@.str.139 = private unnamed_addr constant [80 x i8] c"Increased maximum number of open files to %llu (it was originally set to %llu).\00", align 1
@.str.140 = private unnamed_addr constant [29 x i8] c"/proc/sys/net/core/somaxconn\00", align 1
@.str.141 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.142 = private unnamed_addr constant [128 x i8] c"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.\00", align 1
@.str.143 = private unnamed_addr constant [64 x i8] c"Warning: Could not create server TCP listening socket %s:%d: %s\00", align 1
@.str.144 = private unnamed_addr constant [52 x i8] c"Failed to configure LOCALE for invalid locale name.\00", align 1
@.str.145 = private unnamed_addr constant [20 x i8] c"monotonic clock: %s\00", align 1
@.str.146 = private unnamed_addr constant [52 x i8] c"Failed creating the event loop. Error message: '%s'\00", align 1
@.str.147 = private unnamed_addr constant [32 x i8] c"Can't create event loop timers.\00", align 1
@.str.148 = private unnamed_addr constant [58 x i8] c"Error registering the readable event for the module pipe.\00", align 1
@.str.149 = private unnamed_addr constant [118 x i8] c"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.\00", align 1
@.str.150 = private unnamed_addr constant [4 x i8] c"tcp\00", align 1
@.str.151 = private unnamed_addr constant [41 x i8] c"Failed finding connection listener of %s\00", align 1
@.str.152 = private unnamed_addr constant [28 x i8] c"Failed finding TLS support.\00", align 1
@.str.153 = private unnamed_addr constant [51 x i8] c"Failed to configure TLS. Check logs for more info.\00", align 1
@.str.154 = private unnamed_addr constant [4 x i8] c"tls\00", align 1
@.str.155 = private unnamed_addr constant [5 x i8] c"unix\00", align 1
@.str.156 = private unnamed_addr constant [44 x i8] c"Failed listening on port %u (%s), aborting.\00", align 1
@.str.157 = private unnamed_addr constant [57 x i8] c"Unrecoverable error creating %s listener accept handler.\00", align 1
@.str.158 = private unnamed_addr constant [44 x i8] c"Configured to not listen anywhere, exiting.\00", align 1
@.str.159 = private unnamed_addr constant [14 x i8] c"firstkey != 0\00", align 1
@.str.160 = private unnamed_addr constant [13 x i8] c"lastkey != 0\00", align 1
@.str.161 = private unnamed_addr constant [6 x i8] c"%s|%s\00", align 1
@.str.162 = private unnamed_addr constant [80 x i8] c"dictAdd(parent->subcommands_dict, sdsnew(declared_name), subcommand) == DICT_OK\00", align 1
@redisCommandTable = external global [0 x %struct.redisCommand], align 8
@.str.163 = private unnamed_addr constant [41 x i8] c"retval1 == DICT_OK && retval2 == DICT_OK\00", align 1
@.str.165 = private unnamed_addr constant [2 x i8] c"|\00", align 1
@.str.167 = private unnamed_addr constant [48 x i8] c"c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)\00", align 1
@incrCommandStatsOnError.prev_err_count = internal unnamed_addr global i64 0, align 8
@.str.168 = private unnamed_addr constant [13 x i8] c"fast-command\00", align 1
@.str.169 = private unnamed_addr constant [8 x i8] c"command\00", align 1
@.str.170 = private unnamed_addr constant [3 x i8] c"\0D\0A\00", align 1
@.str.171 = private unnamed_addr constant [3 x i8] c"  \00", align 1
@.str.172 = private unnamed_addr constant [42 x i8] c"unknown subcommand '%.128s'. Try %s HELP.\00", align 1
@.str.173 = private unnamed_addr constant [8 x i8] c"'%.*s' \00", align 1
@.str.174 = private unnamed_addr constant [55 x i8] c"unknown command '%.128s', with args beginning with: %s\00", align 1
@.str.175 = private unnamed_addr constant [43 x i8] c"wrong number of arguments for '%s' command\00", align 1
@.str.176 = private unnamed_addr constant [16 x i8] c"!server.in_exec\00", align 1
@.str.177 = private unnamed_addr constant [19 x i8] c"!scriptIsRunning()\00", align 1
@.str.178 = private unnamed_addr constant [6 x i8] c"host:\00", align 1
@.str.179 = private unnamed_addr constant [5 x i8] c"post\00", align 1
@.str.180 = private unnamed_addr constant [194 x i8] c"%s command not allowed. If the %s option is set to \22local\22, you can run it from a local connection, otherwise you need to set this option in the configuration file, and then restart the server.\00", align 1
@.str.181 = private unnamed_addr constant [6 x i8] c"DEBUG\00", align 1
@.str.182 = private unnamed_addr constant [21 x i8] c"enable-debug-command\00", align 1
@.str.183 = private unnamed_addr constant [22 x i8] c"enable-module-command\00", align 1
@.str.184 = private unnamed_addr constant [41 x i8] c"Command not allowed inside a transaction\00", align 1
@.str.185 = private unnamed_addr constant [11 x i8] c"-NOPERM %s\00", align 1
@.str.186 = private unnamed_addr constant [45 x i8] c"Replica was unable to write command to disk.\00", align 1
@processCommand.last_log_time_ms = internal unnamed_addr global i64 0, align 8
@.str.187 = private unnamed_addr constant [73 x i8] c"Replica is applying a command even though it is unable to write to disk.\00", align 1
@.str.188 = private unnamed_addr constant [109 x i8] c"Can't execute '%s': only (P|S)SUBSCRIBE / (P|S)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\00", align 1
@.str.189 = private unnamed_addr constant [9 x i8] c"-BUSY %s\00", align 1
@.str.190 = private unnamed_addr constant [41 x i8] c"Replica can't interact with the keyspace\00", align 1
@.str.191 = private unnamed_addr constant [31 x i8] c"Removing the unix socket file.\00", align 1
@.str.192 = private unnamed_addr constant [40 x i8] c"Error removing the unix socket file: %s\00", align 1
@.str.193 = private unnamed_addr constant [27 x i8] c"User requested shutdown...\00", align 1
@.str.194 = private unnamed_addr constant [12 x i8] c"STOPPING=1\0A\00", align 1
@.str.195 = private unnamed_addr constant [43 x i8] c"Waiting for replicas before shutting down.\00", align 1
@.str.196 = private unnamed_addr constant [27 x i8] c"Shutdown manually aborted.\00", align 1
@.str.197 = private unnamed_addr constant [74 x i8] c"Lagging replica %s reported offset %lld behind master, lag=%ld, state=%s.\00", align 1
@.str.198 = private unnamed_addr constant [50 x i8] c"%d of %d replicas are in sync when shutting down.\00", align 1
@.str.199 = private unnamed_addr constant [45 x i8] c"There is a child saving an .rdb. Killing it!\00", align 1
@.str.200 = private unnamed_addr constant [42 x i8] c"There is a module fork child. Killing it!\00", align 1
@.str.201 = private unnamed_addr constant [34 x i8] c"Writing initial AOF. Exit anyway.\00", align 1
@.str.202 = private unnamed_addr constant [33 x i8] c"Writing initial AOF, can't exit.\00", align 1
@.str.203 = private unnamed_addr constant [41 x i8] c"STATUS=Writing initial AOF, can't exit.\0A\00", align 1
@.str.204 = private unnamed_addr constant [48 x i8] c"There is a child rewriting the AOF. Killing it!\00", align 1
@.str.205 = private unnamed_addr constant [33 x i8] c"Calling fsync() on the AOF file.\00", align 1
@.str.206 = private unnamed_addr constant [32 x i8] c"Fail to fsync the AOF file: %s.\00", align 1
@.str.207 = private unnamed_addr constant [46 x i8] c"Saving the final RDB snapshot before exiting.\00", align 1
@.str.208 = private unnamed_addr constant [38 x i8] c"STATUS=Saving the final RDB snapshot\0A\00", align 1
@.str.209 = private unnamed_addr constant [42 x i8] c"Error trying to save the DB. Exit anyway.\00", align 1
@.str.210 = private unnamed_addr constant [41 x i8] c"Error trying to save the DB, can't exit.\00", align 1
@.str.211 = private unnamed_addr constant [49 x i8] c"STATUS=Error trying to save the DB, can't exit.\0A\00", align 1
@.str.212 = private unnamed_addr constant [23 x i8] c"Removing the pid file.\00", align 1
@.str.213 = private unnamed_addr constant [36 x i8] c"%s is now ready to exit, bye bye...\00", align 1
@.str.214 = private unnamed_addr constant [9 x i8] c"Sentinel\00", align 1
@.str.215 = private unnamed_addr constant [6 x i8] c"Redis\00", align 1
@.str.216 = private unnamed_addr constant [76 x i8] c"Errors trying to shut down the server. Check the logs for more information.\00", align 1
@.str.217 = private unnamed_addr constant [46 x i8] c"-MISCONF Errors writing to the AOF file: %s\0D\0A\00", align 1
@.str.218 = private unnamed_addr constant [5 x i8] c"pong\00", align 1
@.str.219 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.220 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.221 = private unnamed_addr constant [9 x i8] c"readonly\00", align 1
@.str.222 = private unnamed_addr constant [8 x i8] c"denyoom\00", align 1
@.str.223 = private unnamed_addr constant [7 x i8] c"module\00", align 1
@.str.224 = private unnamed_addr constant [6 x i8] c"admin\00", align 1
@.str.225 = private unnamed_addr constant [7 x i8] c"pubsub\00", align 1
@.str.226 = private unnamed_addr constant [9 x i8] c"noscript\00", align 1
@.str.227 = private unnamed_addr constant [9 x i8] c"blocking\00", align 1
@.str.228 = private unnamed_addr constant [8 x i8] c"loading\00", align 1
@.str.229 = private unnamed_addr constant [6 x i8] c"stale\00", align 1
@.str.230 = private unnamed_addr constant [13 x i8] c"skip_monitor\00", align 1
@.str.231 = private unnamed_addr constant [13 x i8] c"skip_slowlog\00", align 1
@.str.232 = private unnamed_addr constant [7 x i8] c"asking\00", align 1
@.str.233 = private unnamed_addr constant [5 x i8] c"fast\00", align 1
@.str.234 = private unnamed_addr constant [8 x i8] c"no_auth\00", align 1
@.str.235 = private unnamed_addr constant [18 x i8] c"no_mandatory_keys\00", align 1
@.str.236 = private unnamed_addr constant [17 x i8] c"no_async_loading\00", align 1
@.str.237 = private unnamed_addr constant [9 x i8] c"no_multi\00", align 1
@.str.238 = private unnamed_addr constant [12 x i8] c"movablekeys\00", align 1
@.str.239 = private unnamed_addr constant [11 x i8] c"allow_busy\00", align 1
@__const.addReplyFlagsForCommand.flagNames = private unnamed_addr constant [21 x %struct.replyFlagNames] [%struct.replyFlagNames { i64 1, ptr @.str.220 }, %struct.replyFlagNames { i64 2, ptr @.str.221 }, %struct.replyFlagNames { i64 4, ptr @.str.222 }, %struct.replyFlagNames { i64 8, ptr @.str.223 }, %struct.replyFlagNames { i64 16, ptr @.str.224 }, %struct.replyFlagNames { i64 32, ptr @.str.225 }, %struct.replyFlagNames { i64 64, ptr @.str.226 }, %struct.replyFlagNames { i64 256, ptr @.str.227 }, %struct.replyFlagNames { i64 512, ptr @.str.228 }, %struct.replyFlagNames { i64 1024, ptr @.str.229 }, %struct.replyFlagNames { i64 2048, ptr @.str.230 }, %struct.replyFlagNames { i64 4096, ptr @.str.231 }, %struct.replyFlagNames { i64 8192, ptr @.str.232 }, %struct.replyFlagNames { i64 16384, ptr @.str.233 }, %struct.replyFlagNames { i64 32768, ptr @.str.234 }, %struct.replyFlagNames { i64 524288, ptr @.str.235 }, %struct.replyFlagNames { i64 8388608, ptr @.str.236 }, %struct.replyFlagNames { i64 16777216, ptr @.str.237 }, %struct.replyFlagNames { i64 33554432, ptr @.str.238 }, %struct.replyFlagNames { i64 67108864, ptr @.str.239 }, %struct.replyFlagNames zeroinitializer], align 16
@.str.240 = private unnamed_addr constant [11 x i8] c"deprecated\00", align 1
@.str.241 = private unnamed_addr constant [7 x i8] c"syscmd\00", align 1
@__const.addReplyDocFlagsForCommand.docFlagNames = private unnamed_addr constant [3 x %struct.replyFlagNames] [%struct.replyFlagNames { i64 1, ptr @.str.240 }, %struct.replyFlagNames { i64 2, ptr @.str.241 }, %struct.replyFlagNames zeroinitializer], align 16
@.str.242 = private unnamed_addr constant [3 x i8] c"RO\00", align 1
@.str.243 = private unnamed_addr constant [3 x i8] c"RW\00", align 1
@.str.244 = private unnamed_addr constant [3 x i8] c"OW\00", align 1
@.str.245 = private unnamed_addr constant [3 x i8] c"RM\00", align 1
@.str.246 = private unnamed_addr constant [7 x i8] c"access\00", align 1
@.str.247 = private unnamed_addr constant [7 x i8] c"update\00", align 1
@.str.248 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str.249 = private unnamed_addr constant [7 x i8] c"delete\00", align 1
@.str.250 = private unnamed_addr constant [8 x i8] c"not_key\00", align 1
@.str.251 = private unnamed_addr constant [11 x i8] c"incomplete\00", align 1
@.str.252 = private unnamed_addr constant [15 x i8] c"variable_flags\00", align 1
@__const.addReplyFlagsForKeyArgs.docFlagNames = private unnamed_addr constant [12 x %struct.replyFlagNames] [%struct.replyFlagNames { i64 1, ptr @.str.242 }, %struct.replyFlagNames { i64 2, ptr @.str.243 }, %struct.replyFlagNames { i64 4, ptr @.str.244 }, %struct.replyFlagNames { i64 8, ptr @.str.245 }, %struct.replyFlagNames { i64 16, ptr @.str.246 }, %struct.replyFlagNames { i64 32, ptr @.str.247 }, %struct.replyFlagNames { i64 64, ptr @.str.248 }, %struct.replyFlagNames { i64 128, ptr @.str.249 }, %struct.replyFlagNames { i64 256, ptr @.str.250 }, %struct.replyFlagNames { i64 512, ptr @.str.251 }, %struct.replyFlagNames { i64 1024, ptr @.str.252 }, %struct.replyFlagNames zeroinitializer], align 16
@.str.253 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.254 = private unnamed_addr constant [8 x i8] c"integer\00", align 1
@.str.255 = private unnamed_addr constant [7 x i8] c"double\00", align 1
@.str.256 = private unnamed_addr constant [4 x i8] c"key\00", align 1
@.str.257 = private unnamed_addr constant [8 x i8] c"pattern\00", align 1
@.str.258 = private unnamed_addr constant [10 x i8] c"unix-time\00", align 1
@.str.259 = private unnamed_addr constant [11 x i8] c"pure-token\00", align 1
@.str.260 = private unnamed_addr constant [6 x i8] c"oneof\00", align 1
@.str.261 = private unnamed_addr constant [6 x i8] c"block\00", align 1
@ARG_TYPE_STR = dso_local local_unnamed_addr global [9 x ptr] [ptr @.str.253, ptr @.str.254, ptr @.str.255, ptr @.str.256, ptr @.str.257, ptr @.str.258, ptr @.str.259, ptr @.str.260, ptr @.str.261], align 16
@.str.262 = private unnamed_addr constant [9 x i8] c"optional\00", align 1
@.str.263 = private unnamed_addr constant [9 x i8] c"multiple\00", align 1
@.str.264 = private unnamed_addr constant [15 x i8] c"multiple_token\00", align 1
@__const.addReplyFlagsForArg.argFlagNames = private unnamed_addr constant [4 x %struct.replyFlagNames] [%struct.replyFlagNames { i64 1, ptr @.str.262 }, %struct.replyFlagNames { i64 2, ptr @.str.263 }, %struct.replyFlagNames { i64 4, ptr @.str.264 }, %struct.replyFlagNames zeroinitializer], align 16
@.str.265 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.266 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.267 = private unnamed_addr constant [13 x i8] c"display_text\00", align 1
@.str.268 = private unnamed_addr constant [15 x i8] c"key_spec_index\00", align 1
@.str.269 = private unnamed_addr constant [6 x i8] c"token\00", align 1
@.str.270 = private unnamed_addr constant [8 x i8] c"summary\00", align 1
@.str.271 = private unnamed_addr constant [6 x i8] c"since\00", align 1
@.str.272 = private unnamed_addr constant [17 x i8] c"deprecated_since\00", align 1
@.str.273 = private unnamed_addr constant [6 x i8] c"flags\00", align 1
@.str.274 = private unnamed_addr constant [10 x i8] c"arguments\00", align 1
@.str.275 = private unnamed_addr constant [6 x i8] c"notes\00", align 1
@.str.276 = private unnamed_addr constant [13 x i8] c"begin_search\00", align 1
@.str.277 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.278 = private unnamed_addr constant [5 x i8] c"spec\00", align 1
@.str.279 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.280 = private unnamed_addr constant [8 x i8] c"keyword\00", align 1
@.str.281 = private unnamed_addr constant [10 x i8] c"startfrom\00", align 1
@.str.282 = private unnamed_addr constant [38 x i8] c"Invalid begin_search key spec type %d\00", align 1
@.str.283 = private unnamed_addr constant [10 x i8] c"find_keys\00", align 1
@.str.284 = private unnamed_addr constant [6 x i8] c"range\00", align 1
@.str.285 = private unnamed_addr constant [8 x i8] c"lastkey\00", align 1
@.str.286 = private unnamed_addr constant [8 x i8] c"keystep\00", align 1
@.str.287 = private unnamed_addr constant [6 x i8] c"limit\00", align 1
@.str.288 = private unnamed_addr constant [7 x i8] c"keynum\00", align 1
@.str.289 = private unnamed_addr constant [10 x i8] c"keynumidx\00", align 1
@.str.290 = private unnamed_addr constant [9 x i8] c"firstkey\00", align 1
@.str.291 = private unnamed_addr constant [35 x i8] c"Invalid find_keys key spec type %d\00", align 1
@.str.292 = private unnamed_addr constant [6 x i8] c"group\00", align 1
@.str.293 = private unnamed_addr constant [11 x i8] c"complexity\00", align 1
@.str.294 = private unnamed_addr constant [10 x i8] c"doc_flags\00", align 1
@.str.295 = private unnamed_addr constant [12 x i8] c"replaced_by\00", align 1
@.str.296 = private unnamed_addr constant [8 x i8] c"history\00", align 1
@.str.297 = private unnamed_addr constant [12 x i8] c"subcommands\00", align 1
@.str.298 = private unnamed_addr constant [26 x i8] c"Invalid command specified\00", align 1
@.str.299 = private unnamed_addr constant [33 x i8] c"The command has no key arguments\00", align 1
@.str.300 = private unnamed_addr constant [50 x i8] c"Invalid number of arguments specified for command\00", align 1
@.str.301 = private unnamed_addr constant [40 x i8] c"Invalid arguments specified for command\00", align 1
@.str.302 = private unnamed_addr constant [23 x i8] c"Invalid filter type %d\00", align 1
@.str.303 = private unnamed_addr constant [9 x i8] c"filterby\00", align 1
@.str.304 = private unnamed_addr constant [7 x i8] c"aclcat\00", align 1
@.str.305 = private unnamed_addr constant [16 x i8] c"(no subcommand)\00", align 1
@.str.306 = private unnamed_addr constant [45 x i8] c"    Return details about all Redis commands.\00", align 1
@.str.307 = private unnamed_addr constant [6 x i8] c"COUNT\00", align 1
@.str.308 = private unnamed_addr constant [62 x i8] c"    Return the total number of commands in this Redis server.\00", align 1
@.str.309 = private unnamed_addr constant [5 x i8] c"LIST\00", align 1
@.str.310 = private unnamed_addr constant [56 x i8] c"    Return a list of all commands in this Redis server.\00", align 1
@.str.311 = private unnamed_addr constant [26 x i8] c"INFO [<command-name> ...]\00", align 1
@.str.312 = private unnamed_addr constant [50 x i8] c"    Return details about multiple Redis commands.\00", align 1
@.str.313 = private unnamed_addr constant [65 x i8] c"    If no command names are given, documentation details for all\00", align 1
@.str.314 = private unnamed_addr constant [27 x i8] c"    commands are returned.\00", align 1
@.str.315 = private unnamed_addr constant [26 x i8] c"DOCS [<command-name> ...]\00", align 1
@.str.316 = private unnamed_addr constant [64 x i8] c"    Return documentation details about multiple Redis commands.\00", align 1
@.str.317 = private unnamed_addr constant [23 x i8] c"GETKEYS <full-command>\00", align 1
@.str.318 = private unnamed_addr constant [47 x i8] c"    Return the keys from a full Redis command.\00", align 1
@.str.319 = private unnamed_addr constant [31 x i8] c"GETKEYSANDFLAGS <full-command>\00", align 1
@.str.320 = private unnamed_addr constant [68 x i8] c"    Return the keys and the access flags from a full Redis command.\00", align 1
@__const.commandHelpCommand.help = private unnamed_addr constant [19 x ptr] [ptr @.str.305, ptr @.str.306, ptr @.str.307, ptr @.str.308, ptr @.str.309, ptr @.str.310, ptr @.str.311, ptr @.str.312, ptr @.str.313, ptr @.str.314, ptr @.str.315, ptr @.str.316, ptr @.str.313, ptr @.str.314, ptr @.str.317, ptr @.str.318, ptr @.str.319, ptr @.str.320, ptr null], align 16
@.str.321 = private unnamed_addr constant [6 x i8] c"%lluB\00", align 1
@.str.322 = private unnamed_addr constant [6 x i8] c"%.2fK\00", align 1
@.str.323 = private unnamed_addr constant [6 x i8] c"%.2fM\00", align 1
@.str.324 = private unnamed_addr constant [6 x i8] c"%.2fG\00", align 1
@.str.325 = private unnamed_addr constant [6 x i8] c"%.2fT\00", align 1
@.str.326 = private unnamed_addr constant [6 x i8] c"%.2fP\00", align 1
@.str.327 = private unnamed_addr constant [29 x i8] c"latency_percentiles_usec_%s:\00", align 1
@.str.328 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.329 = private unnamed_addr constant [9 x i8] c"p%s=%.3f\00", align 1
@.str.330 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.331 = private unnamed_addr constant [12 x i8] c"wait_bgsave\00", align 1
@.str.332 = private unnamed_addr constant [10 x i8] c"send_bulk\00", align 1
@.str.333 = private unnamed_addr constant [7 x i8] c"online\00", align 1
@unsafe_info_chars = internal global [5 x i8] c"#:\0A\0D\00", align 1
@unsafe_info_chars_substs = internal global [5 x i8] c"____\00", align 1
@.str.334 = private unnamed_addr constant [91 x i8] c"cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f,rejected_calls=%lld,failed_calls=%lld\0D\0A\00", align 1
@.str.335 = private unnamed_addr constant [118 x i8] c"acl_access_denied_auth:%lld\0D\0Aacl_access_denied_cmd:%lld\0D\0Aacl_access_denied_key:%lld\0D\0Aacl_access_denied_channel:%lld\0D\0A\00", align 1
@cached_default_info_sections = internal unnamed_addr global ptr null, align 8
@.str.336 = private unnamed_addr constant [7 x i8] c"server\00", align 1
@.str.337 = private unnamed_addr constant [8 x i8] c"clients\00", align 1
@.str.338 = private unnamed_addr constant [7 x i8] c"memory\00", align 1
@.str.339 = private unnamed_addr constant [12 x i8] c"persistence\00", align 1
@.str.340 = private unnamed_addr constant [6 x i8] c"stats\00", align 1
@.str.341 = private unnamed_addr constant [12 x i8] c"replication\00", align 1
@.str.342 = private unnamed_addr constant [4 x i8] c"cpu\00", align 1
@.str.343 = private unnamed_addr constant [12 x i8] c"module_list\00", align 1
@.str.344 = private unnamed_addr constant [11 x i8] c"errorstats\00", align 1
@.str.345 = private unnamed_addr constant [8 x i8] c"cluster\00", align 1
@.str.346 = private unnamed_addr constant [9 x i8] c"keyspace\00", align 1
@__const.genInfoSectionDict.default_sections = private unnamed_addr constant [12 x ptr] [ptr @.str.336, ptr @.str.337, ptr @.str.338, ptr @.str.339, ptr @.str.340, ptr @.str.341, ptr @.str.342, ptr @.str.343, ptr @.str.344, ptr @.str.345, ptr @.str.346, ptr null], align 16
@.str.347 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.348 = private unnamed_addr constant [11 x i8] c"everything\00", align 1
@genRedisInfoString.call_uname = internal unnamed_addr global i1 false, align 4
@genRedisInfoString.name = internal global %struct.utsname zeroinitializer, align 1
@.str.349 = private unnamed_addr constant [9 x i8] c"sentinel\00", align 1
@.str.350 = private unnamed_addr constant [11 x i8] c"standalone\00", align 1
@.str.351 = private unnamed_addr constant [8 x i8] c"upstart\00", align 1
@.str.352 = private unnamed_addr constant [8 x i8] c"systemd\00", align 1
@.str.353 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.354 = private unnamed_addr constant [420 x i8] c"# Server\0D\0Aredis_version:%s\0D\0Aredis_git_sha1:%s\0D\0Aredis_git_dirty:%i\0D\0Aredis_build_id:%s\0D\0Aredis_mode:%s\0D\0Aos:%s %s %s\0D\0Aarch_bits:%i\0D\0Amonotonic_clock:%s\0D\0Amultiplexing_api:%s\0D\0Aatomicvar_api:%s\0D\0Agcc_version:%s\0D\0Aprocess_id:%I\0D\0Aprocess_supervised:%s\0D\0Arun_id:%s\0D\0Atcp_port:%i\0D\0Aserver_time_usec:%I\0D\0Auptime_in_seconds:%I\0D\0Auptime_in_days:%I\0D\0Ahz:%i\0D\0Aconfigured_hz:%i\0D\0Alru_clock:%u\0D\0Aexecutable:%s\0D\0Aconfig_file:%s\0D\0Aio_threads_active:%i\0D\0A\00", align 1
@.str.355 = private unnamed_addr constant [12 x i8] c"255.255.255\00", align 1
@.str.356 = private unnamed_addr constant [12 x i8] c"c11-builtin\00", align 1
@.str.357 = private unnamed_addr constant [6 x i8] c"4.2.1\00", align 1
@.str.358 = private unnamed_addr constant [30 x i8] c"shutdown_in_milliseconds:%I\0D\0A\00", align 1
@.str.359 = private unnamed_addr constant [298 x i8] c"# Clients\0D\0Aconnected_clients:%lu\0D\0Acluster_connections:%lu\0D\0Amaxclients:%u\0D\0Aclient_recent_max_input_buffer:%zu\0D\0Aclient_recent_max_output_buffer:%zu\0D\0Ablocked_clients:%d\0D\0Atracking_clients:%d\0D\0Apubsub_clients:%d\0D\0Aclients_in_timeout_table:%llu\0D\0Atotal_blocking_keys:%lu\0D\0Atotal_blocking_keys_on_nokey:%lu\0D\0A\00", align 1
@.str.360 = private unnamed_addr constant [1321 x i8] c"# Memory\0D\0Aused_memory:%zu\0D\0Aused_memory_human:%s\0D\0Aused_memory_rss:%zu\0D\0Aused_memory_rss_human:%s\0D\0Aused_memory_peak:%zu\0D\0Aused_memory_peak_human:%s\0D\0Aused_memory_peak_perc:%.2f%%\0D\0Aused_memory_overhead:%zu\0D\0Aused_memory_startup:%zu\0D\0Aused_memory_dataset:%zu\0D\0Aused_memory_dataset_perc:%.2f%%\0D\0Aallocator_allocated:%zu\0D\0Aallocator_active:%zu\0D\0Aallocator_resident:%zu\0D\0Atotal_system_memory:%lu\0D\0Atotal_system_memory_human:%s\0D\0Aused_memory_lua:%lld\0D\0Aused_memory_vm_eval:%lld\0D\0Aused_memory_lua_human:%s\0D\0Aused_memory_scripts_eval:%lld\0D\0Anumber_of_cached_scripts:%lu\0D\0Anumber_of_functions:%lu\0D\0Anumber_of_libraries:%lu\0D\0Aused_memory_vm_functions:%lld\0D\0Aused_memory_vm_total:%lld\0D\0Aused_memory_vm_total_human:%s\0D\0Aused_memory_functions:%lld\0D\0Aused_memory_scripts:%lld\0D\0Aused_memory_scripts_human:%s\0D\0Amaxmemory:%lld\0D\0Amaxmemory_human:%s\0D\0Amaxmemory_policy:%s\0D\0Aallocator_frag_ratio:%.2f\0D\0Aallocator_frag_bytes:%zu\0D\0Aallocator_rss_ratio:%.2f\0D\0Aallocator_rss_bytes:%zd\0D\0Arss_overhead_ratio:%.2f\0D\0Arss_overhead_bytes:%zd\0D\0Amem_fragmentation_ratio:%.2f\0D\0Amem_fragmentation_bytes:%zd\0D\0Amem_not_counted_for_evict:%zu\0D\0Amem_replication_backlog:%zu\0D\0Amem_total_replication_buffers:%zu\0D\0Amem_clients_slaves:%zu\0D\0Amem_clients_normal:%zu\0D\0Amem_cluster_links:%zu\0D\0Amem_aof_buffer:%zu\0D\0Amem_allocator:%s\0D\0Aactive_defrag_running:%d\0D\0Alazyfree_pending_objects:%zu\0D\0Alazyfreed_objects:%zu\0D\0A\00", align 1
@.str.361 = private unnamed_addr constant [15 x i8] c"jemalloc-5.3.0\00", align 1
@.str.362 = private unnamed_addr constant [813 x i8] c"# Persistence\0D\0Aloading:%d\0D\0Aasync_loading:%d\0D\0Acurrent_cow_peak:%zu\0D\0Acurrent_cow_size:%zu\0D\0Acurrent_cow_size_age:%lu\0D\0Acurrent_fork_perc:%.2f\0D\0Acurrent_save_keys_processed:%zu\0D\0Acurrent_save_keys_total:%zu\0D\0Ardb_changes_since_last_save:%lld\0D\0Ardb_bgsave_in_progress:%d\0D\0Ardb_last_save_time:%jd\0D\0Ardb_last_bgsave_status:%s\0D\0Ardb_last_bgsave_time_sec:%jd\0D\0Ardb_current_bgsave_time_sec:%jd\0D\0Ardb_saves:%lld\0D\0Ardb_last_cow_size:%zu\0D\0Ardb_last_load_keys_expired:%lld\0D\0Ardb_last_load_keys_loaded:%lld\0D\0Aaof_enabled:%d\0D\0Aaof_rewrite_in_progress:%d\0D\0Aaof_rewrite_scheduled:%d\0D\0Aaof_last_rewrite_time_sec:%jd\0D\0Aaof_current_rewrite_time_sec:%jd\0D\0Aaof_last_bgrewrite_status:%s\0D\0Aaof_rewrites:%lld\0D\0Aaof_rewrites_consecutive_failures:%lld\0D\0Aaof_last_write_status:%s\0D\0Aaof_last_cow_size:%zu\0D\0Amodule_fork_in_progress:%d\0D\0Amodule_fork_last_cow_size:%zu\0D\0A\00", align 1
@.str.363 = private unnamed_addr constant [3 x i8] c"ok\00", align 1
@.str.364 = private unnamed_addr constant [4 x i8] c"err\00", align 1
@.str.365 = private unnamed_addr constant [141 x i8] c"aof_current_size:%lld\0D\0Aaof_base_size:%lld\0D\0Aaof_pending_rewrite:%d\0D\0Aaof_buffer_length:%zu\0D\0Aaof_pending_bio_fsync:%lu\0D\0Aaof_delayed_fsync:%lu\0D\0A\00", align 1
@.str.366 = private unnamed_addr constant [156 x i8] c"loading_start_time:%jd\0D\0Aloading_total_bytes:%llu\0D\0Aloading_rdb_used_mem:%llu\0D\0Aloading_loaded_bytes:%llu\0D\0Aloading_loaded_perc:%.2f\0D\0Aloading_eta_seconds:%jd\0D\0A\00", align 1
@.str.367 = private unnamed_addr constant [1693 x i8] c"# Stats\0D\0Atotal_connections_received:%lld\0D\0Atotal_commands_processed:%lld\0D\0Ainstantaneous_ops_per_sec:%lld\0D\0Atotal_net_input_bytes:%lld\0D\0Atotal_net_output_bytes:%lld\0D\0Atotal_net_repl_input_bytes:%lld\0D\0Atotal_net_repl_output_bytes:%lld\0D\0Ainstantaneous_input_kbps:%.2f\0D\0Ainstantaneous_output_kbps:%.2f\0D\0Ainstantaneous_input_repl_kbps:%.2f\0D\0Ainstantaneous_output_repl_kbps:%.2f\0D\0Arejected_connections:%lld\0D\0Async_full:%lld\0D\0Async_partial_ok:%lld\0D\0Async_partial_err:%lld\0D\0Aexpired_keys:%lld\0D\0Aexpired_stale_perc:%.2f\0D\0Aexpired_time_cap_reached_count:%lld\0D\0Aexpire_cycle_cpu_milliseconds:%lld\0D\0Aevicted_keys:%lld\0D\0Aevicted_clients:%lld\0D\0Atotal_eviction_exceeded_time:%lld\0D\0Acurrent_eviction_exceeded_time:%lld\0D\0Akeyspace_hits:%lld\0D\0Akeyspace_misses:%lld\0D\0Apubsub_channels:%ld\0D\0Apubsub_patterns:%lu\0D\0Apubsubshard_channels:%lu\0D\0Alatest_fork_usec:%lld\0D\0Atotal_forks:%lld\0D\0Amigrate_cached_sockets:%ld\0D\0Aslave_expires_tracked_keys:%zu\0D\0Aactive_defrag_hits:%lld\0D\0Aactive_defrag_misses:%lld\0D\0Aactive_defrag_key_hits:%lld\0D\0Aactive_defrag_key_misses:%lld\0D\0Atotal_active_defrag_time:%lld\0D\0Acurrent_active_defrag_time:%lld\0D\0Atracking_total_keys:%lld\0D\0Atracking_total_items:%lld\0D\0Atracking_total_prefixes:%lld\0D\0Aunexpected_error_replies:%lld\0D\0Atotal_error_replies:%lld\0D\0Adump_payload_sanitizations:%lld\0D\0Atotal_reads_processed:%lld\0D\0Atotal_writes_processed:%lld\0D\0Aio_threaded_reads_processed:%lld\0D\0Aio_threaded_writes_processed:%lld\0D\0Aclient_query_buffer_limit_disconnections:%lld\0D\0Aclient_output_buffer_limit_disconnections:%lld\0D\0Areply_buffer_shrinks:%lld\0D\0Areply_buffer_expands:%lld\0D\0Aeventloop_cycles:%llu\0D\0Aeventloop_duration_sum:%llu\0D\0Aeventloop_duration_cmd_sum:%llu\0D\0Ainstantaneous_eventloop_cycles_per_sec:%llu\0D\0Ainstantaneous_eventloop_duration_usec:%llu\0D\0A\00", align 1
@.str.368 = private unnamed_addr constant [25 x i8] c"# Replication\0D\0Arole:%s\0D\0A\00", align 1
@.str.369 = private unnamed_addr constant [7 x i8] c"master\00", align 1
@.str.370 = private unnamed_addr constant [6 x i8] c"slave\00", align 1
@.str.371 = private unnamed_addr constant [168 x i8] c"master_host:%s\0D\0Amaster_port:%d\0D\0Amaster_link_status:%s\0D\0Amaster_last_io_seconds_ago:%d\0D\0Amaster_sync_in_progress:%d\0D\0Aslave_read_repl_offset:%lld\0D\0Aslave_repl_offset:%lld\0D\0A\00", align 1
@.str.372 = private unnamed_addr constant [3 x i8] c"up\00", align 1
@.str.373 = private unnamed_addr constant [5 x i8] c"down\00", align 1
@.str.374 = private unnamed_addr constant [148 x i8] c"master_sync_total_bytes:%lld\0D\0Amaster_sync_read_bytes:%lld\0D\0Amaster_sync_left_bytes:%lld\0D\0Amaster_sync_perc:%.2f\0D\0Amaster_sync_last_io_seconds_ago:%d\0D\0A\00", align 1
@.str.375 = private unnamed_addr constant [37 x i8] c"master_link_down_since_seconds:%jd\0D\0A\00", align 1
@.str.376 = private unnamed_addr constant [62 x i8] c"slave_priority:%d\0D\0Aslave_read_only:%d\0D\0Areplica_announced:%d\0D\0A\00", align 1
@.str.377 = private unnamed_addr constant [23 x i8] c"connected_slaves:%lu\0D\0A\00", align 1
@.str.378 = private unnamed_addr constant [28 x i8] c"min_slaves_good_slaves:%d\0D\0A\00", align 1
@.str.379 = private unnamed_addr constant [53 x i8] c"slave%d:ip=%s,port=%d,state=%s,offset=%lld,lag=%ld\0D\0A\00", align 1
@.str.380 = private unnamed_addr constant [226 x i8] c"master_failover_state:%s\0D\0Amaster_replid:%s\0D\0Amaster_replid2:%s\0D\0Amaster_repl_offset:%lld\0D\0Asecond_repl_offset:%lld\0D\0Arepl_backlog_active:%d\0D\0Arepl_backlog_size:%lld\0D\0Arepl_backlog_first_byte_offset:%lld\0D\0Arepl_backlog_histlen:%lld\0D\0A\00", align 1
@.str.381 = private unnamed_addr constant [124 x i8] c"# CPU\0D\0Aused_cpu_sys:%ld.%06ld\0D\0Aused_cpu_user:%ld.%06ld\0D\0Aused_cpu_sys_children:%ld.%06ld\0D\0Aused_cpu_user_children:%ld.%06ld\0D\0A\00", align 1
@.str.382 = private unnamed_addr constant [74 x i8] c"used_cpu_sys_main_thread:%ld.%06ld\0D\0Aused_cpu_user_main_thread:%ld.%06ld\0D\0A\00", align 1
@.str.383 = private unnamed_addr constant [8 x i8] c"modules\00", align 1
@.str.384 = private unnamed_addr constant [12 x i8] c"# Modules\0D\0A\00", align 1
@.str.385 = private unnamed_addr constant [13 x i8] c"commandstats\00", align 1
@.str.386 = private unnamed_addr constant [17 x i8] c"# Commandstats\0D\0A\00", align 1
@.str.387 = private unnamed_addr constant [15 x i8] c"# Errorstats\0D\0A\00", align 1
@.str.388 = private unnamed_addr constant [2 x i8] c"^\00", align 1
@.str.389 = private unnamed_addr constant [28 x i8] c"errorstat_%.*s:count=%lld\0D\0A\00", align 1
@.str.390 = private unnamed_addr constant [13 x i8] c"latencystats\00", align 1
@.str.391 = private unnamed_addr constant [17 x i8] c"# Latencystats\0D\0A\00", align 1
@.str.392 = private unnamed_addr constant [32 x i8] c"# Cluster\0D\0Acluster_enabled:%d\0D\0A\00", align 1
@.str.393 = private unnamed_addr constant [13 x i8] c"# Keyspace\0D\0A\00", align 1
@.str.394 = private unnamed_addr constant [43 x i8] c"db%d:keys=%lld,expires=%lld,avg_ttl=%lld\0D\0A\00", align 1
@.str.395 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.396 = private unnamed_addr constant [140 x i8] c"# Debug\0D\0Aeventloop_duration_aof_sum:%llu\0D\0Aeventloop_duration_cron_sum:%llu\0D\0Aeventloop_duration_max:%llu\0D\0Aeventloop_cmd_per_cycle_max:%lld\0D\0A\00", align 1
@.str.397 = private unnamed_addr constant [4 x i8] c"txt\00", align 1
@.str.398 = private unnamed_addr constant [47 x i8] c"MONITOR isn't allowed for DENY BLOCKING client\00", align 1
@.str.399 = private unnamed_addr constant [11 x i8] c"WARNING %s\00", align 1
@.str.400 = private unnamed_addr constant [19 x i8] c"/var/run/redis.pid\00", align 1
@.str.401 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.402 = private unnamed_addr constant [29 x i8] c"Failed to write PID file: %s\00", align 1
@.str.403 = private unnamed_addr constant [10 x i8] c"/dev/null\00", align 1
@.str.404 = private unnamed_addr constant [58 x i8] c"Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\0A\00", align 1
@stderr = external local_unnamed_addr global ptr, align 8
@.str.405 = private unnamed_addr constant [59 x i8] c"Usage: ./redis-server [/path/to/redis.conf] [options] [-]\0A\00", align 1
@.str.406 = private unnamed_addr constant [50 x i8] c"       ./redis-server - (read config from stdin)\0A\00", align 1
@.str.407 = private unnamed_addr constant [39 x i8] c"       ./redis-server -v or --version\0A\00", align 1
@.str.408 = private unnamed_addr constant [36 x i8] c"       ./redis-server -h or --help\0A\00", align 1
@.str.409 = private unnamed_addr constant [49 x i8] c"       ./redis-server --test-memory <megabytes>\0A\00", align 1
@.str.410 = private unnamed_addr constant [38 x i8] c"       ./redis-server --check-system\0A\00", align 1
@.str.411 = private unnamed_addr constant [11 x i8] c"Examples:\0A\00", align 1
@.str.412 = private unnamed_addr constant [58 x i8] c"       ./redis-server (run the server with default conf)\0A\00", align 1
@.str.413 = private unnamed_addr constant [50 x i8] c"       echo 'maxmemory 128mb' | ./redis-server -\0A\00", align 1
@.str.414 = private unnamed_addr constant [44 x i8] c"       ./redis-server /etc/redis/6379.conf\0A\00", align 1
@.str.415 = private unnamed_addr constant [35 x i8] c"       ./redis-server --port 7777\0A\00", align 1
@.str.416 = private unnamed_addr constant [62 x i8] c"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\0A\00", align 1
@.str.417 = private unnamed_addr constant [62 x i8] c"       ./redis-server /etc/myredis.conf --loglevel verbose -\0A\00", align 1
@.str.418 = private unnamed_addr constant [61 x i8] c"       ./redis-server /etc/myredis.conf --loglevel verbose\0A\0A\00", align 1
@.str.419 = private unnamed_addr constant [16 x i8] c"Sentinel mode:\0A\00", align 1
@.str.420 = private unnamed_addr constant [53 x i8] c"       ./redis-server /etc/sentinel.conf --sentinel\0A\00", align 1
@.str.421 = private unnamed_addr constant [1132 x i8] c"                _._                                                  \0A           _.-``__ ''-._                                             \0A      _.-``    `.  `_.  ''-._           Redis %s (%s/%d) %s bit\0A  .-`` .-```.  ```\\/    _.,_ ''-._                                  \0A (    '      ,       .-`  | `,    )     Running in %s mode\0A |`-._`-...-` __...-.``-._|'` _.-'|     Port: %d\0A |    `-._   `._    /     _.-'    |     PID: %ld\0A  `-._    `-._  `-./  _.-'    _.-'                                   \0A |`-._`-._    `-.__.-'    _.-'_.-'|                                  \0A |    `-._`-._        _.-'_.-'    |           https://redis.io       \0A  `-._    `-._`-.__.-'_.-'    _.-'                                   \0A |`-._`-._    `-.__.-'    _.-'_.-'|                                  \0A |    `-._`-._        _.-'_.-'    |                                  \0A  `-._    `-._`-.__.-'_.-'    _.-'                                   \0A      `-._    `-.__.-'    _.-'                                       \0A          `-._        _.-'                                           \0A              `-.__.-'                                               \0A\0A\00", align 1
@.str.422 = private unnamed_addr constant [26 x i8] c"Running mode=%s, port=%d.\00", align 1
@.str.423 = private unnamed_addr constant [3 x i8] c"64\00", align 1
@.str.424 = private unnamed_addr constant [48 x i8] c"Unrecoverable error creating %s accept handler.\00", align 1
@.str.425 = private unnamed_addr constant [5 x i8] c"fork\00", align 1
@.str.426 = private unnamed_addr constant [15 x i8] c"redis-sentinel\00", align 1
@.str.427 = private unnamed_addr constant [11 x i8] c"--sentinel\00", align 1
@.str.428 = private unnamed_addr constant [46 x i8] c"DB loaded from append only file: %.3f seconds\00", align 1
@__const.loadDataFromDisk.rsi = private unnamed_addr constant %struct.rdbSaveInfo { i32 -1, i32 0, [41 x i8] c"0000000000000000000000000000000000000000\00", i64 -1 }, align 8
@.str.429 = private unnamed_addr constant [34 x i8] c"DB loaded from disk: %.3f seconds\00", align 1
@.str.430 = private unnamed_addr constant [20 x i8] c"server.repl_backlog\00", align 1
@.str.431 = private unnamed_addr constant [56 x i8] c"Fatal error loading the DB, check server logs. Exiting.\00", align 1
@.str.432 = private unnamed_addr constant [36 x i8] c"Out Of Memory allocating %zu bytes!\00", align 1
@.str.433 = private unnamed_addr constant [56 x i8] c"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!\00", align 1
@.str.434 = private unnamed_addr constant [52 x i8] c"systemd supervision error: NOTIFY_SOCKET not found!\00", align 1
@.str.435 = private unnamed_addr constant [41 x i8] c"systemd supervision error: sd_notify: %d\00", align 1
@.str.436 = private unnamed_addr constant [12 x i8] c"UPSTART_JOB\00", align 1
@.str.437 = private unnamed_addr constant [30 x i8] c"Upstart supervision detected.\00", align 1
@.str.438 = private unnamed_addr constant [14 x i8] c"NOTIFY_SOCKET\00", align 1
@.str.439 = private unnamed_addr constant [30 x i8] c"Systemd supervision detected.\00", align 1
@.str.440 = private unnamed_addr constant [16 x i8] c"redis-check-rdb\00", align 1
@.str.441 = private unnamed_addr constant [16 x i8] c"redis-check-aof\00", align 1
@.str.442 = private unnamed_addr constant [3 x i8] c"-v\00", align 1
@.str.443 = private unnamed_addr constant [10 x i8] c"--version\00", align 1
@.str.444 = private unnamed_addr constant [7 x i8] c"--help\00", align 1
@.str.445 = private unnamed_addr constant [3 x i8] c"-h\00", align 1
@.str.446 = private unnamed_addr constant [14 x i8] c"--test-memory\00", align 1
@.str.447 = private unnamed_addr constant [59 x i8] c"Please specify the amount of memory to test in megabytes.\0A\00", align 1
@.str.448 = private unnamed_addr constant [45 x i8] c"Example: ./redis-server --test-memory 4096\0A\0A\00", align 1
@.str.449 = private unnamed_addr constant [15 x i8] c"--check-system\00", align 1
@.str.450 = private unnamed_addr constant [7 x i8] c"--save\00", align 1
@.str.451 = private unnamed_addr constant [3 x i8] c"\22\22\00", align 1
@.str.452 = private unnamed_addr constant [46 x i8] c"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\00", align 1
@.str.453 = private unnamed_addr constant [72 x i8] c"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started\00", align 1
@.str.454 = private unnamed_addr constant [122 x i8] c"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/redis.conf\00", align 1
@.str.455 = private unnamed_addr constant [21 x i8] c"Configuration loaded\00", align 1
@.str.456 = private unnamed_addr constant [19 x i8] c"Server initialized\00", align 1
@.str.457 = private unnamed_addr constant [38 x i8] c"verifyClusterConfigWithData() == C_OK\00", align 1
@.str.458 = private unnamed_addr constant [31 x i8] c"Ready to accept connections %s\00", align 1
@.str.459 = private unnamed_addr constant [36 x i8] c"STATUS=Ready to accept connections\0A\00", align 1
@.str.460 = private unnamed_addr constant [91 x i8] c"STATUS=Ready to accept connections in read-only mode. Waiting for MASTER <-> REPLICA sync\0A\00", align 1
@.str.461 = private unnamed_addr constant [9 x i8] c"READY=1\0A\00", align 1
@.str.462 = private unnamed_addr constant [137 x i8] c"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?\00", align 1
@.str.463 = private unnamed_addr constant [12 x i8] c"rop->target\00", align 1
@.str.464 = private unnamed_addr constant [82 x i8] c"!(isPausedActions(PAUSE_ACTION_REPLICA) && (!server.client_pause_in_transaction))\00", align 1
@.str.465 = private unnamed_addr constant [39 x i8] c"Received SIGINT scheduling shutdown...\00", align 1
@.str.466 = private unnamed_addr constant [40 x i8] c"Received SIGTERM scheduling shutdown...\00", align 1
@.str.467 = private unnamed_addr constant [49 x i8] c"Received shutdown signal, scheduling shutdown...\00", align 1
@.str.468 = private unnamed_addr constant [27 x i8] c"You insist... exiting now.\00", align 1
@.str.469 = private unnamed_addr constant [62 x i8] c"Received shutdown signal during loading, scheduling shutdown.\00", align 1
@.str.470 = private unnamed_addr constant [40 x i8] c"Received SIGUSR1 in child, exiting now.\00", align 1
@.str.471 = private unnamed_addr constant [6 x i8] c"title\00", align 1
@.str.472 = private unnamed_addr constant [12 x i8] c"listen-addr\00", align 1
@.str.473 = private unnamed_addr constant [6 x i8] c"%s:%u\00", align 1
@.str.474 = private unnamed_addr constant [14 x i8] c"unixsocket:%s\00", align 1
@.str.475 = private unnamed_addr constant [12 x i8] c"server-mode\00", align 1
@.str.476 = private unnamed_addr constant [10 x i8] c"[cluster]\00", align 1
@.str.477 = private unnamed_addr constant [11 x i8] c"[sentinel]\00", align 1
@.str.478 = private unnamed_addr constant [12 x i8] c"config-file\00", align 1
@.str.479 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.480 = private unnamed_addr constant [5 x i8] c"port\00", align 1
@.str.481 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@.str.482 = private unnamed_addr constant [9 x i8] c"tls-port\00", align 1
@.str.483 = private unnamed_addr constant [11 x i8] c"unixsocket\00", align 1
@.str.484 = private unnamed_addr constant [58 x i8] c"upstart supervision requested, but UPSTART_JOB not found!\00", align 1
@.str.485 = private unnamed_addr constant [54 x i8] c"supervised by upstart, will stop to signal readiness.\00", align 1
@.str.486 = private unnamed_addr constant [28 x i8] c"STATUS=Redis is loading...\0A\00", align 1
@.str.487 = private unnamed_addr constant [128 x i8] c"Supervised by systemd. Please make sure you set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit.\00", align 1
@switch.table.checkChildrenDone = private unnamed_addr constant [4 x ptr] [ptr @.str.12, ptr @.str.13, ptr @.str.14, ptr @.str.15], align 8
@switch.table.replstateToString = private unnamed_addr constant [4 x ptr] [ptr @.str.331, ptr @.str.331, ptr @.str.332, ptr @.str.333], align 8

; Function Attrs: nounwind uwtable
define dso_local void @serverLogRaw(i32 noundef %level, ptr noundef %msg) local_unnamed_addr #0 {
entry:
  %buf = alloca [64 x i8], align 16
  %tv = alloca %struct.timeval, align 8
  %tm = alloca %struct.tm, align 8
  %and = and i32 %level, 1024
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 250), align 8
  %1 = load i8, ptr %0, align 1
  %cmp = icmp eq i8 %1, 0
  %and2 = and i32 %level, 255
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3 = icmp slt i32 %and2, %2
  br i1 %cmp3, label %if.end45, label %if.end

if.end:                                           ; preds = %entry
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %3 = load ptr, ptr @stdout, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call = tail call noalias ptr @fopen64(ptr noundef nonnull %0, ptr noundef nonnull @.str.1)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %3, %cond.true ], [ %call, %cond.false ]
  %tobool5.not = icmp eq ptr %cond, null
  br i1 %tobool5.not, label %if.end45, label %if.end7

if.end7:                                          ; preds = %cond.end
  %tobool8.not = icmp eq i32 %and, 0
  br i1 %tobool8.not, label %if.else, label %if.then9

if.then9:                                         ; preds = %if.end7
  %fputs = tail call i32 @fputs(ptr %msg, ptr nonnull %cond)
  br label %if.end35

if.else:                                          ; preds = %if.end7
  %call11 = tail call i32 @getpid() #38
  %call12 = call i32 @gettimeofday(ptr noundef nonnull %tv, ptr noundef null) #38
  %4 = load i64, ptr %tv, align 8
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 350), align 8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 351), align 8
  call void @nolocks_localtime(ptr noundef nonnull %tm, i64 noundef %4, i64 noundef %5, i32 noundef %6) #38
  %call13 = call i64 @strftime(ptr noundef nonnull %buf, i64 noundef 64, ptr noundef nonnull @.str.3, ptr noundef nonnull %tm) #38
  %sext = shl i64 %call13, 32
  %idx.ext = ashr exact i64 %sext, 32
  %add.ptr = getelementptr inbounds i8, ptr %buf, i64 %idx.ext
  %sub = sub nsw i64 64, %idx.ext
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i64 0, i32 1
  %7 = load i64, ptr %tv_usec, align 8
  %conv17 = trunc i64 %7 to i32
  %div = sdiv i32 %conv17, 1000
  %call18 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull %add.ptr, i64 noundef %sub, ptr noundef nonnull @.str.4, i32 noundef %div) #38
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool19.not = icmp eq i32 %8, 0
  br i1 %tobool19.not, label %if.else21, label %if.end29

if.else21:                                        ; preds = %if.else
  %9 = load i32, ptr @server, align 8
  %cmp22.not = icmp eq i32 %call11, %9
  br i1 %cmp22.not, label %if.else25, label %if.end29

if.else25:                                        ; preds = %if.else21
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %tobool26.not = icmp eq ptr %10, null
  %cond27 = select i1 %tobool26.not, i32 77, i32 83
  br label %if.end29

if.end29:                                         ; preds = %if.else21, %if.else, %if.else25
  %role_char.0 = phi i32 [ %cond27, %if.else25 ], [ 88, %if.else ], [ 67, %if.else21 ]
  %call30 = call i32 @getpid() #38
  %idxprom = zext nneg i32 %and2 to i64
  %arrayidx32 = getelementptr inbounds i8, ptr @.str, i64 %idxprom
  %11 = load i8, ptr %arrayidx32, align 1
  %conv33 = sext i8 %11 to i32
  %call34 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef nonnull %cond, ptr noundef nonnull @.str.5, i32 noundef %call30, i32 noundef %role_char.0, ptr noundef nonnull %buf, i32 noundef %conv33, ptr noundef %msg)
  br label %if.end35

if.end35:                                         ; preds = %if.end29, %if.then9
  %call36 = call i32 @fflush(ptr noundef nonnull %cond)
  br i1 %cmp, label %if.end40, label %if.then38

if.then38:                                        ; preds = %if.end35
  %call39 = call i32 @fclose(ptr noundef nonnull %cond)
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.end35
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 251), align 8
  %tobool41.not = icmp eq i32 %12, 0
  br i1 %tobool41.not, label %if.end45, label %if.then42

if.then42:                                        ; preds = %if.end40
  %idxprom43 = zext nneg i32 %and2 to i64
  %arrayidx44 = getelementptr inbounds [4 x i32], ptr @__const.serverLogRaw.syslogLevelMap, i64 0, i64 %idxprom43
  %13 = load i32, ptr %arrayidx44, align 4
  call void (i32, ptr, ...) @syslog(i32 noundef %13, ptr noundef nonnull @.str.2, ptr noundef %msg) #38
  br label %if.end45

if.end45:                                         ; preds = %cond.end, %entry, %if.then42, %if.end40
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1

; Function Attrs: nofree nounwind
declare noalias noundef ptr @fopen64(ptr nocapture noundef readonly, ptr nocapture noundef readonly) local_unnamed_addr #2

; Function Attrs: nofree nounwind
declare noundef i32 @fprintf(ptr nocapture noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @getpid() local_unnamed_addr #3

; Function Attrs: nofree nounwind
declare noundef i32 @gettimeofday(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #2

declare void @nolocks_localtime(ptr noundef, i64 noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare i64 @strftime(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #3

; Function Attrs: nofree nounwind
declare noundef i32 @snprintf(ptr noalias nocapture noundef writeonly, i64 noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: nofree nounwind
declare noundef i32 @fflush(ptr nocapture noundef) local_unnamed_addr #2

; Function Attrs: nofree nounwind
declare noundef i32 @fclose(ptr nocapture noundef) local_unnamed_addr #2

declare void @syslog(i32 noundef, ptr noundef, ...) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @_serverLog(i32 noundef %level, ptr nocapture noundef readonly %fmt, ...) local_unnamed_addr #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %msg = alloca [1024 x i8], align 16
  call void @llvm.va_start(ptr nonnull %ap)
  %call = call i32 @vsnprintf(ptr noundef nonnull %msg, i64 noundef 1024, ptr noundef %fmt, ptr noundef nonnull %ap) #38
  call void @llvm.va_end(ptr nonnull %ap)
  call void @serverLogRaw(i32 noundef %level, ptr noundef nonnull %msg)
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #5

; Function Attrs: nofree nounwind
declare noundef i32 @vsnprintf(ptr nocapture noundef, i64 noundef, ptr nocapture noundef readonly, ptr noundef) local_unnamed_addr #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #5

; Function Attrs: nounwind uwtable
define dso_local void @serverLogRawFromHandler(i32 noundef %level, ptr nocapture noundef readonly %msg) local_unnamed_addr #0 {
entry:
  %buf = alloca [64 x i8], align 16
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 250), align 8
  %1 = load i8, ptr %0, align 1
  %cmp = icmp eq i8 %1, 0
  %and = and i32 %level, 255
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2 = icmp slt i32 %and, %2
  br i1 %cmp2, label %if.end66, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 176), align 4
  %tobool4 = icmp ne i32 %3, 0
  %or.cond = select i1 %cmp, i1 %tobool4, i1 false
  br i1 %or.cond, label %if.end66, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  br i1 %cmp, label %if.end9, label %cond.end

cond.end:                                         ; preds = %if.end
  %call = tail call i32 (ptr, i32, ...) @open64(ptr noundef nonnull %0, i32 noundef 1089, i32 noundef 420) #38
  %cmp6 = icmp eq i32 %call, -1
  br i1 %cmp6, label %if.end66, label %if.end9

if.end9:                                          ; preds = %if.end, %cond.end
  %cond17 = phi i32 [ %call, %cond.end ], [ 1, %if.end ]
  %and10 = and i32 %level, 1024
  %tobool11.not = icmp eq i32 %and10, 0
  br i1 %tobool11.not, label %if.else, label %if.then12

if.then12:                                        ; preds = %if.end9
  %call13 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %msg) #39
  %call14 = tail call i64 @write(i32 noundef %cond17, ptr noundef %msg, i64 noundef %call13) #38
  br label %err

if.else:                                          ; preds = %if.end9
  %call19 = tail call i32 @getpid() #38
  %conv20 = sext i32 %call19 to i64
  %call21 = call i32 @ll2string(ptr noundef nonnull %buf, i64 noundef 64, i64 noundef %conv20) #38
  %call24 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buf) #39
  %call25 = call i64 @write(i32 noundef %cond17, ptr noundef nonnull %buf, i64 noundef %call24) #38
  %cmp26 = icmp eq i64 %call25, -1
  br i1 %cmp26, label %err, label %if.end29

if.end29:                                         ; preds = %if.else
  %call30 = call i64 @write(i32 noundef %cond17, ptr noundef nonnull @.str.6, i64 noundef 17) #38
  %cmp31 = icmp eq i64 %call30, -1
  br i1 %cmp31, label %err, label %if.end34

if.end34:                                         ; preds = %if.end29
  %call36 = call i64 @time(ptr noundef null) #38
  %call37 = call i32 @ll2string(ptr noundef nonnull %buf, i64 noundef 64, i64 noundef %call36) #38
  %call40 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buf) #39
  %call41 = call i64 @write(i32 noundef %cond17, ptr noundef nonnull %buf, i64 noundef %call40) #38
  %cmp42 = icmp eq i64 %call41, -1
  br i1 %cmp42, label %err, label %if.end45

if.end45:                                         ; preds = %if.end34
  %call46 = call i64 @write(i32 noundef %cond17, ptr noundef nonnull @.str.7, i64 noundef 2) #38
  %cmp47 = icmp eq i64 %call46, -1
  br i1 %cmp47, label %err, label %if.end50

if.end50:                                         ; preds = %if.end45
  %call51 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %msg) #39
  %call52 = call i64 @write(i32 noundef %cond17, ptr noundef %msg, i64 noundef %call51) #38
  %cmp53 = icmp eq i64 %call52, -1
  br i1 %cmp53, label %err, label %if.end56

if.end56:                                         ; preds = %if.end50
  %call57 = call i64 @write(i32 noundef %cond17, ptr noundef nonnull @.str.8, i64 noundef 1) #38
  br label %err

err:                                              ; preds = %if.end56, %if.then12, %if.end50, %if.end45, %if.end34, %if.end29, %if.else
  br i1 %cmp, label %if.end66, label %if.then64

if.then64:                                        ; preds = %err
  %call65 = call i32 @close(i32 noundef %cond17) #38
  br label %if.end66

if.end66:                                         ; preds = %cond.end, %entry, %lor.lhs.false, %if.then64, %err
  ret void
}

; Function Attrs: nofree
declare noundef i32 @open64(ptr nocapture noundef readonly, i32 noundef, ...) local_unnamed_addr #6

; Function Attrs: nofree
declare noundef i64 @write(i32 noundef, ptr nocapture noundef readonly, i64 noundef) local_unnamed_addr #6

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strlen(ptr nocapture noundef) local_unnamed_addr #7

declare i32 @ll2string(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare i64 @time(ptr noundef) local_unnamed_addr #3

declare i32 @close(i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @serverLogFromHandler(i32 noundef %level, ptr noundef %fmt, ...) local_unnamed_addr #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %msg = alloca [1024 x i8], align 16
  call void @llvm.va_start(ptr nonnull %ap)
  %call = call i32 @vsnprintf_async_signal_safe(ptr noundef nonnull %msg, i64 noundef 1024, ptr noundef %fmt, ptr noundef nonnull %ap) #38
  call void @llvm.va_end(ptr nonnull %ap)
  call void @serverLogRawFromHandler(i32 noundef %level, ptr noundef nonnull %msg)
  ret void
}

declare i32 @vsnprintf_async_signal_safe(ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nofree nounwind uwtable
define dso_local i64 @ustime() local_unnamed_addr #8 {
entry:
  %tv = alloca %struct.timeval, align 8
  %call = call i32 @gettimeofday(ptr noundef nonnull %tv, ptr noundef null) #38
  %0 = load i64, ptr %tv, align 8
  %mul = mul nsw i64 %0, 1000000
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i64 0, i32 1
  %1 = load i64, ptr %tv_usec, align 8
  %add = add nsw i64 %mul, %1
  ret i64 %add
}

; Function Attrs: nofree nounwind uwtable
define dso_local i64 @mstime() local_unnamed_addr #8 {
entry:
  %tv.i = alloca %struct.timeval, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i)
  %call.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i, ptr noundef null) #38
  %0 = load i64, ptr %tv.i, align 8
  %mul.i = mul nsw i64 %0, 1000000
  %tv_usec.i = getelementptr inbounds %struct.timeval, ptr %tv.i, i64 0, i32 1
  %1 = load i64, ptr %tv_usec.i, align 8
  %add.i = add nsw i64 %mul.i, %1
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i)
  %div = sdiv i64 %add.i, 1000
  ret i64 %div
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable
define dso_local i64 @commandTimeSnapshot() local_unnamed_addr #9 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 354), align 8
  ret i64 %0
}

; Function Attrs: noreturn nounwind uwtable
define dso_local void @exitFromChild(i32 noundef %retcode) local_unnamed_addr #10 {
entry:
  tail call void @_exit(i32 noundef %retcode) #40
  unreachable
}

; Function Attrs: noreturn
declare void @_exit(i32 noundef) local_unnamed_addr #11

; Function Attrs: nounwind uwtable
define dso_local void @dictVanillaFree(ptr nocapture readnone %d, ptr noundef %val) #0 {
entry:
  tail call void @zfree(ptr noundef %val) #38
  ret void
}

declare void @zfree(ptr noundef) #4

; Function Attrs: nounwind uwtable
define dso_local void @dictListDestructor(ptr nocapture readnone %d, ptr noundef %val) #0 {
entry:
  tail call void @listRelease(ptr noundef %val) #38
  ret void
}

declare void @listRelease(ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @dictSdsKeyCompare(ptr nocapture readnone %d, ptr nocapture noundef readonly %key1, ptr nocapture noundef readonly %key2) #12 {
entry:
  %arrayidx.i = getelementptr inbounds i8, ptr %key1, i64 -1
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %key1, i64 -3
  %1 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %1 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %key1, i64 -5
  %2 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %2 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %key1, i64 -9
  %3 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %3 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %key1, i64 -17
  %4 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %4, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %conv = trunc i64 %retval.0.i to i32
  %arrayidx.i4 = getelementptr inbounds i8, ptr %key2, i64 -1
  %5 = load i8, ptr %arrayidx.i4, align 1
  %conv.i5 = zext i8 %5 to i32
  %and.i6 = and i32 %conv.i5, 7
  switch i32 %and.i6, label %sdslen.exit22 [
    i32 0, label %sw.bb.i19
    i32 1, label %sw.bb3.i16
    i32 2, label %sw.bb5.i13
    i32 3, label %sw.bb9.i10
    i32 4, label %sw.bb13.i7
  ]

sw.bb.i19:                                        ; preds = %sdslen.exit
  %shr.i20 = lshr i32 %conv.i5, 3
  %conv2.i21 = zext nneg i32 %shr.i20 to i64
  br label %sdslen.exit22

sw.bb3.i16:                                       ; preds = %sdslen.exit
  %add.ptr.i17 = getelementptr inbounds i8, ptr %key2, i64 -3
  %6 = load i8, ptr %add.ptr.i17, align 1
  %conv4.i18 = zext i8 %6 to i64
  br label %sdslen.exit22

sw.bb5.i13:                                       ; preds = %sdslen.exit
  %add.ptr6.i14 = getelementptr inbounds i8, ptr %key2, i64 -5
  %7 = load i16, ptr %add.ptr6.i14, align 1
  %conv8.i15 = zext i16 %7 to i64
  br label %sdslen.exit22

sw.bb9.i10:                                       ; preds = %sdslen.exit
  %add.ptr10.i11 = getelementptr inbounds i8, ptr %key2, i64 -9
  %8 = load i32, ptr %add.ptr10.i11, align 1
  %conv12.i12 = zext i32 %8 to i64
  br label %sdslen.exit22

sw.bb13.i7:                                       ; preds = %sdslen.exit
  %add.ptr14.i8 = getelementptr inbounds i8, ptr %key2, i64 -17
  %9 = load i64, ptr %add.ptr14.i8, align 1
  br label %sdslen.exit22

sdslen.exit22:                                    ; preds = %sdslen.exit, %sw.bb.i19, %sw.bb3.i16, %sw.bb5.i13, %sw.bb9.i10, %sw.bb13.i7
  %retval.0.i9 = phi i64 [ %9, %sw.bb13.i7 ], [ %conv12.i12, %sw.bb9.i10 ], [ %conv8.i15, %sw.bb5.i13 ], [ %conv4.i18, %sw.bb3.i16 ], [ %conv2.i21, %sw.bb.i19 ], [ 0, %sdslen.exit ]
  %conv2 = trunc i64 %retval.0.i9 to i32
  %cmp.not = icmp eq i32 %conv, %conv2
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %sdslen.exit22
  %sext = shl i64 %retval.0.i, 32
  %conv4 = ashr exact i64 %sext, 32
  %bcmp = tail call i32 @bcmp(ptr nonnull %key1, ptr nonnull %key2, i64 %conv4)
  %cmp6 = icmp eq i32 %bcmp, 0
  %conv7 = zext i1 %cmp6 to i32
  br label %return

return:                                           ; preds = %sdslen.exit22, %if.end
  %retval.0 = phi i32 [ %conv7, %if.end ], [ 0, %sdslen.exit22 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define internal fastcc i64 @sdslen(ptr nocapture noundef readonly %s) unnamed_addr #13 {
entry:
  %arrayidx = getelementptr inbounds i8, ptr %s, i64 -1
  %0 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %return [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %shr = lshr i32 %conv, 3
  %conv2 = zext nneg i32 %shr to i64
  br label %return

sw.bb3:                                           ; preds = %entry
  %add.ptr = getelementptr inbounds i8, ptr %s, i64 -3
  %1 = load i8, ptr %add.ptr, align 1
  %conv4 = zext i8 %1 to i64
  br label %return

sw.bb5:                                           ; preds = %entry
  %add.ptr6 = getelementptr inbounds i8, ptr %s, i64 -5
  %2 = load i16, ptr %add.ptr6, align 1
  %conv8 = zext i16 %2 to i64
  br label %return

sw.bb9:                                           ; preds = %entry
  %add.ptr10 = getelementptr inbounds i8, ptr %s, i64 -9
  %3 = load i32, ptr %add.ptr10, align 1
  %conv12 = zext i32 %3 to i64
  br label %return

sw.bb13:                                          ; preds = %entry
  %add.ptr14 = getelementptr inbounds i8, ptr %s, i64 -17
  %4 = load i64, ptr %add.ptr14, align 1
  br label %return

return:                                           ; preds = %entry, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb
  %retval.0 = phi i64 [ %4, %sw.bb13 ], [ %conv12, %sw.bb9 ], [ %conv8, %sw.bb5 ], [ %conv4, %sw.bb3 ], [ %conv2, %sw.bb ], [ 0, %entry ]
  ret i64 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(read) uwtable
define dso_local i32 @dictSdsKeyCaseCompare(ptr nocapture readnone %d, ptr nocapture noundef readonly %key1, ptr nocapture noundef readonly %key2) #14 {
entry:
  %call = tail call i32 @strcasecmp(ptr noundef %key1, ptr noundef %key2) #39
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(read)
declare i32 @strcasecmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #15

; Function Attrs: nounwind uwtable
define dso_local void @dictObjectDestructor(ptr nocapture readnone %d, ptr noundef %val) #0 {
entry:
  %cmp = icmp eq ptr %val, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  tail call void @decrRefCount(ptr noundef nonnull %val) #38
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

declare void @decrRefCount(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @dictSdsDestructor(ptr nocapture readnone %d, ptr noundef %val) #0 {
entry:
  tail call void @sdsfree(ptr noundef %val) #38
  ret void
}

declare void @sdsfree(ptr noundef) #4

; Function Attrs: nounwind uwtable
define dso_local ptr @dictSdsDup(ptr nocapture noundef readnone %d, ptr noundef %key) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @sdsdup(ptr noundef %key) #38
  ret ptr %call
}

declare ptr @sdsdup(ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @dictObjKeyCompare(ptr nocapture readnone %d, ptr nocapture noundef readonly %key1, ptr nocapture noundef readonly %key2) #16 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key1, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %key2, i64 0, i32 2
  %1 = load ptr, ptr %ptr1, align 8
  %arrayidx.i.i = getelementptr inbounds i8, ptr %0, i64 -1
  %2 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %2 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %entry
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %entry
  %add.ptr.i.i = getelementptr inbounds i8, ptr %0, i64 -3
  %3 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %3 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %entry
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %0, i64 -5
  %4 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %4 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %entry
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %0, i64 -9
  %5 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %5 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %entry
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %0, i64 -17
  %6 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %entry
  %retval.0.i.i = phi i64 [ %6, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %entry ]
  %conv.i = trunc i64 %retval.0.i.i to i32
  %arrayidx.i4.i = getelementptr inbounds i8, ptr %1, i64 -1
  %7 = load i8, ptr %arrayidx.i4.i, align 1
  %conv.i5.i = zext i8 %7 to i32
  %and.i6.i = and i32 %conv.i5.i, 7
  switch i32 %and.i6.i, label %sdslen.exit22.i [
    i32 0, label %sw.bb.i19.i
    i32 1, label %sw.bb3.i16.i
    i32 2, label %sw.bb5.i13.i
    i32 3, label %sw.bb9.i10.i
    i32 4, label %sw.bb13.i7.i
  ]

sw.bb.i19.i:                                      ; preds = %sdslen.exit.i
  %shr.i20.i = lshr i32 %conv.i5.i, 3
  %conv2.i21.i = zext nneg i32 %shr.i20.i to i64
  br label %sdslen.exit22.i

sw.bb3.i16.i:                                     ; preds = %sdslen.exit.i
  %add.ptr.i17.i = getelementptr inbounds i8, ptr %1, i64 -3
  %8 = load i8, ptr %add.ptr.i17.i, align 1
  %conv4.i18.i = zext i8 %8 to i64
  br label %sdslen.exit22.i

sw.bb5.i13.i:                                     ; preds = %sdslen.exit.i
  %add.ptr6.i14.i = getelementptr inbounds i8, ptr %1, i64 -5
  %9 = load i16, ptr %add.ptr6.i14.i, align 1
  %conv8.i15.i = zext i16 %9 to i64
  br label %sdslen.exit22.i

sw.bb9.i10.i:                                     ; preds = %sdslen.exit.i
  %add.ptr10.i11.i = getelementptr inbounds i8, ptr %1, i64 -9
  %10 = load i32, ptr %add.ptr10.i11.i, align 1
  %conv12.i12.i = zext i32 %10 to i64
  br label %sdslen.exit22.i

sw.bb13.i7.i:                                     ; preds = %sdslen.exit.i
  %add.ptr14.i8.i = getelementptr inbounds i8, ptr %1, i64 -17
  %11 = load i64, ptr %add.ptr14.i8.i, align 1
  br label %sdslen.exit22.i

sdslen.exit22.i:                                  ; preds = %sw.bb13.i7.i, %sw.bb9.i10.i, %sw.bb5.i13.i, %sw.bb3.i16.i, %sw.bb.i19.i, %sdslen.exit.i
  %retval.0.i9.i = phi i64 [ %11, %sw.bb13.i7.i ], [ %conv12.i12.i, %sw.bb9.i10.i ], [ %conv8.i15.i, %sw.bb5.i13.i ], [ %conv4.i18.i, %sw.bb3.i16.i ], [ %conv2.i21.i, %sw.bb.i19.i ], [ 0, %sdslen.exit.i ]
  %conv2.i = trunc i64 %retval.0.i9.i to i32
  %cmp.not.i = icmp eq i32 %conv.i, %conv2.i
  br i1 %cmp.not.i, label %if.end.i, label %dictSdsKeyCompare.exit

if.end.i:                                         ; preds = %sdslen.exit22.i
  %sext.i = shl i64 %retval.0.i.i, 32
  %conv4.i = ashr exact i64 %sext.i, 32
  %bcmp.i = tail call i32 @bcmp(ptr nonnull %0, ptr nonnull %1, i64 %conv4.i)
  %cmp6.i = icmp eq i32 %bcmp.i, 0
  %conv7.i = zext i1 %cmp6.i to i32
  br label %dictSdsKeyCompare.exit

dictSdsKeyCompare.exit:                           ; preds = %sdslen.exit22.i, %if.end.i
  %retval.0.i = phi i32 [ %conv7.i, %if.end.i ], [ 0, %sdslen.exit22.i ]
  ret i32 %retval.0.i
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dictObjHash(ptr nocapture noundef readonly %key) #0 {
entry:
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call2 = tail call i64 @dictGenHashFunction(ptr noundef nonnull %0, i64 noundef %retval.0.i) #38
  ret i64 %call2
}

declare i64 @dictGenHashFunction(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local i64 @dictSdsHash(ptr noundef %key) #0 {
entry:
  %arrayidx.i = getelementptr inbounds i8, ptr %key, i64 -1
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %key, i64 -3
  %1 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %1 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %key, i64 -5
  %2 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %2 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %key, i64 -9
  %3 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %3 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %key, i64 -17
  %4 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %4, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call1 = tail call i64 @dictGenHashFunction(ptr noundef nonnull %key, i64 noundef %retval.0.i) #38
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dictSdsCaseHash(ptr noundef %key) #0 {
entry:
  %arrayidx.i = getelementptr inbounds i8, ptr %key, i64 -1
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %key, i64 -3
  %1 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %1 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %key, i64 -5
  %2 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %2 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %key, i64 -9
  %3 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %3 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %key, i64 -17
  %4 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %4, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call1 = tail call i64 @dictGenCaseHashFunction(ptr noundef nonnull %key, i64 noundef %retval.0.i) #38
  ret i64 %call1
}

declare i64 @dictGenCaseHashFunction(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local i64 @dictCStrHash(ptr noundef %key) local_unnamed_addr #0 {
entry:
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %key) #39
  %call1 = tail call i64 @dictGenHashFunction(ptr noundef %key, i64 noundef %call) #38
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dictCStrCaseHash(ptr noundef %key) #0 {
entry:
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %key) #39
  %call1 = tail call i64 @dictGenCaseHashFunction(ptr noundef %key, i64 noundef %call) #38
  ret i64 %call1
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @dictCStrKeyCompare(ptr nocapture noundef readnone %d, ptr nocapture noundef readonly %key1, ptr nocapture noundef readonly %key2) local_unnamed_addr #12 {
entry:
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %key1) #39
  %conv = trunc i64 %call to i32
  %call1 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %key2) #39
  %conv2 = trunc i64 %call1 to i32
  %cmp.not = icmp eq i32 %conv, %conv2
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %sext = shl i64 %call, 32
  %conv4 = ashr exact i64 %sext, 32
  %bcmp = tail call i32 @bcmp(ptr %key1, ptr %key2, i64 %conv4)
  %cmp6 = icmp eq i32 %bcmp, 0
  %conv7 = zext i1 %cmp6 to i32
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %conv7, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(read) uwtable
define dso_local i32 @dictCStrKeyCaseCompare(ptr nocapture readnone %d, ptr nocapture noundef readonly %key1, ptr nocapture noundef readonly %key2) #14 {
entry:
  %call = tail call i32 @strcasecmp(ptr noundef %key1, ptr noundef %key2) #39
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @dictEncObjKeyCompare(ptr nocapture readnone %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %bf.load = load i32, ptr %key1, align 8
  %0 = and i32 %bf.load, 240
  %cmp1 = icmp eq i32 %0, 16
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %bf.load2 = load i32, ptr %key2, align 8
  %1 = and i32 %bf.load2, 240
  %cmp5 = icmp eq i32 %1, 16
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key1, i64 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %ptr6 = getelementptr inbounds %struct.redisObject, ptr %key2, i64 0, i32 2
  %3 = load ptr, ptr %ptr6, align 8
  %cmp7 = icmp eq ptr %2, %3
  %conv = zext i1 %cmp7 to i32
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %refcount = getelementptr inbounds %struct.redisObject, ptr %key1, i64 0, i32 1
  %4 = load i32, ptr %refcount, align 4
  %cmp8.not = icmp eq i32 %4, 2147483646
  br i1 %cmp8.not, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  %call = tail call ptr @getDecodedObject(ptr noundef nonnull %key1) #38
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end
  %o1.0 = phi ptr [ %call, %if.then10 ], [ %key1, %if.end ]
  %refcount12 = getelementptr inbounds %struct.redisObject, ptr %key2, i64 0, i32 1
  %5 = load i32, ptr %refcount12, align 4
  %cmp13.not = icmp eq i32 %5, 2147483646
  br i1 %cmp13.not, label %if.end17, label %if.then15

if.then15:                                        ; preds = %if.end11
  %call16 = tail call ptr @getDecodedObject(ptr noundef nonnull %key2) #38
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end11
  %o2.0 = phi ptr [ %call16, %if.then15 ], [ %key2, %if.end11 ]
  %ptr18 = getelementptr inbounds %struct.redisObject, ptr %o1.0, i64 0, i32 2
  %6 = load ptr, ptr %ptr18, align 8
  %ptr19 = getelementptr inbounds %struct.redisObject, ptr %o2.0, i64 0, i32 2
  %7 = load ptr, ptr %ptr19, align 8
  %arrayidx.i.i = getelementptr inbounds i8, ptr %6, i64 -1
  %8 = load i8, ptr %arrayidx.i.i, align 1
  %conv.i.i = zext i8 %8 to i32
  %and.i.i = and i32 %conv.i.i, 7
  switch i32 %and.i.i, label %sdslen.exit.i [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.end17
  %shr.i.i = lshr i32 %conv.i.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.end17
  %add.ptr.i.i = getelementptr inbounds i8, ptr %6, i64 -3
  %9 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %9 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.end17
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %6, i64 -5
  %10 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %10 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.end17
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %6, i64 -9
  %11 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %11 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.end17
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %6, i64 -17
  %12 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i, %if.end17
  %retval.0.i.i = phi i64 [ %12, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ], [ 0, %if.end17 ]
  %conv.i = trunc i64 %retval.0.i.i to i32
  %arrayidx.i4.i = getelementptr inbounds i8, ptr %7, i64 -1
  %13 = load i8, ptr %arrayidx.i4.i, align 1
  %conv.i5.i = zext i8 %13 to i32
  %and.i6.i = and i32 %conv.i5.i, 7
  switch i32 %and.i6.i, label %sdslen.exit22.i [
    i32 0, label %sw.bb.i19.i
    i32 1, label %sw.bb3.i16.i
    i32 2, label %sw.bb5.i13.i
    i32 3, label %sw.bb9.i10.i
    i32 4, label %sw.bb13.i7.i
  ]

sw.bb.i19.i:                                      ; preds = %sdslen.exit.i
  %shr.i20.i = lshr i32 %conv.i5.i, 3
  %conv2.i21.i = zext nneg i32 %shr.i20.i to i64
  br label %sdslen.exit22.i

sw.bb3.i16.i:                                     ; preds = %sdslen.exit.i
  %add.ptr.i17.i = getelementptr inbounds i8, ptr %7, i64 -3
  %14 = load i8, ptr %add.ptr.i17.i, align 1
  %conv4.i18.i = zext i8 %14 to i64
  br label %sdslen.exit22.i

sw.bb5.i13.i:                                     ; preds = %sdslen.exit.i
  %add.ptr6.i14.i = getelementptr inbounds i8, ptr %7, i64 -5
  %15 = load i16, ptr %add.ptr6.i14.i, align 1
  %conv8.i15.i = zext i16 %15 to i64
  br label %sdslen.exit22.i

sw.bb9.i10.i:                                     ; preds = %sdslen.exit.i
  %add.ptr10.i11.i = getelementptr inbounds i8, ptr %7, i64 -9
  %16 = load i32, ptr %add.ptr10.i11.i, align 1
  %conv12.i12.i = zext i32 %16 to i64
  br label %sdslen.exit22.i

sw.bb13.i7.i:                                     ; preds = %sdslen.exit.i
  %add.ptr14.i8.i = getelementptr inbounds i8, ptr %7, i64 -17
  %17 = load i64, ptr %add.ptr14.i8.i, align 1
  br label %sdslen.exit22.i

sdslen.exit22.i:                                  ; preds = %sw.bb13.i7.i, %sw.bb9.i10.i, %sw.bb5.i13.i, %sw.bb3.i16.i, %sw.bb.i19.i, %sdslen.exit.i
  %retval.0.i9.i = phi i64 [ %17, %sw.bb13.i7.i ], [ %conv12.i12.i, %sw.bb9.i10.i ], [ %conv8.i15.i, %sw.bb5.i13.i ], [ %conv4.i18.i, %sw.bb3.i16.i ], [ %conv2.i21.i, %sw.bb.i19.i ], [ 0, %sdslen.exit.i ]
  %conv2.i = trunc i64 %retval.0.i9.i to i32
  %cmp.not.i = icmp eq i32 %conv.i, %conv2.i
  br i1 %cmp.not.i, label %if.end.i, label %dictSdsKeyCompare.exit

if.end.i:                                         ; preds = %sdslen.exit22.i
  %sext.i = shl i64 %retval.0.i.i, 32
  %conv4.i = ashr exact i64 %sext.i, 32
  %bcmp.i = tail call i32 @bcmp(ptr nonnull %6, ptr nonnull %7, i64 %conv4.i)
  %cmp6.i = icmp eq i32 %bcmp.i, 0
  %conv7.i = zext i1 %cmp6.i to i32
  br label %dictSdsKeyCompare.exit

dictSdsKeyCompare.exit:                           ; preds = %sdslen.exit22.i, %if.end.i
  %retval.0.i = phi i32 [ %conv7.i, %if.end.i ], [ 0, %sdslen.exit22.i ]
  %refcount21 = getelementptr inbounds %struct.redisObject, ptr %o1.0, i64 0, i32 1
  %18 = load i32, ptr %refcount21, align 4
  %cmp22.not = icmp eq i32 %18, 2147483646
  br i1 %cmp22.not, label %if.end25, label %if.then24

if.then24:                                        ; preds = %dictSdsKeyCompare.exit
  tail call void @decrRefCount(ptr noundef nonnull %o1.0) #38
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %dictSdsKeyCompare.exit
  %refcount26 = getelementptr inbounds %struct.redisObject, ptr %o2.0, i64 0, i32 1
  %19 = load i32, ptr %refcount26, align 4
  %cmp27.not = icmp eq i32 %19, 2147483646
  br i1 %cmp27.not, label %return, label %if.then29

if.then29:                                        ; preds = %if.end25
  tail call void @decrRefCount(ptr noundef nonnull %o2.0) #38
  br label %return

return:                                           ; preds = %if.end25, %if.then29, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %retval.0.i, %if.then29 ], [ %retval.0.i, %if.end25 ]
  ret i32 %retval.0
}

declare ptr @getDecodedObject(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local i64 @dictEncObjHash(ptr nocapture noundef readonly %key) #0 {
entry:
  %buf = alloca [32 x i8], align 16
  %bf.load = load i32, ptr %key, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  switch i32 %bf.clear, label %if.else16 [
    i32 0, label %if.then
    i32 8, label %if.then
    i32 1, label %if.then11
  ]

if.then:                                          ; preds = %entry, %entry
  %ptr = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then ]
  %call6 = tail call i64 @dictGenHashFunction(ptr noundef nonnull %0, i64 noundef %retval.0.i) #38
  br label %return

if.then11:                                        ; preds = %entry
  %ptr12 = getelementptr inbounds %struct.redisObject, ptr %key, i64 0, i32 2
  %6 = load ptr, ptr %ptr12, align 8
  %7 = ptrtoint ptr %6 to i64
  %call13 = call i32 @ll2string(ptr noundef nonnull %buf, i64 noundef 32, i64 noundef %7) #38
  %conv = sext i32 %call13 to i64
  %call15 = call i64 @dictGenHashFunction(ptr noundef nonnull %buf, i64 noundef %conv) #38
  br label %return

if.else16:                                        ; preds = %entry
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 404, ptr noundef nonnull @.str.10) #38
  tail call void @abort() #40
  unreachable

return:                                           ; preds = %if.then11, %sdslen.exit
  %retval.0 = phi i64 [ %call6, %sdslen.exit ], [ %call15, %if.then11 ]
  ret i64 %retval.0
}

declare void @_serverPanic(ptr noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #4

; Function Attrs: noreturn nounwind
declare void @abort() local_unnamed_addr #17

; Function Attrs: nounwind uwtable
define dso_local i32 @dictExpandAllowed(i64 noundef %moreMem, double noundef %usedRatio) #0 {
entry:
  %cmp = fcmp ugt double %usedRatio, 1.618000e+00
  br i1 %cmp, label %return, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @overMaxmemoryAfterAlloc(i64 noundef %moreMem) #38
  %tobool.not = icmp eq i32 %call, 0
  %lnot.ext = zext i1 %tobool.not to i32
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ %lnot.ext, %if.then ], [ 1, %entry ]
  ret i32 %retval.0
}

declare i32 @overMaxmemoryAfterAlloc(i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @dictRehashingStarted(ptr noundef %d, i32 noundef %keyType) local_unnamed_addr #0 {
entry:
  %from = alloca i64, align 8
  %to = alloca i64, align 8
  %metadata1 = getelementptr inbounds %struct.dict, ptr %d, i64 0, i32 6
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %call = tail call ptr @listAddNodeTail(ptr noundef %0, ptr noundef %d) #38
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %tail = getelementptr inbounds %struct.list, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %tail, align 8
  store ptr %2, ptr %metadata1, align 8
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @dictRehashingInfo(ptr noundef nonnull %d, ptr noundef nonnull %from, ptr noundef nonnull %to) #38
  %4 = load i64, ptr %to, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %idxprom = zext i32 %keyType to i64
  %bucket_count = getelementptr inbounds %struct.redisDb, ptr %5, i64 0, i32 11, i64 %idxprom, i32 3
  %6 = load i64, ptr %bucket_count, align 8
  %add = add i64 %6, %4
  store i64 %add, ptr %bucket_count, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

declare ptr @listAddNodeTail(ptr noundef, ptr noundef) local_unnamed_addr #4

declare void @dictRehashingInfo(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @dictRehashingCompleted(ptr noundef %d, i32 noundef %keyType) local_unnamed_addr #0 {
entry:
  %from = alloca i64, align 8
  %to = alloca i64, align 8
  %metadata1 = getelementptr inbounds %struct.dict, ptr %d, i64 0, i32 6
  %0 = load ptr, ptr %metadata1, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  tail call void @listDelNode(ptr noundef %1, ptr noundef nonnull %0) #38
  store ptr null, ptr %metadata1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool4.not = icmp eq i32 %2, 0
  br i1 %tobool4.not, label %return, label %if.end6

if.end6:                                          ; preds = %if.end
  call void @dictRehashingInfo(ptr noundef nonnull %d, ptr noundef nonnull %from, ptr noundef nonnull %to) #38
  %3 = load i64, ptr %from, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %idxprom = zext i32 %keyType to i64
  %bucket_count = getelementptr inbounds %struct.redisDb, ptr %4, i64 0, i32 11, i64 %idxprom, i32 3
  %5 = load i64, ptr %bucket_count, align 8
  %sub = sub i64 %5, %3
  store i64 %sub, ptr %bucket_count, align 8
  br label %return

return:                                           ; preds = %if.end, %if.end6
  ret void
}

declare void @listDelNode(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @dbDictRehashingStarted(ptr noundef %d) #0 {
entry:
  %from.i = alloca i64, align 8
  %to.i = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %from.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %to.i)
  %metadata1.i = getelementptr inbounds %struct.dict, ptr %d, i64 0, i32 6
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %call.i = tail call ptr @listAddNodeTail(ptr noundef %0, ptr noundef %d) #38
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %tail.i = getelementptr inbounds %struct.list, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %tail.i, align 8
  store ptr %2, ptr %metadata1.i, align 8
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not.i = icmp eq i32 %3, 0
  br i1 %tobool.not.i, label %dictRehashingStarted.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  call void @dictRehashingInfo(ptr noundef nonnull %d, ptr noundef nonnull %from.i, ptr noundef nonnull %to.i) #38
  %4 = load i64, ptr %to.i, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %bucket_count.i = getelementptr inbounds %struct.redisDb, ptr %5, i64 0, i32 11, i64 0, i32 3
  %6 = load i64, ptr %bucket_count.i, align 8
  %add.i = add i64 %6, %4
  store i64 %add.i, ptr %bucket_count.i, align 8
  br label %dictRehashingStarted.exit

dictRehashingStarted.exit:                        ; preds = %entry, %if.end.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %from.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %to.i)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @dbDictRehashingCompleted(ptr noundef %d) #0 {
entry:
  %from.i = alloca i64, align 8
  %to.i = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %from.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %to.i)
  %metadata1.i = getelementptr inbounds %struct.dict, ptr %d, i64 0, i32 6
  %0 = load ptr, ptr %metadata1.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  tail call void @listDelNode(ptr noundef %1, ptr noundef nonnull %0) #38
  store ptr null, ptr %metadata1.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool4.not.i = icmp eq i32 %2, 0
  br i1 %tobool4.not.i, label %dictRehashingCompleted.exit, label %if.end6.i

if.end6.i:                                        ; preds = %if.end.i
  call void @dictRehashingInfo(ptr noundef nonnull %d, ptr noundef nonnull %from.i, ptr noundef nonnull %to.i) #38
  %3 = load i64, ptr %from.i, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %bucket_count.i = getelementptr inbounds %struct.redisDb, ptr %4, i64 0, i32 11, i64 0, i32 3
  %5 = load i64, ptr %bucket_count.i, align 8
  %sub.i = sub i64 %5, %3
  store i64 %sub.i, ptr %bucket_count.i, align 8
  br label %dictRehashingCompleted.exit

dictRehashingCompleted.exit:                      ; preds = %if.end.i, %if.end6.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %from.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %to.i)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @dbExpiresRehashingStarted(ptr noundef %d) #0 {
entry:
  %from.i = alloca i64, align 8
  %to.i = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %from.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %to.i)
  %metadata1.i = getelementptr inbounds %struct.dict, ptr %d, i64 0, i32 6
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %call.i = tail call ptr @listAddNodeTail(ptr noundef %0, ptr noundef %d) #38
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %tail.i = getelementptr inbounds %struct.list, ptr %1, i64 0, i32 1
  %2 = load ptr, ptr %tail.i, align 8
  store ptr %2, ptr %metadata1.i, align 8
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not.i = icmp eq i32 %3, 0
  br i1 %tobool.not.i, label %dictRehashingStarted.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  call void @dictRehashingInfo(ptr noundef nonnull %d, ptr noundef nonnull %from.i, ptr noundef nonnull %to.i) #38
  %4 = load i64, ptr %to.i, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %bucket_count.i = getelementptr inbounds %struct.redisDb, ptr %5, i64 0, i32 11, i64 1, i32 3
  %6 = load i64, ptr %bucket_count.i, align 8
  %add.i = add i64 %6, %4
  store i64 %add.i, ptr %bucket_count.i, align 8
  br label %dictRehashingStarted.exit

dictRehashingStarted.exit:                        ; preds = %entry, %if.end.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %from.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %to.i)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @dbExpiresRehashingCompleted(ptr noundef %d) #0 {
entry:
  %from.i = alloca i64, align 8
  %to.i = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %from.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %to.i)
  %metadata1.i = getelementptr inbounds %struct.dict, ptr %d, i64 0, i32 6
  %0 = load ptr, ptr %metadata1.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  tail call void @listDelNode(ptr noundef %1, ptr noundef nonnull %0) #38
  store ptr null, ptr %metadata1.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool4.not.i = icmp eq i32 %2, 0
  br i1 %tobool4.not.i, label %dictRehashingCompleted.exit, label %if.end6.i

if.end6.i:                                        ; preds = %if.end.i
  call void @dictRehashingInfo(ptr noundef nonnull %d, ptr noundef nonnull %from.i, ptr noundef nonnull %to.i) #38
  %3 = load i64, ptr %from.i, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %bucket_count.i = getelementptr inbounds %struct.redisDb, ptr %4, i64 0, i32 11, i64 1, i32 3
  %5 = load i64, ptr %bucket_count.i, align 8
  %sub.i = sub i64 %5, %3
  store i64 %sub.i, ptr %bucket_count.i, align 8
  br label %dictRehashingCompleted.exit

dictRehashingCompleted.exit:                      ; preds = %if.end.i, %if.end6.i
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %from.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %to.i)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i64 @dbDictMetadataSize(ptr nocapture readnone %d) #18 {
entry:
  ret i64 8
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @htNeedsResize(ptr nocapture noundef readonly %dict) local_unnamed_addr #13 {
entry:
  %ht_size_exp = getelementptr inbounds %struct.dict, ptr %dict, i64 0, i32 5
  %0 = load i8, ptr %ht_size_exp, align 2
  %cmp = icmp eq i8 %0, -1
  %conv = sext i8 %0 to i64
  %sh_prom = and i64 %conv, 4294967295
  %shl = shl nuw i64 1, %sh_prom
  %cond = select i1 %cmp, i64 0, i64 %shl
  %arrayidx6 = getelementptr inbounds %struct.dict, ptr %dict, i64 0, i32 5, i64 1
  %1 = load i8, ptr %arrayidx6, align 1
  %cmp8 = icmp eq i8 %1, -1
  %conv7 = sext i8 %1 to i64
  %sh_prom15 = and i64 %conv7, 4294967295
  %shl16 = shl nuw i64 1, %sh_prom15
  %cond18 = select i1 %cmp8, i64 0, i64 %shl16
  %add = add i64 %cond18, %cond
  %cmp23 = icmp sgt i64 %add, 4
  br i1 %cmp23, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %ht_used = getelementptr inbounds %struct.dict, ptr %dict, i64 0, i32 2
  %2 = load i64, ptr %ht_used, align 8
  %arrayidx21 = getelementptr inbounds %struct.dict, ptr %dict, i64 0, i32 2, i64 1
  %3 = load i64, ptr %arrayidx21, align 8
  %add22 = add i64 %3, %2
  %mul = mul nsw i64 %add22, 100
  %div = sdiv i64 %mul, %add
  %cmp25 = icmp slt i64 %div, 10
  %4 = zext i1 %cmp25 to i32
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %land.ext = phi i32 [ 0, %entry ], [ %4, %land.rhs ]
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define dso_local void @tryResizeHashTables(i32 noundef %dbid) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %idxprom = sext i32 %dbid to i64
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %0, i64 %idxprom
  %expires = getelementptr inbounds %struct.redisDb, ptr %0, i64 %idxprom, i32 1
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc38
  %cmp24 = phi i1 [ true, %entry ], [ false, %for.inc38 ]
  %indvars.iv = phi i64 [ 0, %entry ], [ 1, %for.inc38 ]
  %1 = trunc i64 %indvars.iv to i32
  %call = tail call i64 @dbSize(ptr noundef %arrayidx, i32 noundef %1) #38
  %cmp1 = icmp eq i64 %call, 0
  br i1 %cmp1, label %for.inc38, label %if.end

if.end:                                           ; preds = %for.body
  %arrayidx3 = getelementptr inbounds %struct.redisDb, ptr %0, i64 %idxprom, i32 11, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx3, align 8
  %cmp4 = icmp eq i32 %2, -1
  br i1 %cmp4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end
  %call6 = tail call i32 @findSlotByKeyIndex(ptr noundef nonnull %arrayidx, i64 noundef 1, i32 noundef %1) #38
  store i32 %call6, ptr %arrayidx3, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %if.end
  %3 = phi i32 [ %call6, %if.then5 ], [ %2, %if.end ]
  br i1 %cmp24, label %land.rhs.us, label %land.rhs

land.rhs.us:                                      ; preds = %if.end11, %if.end32.us
  %4 = phi i32 [ %call33.us, %if.end32.us ], [ %3, %if.end11 ]
  %i.026.us = phi i32 [ %inc.us, %if.end32.us ], [ 0, %if.end11 ]
  %cmp18.not.us = icmp eq i32 %4, -1
  br i1 %cmp18.not.us, label %for.inc38, label %for.body19.us

for.body19.us:                                    ; preds = %land.rhs.us
  %5 = load ptr, ptr %arrayidx, align 8
  %idxprom25.us = sext i32 %4 to i64
  %arrayidx26.us = getelementptr inbounds ptr, ptr %5, i64 %idxprom25.us
  %cond.us = load ptr, ptr %arrayidx26.us, align 8
  %ht_size_exp.i.us = getelementptr inbounds %struct.dict, ptr %cond.us, i64 0, i32 5
  %6 = load i8, ptr %ht_size_exp.i.us, align 2
  %cmp.i.us = icmp eq i8 %6, -1
  %conv.i.us = sext i8 %6 to i64
  %sh_prom.i.us = and i64 %conv.i.us, 4294967295
  %shl.i.us = shl nuw i64 1, %sh_prom.i.us
  %cond.i.us = select i1 %cmp.i.us, i64 0, i64 %shl.i.us
  %arrayidx6.i.us = getelementptr inbounds %struct.dict, ptr %cond.us, i64 0, i32 5, i64 1
  %7 = load i8, ptr %arrayidx6.i.us, align 1
  %cmp8.i.us = icmp eq i8 %7, -1
  %conv7.i.us = sext i8 %7 to i64
  %sh_prom15.i.us = and i64 %conv7.i.us, 4294967295
  %shl16.i.us = shl nuw i64 1, %sh_prom15.i.us
  %cond18.i.us = select i1 %cmp8.i.us, i64 0, i64 %shl16.i.us
  %add.i.us = add i64 %cond18.i.us, %cond.i.us
  %cmp23.i.us = icmp sgt i64 %add.i.us, 4
  br i1 %cmp23.i.us, label %htNeedsResize.exit.us, label %if.end32.us

htNeedsResize.exit.us:                            ; preds = %for.body19.us
  %ht_used.i.us = getelementptr inbounds %struct.dict, ptr %cond.us, i64 0, i32 2
  %8 = load i64, ptr %ht_used.i.us, align 8
  %arrayidx21.i.us = getelementptr inbounds %struct.dict, ptr %cond.us, i64 0, i32 2, i64 1
  %9 = load i64, ptr %arrayidx21.i.us, align 8
  %add22.i.us = add i64 %9, %8
  %mul.i.us = mul nsw i64 %add22.i.us, 100
  %div.i.us = sdiv i64 %mul.i.us, %add.i.us
  %cmp25.i.us = icmp sgt i64 %div.i.us, 9
  br i1 %cmp25.i.us, label %if.end32.us, label %if.then30.us

if.then30.us:                                     ; preds = %htNeedsResize.exit.us
  %call31.us = tail call i32 @dictResize(ptr noundef nonnull %cond.us) #38
  br label %if.end32.us

if.end32.us:                                      ; preds = %if.then30.us, %htNeedsResize.exit.us, %for.body19.us
  %call33.us = tail call i32 @dbGetNextNonEmptySlot(ptr noundef nonnull %arrayidx, i32 noundef %4, i32 noundef 0) #38
  store i32 %call33.us, ptr %arrayidx3, align 8
  %inc.us = add nuw nsw i32 %i.026.us, 1
  %exitcond31.not = icmp eq i32 %inc.us, 16
  br i1 %exitcond31.not, label %for.inc38, label %land.rhs.us, !llvm.loop !5

land.rhs:                                         ; preds = %if.end11, %if.end32
  %10 = phi i32 [ %call33, %if.end32 ], [ %3, %if.end11 ]
  %i.026 = phi i32 [ %inc, %if.end32 ], [ 0, %if.end11 ]
  %cmp18.not = icmp eq i32 %10, -1
  br i1 %cmp18.not, label %for.inc38, label %for.body19

for.body19:                                       ; preds = %land.rhs
  %11 = load ptr, ptr %expires, align 8
  %idxprom27 = sext i32 %10 to i64
  %arrayidx28 = getelementptr inbounds ptr, ptr %11, i64 %idxprom27
  %cond = load ptr, ptr %arrayidx28, align 8
  %ht_size_exp.i = getelementptr inbounds %struct.dict, ptr %cond, i64 0, i32 5
  %12 = load i8, ptr %ht_size_exp.i, align 2
  %cmp.i = icmp eq i8 %12, -1
  %conv.i = sext i8 %12 to i64
  %sh_prom.i = and i64 %conv.i, 4294967295
  %shl.i = shl nuw i64 1, %sh_prom.i
  %cond.i = select i1 %cmp.i, i64 0, i64 %shl.i
  %arrayidx6.i = getelementptr inbounds %struct.dict, ptr %cond, i64 0, i32 5, i64 1
  %13 = load i8, ptr %arrayidx6.i, align 1
  %cmp8.i = icmp eq i8 %13, -1
  %conv7.i = sext i8 %13 to i64
  %sh_prom15.i = and i64 %conv7.i, 4294967295
  %shl16.i = shl nuw i64 1, %sh_prom15.i
  %cond18.i = select i1 %cmp8.i, i64 0, i64 %shl16.i
  %add.i = add i64 %cond18.i, %cond.i
  %cmp23.i = icmp sgt i64 %add.i, 4
  br i1 %cmp23.i, label %htNeedsResize.exit, label %if.end32

htNeedsResize.exit:                               ; preds = %for.body19
  %ht_used.i = getelementptr inbounds %struct.dict, ptr %cond, i64 0, i32 2
  %14 = load i64, ptr %ht_used.i, align 8
  %arrayidx21.i = getelementptr inbounds %struct.dict, ptr %cond, i64 0, i32 2, i64 1
  %15 = load i64, ptr %arrayidx21.i, align 8
  %add22.i = add i64 %15, %14
  %mul.i = mul nsw i64 %add22.i, 100
  %div.i = sdiv i64 %mul.i, %add.i
  %cmp25.i = icmp sgt i64 %div.i, 9
  br i1 %cmp25.i, label %if.end32, label %if.then30

if.then30:                                        ; preds = %htNeedsResize.exit
  %call31 = tail call i32 @dictResize(ptr noundef nonnull %cond) #38
  br label %if.end32

if.end32:                                         ; preds = %for.body19, %if.then30, %htNeedsResize.exit
  %call33 = tail call i32 @dbGetNextNonEmptySlot(ptr noundef nonnull %arrayidx, i32 noundef %10, i32 noundef %1) #38
  store i32 %call33, ptr %arrayidx3, align 8
  %inc = add nuw nsw i32 %i.026, 1
  %exitcond.not = icmp eq i32 %inc, 16
  br i1 %exitcond.not, label %for.inc38, label %land.rhs, !llvm.loop !5

for.inc38:                                        ; preds = %if.end32, %land.rhs, %if.end32.us, %land.rhs.us, %for.body
  br i1 %cmp24, label %for.body, label %for.end40, !llvm.loop !7

for.end40:                                        ; preds = %for.inc38
  ret void
}

declare i64 @dbSize(ptr noundef, i32 noundef) local_unnamed_addr #4

declare i32 @findSlotByKeyIndex(ptr noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

declare i32 @dictResize(ptr noundef) local_unnamed_addr #4

declare i32 @dbGetNextNonEmptySlot(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @incrementallyRehash() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %return, label %do.body

do.body:                                          ; preds = %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %2, 0
  br i1 %cmp1, label %do.end, label %if.end3

if.end3:                                          ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.11, i64 noundef %1)
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end3
  %3 = load ptr, ptr @getMonotonicUs, align 8
  %call.i = tail call i64 %3() #38
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %5 = load ptr, ptr %4, align 8
  %tobool.not4 = icmp eq ptr %5, null
  br i1 %tobool.not4, label %return, label %while.body

while.body:                                       ; preds = %do.end, %if.end7
  %6 = phi ptr [ %10, %if.end7 ], [ %5, %do.end ]
  %7 = load ptr, ptr @getMonotonicUs, align 8
  %call.i3 = tail call i64 %7() #38
  %sub.i = sub i64 %call.i3, %call.i
  %cmp5 = icmp ugt i64 %sub.i, 999
  br i1 %cmp5, label %return, label %if.end7

if.end7:                                          ; preds = %while.body
  %value = getelementptr inbounds %struct.listNode, ptr %6, i64 0, i32 2
  %8 = load ptr, ptr %value, align 8
  %sub = sub nuw nsw i64 1000, %sub.i
  %call8 = tail call i32 @dictRehashMicroseconds(ptr noundef %8, i64 noundef %sub) #38
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %10 = load ptr, ptr %9, align 8
  %tobool.not = icmp eq ptr %10, null
  br i1 %tobool.not, label %return, label %while.body, !llvm.loop !8

return:                                           ; preds = %while.body, %if.end7, %do.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 1, %do.end ], [ 1, %if.end7 ], [ 1, %while.body ]
  ret i32 %retval.0
}

declare i32 @dictRehashMicroseconds(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @updateDictResizePolicy() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %cmp.not = icmp eq i32 %0, 0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i.not = icmp ne i32 %1, -1
  %. = zext i1 %cmp.i.not to i32
  %.sink = select i1 %cmp.not, i32 %., i32 2
  tail call void @dictSetResizeEnabled(i32 noundef %.sink) #38
  ret void
}

declare void @dictSetResizeEnabled(i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable
define dso_local i32 @hasActiveChildProcess() local_unnamed_addr #9 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp = icmp ne i32 %0, -1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef nonnull ptr @strChildType(i32 noundef %type) local_unnamed_addr #18 {
entry:
  %switch.tableidx = add i32 %type, -1
  %0 = icmp ult i32 %switch.tableidx, 4
  br i1 %0, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %entry
  %1 = zext nneg i32 %switch.tableidx to i64
  %switch.gep = getelementptr inbounds [4 x ptr], ptr @switch.table.checkChildrenDone, i64 0, i64 %1
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %return

return:                                           ; preds = %entry, %switch.lookup
  %retval.0 = phi ptr [ %switch.load, %switch.lookup ], [ @.str.16, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @resetChildState() local_unnamed_addr #0 {
entry:
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  store double 0.000000e+00, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 136), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 128), i8 0, i64 40, i1 false)
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %cmp.not.i = icmp eq i32 %0, 0
  %.sink.i = select i1 %cmp.not.i, i32 0, i32 2
  tail call void @dictSetResizeEnabled(i32 noundef %.sink.i) #38
  tail call void @closeChildInfoPipe() #38
  tail call void @moduleFireServerEvent(i64 noundef 13, i32 noundef 1, ptr noundef null) #38
  ret void
}

declare void @closeChildInfoPipe() local_unnamed_addr #4

declare void @moduleFireServerEvent(i64 noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef i32 @isMutuallyExclusiveChildType(i32 noundef %type) local_unnamed_addr #18 {
entry:
  %0 = add i32 %type, -1
  %or.cond = icmp ult i32 %0, 2
  %cmp2 = icmp eq i32 %type, 4
  %narrow = or i1 %cmp2, %or.cond
  %lor.ext = zext i1 %narrow to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isInsideYieldingLongCommand() local_unnamed_addr #0 {
entry:
  %call = tail call i32 @scriptIsTimedout() #38
  %tobool = icmp ne i32 %call, 0
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %tobool1 = icmp ne i32 %0, 0
  %1 = select i1 %tobool, i1 true, i1 %tobool1
  %lor.ext = zext i1 %1 to i32
  ret i32 %lor.ext
}

declare i32 @scriptIsTimedout() local_unnamed_addr #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable
define dso_local i32 @allPersistenceDisabled() local_unnamed_addr #9 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 224), align 8
  %cmp = icmp eq i32 %0, 0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp1 = icmp eq i32 %1, 0
  %2 = select i1 %cmp, i1 %cmp1, i1 false
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) uwtable
define dso_local void @trackInstantaneousMetric(i32 noundef %metric, i64 noundef %current_value, i64 noundef %current_base, i64 noundef %factor) local_unnamed_addr #19 {
entry:
  %idxprom = sext i32 %metric to i64
  %arrayidx = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 %idxprom
  %0 = load i64, ptr %arrayidx, align 8
  %cmp = icmp sgt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sub = sub nsw i64 %current_base, %0
  %cmp7 = icmp sgt i64 %sub, 0
  br i1 %cmp7, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then
  %last_sample_value = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 %idxprom, i32 1
  %1 = load i64, ptr %last_sample_value, align 8
  %sub6 = sub nsw i64 %current_value, %1
  %mul = mul nsw i64 %sub6, %factor
  %div = sdiv i64 %mul, %sub
  br label %cond.end

cond.end:                                         ; preds = %if.then, %cond.true
  %cond = phi i64 [ %div, %cond.true ], [ 0, %if.then ]
  %idx = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 %idxprom, i32 3
  %2 = load i32, ptr %idx, align 8
  %idxprom12 = sext i32 %2 to i64
  %arrayidx13 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 %idxprom, i32 2, i64 %idxprom12
  store i64 %cond, ptr %arrayidx13, align 8
  %3 = load i32, ptr %idx, align 8
  %inc = add nsw i32 %3, 1
  %rem = srem i32 %inc, 16
  store i32 %rem, ptr %idx, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  store i64 %current_base, ptr %arrayidx, align 8
  %last_sample_value25 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 %idxprom, i32 1
  store i64 %current_value, ptr %last_sample_value25, align 8
  ret void
}

; Function Attrs: nofree norecurse nosync nounwind memory(read, argmem: none, inaccessiblemem: none) uwtable
define dso_local i64 @getInstantaneousMetric(i32 noundef %metric) local_unnamed_addr #20 {
entry:
  %idxprom = sext i32 %metric to i64
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %sum.05 = phi i64 [ 0, %entry ], [ %add, %for.body ]
  %arrayidx2 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 %idxprom, i32 2, i64 %indvars.iv
  %0 = load i64, ptr %arrayidx2, align 8
  %add = add nsw i64 %0, %sum.05
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !9

for.end:                                          ; preds = %for.body
  %div = sdiv i64 %add, 16
  ret i64 %div
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @clientsCronResizeQueryBuffer(ptr nocapture noundef %c) local_unnamed_addr #0 {
entry:
  %querybuf = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 8
  %0 = load ptr, ptr %querybuf, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdsalloc.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdsalloc.exit

sw.bb3.i:                                         ; preds = %entry
  %alloc.i = getelementptr inbounds i8, ptr %0, i64 -2
  %2 = load i8, ptr %alloc.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdsalloc.exit

sw.bb5.i:                                         ; preds = %entry
  %alloc7.i = getelementptr inbounds i8, ptr %0, i64 -3
  %3 = load i16, ptr %alloc7.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdsalloc.exit

sw.bb9.i:                                         ; preds = %entry
  %alloc11.i = getelementptr inbounds i8, ptr %0, i64 -5
  %4 = load i32, ptr %alloc11.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdsalloc.exit

sw.bb13.i:                                        ; preds = %entry
  %alloc15.i = getelementptr inbounds i8, ptr %0, i64 -9
  %5 = load i64, ptr %alloc15.i, align 1
  br label %sdsalloc.exit

sdsalloc.exit:                                    ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %lastinteraction = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 32
  %6 = load i64, ptr %lastinteraction, align 8
  %7 = load ptr, ptr %querybuf, align 8
  %arrayidx.i28 = getelementptr inbounds i8, ptr %7, i64 -1
  %8 = load i8, ptr %arrayidx.i28, align 1
  %9 = and i8 %8, 7
  %and.i29 = zext nneg i8 %9 to i32
  switch i32 %and.i29, label %if.end30 [
    i32 4, label %sw.bb21.i
    i32 1, label %sw.bb1.i
    i32 2, label %sw.bb5.i31
    i32 3, label %sw.bb14.i
  ]

sw.bb1.i:                                         ; preds = %sdsalloc.exit
  %add.ptr.i = getelementptr inbounds i8, ptr %7, i64 -3
  %alloc.i32 = getelementptr inbounds i8, ptr %7, i64 -2
  %10 = load i8, ptr %alloc.i32, align 1
  %conv2.i33 = zext i8 %10 to i64
  %11 = load i8, ptr %add.ptr.i, align 1
  %conv3.i = zext i8 %11 to i64
  %sub.i = sub nsw i64 %conv2.i33, %conv3.i
  br label %sdsavail.exit

sw.bb5.i31:                                       ; preds = %sdsalloc.exit
  %add.ptr7.i = getelementptr inbounds i8, ptr %7, i64 -5
  %alloc8.i = getelementptr inbounds i8, ptr %7, i64 -3
  %12 = load i16, ptr %alloc8.i, align 1
  %conv9.i = zext i16 %12 to i64
  %13 = load i16, ptr %add.ptr7.i, align 1
  %conv11.i = zext i16 %13 to i64
  %sub12.i = sub nsw i64 %conv9.i, %conv11.i
  %14 = trunc i16 %12 to i8
  br label %sdsavail.exit

sw.bb14.i:                                        ; preds = %sdsalloc.exit
  %add.ptr16.i = getelementptr inbounds i8, ptr %7, i64 -9
  %alloc17.i = getelementptr inbounds i8, ptr %7, i64 -5
  %15 = load i32, ptr %alloc17.i, align 1
  %16 = load i32, ptr %add.ptr16.i, align 1
  %sub19.i = sub i32 %15, %16
  %conv20.i = zext i32 %sub19.i to i64
  %17 = lshr i32 %15, 16
  %18 = trunc i32 %17 to i8
  br label %sdsavail.exit

sw.bb21.i:                                        ; preds = %sdsalloc.exit
  %add.ptr23.i = getelementptr inbounds i8, ptr %7, i64 -17
  %alloc24.i = getelementptr inbounds i8, ptr %7, i64 -9
  %19 = load i64, ptr %alloc24.i, align 1
  %20 = load i64, ptr %add.ptr23.i, align 1
  %sub26.i = sub i64 %19, %20
  %21 = lshr i64 %19, 48
  %22 = trunc i64 %21 to i8
  br label %sdsavail.exit

sdsavail.exit:                                    ; preds = %sw.bb1.i, %sw.bb5.i31, %sw.bb14.i, %sw.bb21.i
  %23 = phi i8 [ %22, %sw.bb21.i ], [ %18, %sw.bb14.i ], [ %14, %sw.bb5.i31 ], [ %11, %sw.bb1.i ]
  %retval.0.i30 = phi i64 [ %sub26.i, %sw.bb21.i ], [ %conv20.i, %sw.bb14.i ], [ %sub12.i, %sw.bb5.i31 ], [ %sub.i, %sw.bb1.i ]
  %cmp = icmp ugt i64 %retval.0.i30, 4096
  br i1 %cmp, label %if.then, label %if.end30

if.then:                                          ; preds = %sdsavail.exit
  %sub = sub nsw i64 %atomic-load, %6
  %cmp3 = icmp sgt i64 %sub, 2
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %call6 = tail call ptr @sdsRemoveFreeSpace(ptr noundef nonnull %7, i32 noundef 1) #38
  br label %if.end30.sink.split

if.else:                                          ; preds = %if.then
  %cmp8 = icmp ugt i64 %retval.0.i, 32768
  br i1 %cmp8, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.else
  %div26 = lshr i64 %retval.0.i, 1
  %querybuf_peak = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 10
  %24 = load i64, ptr %querybuf_peak, align 8
  %cmp9 = icmp ugt i64 %div26, %24
  br i1 %cmp9, label %if.then10, label %if.end30

if.then10:                                        ; preds = %land.lhs.true
  %conv.i35 = zext i8 %8 to i32
  %and.i36 = and i32 %conv.i35, 7
  switch i32 %and.i36, label %sdslen.exit [
    i32 0, label %sw.bb.i46
    i32 1, label %sw.bb3.i43
    i32 2, label %sw.bb5.i41
    i32 3, label %sw.bb9.i39
    i32 4, label %sw.bb13.i37
  ]

sw.bb.i46:                                        ; preds = %if.then10
  %shr.i47 = lshr i32 %conv.i35, 3
  %conv2.i48 = zext nneg i32 %shr.i47 to i64
  br label %sdslen.exit

sw.bb3.i43:                                       ; preds = %if.then10
  %conv4.i45 = zext i8 %23 to i64
  br label %sdslen.exit

sw.bb5.i41:                                       ; preds = %if.then10
  %add.ptr6.i = getelementptr inbounds i8, ptr %7, i64 -5
  %25 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i42 = zext i16 %25 to i64
  br label %sdslen.exit

sw.bb9.i39:                                       ; preds = %if.then10
  %add.ptr10.i = getelementptr inbounds i8, ptr %7, i64 -9
  %26 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i40 = zext i32 %26 to i64
  br label %sdslen.exit

sw.bb13.i37:                                      ; preds = %if.then10
  %add.ptr14.i = getelementptr inbounds i8, ptr %7, i64 -17
  %27 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then10, %sw.bb.i46, %sw.bb3.i43, %sw.bb5.i41, %sw.bb9.i39, %sw.bb13.i37
  %retval.0.i38 = phi i64 [ %27, %sw.bb13.i37 ], [ %conv12.i40, %sw.bb9.i39 ], [ %conv8.i42, %sw.bb5.i41 ], [ %conv4.i45, %sw.bb3.i43 ], [ %conv2.i48, %sw.bb.i46 ], [ 0, %if.then10 ]
  %spec.select = tail call i64 @llvm.umax.i64(i64 %retval.0.i38, i64 %24)
  %bulklen = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 23
  %28 = load i64, ptr %bulklen, align 8
  %cmp17.not = icmp eq i64 %28, -1
  %add = add i64 %28, 2
  %spec.select27 = tail call i64 @llvm.umax.i64(i64 %spec.select, i64 %add)
  %resize.1 = select i1 %cmp17.not, i64 %spec.select, i64 %spec.select27
  %call26 = tail call ptr @sdsResize(ptr noundef nonnull %7, i64 noundef %resize.1, i32 noundef 1) #38
  br label %if.end30.sink.split

if.end30.sink.split:                              ; preds = %sdslen.exit, %if.then4
  %call6.sink = phi ptr [ %call6, %if.then4 ], [ %call26, %sdslen.exit ]
  store ptr %call6.sink, ptr %querybuf, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.end30.sink.split, %sdsalloc.exit, %land.lhs.true, %if.else, %sdsavail.exit
  %29 = phi ptr [ %7, %sdsalloc.exit ], [ %7, %land.lhs.true ], [ %7, %if.else ], [ %7, %sdsavail.exit ], [ %call6.sink, %if.end30.sink.split ]
  %arrayidx.i49 = getelementptr inbounds i8, ptr %29, i64 -1
  %30 = load i8, ptr %arrayidx.i49, align 1
  %conv.i50 = zext i8 %30 to i32
  %and.i51 = and i32 %conv.i50, 7
  switch i32 %and.i51, label %sdslen.exit67 [
    i32 0, label %sw.bb.i64
    i32 1, label %sw.bb3.i61
    i32 2, label %sw.bb5.i58
    i32 3, label %sw.bb9.i55
    i32 4, label %sw.bb13.i52
  ]

sw.bb.i64:                                        ; preds = %if.end30
  %shr.i65 = lshr i32 %conv.i50, 3
  %conv2.i66 = zext nneg i32 %shr.i65 to i64
  br label %sdslen.exit67

sw.bb3.i61:                                       ; preds = %if.end30
  %add.ptr.i62 = getelementptr inbounds i8, ptr %29, i64 -3
  %31 = load i8, ptr %add.ptr.i62, align 1
  %conv4.i63 = zext i8 %31 to i64
  br label %sdslen.exit67

sw.bb5.i58:                                       ; preds = %if.end30
  %add.ptr6.i59 = getelementptr inbounds i8, ptr %29, i64 -5
  %32 = load i16, ptr %add.ptr6.i59, align 1
  %conv8.i60 = zext i16 %32 to i64
  br label %sdslen.exit67

sw.bb9.i55:                                       ; preds = %if.end30
  %add.ptr10.i56 = getelementptr inbounds i8, ptr %29, i64 -9
  %33 = load i32, ptr %add.ptr10.i56, align 1
  %conv12.i57 = zext i32 %33 to i64
  br label %sdslen.exit67

sw.bb13.i52:                                      ; preds = %if.end30
  %add.ptr14.i53 = getelementptr inbounds i8, ptr %29, i64 -17
  %34 = load i64, ptr %add.ptr14.i53, align 1
  br label %sdslen.exit67

sdslen.exit67:                                    ; preds = %if.end30, %sw.bb.i64, %sw.bb3.i61, %sw.bb5.i58, %sw.bb9.i55, %sw.bb13.i52
  %retval.0.i54 = phi i64 [ %34, %sw.bb13.i52 ], [ %conv12.i57, %sw.bb9.i55 ], [ %conv8.i60, %sw.bb5.i58 ], [ %conv4.i63, %sw.bb3.i61 ], [ %conv2.i66, %sw.bb.i64 ], [ 0, %if.end30 ]
  %querybuf_peak33 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 10
  store i64 %retval.0.i54, ptr %querybuf_peak33, align 8
  %bulklen34 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 23
  %35 = load i64, ptr %bulklen34, align 8
  %cmp35.not = icmp eq i64 %35, -1
  br i1 %cmp35.not, label %if.end45, label %land.lhs.true36

land.lhs.true36:                                  ; preds = %sdslen.exit67
  %add38 = add i64 %35, 2
  %cmp40 = icmp ugt i64 %add38, %retval.0.i54
  br i1 %cmp40, label %if.then41, label %if.end45

if.then41:                                        ; preds = %land.lhs.true36
  store i64 %add38, ptr %querybuf_peak33, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then41, %land.lhs.true36, %sdslen.exit67
  ret i32 0
}

declare ptr @sdsRemoveFreeSpace(ptr noundef, i32 noundef) local_unnamed_addr #4

declare ptr @sdsResize(ptr noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @clientsCronResizeOutputBuffer(ptr noundef %c, i64 noundef %now_ms) local_unnamed_addr #0 {
entry:
  %buf_usable_size = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 83
  %0 = load i64, ptr %buf_usable_size, align 8
  %div27 = lshr i64 %0, 1
  %mul = shl i64 %0, 1
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 418), align 8
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp ugt i64 %0, 2047
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %buf_peak = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 80
  %2 = load i64, ptr %buf_peak, align 8
  %cmp2 = icmp ult i64 %2, %div27
  br i1 %cmp2, label %if.end21.thread32, label %if.else

if.end21.thread32:                                ; preds = %land.lhs.true
  %cmp5 = icmp ult i64 %2, 1023
  %add = add nuw nsw i64 %2, 1
  %spec.select = select i1 %cmp5, i64 1024, i64 %add
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 149), align 8
  %inc = add nsw i64 %3, 1
  store i64 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 149), align 8
  br label %lor.rhs

if.else:                                          ; preds = %land.lhs.true, %if.end
  %cmp8 = icmp ult i64 %mul, 32768
  br i1 %cmp8, label %land.lhs.true9, label %cond.end30

land.lhs.true9:                                   ; preds = %if.else
  %buf_peak10 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 80
  %4 = load i64, ptr %buf_peak10, align 8
  %cmp12 = icmp eq i64 %4, %0
  br i1 %cmp12, label %if.end21, label %cond.end30

if.end21:                                         ; preds = %land.lhs.true9
  %cond18 = tail call i64 @llvm.umin.i64(i64 %mul, i64 16384)
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 150), align 8
  %inc19 = add nsw i64 %5, 1
  store i64 %inc19, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 150), align 8
  %tobool22.not = icmp eq i64 %mul, 0
  br i1 %tobool22.not, label %cond.end30, label %lor.rhs

lor.rhs:                                          ; preds = %if.end21.thread32, %if.end21
  %new_buffer_size.035 = phi i64 [ %spec.select, %if.end21.thread32 ], [ %cond18, %if.end21 ]
  %bufpos = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 82
  %6 = load i32, ptr %bufpos, align 8
  %conv = sext i32 %6 to i64
  %cmp23.not = icmp ult i64 %new_buffer_size.035, %conv
  br i1 %cmp23.not, label %cond.false29, label %cond.end30

cond.false29:                                     ; preds = %lor.rhs
  tail call void @_serverAssertWithInfo(ptr noundef nonnull %c, ptr noundef null, ptr noundef nonnull @.str.17, ptr noundef nonnull @.str.9, i32 noundef 878) #38
  tail call void @abort() #40
  unreachable

cond.end30:                                       ; preds = %if.else, %land.lhs.true9, %if.end21, %lor.rhs
  %tobool22.not31 = phi i1 [ true, %if.end21 ], [ false, %lor.rhs ], [ true, %land.lhs.true9 ], [ true, %if.else ]
  %new_buffer_size.030 = phi i64 [ 0, %if.end21 ], [ %new_buffer_size.035, %lor.rhs ], [ 0, %land.lhs.true9 ], [ 0, %if.else ]
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 417), align 8
  %cmp31 = icmp sgt i64 %7, -1
  br i1 %cmp31, label %land.lhs.true33, label %if.end41

land.lhs.true33:                                  ; preds = %cond.end30
  %buf_peak_last_reset_time = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 81
  %8 = load i64, ptr %buf_peak_last_reset_time, align 8
  %sub = sub nsw i64 %now_ms, %8
  %cmp34.not = icmp slt i64 %sub, %7
  br i1 %cmp34.not, label %if.end41, label %if.then36

if.then36:                                        ; preds = %land.lhs.true33
  %bufpos37 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 82
  %9 = load i32, ptr %bufpos37, align 8
  %conv38 = sext i32 %9 to i64
  %buf_peak39 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 80
  store i64 %conv38, ptr %buf_peak39, align 8
  store i64 %now_ms, ptr %buf_peak_last_reset_time, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then36, %land.lhs.true33, %cond.end30
  br i1 %tobool22.not31, label %return, label %if.then43

if.then43:                                        ; preds = %if.end41
  %buf = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 84
  %10 = load ptr, ptr %buf, align 8
  %call = tail call ptr @zmalloc_usable(i64 noundef %new_buffer_size.030, ptr noundef nonnull %buf_usable_size) #38
  store ptr %call, ptr %buf, align 8
  %bufpos47 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 82
  %11 = load i32, ptr %bufpos47, align 8
  %conv48 = sext i32 %11 to i64
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call, ptr align 1 %10, i64 %conv48, i1 false)
  tail call void @zfree(ptr noundef %10) #38
  br label %return

return:                                           ; preds = %if.end41, %if.then43, %entry
  ret i32 0
}

declare void @_serverAssertWithInfo(ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare ptr @zmalloc_usable(i64 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @clientsCronTrackExpansiveClients(ptr noundef %c, i32 noundef %time_idx) local_unnamed_addr #0 {
entry:
  %querybuf = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 8
  %0 = load ptr, ptr %querybuf, align 8
  %call = tail call i64 @sdsZmallocSize(ptr noundef %0) #38
  %argv_len_sum = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 16
  %1 = load i64, ptr %argv_len_sum, align 8
  %add = add i64 %1, %call
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %2 = load ptr, ptr %argv, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %call2 = tail call i64 @je_malloc_usable_size(ptr noundef nonnull %2) #38
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ 0, %entry ]
  %add3 = add i64 %add, %cond
  %call4 = tail call i64 @getClientOutputBufferMemoryUsage(ptr noundef nonnull %c) #38
  %idxprom = sext i32 %time_idx to i64
  %arrayidx = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %idxprom
  %3 = load i64, ptr %arrayidx, align 8
  %cmp = icmp ugt i64 %add3, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i64 %add3, ptr %arrayidx, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %arrayidx8 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %idxprom
  %4 = load i64, ptr %arrayidx8, align 8
  %cmp9 = icmp ugt i64 %call4, %4
  br i1 %cmp9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end
  store i64 %call4, ptr %arrayidx8, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.end
  ret i32 0
}

declare i64 @sdsZmallocSize(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare i64 @je_malloc_usable_size(ptr noundef) local_unnamed_addr #3

declare i64 @getClientOutputBufferMemoryUsage(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @updateClientMemoryUsage(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %call = tail call i64 @getClientMemoryUsage(ptr noundef %c, ptr noundef null) #38
  %call1 = tail call i32 @getClientType(ptr noundef %c) #38
  %last_memory_usage = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 73
  %0 = load i64, ptr %last_memory_usage, align 8
  %last_memory_type = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 74
  %1 = load i32, ptr %last_memory_type, align 8
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 137, i64 %idxprom
  %2 = load i64, ptr %arrayidx, align 8
  %sub = sub i64 %2, %0
  store i64 %sub, ptr %arrayidx, align 8
  %idxprom2 = sext i32 %call1 to i64
  %arrayidx3 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 137, i64 %idxprom2
  %3 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %3, %call
  store i64 %add, ptr %arrayidx3, align 8
  store i32 %call1, ptr %last_memory_type, align 8
  store i64 %call, ptr %last_memory_usage, align 8
  ret void
}

declare i64 @getClientMemoryUsage(ptr noundef, ptr noundef) local_unnamed_addr #4

declare i32 @getClientType(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local i32 @clientEvictionAllowed(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 315), align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %and = and i64 %1, 8796093022208
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false
  %call = tail call i32 @getClientType(ptr noundef nonnull %c) #38
  %2 = and i32 %call, -3
  %3 = icmp eq i32 %2, 0
  %lor.ext = zext i1 %3 to i32
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %if.end
  %retval.0 = phi i32 [ %lor.ext, %if.end ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @removeClientFromMemUsageBucket(ptr nocapture noundef %c, i32 noundef %allow_eviction) local_unnamed_addr #0 {
entry:
  %mem_usage_bucket = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 76
  %0 = load ptr, ptr %mem_usage_bucket, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %last_memory_usage = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 73
  %1 = load i64, ptr %last_memory_usage, align 8
  %mem_usage_sum = getelementptr inbounds %struct.clientMemUsageBucket, ptr %0, i64 0, i32 1
  %2 = load i64, ptr %mem_usage_sum, align 8
  %sub = sub i64 %2, %1
  store i64 %sub, ptr %mem_usage_sum, align 8
  %tobool2.not = icmp eq i32 %allow_eviction, 0
  br i1 %tobool2.not, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.then
  %3 = load ptr, ptr %mem_usage_bucket, align 8
  %4 = load ptr, ptr %3, align 8
  %mem_usage_bucket_node = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 75
  %5 = load ptr, ptr %mem_usage_bucket_node, align 8
  tail call void @listDelNode(ptr noundef %4, ptr noundef %5) #38
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mem_usage_bucket_node, i8 0, i64 16, i1 false)
  br label %if.end7

if.end7:                                          ; preds = %if.then, %if.then3, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @updateClientMemUsageAndBucket(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr @io_threads_op, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.18, ptr noundef nonnull @.str.9, i32 noundef 1011) #38
  tail call void @abort() #40
  unreachable

cond.end:                                         ; preds = %entry
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 315), align 8
  %cmp.i = icmp eq i64 %1, 0
  br i1 %cmp.i, label %clientEvictionAllowed.exit, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %cond.end
  %flags.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %2 = load i64, ptr %flags.i, align 8
  %and.i = and i64 %2, 8796093022208
  %tobool.not.i = icmp eq i64 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %clientEvictionAllowed.exit

if.end.i:                                         ; preds = %lor.lhs.false.i
  %call.i = tail call i32 @getClientType(ptr noundef nonnull %c) #38
  %3 = and i32 %call.i, -3
  %4 = icmp ne i32 %3, 0
  br label %clientEvictionAllowed.exit

clientEvictionAllowed.exit:                       ; preds = %cond.end, %lor.lhs.false.i, %if.end.i
  %retval.0.i = phi i1 [ %4, %if.end.i ], [ true, %lor.lhs.false.i ], [ true, %cond.end ]
  %mem_usage_bucket.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 76
  %5 = load ptr, ptr %mem_usage_bucket.i, align 8
  %tobool.not.i17 = icmp eq ptr %5, null
  br i1 %tobool.not.i17, label %removeClientFromMemUsageBucket.exit, label %if.then.i

if.then.i:                                        ; preds = %clientEvictionAllowed.exit
  %last_memory_usage.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 73
  %6 = load i64, ptr %last_memory_usage.i, align 8
  %mem_usage_sum.i = getelementptr inbounds %struct.clientMemUsageBucket, ptr %5, i64 0, i32 1
  %7 = load i64, ptr %mem_usage_sum.i, align 8
  %sub.i = sub i64 %7, %6
  store i64 %sub.i, ptr %mem_usage_sum.i, align 8
  br i1 %retval.0.i, label %removeClientFromMemUsageBucket.exit.thread, label %if.end

removeClientFromMemUsageBucket.exit.thread:       ; preds = %if.then.i
  %8 = load ptr, ptr %mem_usage_bucket.i, align 8
  %9 = load ptr, ptr %8, align 8
  %mem_usage_bucket_node.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 75
  %10 = load ptr, ptr %mem_usage_bucket_node.i, align 8
  tail call void @listDelNode(ptr noundef %9, ptr noundef %10) #38
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mem_usage_bucket_node.i, i8 0, i64 16, i1 false)
  br label %return

removeClientFromMemUsageBucket.exit:              ; preds = %clientEvictionAllowed.exit
  br i1 %retval.0.i, label %return, label %if.end

if.end:                                           ; preds = %if.then.i, %removeClientFromMemUsageBucket.exit
  %call.i18 = tail call i64 @getClientMemoryUsage(ptr noundef nonnull %c, ptr noundef null) #38
  %call1.i = tail call i32 @getClientType(ptr noundef nonnull %c) #38
  %last_memory_usage.i19 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 73
  %11 = load i64, ptr %last_memory_usage.i19, align 8
  %last_memory_type.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 74
  %12 = load i32, ptr %last_memory_type.i, align 8
  %idxprom.i = sext i32 %12 to i64
  %arrayidx.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 137, i64 %idxprom.i
  %13 = load i64, ptr %arrayidx.i, align 8
  %sub.i20 = sub i64 %13, %11
  store i64 %sub.i20, ptr %arrayidx.i, align 8
  %idxprom2.i = sext i32 %call1.i to i64
  %arrayidx3.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 137, i64 %idxprom2.i
  %14 = load i64, ptr %arrayidx3.i, align 8
  %add.i = add i64 %14, %call.i18
  store i64 %add.i, ptr %arrayidx3.i, align 8
  store i32 %call1.i, ptr %last_memory_type.i, align 8
  store i64 %call.i18, ptr %last_memory_usage.i19, align 8
  %15 = tail call i64 @llvm.ctlz.i64(i64 %call.i18, i1 false), !range !10
  %cast.i = trunc i64 %15 to i32
  %cmp1.i = icmp ult i32 %cast.i, 31
  br i1 %cmp1.i, label %getMemUsageBucket.exit, label %if.else.i

if.else.i:                                        ; preds = %if.end
  %sub.i21 = sub nuw nsw i32 64, %cast.i
  %spec.store.select.i = tail call i32 @llvm.smax.i32(i32 %sub.i21, i32 15)
  %16 = add nsw i32 %spec.store.select.i, -15
  %17 = zext nneg i32 %16 to i64
  br label %getMemUsageBucket.exit

getMemUsageBucket.exit:                           ; preds = %if.end, %if.else.i
  %bucket_idx.0.i = phi i64 [ %17, %if.else.i ], [ 18, %if.end ]
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %arrayidx.i22 = getelementptr inbounds %struct.clientMemUsageBucket, ptr %18, i64 %bucket_idx.0.i
  %mem_usage_sum = getelementptr inbounds %struct.clientMemUsageBucket, ptr %18, i64 %bucket_idx.0.i, i32 1
  %19 = load i64, ptr %mem_usage_sum, align 8
  %add = add i64 %19, %call.i18
  store i64 %add, ptr %mem_usage_sum, align 8
  %20 = load ptr, ptr %mem_usage_bucket.i, align 8
  %cmp5.not = icmp eq ptr %arrayidx.i22, %20
  br i1 %cmp5.not, label %return, label %if.then7

if.then7:                                         ; preds = %getMemUsageBucket.exit
  %tobool9.not = icmp eq ptr %20, null
  br i1 %tobool9.not, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.then7
  %21 = load ptr, ptr %20, align 8
  %mem_usage_bucket_node = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 75
  %22 = load ptr, ptr %mem_usage_bucket_node, align 8
  tail call void @listDelNode(ptr noundef %21, ptr noundef %22) #38
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.then7
  store ptr %arrayidx.i22, ptr %mem_usage_bucket.i, align 8
  %23 = load ptr, ptr %arrayidx.i22, align 8
  %call15 = tail call ptr @listAddNodeTail(ptr noundef %23, ptr noundef nonnull %c) #38
  %24 = load ptr, ptr %arrayidx.i22, align 8
  %tail = getelementptr inbounds %struct.list, ptr %24, i64 0, i32 1
  %25 = load ptr, ptr %tail, align 8
  %mem_usage_bucket_node17 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 75
  store ptr %25, ptr %mem_usage_bucket_node17, align 8
  br label %return

return:                                           ; preds = %removeClientFromMemUsageBucket.exit.thread, %getMemUsageBucket.exit, %if.end12, %removeClientFromMemUsageBucket.exit
  %retval.0 = phi i32 [ 0, %removeClientFromMemUsageBucket.exit ], [ 1, %if.end12 ], [ 1, %getMemUsageBucket.exit ], [ 0, %removeClientFromMemUsageBucket.exit.thread ]
  ret i32 %retval.0
}

declare void @_serverAssert(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nofree norecurse nosync nounwind memory(read, argmem: write, inaccessiblemem: none) uwtable
define dso_local void @getExpansiveClientsInfo(ptr nocapture noundef writeonly %in_usage, ptr nocapture noundef writeonly %out_usage) local_unnamed_addr #21 {
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %o.010 = phi i64 [ 0, %entry ], [ %o.1, %for.body ]
  %i.09 = phi i64 [ 0, %entry ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %indvars.iv
  %0 = load i64, ptr %arrayidx, align 8
  %spec.select = tail call i64 @llvm.umax.i64(i64 %0, i64 %i.09)
  %arrayidx5 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %indvars.iv
  %1 = load i64, ptr %arrayidx5, align 8
  %o.1 = tail call i64 @llvm.umax.i64(i64 %1, i64 %o.010)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 8
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !11

for.end:                                          ; preds = %for.body
  store i64 %spec.select, ptr %in_usage, align 8
  store i64 %o.1, ptr %out_usage, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clientsCron() local_unnamed_addr #0 {
entry:
  %tv.i.i = alloca %struct.timeval, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len, align 8
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i)
  %call.i.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i, ptr noundef null) #38
  %3 = load i64, ptr %tv.i.i, align 8
  %mul.i.i = mul nsw i64 %3, 1000000
  %tv_usec.i.i = getelementptr inbounds %struct.timeval, ptr %tv.i.i, i64 0, i32 1
  %4 = load i64, ptr %tv_usec.i.i, align 8
  %add.i.i = add nsw i64 %mul.i.i, %4
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i)
  %div.i = sdiv i64 %add.i.i, 1000
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %rem = srem i64 %atomic-load, 8
  %5 = trunc i64 %rem to i8
  %rem5.lhs.trunc = add nsw i8 %5, 1
  %rem517 = srem i8 %rem5.lhs.trunc, 8
  %idxprom = sext i8 %rem517 to i64
  %arrayidx = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %idxprom
  store i64 0, ptr %arrayidx, align 8
  %arrayidx7 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %idxprom
  store i64 0, ptr %arrayidx7, align 8
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  %len818 = getelementptr inbounds %struct.list, ptr %6, i64 0, i32 5
  %7 = load i64, ptr %len818, align 8
  %tobool.not19 = icmp eq i64 %7, 0
  br i1 %tobool.not19, label %while.end, label %land.rhs.lr.ph

land.rhs.lr.ph:                                   ; preds = %entry
  %conv = trunc i64 %1 to i32
  %div = sdiv i32 %conv, %2
  %cmp = icmp slt i32 %div, 5
  %cond = tail call i32 @llvm.smin.i32(i32 %conv, i32 5)
  %iterations.0 = select i1 %cmp, i32 %cond, i32 %div
  %arrayidx.i = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %rem
  %arrayidx8.i = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %rem
  br label %land.rhs

land.rhs:                                         ; preds = %land.rhs.lr.ph, %while.cond.backedge
  %8 = phi ptr [ %6, %land.rhs.lr.ph ], [ %11, %while.cond.backedge ]
  %iterations.120 = phi i32 [ %iterations.0, %land.rhs.lr.ph ], [ %dec, %while.cond.backedge ]
  %dec = add nsw i32 %iterations.120, -1
  %tobool9.not = icmp eq i32 %iterations.120, 0
  br i1 %tobool9.not, label %while.end, label %while.body

while.body:                                       ; preds = %land.rhs
  %9 = load ptr, ptr %8, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %value, align 8
  tail call void @listRotateHeadToTail(ptr noundef nonnull %8) #38
  %call11 = tail call i32 @clientsCronHandleTimeout(ptr noundef %10, i64 noundef %div.i) #38
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end14, label %while.cond.backedge

while.cond.backedge:                              ; preds = %while.body, %if.end30
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  %len8 = getelementptr inbounds %struct.list, ptr %11, i64 0, i32 5
  %12 = load i64, ptr %len8, align 8
  %tobool.not = icmp eq i64 %12, 0
  br i1 %tobool.not, label %while.end, label %land.rhs, !llvm.loop !12

if.end14:                                         ; preds = %while.body
  %call15 = tail call i32 @clientsCronResizeQueryBuffer(ptr noundef %10)
  %call19 = tail call i32 @clientsCronResizeOutputBuffer(ptr noundef %10, i64 noundef %div.i)
  %querybuf.i = getelementptr inbounds %struct.client, ptr %10, i64 0, i32 8
  %13 = load ptr, ptr %querybuf.i, align 8
  %call.i = tail call i64 @sdsZmallocSize(ptr noundef %13) #38
  %argv_len_sum.i = getelementptr inbounds %struct.client, ptr %10, i64 0, i32 16
  %14 = load i64, ptr %argv_len_sum.i, align 8
  %add.i = add i64 %14, %call.i
  %argv.i = getelementptr inbounds %struct.client, ptr %10, i64 0, i32 12
  %15 = load ptr, ptr %argv.i, align 8
  %tobool.not.i = icmp eq ptr %15, null
  br i1 %tobool.not.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end14
  %call2.i = tail call i64 @je_malloc_usable_size(ptr noundef nonnull %15) #38
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.end14
  %cond.i = phi i64 [ %call2.i, %cond.true.i ], [ 0, %if.end14 ]
  %add3.i = add i64 %add.i, %cond.i
  %call4.i = tail call i64 @getClientOutputBufferMemoryUsage(ptr noundef nonnull %10) #38
  %16 = load i64, ptr %arrayidx.i, align 8
  %cmp.i = icmp ugt i64 %add3.i, %16
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %cond.end.i
  store i64 %add3.i, ptr %arrayidx.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %cond.end.i
  %17 = load i64, ptr %arrayidx8.i, align 8
  %cmp9.i = icmp ugt i64 %call4.i, %17
  br i1 %cmp9.i, label %if.then10.i, label %clientsCronTrackExpansiveClients.exit

if.then10.i:                                      ; preds = %if.end.i
  store i64 %call4.i, ptr %arrayidx8.i, align 8
  br label %clientsCronTrackExpansiveClients.exit

clientsCronTrackExpansiveClients.exit:            ; preds = %if.end.i, %if.then10.i
  %call27 = tail call i32 @updateClientMemUsageAndBucket(ptr noundef nonnull %10), !range !13
  %tobool28.not = icmp eq i32 %call27, 0
  br i1 %tobool28.not, label %if.then29, label %if.end30

if.then29:                                        ; preds = %clientsCronTrackExpansiveClients.exit
  %call.i13 = tail call i64 @getClientMemoryUsage(ptr noundef nonnull %10, ptr noundef null) #38
  %call1.i = tail call i32 @getClientType(ptr noundef nonnull %10) #38
  %last_memory_usage.i = getelementptr inbounds %struct.client, ptr %10, i64 0, i32 73
  %18 = load i64, ptr %last_memory_usage.i, align 8
  %last_memory_type.i = getelementptr inbounds %struct.client, ptr %10, i64 0, i32 74
  %19 = load i32, ptr %last_memory_type.i, align 8
  %idxprom.i14 = sext i32 %19 to i64
  %arrayidx.i15 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 137, i64 %idxprom.i14
  %20 = load i64, ptr %arrayidx.i15, align 8
  %sub.i = sub i64 %20, %18
  store i64 %sub.i, ptr %arrayidx.i15, align 8
  %idxprom2.i = sext i32 %call1.i to i64
  %arrayidx3.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 137, i64 %idxprom2.i
  %21 = load i64, ptr %arrayidx3.i, align 8
  %add.i16 = add i64 %21, %call.i13
  store i64 %add.i16, ptr %arrayidx3.i, align 8
  store i32 %call1.i, ptr %last_memory_type.i, align 8
  store i64 %call.i13, ptr %last_memory_usage.i, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %clientsCronTrackExpansiveClients.exit
  %call31 = tail call i32 @closeClientOnOutputBufferLimitReached(ptr noundef nonnull %10, i32 noundef 0) #38
  br label %while.cond.backedge

while.end:                                        ; preds = %land.rhs, %while.cond.backedge, %entry
  ret void
}

declare void @listRotateHeadToTail(ptr noundef) local_unnamed_addr #4

declare i32 @clientsCronHandleTimeout(ptr noundef, i64 noundef) local_unnamed_addr #4

declare i32 @closeClientOnOutputBufferLimitReached(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @databasesCron() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 159), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end3, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.i = icmp eq i32 %1, 0
  br i1 %tobool.i, label %iAmMaster.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.then
  %call.i = tail call ptr @getMyClusterNode() #38
  %call2.i = tail call i32 @clusterNodeIsMaster(ptr noundef %call.i) #38
  %tobool3.i.not = icmp eq i32 %call2.i, 0
  br i1 %tobool3.i.not, label %if.else, label %if.then2

iAmMaster.exit:                                   ; preds = %if.then
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp.i = icmp eq ptr %2, null
  br i1 %cmp.i, label %if.then2, label %if.else

if.then2:                                         ; preds = %land.rhs.i, %iAmMaster.exit
  tail call void @activeExpireCycle(i32 noundef 0) #38
  br label %if.end3

if.else:                                          ; preds = %land.rhs.i, %iAmMaster.exit
  tail call void @expireSlaveKeys() #38
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.else, %entry
  tail call void @activeDefragCycle() #38
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i3.not = icmp eq i32 %3, -1
  br i1 %cmp.i3.not, label %if.then6, label %if.end15

if.then6:                                         ; preds = %if.end3
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %spec.select = tail call i32 @llvm.smin.i32(i32 %4, i32 16)
  %cmp95 = icmp sgt i32 %4, 0
  br i1 %cmp95, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %if.then6
  %.pre = load i32, ptr @databasesCron.resize_db, align 4
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %5 = phi i32 [ %inc, %for.body ], [ %.pre, %for.body.preheader ]
  %j.06 = phi i32 [ %inc10, %for.body ], [ 0, %for.body.preheader ]
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %rem = urem i32 %5, %6
  tail call void @tryResizeHashTables(i32 noundef %rem)
  %7 = load i32, ptr @databasesCron.resize_db, align 4
  %inc = add i32 %7, 1
  store i32 %inc, ptr @databasesCron.resize_db, align 4
  %inc10 = add nuw nsw i32 %j.06, 1
  %exitcond.not = icmp eq i32 %inc10, %spec.select
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !14

for.end:                                          ; preds = %for.body, %if.then6
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 21), align 8
  %tobool11.not = icmp eq i32 %8, 0
  br i1 %tobool11.not, label %if.end15, label %if.then12

if.then12:                                        ; preds = %for.end
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %len.i = getelementptr inbounds %struct.list, ptr %9, i64 0, i32 5
  %10 = load i64, ptr %len.i, align 8
  %cmp.i4 = icmp eq i64 %10, 0
  br i1 %cmp.i4, label %if.end15, label %do.body.i

do.body.i:                                        ; preds = %if.then12
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i = icmp sgt i32 %11, 0
  br i1 %cmp1.i, label %do.end.i, label %if.end3.i

if.end3.i:                                        ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.11, i64 noundef %10)
  br label %do.end.i

do.end.i:                                         ; preds = %if.end3.i, %do.body.i
  %12 = load ptr, ptr @getMonotonicUs, align 8
  %call.i.i = tail call i64 %12() #38
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %14 = load ptr, ptr %13, align 8
  %tobool.not4.i = icmp eq ptr %14, null
  br i1 %tobool.not4.i, label %if.end15, label %while.body.i

while.body.i:                                     ; preds = %do.end.i, %if.end7.i
  %15 = phi ptr [ %19, %if.end7.i ], [ %14, %do.end.i ]
  %16 = load ptr, ptr @getMonotonicUs, align 8
  %call.i3.i = tail call i64 %16() #38
  %sub.i.i = sub i64 %call.i3.i, %call.i.i
  %cmp5.i = icmp ugt i64 %sub.i.i, 999
  br i1 %cmp5.i, label %if.end15, label %if.end7.i

if.end7.i:                                        ; preds = %while.body.i
  %value.i = getelementptr inbounds %struct.listNode, ptr %15, i64 0, i32 2
  %17 = load ptr, ptr %value.i, align 8
  %sub.i = sub nuw nsw i64 1000, %sub.i.i
  %call8.i = tail call i32 @dictRehashMicroseconds(ptr noundef %17, i64 noundef %sub.i) #38
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  %19 = load ptr, ptr %18, align 8
  %tobool.not.i = icmp eq ptr %19, null
  br i1 %tobool.not.i, label %if.end15, label %while.body.i, !llvm.loop !8

if.end15:                                         ; preds = %if.end7.i, %while.body.i, %do.end.i, %if.then12, %for.end, %if.end3
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @iAmMaster() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool = icmp eq i32 %0, 0
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp = icmp eq ptr %1, null
  br i1 %tobool, label %lor.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %call = tail call ptr @getMyClusterNode() #38
  %call2 = tail call i32 @clusterNodeIsMaster(ptr noundef %call) #38
  %tobool3 = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %entry, %land.rhs
  %lor.ext.in = phi i1 [ %cmp, %entry ], [ %tobool3, %land.rhs ]
  %lor.ext = zext i1 %lor.ext.in to i32
  ret i32 %lor.ext
}

declare void @activeExpireCycle(i32 noundef) local_unnamed_addr #4

declare void @expireSlaveKeys() local_unnamed_addr #4

declare void @activeDefragCycle() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @updateCachedTime(i32 noundef %update_daylight_info) local_unnamed_addr #0 {
entry:
  %tm.i = alloca %struct.tm, align 8
  %ut.i = alloca i64, align 8
  %tv.i = alloca %struct.timeval, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i)
  %call.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i, ptr noundef null) #38
  %0 = load i64, ptr %tv.i, align 8
  %mul.i = mul nsw i64 %0, 1000000
  %tv_usec.i = getelementptr inbounds %struct.timeval, ptr %tv.i, i64 0, i32 1
  %1 = load i64, ptr %tv_usec.i, align 8
  %add.i = add nsw i64 %mul.i, %1
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i)
  call void @llvm.lifetime.start.p0(i64 56, ptr nonnull %tm.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ut.i)
  store i64 %add.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %div.i = sdiv i64 %add.i, 1000
  store i64 %div.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %div1.i = sdiv i64 %add.i, 1000000
  store atomic i64 %div1.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) monotonic, align 8
  %tobool.not.i = icmp eq i32 %update_daylight_info, 0
  br i1 %tobool.not.i, label %updateCachedTimeWithUs.exit, label %if.then.i

if.then.i:                                        ; preds = %entry
  %atomic-load.i = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  store i64 %atomic-load.i, ptr %ut.i, align 8
  %call.i1 = call ptr @localtime_r(ptr noundef nonnull %ut.i, ptr noundef nonnull %tm.i) #38
  %tm_isdst.i = getelementptr inbounds %struct.tm, ptr %tm.i, i64 0, i32 8
  %2 = load i32, ptr %tm_isdst.i, align 8
  store i32 %2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 351), align 8
  br label %updateCachedTimeWithUs.exit

updateCachedTimeWithUs.exit:                      ; preds = %entry, %if.then.i
  call void @llvm.lifetime.end.p0(i64 56, ptr nonnull %tm.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ut.i)
  ret void
}

; Function Attrs: nofree nounwind uwtable
define dso_local void @enterExecutionUnit(i32 noundef %update_cached_time, i64 noundef %us) local_unnamed_addr #8 {
entry:
  %tv.i = alloca %struct.timeval, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %cmp = icmp eq i32 %0, 0
  %tobool = icmp ne i32 %update_cached_time, 0
  %or.cond = and i1 %tobool, %cmp
  br i1 %or.cond, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %cmp1 = icmp eq i64 %us, 0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i)
  %call.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i, ptr noundef null) #38
  %1 = load i64, ptr %tv.i, align 8
  %mul.i = mul nsw i64 %1, 1000000
  %tv_usec.i = getelementptr inbounds %struct.timeval, ptr %tv.i, i64 0, i32 1
  %2 = load i64, ptr %tv_usec.i, align 8
  %add.i = add nsw i64 %mul.i, %2
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %us.addr.0 = phi i64 [ %add.i, %if.then2 ], [ %us, %if.then ]
  store i64 %us.addr.0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %div.i = sdiv i64 %us.addr.0, 1000
  store i64 %div.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %div1.i = sdiv i64 %us.addr.0, 1000000
  store atomic i64 %div1.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) monotonic, align 8
  store i64 %div.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 354), align 8
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) uwtable
define dso_local void @exitExecutionUnit() local_unnamed_addr #19 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @checkChildrenDone() local_unnamed_addr #0 {
entry:
  %statloc = alloca i32, align 4
  store i32 0, ptr %statloc, align 4
  %call = call i32 @waitpid(i32 noundef -1, ptr noundef nonnull %statloc, i32 noundef 1) #38
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end60, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i32, ptr %statloc, align 4
  %and = and i32 %0, 127
  %cmp1 = icmp eq i32 %and, 0
  %and2 = lshr i32 %0, 8
  %shr = and i32 %and2, 255
  %cond = select i1 %cmp1, i32 %shr, i32 -1
  %conv = shl nuw nsw i32 %and, 24
  %sext = add nuw i32 %conv, 16777216
  %cmp6 = icmp sgt i32 %sext, 33554431
  %spec.select = select i1 %cmp6, i32 %and, i32 0
  %cmp10 = icmp eq i32 %cond, 255
  %exitcode.0 = select i1 %cmp10, i32 1, i32 %cond
  %bysignal.1 = select i1 %cmp10, i32 10, i32 %spec.select
  %cmp14 = icmp eq i32 %call, -1
  br i1 %cmp14, label %do.body, label %if.else

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp17 = icmp sgt i32 %1, 3
  br i1 %cmp17, label %if.end59, label %if.end20

if.end20:                                         ; preds = %do.body
  %call21 = tail call ptr @__errno_location() #41
  %2 = load i32, ptr %call21, align 4
  %call22 = call ptr @strerror(i32 noundef %2) #38
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  %switch.tableidx = add i32 %3, -1
  %4 = icmp ult i32 %switch.tableidx, 4
  br i1 %4, label %switch.lookup, label %strChildType.exit

switch.lookup:                                    ; preds = %if.end20
  %5 = zext nneg i32 %switch.tableidx to i64
  %switch.gep = getelementptr inbounds [4 x ptr], ptr @switch.table.checkChildrenDone, i64 0, i64 %5
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %strChildType.exit

strChildType.exit:                                ; preds = %if.end20, %switch.lookup
  %retval.0.i = phi ptr [ %switch.load, %switch.lookup ], [ @.str.16, %if.end20 ]
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.19, ptr noundef %call22, ptr noundef nonnull %retval.0.i, i32 noundef %6)
  br label %if.end59

if.else:                                          ; preds = %if.then
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp24 = icmp eq i32 %call, %7
  br i1 %cmp24, label %if.then26, label %if.else46

if.then26:                                        ; preds = %if.else
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  switch i32 %8, label %if.else38 [
    i32 1, label %if.then29
    i32 2, label %if.then33
    i32 4, label %if.then37
  ]

if.then29:                                        ; preds = %if.then26
  call void @backgroundSaveDoneHandler(i32 noundef %exitcode.0, i32 noundef %bysignal.1) #38
  br label %if.end41

if.then33:                                        ; preds = %if.then26
  call void @backgroundRewriteDoneHandler(i32 noundef %exitcode.0, i32 noundef %bysignal.1) #38
  br label %if.end41

if.then37:                                        ; preds = %if.then26
  call void @ModuleForkDoneHandler(i32 noundef %exitcode.0, i32 noundef %bysignal.1) #38
  br label %if.end41

if.else38:                                        ; preds = %if.then26
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 1260, ptr noundef nonnull @.str.20, i32 noundef %8, i32 noundef %call) #38
  call void @abort() #40
  unreachable

if.end41:                                         ; preds = %if.then33, %if.then37, %if.then29
  %9 = or i32 %bysignal.1, %exitcode.0
  %or.cond = icmp eq i32 %9, 0
  br i1 %or.cond, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end41
  call void @receiveChildInfo() #38
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %if.end41
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  store double 0.000000e+00, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 136), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 128), i8 0, i64 40, i1 false)
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %cmp.not.i.i = icmp eq i32 %10, 0
  %.sink.i.i = select i1 %cmp.not.i.i, i32 0, i32 2
  call void @dictSetResizeEnabled(i32 noundef %.sink.i.i) #38
  call void @closeChildInfoPipe() #38
  call void @moduleFireServerEvent(i64 noundef 13, i32 noundef 1, ptr noundef null) #38
  br label %if.end59

if.else46:                                        ; preds = %if.else
  %call47 = call i32 @ldbRemoveChild(i32 noundef %call) #38
  %tobool48 = icmp ne i32 %call47, 0
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp51 = icmp sgt i32 %11, 3
  %or.cond1 = select i1 %tobool48, i1 true, i1 %cmp51
  br i1 %or.cond1, label %if.end59, label %if.end54

if.end54:                                         ; preds = %if.else46
  %conv55 = sext i32 %call to i64
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.21, i64 noundef %conv55)
  br label %if.end59

if.end59:                                         ; preds = %if.end45, %if.end54, %if.else46, %strChildType.exit, %do.body
  call void @replicationStartPendingFork() #38
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %entry
  ret void
}

declare i32 @waitpid(i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) local_unnamed_addr #3

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare ptr @__errno_location() local_unnamed_addr #22

declare void @backgroundSaveDoneHandler(i32 noundef, i32 noundef) local_unnamed_addr #4

declare void @backgroundRewriteDoneHandler(i32 noundef, i32 noundef) local_unnamed_addr #4

declare void @ModuleForkDoneHandler(i32 noundef, i32 noundef) local_unnamed_addr #4

declare void @receiveChildInfo() local_unnamed_addr #4

declare i32 @ldbRemoveChild(i32 noundef) local_unnamed_addr #4

declare void @replicationStartPendingFork() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @cronUpdateMemoryStats() local_unnamed_addr #0 {
entry:
  %call = tail call i64 @zmalloc_used_memory() #38
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  %cmp = icmp ugt i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = tail call i64 @zmalloc_used_memory() #38
  store i64 %call1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div = sdiv i32 1000, %1
  %cmp2 = icmp sgt i32 %div, 99
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div4.rhs.trunc = trunc i32 %div to i16
  %div41 = sdiv i16 100, %div4.rhs.trunc
  %div4.sext = sext i16 %div41 to i32
  %rem = srem i32 %2, %div4.sext
  %tobool.not = icmp eq i32 %rem, 0
  br i1 %tobool.not, label %if.then5, label %if.end19

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %call6 = tail call i64 @zmalloc_get_rss() #38
  store i64 %call6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 1), align 8
  %call7 = tail call i64 @zmalloc_used_memory() #38
  store i64 %call7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123), align 8
  %call8 = tail call i32 @zmalloc_get_allocator_info(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 2), ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 3), ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 4)) #38
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 4), align 8
  %tobool9.not = icmp eq i64 %3, 0
  br i1 %tobool9.not, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.then5
  %call11 = tail call i64 @evalMemory() #38
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 1), align 8
  %sub = sub i64 %4, %call11
  store i64 %sub, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 4), align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.then5
  %5 = phi i64 [ %sub, %if.then10 ], [ %3, %if.then5 ]
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 3), align 8
  %tobool13.not = icmp eq i64 %6, 0
  br i1 %tobool13.not, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  store i64 %5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 3), align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end12
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 2), align 8
  %tobool16.not = icmp eq i64 %7, 0
  br i1 %tobool16.not, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123), align 8
  store i64 %8, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 2), align 8
  br label %if.end19

if.end19:                                         ; preds = %if.end15, %if.then17, %lor.lhs.false
  ret void
}

declare i64 @zmalloc_used_memory() local_unnamed_addr #4

declare i64 @zmalloc_get_rss() local_unnamed_addr #4

declare i32 @zmalloc_get_allocator_info(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

declare i64 @evalMemory() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local i32 @serverCron(ptr nocapture readnone %eventLoop, i64 %id, ptr nocapture readnone %clientData) #0 {
entry:
  %li.i = alloca %struct.listIter, align 8
  %rsi = alloca %struct.rdbSaveInfo, align 8
  %rsi320 = alloca %struct.rdbSaveInfo, align 8
  %ei = alloca %struct.RedisModuleCronLoopInfo, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 400), align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @watchdogScheduleSignal(i32 noundef %0) #38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 6), align 4
  store i32 %1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 5), align 8
  %tobool1.not = icmp eq i32 %2, 0
  br i1 %tobool1.not, label %if.end8, label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.end
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  %len = getelementptr inbounds %struct.list, ptr %3, i64 0, i32 5
  br label %while.cond

while.cond:                                       ; preds = %while.cond.preheader, %while.body
  %4 = phi i32 [ %mul, %while.body ], [ %1, %while.cond.preheader ]
  %5 = load i64, ptr %len, align 8
  %conv = sext i32 %4 to i64
  %div = udiv i64 %5, %conv
  %cmp = icmp ugt i64 %div, 200
  br i1 %cmp, label %while.body, label %if.end8

while.body:                                       ; preds = %while.cond
  %mul = shl nsw i32 %4, 1
  store i32 %mul, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %cmp4 = icmp sgt i32 %4, 250
  br i1 %cmp4, label %if.then6, label %while.cond, !llvm.loop !15

if.then6:                                         ; preds = %while.body
  store i32 500, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  br label %if.end8

if.end8:                                          ; preds = %while.cond, %if.then6, %if.end
  %.pn173 = phi i32 [ 500, %if.then6 ], [ %1, %if.end ], [ %4, %while.cond ]
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 180), align 8
  %tobool9.not = icmp eq i32 %6, 0
  br i1 %tobool9.not, label %if.end12, label %return

if.end12:                                         ; preds = %if.end8
  %7 = load ptr, ptr @getMonotonicUs, align 8
  %call = tail call i64 %7() #38
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div13 = sdiv i32 1000, %8
  %cmp14 = icmp sgt i32 %div13, 99
  br i1 %cmp14, label %do.body, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end12
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div17.rhs.trunc = trunc i32 %div13 to i16
  %div17159 = sdiv i16 100, %div17.rhs.trunc
  %div17.sext = sext i16 %div17159 to i32
  %rem = srem i32 %9, %div17.sext
  %tobool18.not = icmp eq i32 %rem, 0
  br i1 %tobool18.not, label %do.body, label %if.end31

do.body:                                          ; preds = %if.end12, %lor.lhs.false
  %10 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 124) monotonic, align 8
  %11 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 125) monotonic, align 8
  %12 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 126) monotonic, align 8
  %13 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 127) monotonic, align 8
  %14 = load ptr, ptr @getMonotonicUs, align 8
  %call29 = tail call i64 %14() #38
  %15 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 89), align 8
  %16 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 0), align 8
  %cmp.i = icmp sgt i64 %16, 0
  br i1 %cmp.i, label %if.then.i, label %trackInstantaneousMetric.exit

if.then.i:                                        ; preds = %do.body
  %sub.i = sub nsw i64 %call29, %16
  %cmp7.i = icmp sgt i64 %sub.i, 0
  br i1 %cmp7.i, label %cond.true.i, label %cond.end.i

cond.true.i:                                      ; preds = %if.then.i
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 0, i32 1), align 8
  %sub6.i = sub nsw i64 %15, %17
  %mul.i = mul nsw i64 %sub6.i, 1000000
  %div.i = sdiv i64 %mul.i, %sub.i
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.then.i
  %cond.i = phi i64 [ %div.i, %cond.true.i ], [ 0, %if.then.i ]
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 0, i32 3), align 8
  %idxprom12.i = sext i32 %18 to i64
  %arrayidx13.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 0, i32 2, i64 %idxprom12.i
  store i64 %cond.i, ptr %arrayidx13.i, align 8
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 0, i32 3), align 8
  %inc.i = add nsw i32 %19, 1
  %rem.i = srem i32 %inc.i, 16
  store i32 %rem.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 0, i32 3), align 8
  br label %trackInstantaneousMetric.exit

trackInstantaneousMetric.exit:                    ; preds = %do.body, %cond.end.i
  store i64 %call29, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 0), align 8
  store i64 %15, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 0, i32 1), align 8
  %add = add nsw i64 %12, %10
  %20 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 1), align 8
  %cmp.i47 = icmp sgt i64 %20, 0
  br i1 %cmp.i47, label %if.then.i48, label %trackInstantaneousMetric.exit61

if.then.i48:                                      ; preds = %trackInstantaneousMetric.exit
  %sub.i49 = sub nsw i64 %call29, %20
  %cmp7.i50 = icmp sgt i64 %sub.i49, 0
  br i1 %cmp7.i50, label %cond.true.i57, label %cond.end.i51

cond.true.i57:                                    ; preds = %if.then.i48
  %21 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 1, i32 1), align 8
  %sub6.i58 = sub nsw i64 %add, %21
  %mul.i59 = mul nsw i64 %sub6.i58, 1000000
  %div.i60 = sdiv i64 %mul.i59, %sub.i49
  br label %cond.end.i51

cond.end.i51:                                     ; preds = %cond.true.i57, %if.then.i48
  %cond.i52 = phi i64 [ %div.i60, %cond.true.i57 ], [ 0, %if.then.i48 ]
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 1, i32 3), align 8
  %idxprom12.i53 = sext i32 %22 to i64
  %arrayidx13.i54 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 1, i32 2, i64 %idxprom12.i53
  store i64 %cond.i52, ptr %arrayidx13.i54, align 8
  %23 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 1, i32 3), align 8
  %inc.i55 = add nsw i32 %23, 1
  %rem.i56 = srem i32 %inc.i55, 16
  store i32 %rem.i56, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 1, i32 3), align 8
  br label %trackInstantaneousMetric.exit61

trackInstantaneousMetric.exit61:                  ; preds = %trackInstantaneousMetric.exit, %cond.end.i51
  store i64 %call29, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 1), align 8
  store i64 %add, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 1, i32 1), align 8
  %add30 = add nsw i64 %13, %11
  %24 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 2), align 8
  %cmp.i62 = icmp sgt i64 %24, 0
  br i1 %cmp.i62, label %if.then.i63, label %trackInstantaneousMetric.exit76

if.then.i63:                                      ; preds = %trackInstantaneousMetric.exit61
  %sub.i64 = sub nsw i64 %call29, %24
  %cmp7.i65 = icmp sgt i64 %sub.i64, 0
  br i1 %cmp7.i65, label %cond.true.i72, label %cond.end.i66

cond.true.i72:                                    ; preds = %if.then.i63
  %25 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 2, i32 1), align 8
  %sub6.i73 = sub nsw i64 %add30, %25
  %mul.i74 = mul nsw i64 %sub6.i73, 1000000
  %div.i75 = sdiv i64 %mul.i74, %sub.i64
  br label %cond.end.i66

cond.end.i66:                                     ; preds = %cond.true.i72, %if.then.i63
  %cond.i67 = phi i64 [ %div.i75, %cond.true.i72 ], [ 0, %if.then.i63 ]
  %26 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 2, i32 3), align 8
  %idxprom12.i68 = sext i32 %26 to i64
  %arrayidx13.i69 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 2, i32 2, i64 %idxprom12.i68
  store i64 %cond.i67, ptr %arrayidx13.i69, align 8
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 2, i32 3), align 8
  %inc.i70 = add nsw i32 %27, 1
  %rem.i71 = srem i32 %inc.i70, 16
  store i32 %rem.i71, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 2, i32 3), align 8
  br label %trackInstantaneousMetric.exit76

trackInstantaneousMetric.exit76:                  ; preds = %trackInstantaneousMetric.exit61, %cond.end.i66
  store i64 %call29, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 2), align 8
  store i64 %add30, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 2, i32 1), align 8
  %28 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 3), align 8
  %cmp.i77 = icmp sgt i64 %28, 0
  br i1 %cmp.i77, label %if.then.i78, label %trackInstantaneousMetric.exit91

if.then.i78:                                      ; preds = %trackInstantaneousMetric.exit76
  %sub.i79 = sub nsw i64 %call29, %28
  %cmp7.i80 = icmp sgt i64 %sub.i79, 0
  br i1 %cmp7.i80, label %cond.true.i87, label %cond.end.i81

cond.true.i87:                                    ; preds = %if.then.i78
  %29 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 3, i32 1), align 8
  %sub6.i88 = sub nsw i64 %12, %29
  %mul.i89 = mul nsw i64 %sub6.i88, 1000000
  %div.i90 = sdiv i64 %mul.i89, %sub.i79
  br label %cond.end.i81

cond.end.i81:                                     ; preds = %cond.true.i87, %if.then.i78
  %cond.i82 = phi i64 [ %div.i90, %cond.true.i87 ], [ 0, %if.then.i78 ]
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 3, i32 3), align 8
  %idxprom12.i83 = sext i32 %30 to i64
  %arrayidx13.i84 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 3, i32 2, i64 %idxprom12.i83
  store i64 %cond.i82, ptr %arrayidx13.i84, align 8
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 3, i32 3), align 8
  %inc.i85 = add nsw i32 %31, 1
  %rem.i86 = srem i32 %inc.i85, 16
  store i32 %rem.i86, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 3, i32 3), align 8
  br label %trackInstantaneousMetric.exit91

trackInstantaneousMetric.exit91:                  ; preds = %trackInstantaneousMetric.exit76, %cond.end.i81
  store i64 %call29, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 3), align 8
  store i64 %12, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 3, i32 1), align 8
  %32 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 4), align 8
  %cmp.i92 = icmp sgt i64 %32, 0
  br i1 %cmp.i92, label %if.then.i93, label %trackInstantaneousMetric.exit106

if.then.i93:                                      ; preds = %trackInstantaneousMetric.exit91
  %sub.i94 = sub nsw i64 %call29, %32
  %cmp7.i95 = icmp sgt i64 %sub.i94, 0
  br i1 %cmp7.i95, label %cond.true.i102, label %cond.end.i96

cond.true.i102:                                   ; preds = %if.then.i93
  %33 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 4, i32 1), align 8
  %sub6.i103 = sub nsw i64 %13, %33
  %mul.i104 = mul nsw i64 %sub6.i103, 1000000
  %div.i105 = sdiv i64 %mul.i104, %sub.i94
  br label %cond.end.i96

cond.end.i96:                                     ; preds = %cond.true.i102, %if.then.i93
  %cond.i97 = phi i64 [ %div.i105, %cond.true.i102 ], [ 0, %if.then.i93 ]
  %34 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 4, i32 3), align 8
  %idxprom12.i98 = sext i32 %34 to i64
  %arrayidx13.i99 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 4, i32 2, i64 %idxprom12.i98
  store i64 %cond.i97, ptr %arrayidx13.i99, align 8
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 4, i32 3), align 8
  %inc.i100 = add nsw i32 %35, 1
  %rem.i101 = srem i32 %inc.i100, 16
  store i32 %rem.i101, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 4, i32 3), align 8
  br label %trackInstantaneousMetric.exit106

trackInstantaneousMetric.exit106:                 ; preds = %trackInstantaneousMetric.exit91, %cond.end.i96
  store i64 %call29, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 4), align 8
  store i64 %13, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 4, i32 1), align 8
  %36 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155), align 8
  %37 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 5), align 8
  %cmp.i107 = icmp sgt i64 %37, 0
  br i1 %cmp.i107, label %if.then.i108, label %trackInstantaneousMetric.exit121

if.then.i108:                                     ; preds = %trackInstantaneousMetric.exit106
  %sub.i109 = sub nsw i64 %call29, %37
  %cmp7.i110 = icmp sgt i64 %sub.i109, 0
  br i1 %cmp7.i110, label %cond.true.i117, label %cond.end.i111

cond.true.i117:                                   ; preds = %if.then.i108
  %38 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 5, i32 1), align 8
  %sub6.i118 = sub nsw i64 %36, %38
  %mul.i119 = mul nsw i64 %sub6.i118, 1000000
  %div.i120 = sdiv i64 %mul.i119, %sub.i109
  br label %cond.end.i111

cond.end.i111:                                    ; preds = %cond.true.i117, %if.then.i108
  %cond.i112 = phi i64 [ %div.i120, %cond.true.i117 ], [ 0, %if.then.i108 ]
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 5, i32 3), align 8
  %idxprom12.i113 = sext i32 %39 to i64
  %arrayidx13.i114 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 5, i32 2, i64 %idxprom12.i113
  store i64 %cond.i112, ptr %arrayidx13.i114, align 8
  %40 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 5, i32 3), align 8
  %inc.i115 = add nsw i32 %40, 1
  %rem.i116 = srem i32 %inc.i115, 16
  store i32 %rem.i116, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 5, i32 3), align 8
  %.pre = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155), align 8
  br label %trackInstantaneousMetric.exit121

trackInstantaneousMetric.exit121:                 ; preds = %trackInstantaneousMetric.exit106, %cond.end.i111
  %41 = phi i64 [ %36, %trackInstantaneousMetric.exit106 ], [ %.pre, %cond.end.i111 ]
  store i64 %call29, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 5), align 8
  store i64 %36, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 5, i32 1), align 8
  %42 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155, i64 0, i32 1), align 8
  %43 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 6), align 8
  %cmp.i122 = icmp sgt i64 %43, 0
  br i1 %cmp.i122, label %if.then.i123, label %trackInstantaneousMetric.exit135

if.then.i123:                                     ; preds = %trackInstantaneousMetric.exit121
  %sub.i124 = sub nsw i64 %41, %43
  %cmp7.i125 = icmp sgt i64 %sub.i124, 0
  br i1 %cmp7.i125, label %cond.true.i132, label %cond.end.i126

cond.true.i132:                                   ; preds = %if.then.i123
  %44 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 6, i32 1), align 8
  %sub6.i133 = sub nsw i64 %42, %44
  %div.i134 = sdiv i64 %sub6.i133, %sub.i124
  br label %cond.end.i126

cond.end.i126:                                    ; preds = %cond.true.i132, %if.then.i123
  %cond.i127 = phi i64 [ %div.i134, %cond.true.i132 ], [ 0, %if.then.i123 ]
  %45 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 6, i32 3), align 8
  %idxprom12.i128 = sext i32 %45 to i64
  %arrayidx13.i129 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 6, i32 2, i64 %idxprom12.i128
  store i64 %cond.i127, ptr %arrayidx13.i129, align 8
  %46 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 6, i32 3), align 8
  %inc.i130 = add nsw i32 %46, 1
  %rem.i131 = srem i32 %inc.i130, 16
  store i32 %rem.i131, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 6, i32 3), align 8
  br label %trackInstantaneousMetric.exit135

trackInstantaneousMetric.exit135:                 ; preds = %trackInstantaneousMetric.exit121, %cond.end.i126
  store i64 %41, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 6), align 8
  store i64 %42, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 148, i64 6, i32 1), align 8
  br label %if.end31

if.end31:                                         ; preds = %trackInstantaneousMetric.exit135, %lor.lhs.false
  %call32 = tail call i32 @getLRUClock() #38
  store i32 %call32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 16), align 8
  tail call void @cronUpdateMemoryStats()
  %47 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  %tobool33.not = icmp ne i32 %47, 0
  %48 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 18), align 8
  %cmp.i136.not = icmp eq i64 %48, 0
  %or.cond160 = select i1 %tobool33.not, i1 %cmp.i136.not, i1 false
  br i1 %or.cond160, label %if.then36, label %if.else54

if.then36:                                        ; preds = %if.end31
  %49 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 19), align 8
  %cmp37 = icmp eq i32 %49, 2
  %50 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 258), align 4
  %tobool40 = icmp ne i32 %50, 0
  %or.cond = select i1 %cmp37, i1 %tobool40, i1 false
  br i1 %or.cond, label %if.end48, label %if.else

if.else:                                          ; preds = %if.then36
  %cmp42 = icmp eq i32 %49, 15
  %51 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 259), align 8
  %tobool45 = icmp ne i32 %51, 0
  %or.cond1 = select i1 %cmp42, i1 %tobool45, i1 false
  %spec.select = select i1 %or.cond1, i32 %51, i32 0
  br label %if.end48

if.end48:                                         ; preds = %if.else, %if.then36
  %shutdownFlags.0 = phi i32 [ %50, %if.then36 ], [ %spec.select, %if.else ]
  %call49 = tail call i32 @prepareForShutdown(i32 noundef %shutdownFlags.0), !range !16
  %cmp50 = icmp eq i32 %call49, 0
  br i1 %cmp50, label %if.then52, label %if.end71

if.then52:                                        ; preds = %if.end48
  tail call void @exit(i32 noundef 0) #40
  unreachable

if.else54:                                        ; preds = %if.end31
  br i1 %cmp.i136.not, label %if.end71, label %if.then57

if.then57:                                        ; preds = %if.else54
  %52 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %cmp58.not = icmp slt i64 %52, %48
  br i1 %cmp58.not, label %lor.lhs.false60, label %if.then63

lor.lhs.false60:                                  ; preds = %if.then57
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i)
  %53 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len.i = getelementptr inbounds %struct.list, ptr %53, i64 0, i32 5
  %54 = load i64, ptr %len.i, align 8
  %cmp.i139 = icmp eq i64 %54, 0
  br i1 %cmp.i139, label %isReadyToShutdown.exit.thread, label %if.end.i

if.end.i:                                         ; preds = %lor.lhs.false60
  call void @listRewind(ptr noundef nonnull %53, ptr noundef nonnull %li.i) #38
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %if.end.i
  %call.i = call ptr @listNext(ptr noundef nonnull %li.i) #38
  %cmp1.not.i = icmp eq ptr %call.i, null
  br i1 %cmp1.not.i, label %isReadyToShutdown.exit.thread, label %while.body.i

while.body.i:                                     ; preds = %while.cond.i
  %value.i = getelementptr inbounds %struct.listNode, ptr %call.i, i64 0, i32 2
  %55 = load ptr, ptr %value.i, align 8
  %repl_ack_off.i = getelementptr inbounds %struct.client, ptr %55, i64 0, i32 44
  %56 = load i64, ptr %repl_ack_off.i, align 8
  %57 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %cmp2.not.i = icmp eq i64 %56, %57
  br i1 %cmp2.not.i, label %while.cond.i, label %isReadyToShutdown.exit, !llvm.loop !17

isReadyToShutdown.exit.thread:                    ; preds = %while.cond.i, %lor.lhs.false60
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  br label %if.then63

isReadyToShutdown.exit:                           ; preds = %while.body.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  br label %if.end71

if.then63:                                        ; preds = %isReadyToShutdown.exit.thread, %if.then57
  %call64 = call i32 @finishShutdown(), !range !16
  %cmp65 = icmp eq i32 %call64, 0
  br i1 %cmp65, label %if.then67, label %if.end71

if.then67:                                        ; preds = %if.then63
  call void @exit(i32 noundef 0) #40
  unreachable

if.end71:                                         ; preds = %isReadyToShutdown.exit, %if.else54, %if.then63, %if.end48
  %58 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp72 = icmp slt i32 %58, 2
  br i1 %cmp72, label %lor.lhs.false78, label %if.end105

lor.lhs.false78:                                  ; preds = %if.end71
  %59 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div75 = sdiv i32 1000, %59
  %60 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div80.rhs.trunc = trunc i32 %div75 to i16
  %div80150 = sdiv i16 5000, %div80.rhs.trunc
  %div80.sext = sext i16 %div80150 to i32
  %rem81 = srem i32 %60, %div80.sext
  %tobool82.not = icmp eq i32 %rem81, 0
  %61 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %cmp84161 = icmp sgt i32 %61, 0
  %or.cond165 = select i1 %tobool82.not, i1 %cmp84161, i1 false
  br i1 %or.cond165, label %for.body, label %if.end105

for.body:                                         ; preds = %lor.lhs.false78, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %lor.lhs.false78 ]
  %62 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %62, i64 %indvars.iv
  %call86 = call i64 @dbBuckets(ptr noundef %arrayidx, i32 noundef 0) #38
  %63 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %arrayidx88 = getelementptr inbounds %struct.redisDb, ptr %63, i64 %indvars.iv
  %call89 = call i64 @dbSize(ptr noundef %arrayidx88, i32 noundef 0) #38
  %64 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %arrayidx91 = getelementptr inbounds %struct.redisDb, ptr %64, i64 %indvars.iv
  %call92 = call i64 @dbSize(ptr noundef %arrayidx91, i32 noundef 1) #38
  %tobool93 = icmp eq i64 %call89, 0
  %tobool95 = icmp eq i64 %call92, 0
  %or.cond2.not46 = select i1 %tobool93, i1 %tobool95, i1 false
  %65 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp98 = icmp sgt i32 %65, 1
  %or.cond12 = select i1 %or.cond2.not46, i1 true, i1 %cmp98
  br i1 %or.cond12, label %for.inc, label %if.end101

if.end101:                                        ; preds = %for.body
  %66 = trunc i64 %indvars.iv to i32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.22, i32 noundef %66, i64 noundef %call89, i64 noundef %call92, i64 noundef %call86)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end101
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %67 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %68 = sext i32 %67 to i64
  %cmp84 = icmp slt i64 %indvars.iv.next, %68
  br i1 %cmp84, label %for.body, label %if.end105, !llvm.loop !18

if.end105:                                        ; preds = %for.inc, %lor.lhs.false78, %if.end71
  %69 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool106.not = icmp eq i32 %69, 0
  br i1 %tobool106.not, label %lor.lhs.false111, label %if.end128

lor.lhs.false111:                                 ; preds = %if.end105
  %70 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div108 = sdiv i32 1000, %70
  %71 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div113.rhs.trunc = trunc i32 %div108 to i16
  %div113151 = sdiv i16 5000, %div113.rhs.trunc
  %div113.sext = sext i16 %div113151 to i32
  %rem114 = srem i32 %71, %div113.sext
  %tobool115 = icmp ne i32 %rem114, 0
  %72 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp118 = icmp sgt i32 %72, 0
  %or.cond13 = select i1 %tobool115, i1 true, i1 %cmp118
  br i1 %or.cond13, label %if.end128, label %if.end121

if.end121:                                        ; preds = %lor.lhs.false111
  %73 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  %len122 = getelementptr inbounds %struct.list, ptr %73, i64 0, i32 5
  %74 = load i64, ptr %len122, align 8
  %75 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len123 = getelementptr inbounds %struct.list, ptr %75, i64 0, i32 5
  %76 = load i64, ptr %len123, align 8
  %sub = sub i64 %74, %76
  %call125 = call i64 @zmalloc_used_memory() #38
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.23, i64 noundef %sub, i64 noundef %76, i64 noundef %call125)
  br label %if.end128

if.end128:                                        ; preds = %lor.lhs.false111, %if.end121, %if.end105
  call void @clientsCron()
  call void @databasesCron()
  %77 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i140.not = icmp eq i32 %77, -1
  %78 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 197), align 4
  %tobool132 = icmp ne i32 %78, 0
  %or.cond3 = select i1 %cmp.i140.not, i1 %tobool132, i1 false
  br i1 %or.cond3, label %land.lhs.true133, label %if.end138

land.lhs.true133:                                 ; preds = %if.end128
  %call134 = call i32 @aofRewriteLimited() #38
  %tobool135.not = icmp eq i32 %call134, 0
  br i1 %tobool135.not, label %if.then136, label %if.end138thread-pre-split

if.then136:                                       ; preds = %land.lhs.true133
  %call137 = call i32 @rewriteAppendOnlyFileBackground() #38
  br label %if.end138thread-pre-split

if.end138thread-pre-split:                        ; preds = %land.lhs.true133, %if.then136
  %.pr = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  br label %if.end138

if.end138:                                        ; preds = %if.end138thread-pre-split, %if.end128
  %79 = phi i32 [ %.pr, %if.end138thread-pre-split ], [ %77, %if.end128 ]
  %cmp.i142.not = icmp eq i32 %79, -1
  br i1 %cmp.i142.not, label %lor.lhs.false141, label %if.then144

lor.lhs.false141:                                 ; preds = %if.end138
  %call142 = call i32 @ldbPendingChildren() #38
  %tobool143.not = icmp eq i32 %call142, 0
  br i1 %tobool143.not, label %for.cond156.preheader, label %if.then144

for.cond156.preheader:                            ; preds = %lor.lhs.false141
  %80 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 224), align 8
  %cmp157163 = icmp sgt i32 %80, 0
  br i1 %cmp157163, label %for.body159, label %for.end190

if.then144:                                       ; preds = %lor.lhs.false141, %if.end138
  %81 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div145 = sdiv i32 1000, %81
  %cmp146 = icmp sgt i32 %div145, 999
  br i1 %cmp146, label %if.then153, label %lor.lhs.false148

lor.lhs.false148:                                 ; preds = %if.then144
  %82 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div150.rhs.trunc = trunc i32 %div145 to i16
  %div150158 = sdiv i16 1000, %div150.rhs.trunc
  %div150.sext = sext i16 %div150158 to i32
  %rem151 = srem i32 %82, %div150.sext
  %tobool152.not = icmp eq i32 %rem151, 0
  br i1 %tobool152.not, label %if.then153, label %if.end154

if.then153:                                       ; preds = %lor.lhs.false148, %if.then144
  call void @receiveChildInfo() #38
  br label %if.end154

if.end154:                                        ; preds = %if.then153, %lor.lhs.false148
  call void @checkChildrenDone()
  br label %if.end222

for.body159:                                      ; preds = %for.cond156.preheader, %for.inc188
  %indvars.iv169 = phi i64 [ %indvars.iv.next170, %for.inc188 ], [ 0, %for.cond156.preheader ]
  %83 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 223), align 8
  %add.ptr = getelementptr inbounds %struct.saveparam, ptr %83, i64 %indvars.iv169
  %84 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  %changes = getelementptr inbounds %struct.saveparam, ptr %83, i64 %indvars.iv169, i32 1
  %85 = load i32, ptr %changes, align 8
  %conv160 = sext i32 %85 to i64
  %cmp161.not = icmp slt i64 %84, %conv160
  br i1 %cmp161.not, label %for.inc188, label %land.lhs.true163

land.lhs.true163:                                 ; preds = %for.body159
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %86 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 229), align 8
  %sub164 = sub nsw i64 %atomic-load, %86
  %87 = load i64, ptr %add.ptr, align 8
  %cmp165 = icmp sgt i64 %sub164, %87
  br i1 %cmp165, label %land.lhs.true167, label %for.inc188

land.lhs.true167:                                 ; preds = %land.lhs.true163
  %atomic-load168 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %88 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 230), align 8
  %sub169 = sub nsw i64 %atomic-load168, %88
  %cmp170 = icmp sgt i64 %sub169, 5
  %89 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 235), align 8
  %cmp173 = icmp eq i32 %89, 0
  %or.cond4 = select i1 %cmp170, i1 true, i1 %cmp173
  br i1 %or.cond4, label %do.body176, label %for.inc188

do.body176:                                       ; preds = %land.lhs.true167
  %90 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp177 = icmp sgt i32 %90, 2
  br i1 %cmp177, label %do.end184, label %if.end180

if.end180:                                        ; preds = %do.body176
  %91 = load i32, ptr %changes, align 8
  %92 = load i64, ptr %add.ptr, align 8
  %conv183 = trunc i64 %92 to i32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.24, i32 noundef %91, i32 noundef %conv183)
  br label %do.end184

do.end184:                                        ; preds = %do.body176, %if.end180
  %call185 = call ptr @rdbPopulateSaveInfo(ptr noundef nonnull %rsi) #38
  %93 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 225), align 8
  %call186 = call i32 @rdbSaveBackground(i32 noundef 0, ptr noundef %93, ptr noundef %call185, i32 noundef 0) #38
  br label %for.end190

for.inc188:                                       ; preds = %for.body159, %land.lhs.true163, %land.lhs.true167
  %indvars.iv.next170 = add nuw nsw i64 %indvars.iv169, 1
  %94 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 224), align 8
  %95 = sext i32 %94 to i64
  %cmp157 = icmp slt i64 %indvars.iv.next170, %95
  br i1 %cmp157, label %for.body159, label %for.end190, !llvm.loop !19

for.end190:                                       ; preds = %for.inc188, %for.cond156.preheader, %do.end184
  %96 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp191 = icmp eq i32 %96, 1
  br i1 %cmp191, label %land.lhs.true193, label %if.end222

land.lhs.true193:                                 ; preds = %for.end190
  %97 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i144.not = icmp eq i32 %97, -1
  %98 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 190), align 4
  %tobool197 = icmp ne i32 %98, 0
  %or.cond5 = select i1 %cmp.i144.not, i1 %tobool197, i1 false
  br i1 %or.cond5, label %land.lhs.true198, label %if.end222

land.lhs.true198:                                 ; preds = %land.lhs.true193
  %99 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 193), align 8
  %100 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 191), align 8
  %cmp199 = icmp sgt i64 %99, %100
  br i1 %cmp199, label %if.then201, label %if.end222

if.then201:                                       ; preds = %land.lhs.true198
  %101 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 192), align 8
  %cond = call i64 @llvm.umax.i64(i64 %101, i64 1)
  %mul203 = mul nsw i64 %99, 100
  %div204 = sdiv i64 %mul203, %cond
  %sub205 = add nsw i64 %div204, -100
  %conv206 = sext i32 %98 to i64
  %cmp207.not = icmp slt i64 %sub205, %conv206
  br i1 %cmp207.not, label %if.end222, label %land.lhs.true209

land.lhs.true209:                                 ; preds = %if.then201
  %call210 = call i32 @aofRewriteLimited() #38
  %tobool211.not = icmp eq i32 %call210, 0
  br i1 %tobool211.not, label %do.body213, label %if.end222

do.body213:                                       ; preds = %land.lhs.true209
  %102 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp214 = icmp sgt i32 %102, 2
  br i1 %cmp214, label %do.end218, label %if.end217

if.end217:                                        ; preds = %do.body213
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.25, i64 noundef %sub205)
  br label %do.end218

do.end218:                                        ; preds = %do.body213, %if.end217
  %call219 = call i32 @rewriteAppendOnlyFileBackground() #38
  br label %if.end222

if.end222:                                        ; preds = %for.end190, %land.lhs.true193, %land.lhs.true198, %do.end218, %land.lhs.true209, %if.then201, %if.end154
  %103 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %cmp.not.i = icmp eq i32 %103, 0
  %104 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i.not.i = icmp ne i32 %104, -1
  %..i = zext i1 %cmp.i.not.i to i32
  %.sink.i = select i1 %cmp.not.i, i32 %..i, i32 2
  call void @dictSetResizeEnabled(i32 noundef %.sink.i) #38
  %105 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %106 = add i32 %105, -1
  %or.cond6 = icmp ult i32 %106, 2
  %107 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 201), align 8
  %tobool229 = icmp ne i64 %107, 0
  %or.cond7 = select i1 %or.cond6, i1 %tobool229, i1 false
  br i1 %or.cond7, label %if.then230, label %if.end231

if.then230:                                       ; preds = %if.end222
  call void @flushAppendOnlyFile(i32 noundef 0) #38
  br label %if.end231

if.end231:                                        ; preds = %if.end222, %if.then230
  %108 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div232 = sdiv i32 1000, %108
  %cmp233 = icmp sgt i32 %div232, 999
  br i1 %cmp233, label %if.then240, label %lor.lhs.false235

lor.lhs.false235:                                 ; preds = %if.end231
  %109 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div237.rhs.trunc = trunc i32 %div232 to i16
  %div237157 = sdiv i16 1000, %div237.rhs.trunc
  %div237.sext = sext i16 %div237157 to i32
  %rem238 = srem i32 %109, %div237.sext
  %tobool239.not = icmp eq i32 %rem238, 0
  br i1 %tobool239.not, label %if.then240, label %if.end251

if.then240:                                       ; preds = %lor.lhs.false235, %if.end231
  %110 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %111 = add i32 %110, -1
  %or.cond8 = icmp ult i32 %111, 2
  %112 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 211), align 8
  %cmp247 = icmp eq i32 %112, -1
  %or.cond9 = select i1 %or.cond8, i1 %cmp247, i1 false
  br i1 %or.cond9, label %if.then249, label %if.end251

if.then249:                                       ; preds = %if.then240
  call void @flushAppendOnlyFile(i32 noundef 0) #38
  br label %if.end251

if.end251:                                        ; preds = %if.then249, %if.then240, %lor.lhs.false235
  call void @updatePausedActions() #38
  %113 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 415), align 4
  %cmp252.not = icmp eq i32 %113, 0
  %114 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div266 = sdiv i32 1000, %114
  br i1 %cmp252.not, label %if.else265, label %if.then254

if.then254:                                       ; preds = %if.end251
  %cmp256 = icmp sgt i32 %div266, 99
  br i1 %cmp256, label %if.end276.sink.split, label %lor.lhs.false258

lor.lhs.false258:                                 ; preds = %if.then254
  %115 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div260.rhs.trunc = trunc i32 %div266 to i16
  %div260156 = sdiv i16 100, %div260.rhs.trunc
  %div260.sext = sext i16 %div260156 to i32
  %rem261 = srem i32 %115, %div260.sext
  %tobool262.not = icmp eq i32 %rem261, 0
  br i1 %tobool262.not, label %if.end276.sink.split, label %if.end276

if.else265:                                       ; preds = %if.end251
  %cmp267 = icmp sgt i32 %div266, 999
  br i1 %cmp267, label %if.end276.sink.split, label %lor.lhs.false269

lor.lhs.false269:                                 ; preds = %if.else265
  %116 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div271.rhs.trunc = trunc i32 %div266 to i16
  %div271155 = sdiv i16 1000, %div271.rhs.trunc
  %div271.sext = sext i16 %div271155 to i32
  %rem272 = srem i32 %116, %div271.sext
  %tobool273.not = icmp eq i32 %rem272, 0
  br i1 %tobool273.not, label %if.end276.sink.split, label %if.end276

if.end276.sink.split:                             ; preds = %if.else265, %lor.lhs.false269, %if.then254, %lor.lhs.false258
  call void @replicationCron() #38
  br label %if.end276

if.end276:                                        ; preds = %if.end276.sink.split, %lor.lhs.false269, %lor.lhs.false258
  %117 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div277 = sdiv i32 1000, %117
  %cmp278 = icmp sgt i32 %div277, 99
  br i1 %cmp278, label %if.then285, label %lor.lhs.false280

lor.lhs.false280:                                 ; preds = %if.end276
  %118 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div282.rhs.trunc = trunc i32 %div277 to i16
  %div282154 = sdiv i16 100, %div282.rhs.trunc
  %div282.sext = sext i16 %div282154 to i32
  %rem283 = srem i32 %118, %div282.sext
  %tobool284 = icmp eq i32 %rem283, 0
  %119 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool286 = icmp ne i32 %119, 0
  %or.cond15 = select i1 %tobool284, i1 %tobool286, i1 false
  br i1 %or.cond15, label %if.then287, label %if.end289

if.then285:                                       ; preds = %if.end276
  %.old14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool286.old.not = icmp eq i32 %.old14, 0
  br i1 %tobool286.old.not, label %if.end289, label %if.then287

if.then287:                                       ; preds = %lor.lhs.false280, %if.then285
  call void @clusterCron() #38
  br label %if.end289

if.end289:                                        ; preds = %if.then285, %if.then287, %lor.lhs.false280
  %120 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool290.not = icmp eq i32 %120, 0
  br i1 %tobool290.not, label %if.end292, label %if.then291

if.then291:                                       ; preds = %if.end289
  call void @sentinelTimer() #38
  br label %if.end292

if.end292:                                        ; preds = %if.then291, %if.end289
  %121 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div293 = sdiv i32 1000, %121
  %cmp294 = icmp sgt i32 %div293, 999
  br i1 %cmp294, label %if.then301, label %lor.lhs.false296

lor.lhs.false296:                                 ; preds = %if.end292
  %122 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div298.rhs.trunc = trunc i32 %div293 to i16
  %div298153 = sdiv i16 1000, %div298.rhs.trunc
  %div298.sext = sext i16 %div298153 to i32
  %rem299 = srem i32 %122, %div298.sext
  %tobool300.not = icmp eq i32 %rem299, 0
  br i1 %tobool300.not, label %if.then301, label %if.end302

if.then301:                                       ; preds = %lor.lhs.false296, %if.end292
  call void @migrateCloseTimedoutSockets() #38
  br label %if.end302

if.end302:                                        ; preds = %if.then301, %lor.lhs.false296
  %call303 = call i32 @stopThreadedIOIfNeeded() #38
  %123 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 329), align 8
  %tobool304.not = icmp eq i32 %123, 0
  br i1 %tobool304.not, label %if.end306, label %if.then305

if.then305:                                       ; preds = %if.end302
  call void @trackingLimitUsedSlots() #38
  br label %if.end306

if.end306:                                        ; preds = %if.then305, %if.end302
  %124 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i146.not = icmp eq i32 %124, -1
  %125 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 233), align 8
  %tobool310 = icmp ne i32 %125, 0
  %or.cond10 = select i1 %cmp.i146.not, i1 %tobool310, i1 false
  br i1 %or.cond10, label %land.lhs.true311, label %if.end328

land.lhs.true311:                                 ; preds = %if.end306
  %atomic-load312 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %126 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 230), align 8
  %sub313 = sub nsw i64 %atomic-load312, %126
  %cmp314 = icmp sgt i64 %sub313, 5
  %127 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 235), align 8
  %cmp317 = icmp eq i32 %127, 0
  %or.cond11 = select i1 %cmp314, i1 true, i1 %cmp317
  br i1 %or.cond11, label %if.then319, label %if.end328

if.then319:                                       ; preds = %land.lhs.true311
  %call322 = call ptr @rdbPopulateSaveInfo(ptr noundef nonnull %rsi320) #38
  %128 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 225), align 8
  %call323 = call i32 @rdbSaveBackground(i32 noundef 0, ptr noundef %128, ptr noundef %call322, i32 noundef 0) #38
  %cmp324 = icmp eq i32 %call323, 0
  br i1 %cmp324, label %if.then326, label %if.end328

if.then326:                                       ; preds = %if.then319
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 233), align 8
  br label %if.end328

if.end328:                                        ; preds = %if.then319, %if.then326, %land.lhs.true311, %if.end306
  %129 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div329 = sdiv i32 1000, %129
  %cmp330 = icmp sgt i32 %div329, 99
  br i1 %cmp330, label %if.then337, label %lor.lhs.false332

lor.lhs.false332:                                 ; preds = %if.end328
  %130 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %div334.rhs.trunc = trunc i32 %div329 to i16
  %div334152 = sdiv i16 100, %div334.rhs.trunc
  %div334.sext = sext i16 %div334152 to i32
  %rem335 = srem i32 %130, %div334.sext
  %tobool336.not = icmp eq i32 %rem335, 0
  br i1 %tobool336.not, label %if.then337, label %if.end342

if.then337:                                       ; preds = %lor.lhs.false332, %if.end328
  %call338 = call i64 @moduleCount() #38
  %tobool339.not = icmp eq i64 %call338, 0
  br i1 %tobool339.not, label %if.end342, label %if.then340

if.then340:                                       ; preds = %if.then337
  call void @modulesCron() #38
  br label %if.end342

if.end342:                                        ; preds = %if.then337, %if.then340, %lor.lhs.false332
  store i64 1, ptr %ei, align 8
  %hz = getelementptr inbounds %struct.RedisModuleCronLoopInfo, ptr %ei, i64 0, i32 1
  %131 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  store i32 %131, ptr %hz, align 8
  call void @moduleFireServerEvent(i64 noundef 8, i32 noundef 0, ptr noundef nonnull %ei) #38
  %132 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %inc343 = add nsw i32 %132, 1
  store i32 %inc343, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %133 = load ptr, ptr @getMonotonicUs, align 8
  %call344 = call i64 %133() #38
  %sub345 = sub i64 %call344, %call
  store i64 %sub345, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 154), align 8
  %.pn.pre = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  br label %return

return:                                           ; preds = %if.end8, %if.end342
  %.pn = phi i32 [ %.pn173, %if.end8 ], [ %.pn.pre, %if.end342 ]
  %retval.0 = sdiv i32 1000, %.pn
  ret i32 %retval.0
}

declare void @watchdogScheduleSignal(i32 noundef) local_unnamed_addr #4

declare i32 @getLRUClock() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @prepareForShutdown(i32 noundef %flags) local_unnamed_addr #0 {
entry:
  %argv.i = alloca [3 x ptr], align 16
  %li.i = alloca %struct.listIter, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 18), align 8
  %cmp.i.not = icmp eq i64 %0, 0
  br i1 %cmp.i.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool1 = icmp ne i32 %1, 0
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool2 = icmp ne i32 %2, 0
  %or.cond = select i1 %tobool1, i1 true, i1 %tobool2
  %and = and i32 %flags, -4
  %or = or disjoint i32 %and, 2
  %flags.addr.0 = select i1 %or.cond, i32 %or, i32 %flags
  store i32 %flags.addr.0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 20), align 4
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %3, 2
  br i1 %cmp, label %do.end, label %if.end6

if.end6:                                          ; preds = %if.end
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.193)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.end6
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  %cmp7 = icmp eq i32 %4, 2
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %do.end
  %call.i = tail call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.194) #38
  %cmp.i4 = icmp eq i32 %call.i, 0
  br i1 %cmp.i4, label %do.body.i, label %if.else.i

do.body.i:                                        ; preds = %if.then8
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i = icmp sgt i32 %5, 3
  br i1 %cmp1.i, label %if.end10, label %if.end.i

if.end.i:                                         ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %if.end10

if.else.i:                                        ; preds = %if.then8
  %cmp3.i = icmp sgt i32 %call.i, -1
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i = icmp sgt i32 %6, 3
  %or.cond.i = select i1 %cmp3.i, i1 true, i1 %cmp6.i
  br i1 %or.cond.i, label %if.end10, label %if.end8.i

if.end8.i:                                        ; preds = %if.else.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i)
  br label %if.end10

if.end10:                                         ; preds = %if.end8.i, %if.else.i, %if.end.i, %do.body.i, %do.end
  %and11 = and i32 %flags.addr.0, 4
  %tobool12 = icmp eq i32 %and11, 0
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 257), align 8
  %cmp13 = icmp ne i32 %7, 0
  %or.cond1 = select i1 %tobool12, i1 %cmp13, i1 false
  br i1 %or.cond1, label %land.lhs.true14, label %if.end28

land.lhs.true14:                                  ; preds = %if.end10
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i)
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len.i = getelementptr inbounds %struct.list, ptr %8, i64 0, i32 5
  %9 = load i64, ptr %len.i, align 8
  %cmp.i5 = icmp eq i64 %9, 0
  br i1 %cmp.i5, label %isReadyToShutdown.exit.thread, label %if.end.i6

if.end.i6:                                        ; preds = %land.lhs.true14
  call void @listRewind(ptr noundef nonnull %8, ptr noundef nonnull %li.i) #38
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %if.end.i6
  %call.i7 = call ptr @listNext(ptr noundef nonnull %li.i) #38
  %cmp1.not.i = icmp eq ptr %call.i7, null
  br i1 %cmp1.not.i, label %isReadyToShutdown.exit.thread, label %while.body.i

while.body.i:                                     ; preds = %while.cond.i
  %value.i = getelementptr inbounds %struct.listNode, ptr %call.i7, i64 0, i32 2
  %10 = load ptr, ptr %value.i, align 8
  %repl_ack_off.i = getelementptr inbounds %struct.client, ptr %10, i64 0, i32 44
  %11 = load i64, ptr %repl_ack_off.i, align 8
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %cmp2.not.i = icmp eq i64 %11, %12
  br i1 %cmp2.not.i, label %while.cond.i, label %if.then17, !llvm.loop !17

isReadyToShutdown.exit.thread:                    ; preds = %while.cond.i, %land.lhs.true14
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  br label %if.end28

if.then17:                                        ; preds = %while.body.i
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 257), align 8
  %mul = mul nsw i32 %14, 1000
  %conv = sext i32 %mul to i64
  %add = add nsw i64 %13, %conv
  store i64 %add, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 18), align 8
  %call18 = call i32 @isPausedActions(i32 noundef 16) #38
  %tobool19.not = icmp eq i32 %call18, 0
  br i1 %tobool19.not, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.then17
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %argv.i)
  %15 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 58), align 8
  store ptr %15, ptr %argv.i, align 16
  %arrayidx1.i = getelementptr inbounds [3 x ptr], ptr %argv.i, i64 0, i64 1
  %16 = load <2 x ptr>, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 77), align 8
  store <2 x ptr> %16, ptr %arrayidx1.i, align 8
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  call void @replicationFeedSlaves(ptr noundef %17, i32 noundef -1, ptr noundef nonnull %argv.i, i32 noundef 3) #38
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %argv.i)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.then17
  call void @pauseActions(i32 noundef 1, i64 noundef 9223372036854775807, i32 noundef 29) #38
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp23 = icmp sgt i32 %18, 2
  br i1 %cmp23, label %return, label %if.end26

if.end26:                                         ; preds = %if.end21
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.195)
  br label %return

if.end28:                                         ; preds = %isReadyToShutdown.exit.thread, %if.end10
  %call29 = call i32 @finishShutdown(), !range !16
  br label %return

return:                                           ; preds = %if.end26, %if.end21, %entry, %if.end28
  %retval.0 = phi i32 [ %call29, %if.end28 ], [ -1, %entry ], [ -1, %if.end21 ], [ -1, %if.end26 ]
  ret i32 %retval.0
}

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) local_unnamed_addr #17

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @isReadyToShutdown() local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @listRewind(ptr noundef nonnull %0, ptr noundef nonnull %li) #38
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %call = call ptr @listNext(ptr noundef nonnull %li) #38
  %cmp1.not = icmp eq ptr %call, null
  br i1 %cmp1.not, label %return, label %while.body

while.body:                                       ; preds = %while.cond
  %value = getelementptr inbounds %struct.listNode, ptr %call, i64 0, i32 2
  %2 = load ptr, ptr %value, align 8
  %repl_ack_off = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 44
  %3 = load i64, ptr %repl_ack_off, align 8
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %cmp2.not = icmp eq i64 %3, %4
  br i1 %cmp2.not, label %while.cond, label %return, !llvm.loop !17

return:                                           ; preds = %while.cond, %while.body, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 1, %while.cond ], [ 0, %while.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @finishShutdown() local_unnamed_addr #0 {
entry:
  %replicas_iter = alloca %struct.listIter, align 8
  %rsi = alloca %struct.rdbSaveInfo, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 20), align 4
  %and = and i32 %0, 1
  %and1 = and i32 %0, 2
  %and2 = and i32 %0, 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  call void @listRewind(ptr noundef %1, ptr noundef nonnull %replicas_iter) #38
  %call44 = call ptr @listNext(ptr noundef nonnull %replicas_iter) #38
  %cmp.not45 = icmp eq ptr %call44, null
  br i1 %cmp.not45, label %if.end23, label %while.body

while.body:                                       ; preds = %entry, %if.end14
  %call48 = phi ptr [ %call, %if.end14 ], [ %call44, %entry ]
  %num_replicas.047 = phi i32 [ %inc, %if.end14 ], [ 0, %entry ]
  %num_lagging_replicas.046 = phi i32 [ %num_lagging_replicas.1, %if.end14 ], [ 0, %entry ]
  %value = getelementptr inbounds %struct.listNode, ptr %call48, i64 0, i32 2
  %2 = load ptr, ptr %value, align 8
  %inc = add nuw nsw i32 %num_replicas.047, 1
  %repl_ack_off = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 44
  %3 = load i64, ptr %repl_ack_off, align 8
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %cmp3.not = icmp eq i64 %3, %4
  br i1 %cmp3.not, label %if.end14, label %if.then

if.then:                                          ; preds = %while.body
  %inc4 = add nsw i32 %num_lagging_replicas.046, 1
  %replstate = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 35
  %5 = load i32, ptr %replstate, align 4
  %cmp5 = icmp eq i32 %5, 9
  br i1 %cmp5, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.then
  %call6 = call i64 @time(ptr noundef null) #38
  %repl_ack_time = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 46
  %6 = load i64, ptr %repl_ack_time, align 8
  %sub = sub nsw i64 %call6, %6
  br label %cond.end

cond.end:                                         ; preds = %if.then, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ 0, %if.then ]
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp7 = icmp sgt i32 %7, 2
  br i1 %cmp7, label %if.end14, label %if.end

if.end:                                           ; preds = %cond.end
  %call9 = call ptr @replicationGetSlaveName(ptr noundef nonnull %2) #38
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %9 = load i64, ptr %repl_ack_off, align 8
  %sub11 = sub nsw i64 %8, %9
  %10 = load i32, ptr %replstate, align 4
  %switch.tableidx = add i32 %10, -6
  %11 = icmp ult i32 %switch.tableidx, 4
  br i1 %11, label %switch.lookup, label %replstateToString.exit

switch.lookup:                                    ; preds = %if.end
  %12 = zext nneg i32 %switch.tableidx to i64
  %switch.gep = getelementptr inbounds [4 x ptr], ptr @switch.table.replstateToString, i64 0, i64 %12
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %replstateToString.exit

replstateToString.exit:                           ; preds = %if.end, %switch.lookup
  %retval.0.i = phi ptr [ %switch.load, %switch.lookup ], [ @.str.219, %if.end ]
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.197, ptr noundef %call9, i64 noundef %sub11, i64 noundef %cond, ptr noundef nonnull %retval.0.i)
  br label %if.end14

if.end14:                                         ; preds = %replstateToString.exit, %cond.end, %while.body
  %num_lagging_replicas.1 = phi i32 [ %inc4, %cond.end ], [ %inc4, %replstateToString.exit ], [ %num_lagging_replicas.046, %while.body ]
  %call = call ptr @listNext(ptr noundef nonnull %replicas_iter) #38
  %cmp.not = icmp eq ptr %call, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !20

while.end:                                        ; preds = %if.end14
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp18 = icmp sgt i32 %13, 2
  br i1 %cmp18, label %if.end23, label %if.end20

if.end20:                                         ; preds = %while.end
  %sub21 = sub nsw i32 %inc, %num_lagging_replicas.1
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.198, i32 noundef %sub21, i32 noundef %inc)
  br label %if.end23

if.end23:                                         ; preds = %entry, %if.end20, %while.end
  call void @ldbKillForkedSessions() #38
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  %cmp24 = icmp eq i32 %14, 1
  br i1 %cmp24, label %do.body26, label %if.end31

do.body26:                                        ; preds = %if.end23
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp27 = icmp sgt i32 %15, 3
  br i1 %cmp27, label %do.end30, label %if.end29

if.end29:                                         ; preds = %do.body26
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.199)
  br label %do.end30

do.end30:                                         ; preds = %do.body26, %if.end29
  call void @killRDBChild() #38
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  call void @rdbRemoveTempFile(i32 noundef %16, i32 noundef 0) #38
  %.pr = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  br label %if.end31

if.end31:                                         ; preds = %do.end30, %if.end23
  %17 = phi i32 [ %.pr, %do.end30 ], [ %14, %if.end23 ]
  %cmp32 = icmp eq i32 %17, 4
  br i1 %cmp32, label %do.body34, label %if.end40

do.body34:                                        ; preds = %if.end31
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp35 = icmp sgt i32 %18, 3
  br i1 %cmp35, label %do.end38, label %if.end37

if.end37:                                         ; preds = %do.body34
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.200)
  br label %do.end38

do.end38:                                         ; preds = %do.body34, %if.end37
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %call39 = call i32 @TerminateModuleForkChild(i32 noundef %19, i32 noundef 0) #38
  %.pre = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  br label %if.end40

if.end40:                                         ; preds = %do.end38, %if.end31
  %20 = phi i32 [ %.pre, %do.end38 ], [ %17, %if.end31 ]
  %cmp41 = icmp eq i32 %20, 2
  br i1 %cmp41, label %if.then42, label %if.end67

if.then42:                                        ; preds = %if.end40
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp43 = icmp eq i32 %21, 2
  br i1 %cmp43, label %if.then44, label %do.body62

if.then44:                                        ; preds = %if.then42
  %tobool.not = icmp eq i32 %and2, 0
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp52 = icmp sgt i32 %22, 3
  br i1 %tobool.not, label %do.body51, label %do.body46

do.body46:                                        ; preds = %if.then44
  br i1 %cmp52, label %do.end66, label %if.end49

if.end49:                                         ; preds = %do.body46
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.201)
  br label %do.body62

do.body51:                                        ; preds = %if.then44
  br i1 %cmp52, label %do.end55, label %if.end54

if.end54:                                         ; preds = %do.body51
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.202)
  br label %do.end55

do.end55:                                         ; preds = %do.body51, %if.end54
  %23 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  %cmp56 = icmp eq i32 %23, 2
  br i1 %cmp56, label %if.then57, label %do.body151thread-pre-split

if.then57:                                        ; preds = %do.end55
  %call.i = call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.203) #38
  %cmp.i = icmp eq i32 %call.i, 0
  br i1 %cmp.i, label %do.body.i, label %if.else.i

do.body.i:                                        ; preds = %if.then57
  %24 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i = icmp sgt i32 %24, 3
  br i1 %cmp1.i, label %do.end155, label %if.end.i

if.end.i:                                         ; preds = %do.body.i
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %do.body151thread-pre-split

if.else.i:                                        ; preds = %if.then57
  %cmp3.i = icmp sgt i32 %call.i, -1
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i = icmp sgt i32 %25, 3
  %or.cond.i = select i1 %cmp3.i, i1 true, i1 %cmp6.i
  br i1 %or.cond.i, label %do.body151, label %if.end8.i

if.end8.i:                                        ; preds = %if.else.i
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i)
  br label %do.body151thread-pre-split

do.body62:                                        ; preds = %if.then42, %if.end49
  %.pr40 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp63 = icmp sgt i32 %.pr40, 3
  br i1 %cmp63, label %do.end66, label %if.end65

if.end65:                                         ; preds = %do.body62
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.204)
  br label %do.end66

do.end66:                                         ; preds = %do.body46, %do.body62, %if.end65
  call void @killAppendOnlyChild() #38
  br label %if.end67

if.end67:                                         ; preds = %do.end66, %if.end40
  %26 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp68.not = icmp eq i32 %26, 0
  br i1 %cmp68.not, label %if.end86, label %do.body70

do.body70:                                        ; preds = %if.end67
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp71 = icmp sgt i32 %27, 2
  br i1 %cmp71, label %do.end74, label %if.end73

if.end73:                                         ; preds = %do.body70
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.205)
  br label %do.end74

do.end74:                                         ; preds = %do.body70, %if.end73
  call void @flushAppendOnlyFile(i32 noundef 1) #38
  %28 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 199), align 8
  %call75 = call i32 @fdatasync(i32 noundef %28) #38
  %cmp76 = icmp ne i32 %call75, -1
  %29 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp79 = icmp sgt i32 %29, 3
  %or.cond5 = select i1 %cmp76, i1 true, i1 %cmp79
  br i1 %or.cond5, label %if.end86, label %if.end81

if.end81:                                         ; preds = %do.end74
  %call82 = tail call ptr @__errno_location() #41
  %30 = load i32, ptr %call82, align 4
  %call83 = call ptr @strerror(i32 noundef %30) #38
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.206, ptr noundef %call83)
  br label %if.end86

if.end86:                                         ; preds = %do.end74, %if.end81, %if.end67
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 224), align 8
  %cmp87 = icmp sgt i32 %31, 0
  %tobool88 = icmp eq i32 %and1, 0
  %or.cond.not17 = select i1 %cmp87, i1 %tobool88, i1 false
  %tobool89 = icmp ne i32 %and, 0
  %or.cond1 = select i1 %or.cond.not17, i1 true, i1 %tobool89
  br i1 %or.cond1, label %do.body91, label %if.end123

do.body91:                                        ; preds = %if.end86
  %32 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp92 = icmp sgt i32 %32, 2
  br i1 %cmp92, label %do.end95, label %if.end94

if.end94:                                         ; preds = %do.body91
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.207)
  br label %do.end95

do.end95:                                         ; preds = %do.body91, %if.end94
  %33 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  %cmp96 = icmp eq i32 %33, 2
  br i1 %cmp96, label %if.then97, label %if.end99

if.then97:                                        ; preds = %do.end95
  %call.i18 = call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.208) #38
  %cmp.i19 = icmp eq i32 %call.i18, 0
  br i1 %cmp.i19, label %do.body.i25, label %if.else.i20

do.body.i25:                                      ; preds = %if.then97
  %34 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i26 = icmp sgt i32 %34, 3
  br i1 %cmp1.i26, label %if.end99, label %if.end.i27

if.end.i27:                                       ; preds = %do.body.i25
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %if.end99

if.else.i20:                                      ; preds = %if.then97
  %cmp3.i21 = icmp sgt i32 %call.i18, -1
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i22 = icmp sgt i32 %35, 3
  %or.cond.i23 = select i1 %cmp3.i21, i1 true, i1 %cmp6.i22
  br i1 %or.cond.i23, label %if.end99, label %if.end8.i24

if.end8.i24:                                      ; preds = %if.else.i20
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i18)
  br label %if.end99

if.end99:                                         ; preds = %if.end8.i24, %if.else.i20, %if.end.i27, %do.body.i25, %do.end95
  %call100 = call ptr @rdbPopulateSaveInfo(ptr noundef nonnull %rsi) #38
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 225), align 8
  %call101 = call i32 @rdbSave(i32 noundef 0, ptr noundef %36, ptr noundef %call100, i32 noundef 16) #38
  %cmp102.not = icmp eq i32 %call101, 0
  br i1 %cmp102.not, label %if.end123, label %if.then103

if.then103:                                       ; preds = %if.end99
  %tobool104.not = icmp eq i32 %and2, 0
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp113 = icmp sgt i32 %37, 3
  br i1 %tobool104.not, label %do.body112, label %do.body106

do.body106:                                       ; preds = %if.then103
  br i1 %cmp113, label %if.end123, label %if.end109

if.end109:                                        ; preds = %do.body106
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.209)
  br label %if.end123

do.body112:                                       ; preds = %if.then103
  br i1 %cmp113, label %do.end116, label %if.end115

if.end115:                                        ; preds = %do.body112
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.210)
  br label %do.end116

do.end116:                                        ; preds = %do.body112, %if.end115
  %38 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  %cmp117 = icmp eq i32 %38, 2
  br i1 %cmp117, label %if.then118, label %do.body151thread-pre-split

if.then118:                                       ; preds = %do.end116
  %call.i29 = call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.211) #38
  %cmp.i30 = icmp eq i32 %call.i29, 0
  br i1 %cmp.i30, label %do.body.i36, label %if.else.i31

do.body.i36:                                      ; preds = %if.then118
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i37 = icmp sgt i32 %39, 3
  br i1 %cmp1.i37, label %do.end155, label %if.end.i38

if.end.i38:                                       ; preds = %do.body.i36
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %do.body151thread-pre-split

if.else.i31:                                      ; preds = %if.then118
  %cmp3.i32 = icmp sgt i32 %call.i29, -1
  %40 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i33 = icmp sgt i32 %40, 3
  %or.cond.i34 = select i1 %cmp3.i32, i1 true, i1 %cmp6.i33
  br i1 %or.cond.i34, label %do.body151, label %if.end8.i35

if.end8.i35:                                      ; preds = %if.else.i31
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i29)
  br label %do.body151thread-pre-split

if.end123:                                        ; preds = %if.end99, %if.end109, %do.body106, %if.end86
  %41 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 217), align 8
  %tobool124.not = icmp eq ptr %41, null
  br i1 %tobool124.not, label %if.end126, label %if.then125

if.then125:                                       ; preds = %if.end123
  call void @aofManifestFree(ptr noundef nonnull %41) #38
  br label %if.end126

if.end126:                                        ; preds = %if.then125, %if.end123
  call void @moduleFireServerEvent(i64 noundef 5, i32 noundef 0, ptr noundef null) #38
  %42 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 176), align 4
  %tobool127 = icmp ne i32 %42, 0
  %43 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 23), align 8
  %tobool129 = icmp ne ptr %43, null
  %or.cond2 = select i1 %tobool127, i1 true, i1 %tobool129
  br i1 %or.cond2, label %do.body131, label %if.end137

do.body131:                                       ; preds = %if.end126
  %44 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp132 = icmp sgt i32 %44, 2
  br i1 %cmp132, label %do.end135, label %if.end134

if.end134:                                        ; preds = %do.body131
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.212)
  %.pre50 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 23), align 8
  br label %do.end135

do.end135:                                        ; preds = %do.body131, %if.end134
  %45 = phi ptr [ %43, %do.body131 ], [ %.pre50, %if.end134 ]
  %call136 = call i32 @unlink(ptr noundef %45) #38
  br label %if.end137

if.end137:                                        ; preds = %if.end126, %do.end135
  call void @flushSlavesOutputBuffers() #38
  call void @closeListeningSockets(i32 noundef 1)
  %46 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool138 = icmp ne i32 %46, 0
  %47 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 382), align 8
  %cmp140 = icmp ne i32 %47, -1
  %or.cond3 = select i1 %tobool138, i1 %cmp140, i1 false
  br i1 %or.cond3, label %if.then141, label %do.body144

if.then141:                                       ; preds = %if.end137
  %call142 = call i32 @flock(i32 noundef %47, i32 noundef 12) #38
  br label %do.body144

do.body144:                                       ; preds = %if.end137, %if.then141
  %48 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp145 = icmp sgt i32 %48, 3
  br i1 %cmp145, label %return, label %if.end147

if.end147:                                        ; preds = %do.body144
  %49 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool148.not = icmp eq i32 %49, 0
  %cond149 = select i1 %tobool148.not, ptr @.str.215, ptr @.str.214
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.213, ptr noundef nonnull %cond149)
  br label %return

do.body151thread-pre-split:                       ; preds = %do.end116, %do.end55, %if.end.i, %if.end8.i, %if.end.i38, %if.end8.i35
  %.pr42 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  br label %do.body151

do.body151:                                       ; preds = %do.body151thread-pre-split, %if.else.i31, %if.else.i
  %50 = phi i32 [ %.pr42, %do.body151thread-pre-split ], [ %40, %if.else.i31 ], [ %25, %if.else.i ]
  %cmp152 = icmp sgt i32 %50, 3
  br i1 %cmp152, label %do.end155, label %if.end154

if.end154:                                        ; preds = %do.body151
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.216)
  br label %do.end155

do.end155:                                        ; preds = %do.body.i, %do.body.i36, %do.body151, %if.end154
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 18), i8 0, i64 16, i1 false)
  call void @replyToClientsBlockedOnShutdown() #38
  call void @unpauseActions(i32 noundef 1) #38
  br label %return

return:                                           ; preds = %if.end147, %do.body144, %do.end155
  %retval.0 = phi i32 [ -1, %do.end155 ], [ 0, %do.body144 ], [ 0, %if.end147 ]
  ret i32 %retval.0
}

declare i64 @dbBuckets(ptr noundef, i32 noundef) local_unnamed_addr #4

declare i32 @aofRewriteLimited() local_unnamed_addr #4

declare i32 @rewriteAppendOnlyFileBackground() local_unnamed_addr #4

declare i32 @ldbPendingChildren() local_unnamed_addr #4

declare ptr @rdbPopulateSaveInfo(ptr noundef) local_unnamed_addr #4

declare i32 @rdbSaveBackground(i32 noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare void @flushAppendOnlyFile(i32 noundef) local_unnamed_addr #4

declare void @updatePausedActions() local_unnamed_addr #4

declare void @replicationCron() local_unnamed_addr #4

declare void @clusterCron() local_unnamed_addr #4

declare void @sentinelTimer() local_unnamed_addr #4

declare void @migrateCloseTimedoutSockets() local_unnamed_addr #4

declare i32 @stopThreadedIOIfNeeded() local_unnamed_addr #4

declare void @trackingLimitUsedSlots() local_unnamed_addr #4

declare i64 @moduleCount() local_unnamed_addr #4

declare void @modulesCron() local_unnamed_addr #4

; Function Attrs: nofree nounwind uwtable
define dso_local void @blockingOperationStarts() local_unnamed_addr #8 {
entry:
  %tv.i.i = alloca %struct.timeval, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 355), align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 355), align 8
  %tobool.not = icmp eq i64 %0, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i)
  %call.i.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i, ptr noundef null) #38
  %1 = load i64, ptr %tv.i.i, align 8
  %mul.i.i = mul nsw i64 %1, 1000000
  %tv_usec.i.i = getelementptr inbounds %struct.timeval, ptr %tv.i.i, i64 0, i32 1
  %2 = load i64, ptr %tv_usec.i.i, align 8
  %add.i.i = add nsw i64 %mul.i.i, %2
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i)
  store i64 %add.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %div.i.i = sdiv i64 %add.i.i, 1000
  store i64 %div.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %div1.i.i = sdiv i64 %add.i.i, 1000000
  store atomic i64 %div1.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) monotonic, align 8
  store i64 %div.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 356), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) uwtable
define dso_local void @blockingOperationEnds() local_unnamed_addr #19 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 355), align 8
  %dec = add i64 %0, -1
  store i64 %dec, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 355), align 8
  %tobool.not = icmp eq i64 %dec, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 356), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @whileBlockedCron() local_unnamed_addr #0 {
entry:
  %tv.i.i4 = alloca %struct.timeval, align 8
  %tv.i.i = alloca %struct.timeval, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 356), align 8
  %tobool.not = icmp eq i64 %0, 0
  br i1 %tobool.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.26, ptr noundef nonnull @.str.9, i32 noundef 1625) #38
  tail call void @abort() #40
  unreachable

cond.end:                                         ; preds = %entry
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %cmp.not = icmp slt i64 %0, %1
  br i1 %cmp.not, label %if.end, label %if.end35

if.end:                                           ; preds = %cond.end
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %tobool4.not = icmp eq i64 %2, 0
  br i1 %tobool4.not, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i)
  %call.i.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i, ptr noundef null) #38
  %3 = load i64, ptr %tv.i.i, align 8
  %mul.i.i = mul nsw i64 %3, 1000000
  %tv_usec.i.i = getelementptr inbounds %struct.timeval, ptr %tv.i.i, i64 0, i32 1
  %4 = load i64, ptr %tv_usec.i.i, align 8
  %add.i.i = add nsw i64 %mul.i.i, %4
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i)
  %div.i.neg = sdiv i64 %add.i.i, -1000
  %.pre = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 356), align 8
  %.pre11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then5
  %5 = phi i64 [ %.pre11, %if.then5 ], [ %1, %if.end ]
  %6 = phi i64 [ %.pre, %if.then5 ], [ %0, %if.end ]
  %latency.0.neg = phi i64 [ %div.i.neg, %if.then5 ], [ 0, %if.end ]
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %div = sdiv i32 1000, %7
  %conv7 = sext i32 %div to i64
  %cmp810 = icmp slt i64 %6, %5
  br i1 %cmp810, label %while.body, label %while.end

while.body:                                       ; preds = %if.end6, %while.body
  tail call void @activeDefragCycle() #38
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 356), align 8
  %add = add nsw i64 %8, %conv7
  store i64 %add, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 356), align 8
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %cmp8 = icmp slt i64 %add, %10
  br i1 %cmp8, label %while.body, label %while.end, !llvm.loop !21

while.end:                                        ; preds = %while.body, %if.end6
  %11 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool10.not = icmp eq i32 %11, 0
  br i1 %tobool10.not, label %if.end12, label %if.then11

if.then11:                                        ; preds = %while.end
  tail call void @cronUpdateMemoryStats()
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %while.end
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %tobool13.not = icmp eq i64 %12, 0
  br i1 %tobool13.not, label %if.end21, label %if.end16

if.end16:                                         ; preds = %if.end12
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i4)
  %call.i.i5 = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i4, ptr noundef null) #38
  %13 = load i64, ptr %tv.i.i4, align 8
  %mul.i.i6 = mul nsw i64 %13, 1000000
  %tv_usec.i.i7 = getelementptr inbounds %struct.timeval, ptr %tv.i.i4, i64 0, i32 1
  %14 = load i64, ptr %tv_usec.i.i7, align 8
  %add.i.i8 = add nsw i64 %mul.i.i6, %14
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i4)
  %div.i9 = sdiv i64 %add.i.i8, 1000
  %sub = add i64 %latency.0.neg, %div.i9
  %.pre12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %tobool17.not = icmp eq i64 %.pre12, 0
  %cmp18.not = icmp slt i64 %sub, %.pre12
  %or.cond = select i1 %tobool17.not, i1 true, i1 %cmp18.not
  br i1 %or.cond, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end16
  tail call void @latencyAddSample(ptr noundef nonnull @.str.27, i64 noundef %sub) #38
  br label %if.end21

if.end21:                                         ; preds = %if.end12, %if.then20, %if.end16
  %15 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  %tobool22.not = icmp eq i32 %15, 0
  br i1 %tobool22.not, label %if.end35, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %if.end21
  %16 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool24.not = icmp eq i32 %16, 0
  br i1 %tobool24.not, label %if.end35, label %if.then25

if.then25:                                        ; preds = %land.lhs.true23
  %call26 = tail call i32 @prepareForShutdown(i32 noundef 2), !range !16
  %cmp27 = icmp eq i32 %call26, 0
  br i1 %cmp27, label %if.then29, label %do.body

if.then29:                                        ; preds = %if.then25
  tail call void @exit(i32 noundef 0) #40
  unreachable

do.body:                                          ; preds = %if.then25
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp31 = icmp sgt i32 %17, 3
  br i1 %cmp31, label %do.end, label %if.end34

if.end34:                                         ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.28)
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end34
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 19), align 8
  br label %if.end35

if.end35:                                         ; preds = %cond.end, %do.end, %land.lhs.true23, %if.end21
  ret void
}

declare void @latencyAddSample(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @beforeSleep(ptr nocapture readnone %eventLoop) #0 {
entry:
  %argv.i = alloca [3 x ptr], align 16
  %call = tail call i64 @zmalloc_used_memory() #38
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  %cmp = icmp ugt i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32, ptr @ProcessingEventsWhileBlocked, align 4
  %tobool.not = icmp eq i32 %1, 0
  %call20 = tail call i32 @handleClientsWithPendingReadsUsingThreads() #38
  br i1 %tobool.not, label %if.end19, label %if.then1

if.then1:                                         ; preds = %if.end
  %conv = sext i32 %call20 to i64
  %call3 = tail call i32 @connTypeProcessPendingData() #38
  %conv4 = sext i32 %call3 to i64
  %add5 = add nsw i64 %conv4, %conv
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %3 = add i32 %2, -1
  %or.cond = icmp ult i32 %3, 2
  br i1 %or.cond, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then1
  tail call void @flushAppendOnlyFile(i32 noundef 0) #38
  br label %if.end11

if.end11:                                         ; preds = %if.then1, %if.then10
  %call12 = tail call i32 @handleClientsWithPendingWrites() #38
  %conv13 = sext i32 %call12 to i64
  %add14 = add nsw i64 %add5, %conv13
  %call15 = tail call i32 @freeClientsInAsyncFreeQueue() #38
  %conv16 = sext i32 %call15 to i64
  %add17 = add nsw i64 %add14, %conv16
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 77), align 8
  %add18 = add i64 %add17, %4
  store i64 %add18, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 77), align 8
  br label %if.end104

if.end19:                                         ; preds = %if.end
  %call21 = tail call i32 @connTypeProcessPendingData() #38
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call22 = tail call i32 @connTypeHasPendingData() #38
  tail call void @aeSetDontWait(ptr noundef %5, i32 noundef %call22) #38
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool23.not = icmp eq i32 %6, 0
  br i1 %tobool23.not, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.end19
  tail call void @clusterBeforeSleep() #38
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.end19
  tail call void @blockedBeforeSleep() #38
  %7 = load ptr, ptr @getMonotonicUs, align 8
  %call26 = tail call i64 %7() #38
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 159), align 4
  %tobool27.not = icmp eq i32 %8, 0
  br i1 %tobool27.not, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end25
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.i = icmp eq i32 %9, 0
  br i1 %tobool.i, label %iAmMaster.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %land.lhs.true
  %call.i = tail call ptr @getMyClusterNode() #38
  %call2.i = tail call i32 @clusterNodeIsMaster(ptr noundef %call.i) #38
  %tobool3.i.not = icmp eq i32 %call2.i, 0
  br i1 %tobool3.i.not, label %if.end31, label %if.then30

iAmMaster.exit:                                   ; preds = %land.lhs.true
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp.i = icmp eq ptr %10, null
  br i1 %cmp.i, label %if.then30, label %if.end31

if.then30:                                        ; preds = %land.rhs.i, %iAmMaster.exit
  tail call void @activeExpireCycle(i32 noundef 1) #38
  br label %if.end31

if.end31:                                         ; preds = %land.rhs.i, %if.then30, %iAmMaster.exit, %if.end25
  %call32 = tail call i64 @moduleCount() #38
  %tobool33.not = icmp eq i64 %call32, 0
  br i1 %tobool33.not, label %if.end35, label %if.then34

if.then34:                                        ; preds = %if.end31
  tail call void @moduleFireServerEvent(i64 noundef 15, i32 noundef 0, ptr noundef null) #38
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.end31
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 312), align 8
  %tobool36.not = icmp eq i32 %11, 0
  br i1 %tobool36.not, label %if.end41, label %land.lhs.true37

land.lhs.true37:                                  ; preds = %if.end35
  %call38 = tail call i32 @isPausedActionsWithUpdate(i32 noundef 16) #38
  %tobool39.not = icmp eq i32 %call38, 0
  br i1 %tobool39.not, label %if.then40, label %if.end41

if.then40:                                        ; preds = %land.lhs.true37
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %argv.i)
  %12 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 58), align 8
  store ptr %12, ptr %argv.i, align 16
  %arrayidx1.i = getelementptr inbounds [3 x ptr], ptr %argv.i, i64 0, i64 1
  %13 = load <2 x ptr>, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 77), align 8
  store <2 x ptr> %13, ptr %arrayidx1.i, align 8
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  call void @replicationFeedSlaves(ptr noundef %14, i32 noundef -1, ptr noundef nonnull %argv.i, i32 noundef 3) #38
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %argv.i)
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 312), align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %land.lhs.true37, %if.end35
  call void @updateFailoverStatus() #38
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 331), align 8
  %len = getelementptr inbounds %struct.list, ptr %15, i64 0, i32 5
  %16 = load i64, ptr %len, align 8
  %cmp42 = icmp eq i64 %16, 0
  br i1 %cmp42, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end41
  call void @_serverAssert(ptr noundef nonnull @.str.29, ptr noundef nonnull @.str.9, i32 noundef 1778) #38
  call void @abort() #40
  unreachable

cond.end:                                         ; preds = %if.end41
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 332), align 8
  %len47 = getelementptr inbounds %struct.list, ptr %17, i64 0, i32 5
  %18 = load i64, ptr %len47, align 8
  %cmp48 = icmp eq i64 %18, 0
  br i1 %cmp48, label %cond.end58, label %cond.false57

cond.false57:                                     ; preds = %cond.end
  call void @_serverAssert(ptr noundef nonnull @.str.30, ptr noundef nonnull @.str.9, i32 noundef 1779) #38
  call void @abort() #40
  unreachable

cond.end58:                                       ; preds = %cond.end
  call void @trackingBroadcastInvalidationMessages() #38
  %19 = load ptr, ptr @getMonotonicUs, align 8
  %call59 = call i64 %19() #38
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %21 = add i32 %20, -1
  %or.cond1 = icmp ult i32 %21, 2
  br i1 %or.cond1, label %if.then65, label %if.end66

if.then65:                                        ; preds = %cond.end58
  call void @flushAppendOnlyFile(i32 noundef 0) #38
  br label %if.end66

if.end66:                                         ; preds = %cond.end58, %if.then65
  %22 = load ptr, ptr @getMonotonicUs, align 8
  %call67 = call i64 %22() #38
  %sub68 = sub i64 %call67, %call59
  call void @durationAddSample(i32 noundef 2, i64 noundef %sub68) #38
  %23 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp69 = icmp eq i32 %23, 1
  %24 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 265), align 8
  %cmp72 = icmp ne i64 %24, -1
  %or.cond2 = select i1 %cmp69, i1 %cmp72, i1 false
  br i1 %or.cond2, label %do.body, label %if.end75

do.body:                                          ; preds = %if.end66
  %25 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 264) monotonic, align 8
  store i64 %25, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 265), align 8
  br label %if.end75

if.end75:                                         ; preds = %do.body, %if.end66
  %call76 = call i32 @handleClientsWithPendingWritesUsingThreads() #38
  %26 = load ptr, ptr @getMonotonicUs, align 8
  %call77 = call i64 %26() #38
  %call78 = call i32 @freeClientsInAsyncFreeQueue() #38
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 268), align 8
  %tobool79.not = icmp eq ptr %27, null
  br i1 %tobool79.not, label %if.end81, label %if.then80

if.then80:                                        ; preds = %if.end75
  call void @incrementalTrimReplicationBacklog(i64 noundef 640) #38
  br label %if.end81

if.end81:                                         ; preds = %if.then80, %if.end75
  call void @evictClients() #38
  %28 = load ptr, ptr @getMonotonicUs, align 8
  %call82 = call i64 %28() #38
  %29 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 151), align 8
  %cmp84.not = icmp eq i64 %29, 0
  br i1 %cmp84.not, label %if.end89, label %if.then86

if.then86:                                        ; preds = %if.end81
  %30 = load ptr, ptr @getMonotonicUs, align 8
  %call87 = call i64 %30() #38
  %31 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 151), align 8
  %sub88 = sub i64 %call87, %31
  call void @durationAddSample(i32 noundef 0, i64 noundef %sub88) #38
  br label %if.end89

if.end89:                                         ; preds = %if.then86, %if.end81
  %32 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 154), align 8
  %33 = add i64 %call26, %call77
  %sub = sub i64 %call59, %33
  %add90 = add i64 %sub, %call82
  %add91 = add i64 %add90, %32
  store i64 %add91, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 154), align 8
  call void @durationAddSample(i32 noundef 3, i64 noundef %add91) #38
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 154), align 8
  %34 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 89), align 8
  %35 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 152), align 8
  %cmp92 = icmp sgt i64 %34, %35
  br i1 %cmp92, label %if.then94, label %if.end100

if.then94:                                        ; preds = %if.end89
  %sub95 = sub nsw i64 %34, %35
  %36 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 153), align 8
  %cmp96 = icmp sgt i64 %sub95, %36
  br i1 %cmp96, label %if.then98, label %if.end100

if.then98:                                        ; preds = %if.then94
  store i64 %sub95, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 153), align 8
  br label %if.end100

if.end100:                                        ; preds = %if.then94, %if.then98, %if.end89
  %call101 = call i64 @moduleCount() #38
  %tobool102.not = icmp eq i64 %call101, 0
  br i1 %tobool102.not, label %if.end104, label %if.then103

if.then103:                                       ; preds = %if.end100
  call void @moduleReleaseGIL() #38
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %if.end100, %if.end11
  ret void
}

declare i32 @handleClientsWithPendingReadsUsingThreads() local_unnamed_addr #4

declare i32 @connTypeProcessPendingData() local_unnamed_addr #4

declare i32 @handleClientsWithPendingWrites() local_unnamed_addr #4

declare i32 @freeClientsInAsyncFreeQueue() local_unnamed_addr #4

declare void @aeSetDontWait(ptr noundef, i32 noundef) local_unnamed_addr #4

declare i32 @connTypeHasPendingData() local_unnamed_addr #4

declare void @clusterBeforeSleep() local_unnamed_addr #4

declare void @blockedBeforeSleep() local_unnamed_addr #4

declare i32 @isPausedActionsWithUpdate(i32 noundef) local_unnamed_addr #4

declare void @updateFailoverStatus() local_unnamed_addr #4

declare void @trackingBroadcastInvalidationMessages() local_unnamed_addr #4

declare void @durationAddSample(i32 noundef, i64 noundef) local_unnamed_addr #4

declare i32 @handleClientsWithPendingWritesUsingThreads() local_unnamed_addr #4

declare void @incrementalTrimReplicationBacklog(i64 noundef) local_unnamed_addr #4

declare void @evictClients() local_unnamed_addr #4

declare void @moduleReleaseGIL() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @afterSleep(ptr nocapture readnone %eventLoop) #0 {
entry:
  %tm.i.i = alloca %struct.tm, align 8
  %ut.i.i = alloca i64, align 8
  %tv.i.i9 = alloca %struct.timeval, align 8
  %tv.i.i3 = alloca %struct.timeval, align 8
  %tv.i.i = alloca %struct.timeval, align 8
  %0 = load i32, ptr @ProcessingEventsWhileBlocked, align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.then, label %if.end15

if.then:                                          ; preds = %entry
  %call = tail call i64 @moduleCount() #38
  %tobool1.not = icmp eq i64 %call, 0
  br i1 %tobool1.not, label %if.end13, label %if.then2

if.then2:                                         ; preds = %if.then
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %tobool3.not = icmp eq i64 %1, 0
  br i1 %tobool3.not, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then2
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i)
  %call.i.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i, ptr noundef null) #38
  %2 = load i64, ptr %tv.i.i, align 8
  %mul.i.i = mul nsw i64 %2, 1000000
  %tv_usec.i.i = getelementptr inbounds %struct.timeval, ptr %tv.i.i, i64 0, i32 1
  %3 = load i64, ptr %tv_usec.i.i, align 8
  %add.i.i = add nsw i64 %mul.i.i, %3
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i)
  %div.i.neg = sdiv i64 %add.i.i, -1000
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then4
  %latency.0.neg = phi i64 [ %div.i.neg, %if.then4 ], [ 0, %if.then2 ]
  tail call void @moduleAcquireGIL() #38
  tail call void @moduleFireServerEvent(i64 noundef 15, i32 noundef 1, ptr noundef null) #38
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %tobool6.not = icmp eq i64 %4, 0
  br i1 %tobool6.not, label %if.end13, label %if.end9

if.end9:                                          ; preds = %if.end
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i3)
  %call.i.i4 = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i3, ptr noundef null) #38
  %5 = load i64, ptr %tv.i.i3, align 8
  %mul.i.i5 = mul nsw i64 %5, 1000000
  %tv_usec.i.i6 = getelementptr inbounds %struct.timeval, ptr %tv.i.i3, i64 0, i32 1
  %6 = load i64, ptr %tv_usec.i.i6, align 8
  %add.i.i7 = add nsw i64 %mul.i.i5, %6
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i3)
  %div.i8 = sdiv i64 %add.i.i7, 1000
  %sub = add i64 %latency.0.neg, %div.i8
  %.pre = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %tobool10.not = icmp eq i64 %.pre, 0
  %cmp.not = icmp slt i64 %sub, %.pre
  %or.cond = select i1 %tobool10.not, i1 true, i1 %cmp.not
  br i1 %or.cond, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end9
  tail call void @latencyAddSample(ptr noundef nonnull @.str.31, i64 noundef %sub) #38
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.end9, %if.then11, %if.then
  %7 = load ptr, ptr @getMonotonicUs, align 8
  %call14 = tail call i64 %7() #38
  store i64 %call14, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 151), align 8
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 89), align 8
  store i64 %8, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 152), align 8
  br label %if.end15

if.end15:                                         ; preds = %if.end13, %entry
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i9)
  %call.i.i10 = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i9, ptr noundef null) #38
  %9 = load i64, ptr %tv.i.i9, align 8
  %mul.i.i11 = mul nsw i64 %9, 1000000
  %tv_usec.i.i12 = getelementptr inbounds %struct.timeval, ptr %tv.i.i9, i64 0, i32 1
  %10 = load i64, ptr %tv_usec.i.i12, align 8
  %add.i.i13 = add nsw i64 %mul.i.i11, %10
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i9)
  call void @llvm.lifetime.start.p0(i64 56, ptr nonnull %tm.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ut.i.i)
  store i64 %add.i.i13, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %div.i.i = sdiv i64 %add.i.i13, 1000
  store i64 %div.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %div1.i.i = sdiv i64 %add.i.i13, 1000000
  store atomic i64 %div1.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) monotonic, align 8
  %atomic-load.i.i = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  store i64 %atomic-load.i.i, ptr %ut.i.i, align 8
  %call.i1.i = call ptr @localtime_r(ptr noundef nonnull %ut.i.i, ptr noundef nonnull %tm.i.i) #38
  %tm_isdst.i.i = getelementptr inbounds %struct.tm, ptr %tm.i.i, i64 0, i32 8
  %11 = load i32, ptr %tm_isdst.i.i, align 8
  store i32 %11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 351), align 8
  call void @llvm.lifetime.end.p0(i64 56, ptr nonnull %tm.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ut.i.i)
  %12 = load i32, ptr @ProcessingEventsWhileBlocked, align 4
  %tobool16.not = icmp eq i32 %12, 0
  br i1 %tobool16.not, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  store i64 %13, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 354), align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  ret void
}

declare void @moduleAcquireGIL() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @createSharedObjects() local_unnamed_addr #0 {
entry:
  %dictid_str = alloca [64 x i8], align 16
  %call = tail call ptr @sdsnew(ptr noundef nonnull @.str.32) #38
  %call1 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call) #38
  store ptr %call1, ptr @shared, align 8
  %call2 = tail call ptr @sdsnew(ptr noundef nonnull @.str.33) #38
  %call3 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call2) #38
  store ptr %call3, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 2), align 8
  %call4 = tail call ptr @sdsnew(ptr noundef nonnull @.str.34) #38
  %call5 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call4) #38
  store ptr %call5, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 3), align 8
  %call6 = tail call ptr @sdsnew(ptr noundef nonnull @.str.35) #38
  %call7 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call6) #38
  store ptr %call7, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 4), align 8
  %call8 = tail call ptr @sdsnew(ptr noundef nonnull @.str.36) #38
  %call9 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call8) #38
  store ptr %call9, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 12), align 8
  %call10 = tail call ptr @sdsnew(ptr noundef nonnull @.str.37) #38
  %call11 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call10) #38
  store ptr %call11, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 5), align 8
  %call12 = tail call ptr @sdsnew(ptr noundef nonnull @.str.38) #38
  %call13 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call12) #38
  store ptr %call13, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 7), align 8
  %call14 = tail call ptr @sdsnew(ptr noundef nonnull @.str.39) #38
  %call15 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call14) #38
  store ptr %call15, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 48), align 8
  %call16 = tail call ptr @sdsnew(ptr noundef nonnull @.str.40) #38
  %call17 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call16) #38
  store ptr %call17, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 6), align 8
  %call18 = tail call ptr @sdsnew(ptr noundef nonnull @.str.41) #38
  %call19 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call18) #38
  store ptr %call19, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 31), align 8
  %call20 = tail call ptr @sdsnew(ptr noundef nonnull @.str.42) #38
  %call21 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call20) #38
  store ptr %call21, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 13), align 8
  %call22 = tail call ptr @sdsnew(ptr noundef nonnull @.str.43) #38
  %call23 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call22) #38
  store ptr %call23, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 1), align 8
  %call24 = tail call ptr @sdsnew(ptr noundef nonnull @.str.44) #38
  %call25 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call24) #38
  store ptr %call25, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 14), align 8
  %call26 = tail call ptr @sdsnew(ptr noundef nonnull @.str.45) #38
  %call27 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call26) #38
  store ptr %call27, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 15), align 8
  %call28 = tail call ptr @sdsnew(ptr noundef nonnull @.str.46) #38
  %call29 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call28) #38
  store ptr %call29, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 16), align 8
  %call30 = tail call ptr @sdsnew(ptr noundef nonnull @.str.47) #38
  %call31 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call30) #38
  store ptr %call31, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 17), align 8
  %call32 = tail call ptr @sdsnew(ptr noundef nonnull @.str.48) #38
  %call33 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call32) #38
  store ptr %call33, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 18), align 8
  %call34 = tail call ptr @sdsnew(ptr noundef nonnull @.str.49) #38
  %call35 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call34) #38
  store ptr %call35, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 19), align 8
  %call36 = tail call ptr @sdsnew(ptr noundef nonnull @.str.50) #38
  %call37 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call36) #38
  store ptr %call37, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 20), align 8
  %call38 = tail call ptr @sdsnew(ptr noundef nonnull @.str.51) #38
  %call39 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call38) #38
  store ptr %call39, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 21), align 8
  %call40 = tail call ptr @sdsnew(ptr noundef nonnull @.str.52) #38
  %call41 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call40) #38
  store ptr %call41, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 22), align 8
  %call42 = tail call ptr @sdsnew(ptr noundef nonnull @.str.53) #38
  %call43 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call42) #38
  store ptr %call43, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 24), align 8
  %call44 = tail call ptr @sdsnew(ptr noundef nonnull @.str.54) #38
  %call45 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call44) #38
  store ptr %call45, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 23), align 8
  %call46 = tail call ptr @sdsnew(ptr noundef nonnull @.str.55) #38
  %call47 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call46) #38
  store ptr %call47, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 25), align 8
  %call48 = tail call ptr @sdsnew(ptr noundef nonnull @.str.56) #38
  %call49 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call48) #38
  store ptr %call49, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 27), align 8
  %call50 = tail call ptr @sdsnew(ptr noundef nonnull @.str.57) #38
  %call51 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call50) #38
  store ptr %call51, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 30), align 8
  %call52 = tail call ptr @sdsnew(ptr noundef nonnull @.str.58) #38
  %call53 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call52) #38
  store ptr %call53, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 26), align 8
  %call54 = tail call ptr @sdsnew(ptr noundef nonnull @.str.59) #38
  %call55 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call54) #38
  store ptr %call55, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 28), align 8
  %call56 = tail call ptr @sdsnew(ptr noundef nonnull @.str.60) #38
  %call57 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call56) #38
  store ptr %call57, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 29), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 8), i8 0, i64 16, i1 false)
  %call58 = tail call ptr @sdsnew(ptr noundef nonnull @.str.61) #38
  %call59 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call58) #38
  store ptr %call59, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 8, i64 2), align 8
  %call60 = tail call ptr @sdsnew(ptr noundef nonnull @.str.62) #38
  %call61 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call60) #38
  store ptr %call61, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 8, i64 3), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 9), i8 0, i64 16, i1 false)
  %call62 = tail call ptr @sdsnew(ptr noundef nonnull @.str.63) #38
  %call63 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call62) #38
  store ptr %call63, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 9, i64 2), align 8
  %call64 = tail call ptr @sdsnew(ptr noundef nonnull @.str.62) #38
  %call65 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call64) #38
  store ptr %call65, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 9, i64 3), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 10), i8 0, i64 16, i1 false)
  %call66 = tail call ptr @sdsnew(ptr noundef nonnull @.str.36) #38
  %call67 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call66) #38
  store ptr %call67, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 10, i64 2), align 8
  %call68 = tail call ptr @sdsnew(ptr noundef nonnull @.str.64) #38
  %call69 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call68) #38
  store ptr %call69, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 10, i64 3), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 11), i8 0, i64 16, i1 false)
  %call70 = tail call ptr @sdsnew(ptr noundef nonnull @.str.36) #38
  %call71 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call70) #38
  store ptr %call71, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 11, i64 2), align 8
  %call72 = tail call ptr @sdsnew(ptr noundef nonnull @.str.65) #38
  %call73 = tail call ptr @createObject(i32 noundef 0, ptr noundef %call72) #38
  store ptr %call73, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 11, i64 3), align 8
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %call74 = call i32 @ll2string(ptr noundef nonnull %dictid_str, i64 noundef 64, i64 noundef %indvars.iv) #38
  %call75 = call ptr @sdsempty() #38
  %call77 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call75, ptr noundef nonnull @.str.66, i32 noundef %call74, ptr noundef nonnull %dictid_str) #38
  %call78 = call ptr @createObject(i32 noundef 0, ptr noundef %call77) #38
  %arrayidx = getelementptr inbounds %struct.sharedObjectsStruct, ptr @shared, i64 0, i32 85, i64 %indvars.iv
  store ptr %call78, ptr %arrayidx, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 10
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !22

for.end:                                          ; preds = %for.body
  %call79 = call ptr @createStringObject(ptr noundef nonnull @.str.67, i64 noundef 13) #38
  store ptr %call79, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 32), align 8
  %call80 = call ptr @createStringObject(ptr noundef nonnull @.str.68, i64 noundef 14) #38
  store ptr %call80, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 33), align 8
  %call81 = call ptr @createStringObject(ptr noundef nonnull @.str.69, i64 noundef 15) #38
  store ptr %call81, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 34), align 8
  %call82 = call ptr @createStringObject(ptr noundef nonnull @.str.70, i64 noundef 18) #38
  store ptr %call82, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 35), align 8
  %call83 = call ptr @createStringObject(ptr noundef nonnull @.str.71, i64 noundef 17) #38
  store ptr %call83, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 82), align 8
  %call84 = call ptr @createStringObject(ptr noundef nonnull @.str.72, i64 noundef 19) #38
  store ptr %call84, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 83), align 8
  %call85 = call ptr @createStringObject(ptr noundef nonnull @.str.73, i64 noundef 14) #38
  store ptr %call85, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 84), align 8
  %call86 = call ptr @createStringObject(ptr noundef nonnull @.str.74, i64 noundef 17) #38
  store ptr %call86, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 36), align 8
  %call87 = call ptr @createStringObject(ptr noundef nonnull @.str.75, i64 noundef 19) #38
  store ptr %call87, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 37), align 8
  %call88 = call ptr @createStringObject(ptr noundef nonnull @.str.76, i64 noundef 3) #38
  store ptr %call88, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 38), align 8
  %call89 = call ptr @createStringObject(ptr noundef nonnull @.str.77, i64 noundef 6) #38
  store ptr %call89, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 39), align 8
  %call90 = call ptr @createStringObject(ptr noundef nonnull @.str.78, i64 noundef 4) #38
  store ptr %call90, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 40), align 8
  %call91 = call ptr @createStringObject(ptr noundef nonnull @.str.79, i64 noundef 4) #38
  store ptr %call91, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 41), align 8
  %call92 = call ptr @createStringObject(ptr noundef nonnull @.str.80, i64 noundef 5) #38
  store ptr %call92, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 42), align 8
  %call93 = call ptr @createStringObject(ptr noundef nonnull @.str.81, i64 noundef 9) #38
  store ptr %call93, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 43), align 8
  %call94 = call ptr @createStringObject(ptr noundef nonnull @.str.82, i64 noundef 5) #38
  store ptr %call94, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 44), align 8
  %call95 = call ptr @createStringObject(ptr noundef nonnull @.str.83, i64 noundef 6) #38
  store ptr %call95, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 45), align 8
  %call96 = call ptr @createStringObject(ptr noundef nonnull @.str.84, i64 noundef 7) #38
  store ptr %call96, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 46), align 8
  %call97 = call ptr @createStringObject(ptr noundef nonnull @.str.85, i64 noundef 7) #38
  store ptr %call97, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 47), align 8
  %call98 = call ptr @createStringObject(ptr noundef nonnull @.str.86, i64 noundef 5) #38
  store ptr %call98, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 49), align 8
  %call99 = call ptr @createStringObject(ptr noundef nonnull @.str.87, i64 noundef 4) #38
  store ptr %call99, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 50), align 8
  %call100 = call ptr @createStringObject(ptr noundef nonnull @.str.88, i64 noundef 4) #38
  store ptr %call100, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 53), align 8
  %call101 = call ptr @createStringObject(ptr noundef nonnull @.str.89, i64 noundef 4) #38
  store ptr %call101, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 54), align 8
  %call102 = call ptr @createStringObject(ptr noundef nonnull @.str.90, i64 noundef 6) #38
  store ptr %call102, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 55), align 8
  %call103 = call ptr @createStringObject(ptr noundef nonnull @.str.91, i64 noundef 6) #38
  store ptr %call103, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 56), align 8
  %call104 = call ptr @createStringObject(ptr noundef nonnull @.str.92, i64 noundef 6) #38
  store ptr %call104, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 57), align 8
  %call105 = call ptr @createStringObject(ptr noundef nonnull @.str.93, i64 noundef 8) #38
  store ptr %call105, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 58), align 8
  %call106 = call ptr @createStringObject(ptr noundef nonnull @.str.94, i64 noundef 9) #38
  store ptr %call106, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 62), align 8
  %call107 = call ptr @createStringObject(ptr noundef nonnull @.str.95, i64 noundef 7) #38
  store ptr %call107, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 63), align 8
  %call108 = call ptr @createStringObject(ptr noundef nonnull @.str.96, i64 noundef 7) #38
  store ptr %call108, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 60), align 8
  %call109 = call ptr @createStringObject(ptr noundef nonnull @.str.97, i64 noundef 3) #38
  store ptr %call109, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 61), align 8
  %call110 = call ptr @createStringObject(ptr noundef nonnull @.str.98, i64 noundef 4) #38
  store ptr %call110, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 59), align 8
  %call111 = call ptr @createStringObject(ptr noundef nonnull @.str.99, i64 noundef 4) #38
  store ptr %call111, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 51), align 8
  %call112 = call ptr @createStringObject(ptr noundef nonnull @.str.100, i64 noundef 5) #38
  store ptr %call112, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 52), align 8
  %call113 = call ptr @createStringObject(ptr noundef nonnull @.str.101, i64 noundef 4) #38
  store ptr %call113, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 65), align 8
  %call114 = call ptr @createStringObject(ptr noundef nonnull @.str.102, i64 noundef 4) #38
  store ptr %call114, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 64), align 8
  %call115 = call ptr @createStringObject(ptr noundef nonnull @.str.103, i64 noundef 10) #38
  store ptr %call115, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 67), align 8
  %call116 = call ptr @createStringObject(ptr noundef nonnull @.str.104, i64 noundef 5) #38
  store ptr %call116, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 68), align 8
  %call117 = call ptr @createStringObject(ptr noundef nonnull @.str.105, i64 noundef 6) #38
  store ptr %call117, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 69), align 8
  %call118 = call ptr @createStringObject(ptr noundef nonnull @.str.106, i64 noundef 11) #38
  store ptr %call118, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 70), align 8
  %call119 = call ptr @createStringObject(ptr noundef nonnull @.str.107, i64 noundef 6) #38
  store ptr %call119, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 71), align 8
  %call120 = call ptr @createStringObject(ptr noundef nonnull @.str.108, i64 noundef 7) #38
  store ptr %call120, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 80), align 8
  %call121 = call ptr @createStringObject(ptr noundef nonnull @.str.109, i64 noundef 4) #38
  store ptr %call121, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 72), align 8
  %call122 = call ptr @createStringObject(ptr noundef nonnull @.str.110, i64 noundef 5) #38
  store ptr %call122, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 73), align 8
  %call123 = call ptr @createStringObject(ptr noundef nonnull @.str.111, i64 noundef 7) #38
  store ptr %call123, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 74), align 8
  %call124 = call ptr @createStringObject(ptr noundef nonnull @.str.112, i64 noundef 6) #38
  store ptr %call124, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 66), align 8
  %call125 = call ptr @createStringObject(ptr noundef nonnull @.str.113, i64 noundef 4) #38
  store ptr %call125, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 75), align 8
  %call126 = call ptr @createStringObject(ptr noundef nonnull @.str.114, i64 noundef 14) #38
  store ptr %call126, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 76), align 8
  %call127 = call ptr @createStringObject(ptr noundef nonnull @.str.115, i64 noundef 6) #38
  store ptr %call127, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 77), align 8
  %call128 = call ptr @createStringObject(ptr noundef nonnull @.str.116, i64 noundef 1) #38
  store ptr %call128, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 78), align 8
  %call129 = call ptr @createStringObject(ptr noundef nonnull @.str.117, i64 noundef 1) #38
  store ptr %call129, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 79), align 8
  %call130 = call ptr @createStringObject(ptr noundef nonnull @.str.118, i64 noundef 10) #38
  %call131 = call ptr @makeObjectShared(ptr noundef %call130) #38
  store ptr %call131, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 81), align 8
  br label %for.body135

for.body135:                                      ; preds = %for.end, %for.body135
  %indvars.iv24 = phi i64 [ 0, %for.end ], [ %indvars.iv.next25, %for.body135 ]
  %0 = inttoptr i64 %indvars.iv24 to ptr
  %call137 = call ptr @createObject(i32 noundef 0, ptr noundef %0) #38
  %call138 = call ptr @makeObjectShared(ptr noundef %call137) #38
  %arrayidx140 = getelementptr inbounds %struct.sharedObjectsStruct, ptr @shared, i64 0, i32 86, i64 %indvars.iv24
  store ptr %call138, ptr %arrayidx140, align 8
  call void @initObjectLRUOrLFU(ptr noundef %call138) #38
  %1 = load ptr, ptr %arrayidx140, align 8
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, -241
  %bf.set = or disjoint i32 %bf.clear, 16
  store i32 %bf.set, ptr %1, align 8
  %indvars.iv.next25 = add nuw nsw i64 %indvars.iv24, 1
  %exitcond27.not = icmp eq i64 %indvars.iv.next25, 10000
  br i1 %exitcond27.not, label %for.body151, label %for.body135, !llvm.loop !23

for.body151:                                      ; preds = %for.body135, %for.body151
  %indvars.iv28 = phi i64 [ %indvars.iv.next29, %for.body151 ], [ 0, %for.body135 ]
  %call152 = call ptr @sdsempty() #38
  %2 = trunc i64 %indvars.iv28 to i32
  %call153 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call152, ptr noundef nonnull @.str.119, i32 noundef %2) #38
  %call154 = call ptr @createObject(i32 noundef 0, ptr noundef %call153) #38
  %arrayidx156 = getelementptr inbounds %struct.sharedObjectsStruct, ptr @shared, i64 0, i32 87, i64 %indvars.iv28
  store ptr %call154, ptr %arrayidx156, align 8
  %call157 = call ptr @sdsempty() #38
  %call158 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call157, ptr noundef nonnull @.str.120, i32 noundef %2) #38
  %call159 = call ptr @createObject(i32 noundef 0, ptr noundef %call158) #38
  %arrayidx161 = getelementptr inbounds %struct.sharedObjectsStruct, ptr @shared, i64 0, i32 88, i64 %indvars.iv28
  store ptr %call159, ptr %arrayidx161, align 8
  %call162 = call ptr @sdsempty() #38
  %call163 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call162, ptr noundef nonnull @.str.121, i32 noundef %2) #38
  %call164 = call ptr @createObject(i32 noundef 0, ptr noundef %call163) #38
  %arrayidx166 = getelementptr inbounds %struct.sharedObjectsStruct, ptr @shared, i64 0, i32 89, i64 %indvars.iv28
  store ptr %call164, ptr %arrayidx166, align 8
  %call167 = call ptr @sdsempty() #38
  %call168 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call167, ptr noundef nonnull @.str.122, i32 noundef %2) #38
  %call169 = call ptr @createObject(i32 noundef 0, ptr noundef %call168) #38
  %arrayidx171 = getelementptr inbounds %struct.sharedObjectsStruct, ptr @shared, i64 0, i32 90, i64 %indvars.iv28
  store ptr %call169, ptr %arrayidx171, align 8
  %indvars.iv.next29 = add nuw nsw i64 %indvars.iv28, 1
  %exitcond31.not = icmp eq i64 %indvars.iv.next29, 32
  br i1 %exitcond31.not, label %for.end174, label %for.body151, !llvm.loop !24

for.end174:                                       ; preds = %for.body151
  %call175 = call ptr @sdsnew(ptr noundef nonnull @.str.123) #38
  store ptr %call175, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 91), align 8
  %call176 = call ptr @sdsnew(ptr noundef nonnull @.str.124) #38
  store ptr %call176, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 92), align 8
  ret void
}

declare ptr @createObject(i32 noundef, ptr noundef) local_unnamed_addr #4

declare ptr @sdsnew(ptr noundef) local_unnamed_addr #4

declare ptr @sdscatprintf(ptr noundef, ptr noundef, ...) local_unnamed_addr #4

declare ptr @sdsempty() local_unnamed_addr #4

declare ptr @createStringObject(ptr noundef, i64 noundef) local_unnamed_addr #4

declare ptr @makeObjectShared(ptr noundef) local_unnamed_addr #4

declare void @initObjectLRUOrLFU(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @initServerClientMemUsageBuckets() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %for.end

if.end:                                           ; preds = %entry
  %call = tail call noalias dereferenceable_or_null(304) ptr @zmalloc(i64 noundef 304) #42
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  br label %for.body

for.body:                                         ; preds = %if.end, %for.body
  %indvars.iv = phi i64 [ 0, %if.end ], [ %indvars.iv.next, %for.body ]
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %mem_usage_sum = getelementptr inbounds %struct.clientMemUsageBucket, ptr %1, i64 %indvars.iv, i32 1
  store i64 0, ptr %mem_usage_sum, align 8
  %call1 = tail call ptr @listCreate() #38
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %arrayidx3 = getelementptr inbounds %struct.clientMemUsageBucket, ptr %2, i64 %indvars.iv
  store ptr %call1, ptr %arrayidx3, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 19
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !25

for.end:                                          ; preds = %for.body, %entry
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @zmalloc(i64 noundef) local_unnamed_addr #23

declare ptr @listCreate() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @freeServerClientMemUsageBuckets() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %entry ]
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %arrayidx = getelementptr inbounds %struct.clientMemUsageBucket, ptr %1, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  tail call void @listRelease(ptr noundef %2) #38
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 19
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !26

for.end:                                          ; preds = %for.body
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  tail call void @zfree(ptr noundef %3) #38
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  br label %return

return:                                           ; preds = %entry, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @initServerConfig() local_unnamed_addr #0 {
entry:
  %tm.i.i = alloca %struct.tm, align 8
  %ut.i.i = alloca i64, align 8
  %tv.i.i = alloca %struct.timeval, align 8
  tail call void @initConfigValues() #38
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i)
  %call.i.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i, ptr noundef null) #38
  %0 = load i64, ptr %tv.i.i, align 8
  %mul.i.i = mul nsw i64 %0, 1000000
  %tv_usec.i.i = getelementptr inbounds %struct.timeval, ptr %tv.i.i, i64 0, i32 1
  %1 = load i64, ptr %tv_usec.i.i, align 8
  %add.i.i = add nsw i64 %mul.i.i, %1
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i)
  call void @llvm.lifetime.start.p0(i64 56, ptr nonnull %tm.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ut.i.i)
  store i64 %add.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %div.i.i = sdiv i64 %add.i.i, 1000
  store i64 %div.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %div1.i.i = sdiv i64 %add.i.i, 1000000
  store atomic i64 %div1.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) monotonic, align 8
  %atomic-load.i.i = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  store i64 %atomic-load.i.i, ptr %ut.i.i, align 8
  %call.i1.i = call ptr @localtime_r(ptr noundef nonnull %ut.i.i, ptr noundef nonnull %tm.i.i) #38
  %tm_isdst.i.i = getelementptr inbounds %struct.tm, ptr %tm.i.i, i64 0, i32 8
  %2 = load i32, ptr %tm_isdst.i.i, align 8
  store i32 %2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 351), align 8
  call void @llvm.lifetime.end.p0(i64 56, ptr nonnull %tm.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ut.i.i)
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  store i64 %3, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 354), align 8
  call void @getRandomHexChars(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 26), i64 noundef 40) #38
  store i8 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 26, i64 40), align 8
  call void @changeReplicationId() #38
  call void @clearReplicationId2() #38
  store i32 10, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %call = call i64 @getTimeZone() #38
  store i64 %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 350), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 2), i8 0, i64 16, i1 false)
  store i32 64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 24), align 8
  store i32 2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 48), align 8
  %call1 = call noalias ptr @zstrdup(ptr noundef nonnull @.str.116) #38
  store ptr %call1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 47, i64 0), align 8
  %call1.c = call noalias ptr @zstrdup(ptr noundef nonnull @.str.125) #38
  store ptr %call1.c, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 47, i64 1), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(832) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 52), i8 0, i64 832, i1 false)
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 159), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 161), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 164), align 8
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 82), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 84), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 192), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 197), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 196), align 8
  %call4 = call i64 @time(ptr noundef null) #38
  store i64 %call4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 202), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 205), align 8
  store atomic i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 215) monotonic, align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 203), i8 -1, i64 16, i1 false)
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 207), align 4
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 208), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 199), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 200), align 4
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 201), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 22), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 359), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 194), i8 0, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 4 dereferenceable(40) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 325), i8 0, i64 40, i1 false)
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 20), align 4
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 18), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  %call5 = call ptr @dictCreate(ptr noundef nonnull @migrateCacheDictType) #38
  store ptr %call5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 71), align 8
  store atomic i64 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 72) seq_cst, align 8
  %call6 = call i64 @sysconf(i32 noundef 30) #38
  store i64 %call6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 36), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 180), align 8
  store i32 3, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 183), align 8
  %call7 = call noalias dereferenceable_or_null(24) ptr @zmalloc(i64 noundef 24) #42
  store ptr %call7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 182), align 8
  store <2 x double> <double 5.000000e+01, double 9.900000e+01>, ptr %call7, align 8
  %arrayidx10 = getelementptr inbounds double, ptr %call7, i64 2
  store double 9.990000e+01, ptr %arrayidx10, align 8
  %call11 = call i32 @getLRUClock() #38
  store i32 %call11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 16), align 8
  call void @resetServerSaveParams() #38
  call void @appendServerSaveParams(i64 noundef 3600, i32 noundef 1) #38
  call void @appendServerSaveParams(i64 noundef 300, i32 noundef 100) #38
  call void @appendServerSaveParams(i64 noundef 60, i32 noundef 10000) #38
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  store i32 6379, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 284), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 286), i8 0, i64 16, i1 false)
  store i64 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 309), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 295), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 294), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 293), align 8
  store i32 5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 288), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 300), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 264) seq_cst, align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 268), align 8
  %call12 = call i64 @time(ptr noundef null) #38
  store i64 %call12, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 271), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 411), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 412), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 413), i8 0, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(72) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 179, i64 0, i32 0), ptr noundef nonnull align 16 dereferenceable(72) @clientBufferLimitsDefaults, i64 72, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(12) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 322, i64 0), ptr noundef nonnull align 4 dereferenceable(12) @configOOMScoreAdjValuesDefaults, i64 12, i1 false)
  store double 0.000000e+00, ptr @R_Zero, align 8
  store double 0x7FF0000000000000, ptr @R_PosInf, align 8
  store double 0xFFF0000000000000, ptr @R_NegInf, align 8
  store double 0x7FF8000000000000, ptr @R_Nan, align 8
  %call37 = call ptr @dictCreate(ptr noundef nonnull @commandTableDictType) #38
  store ptr %call37, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call38 = call ptr @dictCreate(ptr noundef nonnull @commandTableDictType) #38
  store ptr %call38, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 13), align 8
  call void @populateCommandTable()
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 400), align 8
  ret void
}

declare void @initConfigValues() local_unnamed_addr #4

declare void @getRandomHexChars(ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @changeReplicationId() local_unnamed_addr #4

declare void @clearReplicationId2() local_unnamed_addr #4

declare i64 @getTimeZone() local_unnamed_addr #4

declare noalias ptr @zstrdup(ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #24

declare ptr @dictCreate(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare i64 @sysconf(i32 noundef) local_unnamed_addr #3

declare void @resetServerSaveParams() local_unnamed_addr #4

declare void @appendServerSaveParams(i64 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @populateCommandTable() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @redisCommandTable, align 8
  %cmp9 = icmp eq ptr %0, null
  br i1 %cmp9, label %for.end, label %if.end

if.end:                                           ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %1 = phi ptr [ %7, %for.inc ], [ %0, %entry ]
  %add.ptr12 = phi ptr [ %add.ptr, %for.inc ], [ @redisCommandTable, %entry ]
  %call = tail call ptr @sdsnew(ptr noundef nonnull %1) #38
  %fullname = getelementptr inbounds %struct.redisCommand, ptr @redisCommandTable, i64 %indvars.iv, i32 27
  store ptr %call, ptr %fullname, align 8
  %call2 = tail call i32 @populateCommandStructure(ptr noundef nonnull %add.ptr12), !range !16
  %cmp3 = icmp eq i32 %call2, -1
  br i1 %cmp3, label %for.inc, label %if.end5

if.end5:                                          ; preds = %if.end
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %3 = load ptr, ptr %fullname, align 8
  %call7 = tail call ptr @sdsdup(ptr noundef %3) #38
  %call8 = tail call i32 @dictAdd(ptr noundef %2, ptr noundef %call7, ptr noundef nonnull %add.ptr12) #38
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 13), align 8
  %5 = load ptr, ptr %fullname, align 8
  %call10 = tail call ptr @sdsdup(ptr noundef %5) #38
  %call11 = tail call i32 @dictAdd(ptr noundef %4, ptr noundef %call10, ptr noundef nonnull %add.ptr12) #38
  %cmp12 = icmp eq i32 %call8, 0
  %cmp13 = icmp eq i32 %call11, 0
  %6 = select i1 %cmp12, i1 %cmp13, i1 false
  br i1 %6, label %for.inc, label %cond.false

cond.false:                                       ; preds = %if.end5
  tail call void @_serverAssert(ptr noundef nonnull @.str.163, ptr noundef nonnull @.str.9, i32 noundef 3133) #38
  tail call void @abort() #40
  unreachable

for.inc:                                          ; preds = %if.end5, %if.end
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  %add.ptr = getelementptr inbounds %struct.redisCommand, ptr @redisCommandTable, i64 %indvars.iv.next
  %7 = load ptr, ptr %add.ptr, align 8
  %cmp = icmp eq ptr %7, null
  br i1 %cmp, label %for.end, label %if.end

for.end:                                          ; preds = %for.inc, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @restartServer(i32 noundef %flags, i64 noundef %delay) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 3), align 8
  %call = tail call i32 @access(ptr noundef %0, i32 noundef 1) #38
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %do.body, label %if.end3

do.body:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %1, 3
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %do.body
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 3), align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.126, ptr noundef %2)
  br label %return

if.end3:                                          ; preds = %entry
  %and = and i32 %flags, 2
  %tobool = icmp ne i32 %and, 0
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 2), align 8
  %tobool4 = icmp ne ptr %3, null
  %or.cond = select i1 %tobool, i1 %tobool4, i1 false
  br i1 %or.cond, label %land.lhs.true5, label %if.end16

land.lhs.true5:                                   ; preds = %if.end3
  %call6 = tail call i32 @rewriteConfig(ptr noundef nonnull %3, i32 noundef 0) #38
  %cmp7 = icmp eq i32 %call6, -1
  br i1 %cmp7, label %do.body9, label %if.end16

do.body9:                                         ; preds = %land.lhs.true5
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp10 = icmp sgt i32 %4, 3
  br i1 %cmp10, label %return, label %if.end12

if.end12:                                         ; preds = %do.body9
  %call13 = tail call ptr @__errno_location() #41
  %5 = load i32, ptr %call13, align 4
  %call14 = tail call ptr @strerror(i32 noundef %5) #38
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.127, ptr noundef %call14)
  br label %return

if.end16:                                         ; preds = %land.lhs.true5, %if.end3
  %and17 = and i32 %flags, 1
  %tobool18.not = icmp eq i32 %and17, 0
  br i1 %tobool18.not, label %if.end28, label %land.lhs.true19

land.lhs.true19:                                  ; preds = %if.end16
  %call20 = tail call i32 @prepareForShutdown(i32 noundef 4), !range !16
  %cmp21.not = icmp eq i32 %call20, 0
  br i1 %cmp21.not, label %if.end28, label %do.body23

do.body23:                                        ; preds = %land.lhs.true19
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp24 = icmp sgt i32 %6, 3
  br i1 %cmp24, label %return, label %if.end26

if.end26:                                         ; preds = %do.body23
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.128)
  br label %return

if.end28:                                         ; preds = %land.lhs.true19, %if.end16
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  %cmp297 = icmp sgt i32 %7, -1021
  br i1 %cmp297, label %for.body, label %for.end

for.body:                                         ; preds = %if.end28, %for.inc
  %j.08 = phi i32 [ %inc, %for.inc ], [ 3, %if.end28 ]
  %call30 = tail call i32 (i32, i32, ...) @fcntl64(i32 noundef %j.08, i32 noundef 1) #38
  %cmp31.not = icmp eq i32 %call30, -1
  br i1 %cmp31.not, label %for.inc, label %if.then32

if.then32:                                        ; preds = %for.body
  %call33 = tail call i32 @close(i32 noundef %j.08) #38
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then32
  %inc = add nuw nsw i32 %j.08, 1
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  %9 = add nsw i32 %8, 1023
  %cmp29 = icmp slt i32 %j.08, %9
  br i1 %cmp29, label %for.body, label %for.end, !llvm.loop !27

for.end:                                          ; preds = %for.inc, %if.end28
  %tobool35.not = icmp eq i64 %delay, 0
  br i1 %tobool35.not, label %if.end38, label %if.then36

if.then36:                                        ; preds = %for.end
  %10 = trunc i64 %delay to i32
  %conv = mul i32 %10, 1000
  %call37 = tail call i32 @usleep(i32 noundef %conv) #38
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %for.end
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %12 = load ptr, ptr %11, align 8
  tail call void @zfree(ptr noundef %12) #38
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 3), align 8
  %call39 = tail call noalias ptr @zstrdup(ptr noundef %13) #38
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  store ptr %call39, ptr %14, align 8
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 3), align 8
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %17 = load ptr, ptr @environ, align 8
  %call41 = tail call i32 @execve(ptr noundef %15, ptr noundef %16, ptr noundef %17) #38
  tail call void @_exit(i32 noundef 1) #40
  unreachable

return:                                           ; preds = %if.end26, %do.body23, %if.end12, %do.body9, %if.end, %do.body
  ret i32 -1
}

; Function Attrs: nofree nounwind
declare noundef i32 @access(ptr nocapture noundef readonly, i32 noundef) local_unnamed_addr #2

declare i32 @rewriteConfig(ptr noundef, i32 noundef) local_unnamed_addr #4

declare i32 @fcntl64(i32 noundef, i32 noundef, ...) local_unnamed_addr #4

declare i32 @usleep(i32 noundef) local_unnamed_addr #4

; Function Attrs: nofree nounwind
declare i32 @execve(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #2

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @setOOMScoreAdj(i32 noundef %process_class) local_unnamed_addr #0 {
entry:
  %buf = alloca [64 x i8], align 16
  %cmp = icmp eq i32 %process_class, -1
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %tobool.not = icmp ne ptr %0, null
  %cond = zext i1 %tobool.not to i32
  %process_class.addr.0 = select i1 %cmp, i32 %cond, i32 %process_class
  %1 = icmp ult i32 %process_class.addr.0, 3
  br i1 %1, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.129, ptr noundef nonnull @.str.9, i32 noundef 2278) #38
  tail call void @abort() #40
  unreachable

cond.end:                                         ; preds = %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 323), align 4
  %cmp5.not = icmp eq i32 %2, 0
  %.b = load i1, ptr @setOOMScoreAdj.oom_score_adjusted_by_redis, align 4
  br i1 %cmp5.not, label %if.else, label %if.then7

if.then7:                                         ; preds = %cond.end
  br i1 %.b, label %if.end31, label %if.then9

if.then9:                                         ; preds = %if.then7
  store i1 true, ptr @setOOMScoreAdj.oom_score_adjusted_by_redis, align 4
  %call = tail call i32 (ptr, i32, ...) @open64(ptr noundef nonnull @.str.130, i32 noundef 0) #38
  %cmp10 = icmp slt i32 %call, 0
  br i1 %cmp10, label %do.body, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then9
  %call12 = call i64 @read(i32 noundef %call, ptr noundef nonnull %buf, i64 noundef 64) #38
  %cmp13 = icmp slt i64 %call12, 0
  br i1 %cmp13, label %do.body, label %if.end27

do.body:                                          ; preds = %if.then9, %lor.lhs.false
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp16 = icmp sgt i32 %3, 3
  br i1 %cmp16, label %do.end, label %if.end19

if.end19:                                         ; preds = %do.body
  %call20 = tail call ptr @__errno_location() #41
  %4 = load i32, ptr %call20, align 4
  %call21 = tail call ptr @strerror(i32 noundef %4) #38
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.131, ptr noundef %call21)
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end19
  %cmp22.not = icmp eq i32 %call, -1
  br i1 %cmp22.not, label %return, label %return.sink.split

if.end27:                                         ; preds = %lor.lhs.false
  %call29 = call i32 @atoi(ptr nocapture noundef nonnull %buf) #39
  store i32 %call29, ptr @setOOMScoreAdj.oom_score_adj_base, align 4
  %call30 = tail call i32 @close(i32 noundef %call) #38
  %.pre = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 323), align 4
  br label %if.end31

if.end31:                                         ; preds = %if.end27, %if.then7
  %5 = phi i32 [ %.pre, %if.end27 ], [ %2, %if.then7 ]
  %idxprom = zext nneg i32 %process_class.addr.0 to i64
  %arrayidx = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 322, i64 %idxprom
  %6 = load i32, ptr %arrayidx, align 4
  %cmp32 = icmp eq i32 %5, 1
  %7 = load i32, ptr @setOOMScoreAdj.oom_score_adj_base, align 4
  %add = select i1 %cmp32, i32 %7, i32 0
  %val.0 = add nsw i32 %add, %6
  %spec.store.select = tail call i32 @llvm.smin.i32(i32 %val.0, i32 1000)
  %spec.store.select1 = tail call i32 @llvm.smax.i32(i32 %spec.store.select, i32 -1000)
  br label %if.end48

if.else:                                          ; preds = %cond.end
  br i1 %.b, label %if.then45, label %return

if.then45:                                        ; preds = %if.else
  store i1 false, ptr @setOOMScoreAdj.oom_score_adjusted_by_redis, align 4
  %8 = load i32, ptr @setOOMScoreAdj.oom_score_adj_base, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.end31, %if.then45
  %val.1 = phi i32 [ %spec.store.select1, %if.end31 ], [ %8, %if.then45 ]
  %call50 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %buf, i64 noundef 63, ptr noundef nonnull @.str.132, i32 noundef %val.1) #38
  %call51 = tail call i32 (ptr, i32, ...) @open64(ptr noundef nonnull @.str.130, i32 noundef 1) #38
  %cmp52 = icmp slt i32 %call51, 0
  br i1 %cmp52, label %do.body62, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %if.end48
  %call57 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %buf) #39
  %call58 = call i64 @write(i32 noundef %call51, ptr noundef nonnull %buf, i64 noundef %call57) #38
  %cmp59 = icmp slt i64 %call58, 0
  br i1 %cmp59, label %do.body62, label %return.sink.split

do.body62:                                        ; preds = %if.end48, %lor.lhs.false54
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp63 = icmp sgt i32 %9, 3
  br i1 %cmp63, label %do.end69, label %if.end66

if.end66:                                         ; preds = %do.body62
  %call67 = tail call ptr @__errno_location() #41
  %10 = load i32, ptr %call67, align 4
  %call68 = tail call ptr @strerror(i32 noundef %10) #38
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.133, ptr noundef %call68)
  br label %do.end69

do.end69:                                         ; preds = %do.body62, %if.end66
  %cmp70.not = icmp eq i32 %call51, -1
  br i1 %cmp70.not, label %return, label %return.sink.split

return.sink.split:                                ; preds = %lor.lhs.false54, %do.end69, %do.end
  %call51.sink = phi i32 [ %call, %do.end ], [ %call51, %do.end69 ], [ %call51, %lor.lhs.false54 ]
  %retval.0.ph = phi i32 [ -1, %do.end ], [ -1, %do.end69 ], [ 0, %lor.lhs.false54 ]
  %call73 = tail call i32 @close(i32 noundef %call51.sink) #38
  br label %return

return:                                           ; preds = %return.sink.split, %do.end69, %if.else, %do.end
  %retval.0 = phi i32 [ -1, %do.end ], [ 0, %if.else ], [ -1, %do.end69 ], [ %retval.0.ph, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nofree
declare noundef i64 @read(i32 noundef, ptr nocapture noundef, i64 noundef) local_unnamed_addr #6

; Function Attrs: mustprogress nofree nounwind willreturn memory(read)
declare i32 @atoi(ptr nocapture noundef) local_unnamed_addr #15

; Function Attrs: nounwind uwtable
define dso_local void @adjustOpenFilesLimit() local_unnamed_addr #0 {
entry:
  %limit = alloca %struct.rlimit, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  %add = add i32 %0, 32
  %conv = zext i32 %add to i64
  %call = call i32 @getrlimit64(i32 noundef 7, ptr noundef nonnull %limit) #38
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %do.body, label %if.else

do.body:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2 = icmp sgt i32 %1, 3
  br i1 %cmp2, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %call5 = tail call ptr @__errno_location() #41
  %2 = load i32, ptr %call5, align 4
  %call6 = call ptr @strerror(i32 noundef %2) #38
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.134, ptr noundef %call6)
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  store i32 992, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  br label %if.end70

if.else:                                          ; preds = %entry
  %3 = load i64, ptr %limit, align 8
  %cmp7 = icmp ult i64 %3, %conv
  br i1 %cmp7, label %while.cond.preheader, label %if.end70

while.cond.preheader:                             ; preds = %if.else
  %rlim_max = getelementptr inbounds %struct.rlimit, ptr %limit, i64 0, i32 1
  store i64 %conv, ptr %limit, align 8
  store i64 %conv, ptr %rlim_max, align 8
  %call1328 = call i32 @setrlimit64(i32 noundef 7, ptr noundef nonnull %limit) #38
  %cmp14.not29 = icmp eq i32 %call1328, -1
  br i1 %cmp14.not29, label %if.end17.preheader, label %while.end

if.end17.preheader:                               ; preds = %while.cond.preheader
  %call18 = tail call ptr @__errno_location() #41
  br label %if.end17

while.body:                                       ; preds = %if.end22
  store i64 %sub, ptr %limit, align 8
  store i64 %sub, ptr %rlim_max, align 8
  %call13 = call i32 @setrlimit64(i32 noundef 7, ptr noundef nonnull %limit) #38
  %cmp14.not = icmp eq i32 %call13, -1
  br i1 %cmp14.not, label %if.end17, label %while.end, !llvm.loop !28

if.end17:                                         ; preds = %if.end17.preheader, %while.body
  %bestlimit.02730 = phi i64 [ %sub, %while.body ], [ %conv, %if.end17.preheader ]
  %4 = load i32, ptr %call18, align 4
  %cmp19 = icmp ult i64 %bestlimit.02730, 16
  br i1 %cmp19, label %while.end, label %if.end22

if.end22:                                         ; preds = %if.end17
  %sub = add nsw i64 %bestlimit.02730, -16
  %cmp10 = icmp ugt i64 %sub, %3
  br i1 %cmp10, label %while.body, label %while.end, !llvm.loop !28

while.end:                                        ; preds = %if.end22, %while.body, %if.end17, %while.cond.preheader
  %setrlimit_error.1 = phi i32 [ 0, %while.cond.preheader ], [ %4, %if.end17 ], [ %4, %while.body ], [ %4, %if.end22 ]
  %bestlimit.1 = phi i64 [ %conv, %while.cond.preheader ], [ %sub, %if.end22 ], [ %sub, %while.body ], [ %3, %if.end17 ]
  %spec.select = call i64 @llvm.umax.i64(i64 %bestlimit.1, i64 %3)
  %cmp27 = icmp ult i64 %spec.select, %conv
  br i1 %cmp27, label %if.then29, label %do.body62

if.then29:                                        ; preds = %while.end
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  %6 = trunc i64 %spec.select to i32
  %conv31 = add i32 %6, -32
  store i32 %conv31, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  %cmp32 = icmp ult i64 %spec.select, 33
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp36 = icmp sgt i32 %7, 3
  br i1 %cmp32, label %do.body35, label %do.body42

do.body35:                                        ; preds = %if.then29
  br i1 %cmp36, label %do.end40, label %if.end39

if.end39:                                         ; preds = %do.body35
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.135, i64 noundef %3, i64 noundef %conv)
  br label %do.end40

do.end40:                                         ; preds = %do.body35, %if.end39
  call void @exit(i32 noundef 1) #40
  unreachable

do.body42:                                        ; preds = %if.then29
  br i1 %cmp36, label %if.end70, label %do.body48

do.body48:                                        ; preds = %do.body42
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.136, i32 noundef %5, i64 noundef %conv)
  %.pr = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp49 = icmp sgt i32 %.pr, 3
  br i1 %cmp49, label %if.end70, label %do.body55

do.body55:                                        ; preds = %do.body48
  %call53 = call ptr @strerror(i32 noundef %setrlimit_error.1) #38
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.137, i64 noundef %conv, ptr noundef %call53)
  %.pr24 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp56 = icmp sgt i32 %.pr24, 3
  br i1 %cmp56, label %if.end70, label %if.end59

if.end59:                                         ; preds = %do.body55
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.138, i64 noundef %spec.select, i32 noundef %8)
  br label %if.end70

do.body62:                                        ; preds = %while.end
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp63 = icmp sgt i32 %9, 2
  br i1 %cmp63, label %if.end70, label %if.end66

if.end66:                                         ; preds = %do.body62
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.139, i64 noundef %conv, i64 noundef %3)
  br label %if.end70

if.end70:                                         ; preds = %do.body42, %do.body48, %if.else, %if.end66, %do.body62, %if.end59, %do.body55, %do.end
  ret void
}

; Function Attrs: nounwind
declare i32 @getrlimit64(i32 noundef, ptr noundef) local_unnamed_addr #3

; Function Attrs: nounwind
declare i32 @setrlimit64(i32 noundef, ptr noundef) local_unnamed_addr #3

; Function Attrs: nounwind uwtable
define dso_local void @checkTcpBacklogSettings() local_unnamed_addr #0 {
entry:
  %buf = alloca [1024 x i8], align 16
  %call = tail call noalias ptr @fopen64(ptr noundef nonnull @.str.140, ptr noundef nonnull @.str.141)
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call ptr @fgets(ptr noundef nonnull %buf, i32 noundef 1024, ptr noundef nonnull %call)
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %if.end12, label %if.then2

if.then2:                                         ; preds = %if.end
  %call4 = call i32 @atoi(ptr nocapture noundef nonnull %buf) #39
  %cmp5 = icmp sgt i32 %call4, 0
  br i1 %cmp5, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.then2
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 46), align 8
  %cmp6 = icmp sge i32 %call4, %0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp8 = icmp sgt i32 %1, 3
  %or.cond = select i1 %cmp6, i1 true, i1 %cmp8
  br i1 %or.cond, label %if.end12, label %if.end10

if.end10:                                         ; preds = %land.lhs.true
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.142, i32 noundef %0, i32 noundef %call4)
  br label %if.end12

if.end12:                                         ; preds = %if.then2, %land.lhs.true, %if.end10, %if.end
  %call13 = call i32 @fclose(ptr noundef nonnull %call)
  br label %return

return:                                           ; preds = %entry, %if.end12
  ret void
}

; Function Attrs: nofree nounwind
declare noundef ptr @fgets(ptr noundef, i32 noundef, ptr nocapture noundef) local_unnamed_addr #2

; Function Attrs: nounwind uwtable
define dso_local void @closeListener(ptr nocapture noundef %sfd) local_unnamed_addr #0 {
entry:
  %count = getelementptr inbounds %struct.connListener, ptr %sfd, i64 0, i32 1
  %0 = load i32, ptr %count, align 8
  %cmp9 = icmp sgt i32 %0, 0
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.inc
  %1 = phi i32 [ %5, %for.inc ], [ %0, %entry ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds [16 x i32], ptr %sfd, i64 0, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx, align 4
  %cmp1 = icmp eq i32 %2, -1
  br i1 %cmp1, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  tail call void @aeDeleteFileEvent(ptr noundef %3, i32 noundef %2, i32 noundef 1) #38
  %4 = load i32, ptr %arrayidx, align 4
  %call = tail call i32 @close(i32 noundef %4) #38
  %.pre = load i32, ptr %count, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %5 = phi i32 [ %1, %for.body ], [ %.pre, %if.end ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %6 = sext i32 %5 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %6
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !29

for.end:                                          ; preds = %for.inc, %entry
  store i32 0, ptr %count, align 8
  ret void
}

declare void @aeDeleteFileEvent(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @createSocketAcceptHandler(ptr noundef %sfd, ptr noundef %accept_handler) local_unnamed_addr #0 {
entry:
  %count = getelementptr inbounds %struct.connListener, ptr %sfd, i64 0, i32 1
  %0 = load i32, ptr %count, align 8
  %cmp12 = icmp sgt i32 %0, 0
  br i1 %cmp12, label %for.body, label %return

for.body:                                         ; preds = %entry, %for.inc8
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc8 ], [ 0, %entry ]
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %arrayidx = getelementptr inbounds [16 x i32], ptr %sfd, i64 0, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx, align 4
  %call = tail call i32 @aeCreateFileEvent(ptr noundef %1, i32 noundef %2, i32 noundef 1, ptr noundef %accept_handler, ptr noundef nonnull %sfd) #38
  %cmp1 = icmp eq i32 %call, -1
  br i1 %cmp1, label %for.cond2.preheader, label %for.inc8

for.cond2.preheader:                              ; preds = %for.body
  %3 = and i64 %indvars.iv, 4294967295
  %cmp314.not = icmp eq i64 %3, 0
  br i1 %cmp314.not, label %return, label %for.body4

for.body4:                                        ; preds = %for.cond2.preheader, %for.body4
  %indvars.iv20 = phi i64 [ %indvars.iv.next21, %for.body4 ], [ %indvars.iv, %for.cond2.preheader ]
  %indvars.iv.next21 = add nsw i64 %indvars.iv20, -1
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %idxprom6 = and i64 %indvars.iv.next21, 4294967295
  %arrayidx7 = getelementptr inbounds [16 x i32], ptr %sfd, i64 0, i64 %idxprom6
  %5 = load i32, ptr %arrayidx7, align 4
  tail call void @aeDeleteFileEvent(ptr noundef %4, i32 noundef %5, i32 noundef 1) #38
  %6 = icmp sgt i64 %indvars.iv20, 1
  br i1 %6, label %for.body4, label %return, !llvm.loop !30

for.inc8:                                         ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %7 = load i32, ptr %count, align 8
  %8 = sext i32 %7 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %8
  br i1 %cmp, label %for.body, label %return, !llvm.loop !31

return:                                           ; preds = %for.inc8, %for.body4, %entry, %for.cond2.preheader
  %retval.0 = phi i32 [ -1, %for.cond2.preheader ], [ 0, %entry ], [ -1, %for.body4 ], [ 0, %for.inc8 ]
  ret i32 %retval.0
}

declare i32 @aeCreateFileEvent(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @listenToPort(ptr nocapture noundef %sfd) local_unnamed_addr #0 {
entry:
  %port1 = getelementptr inbounds %struct.connListener, ptr %sfd, i64 0, i32 4
  %0 = load i32, ptr %port1, align 4
  %bindaddr2 = getelementptr inbounds %struct.connListener, ptr %sfd, i64 0, i32 2
  %1 = load ptr, ptr %bindaddr2, align 8
  %bindaddr_count = getelementptr inbounds %struct.connListener, ptr %sfd, i64 0, i32 3
  %2 = load i32, ptr %bindaddr_count, align 8
  %cmp438 = icmp sgt i32 %2, 0
  br i1 %cmp438, label %for.body.lr.ph, label %return

for.body.lr.ph:                                   ; preds = %entry
  %count = getelementptr inbounds %struct.connListener, ptr %sfd, i64 0, i32 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %indvars.iv
  %3 = load ptr, ptr %arrayidx, align 8
  %4 = load i8, ptr %3, align 1
  %cmp5 = icmp eq i8 %4, 45
  %spec.select.idx = zext i1 %cmp5 to i64
  %spec.select = getelementptr inbounds i8, ptr %3, i64 %spec.select.idx
  %call = tail call ptr @strchr(ptr noundef nonnull dereferenceable(1) %spec.select, i32 noundef 58) #39
  %tobool9.not = icmp eq ptr %call, null
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 46), align 8
  br i1 %tobool9.not, label %if.else, label %if.then10

if.then10:                                        ; preds = %for.body
  %call11 = tail call i32 @anetTcp6Server(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 70), i32 noundef %0, ptr noundef nonnull %spec.select, i32 noundef %5) #38
  br label %if.end19

if.else:                                          ; preds = %for.body
  %call14 = tail call i32 @anetTcpServer(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 70), i32 noundef %0, ptr noundef nonnull %spec.select, i32 noundef %5) #38
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then10
  %call14.sink = phi i32 [ %call14, %if.else ], [ %call11, %if.then10 ]
  %6 = load i32, ptr %count, align 8
  %idxprom17 = sext i32 %6 to i64
  %arrayidx18 = getelementptr inbounds [16 x i32], ptr %sfd, i64 0, i64 %idxprom17
  store i32 %call14.sink, ptr %arrayidx18, align 4
  %7 = load i32, ptr %count, align 8
  %idxprom22 = sext i32 %7 to i64
  %arrayidx23 = getelementptr inbounds [16 x i32], ptr %sfd, i64 0, i64 %idxprom22
  %8 = load i32, ptr %arrayidx23, align 4
  %cmp24 = icmp eq i32 %8, -1
  br i1 %cmp24, label %if.then26, label %if.end52

if.then26:                                        ; preds = %if.end19
  %call27 = tail call ptr @__errno_location() #41
  %9 = load i32, ptr %call27, align 4
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp28 = icmp sgt i32 %10, 3
  br i1 %cmp28, label %do.end, label %if.end31

if.end31:                                         ; preds = %if.then26
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.143, ptr noundef nonnull %spec.select, i32 noundef %0, ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 70))
  br label %do.end

do.end:                                           ; preds = %if.then26, %if.end31
  %cmp32 = icmp eq i32 %9, 99
  %or.cond = and i1 %cmp5, %cmp32
  br i1 %or.cond, label %for.inc, label %if.end36

if.end36:                                         ; preds = %do.end
  switch i32 %9, label %if.end51 [
    i32 97, label %for.inc
    i32 96, label %for.inc
    i32 94, label %for.inc
    i32 93, label %for.inc
    i32 92, label %for.inc
  ]

if.end51:                                         ; preds = %if.end36
  %11 = load i32, ptr %count, align 8
  %cmp9.i = icmp sgt i32 %11, 0
  br i1 %cmp9.i, label %for.body.i, label %closeListener.exit

for.body.i:                                       ; preds = %if.end51, %for.inc.i
  %12 = phi i32 [ %16, %for.inc.i ], [ %11, %if.end51 ]
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.inc.i ], [ 0, %if.end51 ]
  %arrayidx.i = getelementptr inbounds [16 x i32], ptr %sfd, i64 0, i64 %indvars.iv.i
  %13 = load i32, ptr %arrayidx.i, align 4
  %cmp1.i = icmp eq i32 %13, -1
  br i1 %cmp1.i, label %for.inc.i, label %if.end.i

if.end.i:                                         ; preds = %for.body.i
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  tail call void @aeDeleteFileEvent(ptr noundef %14, i32 noundef %13, i32 noundef 1) #38
  %15 = load i32, ptr %arrayidx.i, align 4
  %call.i = tail call i32 @close(i32 noundef %15) #38
  %.pre.i = load i32, ptr %count, align 8
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.end.i, %for.body.i
  %16 = phi i32 [ %12, %for.body.i ], [ %.pre.i, %if.end.i ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %17 = sext i32 %16 to i64
  %cmp.i = icmp slt i64 %indvars.iv.next.i, %17
  br i1 %cmp.i, label %for.body.i, label %closeListener.exit, !llvm.loop !29

closeListener.exit:                               ; preds = %for.inc.i, %if.end51
  store i32 0, ptr %count, align 8
  br label %return

if.end52:                                         ; preds = %if.end19
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 53), align 8
  %cmp53.not = icmp eq i32 %18, 0
  br i1 %cmp53.not, label %if.end61, label %if.then55

if.then55:                                        ; preds = %if.end52
  %call60 = tail call i32 @anetSetSockMarkId(ptr noundef null, i32 noundef %8, i32 noundef %18) #38
  %.pre = load i32, ptr %count, align 8
  %idxprom64.phi.trans.insert = sext i32 %.pre to i64
  %arrayidx65.phi.trans.insert = getelementptr inbounds [16 x i32], ptr %sfd, i64 0, i64 %idxprom64.phi.trans.insert
  %.pre41 = load i32, ptr %arrayidx65.phi.trans.insert, align 4
  br label %if.end61

if.end61:                                         ; preds = %if.then55, %if.end52
  %19 = phi i32 [ %.pre41, %if.then55 ], [ %8, %if.end52 ]
  %call66 = tail call i32 @anetNonBlock(ptr noundef null, i32 noundef %19) #38
  %20 = load i32, ptr %count, align 8
  %idxprom69 = sext i32 %20 to i64
  %arrayidx70 = getelementptr inbounds [16 x i32], ptr %sfd, i64 0, i64 %idxprom69
  %21 = load i32, ptr %arrayidx70, align 4
  %call71 = tail call i32 @anetCloexec(i32 noundef %21) #38
  %22 = load i32, ptr %count, align 8
  %inc = add nsw i32 %22, 1
  store i32 %inc, ptr %count, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end36, %if.end36, %if.end36, %if.end36, %if.end36, %do.end, %if.end61
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %23 = load i32, ptr %bindaddr_count, align 8
  %24 = sext i32 %23 to i64
  %cmp4 = icmp slt i64 %indvars.iv.next, %24
  br i1 %cmp4, label %for.body, label %return, !llvm.loop !32

return:                                           ; preds = %for.inc, %entry, %closeListener.exit
  %retval.0 = phi i32 [ -1, %closeListener.exit ], [ 0, %entry ], [ 0, %for.inc ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strchr(ptr noundef, i32 noundef) local_unnamed_addr #7

declare i32 @anetTcp6Server(ptr noundef, i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare i32 @anetTcpServer(ptr noundef, i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare i32 @anetSetSockMarkId(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

declare i32 @anetNonBlock(ptr noundef, i32 noundef) local_unnamed_addr #4

declare i32 @anetCloexec(i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @resetServerStats() local_unnamed_addr #0 {
entry:
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 142), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(152) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 89), i8 0, i64 152, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 112), i8 0, i64 56, i1 false)
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 144) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 143), align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 145) monotonic, align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 146) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 147), align 8
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 %indvars.iv
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 7
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(148) %arrayidx, i8 0, i64 148, i1 false)
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !33

for.end:                                          ; preds = %for.body
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 109), i8 0, i64 24, i1 false)
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 124) monotonic, align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 125) monotonic, align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 126) monotonic, align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 127) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 208), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(96) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155), i8 0, i64 96, i1 false)
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 153), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 139), i8 0, i64 24, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 149), i8 0, i64 16, i1 false)
  tail call void @lazyfreeResetStats() #38
  ret void
}

declare void @lazyfreeResetStats() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @makeThreadKillable() local_unnamed_addr #0 {
entry:
  %call = tail call i32 @pthread_setcancelstate(i32 noundef 0, ptr noundef null) #38
  %call1 = tail call i32 @pthread_setcanceltype(i32 noundef 1, ptr noundef null) #38
  ret void
}

declare i32 @pthread_setcancelstate(i32 noundef, ptr noundef) local_unnamed_addr #4

declare i32 @pthread_setcanceltype(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @initDbState(ptr nocapture noundef writeonly %db) local_unnamed_addr #0 {
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %cond.end
  %cmp = phi i1 [ true, %entry ], [ false, %cond.end ]
  %indvars.iv = phi i64 [ 0, %entry ], [ 1, %cond.end ]
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %db, i64 0, i32 11, i64 %indvars.iv
  %non_empty_slots = getelementptr inbounds %struct.redisDb, ptr %db, i64 0, i32 11, i64 %indvars.iv, i32 1
  store i32 0, ptr %non_empty_slots, align 4
  %key_count = getelementptr inbounds %struct.redisDb, ptr %db, i64 0, i32 11, i64 %indvars.iv, i32 2
  store i64 0, ptr %key_count, align 8
  store i32 -1, ptr %arrayidx, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %for.body
  %call = tail call noalias dereferenceable_or_null(131080) ptr @zcalloc(i64 noundef 131080) #42
  br label %cond.end

cond.end:                                         ; preds = %for.body, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ null, %for.body ]
  %slot_size_index = getelementptr inbounds %struct.redisDb, ptr %db, i64 0, i32 11, i64 %indvars.iv, i32 4
  store ptr %cond, ptr %slot_size_index, align 8
  %bucket_count = getelementptr inbounds %struct.redisDb, ptr %db, i64 0, i32 11, i64 %indvars.iv, i32 3
  store i64 0, ptr %bucket_count, align 8
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !34

for.end:                                          ; preds = %cond.end
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @zcalloc(i64 noundef) local_unnamed_addr #23

; Function Attrs: nounwind uwtable
define dso_local void @initServer() local_unnamed_addr #0 {
entry:
  %act.i = alloca %struct.sigaction, align 8
  %call = tail call ptr @signal(i32 noundef 1, ptr noundef nonnull inttoptr (i64 1 to ptr)) #38
  %call1 = tail call ptr @signal(i32 noundef 13, ptr noundef nonnull inttoptr (i64 1 to ptr)) #38
  call void @llvm.lifetime.start.p0(i64 152, ptr nonnull %act.i)
  %sa_mask.i = getelementptr inbounds %struct.sigaction, ptr %act.i, i64 0, i32 1
  %call.i = call i32 @sigemptyset(ptr noundef nonnull %sa_mask.i) #38
  %sa_flags.i = getelementptr inbounds %struct.sigaction, ptr %act.i, i64 0, i32 2
  store i32 0, ptr %sa_flags.i, align 8
  store ptr @sigShutdownHandler, ptr %act.i, align 8
  %call1.i = call i32 @sigaction(i32 noundef 15, ptr noundef nonnull %act.i, ptr noundef null) #38
  %call2.i = call i32 @sigaction(i32 noundef 2, ptr noundef nonnull %act.i, ptr noundef null) #38
  call void @setupDebugSigHandlers() #38
  call void @llvm.lifetime.end.p0(i64 152, ptr nonnull %act.i)
  call void @ThreadsManager_init() #38
  %call.i20 = call i32 @pthread_setcancelstate(i32 noundef 0, ptr noundef null) #38
  %call1.i21 = call i32 @pthread_setcanceltype(i32 noundef 1, ptr noundef null) #38
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 251), align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 252), align 8
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 253), align 8
  call void @openlog(ptr noundef %1, i32 noundef 25, i32 noundef %2) #38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 184), align 4
  %tobool2.not = icmp ne i32 %3, 0
  %cond = zext i1 %tobool2.not to i32
  store i32 %cond, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %tobool3.not = icmp eq i32 %3, 0
  %conv = sext i1 %tobool3.not to i64
  store i64 %conv, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 265), align 8
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 6), align 4
  store i32 %4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %call5 = call i32 @getpid() #38
  store i32 %call5, ptr @server, align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %call6 = tail call i64 @pthread_self() #41
  store i64 %call6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 1), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %call7 = call ptr @raxNew() #38
  store ptr %call7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 15), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %call8 = call ptr @listCreate() #38
  store ptr %call8, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  %call9 = call ptr @raxNew() #38
  store ptr %call9, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 66), align 8
  %call10 = call ptr @listCreate() #38
  store ptr %call10, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 56), align 8
  %call11 = call ptr @listCreate() #38
  store ptr %call11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %call12 = call ptr @listCreate() #38
  store ptr %call12, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 60), align 8
  %call13 = call ptr @listCreate() #38
  store ptr %call13, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 57), align 8
  %call14 = call ptr @listCreate() #38
  store ptr %call14, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 58), align 8
  %call15 = call ptr @raxNew() #38
  store ptr %call15, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 64), align 8
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 249), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 266), align 8
  %call16 = call ptr @listCreate() #38
  store ptr %call16, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 327), align 8
  %call17 = call ptr @listCreate() #38
  store ptr %call17, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 328), align 8
  %call18 = call ptr @listCreate() #38
  store ptr %call18, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 331), align 8
  %call19 = call ptr @listCreate() #38
  store ptr %call19, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 332), align 8
  %call20 = call ptr @listCreate() #38
  store ptr %call20, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 311), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 312), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 67), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(48) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 69), i8 0, i64 48, i1 false)
  %call21 = call ptr @listCreate() #38
  store ptr %call21, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 68), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 77), align 8
  %call22 = call i64 @zmalloc_get_memory_size() #38
  store i64 %call22, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 401), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 35), align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 355), i8 0, i64 16, i1 false)
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 384), align 8
  store i64 5000, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 417), align 8
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 418), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  call void @resetReplicationBuffer() #38
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 419), align 8
  %call23 = call ptr @setlocale(i32 noundef 3, ptr noundef %5) #38
  %cmp = icmp eq ptr %call23, null
  br i1 %cmp, label %do.body, label %if.end30

do.body:                                          ; preds = %if.end
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp26 = icmp sgt i32 %6, 3
  br i1 %cmp26, label %do.end, label %if.end29

if.end29:                                         ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.144)
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end29
  call void @exit(i32 noundef 1) #40
  unreachable

if.end30:                                         ; preds = %if.end
  call void @createSharedObjects()
  call void @adjustOpenFilesLimit()
  %call31 = call ptr @monotonicInit() #38
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp33 = icmp sgt i32 %7, 2
  br i1 %cmp33, label %do.end37, label %if.end36

if.end36:                                         ; preds = %if.end30
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.145, ptr noundef %call31)
  br label %do.end37

do.end37:                                         ; preds = %if.end30, %if.end36
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  %add = add i32 %8, 128
  %call38 = call ptr @aeCreateEventLoop(i32 noundef %add) #38
  store ptr %call38, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %cmp39 = icmp eq ptr %call38, null
  br i1 %cmp39, label %do.body42, label %if.end50

do.body42:                                        ; preds = %do.end37
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp43 = icmp sgt i32 %9, 3
  br i1 %cmp43, label %do.end49, label %if.end46

if.end46:                                         ; preds = %do.body42
  %call47 = tail call ptr @__errno_location() #41
  %10 = load i32, ptr %call47, align 4
  %call48 = call ptr @strerror(i32 noundef %10) #38
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.146, ptr noundef %call48)
  br label %do.end49

do.end49:                                         ; preds = %do.body42, %if.end46
  call void @exit(i32 noundef 1) #40
  unreachable

if.end50:                                         ; preds = %do.end37
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %conv51 = sext i32 %11 to i64
  %mul = mul nsw i64 %conv51, 152
  %call52 = call noalias ptr @zmalloc(i64 noundef %mul) #42
  store ptr %call52, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %cmp5334 = icmp sgt i32 %12, 0
  br i1 %cmp5334, label %for.body, label %for.end

for.body:                                         ; preds = %if.end50, %initDbState.exit
  %indvars.iv = phi i64 [ %indvars.iv.next, %initDbState.exit ], [ 0, %if.end50 ]
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool55.not = icmp eq i32 %13, 0
  %cond56 = select i1 %tobool55.not, i32 1, i32 16384
  %call57 = call ptr @dictCreateMultiple(ptr noundef nonnull @dbDictType, i32 noundef %cond56) #38
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %14, i64 %indvars.iv
  store ptr %call57, ptr %arrayidx, align 8
  %call58 = call ptr @dictCreateMultiple(ptr noundef nonnull @dbExpiresDictType, i32 noundef %cond56) #38
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %expires = getelementptr inbounds %struct.redisDb, ptr %15, i64 %indvars.iv, i32 1
  store ptr %call58, ptr %expires, align 8
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %expires_cursor = getelementptr inbounds %struct.redisDb, ptr %16, i64 %indvars.iv, i32 8
  store i64 0, ptr %expires_cursor, align 8
  %call63 = call ptr @dictCreate(ptr noundef nonnull @keylistDictType) #38
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %blocking_keys = getelementptr inbounds %struct.redisDb, ptr %17, i64 %indvars.iv, i32 2
  store ptr %call63, ptr %blocking_keys, align 8
  %call66 = call ptr @dictCreate(ptr noundef nonnull @objectKeyPointerValueDictType) #38
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %blocking_keys_unblock_on_nokey = getelementptr inbounds %struct.redisDb, ptr %18, i64 %indvars.iv, i32 3
  store ptr %call66, ptr %blocking_keys_unblock_on_nokey, align 8
  %call69 = call ptr @dictCreate(ptr noundef nonnull @objectKeyPointerValueDictType) #38
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %ready_keys = getelementptr inbounds %struct.redisDb, ptr %19, i64 %indvars.iv, i32 4
  store ptr %call69, ptr %ready_keys, align 8
  %call72 = call ptr @dictCreate(ptr noundef nonnull @keylistDictType) #38
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %watched_keys = getelementptr inbounds %struct.redisDb, ptr %20, i64 %indvars.iv, i32 5
  store ptr %call72, ptr %watched_keys, align 8
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %21, i64 %indvars.iv, i32 6
  %22 = trunc i64 %indvars.iv to i32
  store i32 %22, ptr %id, align 8
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %avg_ttl = getelementptr inbounds %struct.redisDb, ptr %23, i64 %indvars.iv, i32 7
  store i64 0, ptr %avg_ttl, align 8
  %call79 = call ptr @listCreate() #38
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %defrag_later = getelementptr inbounds %struct.redisDb, ptr %24, i64 %indvars.iv, i32 9
  store ptr %call79, ptr %defrag_later, align 8
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %dict_count = getelementptr inbounds %struct.redisDb, ptr %25, i64 %indvars.iv, i32 10
  store i32 %cond56, ptr %dict_count, align 8
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  br label %for.body.i

for.body.i:                                       ; preds = %cond.end.i, %for.body
  %cmp.i = phi i1 [ true, %for.body ], [ false, %cond.end.i ]
  %indvars.iv.i = phi i64 [ 0, %for.body ], [ 1, %cond.end.i ]
  %arrayidx.i = getelementptr inbounds %struct.redisDb, ptr %26, i64 %indvars.iv, i32 11, i64 %indvars.iv.i
  %non_empty_slots.i = getelementptr inbounds %struct.redisDb, ptr %26, i64 %indvars.iv, i32 11, i64 %indvars.iv.i, i32 1
  store i32 0, ptr %non_empty_slots.i, align 4
  %key_count.i = getelementptr inbounds %struct.redisDb, ptr %26, i64 %indvars.iv, i32 11, i64 %indvars.iv.i, i32 2
  store i64 0, ptr %key_count.i, align 8
  store i32 -1, ptr %arrayidx.i, align 8
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not.i = icmp eq i32 %27, 0
  br i1 %tobool.not.i, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %for.body.i
  %call.i22 = call noalias dereferenceable_or_null(131080) ptr @zcalloc(i64 noundef 131080) #42
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %for.body.i
  %cond.i = phi ptr [ %call.i22, %cond.true.i ], [ null, %for.body.i ]
  %slot_size_index.i = getelementptr inbounds %struct.redisDb, ptr %26, i64 %indvars.iv, i32 11, i64 %indvars.iv.i, i32 4
  store ptr %cond.i, ptr %slot_size_index.i, align 8
  %bucket_count.i = getelementptr inbounds %struct.redisDb, ptr %26, i64 %indvars.iv, i32 11, i64 %indvars.iv.i, i32 3
  store i64 0, ptr %bucket_count.i, align 8
  br i1 %cmp.i, label %for.body.i, label %initDbState.exit, !llvm.loop !34

initDbState.exit:                                 ; preds = %cond.end.i
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %defrag_later88 = getelementptr inbounds %struct.redisDb, ptr %28, i64 %indvars.iv, i32 9
  %29 = load ptr, ptr %defrag_later88, align 8
  %free = getelementptr inbounds %struct.list, ptr %29, i64 0, i32 3
  store ptr @sdsfree, ptr %free, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %31 = sext i32 %30 to i64
  %cmp53 = icmp slt i64 %indvars.iv.next, %31
  br i1 %cmp53, label %for.body, label %for.end, !llvm.loop !35

for.end:                                          ; preds = %initDbState.exit, %if.end50
  %call89 = call ptr @listCreate() #38
  store ptr %call89, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 11), align 8
  call void @evictionPoolAlloc() #38
  %call90 = call ptr @dictCreate(ptr noundef nonnull @keylistDictType) #38
  store ptr %call90, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 357), align 8
  %call91 = call ptr @dictCreate(ptr noundef nonnull @keylistDictType) #38
  store ptr %call91, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 358), align 8
  %call92 = call ptr @dictCreate(ptr noundef nonnull @keylistDictType) #38
  store ptr %call92, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 360), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 361), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 25), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 30), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 32), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 34), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 234), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 233), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(28) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 239), i8 0, i64 28, i1 false)
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 246), align 4
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 246, i64 1), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 247), align 4
  %call93 = call ptr @sdsempty() #38
  store ptr %call93, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 198), align 8
  %call94 = call i64 @time(ptr noundef null) #38
  store i64 %call94, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 229), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 230), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 231), i8 -1, i64 16, i1 false)
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 142), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(152) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 89), i8 0, i64 152, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 112), i8 0, i64 56, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 221), i8 0, i64 16, i1 false)
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 144) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 143), align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 145) monotonic, align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 146) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 147), align 8
  br label %for.body.i23

for.body.i23:                                     ; preds = %for.body.i23, %for.end
  %indvars.iv.i24 = phi i64 [ 0, %for.end ], [ %indvars.iv.next.i, %for.body.i23 ]
  %arrayidx.i25 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 %indvars.iv.i24
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i24, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 7
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(148) %arrayidx.i25, i8 0, i64 148, i1 false)
  br i1 %exitcond.not.i, label %resetServerStats.exit, label %for.body.i23, !llvm.loop !33

resetServerStats.exit:                            ; preds = %for.body.i23
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 109), i8 0, i64 24, i1 false)
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 124) monotonic, align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 125) monotonic, align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 126) monotonic, align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 127) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 208), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(96) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155), i8 0, i64 96, i1 false)
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 153), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 139), i8 0, i64 24, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 149), i8 0, i64 16, i1 false)
  call void @lazyfreeResetStats() #38
  %call95 = call i64 @time(ptr noundef null) #38
  store i64 %call95, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 88), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 235), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 211), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 212), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 274), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 19), align 8
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123), i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(112) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 128), i8 0, i64 112, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399), i8 0, i64 32, i1 false)
  %32 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %call106 = call i64 @aeCreateTimeEvent(ptr noundef %32, i64 noundef 1, ptr noundef nonnull @serverCron, ptr noundef null, ptr noundef null) #38
  %cmp107 = icmp eq i64 %call106, -1
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %resetServerStats.exit
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 2801, ptr noundef nonnull @.str.147) #38
  call void @abort() #40
  unreachable

if.end110:                                        ; preds = %resetServerStats.exit
  %33 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %34 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 41), align 8
  %call111 = call i32 @aeCreateFileEvent(ptr noundef %33, i32 noundef %34, i32 noundef 1, ptr noundef nonnull @modulePipeReadable, ptr noundef null) #38
  %cmp112 = icmp eq i32 %call111, -1
  br i1 %cmp112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.end110
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 2810, ptr noundef nonnull @.str.148) #38
  call void @abort() #40
  unreachable

if.end115:                                        ; preds = %if.end110
  %35 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  call void @aeSetBeforeSleepProc(ptr noundef %35, ptr noundef nonnull @beforeSleep) #38
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  call void @aeSetAfterSleepProc(ptr noundef %36, ptr noundef nonnull @afterSleep) #38
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 24), align 8
  %cmp116 = icmp eq i32 %37, 32
  %38 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 314), align 8
  %cmp118 = icmp eq i64 %38, 0
  %or.cond = select i1 %cmp116, i1 %cmp118, i1 false
  br i1 %or.cond, label %do.body121, label %if.end127

do.body121:                                       ; preds = %if.end115
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp122 = icmp sgt i32 %39, 3
  br i1 %cmp122, label %do.end126, label %if.end125

if.end125:                                        ; preds = %do.body121
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.149)
  br label %do.end126

do.end126:                                        ; preds = %do.body121, %if.end125
  store i64 3221225472, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 314), align 8
  store i32 1792, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 316), align 8
  br label %if.end127

if.end127:                                        ; preds = %do.end126, %if.end115
  call void @scriptingInit(i32 noundef 1) #38
  %call128 = call i32 @functionsInit() #38
  call void @slowlogInit() #38
  call void @latencyMonitorInit() #38
  %40 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 397), align 8
  call void @ACLUpdateDefaultUserPassword(ptr noundef %40) #38
  call void @applyWatchdogPeriod() #38
  %41 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 315), align 8
  %cmp129.not = icmp ne i64 %41, 0
  %42 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %tobool.not.i26 = icmp eq ptr %42, null
  %or.cond33 = select i1 %cmp129.not, i1 %tobool.not.i26, i1 false
  br i1 %or.cond33, label %if.end.i, label %if.end132

if.end.i:                                         ; preds = %if.end127
  %call.i27 = call noalias dereferenceable_or_null(304) ptr @zmalloc(i64 noundef 304) #42
  store ptr %call.i27, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  br label %for.body.i28

for.body.i28:                                     ; preds = %for.body.i28, %if.end.i
  %indvars.iv.i29 = phi i64 [ 0, %if.end.i ], [ %indvars.iv.next.i31, %for.body.i28 ]
  %43 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %mem_usage_sum.i = getelementptr inbounds %struct.clientMemUsageBucket, ptr %43, i64 %indvars.iv.i29, i32 1
  store i64 0, ptr %mem_usage_sum.i, align 8
  %call1.i30 = call ptr @listCreate() #38
  %44 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 63), align 8
  %arrayidx3.i = getelementptr inbounds %struct.clientMemUsageBucket, ptr %44, i64 %indvars.iv.i29
  store ptr %call1.i30, ptr %arrayidx3.i, align 8
  %indvars.iv.next.i31 = add nuw nsw i64 %indvars.iv.i29, 1
  %exitcond.not.i32 = icmp eq i64 %indvars.iv.next.i31, 19
  br i1 %exitcond.not.i32, label %if.end132, label %for.body.i28, !llvm.loop !25

if.end132:                                        ; preds = %for.body.i28, %if.end127
  ret void
}

; Function Attrs: nounwind
declare ptr @signal(i32 noundef, ptr noundef) local_unnamed_addr #3

; Function Attrs: nounwind uwtable
define dso_local void @setupSignalHandlers() local_unnamed_addr #0 {
entry:
  %act = alloca %struct.sigaction, align 8
  %sa_mask = getelementptr inbounds %struct.sigaction, ptr %act, i64 0, i32 1
  %call = call i32 @sigemptyset(ptr noundef nonnull %sa_mask) #38
  %sa_flags = getelementptr inbounds %struct.sigaction, ptr %act, i64 0, i32 2
  store i32 0, ptr %sa_flags, align 8
  store ptr @sigShutdownHandler, ptr %act, align 8
  %call1 = call i32 @sigaction(i32 noundef 15, ptr noundef nonnull %act, ptr noundef null) #38
  %call2 = call i32 @sigaction(i32 noundef 2, ptr noundef nonnull %act, ptr noundef null) #38
  call void @setupDebugSigHandlers() #38
  ret void
}

declare void @ThreadsManager_init() local_unnamed_addr #4

declare void @openlog(ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare i64 @pthread_self() local_unnamed_addr #22

declare ptr @raxNew() local_unnamed_addr #4

declare i64 @zmalloc_get_memory_size() local_unnamed_addr #4

declare void @resetReplicationBuffer() local_unnamed_addr #4

; Function Attrs: nounwind
declare ptr @setlocale(i32 noundef, ptr noundef) local_unnamed_addr #3

declare ptr @monotonicInit() local_unnamed_addr #4

declare ptr @aeCreateEventLoop(i32 noundef) local_unnamed_addr #4

declare ptr @dictCreateMultiple(ptr noundef, i32 noundef) local_unnamed_addr #4

declare void @evictionPoolAlloc() local_unnamed_addr #4

declare i64 @aeCreateTimeEvent(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

declare void @modulePipeReadable(ptr noundef, i32 noundef, ptr noundef, i32 noundef) #4

declare void @aeSetBeforeSleepProc(ptr noundef, ptr noundef) local_unnamed_addr #4

declare void @aeSetAfterSleepProc(ptr noundef, ptr noundef) local_unnamed_addr #4

declare void @scriptingInit(i32 noundef) local_unnamed_addr #4

declare i32 @functionsInit() local_unnamed_addr #4

declare void @slowlogInit() local_unnamed_addr #4

declare void @latencyMonitorInit() local_unnamed_addr #4

declare void @ACLUpdateDefaultUserPassword(ptr noundef) local_unnamed_addr #4

declare void @applyWatchdogPeriod() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @initListeners() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %cmp.not = icmp eq i32 %0, 0
  br i1 %cmp.not, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i32 @connectionIndexByType(ptr noundef nonnull @.str.150) #38
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 2849, ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.150) #38
  tail call void @abort() #40
  unreachable

if.end:                                           ; preds = %if.then
  %idxprom = zext nneg i32 %call to i64
  %bindaddr = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom, i32 2
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 47), ptr %bindaddr, align 8
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 48), align 8
  %bindaddr_count = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom, i32 3
  store i32 %1, ptr %bindaddr_count, align 8
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %port = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom, i32 4
  store i32 %2, ptr %port, align 4
  %call3 = tail call ptr @connectionByType(ptr noundef nonnull @.str.150) #38
  %ct = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom, i32 5
  store ptr %call3, ptr %ct, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %tobool = icmp ne i32 %3, 0
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 403), align 4
  %tobool5 = icmp ne i32 %4, 0
  %or.cond = select i1 %tobool, i1 true, i1 %tobool5
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool7 = icmp ne i32 %5, 0
  %or.cond1 = select i1 %or.cond, i1 true, i1 %tobool7
  br i1 %or.cond1, label %if.then8, label %if.end39

if.then8:                                         ; preds = %if.end4
  %call9 = tail call ptr @connectionTypeTls() #38
  %tobool10.not = icmp eq ptr %call9, null
  br i1 %tobool10.not, label %do.body, label %if.end15

do.body:                                          ; preds = %if.then8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp12 = icmp sgt i32 %6, 3
  br i1 %cmp12, label %do.end, label %if.end14

if.end14:                                         ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.152)
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end14
  tail call void @exit(i32 noundef 1) #40
  unreachable

if.end15:                                         ; preds = %if.then8
  %7 = getelementptr i8, ptr %call9, i64 24
  %call9.val = load ptr, ptr %7, align 8
  %call.i = tail call i32 %call9.val(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 405), i32 noundef 1) #38
  %cmp17 = icmp eq i32 %call.i, -1
  br i1 %cmp17, label %do.body19, label %if.end25

do.body19:                                        ; preds = %if.end15
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp20 = icmp sgt i32 %8, 3
  br i1 %cmp20, label %do.end23, label %if.end22

if.end22:                                         ; preds = %do.body19
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.153)
  br label %do.end23

do.end23:                                         ; preds = %do.body19, %if.end22
  tail call void @exit(i32 noundef 1) #40
  unreachable

if.end25:                                         ; preds = %if.end15
  %.pre = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %9 = icmp eq i32 %.pre, 0
  br i1 %9, label %if.end39, label %if.then27

if.then27:                                        ; preds = %if.end25
  %call28 = tail call i32 @connectionIndexByType(ptr noundef nonnull @.str.154) #38
  %cmp29 = icmp slt i32 %call28, 0
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.then27
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 2872, ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.154) #38
  tail call void @abort() #40
  unreachable

if.end31:                                         ; preds = %if.then27
  %idxprom32 = zext nneg i32 %call28 to i64
  %bindaddr34 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom32, i32 2
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 47), ptr %bindaddr34, align 8
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 48), align 8
  %bindaddr_count35 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom32, i32 3
  store i32 %10, ptr %bindaddr_count35, align 8
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %port36 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom32, i32 4
  store i32 %11, ptr %port36, align 4
  %call37 = tail call ptr @connectionByType(ptr noundef nonnull @.str.154) #38
  %ct38 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom32, i32 5
  store ptr %call37, ptr %ct38, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.end4, %if.end31, %if.end25
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 50), align 8
  %cmp40.not = icmp eq ptr %12, null
  br i1 %cmp40.not, label %for.body.preheader, label %if.then41

if.then41:                                        ; preds = %if.end39
  %call42 = tail call i32 @connectionIndexByType(ptr noundef nonnull @.str.155) #38
  %cmp43 = icmp slt i32 %call42, 0
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.then41
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 2882, ptr noundef nonnull @.str.151, ptr noundef nonnull @.str.155) #38
  tail call void @abort() #40
  unreachable

if.end45:                                         ; preds = %if.then41
  %idxprom46 = zext nneg i32 %call42 to i64
  %bindaddr48 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom46, i32 2
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 50), ptr %bindaddr48, align 8
  %bindaddr_count49 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom46, i32 3
  store i32 1, ptr %bindaddr_count49, align 8
  %call50 = tail call ptr @connectionByType(ptr noundef nonnull @.str.155) #38
  %ct51 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom46, i32 5
  store ptr %call50, ptr %ct51, align 8
  %priv = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom46, i32 6
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 51), ptr %priv, align 8
  br label %for.body.preheader

for.body.preheader:                               ; preds = %if.end45, %if.end39
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body.preheader ]
  %listen_fds.041 = phi i32 [ %listen_fds.1, %for.inc ], [ 0, %for.body.preheader ]
  %arrayidx55 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv
  %ct56 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv, i32 5
  %13 = load ptr, ptr %ct56, align 8
  %cmp57 = icmp eq ptr %13, null
  br i1 %cmp57, label %for.inc, label %if.end59

if.end59:                                         ; preds = %for.body
  %listen.i = getelementptr inbounds %struct.ConnectionType, ptr %13, i64 0, i32 8
  %14 = load ptr, ptr %listen.i, align 8
  %call.i30 = tail call i32 %14(ptr noundef nonnull %arrayidx55) #38
  %cmp61 = icmp eq i32 %call.i30, -1
  br i1 %cmp61, label %do.body63, label %if.end71

do.body63:                                        ; preds = %if.end59
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp64 = icmp sgt i32 %15, 3
  br i1 %cmp64, label %do.end70, label %if.end66

if.end66:                                         ; preds = %do.body63
  %port67 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv, i32 4
  %16 = load i32, ptr %port67, align 4
  %17 = load ptr, ptr %ct56, align 8
  %18 = load ptr, ptr %17, align 8
  %call69 = tail call ptr %18(ptr noundef null) #38
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.156, i32 noundef %16, ptr noundef %call69)
  br label %do.end70

do.end70:                                         ; preds = %do.body63, %if.end66
  tail call void @exit(i32 noundef 1) #40
  unreachable

if.end71:                                         ; preds = %if.end59
  %19 = load ptr, ptr %ct56, align 8
  %tobool.not.i = icmp eq ptr %19, null
  br i1 %tobool.not.i, label %connAcceptHandler.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end71
  %accept_handler.i = getelementptr inbounds %struct.ConnectionType, ptr %19, i64 0, i32 5
  %20 = load ptr, ptr %accept_handler.i, align 8
  br label %connAcceptHandler.exit

connAcceptHandler.exit:                           ; preds = %if.end71, %if.then.i
  %retval.0.i = phi ptr [ %20, %if.then.i ], [ null, %if.end71 ]
  %count.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv, i32 1
  %21 = load i32, ptr %count.i, align 8
  %cmp12.i = icmp sgt i32 %21, 0
  br i1 %cmp12.i, label %for.body.i, label %if.end80

for.body.i:                                       ; preds = %connAcceptHandler.exit, %for.inc8.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.inc8.i ], [ 0, %connAcceptHandler.exit ]
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %arrayidx.i = getelementptr inbounds [16 x i32], ptr %arrayidx55, i64 0, i64 %indvars.iv.i
  %23 = load i32, ptr %arrayidx.i, align 4
  %call.i32 = tail call i32 @aeCreateFileEvent(ptr noundef %22, i32 noundef %23, i32 noundef 1, ptr noundef %retval.0.i, ptr noundef nonnull %arrayidx55) #38
  %cmp1.i = icmp eq i32 %call.i32, -1
  br i1 %cmp1.i, label %for.cond2.preheader.i, label %for.inc8.i

for.cond2.preheader.i:                            ; preds = %for.body.i
  %24 = and i64 %indvars.iv.i, 4294967295
  %cmp314.not.i = icmp eq i64 %24, 0
  br i1 %cmp314.not.i, label %if.then76, label %for.body4.i

for.body4.i:                                      ; preds = %for.cond2.preheader.i, %for.body4.i
  %indvars.iv20.i = phi i64 [ %indvars.iv.next21.i, %for.body4.i ], [ %indvars.iv.i, %for.cond2.preheader.i ]
  %indvars.iv.next21.i = add nsw i64 %indvars.iv20.i, -1
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %idxprom6.i = and i64 %indvars.iv.next21.i, 4294967295
  %arrayidx7.i = getelementptr inbounds [16 x i32], ptr %arrayidx55, i64 0, i64 %idxprom6.i
  %26 = load i32, ptr %arrayidx7.i, align 4
  tail call void @aeDeleteFileEvent(ptr noundef %25, i32 noundef %26, i32 noundef 1) #38
  %27 = icmp sgt i64 %indvars.iv20.i, 1
  br i1 %27, label %for.body4.i, label %if.then76, !llvm.loop !30

for.inc8.i:                                       ; preds = %for.body.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %28 = load i32, ptr %count.i, align 8
  %29 = sext i32 %28 to i64
  %cmp.i = icmp slt i64 %indvars.iv.next.i, %29
  br i1 %cmp.i, label %for.body.i, label %if.end80, !llvm.loop !31

if.then76:                                        ; preds = %for.body4.i, %for.cond2.preheader.i
  %30 = load ptr, ptr %ct56, align 8
  %31 = load ptr, ptr %30, align 8
  %call79 = tail call ptr %31(ptr noundef null) #38
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 2903, ptr noundef nonnull @.str.157, ptr noundef %call79) #38
  tail call void @abort() #40
  unreachable

if.end80:                                         ; preds = %for.inc8.i, %connAcceptHandler.exit
  %32 = phi i32 [ %21, %connAcceptHandler.exit ], [ %28, %for.inc8.i ]
  %add = add nsw i32 %32, %listen_fds.041
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end80
  %listen_fds.1 = phi i32 [ %listen_fds.041, %for.body ], [ %add, %if.end80 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 8
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !36

for.end:                                          ; preds = %for.inc
  %cmp81 = icmp eq i32 %listen_fds.1, 0
  br i1 %cmp81, label %do.body83, label %if.end88

do.body83:                                        ; preds = %for.end
  %33 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp84 = icmp sgt i32 %33, 3
  br i1 %cmp84, label %do.end87, label %if.end86

if.end86:                                         ; preds = %do.body83
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.158)
  br label %do.end87

do.end87:                                         ; preds = %do.body83, %if.end86
  tail call void @exit(i32 noundef 1) #40
  unreachable

if.end88:                                         ; preds = %for.end
  ret void
}

declare i32 @connectionIndexByType(ptr noundef) local_unnamed_addr #4

declare ptr @connectionByType(ptr noundef) local_unnamed_addr #4

declare ptr @connectionTypeTls() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @InitServerLast() local_unnamed_addr #0 {
entry:
  tail call void @bioInit() #38
  tail call void @initThreadedIO() #38
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 165), align 4
  tail call void @set_jemalloc_bg_thread(i32 noundef %0) #38
  %call = tail call i64 @zmalloc_used_memory() #38
  store i64 %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 28), align 8
  ret void
}

declare void @bioInit() local_unnamed_addr #4

declare void @initThreadedIO() local_unnamed_addr #4

declare void @set_jemalloc_bg_thread(i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @populateCommandLegacyRangeSpec(ptr nocapture noundef %c) local_unnamed_addr #0 {
entry:
  %legacy_range_key_spec = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 29
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) %legacy_range_key_spec, i8 0, i64 56, i1 false)
  %flags = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 14
  %0 = load i64, ptr %flags, align 8
  %and = and i64 %0, 2097152
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %or = or i64 %0, 33554432
  store i64 %or, ptr %flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = phi i64 [ %or, %if.then ], [ %0, %entry ]
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 17
  %2 = load i32, ptr %key_specs_num, align 8
  switch i32 %2, label %if.end24 [
    i32 0, label %return
    i32 1, label %land.lhs.true
  ]

land.lhs.true:                                    ; preds = %if.end
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 16
  %3 = load ptr, ptr %key_specs, align 8
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %3, i64 0, i32 2
  %4 = load i32, ptr %begin_search_type, align 8
  %cmp6 = icmp eq i32 %4, 2
  br i1 %cmp6, label %land.lhs.true7, label %for.body.lr.ph

land.lhs.true7:                                   ; preds = %land.lhs.true
  %find_keys_type = getelementptr inbounds %struct.keySpec, ptr %3, i64 0, i32 4
  %5 = load i32, ptr %find_keys_type, align 8
  %cmp10 = icmp eq i32 %5, 2
  br i1 %cmp10, label %if.then11, label %for.body.lr.ph

if.then11:                                        ; preds = %land.lhs.true7
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) %legacy_range_key_spec, ptr noundef nonnull align 8 dereferenceable(56) %3, i64 56, i1 false)
  %flags17 = getelementptr inbounds %struct.keySpec, ptr %3, i64 0, i32 1
  %6 = load i64, ptr %flags17, align 8
  %and18 = and i64 %6, 512
  %tobool19.not = icmp eq i64 %and18, 0
  br i1 %tobool19.not, label %return, label %if.then20

if.then20:                                        ; preds = %if.then11
  %or22 = or i64 %1, 33554432
  store i64 %or22, ptr %flags, align 8
  br label %return

if.end24:                                         ; preds = %if.end
  %cmp2659 = icmp sgt i32 %2, 0
  br i1 %cmp2659, label %for.body.lr.ph, label %if.then95

for.body.lr.ph:                                   ; preds = %land.lhs.true, %land.lhs.true7, %if.end24
  %key_specs27 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 16
  %7 = load ptr, ptr %key_specs27, align 8
  %wide.trip.count = zext nneg i32 %2 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %8 = phi i64 [ %1, %for.body.lr.ph ], [ %17, %for.inc ]
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %prev_lastkey.062 = phi i32 [ 0, %for.body.lr.ph ], [ %prev_lastkey.1, %for.inc ]
  %lastkey.061 = phi i32 [ 0, %for.body.lr.ph ], [ %lastkey.1, %for.inc ]
  %firstkey.060 = phi i32 [ 2147483647, %for.body.lr.ph ], [ %firstkey.1, %for.inc ]
  %begin_search_type29 = getelementptr inbounds %struct.keySpec, ptr %7, i64 %indvars.iv, i32 2
  %9 = load i32, ptr %begin_search_type29, align 8
  %cmp30.not = icmp eq i32 %9, 2
  br i1 %cmp30.not, label %lor.lhs.false, label %if.then36

lor.lhs.false:                                    ; preds = %for.body
  %find_keys_type34 = getelementptr inbounds %struct.keySpec, ptr %7, i64 %indvars.iv, i32 4
  %10 = load i32, ptr %find_keys_type34, align 8
  %cmp35.not = icmp eq i32 %10, 2
  br i1 %cmp35.not, label %if.end39, label %if.then36

if.then36:                                        ; preds = %lor.lhs.false, %for.body
  %or38 = or i64 %8, 33554432
  store i64 %or38, ptr %flags, align 8
  br label %for.inc

if.end39:                                         ; preds = %lor.lhs.false
  %keystep = getelementptr inbounds %struct.keySpec, ptr %7, i64 %indvars.iv, i32 5, i32 0, i32 1
  %11 = load i32, ptr %keystep, align 4
  %cmp43.not = icmp eq i32 %11, 1
  br i1 %cmp43.not, label %lor.lhs.false44, label %if.then51

lor.lhs.false44:                                  ; preds = %if.end39
  %tobool45.not = icmp eq i32 %prev_lastkey.062, 0
  br i1 %tobool45.not, label %if.end54, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %lor.lhs.false44
  %bs = getelementptr inbounds %struct.keySpec, ptr %7, i64 %indvars.iv, i32 3
  %12 = load i32, ptr %bs, align 8
  %sub = add nsw i32 %12, -1
  %cmp50.not = icmp eq i32 %prev_lastkey.062, %sub
  br i1 %cmp50.not, label %if.end54, label %if.then51

if.then51:                                        ; preds = %land.lhs.true46, %if.end39
  %or53 = or i64 %8, 33554432
  store i64 %or53, ptr %flags, align 8
  br label %for.inc

if.end54:                                         ; preds = %land.lhs.true46, %lor.lhs.false44
  %flags58 = getelementptr inbounds %struct.keySpec, ptr %7, i64 %indvars.iv, i32 1
  %13 = load i64, ptr %flags58, align 8
  %and59 = and i64 %13, 512
  %tobool60.not = icmp eq i64 %and59, 0
  br i1 %tobool60.not, label %if.end64, label %if.then61

if.then61:                                        ; preds = %if.end54
  %or63 = or i64 %8, 33554432
  store i64 %or63, ptr %flags, align 8
  br label %if.end64

if.end64:                                         ; preds = %if.then61, %if.end54
  %14 = phi i64 [ %or63, %if.then61 ], [ %8, %if.end54 ]
  %bs68 = getelementptr inbounds %struct.keySpec, ptr %7, i64 %indvars.iv, i32 3
  %15 = load i32, ptr %bs68, align 8
  %firstkey.0. = tail call i32 @llvm.smin.i32(i32 %firstkey.060, i32 %15)
  %fk79 = getelementptr inbounds %struct.keySpec, ptr %7, i64 %indvars.iv, i32 5
  %16 = load i32, ptr %fk79, align 4
  %cmp8158 = icmp slt i32 %16, 0
  %add = select i1 %cmp8158, i32 0, i32 %15
  %spec.select = add nsw i32 %add, %16
  %cond93 = tail call i32 @llvm.umax.i32(i32 %lastkey.061, i32 %spec.select)
  br label %for.inc

for.inc:                                          ; preds = %if.end64, %if.then51, %if.then36
  %17 = phi i64 [ %or38, %if.then36 ], [ %or53, %if.then51 ], [ %14, %if.end64 ]
  %firstkey.1 = phi i32 [ %firstkey.060, %if.then36 ], [ %firstkey.060, %if.then51 ], [ %firstkey.0., %if.end64 ]
  %lastkey.1 = phi i32 [ %lastkey.061, %if.then36 ], [ %lastkey.061, %if.then51 ], [ %cond93, %if.end64 ]
  %prev_lastkey.1 = phi i32 [ %prev_lastkey.062, %if.then36 ], [ %prev_lastkey.062, %if.then51 ], [ %cond93, %if.end64 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !37

for.end:                                          ; preds = %for.inc
  switch i32 %firstkey.1, label %cond.end104 [
    i32 2147483647, label %if.then95
    i32 0, label %cond.false103
  ]

if.then95:                                        ; preds = %if.end24, %for.end
  %18 = phi i64 [ %17, %for.end ], [ %1, %if.end24 ]
  %or97 = or i64 %18, 33554432
  store i64 %or97, ptr %flags, align 8
  br label %return

cond.false103:                                    ; preds = %for.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.159, ptr noundef nonnull @.str.9, i32 noundef 3020) #38
  tail call void @abort() #40
  unreachable

cond.end104:                                      ; preds = %for.end
  %cmp105.not = icmp eq i32 %lastkey.1, 0
  br i1 %cmp105.not, label %cond.false114, label %cond.end115

cond.false114:                                    ; preds = %cond.end104
  tail call void @_serverAssert(ptr noundef nonnull @.str.160, ptr noundef nonnull @.str.9, i32 noundef 3021) #38
  tail call void @abort() #40
  unreachable

cond.end115:                                      ; preds = %cond.end104
  %begin_search_type117 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 29, i32 2
  store i32 2, ptr %begin_search_type117, align 8
  %bs119 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 29, i32 3
  store i32 %firstkey.1, ptr %bs119, align 8
  %find_keys_type122 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 29, i32 4
  store i32 2, ptr %find_keys_type122, align 8
  %cmp123 = icmp slt i32 %lastkey.1, 0
  %sub127 = select i1 %cmp123, i32 0, i32 %firstkey.1
  %cond129 = sub nsw i32 %lastkey.1, %sub127
  %fk131 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 29, i32 5
  store i32 %cond129, ptr %fk131, align 4
  %keystep135 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 29, i32 5, i32 0, i32 1
  store i32 1, ptr %keystep135, align 4
  %limit = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 29, i32 5, i32 0, i32 2
  store i32 0, ptr %limit, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then11, %if.then20, %cond.end115, %if.then95
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @catSubCommandFullname(ptr noundef %parent_name, ptr noundef %sub_name) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @sdsempty() #38
  %call1 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call, ptr noundef nonnull @.str.161, ptr noundef %parent_name, ptr noundef %sub_name) #38
  ret ptr %call1
}

declare ptr @sdscatfmt(ptr noundef, ptr noundef, ...) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @commandAddSubcommand(ptr noundef %parent, ptr noundef %subcommand, ptr noundef %declared_name) local_unnamed_addr #0 {
entry:
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %parent, i64 0, i32 30
  %0 = load ptr, ptr %subcommands_dict, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call ptr @dictCreate(ptr noundef nonnull @commandTableDictType) #38
  store ptr %call, ptr %subcommands_dict, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %parent2 = getelementptr inbounds %struct.redisCommand, ptr %subcommand, i64 0, i32 31
  store ptr %parent, ptr %parent2, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %subcommand, i64 0, i32 27
  %1 = load ptr, ptr %fullname, align 8
  %call3 = tail call i64 @ACLGetCommandID(ptr noundef %1) #38
  %conv = trunc i64 %call3 to i32
  %id = getelementptr inbounds %struct.redisCommand, ptr %subcommand, i64 0, i32 26
  store i32 %conv, ptr %id, align 8
  %2 = load ptr, ptr %subcommands_dict, align 8
  %call5 = tail call ptr @sdsnew(ptr noundef %declared_name) #38
  %call6 = tail call i32 @dictAdd(ptr noundef %2, ptr noundef %call5, ptr noundef %subcommand) #38
  %cmp = icmp eq i32 %call6, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.162, ptr noundef nonnull @.str.9, i32 noundef 3042) #38
  tail call void @abort() #40
  unreachable

cond.end:                                         ; preds = %if.end
  ret void
}

declare i64 @ACLGetCommandID(ptr noundef) local_unnamed_addr #4

declare i32 @dictAdd(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local void @setImplicitACLCategories(ptr nocapture noundef %c) local_unnamed_addr #25 {
entry:
  %flags = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 14
  %0 = load i64, ptr %flags, align 8
  %and = and i64 %0, 1
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %acl_categories = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %1 = load i64, ptr %acl_categories, align 8
  %or = or i64 %1, 4
  store i64 %or, ptr %acl_categories, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %and2 = and i64 %0, 2
  %tobool3.not = icmp eq i64 %and2, 0
  br i1 %tobool3.not, label %if.end10, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %acl_categories4 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %2 = load i64, ptr %acl_categories4, align 8
  %and5 = and i64 %2, 1048576
  %tobool6.not = icmp eq i64 %and5, 0
  br i1 %tobool6.not, label %if.then7, label %if.end10

if.then7:                                         ; preds = %land.lhs.true
  %or9 = or i64 %2, 2
  store i64 %or9, ptr %acl_categories4, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %land.lhs.true, %if.end
  %and12 = and i64 %0, 16
  %tobool13.not = icmp eq i64 %and12, 0
  br i1 %tobool13.not, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.end10
  %acl_categories15 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %3 = load i64, ptr %acl_categories15, align 8
  %or16 = or i64 %3, 139264
  store i64 %or16, ptr %acl_categories15, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end10
  %and19 = and i64 %0, 32
  %tobool20.not = icmp eq i64 %and19, 0
  br i1 %tobool20.not, label %if.end24, label %if.then21

if.then21:                                        ; preds = %if.end17
  %acl_categories22 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %4 = load i64, ptr %acl_categories22, align 8
  %or23 = or i64 %4, 4096
  store i64 %or23, ptr %acl_categories22, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end17
  %and26 = and i64 %0, 16384
  %tobool27.not = icmp eq i64 %and26, 0
  br i1 %tobool27.not, label %if.end31, label %if.then28

if.then28:                                        ; preds = %if.end24
  %acl_categories29 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %5 = load i64, ptr %acl_categories29, align 8
  %or30 = or i64 %5, 16384
  store i64 %or30, ptr %acl_categories29, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %if.end24
  %and33 = and i64 %0, 256
  %tobool34.not = icmp eq i64 %and33, 0
  %acl_categories39.phi.trans.insert = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %.pre = load i64, ptr %acl_categories39.phi.trans.insert, align 8
  br i1 %tobool34.not, label %if.end38, label %if.then35

if.then35:                                        ; preds = %if.end31
  %or37 = or i64 %.pre, 65536
  store i64 %or37, ptr %acl_categories39.phi.trans.insert, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.end31, %if.then35
  %6 = phi i64 [ %or37, %if.then35 ], [ %.pre, %if.end31 ]
  %and40 = and i64 %6, 16384
  %tobool41.not = icmp eq i64 %and40, 0
  br i1 %tobool41.not, label %if.then42, label %if.end45

if.then42:                                        ; preds = %if.end38
  %acl_categories39 = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %or44 = or i64 %6, 32768
  store i64 %or44, ptr %acl_categories39, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then42, %if.end38
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @populateCommandStructure(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 14
  %0 = load i64, ptr %flags, align 8
  %and = and i64 %0, 131072
  %tobool = icmp eq i64 %and, 0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool1 = icmp ne i32 %1, 0
  %or.cond = select i1 %tobool, i1 %tobool1, i1 false
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %and3 = and i64 %0, 262144
  %tobool4 = icmp eq i64 %and3, 0
  %or.cond1 = select i1 %tobool4, i1 true, i1 %tobool1
  br i1 %or.cond1, label %if.end8, label %return

if.end8:                                          ; preds = %if.end
  %and.i = and i64 %0, 1
  %tobool.not.i = icmp eq i64 %and.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %if.end8
  %acl_categories.i = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %2 = load i64, ptr %acl_categories.i, align 8
  %or.i = or i64 %2, 4
  store i64 %or.i, ptr %acl_categories.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %if.end8
  %and2.i = and i64 %0, 2
  %tobool3.not.i = icmp eq i64 %and2.i, 0
  br i1 %tobool3.not.i, label %if.end10.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %acl_categories4.i = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %3 = load i64, ptr %acl_categories4.i, align 8
  %and5.i = and i64 %3, 1048576
  %tobool6.not.i = icmp eq i64 %and5.i, 0
  br i1 %tobool6.not.i, label %if.then7.i, label %if.end10.i

if.then7.i:                                       ; preds = %land.lhs.true.i
  %or9.i = or i64 %3, 2
  store i64 %or9.i, ptr %acl_categories4.i, align 8
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then7.i, %land.lhs.true.i, %if.end.i
  %and12.i = and i64 %0, 16
  %tobool13.not.i = icmp eq i64 %and12.i, 0
  br i1 %tobool13.not.i, label %if.end17.i, label %if.then14.i

if.then14.i:                                      ; preds = %if.end10.i
  %acl_categories15.i = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %4 = load i64, ptr %acl_categories15.i, align 8
  %or16.i = or i64 %4, 139264
  store i64 %or16.i, ptr %acl_categories15.i, align 8
  br label %if.end17.i

if.end17.i:                                       ; preds = %if.then14.i, %if.end10.i
  %and19.i = and i64 %0, 32
  %tobool20.not.i = icmp eq i64 %and19.i, 0
  br i1 %tobool20.not.i, label %if.end24.i, label %if.then21.i

if.then21.i:                                      ; preds = %if.end17.i
  %acl_categories22.i = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %5 = load i64, ptr %acl_categories22.i, align 8
  %or23.i = or i64 %5, 4096
  store i64 %or23.i, ptr %acl_categories22.i, align 8
  br label %if.end24.i

if.end24.i:                                       ; preds = %if.then21.i, %if.end17.i
  %and26.i = and i64 %0, 16384
  %tobool27.not.i = icmp eq i64 %and26.i, 0
  %acl_categories39.phi.trans.insert.i.phi.trans.insert = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %.pre.i.pre = load i64, ptr %acl_categories39.phi.trans.insert.i.phi.trans.insert, align 8
  br i1 %tobool27.not.i, label %if.end31.i, label %if.then28.i

if.then28.i:                                      ; preds = %if.end24.i
  %or30.i = or i64 %.pre.i.pre, 16384
  store i64 %or30.i, ptr %acl_categories39.phi.trans.insert.i.phi.trans.insert, align 8
  br label %if.end31.i

if.end31.i:                                       ; preds = %if.end24.i, %if.then28.i
  %.pre.i = phi i64 [ %or30.i, %if.then28.i ], [ %.pre.i.pre, %if.end24.i ]
  %and33.i = and i64 %0, 256
  %tobool34.not.i = icmp ne i64 %and33.i, 0
  %and40.i = and i64 %.pre.i, 16384
  %tobool41.not.i.not = icmp eq i64 %and40.i, 0
  %6 = or i1 %tobool34.not.i, %tobool41.not.i.not
  br i1 %6, label %7, label %10

7:                                                ; preds = %if.end31.i
  %acl_categories39.phi.trans.insert.i = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 15
  %8 = shl nuw nsw i64 %and33.i, 8
  %9 = or i64 %.pre.i, %8
  %or44.i = or i64 %9, 32768
  %simplifycfg.merge = select i1 %tobool41.not.i.not, i64 %or44.i, i64 %9
  store i64 %simplifycfg.merge, ptr %acl_categories39.phi.trans.insert.i, align 8
  br label %10

10:                                               ; preds = %if.end31.i, %7
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 28
  store ptr null, ptr %latency_histogram, align 8
  tail call void @populateCommandLegacyRangeSpec(ptr noundef nonnull %c)
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 27
  %11 = load ptr, ptr %fullname, align 8
  %call = tail call i64 @ACLGetCommandID(ptr noundef %11) #38
  %conv = trunc i64 %call to i32
  %id = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 26
  store i32 %conv, ptr %id, align 8
  %subcommands = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 20
  %12 = load ptr, ptr %subcommands, align 8
  %tobool9.not = icmp eq ptr %12, null
  br i1 %tobool9.not, label %return, label %for.cond.preheader

for.cond.preheader:                               ; preds = %10
  %13 = load ptr, ptr %12, align 8
  %tobool12.not23 = icmp eq ptr %13, null
  br i1 %tobool12.not23, label %return, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %subcommands_dict.i = getelementptr inbounds %struct.redisCommand, ptr %c, i64 0, i32 30
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %14 = phi ptr [ %13, %for.body.lr.ph ], [ %22, %for.inc ]
  %arrayidx26 = phi ptr [ %12, %for.body.lr.ph ], [ %arrayidx, %for.inc ]
  %15 = phi ptr [ %12, %for.body.lr.ph ], [ %21, %for.inc ]
  %16 = load ptr, ptr %c, align 8
  %call.i = tail call ptr @sdsempty() #38
  %call1.i = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call.i, ptr noundef nonnull @.str.161, ptr noundef %16, ptr noundef nonnull %14) #38
  %fullname17 = getelementptr inbounds %struct.redisCommand, ptr %15, i64 %indvars.iv, i32 27
  store ptr %call1.i, ptr %fullname17, align 8
  %call18 = tail call i32 @populateCommandStructure(ptr noundef nonnull %arrayidx26), !range !16
  %cmp = icmp eq i32 %call18, -1
  br i1 %cmp, label %for.inc, label %if.end21

if.end21:                                         ; preds = %for.body
  %17 = load ptr, ptr %arrayidx26, align 8
  %18 = load ptr, ptr %subcommands_dict.i, align 8
  %tobool.not.i19 = icmp eq ptr %18, null
  br i1 %tobool.not.i19, label %if.then.i21, label %if.end.i20

if.then.i21:                                      ; preds = %if.end21
  %call.i22 = tail call ptr @dictCreate(ptr noundef nonnull @commandTableDictType) #38
  store ptr %call.i22, ptr %subcommands_dict.i, align 8
  br label %if.end.i20

if.end.i20:                                       ; preds = %if.then.i21, %if.end21
  %parent2.i = getelementptr inbounds %struct.redisCommand, ptr %15, i64 %indvars.iv, i32 31
  store ptr %c, ptr %parent2.i, align 8
  %19 = load ptr, ptr %fullname17, align 8
  %call3.i = tail call i64 @ACLGetCommandID(ptr noundef %19) #38
  %conv.i = trunc i64 %call3.i to i32
  %id.i = getelementptr inbounds %struct.redisCommand, ptr %15, i64 %indvars.iv, i32 26
  store i32 %conv.i, ptr %id.i, align 8
  %20 = load ptr, ptr %subcommands_dict.i, align 8
  %call5.i = tail call ptr @sdsnew(ptr noundef %17) #38
  %call6.i = tail call i32 @dictAdd(ptr noundef %20, ptr noundef %call5.i, ptr noundef nonnull %arrayidx26) #38
  %cmp.i = icmp eq i32 %call6.i, 0
  br i1 %cmp.i, label %for.inc, label %cond.false.i

cond.false.i:                                     ; preds = %if.end.i20
  tail call void @_serverAssert(ptr noundef nonnull @.str.162, ptr noundef nonnull @.str.9, i32 noundef 3042) #38
  tail call void @abort() #40
  unreachable

for.inc:                                          ; preds = %if.end.i20, %for.body
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  %21 = load ptr, ptr %subcommands, align 8
  %arrayidx = getelementptr inbounds %struct.redisCommand, ptr %21, i64 %indvars.iv.next
  %22 = load ptr, ptr %arrayidx, align 8
  %tobool12.not = icmp eq ptr %22, null
  br i1 %tobool12.not, label %return, label %for.body, !llvm.loop !38

return:                                           ; preds = %for.inc, %for.cond.preheader, %10, %if.end, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ -1, %if.end ], [ 0, %10 ], [ 0, %for.cond.preheader ], [ 0, %for.inc ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @resetCommandTableStats(ptr noundef %commands) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %commands) #38
  %call111 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not12 = icmp eq ptr %call111, null
  br i1 %cmp.not12, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end8
  %call113 = phi ptr [ %call1, %if.end8 ], [ %call111, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call113) #38
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 22
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 28
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %microseconds, i8 0, i64 32, i1 false)
  %0 = load ptr, ptr %latency_histogram, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  tail call void @hdr_close(ptr noundef nonnull %0) #38
  store ptr null, ptr %latency_histogram, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 30
  %1 = load ptr, ptr %subcommands_dict, align 8
  %tobool5.not = icmp eq ptr %1, null
  br i1 %tobool5.not, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end
  tail call void @resetCommandTableStats(ptr noundef nonnull %1)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %call1 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !39

while.end:                                        ; preds = %if.end8, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  ret void
}

declare ptr @dictGetSafeIterator(ptr noundef) local_unnamed_addr #4

declare ptr @dictNext(ptr noundef) local_unnamed_addr #4

declare ptr @dictGetVal(ptr noundef) local_unnamed_addr #4

declare void @hdr_close(ptr noundef) local_unnamed_addr #4

declare void @dictReleaseIterator(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @resetErrorTableStats() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 15), align 8
  tail call void @raxFreeWithCallback(ptr noundef %0, ptr noundef nonnull @zfree) #38
  %call = tail call ptr @raxNew() #38
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 15), align 8
  ret void
}

declare void @raxFreeWithCallback(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local i32 @redisOpArrayAppend(ptr nocapture noundef %oa, i32 noundef %dbid, ptr noundef %argv, i32 noundef %argc, i32 noundef %target) local_unnamed_addr #0 {
entry:
  %capacity = getelementptr inbounds %struct.redisOpArray, ptr %oa, i64 0, i32 2
  %0 = load i32, ptr %capacity, align 4
  %numops = getelementptr inbounds %struct.redisOpArray, ptr %oa, i64 0, i32 1
  %1 = load i32, ptr %numops, align 8
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.end7, label %if.else

if.else:                                          ; preds = %entry
  %cmp4.not = icmp slt i32 %1, %0
  br i1 %cmp4.not, label %if.end7.thread, label %if.then5

if.end7.thread:                                   ; preds = %if.else
  %.pre21 = load ptr, ptr %oa, align 8
  br label %if.end14

if.then5:                                         ; preds = %if.else
  %mul = shl nsw i32 %0, 1
  br label %if.end7

if.end7:                                          ; preds = %entry, %if.then5
  %mul.sink = phi i32 [ %mul, %if.then5 ], [ 16, %entry ]
  store i32 %mul.sink, ptr %capacity, align 4
  %cmp9.not = icmp eq i32 %0, %mul.sink
  %.pre = load ptr, ptr %oa, align 8
  br i1 %cmp9.not, label %if.end14, label %if.then10

if.then10:                                        ; preds = %if.end7
  %conv = sext i32 %mul.sink to i64
  %mul12 = mul nsw i64 %conv, 24
  %call = tail call ptr @zrealloc(ptr noundef %.pre, i64 noundef %mul12) #43
  store ptr %call, ptr %oa, align 8
  %.pre19 = load i32, ptr %numops, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end7.thread, %if.then10, %if.end7
  %2 = phi i32 [ %.pre19, %if.then10 ], [ %1, %if.end7 ], [ %1, %if.end7.thread ]
  %3 = phi ptr [ %call, %if.then10 ], [ %.pre, %if.end7 ], [ %.pre21, %if.end7.thread ]
  %idx.ext = sext i32 %2 to i64
  %add.ptr = getelementptr inbounds %struct.redisOp, ptr %3, i64 %idx.ext
  %dbid17 = getelementptr inbounds %struct.redisOp, ptr %3, i64 %idx.ext, i32 2
  store i32 %dbid, ptr %dbid17, align 4
  store ptr %argv, ptr %add.ptr, align 8
  %argc19 = getelementptr inbounds %struct.redisOp, ptr %3, i64 %idx.ext, i32 1
  store i32 %argc, ptr %argc19, align 8
  %target20 = getelementptr inbounds %struct.redisOp, ptr %3, i64 %idx.ext, i32 3
  store i32 %target, ptr %target20, align 8
  %4 = load i32, ptr %numops, align 8
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %numops, align 8
  ret i32 %inc
}

; Function Attrs: allocsize(1)
declare ptr @zrealloc(ptr noundef, i64 noundef) local_unnamed_addr #26

; Function Attrs: nounwind uwtable
define dso_local void @redisOpArrayFree(ptr nocapture noundef %oa) local_unnamed_addr #0 {
entry:
  %numops = getelementptr inbounds %struct.redisOpArray, ptr %oa, i64 0, i32 1
  %0 = load i32, ptr %numops, align 8
  %tobool.not11 = icmp eq i32 %0, 0
  br i1 %tobool.not11, label %cond.end, label %while.body

while.body:                                       ; preds = %entry, %for.end
  %1 = phi i32 [ %9, %for.end ], [ %0, %entry ]
  %dec = add nsw i32 %1, -1
  store i32 %dec, ptr %numops, align 8
  %2 = load ptr, ptr %oa, align 8
  %idx.ext = sext i32 %dec to i64
  %add.ptr = getelementptr inbounds %struct.redisOp, ptr %2, i64 %idx.ext
  %argc = getelementptr inbounds %struct.redisOp, ptr %2, i64 %idx.ext, i32 1
  %3 = load i32, ptr %argc, align 8
  %cmp9 = icmp sgt i32 %3, 0
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %while.body, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %while.body ]
  %4 = load ptr, ptr %add.ptr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv
  %5 = load ptr, ptr %arrayidx, align 8
  tail call void @decrRefCount(ptr noundef %5) #38
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %6 = load i32, ptr %argc, align 8
  %7 = sext i32 %6 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %7
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !40

for.end:                                          ; preds = %for.body, %while.body
  %8 = load ptr, ptr %add.ptr, align 8
  tail call void @zfree(ptr noundef %8) #38
  %9 = load i32, ptr %numops, align 8
  %tobool.not = icmp eq i32 %9, 0
  br i1 %tobool.not, label %cond.end, label %while.body, !llvm.loop !41

cond.end:                                         ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isContainerCommandBySds(ptr noundef %s) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call = tail call ptr @dictFetchValue(ptr noundef %0, ptr noundef %s) #38
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %call, i64 0, i32 30
  %1 = load ptr, ptr %subcommands_dict, align 8
  %tobool1 = icmp ne ptr %1, null
  %2 = zext i1 %tobool1 to i32
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %land.ext = phi i32 [ 0, %entry ], [ %2, %land.rhs ]
  ret i32 %land.ext
}

declare ptr @dictFetchValue(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupSubcommand(ptr nocapture noundef readonly %container, ptr noundef %sub_name) local_unnamed_addr #0 {
entry:
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %container, i64 0, i32 30
  %0 = load ptr, ptr %subcommands_dict, align 8
  %call = tail call ptr @dictFetchValue(ptr noundef %0, ptr noundef %sub_name) #38
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandLogic(ptr noundef %commands, ptr nocapture noundef readonly %argv, i32 noundef %argc, i32 noundef %strict) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr %argv, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %call = tail call ptr @dictFetchValue(ptr noundef %commands, ptr noundef %1) #38
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %land.end.thread, label %land.end

land.end.thread:                                  ; preds = %entry
  %cmp10 = icmp ne i32 %argc, 1
  br label %if.then

land.end:                                         ; preds = %entry
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %call, i64 0, i32 30
  %2 = load ptr, ptr %subcommands_dict, align 8
  %tobool1 = icmp ne ptr %2, null
  %cmp = icmp ne i32 %argc, 1
  %or.cond = select i1 %cmp, i1 %tobool1, i1 false
  br i1 %or.cond, label %if.else, label %if.then

if.then:                                          ; preds = %land.end.thread, %land.end
  %cmp12 = phi i1 [ %cmp10, %land.end.thread ], [ %cmp, %land.end ]
  %tobool3 = icmp ne i32 %strict, 0
  %or.cond1 = and i1 %tobool3, %cmp12
  %.call = select i1 %or.cond1, ptr null, ptr %call
  br label %return

if.else:                                          ; preds = %land.end
  %tobool6 = icmp ne i32 %strict, 0
  %cmp8 = icmp ne i32 %argc, 2
  %or.cond2 = and i1 %cmp8, %tobool6
  br i1 %or.cond2, label %return, label %if.end10

if.end10:                                         ; preds = %if.else
  %arrayidx11 = getelementptr inbounds ptr, ptr %argv, i64 1
  %3 = load ptr, ptr %arrayidx11, align 8
  %ptr12 = getelementptr inbounds %struct.redisObject, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %ptr12, align 8
  %call.i = tail call ptr @dictFetchValue(ptr noundef nonnull %2, ptr noundef %4) #38
  br label %return

return:                                           ; preds = %if.else, %if.then, %if.end10
  %retval.0 = phi ptr [ %call.i, %if.end10 ], [ %.call, %if.then ], [ null, %if.else ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommand(ptr nocapture noundef readonly %argv, i32 noundef %argc) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %1 = load ptr, ptr %argv, align 8
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %ptr.i, align 8
  %call.i = tail call ptr @dictFetchValue(ptr noundef %0, ptr noundef %2) #38
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %lookupCommandLogic.exit, label %land.end.i

land.end.i:                                       ; preds = %entry
  %subcommands_dict.i = getelementptr inbounds %struct.redisCommand, ptr %call.i, i64 0, i32 30
  %3 = load ptr, ptr %subcommands_dict.i, align 8
  %tobool1.i = icmp ne ptr %3, null
  %cmp.i = icmp ne i32 %argc, 1
  %or.cond.i = select i1 %cmp.i, i1 %tobool1.i, i1 false
  br i1 %or.cond.i, label %if.else.i, label %lookupCommandLogic.exit

if.else.i:                                        ; preds = %land.end.i
  %arrayidx11.i = getelementptr inbounds ptr, ptr %argv, i64 1
  %4 = load ptr, ptr %arrayidx11.i, align 8
  %ptr12.i = getelementptr inbounds %struct.redisObject, ptr %4, i64 0, i32 2
  %5 = load ptr, ptr %ptr12.i, align 8
  %call.i.i = tail call ptr @dictFetchValue(ptr noundef nonnull %3, ptr noundef %5) #38
  br label %lookupCommandLogic.exit

lookupCommandLogic.exit:                          ; preds = %entry, %land.end.i, %if.else.i
  %retval.0.i = phi ptr [ %call.i.i, %if.else.i ], [ %call.i, %land.end.i ], [ null, %entry ]
  ret ptr %retval.0.i
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandBySdsLogic(ptr noundef %commands, ptr noundef %s) local_unnamed_addr #0 {
entry:
  %argc = alloca i32, align 4
  %arrayidx.i = getelementptr inbounds i8, ptr %s, i64 -1
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %s, i64 -3
  %1 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %1 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %s, i64 -5
  %2 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %2 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %s, i64 -9
  %3 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %3 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %s, i64 -17
  %4 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %4, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call1 = call ptr @sdssplitlen(ptr noundef nonnull %s, i64 noundef %retval.0.i, ptr noundef nonnull @.str.165, i32 noundef 1, ptr noundef nonnull %argc) #38
  %cmp = icmp eq ptr %call1, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %sdslen.exit
  %5 = load i32, ptr %argc, align 4
  %6 = add i32 %5, -3
  %or.cond = icmp ult i32 %6, -2
  br i1 %or.cond, label %if.then4, label %cond.end

if.then4:                                         ; preds = %if.end
  call void @sdsfreesplitres(ptr noundef nonnull %call1, i32 noundef %5) #38
  br label %return

cond.end:                                         ; preds = %if.end
  %7 = zext nneg i32 %5 to i64
  %8 = call ptr @llvm.stacksave.p0()
  %vla = alloca %struct.redisObject, i64 %7, align 16
  %9 = load i32, ptr %argc, align 4
  %10 = zext nneg i32 %9 to i64
  %vla8 = alloca ptr, i64 %10, align 16
  %cmp915 = icmp sgt i32 %9, 0
  call void @llvm.assume(i1 %cmp915)
  br label %do.body

do.body:                                          ; preds = %cond.end, %do.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %do.body ], [ 0, %cond.end ]
  %arrayidx = getelementptr inbounds %struct.redisObject, ptr %vla, i64 %indvars.iv
  %refcount = getelementptr inbounds %struct.redisObject, ptr %vla, i64 %indvars.iv, i32 1
  store i32 2147483646, ptr %refcount, align 4
  %bf.load = load i32, ptr %arrayidx, align 16
  %bf.clear16 = and i32 %bf.load, -256
  store i32 %bf.clear16, ptr %arrayidx, align 16
  %arrayidx19 = getelementptr inbounds ptr, ptr %call1, i64 %indvars.iv
  %11 = load ptr, ptr %arrayidx19, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %vla, i64 %indvars.iv, i32 2
  store ptr %11, ptr %ptr, align 8
  %arrayidx25 = getelementptr inbounds ptr, ptr %vla8, i64 %indvars.iv
  store ptr %arrayidx, ptr %arrayidx25, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %10
  br i1 %exitcond.not, label %for.end.loopexit, label %do.body, !llvm.loop !42

for.end.loopexit:                                 ; preds = %do.body
  %.pre = load ptr, ptr %vla8, align 16
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %.pre, i64 0, i32 2
  %12 = load ptr, ptr %ptr.i, align 8
  %call.i = call ptr @dictFetchValue(ptr noundef %commands, ptr noundef %12) #38
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %land.end.thread.i, label %land.end.i

land.end.thread.i:                                ; preds = %for.end.loopexit
  %cmp10.i = icmp ne i32 %9, 1
  br label %if.then.i

land.end.i:                                       ; preds = %for.end.loopexit
  %subcommands_dict.i = getelementptr inbounds %struct.redisCommand, ptr %call.i, i64 0, i32 30
  %13 = load ptr, ptr %subcommands_dict.i, align 8
  %tobool1.i = icmp ne ptr %13, null
  %cmp.i = icmp ne i32 %9, 1
  %or.cond.i = select i1 %cmp.i, i1 %tobool1.i, i1 false
  br i1 %or.cond.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %land.end.i, %land.end.thread.i
  %cmp12.i = phi i1 [ %cmp10.i, %land.end.thread.i ], [ %cmp.i, %land.end.i ]
  %.call.i = select i1 %cmp12.i, ptr null, ptr %call.i
  br label %lookupCommandLogic.exit

if.else.i:                                        ; preds = %land.end.i
  %cmp8.i.not = icmp eq i32 %9, 2
  br i1 %cmp8.i.not, label %if.end10.i, label %lookupCommandLogic.exit

if.end10.i:                                       ; preds = %if.else.i
  %arrayidx11.i = getelementptr inbounds ptr, ptr %vla8, i64 1
  %14 = load ptr, ptr %arrayidx11.i, align 8
  %ptr12.i = getelementptr inbounds %struct.redisObject, ptr %14, i64 0, i32 2
  %15 = load ptr, ptr %ptr12.i, align 8
  %call.i.i = call ptr @dictFetchValue(ptr noundef nonnull %13, ptr noundef %15) #38
  br label %lookupCommandLogic.exit

lookupCommandLogic.exit:                          ; preds = %if.then.i, %if.else.i, %if.end10.i
  %retval.0.i14 = phi ptr [ %call.i.i, %if.end10.i ], [ %.call.i, %if.then.i ], [ null, %if.else.i ]
  %16 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call1, i32 noundef %16) #38
  call void @llvm.stackrestore.p0(ptr %8)
  br label %return

return:                                           ; preds = %sdslen.exit, %lookupCommandLogic.exit, %if.then4
  %retval.0 = phi ptr [ null, %if.then4 ], [ %retval.0.i14, %lookupCommandLogic.exit ], [ null, %sdslen.exit ]
  ret ptr %retval.0
}

declare ptr @sdssplitlen(ptr noundef, i64 noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

declare void @sdsfreesplitres(ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #5

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore.p0(ptr) #5

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandBySds(ptr noundef %s) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call = tail call ptr @lookupCommandBySdsLogic(ptr noundef %0, ptr noundef %s)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandByCStringLogic(ptr noundef %commands, ptr noundef %s) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @sdsnew(ptr noundef %s) #38
  %call1 = tail call ptr @lookupCommandBySdsLogic(ptr noundef %commands, ptr noundef %call)
  tail call void @sdsfree(ptr noundef %call) #38
  ret ptr %call1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandByCString(ptr noundef %s) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call.i = tail call ptr @sdsnew(ptr noundef %s) #38
  %call1.i = tail call ptr @lookupCommandBySdsLogic(ptr noundef %0, ptr noundef %call.i)
  tail call void @sdsfree(ptr noundef %call.i) #38
  ret ptr %call1.i
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandOrOriginal(ptr nocapture noundef readonly %argv, i32 noundef %argc) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %1 = load ptr, ptr %argv, align 8
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %ptr.i, align 8
  %call.i = tail call ptr @dictFetchValue(ptr noundef %0, ptr noundef %2) #38
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.then, label %land.end.i

land.end.i:                                       ; preds = %entry
  %subcommands_dict.i = getelementptr inbounds %struct.redisCommand, ptr %call.i, i64 0, i32 30
  %3 = load ptr, ptr %subcommands_dict.i, align 8
  %tobool1.i = icmp ne ptr %3, null
  %cmp.i = icmp ne i32 %argc, 1
  %or.cond.i = select i1 %cmp.i, i1 %tobool1.i, i1 false
  br i1 %or.cond.i, label %lookupCommandLogic.exit, label %if.end

lookupCommandLogic.exit:                          ; preds = %land.end.i
  %arrayidx11.i = getelementptr inbounds ptr, ptr %argv, i64 1
  %4 = load ptr, ptr %arrayidx11.i, align 8
  %ptr12.i = getelementptr inbounds %struct.redisObject, ptr %4, i64 0, i32 2
  %5 = load ptr, ptr %ptr12.i, align 8
  %call.i.i = tail call ptr @dictFetchValue(ptr noundef nonnull %3, ptr noundef %5) #38
  %tobool.not = icmp eq ptr %call.i.i, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry, %lookupCommandLogic.exit
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 13), align 8
  %7 = load ptr, ptr %argv, align 8
  %ptr.i4 = getelementptr inbounds %struct.redisObject, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %ptr.i4, align 8
  %call.i5 = tail call ptr @dictFetchValue(ptr noundef %6, ptr noundef %8) #38
  %tobool.not.i6 = icmp eq ptr %call.i5, null
  br i1 %tobool.not.i6, label %if.end, label %land.end.i7

land.end.i7:                                      ; preds = %if.then
  %subcommands_dict.i8 = getelementptr inbounds %struct.redisCommand, ptr %call.i5, i64 0, i32 30
  %9 = load ptr, ptr %subcommands_dict.i8, align 8
  %tobool1.i9 = icmp ne ptr %9, null
  %cmp.i10 = icmp ne i32 %argc, 1
  %or.cond.i11 = select i1 %cmp.i10, i1 %tobool1.i9, i1 false
  br i1 %or.cond.i11, label %if.else.i15, label %if.end

if.else.i15:                                      ; preds = %land.end.i7
  %arrayidx11.i17 = getelementptr inbounds ptr, ptr %argv, i64 1
  %10 = load ptr, ptr %arrayidx11.i17, align 8
  %ptr12.i18 = getelementptr inbounds %struct.redisObject, ptr %10, i64 0, i32 2
  %11 = load ptr, ptr %ptr12.i18, align 8
  %call.i.i19 = tail call ptr @dictFetchValue(ptr noundef nonnull %9, ptr noundef %11) #38
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end.i, %if.else.i15, %land.end.i7, %lookupCommandLogic.exit
  %cmd.0 = phi ptr [ %call.i.i, %lookupCommandLogic.exit ], [ %call.i.i19, %if.else.i15 ], [ %call.i5, %land.end.i7 ], [ %call.i, %land.end.i ], [ null, %if.then ]
  ret ptr %cmd.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @mustObeyClient(ptr nocapture noundef readonly %c) local_unnamed_addr #13 {
entry:
  %0 = load i64, ptr %c, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %2 = trunc i64 %1 to i32
  %3 = lshr i32 %2, 1
  %4 = and i32 %3, 1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %lor.ext = phi i32 [ 1, %entry ], [ %4, %lor.rhs ]
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define dso_local void @alsoPropagate(i32 noundef %dbid, ptr nocapture noundef readonly %argv, i32 noundef %argc, i32 noundef %target) local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 249), align 8
  %tobool.i = icmp eq i32 %0, 0
  %cmp.i = icmp eq i32 %target, 0
  %or.cond.i = or i1 %cmp.i, %tobool.i
  br i1 %or.cond.i, label %return, label %lor.lhs.false1.i

lor.lhs.false1.i:                                 ; preds = %entry
  %1 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool2.not.i = icmp eq i32 %1, 0
  br i1 %tobool2.not.i, label %if.end.i, label %return

if.end.i:                                         ; preds = %lor.lhs.false1.i
  %and.i = and i32 %target, 1
  %tobool3.i = icmp ne i32 %and.i, 0
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp5.i = icmp ne i32 %2, 0
  %or.cond1.i = select i1 %tobool3.i, i1 %cmp5.i, i1 false
  br i1 %or.cond1.i, label %if.end, label %if.end8.i

if.end8.i:                                        ; preds = %if.end.i
  %and9.i = and i32 %target, 2
  %tobool10.i = icmp ne i32 %and9.i, 0
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp12.i = icmp eq ptr %3, null
  %or.cond2.i = select i1 %tobool10.i, i1 %cmp12.i, i1 false
  br i1 %or.cond2.i, label %land.lhs.true.i, label %return

land.lhs.true.i:                                  ; preds = %if.end8.i
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 268), align 8
  %tobool13.not.i = icmp eq ptr %4, null
  br i1 %tobool13.not.i, label %lor.lhs.false14.i, label %if.end

lor.lhs.false14.i:                                ; preds = %land.lhs.true.i
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len.i = getelementptr inbounds %struct.list, ptr %5, i64 0, i32 5
  %6 = load i64, ptr %len.i, align 8
  %cmp15.not.i = icmp eq i64 %6, 0
  br i1 %cmp15.not.i, label %return, label %if.end

if.end:                                           ; preds = %lor.lhs.false14.i, %land.lhs.true.i, %if.end.i
  %conv = sext i32 %argc to i64
  %mul = shl nsw i64 %conv, 3
  %call1 = tail call noalias ptr @zmalloc(i64 noundef %mul) #42
  %cmp13 = icmp sgt i32 %argc, 0
  br i1 %cmp13, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %if.end
  %wide.trip.count = zext nneg i32 %argc to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds ptr, ptr %argv, i64 %indvars.iv
  %7 = load ptr, ptr %arrayidx, align 8
  %arrayidx4 = getelementptr inbounds ptr, ptr %call1, i64 %indvars.iv
  store ptr %7, ptr %arrayidx4, align 8
  tail call void @incrRefCount(ptr noundef %7) #38
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !43

for.end:                                          ; preds = %for.body, %if.end
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 2), align 4
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  %cmp.i10 = icmp eq i32 %9, 0
  br i1 %cmp.i10, label %if.end7.i, label %if.else.i

if.else.i:                                        ; preds = %for.end
  %cmp4.not.i = icmp slt i32 %9, %8
  br i1 %cmp4.not.i, label %if.end7.thread.i, label %if.then5.i

if.end7.thread.i:                                 ; preds = %if.else.i
  %.pre21.i = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248), align 8
  br label %redisOpArrayAppend.exit

if.then5.i:                                       ; preds = %if.else.i
  %mul.i = shl nsw i32 %8, 1
  br label %if.end7.i

if.end7.i:                                        ; preds = %if.then5.i, %for.end
  %mul.sink.i = phi i32 [ %mul.i, %if.then5.i ], [ 16, %for.end ]
  store i32 %mul.sink.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 2), align 4
  %cmp9.not.i = icmp eq i32 %8, %mul.sink.i
  %.pre.i = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248), align 8
  br i1 %cmp9.not.i, label %redisOpArrayAppend.exit, label %if.then10.i

if.then10.i:                                      ; preds = %if.end7.i
  %conv.i = sext i32 %mul.sink.i to i64
  %mul12.i = mul nsw i64 %conv.i, 24
  %call.i = tail call ptr @zrealloc(ptr noundef %.pre.i, i64 noundef %mul12.i) #43
  store ptr %call.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248), align 8
  %.pre19.i = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  br label %redisOpArrayAppend.exit

redisOpArrayAppend.exit:                          ; preds = %if.end7.thread.i, %if.end7.i, %if.then10.i
  %10 = phi i32 [ %.pre19.i, %if.then10.i ], [ %9, %if.end7.i ], [ %9, %if.end7.thread.i ]
  %11 = phi ptr [ %call.i, %if.then10.i ], [ %.pre.i, %if.end7.i ], [ %.pre21.i, %if.end7.thread.i ]
  %idx.ext.i = sext i32 %10 to i64
  %add.ptr.i = getelementptr inbounds %struct.redisOp, ptr %11, i64 %idx.ext.i
  %dbid17.i = getelementptr inbounds %struct.redisOp, ptr %11, i64 %idx.ext.i, i32 2
  store i32 %dbid, ptr %dbid17.i, align 4
  store ptr %call1, ptr %add.ptr.i, align 8
  %argc19.i = getelementptr inbounds %struct.redisOp, ptr %11, i64 %idx.ext.i, i32 1
  store i32 %argc, ptr %argc19.i, align 8
  %target20.i = getelementptr inbounds %struct.redisOp, ptr %11, i64 %idx.ext.i, i32 3
  store i32 %target, ptr %target20.i, align 8
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  %inc.i = add nsw i32 %12, 1
  store i32 %inc.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  br label %return

return:                                           ; preds = %if.end8.i, %lor.lhs.false14.i, %entry, %lor.lhs.false1.i, %redisOpArrayAppend.exit
  ret void
}

declare void @incrRefCount(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @forceCommandPropagation(ptr nocapture noundef %c, i32 noundef %flags) local_unnamed_addr #0 {
entry:
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %0 = load ptr, ptr %cmd, align 8
  %flags1 = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %flags1, align 8
  %and = and i64 %1, 65537
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.167, ptr noundef nonnull @.str.9, i32 noundef 3378) #38
  tail call void @abort() #40
  unreachable

cond.end:                                         ; preds = %entry
  %and4 = and i32 %flags, 2
  %tobool5.not = icmp eq i32 %and4, 0
  br i1 %tobool5.not, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %flags6 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %2 = load i64, ptr %flags6, align 8
  %or = or i64 %2, 32768
  store i64 %or, ptr %flags6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %and7 = and i32 %flags, 1
  %tobool8.not = icmp eq i32 %and7, 0
  br i1 %tobool8.not, label %if.end12, label %if.then9

if.then9:                                         ; preds = %if.end
  %flags10 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %3 = load i64, ptr %flags10, align 8
  %or11 = or i64 %3, 16384
  store i64 %or11, ptr %flags10, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local void @preventCommandPropagation(ptr nocapture noundef %c) local_unnamed_addr #25 {
entry:
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %0 = load i64, ptr %flags, align 8
  %or = or i64 %0, 1572864
  store i64 %or, ptr %flags, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local void @preventCommandAOF(ptr nocapture noundef %c) local_unnamed_addr #25 {
entry:
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %0 = load i64, ptr %flags, align 8
  %or = or i64 %0, 524288
  store i64 %or, ptr %flags, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local void @preventCommandReplication(ptr nocapture noundef %c) local_unnamed_addr #25 {
entry:
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %0 = load i64, ptr %flags, align 8
  %or = or i64 %0, 1048576
  store i64 %or, ptr %flags, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @slowlogPushCurrentCommand(ptr noundef %c, ptr nocapture noundef readonly %cmd, i64 noundef %duration) local_unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 14
  %0 = load i64, ptr %flags, align 8
  %and = and i64 %0, 4096
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %original_argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 15
  %1 = load ptr, ptr %original_argv, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end
  %argv3 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %2 = load ptr, ptr %argv3, align 8
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.false
  %cond = phi ptr [ %2, %cond.false ], [ %1, %if.end ]
  %original_argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 14
  %argc8 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %cond10.in = select i1 %tobool1.not, ptr %argc8, ptr %original_argc
  %cond10 = load i32, ptr %cond10.in, align 4
  tail call void @slowlogPushEntryIfNeeded(ptr noundef nonnull %c, ptr noundef %cond, i32 noundef %cond10, i64 noundef %duration) #38
  br label %return

return:                                           ; preds = %entry, %cond.end
  ret void
}

declare void @slowlogPushEntryIfNeeded(ptr noundef, ptr noundef, i32 noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @updateCommandLatencyHistogram(ptr noundef %latency_histogram, i64 noundef %duration_hist) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr %latency_histogram, align 8
  %cmp4 = icmp eq ptr %0, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %entry
  %call = tail call i32 @hdr_init(i64 noundef 1, i64 noundef 1000000000, i32 noundef 2, ptr noundef nonnull %latency_histogram) #38
  %.pre = load ptr, ptr %latency_histogram, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %entry
  %1 = phi ptr [ %.pre, %if.then5 ], [ %0, %entry ]
  %spec.store.select = tail call i64 @llvm.smax.i64(i64 %duration_hist, i64 1)
  %spec.store.select1 = tail call i64 @llvm.umin.i64(i64 %spec.store.select, i64 1000000000)
  %call7 = tail call zeroext i1 @hdr_record_value(ptr noundef %1, i64 noundef %spec.store.select1) #38
  ret void
}

declare i32 @hdr_init(i64 noundef, i64 noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

declare zeroext i1 @hdr_record_value(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @postExecutionUnitOperations() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  tail call void @firePostExecutionUnitJobs() #38
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  %cmp.i = icmp eq i32 %1, 0
  br i1 %cmp.i, label %propagatePendingCommands.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %cmp1.i = icmp sgt i32 %1, 1
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %tobool.not.i = icmp eq ptr %2, null
  br i1 %tobool.not.i, label %if.end7.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %cmd.i = getelementptr inbounds %struct.client, ptr %2, i64 0, i32 17
  %3 = load ptr, ptr %cmd.i, align 8
  %tobool2.not.i = icmp eq ptr %3, null
  br i1 %tobool2.not.i, label %if.end7.i, label %land.lhs.true3.i

land.lhs.true3.i:                                 ; preds = %land.lhs.true.i
  %flags.i = getelementptr inbounds %struct.redisCommand, ptr %3, i64 0, i32 14
  %4 = load i64, ptr %flags.i, align 8
  %and.i = and i64 %4, 268435456
  %tobool5.not.i = icmp eq i64 %and.i, 0
  %spec.select.i = and i1 %cmp1.i, %tobool5.not.i
  br i1 %spec.select.i, label %if.then9.i, label %if.end10.i

if.end7.i:                                        ; preds = %land.lhs.true.i, %if.end.i
  br i1 %cmp1.i, label %if.then9.i, label %if.end10.i

if.then9.i:                                       ; preds = %if.end7.i, %land.lhs.true3.i
  tail call fastcc void @propagateNow(i32 noundef -1, ptr noundef nonnull getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 49), i32 noundef 1, i32 noundef 3)
  %.pre.i = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  br label %if.end10.i

if.end10.i:                                       ; preds = %if.then9.i, %if.end7.i, %land.lhs.true3.i
  %5 = phi i32 [ %1, %land.lhs.true3.i ], [ %.pre.i, %if.then9.i ], [ %1, %if.end7.i ]
  %transaction.0.shrunk11.i = phi i1 [ false, %land.lhs.true3.i ], [ true, %if.then9.i ], [ false, %if.end7.i ]
  %cmp1114.i = icmp sgt i32 %5, 0
  br i1 %cmp1114.i, label %for.body.i, label %for.end.i

for.body.i:                                       ; preds = %if.end10.i, %cond.end.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %cond.end.i ], [ 0, %if.end10.i ]
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248), align 8
  %target.i = getelementptr inbounds %struct.redisOp, ptr %6, i64 %indvars.iv.i, i32 3
  %7 = load i32, ptr %target.i, align 8
  %tobool13.not.i = icmp eq i32 %7, 0
  br i1 %tobool13.not.i, label %cond.false.i, label %cond.end.i

cond.false.i:                                     ; preds = %for.body.i
  tail call void @_serverAssert(ptr noundef nonnull @.str.463, ptr noundef nonnull @.str.9, i32 noundef 3459) #38
  tail call void @abort() #40
  unreachable

cond.end.i:                                       ; preds = %for.body.i
  %arrayidx.i = getelementptr inbounds %struct.redisOp, ptr %6, i64 %indvars.iv.i
  %dbid.i = getelementptr inbounds %struct.redisOp, ptr %6, i64 %indvars.iv.i, i32 2
  %8 = load i32, ptr %dbid.i, align 4
  %9 = load ptr, ptr %arrayidx.i, align 8
  %argc.i = getelementptr inbounds %struct.redisOp, ptr %6, i64 %indvars.iv.i, i32 1
  %10 = load i32, ptr %argc.i, align 8
  tail call fastcc void @propagateNow(i32 noundef %8, ptr noundef %9, i32 noundef %10, i32 noundef %7)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  %12 = sext i32 %11 to i64
  %cmp11.i = icmp slt i64 %indvars.iv.next.i, %12
  br i1 %cmp11.i, label %for.body.i, label %for.end.i, !llvm.loop !44

for.end.i:                                        ; preds = %cond.end.i, %if.end10.i
  %.lcssa.i = phi i32 [ %5, %if.end10.i ], [ %11, %cond.end.i ]
  br i1 %transaction.0.shrunk11.i, label %if.then19.i, label %if.end20.i

if.then19.i:                                      ; preds = %for.end.i
  tail call fastcc void @propagateNow(i32 noundef -1, ptr noundef nonnull getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 50), i32 noundef 1, i32 noundef 3)
  %.pr.i = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  br label %if.end20.i

if.end20.i:                                       ; preds = %if.then19.i, %for.end.i
  %13 = phi i32 [ %.pr.i, %if.then19.i ], [ %.lcssa.i, %for.end.i ]
  %tobool.not11.i.i = icmp eq i32 %13, 0
  br i1 %tobool.not11.i.i, label %propagatePendingCommands.exit, label %while.body.i.i

while.body.i.i:                                   ; preds = %if.end20.i, %for.end.i.i
  %14 = phi i32 [ %22, %for.end.i.i ], [ %13, %if.end20.i ]
  %dec.i.i = add nsw i32 %14, -1
  store i32 %dec.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248), align 8
  %idx.ext.i.i = sext i32 %dec.i.i to i64
  %add.ptr.i.i = getelementptr inbounds %struct.redisOp, ptr %15, i64 %idx.ext.i.i
  %argc.i.i = getelementptr inbounds %struct.redisOp, ptr %15, i64 %idx.ext.i.i, i32 1
  %16 = load i32, ptr %argc.i.i, align 8
  %cmp9.i.i = icmp sgt i32 %16, 0
  br i1 %cmp9.i.i, label %for.body.i.i, label %for.end.i.i

for.body.i.i:                                     ; preds = %while.body.i.i, %for.body.i.i
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %for.body.i.i ], [ 0, %while.body.i.i ]
  %17 = load ptr, ptr %add.ptr.i.i, align 8
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %17, i64 %indvars.iv.i.i
  %18 = load ptr, ptr %arrayidx.i.i, align 8
  tail call void @decrRefCount(ptr noundef %18) #38
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %19 = load i32, ptr %argc.i.i, align 8
  %20 = sext i32 %19 to i64
  %cmp.i.i = icmp slt i64 %indvars.iv.next.i.i, %20
  br i1 %cmp.i.i, label %for.body.i.i, label %for.end.i.i, !llvm.loop !40

for.end.i.i:                                      ; preds = %for.body.i.i, %while.body.i.i
  %21 = load ptr, ptr %add.ptr.i.i, align 8
  tail call void @zfree(ptr noundef %21) #38
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 248, i32 1), align 8
  %tobool.not.i.i = icmp eq i32 %22, 0
  br i1 %tobool.not.i.i, label %propagatePendingCommands.exit, label %while.body.i.i, !llvm.loop !41

propagatePendingCommands.exit:                    ; preds = %for.end.i.i, %if.end, %if.end20.i
  tail call void @modulePostExecutionUnitOperations() #38
  br label %return

return:                                           ; preds = %entry, %propagatePendingCommands.exit
  ret void
}

declare void @firePostExecutionUnitJobs() local_unnamed_addr #4

declare void @modulePostExecutionUnitOperations() local_unnamed_addr #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable
define dso_local noundef i32 @incrCommandStatsOnError(ptr noundef %cmd, i32 noundef %flags) local_unnamed_addr #27 {
entry:
  %tobool.not = icmp eq ptr %cmd, null
  br i1 %tobool.not, label %if.end10, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  %1 = load i64, ptr @incrCommandStatsOnError.prev_err_count, align 8
  %cmp = icmp sgt i64 %0, %1
  br i1 %cmp, label %if.then1, label %if.end10

if.then1:                                         ; preds = %if.then
  %and = and i32 %flags, 1
  %tobool2.not = icmp eq i32 %and, 0
  br i1 %tobool2.not, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.then1
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 24
  br label %if.end10.sink.split

if.else:                                          ; preds = %if.then1
  %and4 = and i32 %flags, 2
  %tobool5.not = icmp eq i32 %and4, 0
  br i1 %tobool5.not, label %if.end10, label %if.then6

if.then6:                                         ; preds = %if.else
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 25
  br label %if.end10.sink.split

if.end10.sink.split:                              ; preds = %if.then3, %if.then6
  %failed_calls.sink4 = phi ptr [ %failed_calls, %if.then6 ], [ %rejected_calls, %if.then3 ]
  %2 = load i64, ptr %failed_calls.sink4, align 8
  %inc7 = add nsw i64 %2, 1
  store i64 %inc7, ptr %failed_calls.sink4, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.end10.sink.split, %if.then, %if.else, %entry
  %res.0 = phi i32 [ 0, %if.else ], [ 0, %if.then ], [ 0, %entry ], [ 1, %if.end10.sink.split ]
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  store i64 %3, ptr @incrCommandStatsOnError.prev_err_count, align 8
  ret i32 %res.0
}

; Function Attrs: nounwind uwtable
define dso_local void @call(ptr noundef %c, i32 noundef %flags) local_unnamed_addr #0 {
entry:
  %tv.i94 = alloca %struct.timeval, align 8
  %tv.i.i = alloca %struct.timeval, align 8
  %tv.i = alloca %struct.timeval, align 8
  %flags1 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %0 = load i64, ptr %flags1, align 8
  %realcmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 19
  %1 = load ptr, ptr %realcmd, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 62), align 8
  store ptr %c, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 62), align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %tobool.not = icmp eq ptr %3, null
  br i1 %tobool.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %4 = load i64, ptr %3, align 8
  %cmp = icmp eq i64 %4, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %and = and i32 %flags, 4
  %6 = load i64, ptr %flags1, align 8
  %and4 = and i64 %6, -1622017
  store i64 %and4, ptr %flags1, align 8
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %9 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  store i64 %9, ptr @incrCommandStatsOnError.prev_err_count, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i)
  %call.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i, ptr noundef null) #38
  %10 = load i64, ptr %tv.i, align 8
  %mul.i = mul nsw i64 %10, 1000000
  %tv_usec.i = getelementptr inbounds %struct.timeval, ptr %tv.i, i64 0, i32 1
  %11 = load i64, ptr %tv_usec.i, align 8
  %add.i = add nsw i64 %mul.i, %11
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i)
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %inc.i = add nsw i32 %12, 1
  store i32 %inc.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %cmp.i = icmp eq i32 %12, 0
  br i1 %cmp.i, label %if.then.i, label %enterExecutionUnit.exit

if.then.i:                                        ; preds = %land.end
  %cmp1.i = icmp eq i64 %add.i, 0
  br i1 %cmp1.i, label %if.then2.i, label %if.end.i

if.then2.i:                                       ; preds = %if.then.i
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i.i)
  %call.i.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i.i, ptr noundef null) #38
  %13 = load i64, ptr %tv.i.i, align 8
  %mul.i.i = mul nsw i64 %13, 1000000
  %tv_usec.i.i = getelementptr inbounds %struct.timeval, ptr %tv.i.i, i64 0, i32 1
  %14 = load i64, ptr %tv_usec.i.i, align 8
  %add.i.i = add nsw i64 %mul.i.i, %14
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i.i)
  br label %if.end.i

if.end.i:                                         ; preds = %if.then2.i, %if.then.i
  %us.addr.0.i = phi i64 [ %add.i.i, %if.then2.i ], [ %add.i, %if.then.i ]
  store i64 %us.addr.0.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %div.i.i = sdiv i64 %us.addr.0.i, 1000
  store i64 %div.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %div1.i.i = sdiv i64 %us.addr.0.i, 1000000
  store atomic i64 %div1.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) monotonic, align 8
  store i64 %div.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 354), align 8
  br label %enterExecutionUnit.exit

enterExecutionUnit.exit:                          ; preds = %land.end, %if.end.i
  %15 = load i64, ptr %flags1, align 8
  %or = or i64 %15, 536870912
  store i64 %or, ptr %flags1, align 8
  %call7 = tail call i32 @monotonicGetType() #38
  %cmp8 = icmp eq i32 %call7, 1
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %enterExecutionUnit.exit
  %16 = load ptr, ptr @getMonotonicUs, align 8
  %call9 = tail call i64 %16() #38
  br label %if.end

if.end:                                           ; preds = %if.then, %enterExecutionUnit.exit
  %monotonic_start.0 = phi i64 [ %call9, %if.then ], [ 0, %enterExecutionUnit.exit ]
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %17 = load ptr, ptr %cmd, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %17, i64 0, i32 12
  %18 = load ptr, ptr %proc, align 8
  tail call void %18(ptr noundef nonnull %c) #38
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %dec.i = add nsw i32 %19, -1
  store i32 %dec.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %20 = load i64, ptr %flags1, align 8
  %and11 = and i64 %20, 16
  %tobool12.not = icmp eq i64 %and11, 0
  br i1 %tobool12.not, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end
  %and15 = and i64 %20, -536870929
  store i64 %and15, ptr %flags1, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end
  %call17 = tail call i32 @monotonicGetType() #38
  %cmp18 = icmp eq i32 %call17, 1
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  %21 = load ptr, ptr @getMonotonicUs, align 8
  %call20 = tail call i64 %21() #38
  %sub = sub i64 %call20, %monotonic_start.0
  br label %if.end23

if.else:                                          ; preds = %if.end16
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i94)
  %call.i95 = call i32 @gettimeofday(ptr noundef nonnull %tv.i94, ptr noundef null) #38
  %22 = load i64, ptr %tv.i94, align 8
  %mul.i96 = mul nsw i64 %22, 1000000
  %tv_usec.i97 = getelementptr inbounds %struct.timeval, ptr %tv.i94, i64 0, i32 1
  %23 = load i64, ptr %tv_usec.i97, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i94)
  %add.i98 = sub i64 %23, %add.i
  %sub22 = add i64 %add.i98, %mul.i96
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then19
  %duration.0 = phi i64 [ %sub, %if.then19 ], [ %sub22, %if.else ]
  %duration24 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 29
  %24 = load i64, ptr %duration24, align 8
  %add = add nsw i64 %24, %duration.0
  store i64 %add, ptr %duration24, align 8
  %25 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  %tobool.not.i = icmp ne ptr %1, null
  %.pre = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  %26 = load i64, ptr @incrCommandStatsOnError.prev_err_count, align 8
  %cmp.i100 = icmp sgt i64 %.pre, %26
  %or.cond = select i1 %tobool.not.i, i1 %cmp.i100, i1 false
  br i1 %or.cond, label %incrCommandStatsOnError.exit, label %land.lhs.true

incrCommandStatsOnError.exit:                     ; preds = %if.end23
  %failed_calls.i = getelementptr inbounds %struct.redisCommand, ptr %1, i64 0, i32 25
  %27 = load i64, ptr %failed_calls.i, align 8
  %inc7.i = add nsw i64 %27, 1
  store i64 %inc7.i, ptr %failed_calls.i, align 8
  %28 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  store i64 %28, ptr @incrCommandStatsOnError.prev_err_count, align 8
  br label %if.end33

land.lhs.true:                                    ; preds = %if.end23
  store i64 %.pre, ptr @incrCommandStatsOnError.prev_err_count, align 8
  %deferred_reply_errors = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 26
  %29 = load ptr, ptr %deferred_reply_errors, align 8
  %tobool31.not = icmp eq ptr %29, null
  br i1 %tobool31.not, label %if.end33, label %if.then32

if.then32:                                        ; preds = %land.lhs.true
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %1, i64 0, i32 25
  %30 = load i64, ptr %failed_calls, align 8
  %inc = add nsw i64 %30, 1
  store i64 %inc, ptr %failed_calls, align 8
  br label %if.end33

if.end33:                                         ; preds = %incrCommandStatsOnError.exit, %if.then32, %land.lhs.true
  %31 = load i64, ptr %flags1, align 8
  %and35 = and i64 %31, 1099511627776
  %tobool36.not = icmp eq i64 %and35, 0
  br i1 %tobool36.not, label %if.end42, label %if.then37

if.then37:                                        ; preds = %if.end33
  %and39 = and i64 %31, -1099511627841
  %or41 = or disjoint i64 %and39, 64
  store i64 %or41, ptr %flags1, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.then37, %if.end33
  br i1 %5, label %if.end88, label %if.then44

if.then44:                                        ; preds = %if.end42
  %flags45 = getelementptr inbounds %struct.redisCommand, ptr %1, i64 0, i32 14
  %32 = load i64, ptr %flags45, align 8
  %and46 = and i64 %32, 16384
  %tobool47.not = icmp eq i64 %and46, 0
  %cond48 = select i1 %tobool47.not, ptr @.str.169, ptr @.str.168
  %33 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %tobool49.not = icmp eq i64 %33, 0
  br i1 %tobool49.not, label %if.end54, label %land.lhs.true50

land.lhs.true50:                                  ; preds = %if.then44
  %div = sdiv i64 %duration.0, 1000
  %cmp51.not = icmp slt i64 %div, %33
  br i1 %cmp51.not, label %if.end54, label %if.then52

if.then52:                                        ; preds = %land.lhs.true50
  tail call void @latencyAddSample(ptr noundef nonnull %cond48, i64 noundef %div) #38
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %land.lhs.true50, %if.then44
  %34 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %cmp55 = icmp eq i32 %34, 0
  br i1 %cmp55, label %if.then56, label %land.lhs.true60

if.then56:                                        ; preds = %if.end54
  tail call void @durationAddSample(i32 noundef 1, i64 noundef %duration.0) #38
  br label %land.lhs.true60

land.lhs.true60:                                  ; preds = %if.then56, %if.end54
  %35 = load i64, ptr %flags1, align 8
  %and62 = and i64 %35, 16
  %tobool63.not = icmp eq i64 %and62, 0
  br i1 %tobool63.not, label %if.then64, label %if.end66

if.then64:                                        ; preds = %land.lhs.true60
  %36 = load i64, ptr %duration24, align 8
  %37 = load i64, ptr %flags45, align 8
  %and.i = and i64 %37, 4096
  %tobool.not.i101 = icmp eq i64 %and.i, 0
  br i1 %tobool.not.i101, label %if.end.i102, label %if.end66

if.end.i102:                                      ; preds = %if.then64
  %original_argv.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 15
  %38 = load ptr, ptr %original_argv.i, align 8
  %tobool1.not.i = icmp eq ptr %38, null
  br i1 %tobool1.not.i, label %cond.false.i, label %cond.end.i

cond.false.i:                                     ; preds = %if.end.i102
  %argv3.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %39 = load ptr, ptr %argv3.i, align 8
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %if.end.i102
  %cond.i = phi ptr [ %39, %cond.false.i ], [ %38, %if.end.i102 ]
  %original_argc.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 14
  %argc8.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %cond10.in.i = select i1 %tobool1.not.i, ptr %argc8.i, ptr %original_argc.i
  %cond10.i = load i32, ptr %cond10.in.i, align 4
  tail call void @slowlogPushEntryIfNeeded(ptr noundef nonnull %c, ptr noundef %cond.i, i32 noundef %cond10.i, i64 noundef %36) #38
  br label %if.end66

if.end66:                                         ; preds = %cond.end.i, %if.then64, %land.lhs.true60
  %tobool69.not = icmp eq i32 %and, 0
  br i1 %tobool69.not, label %land.lhs.true70, label %if.end88

land.lhs.true70:                                  ; preds = %if.end66
  %40 = load ptr, ptr %cmd, align 8
  %flags72 = getelementptr inbounds %struct.redisCommand, ptr %40, i64 0, i32 14
  %41 = load i64, ptr %flags72, align 8
  %and73 = and i64 %41, 2064
  %tobool74.not = icmp eq i64 %and73, 0
  br i1 %tobool74.not, label %if.then75, label %if.end88

if.then75:                                        ; preds = %land.lhs.true70
  %original_argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 15
  %42 = load ptr, ptr %original_argv, align 8
  %tobool76.not = icmp eq ptr %42, null
  br i1 %tobool76.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then75
  %argv78 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %43 = load ptr, ptr %argv78, align 8
  br label %cond.end

cond.end:                                         ; preds = %if.then75, %cond.false
  %cond79 = phi ptr [ %43, %cond.false ], [ %42, %if.then75 ]
  %original_argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 14
  %argc84 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %cond86.in = select i1 %tobool76.not, ptr %argc84, ptr %original_argc
  %cond86 = load i32, ptr %cond86.in, align 4
  %44 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 60), align 8
  %db = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 4
  %45 = load ptr, ptr %db, align 8
  %id87 = getelementptr inbounds %struct.redisDb, ptr %45, i64 0, i32 6
  %46 = load i32, ptr %id87, align 8
  tail call void @replicationFeedMonitors(ptr noundef nonnull %c, ptr noundef %44, i32 noundef %46, ptr noundef %cond79, i32 noundef %cond86) #38
  br label %if.end88

if.end88:                                         ; preds = %if.end42, %cond.end, %land.lhs.true70, %if.end66
  %47 = load i64, ptr %flags1, align 8
  %and90 = and i64 %47, 16
  %tobool91.not = icmp eq i64 %and90, 0
  br i1 %tobool91.not, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.end88
  tail call void @freeClientOriginalArgv(ptr noundef nonnull %c) #38
  %.pre114.pre = load i64, ptr %flags1, align 8
  br label %if.end93

if.end93:                                         ; preds = %if.then92, %if.end88
  %.pre114 = phi i64 [ %.pre114.pre, %if.then92 ], [ %47, %if.end88 ]
  %and97 = and i64 %.pre114, 16
  %tobool98.not = icmp ne i64 %and97, 0
  %or.cond120.not = select i1 %5, i1 true, i1 %tobool98.not
  br i1 %or.cond120.not, label %if.end111, label %if.then99

if.then99:                                        ; preds = %if.end93
  %calls = getelementptr inbounds %struct.redisCommand, ptr %1, i64 0, i32 23
  %48 = load i64, ptr %calls, align 8
  %inc100 = add nsw i64 %48, 1
  store i64 %inc100, ptr %calls, align 8
  %49 = load i64, ptr %duration24, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %1, i64 0, i32 22
  %50 = load i64, ptr %microseconds, align 8
  %add102 = add nsw i64 %50, %49
  store i64 %add102, ptr %microseconds, align 8
  %51 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 181), align 4
  %tobool103.not = icmp ne i32 %51, 0
  %.pre113 = load i64, ptr %flags1, align 8
  %and106 = and i64 %.pre113, 16
  %tobool107.not = icmp eq i64 %and106, 0
  %or.cond121 = select i1 %tobool103.not, i1 %tobool107.not, i1 false
  br i1 %or.cond121, label %if.then108, label %if.end111

if.then108:                                       ; preds = %if.then99
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %1, i64 0, i32 28
  %52 = load i64, ptr %duration24, align 8
  %mul = mul nsw i64 %52, 1000
  %53 = load ptr, ptr %latency_histogram, align 8
  %cmp4.i = icmp eq ptr %53, null
  br i1 %cmp4.i, label %if.then5.i, label %updateCommandLatencyHistogram.exit

if.then5.i:                                       ; preds = %if.then108
  %call.i103 = tail call i32 @hdr_init(i64 noundef 1, i64 noundef 1000000000, i32 noundef 2, ptr noundef nonnull %latency_histogram) #38
  %.pre.i = load ptr, ptr %latency_histogram, align 8
  br label %updateCommandLatencyHistogram.exit

updateCommandLatencyHistogram.exit:               ; preds = %if.then108, %if.then5.i
  %54 = phi ptr [ %.pre.i, %if.then5.i ], [ %53, %if.then108 ]
  %spec.store.select.i = tail call i64 @llvm.smax.i64(i64 %mul, i64 1)
  %spec.store.select1.i = tail call i64 @llvm.umin.i64(i64 %spec.store.select.i, i64 1000000000)
  %call7.i = tail call zeroext i1 @hdr_record_value(ptr noundef %54, i64 noundef %spec.store.select1.i) #38
  %.pre112 = load i64, ptr %flags1, align 8
  br label %if.end111

if.end111:                                        ; preds = %if.then99, %updateCommandLatencyHistogram.exit, %if.end93
  %55 = phi i64 [ %.pre113, %if.then99 ], [ %.pre112, %updateCommandLatencyHistogram.exit ], [ %.pre114, %if.end93 ]
  %and113 = and i64 %55, 16
  %tobool114.not = icmp eq i64 %and113, 0
  br i1 %tobool114.not, label %if.then115, label %if.end117

if.then115:                                       ; preds = %if.end111
  store i64 0, ptr %duration24, align 8
  br label %if.end117

if.end117:                                        ; preds = %if.then115, %if.end111
  %and118 = and i32 %flags, 3
  %tobool119.not = icmp eq i32 %and118, 0
  %and122 = and i64 %55, 1572864
  %cmp123.not = icmp eq i64 %and122, 1572864
  %or.cond111 = or i1 %tobool119.not, %cmp123.not
  %.pre117 = load ptr, ptr %cmd, align 8
  br i1 %or.cond111, label %if.end182, label %land.lhs.true124

land.lhs.true124:                                 ; preds = %if.end117
  %proc126 = getelementptr inbounds %struct.redisCommand, ptr %.pre117, i64 0, i32 12
  %56 = load ptr, ptr %proc126, align 8
  %cmp127.not = icmp eq ptr %56, @execCommand
  br i1 %cmp127.not, label %if.end182, label %land.lhs.true128

land.lhs.true128:                                 ; preds = %land.lhs.true124
  %flags130 = getelementptr inbounds %struct.redisCommand, ptr %.pre117, i64 0, i32 14
  %57 = load i64, ptr %flags130, align 8
  %and131 = and i64 %57, 8
  %tobool132.not = icmp eq i64 %and131, 0
  br i1 %tobool132.not, label %if.then133, label %if.end182

if.then133:                                       ; preds = %land.lhs.true128
  %tobool134.not.not = icmp sgt i64 %25, %7
  %58 = trunc i64 %55 to i32
  %59 = lshr i32 %58, 14
  %60 = and i32 %59, 3
  %propagate_flags.2 = select i1 %tobool134.not.not, i32 3, i32 %60
  %61 = and i64 %55, 562949954469888
  %or.cond88 = icmp ne i64 %61, 0
  %and157 = and i32 %flags, 2
  %tobool158.not = icmp eq i32 %and157, 0
  %or.cond89 = or i1 %tobool158.not, %or.cond88
  %and160 = and i32 %propagate_flags.2, 1
  %propagate_flags.3 = select i1 %or.cond89, i32 %and160, i32 %propagate_flags.2
  %62 = and i64 %55, 281474977234944
  %or.cond90 = icmp ne i64 %62, 0
  %and170 = and i32 %flags, 1
  %tobool171.not = icmp eq i32 %and170, 0
  %or.cond91 = or i1 %tobool171.not, %or.cond90
  %and173 = and i32 %propagate_flags.3, 2
  %propagate_flags.4 = select i1 %or.cond91, i32 %and173, i32 %propagate_flags.3
  %cmp175.not = icmp eq i32 %propagate_flags.4, 0
  br i1 %cmp175.not, label %if.end182, label %if.then176

if.then176:                                       ; preds = %if.then133
  %db177 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 4
  %63 = load ptr, ptr %db177, align 8
  %id178 = getelementptr inbounds %struct.redisDb, ptr %63, i64 0, i32 6
  %64 = load i32, ptr %id178, align 8
  %argv179 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %65 = load ptr, ptr %argv179, align 8
  %argc180 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %66 = load i32, ptr %argc180, align 8
  tail call void @alsoPropagate(i32 noundef %64, ptr noundef %65, i32 noundef %66, i32 noundef %propagate_flags.4)
  %.pre115 = load i64, ptr %flags1, align 8
  %.pre116 = load ptr, ptr %cmd, align 8
  br label %if.end182

if.end182:                                        ; preds = %if.then133, %if.then176, %land.lhs.true128, %land.lhs.true124, %if.end117
  %67 = phi ptr [ %.pre117, %if.then133 ], [ %.pre116, %if.then176 ], [ %.pre117, %land.lhs.true128 ], [ %.pre117, %land.lhs.true124 ], [ %.pre117, %if.end117 ]
  %68 = phi i64 [ %55, %if.then133 ], [ %.pre115, %if.then176 ], [ %55, %land.lhs.true128 ], [ %55, %land.lhs.true124 ], [ %55, %if.end117 ]
  %and184 = and i64 %68, -1622017
  %and185 = and i64 %0, 1622016
  %or187 = or disjoint i64 %and184, %and185
  store i64 %or187, ptr %flags1, align 8
  %flags189 = getelementptr inbounds %struct.redisCommand, ptr %67, i64 0, i32 14
  %69 = load i64, ptr %flags189, align 8
  %and190 = and i64 %69, 2
  %tobool191.not = icmp eq i64 %and190, 0
  br i1 %tobool191.not, label %if.end216, label %land.lhs.true192

land.lhs.true192:                                 ; preds = %if.end182
  %proc194 = getelementptr inbounds %struct.redisCommand, ptr %67, i64 0, i32 12
  %70 = load ptr, ptr %proc194, align 8
  %cmp195.not = icmp eq ptr %70, @evalRoCommand
  %cmp199.not = icmp eq ptr %70, @evalShaRoCommand
  %or.cond92 = or i1 %cmp195.not, %cmp199.not
  br i1 %or.cond92, label %if.end216, label %land.lhs.true200

land.lhs.true200:                                 ; preds = %land.lhs.true192
  %cmp203 = icmp ne ptr %70, @fcallroCommand
  %71 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %tobool205 = icmp ne ptr %71, null
  %or.cond2 = select i1 %cmp203, i1 %tobool205, i1 false
  br i1 %or.cond2, label %land.lhs.true206, label %if.end216

land.lhs.true206:                                 ; preds = %land.lhs.true200
  %flags207 = getelementptr inbounds %struct.client, ptr %71, i64 0, i32 1
  %72 = load i64, ptr %flags207, align 8
  %73 = and i64 %72, 10737418240
  %or.cond93 = icmp eq i64 %73, 2147483648
  br i1 %or.cond93, label %if.then214, label %if.end216

if.then214:                                       ; preds = %land.lhs.true206
  tail call void @trackingRememberKeys(ptr noundef nonnull %71, ptr noundef nonnull %c) #38
  %.pre118 = load i64, ptr %flags1, align 8
  br label %if.end216

if.end216:                                        ; preds = %land.lhs.true206, %if.then214, %land.lhs.true200, %land.lhs.true192, %if.end182
  %74 = phi i64 [ %or187, %land.lhs.true206 ], [ %.pre118, %if.then214 ], [ %or187, %land.lhs.true200 ], [ %or187, %land.lhs.true192 ], [ %or187, %if.end182 ]
  %and218 = and i64 %74, 16
  %tobool219.not = icmp eq i64 %and218, 0
  br i1 %tobool219.not, label %if.then220, label %if.end222

if.then220:                                       ; preds = %if.end216
  %75 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 89), align 8
  %inc221 = add nsw i64 %75, 1
  store i64 %inc221, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 89), align 8
  br label %if.end222

if.end222:                                        ; preds = %if.then220, %if.end216
  %call223 = tail call i64 @zmalloc_used_memory() #38
  %76 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  %cmp224 = icmp ugt i64 %call223, %76
  br i1 %cmp224, label %if.then225, label %if.end226

if.then225:                                       ; preds = %if.end222
  store i64 %call223, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  br label %if.end226

if.end226:                                        ; preds = %if.then225, %if.end222
  tail call void @postExecutionUnitOperations()
  tail call void @trackingHandlePendingKeyInvalidations() #38
  %77 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %tobool.not.i104 = icmp eq i32 %77, 0
  br i1 %tobool.not.i104, label %if.then.i106, label %afterCommand.exit

if.then.i106:                                     ; preds = %if.end226
  %reply.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 24
  %78 = load ptr, ptr %reply.i, align 8
  %79 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 332), align 8
  tail call void @listJoin(ptr noundef %78, ptr noundef %79) #38
  br label %afterCommand.exit

afterCommand.exit:                                ; preds = %if.end226, %if.then.i106
  %80 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %cmp227.not = icmp eq i64 %8, %80
  br i1 %cmp227.not, label %if.end229, label %if.then228

if.then228:                                       ; preds = %afterCommand.exit
  %woff = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 56
  store i64 %80, ptr %woff, align 8
  br label %if.end229

if.end229:                                        ; preds = %if.then228, %afterCommand.exit
  %81 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 30), align 4
  %tobool230 = icmp eq i32 %81, 0
  %82 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 34), align 8
  %tobool232 = icmp ne i32 %82, 0
  %or.cond1 = select i1 %tobool230, i1 %tobool232, i1 false
  br i1 %or.cond1, label %if.then233, label %if.end234

if.then233:                                       ; preds = %if.end229
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 34), align 8
  br label %if.end234

if.end234:                                        ; preds = %if.then233, %if.end229
  store ptr %2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 62), align 8
  ret void
}

declare i32 @monotonicGetType() local_unnamed_addr #4

declare void @replicationFeedMonitors(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare void @freeClientOriginalArgv(ptr noundef) local_unnamed_addr #4

declare void @execCommand(ptr noundef) #4

declare void @evalRoCommand(ptr noundef) #4

declare void @evalShaRoCommand(ptr noundef) #4

declare void @fcallroCommand(ptr noundef) #4

declare void @trackingRememberKeys(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @afterCommand(ptr nocapture noundef readonly %c) local_unnamed_addr #0 {
entry:
  tail call void @postExecutionUnitOperations()
  tail call void @trackingHandlePendingKeyInvalidations() #38
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 65), align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %reply = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 24
  %1 = load ptr, ptr %reply, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 332), align 8
  tail call void @listJoin(ptr noundef %1, ptr noundef %2) #38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @rejectCommand(ptr noundef %c, ptr noundef %reply) local_unnamed_addr #0 {
entry:
  tail call void @flagTransaction(ptr noundef %c) #38
  %duration = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 29
  store i64 0, ptr %duration, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %0 = load ptr, ptr %cmd, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.else, label %if.end

if.end:                                           ; preds = %entry
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 24
  %1 = load i64, ptr %rejected_calls, align 8
  %inc = add nsw i64 %1, 1
  store i64 %inc, ptr %rejected_calls, align 8
  %.pr = load ptr, ptr %cmd, align 8
  %tobool3.not = icmp eq ptr %.pr, null
  br i1 %tobool3.not, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %proc = getelementptr inbounds %struct.redisCommand, ptr %.pr, i64 0, i32 12
  %2 = load ptr, ptr %proc, align 8
  %cmp = icmp eq ptr %2, @execCommand
  br i1 %cmp, label %if.then5, label %if.else

if.then5:                                         ; preds = %land.lhs.true
  %ptr = getelementptr inbounds %struct.redisObject, ptr %reply, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  tail call void @execCommandAbort(ptr noundef nonnull %c, ptr noundef %3) #38
  br label %if.end6

if.else:                                          ; preds = %entry, %land.lhs.true, %if.end
  tail call void @addReplyErrorObject(ptr noundef nonnull %c, ptr noundef %reply) #38
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then5
  ret void
}

declare void @flagTransaction(ptr noundef) local_unnamed_addr #4

declare void @execCommandAbort(ptr noundef, ptr noundef) local_unnamed_addr #4

declare void @addReplyErrorObject(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @rejectCommandSds(ptr noundef %c, ptr noundef %s) local_unnamed_addr #0 {
entry:
  tail call void @flagTransaction(ptr noundef %c) #38
  %duration = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 29
  store i64 0, ptr %duration, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %0 = load ptr, ptr %cmd, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.else, label %if.end

if.end:                                           ; preds = %entry
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 24
  %1 = load i64, ptr %rejected_calls, align 8
  %inc = add nsw i64 %1, 1
  store i64 %inc, ptr %rejected_calls, align 8
  %.pr = load ptr, ptr %cmd, align 8
  %tobool3.not = icmp eq ptr %.pr, null
  br i1 %tobool3.not, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %proc = getelementptr inbounds %struct.redisCommand, ptr %.pr, i64 0, i32 12
  %2 = load ptr, ptr %proc, align 8
  %cmp = icmp eq ptr %2, @execCommand
  br i1 %cmp, label %if.then5, label %if.else

if.then5:                                         ; preds = %land.lhs.true
  tail call void @execCommandAbort(ptr noundef nonnull %c, ptr noundef %s) #38
  tail call void @sdsfree(ptr noundef %s) #38
  br label %if.end6

if.else:                                          ; preds = %entry, %land.lhs.true, %if.end
  tail call void @addReplyErrorSds(ptr noundef nonnull %c, ptr noundef %s) #38
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then5
  ret void
}

declare void @addReplyErrorSds(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @rejectCommandFormat(ptr noundef %c, ptr noundef %fmt, ...) local_unnamed_addr #0 {
entry:
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  call void @llvm.va_start(ptr nonnull %ap)
  %call = call ptr @sdsempty() #38
  %call2 = call ptr @sdscatvprintf(ptr noundef %call, ptr noundef %fmt, ptr noundef nonnull %ap) #38
  call void @llvm.va_end(ptr nonnull %ap)
  %call4 = call ptr @sdsmapchars(ptr noundef %call2, ptr noundef nonnull @.str.170, ptr noundef nonnull @.str.171, i64 noundef 2) #38
  call void @flagTransaction(ptr noundef %c) #38
  %duration.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 29
  store i64 0, ptr %duration.i, align 8
  %cmd.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %0 = load ptr, ptr %cmd.i, align 8
  %tobool.not.i = icmp eq ptr %0, null
  br i1 %tobool.not.i, label %if.else.i, label %if.end.i

if.end.i:                                         ; preds = %entry
  %rejected_calls.i = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 24
  %1 = load i64, ptr %rejected_calls.i, align 8
  %inc.i = add nsw i64 %1, 1
  store i64 %inc.i, ptr %rejected_calls.i, align 8
  %.pr.i = load ptr, ptr %cmd.i, align 8
  %tobool3.not.i = icmp eq ptr %.pr.i, null
  br i1 %tobool3.not.i, label %if.else.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %proc.i = getelementptr inbounds %struct.redisCommand, ptr %.pr.i, i64 0, i32 12
  %2 = load ptr, ptr %proc.i, align 8
  %cmp.i = icmp eq ptr %2, @execCommand
  br i1 %cmp.i, label %if.then5.i, label %if.else.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  call void @execCommandAbort(ptr noundef nonnull %c, ptr noundef %call2) #38
  call void @sdsfree(ptr noundef %call2) #38
  br label %rejectCommandSds.exit

if.else.i:                                        ; preds = %land.lhs.true.i, %if.end.i, %entry
  call void @addReplyErrorSds(ptr noundef nonnull %c, ptr noundef %call2) #38
  br label %rejectCommandSds.exit

rejectCommandSds.exit:                            ; preds = %if.then5.i, %if.else.i
  ret void
}

declare ptr @sdscatvprintf(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

declare ptr @sdsmapchars(ptr noundef, ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @trackingHandlePendingKeyInvalidations() local_unnamed_addr #4

declare void @listJoin(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @commandCheckExistence(ptr nocapture noundef readonly %c, ptr noundef %err) local_unnamed_addr #0 {
entry:
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %0 = load ptr, ptr %cmd, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %tobool1.not = icmp eq ptr %err, null
  br i1 %tobool1.not, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %1 = load ptr, ptr %argv, align 8
  %2 = load ptr, ptr %1, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call.i = tail call ptr @dictFetchValue(ptr noundef %4, ptr noundef %3) #38
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %if.else, label %isContainerCommandBySds.exit

isContainerCommandBySds.exit:                     ; preds = %if.end3
  %subcommands_dict.i = getelementptr inbounds %struct.redisCommand, ptr %call.i, i64 0, i32 30
  %5 = load ptr, ptr %subcommands_dict.i, align 8
  %tobool1.i.not = icmp eq ptr %5, null
  br i1 %tobool1.i.not, label %if.else, label %if.then5

if.then5:                                         ; preds = %isContainerCommandBySds.exit
  %6 = load ptr, ptr %argv, align 8
  %7 = load ptr, ptr %6, align 8
  %ptr9 = getelementptr inbounds %struct.redisObject, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %ptr9, align 8
  %call10 = tail call ptr @sdsnew(ptr noundef %8) #38
  tail call void @sdstoupper(ptr noundef %call10) #38
  %call11 = tail call ptr @sdsnew(ptr noundef null) #38
  store ptr %call11, ptr %err, align 8
  %9 = load ptr, ptr %argv, align 8
  %arrayidx13 = getelementptr inbounds ptr, ptr %9, i64 1
  %10 = load ptr, ptr %arrayidx13, align 8
  %ptr14 = getelementptr inbounds %struct.redisObject, ptr %10, i64 0, i32 2
  %11 = load ptr, ptr %ptr14, align 8
  %call15 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call11, ptr noundef nonnull @.str.172, ptr noundef %11, ptr noundef %call10) #38
  br label %if.end29

if.else:                                          ; preds = %if.end3, %isContainerCommandBySds.exit
  %call16 = tail call ptr @sdsempty() #38
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %12 = load i32, ptr %argc, align 8
  %cmp45 = icmp sgt i32 %12, 1
  br i1 %cmp45, label %land.rhs, label %for.end

land.rhs:                                         ; preds = %if.else, %sdslen.exit40
  %indvars.iv = phi i64 [ %indvars.iv.next, %sdslen.exit40 ], [ 1, %if.else ]
  %args.046 = phi ptr [ %call23, %sdslen.exit40 ], [ %call16, %if.else ]
  %arrayidx.i = getelementptr inbounds i8, ptr %args.046, i64 -1
  %13 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %13 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit40 [
    i32 4, label %sw.bb13.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 0, label %sw.bb.i37
  ]

sw.bb3.i:                                         ; preds = %land.rhs
  %add.ptr.i = getelementptr inbounds i8, ptr %args.046, i64 -3
  %14 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %14 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %land.rhs
  %add.ptr6.i = getelementptr inbounds i8, ptr %args.046, i64 -5
  %15 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %15 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %land.rhs
  %add.ptr10.i = getelementptr inbounds i8, ptr %args.046, i64 -9
  %16 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %16 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %land.rhs
  %add.ptr14.i = getelementptr inbounds i8, ptr %args.046, i64 -17
  %17 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %17, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ]
  %cmp18 = icmp ult i64 %retval.0.i, 128
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %sdslen.exit
  switch i32 %and.i, label %sdslen.exit40 [
    i32 4, label %sw.bb13.i25
    i32 1, label %sw.bb3.i34
    i32 2, label %sw.bb5.i31
    i32 3, label %sw.bb9.i28
  ]

sw.bb.i37:                                        ; preds = %land.rhs
  %shr.i38 = lshr i32 %conv.i, 3
  %conv2.i39 = zext nneg i32 %shr.i38 to i64
  br label %sdslen.exit40

sw.bb3.i34:                                       ; preds = %for.body
  %add.ptr.i35 = getelementptr inbounds i8, ptr %args.046, i64 -3
  %18 = load i8, ptr %add.ptr.i35, align 1
  %conv4.i36 = zext i8 %18 to i64
  br label %sdslen.exit40

sw.bb5.i31:                                       ; preds = %for.body
  %add.ptr6.i32 = getelementptr inbounds i8, ptr %args.046, i64 -5
  %19 = load i16, ptr %add.ptr6.i32, align 1
  %conv8.i33 = zext i16 %19 to i64
  br label %sdslen.exit40

sw.bb9.i28:                                       ; preds = %for.body
  %add.ptr10.i29 = getelementptr inbounds i8, ptr %args.046, i64 -9
  %20 = load i32, ptr %add.ptr10.i29, align 1
  %conv12.i30 = zext i32 %20 to i64
  br label %sdslen.exit40

sw.bb13.i25:                                      ; preds = %for.body
  %add.ptr14.i26 = getelementptr inbounds i8, ptr %args.046, i64 -17
  %21 = load i64, ptr %add.ptr14.i26, align 1
  br label %sdslen.exit40

sdslen.exit40:                                    ; preds = %land.rhs, %for.body, %sw.bb.i37, %sw.bb3.i34, %sw.bb5.i31, %sw.bb9.i28, %sw.bb13.i25
  %retval.0.i27 = phi i64 [ %21, %sw.bb13.i25 ], [ %conv12.i30, %sw.bb9.i28 ], [ %conv8.i33, %sw.bb5.i31 ], [ %conv4.i36, %sw.bb3.i34 ], [ %conv2.i39, %sw.bb.i37 ], [ 0, %for.body ], [ 0, %land.rhs ]
  %conv = trunc i64 %retval.0.i27 to i32
  %sub = sub nsw i32 128, %conv
  %22 = load ptr, ptr %argv, align 8
  %arrayidx21 = getelementptr inbounds ptr, ptr %22, i64 %indvars.iv
  %23 = load ptr, ptr %arrayidx21, align 8
  %ptr22 = getelementptr inbounds %struct.redisObject, ptr %23, i64 0, i32 2
  %24 = load ptr, ptr %ptr22, align 8
  %call23 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef nonnull %args.046, ptr noundef nonnull @.str.173, i32 noundef %sub, ptr noundef %24) #38
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %25 = load i32, ptr %argc, align 8
  %26 = sext i32 %25 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %26
  br i1 %cmp, label %land.rhs, label %for.end, !llvm.loop !45

for.end:                                          ; preds = %sdslen.exit, %sdslen.exit40, %if.else
  %args.0.lcssa = phi ptr [ %call16, %if.else ], [ %call23, %sdslen.exit40 ], [ %args.046, %sdslen.exit ]
  %call24 = tail call ptr @sdsnew(ptr noundef null) #38
  store ptr %call24, ptr %err, align 8
  %27 = load ptr, ptr %argv, align 8
  %28 = load ptr, ptr %27, align 8
  %ptr27 = getelementptr inbounds %struct.redisObject, ptr %28, i64 0, i32 2
  %29 = load ptr, ptr %ptr27, align 8
  %call28 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call24, ptr noundef nonnull @.str.174, ptr noundef %29, ptr noundef %args.0.lcssa) #38
  br label %if.end29

if.end29:                                         ; preds = %for.end, %if.then5
  %call28.sink = phi ptr [ %call28, %for.end ], [ %call15, %if.then5 ]
  %args.0.lcssa.sink = phi ptr [ %args.0.lcssa, %for.end ], [ %call10, %if.then5 ]
  store ptr %call28.sink, ptr %err, align 8
  tail call void @sdsfree(ptr noundef %args.0.lcssa.sink) #38
  %30 = load ptr, ptr %err, align 8
  %call30 = tail call ptr @sdsmapchars(ptr noundef %30, ptr noundef nonnull @.str.170, ptr noundef nonnull @.str.171, i64 noundef 2) #38
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end29
  %retval.0 = phi i32 [ 0, %if.end29 ], [ 1, %entry ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare void @sdstoupper(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @commandCheckArity(ptr nocapture noundef readonly %c, ptr noundef writeonly %err) local_unnamed_addr #0 {
entry:
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %0 = load ptr, ptr %cmd, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 13
  %1 = load i32, ptr %arity, align 8
  %cmp = icmp sgt i32 %1, 0
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %2 = load i32, ptr %argc, align 8
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %cmp3.not = icmp eq i32 %1, %2
  br i1 %cmp3.not, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry, %land.lhs.true
  %3 = phi i32 [ %1, %land.lhs.true ], [ %2, %entry ]
  %sub = sub nsw i32 0, %1
  %cmp7 = icmp slt i32 %3, %sub
  br i1 %cmp7, label %if.then, label %return

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %tobool.not = icmp eq ptr %err, null
  br i1 %tobool.not, label %return, label %if.then8

if.then8:                                         ; preds = %if.then
  %call = tail call ptr @sdsnew(ptr noundef null) #38
  store ptr %call, ptr %err, align 8
  %4 = load ptr, ptr %cmd, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %4, i64 0, i32 27
  %5 = load ptr, ptr %fullname, align 8
  %call10 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call, ptr noundef nonnull @.str.175, ptr noundef %5) #38
  store ptr %call10, ptr %err, align 8
  br label %return

return:                                           ; preds = %lor.lhs.false, %if.then, %if.then8
  %retval.0 = phi i32 [ 0, %if.then8 ], [ 0, %if.then ], [ 1, %lor.lhs.false ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i64 @getCommandFlags(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %0 = load ptr, ptr %cmd, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 14
  %1 = load i64, ptr %flags, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %0, i64 0, i32 12
  %2 = load ptr, ptr %proc, align 8
  %cmp = icmp eq ptr %2, @fcallCommand
  %cmp4 = icmp eq ptr %2, @fcallroCommand
  %or.cond = or i1 %cmp, %cmp4
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call i64 @fcallGetCommandFlags(ptr noundef nonnull %c, i64 noundef %1) #38
  br label %if.end22

if.else:                                          ; preds = %entry
  %cmp7 = icmp eq ptr %2, @evalCommand
  %cmp11 = icmp eq ptr %2, @evalRoCommand
  %or.cond11 = or i1 %cmp7, %cmp11
  %cmp15 = icmp eq ptr %2, @evalShaCommand
  %or.cond12 = or i1 %cmp15, %or.cond11
  %cmp19 = icmp eq ptr %2, @evalShaRoCommand
  %or.cond13 = or i1 %cmp19, %or.cond12
  br i1 %or.cond13, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.else
  %call21 = tail call i64 @evalGetCommandFlags(ptr noundef nonnull %c, i64 noundef %1) #38
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then20, %if.then
  %cmd_flags.0 = phi i64 [ %call, %if.then ], [ %call21, %if.then20 ], [ %1, %if.else ]
  ret i64 %cmd_flags.0
}

declare void @fcallCommand(ptr noundef) #4

declare i64 @fcallGetCommandFlags(ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @evalCommand(ptr noundef) #4

declare void @evalShaCommand(ptr noundef) #4

declare i64 @evalGetCommandFlags(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @processCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %err = alloca ptr, align 8
  %acl_errpos = alloca i32, align 4
  %error_code = alloca i32, align 4
  %call = tail call i32 @scriptIsTimedout() #38
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 30), align 4
  %tobool1.not = icmp eq i32 %0, 0
  br i1 %tobool1.not, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.then
  tail call void @_serverAssert(ptr noundef nonnull @.str.176, ptr noundef nonnull @.str.9, i32 noundef 3920) #38
  tail call void @abort() #40
  unreachable

cond.end:                                         ; preds = %if.then
  %call5 = tail call i32 @scriptIsRunning() #38
  %tobool6.not = icmp eq i32 %call5, 0
  br i1 %tobool6.not, label %if.end, label %cond.false16

cond.false16:                                     ; preds = %cond.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.177, ptr noundef nonnull @.str.9, i32 noundef 3921) #38
  tail call void @abort() #40
  unreachable

if.end:                                           ; preds = %cond.end, %entry
  %cmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 17
  %1 = load ptr, ptr %cmd, align 8
  %tobool18.not = icmp eq ptr %1, null
  br i1 %tobool18.not, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end
  tail call void @moduleCallCommandFilters(ptr noundef nonnull %c) #38
  %call21 = tail call i64 @reqresAppendRequest(ptr noundef nonnull %c) #38
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %2 = load ptr, ptr %argv, align 8
  %3 = load ptr, ptr %2, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %ptr, align 8
  %call23 = tail call i32 @strcasecmp(ptr noundef %4, ptr noundef nonnull @.str.178) #39
  %tobool24.not = icmp eq i32 %call23, 0
  br i1 %tobool24.not, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end22
  %call28 = tail call i32 @strcasecmp(ptr noundef %4, ptr noundef nonnull @.str.179) #39
  %tobool29.not = icmp eq i32 %call28, 0
  br i1 %tobool29.not, label %if.then30, label %if.end31

if.then30:                                        ; preds = %lor.lhs.false, %if.end22
  tail call void @securityWarningCommand(ptr noundef nonnull %c) #38
  br label %return

if.end31:                                         ; preds = %lor.lhs.false
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %cmp.not = icmp ne i32 %5, 0
  %and = and i32 %5, 2
  %tobool33.not = icmp eq i32 %and, 0
  %or.cond156 = and i1 %cmp.not, %tobool33.not
  br i1 %or.cond156, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  tail call void @blockPostponeClient(ptr noundef nonnull %c) #38
  br label %return

if.end35:                                         ; preds = %if.end31
  br i1 %tobool18.not, label %if.then37, label %if.end80

if.then37:                                        ; preds = %if.end35
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %6 = load i32, ptr %argc, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call.i.i = tail call ptr @dictFetchValue(ptr noundef %7, ptr noundef %4) #38
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %lookupCommand.exit, label %land.end.i.i

land.end.i.i:                                     ; preds = %if.then37
  %subcommands_dict.i.i = getelementptr inbounds %struct.redisCommand, ptr %call.i.i, i64 0, i32 30
  %8 = load ptr, ptr %subcommands_dict.i.i, align 8
  %tobool1.i.i = icmp ne ptr %8, null
  %cmp.i.i = icmp ne i32 %6, 1
  %or.cond.i.i = select i1 %cmp.i.i, i1 %tobool1.i.i, i1 false
  br i1 %or.cond.i.i, label %if.else.i.i, label %lookupCommand.exit

if.else.i.i:                                      ; preds = %land.end.i.i
  %arrayidx11.i.i = getelementptr inbounds ptr, ptr %2, i64 1
  %9 = load ptr, ptr %arrayidx11.i.i, align 8
  %ptr12.i.i = getelementptr inbounds %struct.redisObject, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %ptr12.i.i, align 8
  %call.i.i.i = tail call ptr @dictFetchValue(ptr noundef nonnull %8, ptr noundef %10) #38
  br label %lookupCommand.exit

lookupCommand.exit:                               ; preds = %if.then37, %land.end.i.i, %if.else.i.i
  %retval.0.i.i = phi ptr [ %call.i.i.i, %if.else.i.i ], [ %call.i.i, %land.end.i.i ], [ null, %if.then37 ]
  %realcmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 19
  store ptr %retval.0.i.i, ptr %realcmd, align 8
  %lastcmd = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 18
  store ptr %retval.0.i.i, ptr %lastcmd, align 8
  store ptr %retval.0.i.i, ptr %cmd, align 8
  %call41 = call i32 @commandCheckExistence(ptr noundef nonnull %c, ptr noundef nonnull %err), !range !13
  %tobool42.not = icmp eq i32 %call41, 0
  br i1 %tobool42.not, label %if.then43, label %if.end44

if.then43:                                        ; preds = %lookupCommand.exit
  %11 = load ptr, ptr %err, align 8
  call void @flagTransaction(ptr noundef nonnull %c) #38
  %duration.i = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 29
  store i64 0, ptr %duration.i, align 8
  %12 = load ptr, ptr %cmd, align 8
  %tobool.not.i = icmp eq ptr %12, null
  br i1 %tobool.not.i, label %if.else.i, label %if.end.i

if.end.i:                                         ; preds = %if.then43
  %rejected_calls.i = getelementptr inbounds %struct.redisCommand, ptr %12, i64 0, i32 24
  %13 = load i64, ptr %rejected_calls.i, align 8
  %inc.i = add nsw i64 %13, 1
  store i64 %inc.i, ptr %rejected_calls.i, align 8
  %.pr.i = load ptr, ptr %cmd, align 8
  %tobool3.not.i = icmp eq ptr %.pr.i, null
  br i1 %tobool3.not.i, label %if.else.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %proc.i = getelementptr inbounds %struct.redisCommand, ptr %.pr.i, i64 0, i32 12
  %14 = load ptr, ptr %proc.i, align 8
  %cmp.i = icmp eq ptr %14, @execCommand
  br i1 %cmp.i, label %if.then5.i, label %if.else.i

if.then5.i:                                       ; preds = %land.lhs.true.i
  call void @execCommandAbort(ptr noundef nonnull %c, ptr noundef %11) #38
  call void @sdsfree(ptr noundef %11) #38
  br label %return

if.else.i:                                        ; preds = %land.lhs.true.i, %if.end.i, %if.then43
  call void @addReplyErrorSds(ptr noundef nonnull %c, ptr noundef %11) #38
  br label %return

if.end44:                                         ; preds = %lookupCommand.exit
  %15 = load ptr, ptr %cmd, align 8
  %arity.i = getelementptr inbounds %struct.redisCommand, ptr %15, i64 0, i32 13
  %16 = load i32, ptr %arity.i, align 8
  %cmp.i175 = icmp sgt i32 %16, 0
  %17 = load i32, ptr %argc, align 8
  br i1 %cmp.i175, label %land.lhs.true.i176, label %lor.lhs.false.i

land.lhs.true.i176:                               ; preds = %if.end44
  %cmp3.not.i = icmp eq i32 %16, %17
  br i1 %cmp3.not.i, label %lor.lhs.false.i, label %if.then47

lor.lhs.false.i:                                  ; preds = %land.lhs.true.i176, %if.end44
  %18 = phi i32 [ %16, %land.lhs.true.i176 ], [ %17, %if.end44 ]
  %sub.i = sub nsw i32 0, %16
  %cmp7.i = icmp slt i32 %18, %sub.i
  br i1 %cmp7.i, label %if.then47, label %if.end48

if.then47:                                        ; preds = %land.lhs.true.i176, %lor.lhs.false.i
  %call.i = call ptr @sdsnew(ptr noundef null) #38
  store ptr %call.i, ptr %err, align 8
  %19 = load ptr, ptr %cmd, align 8
  %fullname.i = getelementptr inbounds %struct.redisCommand, ptr %19, i64 0, i32 27
  %20 = load ptr, ptr %fullname.i, align 8
  %call10.i = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call.i, ptr noundef nonnull @.str.175, ptr noundef %20) #38
  store ptr %call10.i, ptr %err, align 8
  call void @rejectCommandSds(ptr noundef nonnull %c, ptr noundef %call10.i)
  br label %return

if.end48:                                         ; preds = %lor.lhs.false.i
  %flags = getelementptr inbounds %struct.redisCommand, ptr %15, i64 0, i32 14
  %21 = load i64, ptr %flags, align 8
  %and50 = and i64 %21, 1048576
  %tobool51.not = icmp eq i64 %and50, 0
  br i1 %tobool51.not, label %if.end80, label %if.then52

if.then52:                                        ; preds = %if.end48
  %proc = getelementptr inbounds %struct.redisCommand, ptr %15, i64 0, i32 12
  %22 = load ptr, ptr %proc, align 8
  %cmp54 = icmp eq ptr %22, @debugCommand
  br i1 %cmp54, label %land.lhs.true56, label %lor.lhs.false59

land.lhs.true56:                                  ; preds = %if.then52
  %23 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 79), align 4
  %call57 = call i32 @allowProtectedAction(i32 noundef %23, ptr noundef nonnull %c) #38
  %tobool58.not = icmp eq i32 %call57, 0
  br i1 %tobool58.not, label %if.then67, label %land.lhs.true56.lor.lhs.false59_crit_edge

land.lhs.true56.lor.lhs.false59_crit_edge:        ; preds = %land.lhs.true56
  %.pre = load ptr, ptr %cmd, align 8
  %proc61.phi.trans.insert = getelementptr inbounds %struct.redisCommand, ptr %.pre, i64 0, i32 12
  %.pre219 = load ptr, ptr %proc61.phi.trans.insert, align 8
  br label %lor.lhs.false59

lor.lhs.false59:                                  ; preds = %land.lhs.true56.lor.lhs.false59_crit_edge, %if.then52
  %24 = phi ptr [ %.pre219, %land.lhs.true56.lor.lhs.false59_crit_edge ], [ %22, %if.then52 ]
  %cmp62 = icmp eq ptr %24, @moduleCommand
  br i1 %cmp62, label %land.lhs.true64, label %if.end80

land.lhs.true64:                                  ; preds = %lor.lhs.false59
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 80), align 8
  %call65 = call i32 @allowProtectedAction(i32 noundef %25, ptr noundef nonnull %c) #38
  %tobool66.not = icmp eq i32 %call65, 0
  br i1 %tobool66.not, label %if.then67, label %if.end80

if.then67:                                        ; preds = %land.lhs.true64, %land.lhs.true56
  %26 = load ptr, ptr %cmd, align 8
  %proc69 = getelementptr inbounds %struct.redisCommand, ptr %26, i64 0, i32 12
  %27 = load ptr, ptr %proc69, align 8
  %cmp70 = icmp eq ptr %27, @debugCommand
  %cond72 = select i1 %cmp70, ptr @.str.181, ptr @.str.15
  %cond77 = select i1 %cmp70, ptr @.str.182, ptr @.str.183
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.180, ptr noundef nonnull %cond72, ptr noundef nonnull %cond77)
  br label %return

if.end80:                                         ; preds = %if.end48, %land.lhs.true64, %lor.lhs.false59, %if.end35
  %28 = load ptr, ptr %cmd, align 8
  %flags.i = getelementptr inbounds %struct.redisCommand, ptr %28, i64 0, i32 14
  %29 = load i64, ptr %flags.i, align 8
  %proc.i178 = getelementptr inbounds %struct.redisCommand, ptr %28, i64 0, i32 12
  %30 = load ptr, ptr %proc.i178, align 8
  %cmp.i179 = icmp eq ptr %30, @fcallCommand
  %cmp4.i = icmp eq ptr %30, @fcallroCommand
  %or.cond.i = or i1 %cmp.i179, %cmp4.i
  br i1 %or.cond.i, label %if.then.i182, label %if.else.i180

if.then.i182:                                     ; preds = %if.end80
  %call.i183 = call i64 @fcallGetCommandFlags(ptr noundef nonnull %c, i64 noundef %29) #38
  br label %getCommandFlags.exit

if.else.i180:                                     ; preds = %if.end80
  %cmp7.i181 = icmp eq ptr %30, @evalCommand
  %cmp11.i = icmp eq ptr %30, @evalRoCommand
  %or.cond11.i = or i1 %cmp7.i181, %cmp11.i
  %cmp15.i = icmp eq ptr %30, @evalShaCommand
  %or.cond12.i = or i1 %cmp15.i, %or.cond11.i
  %cmp19.i = icmp eq ptr %30, @evalShaRoCommand
  %or.cond13.i = or i1 %cmp19.i, %or.cond12.i
  br i1 %or.cond13.i, label %if.then20.i, label %getCommandFlags.exit

if.then20.i:                                      ; preds = %if.else.i180
  %call21.i = call i64 @evalGetCommandFlags(ptr noundef nonnull %c, i64 noundef %29) #38
  br label %getCommandFlags.exit

getCommandFlags.exit:                             ; preds = %if.then.i182, %if.else.i180, %if.then20.i
  %cmd_flags.0.i = phi i64 [ %call.i183, %if.then.i182 ], [ %call21.i, %if.then20.i ], [ %29, %if.else.i180 ]
  %and82 = and i64 %cmd_flags.0.i, 2
  %tobool83.not = icmp eq i64 %and82, 0
  br i1 %tobool83.not, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %getCommandFlags.exit
  %31 = load ptr, ptr %cmd, align 8
  %proc85 = getelementptr inbounds %struct.redisCommand, ptr %31, i64 0, i32 12
  %32 = load ptr, ptr %proc85, align 8
  %cmp86 = icmp eq ptr %32, @execCommand
  br i1 %cmp86, label %land.rhs, label %lor.end

land.rhs:                                         ; preds = %lor.rhs
  %cmd_flags88 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 54, i32 2
  %33 = load i32, ptr %cmd_flags88, align 4
  %34 = and i32 %33, 2
  %tobool91 = icmp ne i32 %34, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs, %getCommandFlags.exit
  %35 = phi i1 [ true, %getCommandFlags.exit ], [ false, %lor.rhs ], [ %tobool91, %land.rhs ]
  %and92 = and i64 %cmd_flags.0.i, 1
  %tobool93.not = icmp eq i64 %and92, 0
  br i1 %tobool93.not, label %lor.rhs94, label %lor.end106

lor.rhs94:                                        ; preds = %lor.end
  %36 = load ptr, ptr %cmd, align 8
  %proc96 = getelementptr inbounds %struct.redisCommand, ptr %36, i64 0, i32 12
  %37 = load ptr, ptr %proc96, align 8
  %cmp97 = icmp eq ptr %37, @execCommand
  br i1 %cmp97, label %land.rhs99, label %lor.end106

land.rhs99:                                       ; preds = %lor.rhs94
  %cmd_flags101 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 54, i32 2
  %38 = load i32, ptr %cmd_flags101, align 4
  %39 = and i32 %38, 1
  %tobool104 = icmp ne i32 %39, 0
  br label %lor.end106

lor.end106:                                       ; preds = %lor.rhs94, %land.rhs99, %lor.end
  %40 = phi i1 [ true, %lor.end ], [ false, %lor.rhs94 ], [ %tobool104, %land.rhs99 ]
  %and108 = and i64 %cmd_flags.0.i, 4
  %tobool109.not = icmp eq i64 %and108, 0
  br i1 %tobool109.not, label %lor.rhs110, label %lor.end122

lor.rhs110:                                       ; preds = %lor.end106
  %41 = load ptr, ptr %cmd, align 8
  %proc112 = getelementptr inbounds %struct.redisCommand, ptr %41, i64 0, i32 12
  %42 = load ptr, ptr %proc112, align 8
  %cmp113 = icmp eq ptr %42, @execCommand
  br i1 %cmp113, label %land.rhs115, label %lor.end122

land.rhs115:                                      ; preds = %lor.rhs110
  %cmd_flags117 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 54, i32 2
  %43 = load i32, ptr %cmd_flags117, align 4
  %44 = and i32 %43, 4
  %tobool120 = icmp ne i32 %44, 0
  br label %lor.end122

lor.end122:                                       ; preds = %lor.rhs110, %land.rhs115, %lor.end106
  %45 = phi i1 [ true, %lor.end106 ], [ false, %lor.rhs110 ], [ %tobool120, %land.rhs115 ]
  %and124 = and i64 %cmd_flags.0.i, 1024
  %tobool125.not = icmp eq i64 %and124, 0
  br i1 %tobool125.not, label %lor.end137, label %lor.rhs126

lor.rhs126:                                       ; preds = %lor.end122
  %46 = load ptr, ptr %cmd, align 8
  %proc128 = getelementptr inbounds %struct.redisCommand, ptr %46, i64 0, i32 12
  %47 = load ptr, ptr %proc128, align 8
  %cmp129 = icmp eq ptr %47, @execCommand
  br i1 %cmp129, label %land.rhs131, label %lor.end137

land.rhs131:                                      ; preds = %lor.rhs126
  %cmd_inv_flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 54, i32 3
  %48 = load i32, ptr %cmd_inv_flags, align 8
  %49 = and i32 %48, 1024
  %tobool135 = icmp ne i32 %49, 0
  br label %lor.end137

lor.end137:                                       ; preds = %lor.rhs126, %land.rhs131, %lor.end122
  %50 = phi i1 [ true, %lor.end122 ], [ false, %lor.rhs126 ], [ %tobool135, %land.rhs131 ]
  %and139 = and i64 %cmd_flags.0.i, 512
  %tobool140.not = icmp eq i64 %and139, 0
  br i1 %tobool140.not, label %lor.end153, label %lor.rhs141

lor.rhs141:                                       ; preds = %lor.end137
  %51 = load ptr, ptr %cmd, align 8
  %proc143 = getelementptr inbounds %struct.redisCommand, ptr %51, i64 0, i32 12
  %52 = load ptr, ptr %proc143, align 8
  %cmp144 = icmp eq ptr %52, @execCommand
  br i1 %cmp144, label %land.rhs146, label %lor.end153

land.rhs146:                                      ; preds = %lor.rhs141
  %cmd_inv_flags148 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 54, i32 3
  %53 = load i32, ptr %cmd_inv_flags148, align 8
  %54 = and i32 %53, 512
  %tobool151 = icmp ne i32 %54, 0
  br label %lor.end153

lor.end153:                                       ; preds = %lor.rhs141, %land.rhs146, %lor.end137
  %55 = phi i1 [ true, %lor.end137 ], [ false, %lor.rhs141 ], [ %tobool151, %land.rhs146 ]
  %and155 = and i64 %cmd_flags.0.i, 65537
  %tobool156.not = icmp eq i64 %and155, 0
  br i1 %tobool156.not, label %lor.rhs157, label %lor.end169

lor.rhs157:                                       ; preds = %lor.end153
  %56 = load ptr, ptr %cmd, align 8
  %proc159 = getelementptr inbounds %struct.redisCommand, ptr %56, i64 0, i32 12
  %57 = load ptr, ptr %proc159, align 8
  %cmp160 = icmp eq ptr %57, @execCommand
  br i1 %cmp160, label %land.rhs162, label %lor.end169

land.rhs162:                                      ; preds = %lor.rhs157
  %cmd_flags164 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 54, i32 2
  %58 = load i32, ptr %cmd_flags164, align 4
  %59 = and i32 %58, 65537
  %tobool167 = icmp ne i32 %59, 0
  br label %lor.end169

lor.end169:                                       ; preds = %lor.rhs157, %land.rhs162, %lor.end153
  %60 = phi i1 [ true, %lor.end153 ], [ false, %lor.rhs157 ], [ %tobool167, %land.rhs162 ]
  %and171 = and i64 %cmd_flags.0.i, 8388608
  %tobool172.not = icmp eq i64 %and171, 0
  br i1 %tobool172.not, label %lor.rhs173, label %lor.end185

lor.rhs173:                                       ; preds = %lor.end169
  %61 = load ptr, ptr %cmd, align 8
  %proc175 = getelementptr inbounds %struct.redisCommand, ptr %61, i64 0, i32 12
  %62 = load ptr, ptr %proc175, align 8
  %cmp176 = icmp eq ptr %62, @execCommand
  br i1 %cmp176, label %land.rhs178, label %lor.end185

land.rhs178:                                      ; preds = %lor.rhs173
  %cmd_flags180 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 54, i32 2
  %63 = load i32, ptr %cmd_flags180, align 4
  %64 = and i32 %63, 8388608
  %tobool183 = icmp ne i32 %64, 0
  br label %lor.end185

lor.end185:                                       ; preds = %lor.rhs173, %land.rhs178, %lor.end169
  %65 = phi i1 [ true, %lor.end169 ], [ false, %lor.rhs173 ], [ %tobool183, %land.rhs178 ]
  %66 = load i64, ptr %c, align 8
  %cmp.i184 = icmp eq i64 %66, -1
  br i1 %cmp.i184, label %mustObeyClient.exit, label %lor.rhs.i

lor.rhs.i:                                        ; preds = %lor.end185
  %flags.i185 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %67 = load i64, ptr %flags.i185, align 8
  %68 = trunc i64 %67 to i32
  %69 = lshr i32 %68, 1
  %70 = and i32 %69, 1
  br label %mustObeyClient.exit

mustObeyClient.exit:                              ; preds = %lor.end185, %lor.rhs.i
  %lor.ext.i = phi i32 [ 1, %lor.end185 ], [ %70, %lor.rhs.i ]
  %call188 = call i32 @authRequired(ptr noundef nonnull %c) #38
  %tobool189.not = icmp eq i32 %call188, 0
  br i1 %tobool189.not, label %if.end197, label %if.then190

if.then190:                                       ; preds = %mustObeyClient.exit
  %71 = load ptr, ptr %cmd, align 8
  %flags192 = getelementptr inbounds %struct.redisCommand, ptr %71, i64 0, i32 14
  %72 = load i64, ptr %flags192, align 8
  %and193 = and i64 %72, 32768
  %tobool194.not = icmp eq i64 %and193, 0
  br i1 %tobool194.not, label %if.then195, label %if.end197

if.then195:                                       ; preds = %if.then190
  %73 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 27), align 8
  call void @flagTransaction(ptr noundef nonnull %c) #38
  %duration.i186 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 29
  store i64 0, ptr %duration.i186, align 8
  %74 = load ptr, ptr %cmd, align 8
  %tobool.not.i188 = icmp eq ptr %74, null
  br i1 %tobool.not.i188, label %if.else.i197, label %if.end.i189

if.end.i189:                                      ; preds = %if.then195
  %rejected_calls.i190 = getelementptr inbounds %struct.redisCommand, ptr %74, i64 0, i32 24
  %75 = load i64, ptr %rejected_calls.i190, align 8
  %inc.i191 = add nsw i64 %75, 1
  store i64 %inc.i191, ptr %rejected_calls.i190, align 8
  %.pr.i192 = load ptr, ptr %cmd, align 8
  %tobool3.not.i193 = icmp eq ptr %.pr.i192, null
  br i1 %tobool3.not.i193, label %if.else.i197, label %land.lhs.true.i194

land.lhs.true.i194:                               ; preds = %if.end.i189
  %proc.i195 = getelementptr inbounds %struct.redisCommand, ptr %.pr.i192, i64 0, i32 12
  %76 = load ptr, ptr %proc.i195, align 8
  %cmp.i196 = icmp eq ptr %76, @execCommand
  br i1 %cmp.i196, label %if.then5.i198, label %if.else.i197

if.then5.i198:                                    ; preds = %land.lhs.true.i194
  %ptr.i = getelementptr inbounds %struct.redisObject, ptr %73, i64 0, i32 2
  %77 = load ptr, ptr %ptr.i, align 8
  call void @execCommandAbort(ptr noundef nonnull %c, ptr noundef %77) #38
  br label %return

if.else.i197:                                     ; preds = %land.lhs.true.i194, %if.end.i189, %if.then195
  call void @addReplyErrorObject(ptr noundef nonnull %c, ptr noundef %73) #38
  br label %return

if.end197:                                        ; preds = %if.then190, %mustObeyClient.exit
  %flags198 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %78 = load i64, ptr %flags198, align 8
  %and199 = and i64 %78, 8
  %tobool200.not = icmp eq i64 %and199, 0
  br i1 %tobool200.not, label %if.end207, label %land.lhs.true201

land.lhs.true201:                                 ; preds = %if.end197
  %79 = load ptr, ptr %cmd, align 8
  %flags203 = getelementptr inbounds %struct.redisCommand, ptr %79, i64 0, i32 14
  %80 = load i64, ptr %flags203, align 8
  %and204 = and i64 %80, 16777216
  %tobool205.not = icmp eq i64 %and204, 0
  br i1 %tobool205.not, label %if.end207, label %if.then206

if.then206:                                       ; preds = %land.lhs.true201
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.184)
  br label %return

if.end207:                                        ; preds = %land.lhs.true201, %if.end197
  %call208 = call i32 @ACLCheckAllPerm(ptr noundef nonnull %c, ptr noundef nonnull %acl_errpos) #38
  %cmp209.not = icmp eq i32 %call208, 0
  br i1 %cmp209.not, label %if.end221, label %if.then211

if.then211:                                       ; preds = %if.end207
  %81 = load i64, ptr %flags198, align 8
  %82 = trunc i64 %81 to i32
  %83 = lshr i32 %82, 2
  %cond215 = and i32 %83, 2
  %84 = load i32, ptr %acl_errpos, align 4
  call void @addACLLogEntry(ptr noundef nonnull %c, i32 noundef %call208, i32 noundef %cond215, i32 noundef %84, ptr noundef null, ptr noundef null) #38
  %user = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 20
  %85 = load ptr, ptr %user, align 8
  %86 = load ptr, ptr %cmd, align 8
  %87 = load ptr, ptr %argv, align 8
  %88 = load i32, ptr %acl_errpos, align 4
  %idxprom = sext i32 %88 to i64
  %arrayidx218 = getelementptr inbounds ptr, ptr %87, i64 %idxprom
  %89 = load ptr, ptr %arrayidx218, align 8
  %ptr219 = getelementptr inbounds %struct.redisObject, ptr %89, i64 0, i32 2
  %90 = load ptr, ptr %ptr219, align 8
  %call220 = call ptr @getAclErrorMessage(i32 noundef %call208, ptr noundef %85, ptr noundef %86, ptr noundef %90, i32 noundef 0) #38
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.185, ptr noundef %call220)
  call void @sdsfree(ptr noundef %call220) #38
  br label %return

if.end221:                                        ; preds = %if.end207
  %91 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool222.not = icmp eq i32 %91, 0
  br i1 %tobool222.not, label %if.end260, label %land.lhs.true223

land.lhs.true223:                                 ; preds = %if.end221
  %92 = load i64, ptr %c, align 8
  %cmp.i199 = icmp eq i64 %92, -1
  br i1 %cmp.i199, label %if.end260, label %mustObeyClient.exit203

mustObeyClient.exit203:                           ; preds = %land.lhs.true223
  %93 = load i64, ptr %flags198, align 8
  %94 = and i64 %93, 2
  %tobool225.not = icmp eq i64 %94, 0
  br i1 %tobool225.not, label %land.lhs.true226, label %if.end260

land.lhs.true226:                                 ; preds = %mustObeyClient.exit203
  %95 = load ptr, ptr %cmd, align 8
  %flags228 = getelementptr inbounds %struct.redisCommand, ptr %95, i64 0, i32 14
  %96 = load i64, ptr %flags228, align 8
  %and229 = and i64 %96, 33554432
  %tobool230.not = icmp eq i64 %and229, 0
  br i1 %tobool230.not, label %land.lhs.true231, label %if.then240

land.lhs.true231:                                 ; preds = %land.lhs.true226
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %95, i64 0, i32 17
  %97 = load i32, ptr %key_specs_num, align 8
  %cmp233 = icmp eq i32 %97, 0
  br i1 %cmp233, label %land.lhs.true235, label %if.then240

land.lhs.true235:                                 ; preds = %land.lhs.true231
  %proc237 = getelementptr inbounds %struct.redisCommand, ptr %95, i64 0, i32 12
  %98 = load ptr, ptr %proc237, align 8
  %cmp238.not = icmp eq ptr %98, @execCommand
  br i1 %cmp238.not, label %if.then240, label %if.end260

if.then240:                                       ; preds = %land.lhs.true235, %land.lhs.true231, %land.lhs.true226
  %99 = load ptr, ptr %argv, align 8
  %argc243 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %100 = load i32, ptr %argc243, align 8
  %slot = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 30
  %call244 = call ptr @getNodeByQuery(ptr noundef nonnull %c, ptr noundef nonnull %95, ptr noundef %99, i32 noundef %100, ptr noundef nonnull %slot, ptr noundef nonnull %error_code) #38
  %cmp245 = icmp eq ptr %call244, null
  br i1 %cmp245, label %if.then250, label %lor.lhs.false247

lor.lhs.false247:                                 ; preds = %if.then240
  %call248 = call i32 @clusterNodeIsMyself(ptr noundef nonnull %call244) #38
  %tobool249.not = icmp eq i32 %call248, 0
  br i1 %tobool249.not, label %if.then250, label %if.end260

if.then250:                                       ; preds = %lor.lhs.false247, %if.then240
  %101 = load ptr, ptr %cmd, align 8
  %proc252 = getelementptr inbounds %struct.redisCommand, ptr %101, i64 0, i32 12
  %102 = load ptr, ptr %proc252, align 8
  %cmp253 = icmp eq ptr %102, @execCommand
  br i1 %cmp253, label %if.then255, label %if.else

if.then255:                                       ; preds = %if.then250
  call void @discardTransaction(ptr noundef nonnull %c) #38
  br label %if.end256

if.else:                                          ; preds = %if.then250
  call void @flagTransaction(ptr noundef nonnull %c) #38
  br label %if.end256

if.end256:                                        ; preds = %if.else, %if.then255
  %103 = load i32, ptr %slot, align 8
  %104 = load i32, ptr %error_code, align 4
  call void @clusterRedirectClient(ptr noundef nonnull %c, ptr noundef %call244, i32 noundef %103, i32 noundef %104) #38
  %105 = load ptr, ptr %cmd, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %105, i64 0, i32 24
  %106 = load i64, ptr %rejected_calls, align 8
  %inc = add nsw i64 %106, 1
  store i64 %inc, ptr %rejected_calls, align 8
  br label %return

if.end260:                                        ; preds = %land.lhs.true223, %lor.lhs.false247, %land.lhs.true235, %mustObeyClient.exit203, %if.end221
  call void @evictClients() #38
  %107 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %cmp261 = icmp eq ptr %107, null
  br i1 %cmp261, label %return, label %if.end264

if.end264:                                        ; preds = %if.end260
  %108 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 314), align 8
  %tobool265.not = icmp eq i64 %108, 0
  br i1 %tobool265.not, label %if.end307, label %land.lhs.true266

land.lhs.true266:                                 ; preds = %if.end264
  %call.i204 = call i32 @scriptIsTimedout() #38
  %tobool.i = icmp eq i32 %call.i204, 0
  %109 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %tobool1.i = icmp eq i32 %109, 0
  %.not = select i1 %tobool.i, i1 %tobool1.i, i1 false
  br i1 %.not, label %if.then269, label %if.end307

if.then269:                                       ; preds = %land.lhs.true266
  %call270 = call i32 @performEvictions() #38
  %cmp271 = icmp eq i32 %call270, 2
  %conv272 = zext i1 %cmp271 to i32
  call void @trackingHandlePendingKeyInvalidations() #38
  %110 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 61), align 8
  %cmp273 = icmp eq ptr %110, null
  br i1 %cmp273, label %return, label %if.end276

if.end276:                                        ; preds = %if.then269
  %111 = load i64, ptr %flags198, align 8
  %and278 = and i64 %111, 8
  %tobool279.not = icmp eq i64 %and278, 0
  br i1 %tobool279.not, label %if.end301, label %land.lhs.true280

land.lhs.true280:                                 ; preds = %if.end276
  %112 = load ptr, ptr %cmd, align 8
  %proc282 = getelementptr inbounds %struct.redisCommand, ptr %112, i64 0, i32 12
  %113 = load ptr, ptr %proc282, align 8
  %cmp283.not = icmp eq ptr %113, @execCommand
  %cmp288.not = icmp eq ptr %113, @discardCommand
  %or.cond157 = or i1 %cmp283.not, %cmp288.not
  %cmp293.not = icmp eq ptr %113, @quitCommand
  %or.cond158 = or i1 %cmp293.not, %or.cond157
  %cmp298.not = icmp eq ptr %113, @resetCommand
  %or.cond159 = or i1 %cmp298.not, %or.cond158
  %not.or.cond159 = xor i1 %or.cond159, true
  %spec.select = select i1 %not.or.cond159, i1 true, i1 %45
  br label %if.end301

if.end301:                                        ; preds = %land.lhs.true280, %if.end276
  %reject_cmd_on_oom.0.shrunk = phi i1 [ %45, %if.end276 ], [ %spec.select, %land.lhs.true280 ]
  %or.cond = select i1 %cmp271, i1 %reject_cmd_on_oom.0.shrunk, i1 false
  br i1 %or.cond, label %if.then305, label %if.end306

if.then305:                                       ; preds = %if.end301
  %114 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 30), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %114)
  br label %return

if.end306:                                        ; preds = %if.end301
  store i32 %conv272, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 386), align 8
  br label %if.end307

if.end307:                                        ; preds = %if.end306, %land.lhs.true266, %if.end264
  %115 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 329), align 8
  %tobool308.not = icmp eq i32 %115, 0
  br i1 %tobool308.not, label %if.end310, label %if.then309

if.then309:                                       ; preds = %if.end307
  call void @trackingLimitUsedSlots() #38
  br label %if.end310

if.end310:                                        ; preds = %if.then309, %if.end307
  %call311 = call i32 @writeCommandsDeniedByDiskError(), !range !46
  %cmp312.not = icmp eq i32 %call311, 0
  br i1 %cmp312.not, label %if.end346, label %land.lhs.true314

land.lhs.true314:                                 ; preds = %if.end310
  br i1 %40, label %if.then321, label %lor.lhs.false316

lor.lhs.false316:                                 ; preds = %land.lhs.true314
  %116 = load ptr, ptr %cmd, align 8
  %proc318 = getelementptr inbounds %struct.redisCommand, ptr %116, i64 0, i32 12
  %117 = load ptr, ptr %proc318, align 8
  %cmp319 = icmp eq ptr %117, @pingCommand
  br i1 %cmp319, label %if.then321, label %if.end352

if.then321:                                       ; preds = %lor.lhs.false316, %land.lhs.true314
  %tobool322.not = icmp eq i32 %lor.ext.i, 0
  br i1 %tobool322.not, label %if.else341, label %if.then323

if.then323:                                       ; preds = %if.then321
  %118 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 307), align 4
  %tobool324.not = icmp eq i32 %118, 0
  br i1 %tobool324.not, label %land.lhs.true325, label %if.else331

land.lhs.true325:                                 ; preds = %if.then323
  %119 = load ptr, ptr %cmd, align 8
  %proc327 = getelementptr inbounds %struct.redisCommand, ptr %119, i64 0, i32 12
  %120 = load ptr, ptr %proc327, align 8
  %cmp328.not = icmp eq ptr %120, @pingCommand
  br i1 %cmp328.not, label %if.else331, label %if.then330

if.then330:                                       ; preds = %land.lhs.true325
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 4118, ptr noundef nonnull @.str.186) #38
  call void @abort() #40
  unreachable

if.else331:                                       ; preds = %land.lhs.true325, %if.then323
  %121 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %122 = load i64, ptr @processCommand.last_log_time_ms, align 8
  %add = add nsw i64 %122, 10000
  %cmp332 = icmp sgt i64 %121, %add
  br i1 %cmp332, label %if.then334, label %if.end346

if.then334:                                       ; preds = %if.else331
  store i64 %121, ptr @processCommand.last_log_time_ms, align 8
  %123 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp335 = icmp sgt i32 %123, 3
  br i1 %cmp335, label %if.end346, label %if.end338

if.end338:                                        ; preds = %if.then334
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.187)
  br label %if.end346

if.else341:                                       ; preds = %if.then321
  %call343 = call ptr @writeCommandsGetDiskErrorMessage(i32 noundef %call311)
  %call344 = call fastcc i64 @sdslen(ptr noundef %call343)
  %sub = add i64 %call344, -2
  call void @sdssubstr(ptr noundef %call343, i64 noundef 0, i64 noundef %sub) #38
  call void @rejectCommandSds(ptr noundef nonnull %c, ptr noundef %call343)
  br label %return

if.end346:                                        ; preds = %if.else331, %if.then334, %if.end338, %if.end310
  br i1 %40, label %land.lhs.true348, label %if.end352

land.lhs.true348:                                 ; preds = %if.end346
  %call349 = call i32 @checkGoodReplicasStatus() #38
  %tobool350.not = icmp eq i32 %call349, 0
  br i1 %tobool350.not, label %if.then351, label %if.end352

if.then351:                                       ; preds = %land.lhs.true348
  %124 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 28), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %124)
  br label %return

if.end352:                                        ; preds = %lor.lhs.false316, %land.lhs.true348, %if.end346
  %125 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %tobool353 = icmp ne ptr %125, null
  %126 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 298), align 4
  %tobool355 = icmp ne i32 %126, 0
  %or.cond1.not155.not = select i1 %tobool353, i1 %tobool355, i1 false
  %tobool357 = icmp eq i32 %lor.ext.i, 0
  %or.cond2 = select i1 %or.cond1.not155.not, i1 %tobool357, i1 false
  %or.cond3 = select i1 %or.cond2, i1 %40, i1 false
  br i1 %or.cond3, label %if.then360, label %if.end361

if.then360:                                       ; preds = %if.end352
  %127 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 25), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %127)
  br label %return

if.end361:                                        ; preds = %if.end352
  %128 = load i64, ptr %flags198, align 8
  %and363 = and i64 %128, 262144
  %tobool364.not = icmp eq i64 %and363, 0
  br i1 %tobool364.not, label %if.end415, label %land.lhs.true365

land.lhs.true365:                                 ; preds = %if.end361
  %resp = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 3
  %129 = load i32, ptr %resp, align 8
  %cmp366 = icmp eq i32 %129, 2
  br i1 %cmp366, label %land.lhs.true368, label %if.end415

land.lhs.true368:                                 ; preds = %land.lhs.true365
  %130 = load ptr, ptr %cmd, align 8
  %proc370 = getelementptr inbounds %struct.redisCommand, ptr %130, i64 0, i32 12
  %131 = load ptr, ptr %proc370, align 8
  %132 = insertelement <8 x ptr> poison, ptr %131, i64 0
  %133 = shufflevector <8 x ptr> %132, <8 x ptr> poison, <8 x i32> zeroinitializer
  %134 = icmp eq <8 x ptr> %133, <ptr @subscribeCommand, ptr @pingCommand, ptr @ssubscribeCommand, ptr @unsubscribeCommand, ptr @sunsubscribeCommand, ptr @psubscribeCommand, ptr @punsubscribeCommand, ptr @quitCommand>
  %cmp411.not = icmp eq ptr %131, @resetCommand
  %135 = bitcast <8 x i1> %134 to i8
  %136 = icmp ne i8 %135, 0
  %op.rdx = or i1 %136, %cmp411.not
  br i1 %op.rdx, label %if.end415, label %if.then413

if.then413:                                       ; preds = %land.lhs.true368
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %130, i64 0, i32 27
  %137 = load ptr, ptr %fullname, align 8
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.188, ptr noundef %137)
  br label %return

if.end415:                                        ; preds = %land.lhs.true368, %land.lhs.true365, %if.end361
  %138 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  %cmp418 = icmp ne i32 %138, 12
  %or.cond4 = select i1 %tobool353, i1 %cmp418, i1 false
  %139 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 297), align 8
  %cmp421 = icmp eq i32 %139, 0
  %or.cond5 = select i1 %or.cond4, i1 %cmp421, i1 false
  %or.cond6 = select i1 %or.cond5, i1 %50, i1 false
  br i1 %or.cond6, label %if.then425, label %if.end426

if.then425:                                       ; preds = %if.end415
  %140 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 24), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %140)
  br label %return

if.end426:                                        ; preds = %if.end415
  %141 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool427.not = icmp eq i32 %141, 0
  br i1 %tobool427.not, label %if.end433, label %land.lhs.true428

land.lhs.true428:                                 ; preds = %if.end426
  %142 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 82), align 8
  %tobool429 = icmp eq i32 %142, 0
  %or.cond7 = select i1 %tobool429, i1 %55, i1 false
  br i1 %or.cond7, label %if.then432, label %if.end433

if.then432:                                       ; preds = %land.lhs.true428
  %143 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 19), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %143)
  br label %return

if.end433:                                        ; preds = %land.lhs.true428, %if.end426
  %144 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 82), align 8
  %tobool434 = icmp ne i32 %144, 0
  %or.cond8 = select i1 %tobool434, i1 %65, i1 false
  br i1 %or.cond8, label %if.then437, label %if.end438

if.then437:                                       ; preds = %if.end433
  %145 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 19), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %145)
  br label %return

if.end438:                                        ; preds = %if.end433
  %call.i206 = call i32 @scriptIsTimedout() #38
  %tobool.i207 = icmp ne i32 %call.i206, 0
  %146 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %tobool1.i208 = icmp ne i32 %146, 0
  %147 = select i1 %tobool.i207, i1 true, i1 %tobool1.i208
  br i1 %147, label %land.lhs.true441, label %if.end462

land.lhs.true441:                                 ; preds = %if.end438
  %148 = load ptr, ptr %cmd, align 8
  %flags443 = getelementptr inbounds %struct.redisCommand, ptr %148, i64 0, i32 14
  %149 = load i64, ptr %flags443, align 8
  %and444 = and i64 %149, 67108864
  %tobool445.not = icmp eq i64 %and444, 0
  br i1 %tobool445.not, label %if.then446, label %if.end462

if.then446:                                       ; preds = %land.lhs.true441
  %150 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 32), align 8
  %tobool449 = icmp ne ptr %150, null
  %or.cond9 = select i1 %tobool1.i208, i1 %tobool449, i1 false
  br i1 %or.cond9, label %if.then450, label %if.else451

if.then450:                                       ; preds = %if.then446
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.189, ptr noundef nonnull %150)
  br label %return

if.else451:                                       ; preds = %if.then446
  br i1 %tobool1.i208, label %if.then453, label %if.else454

if.then453:                                       ; preds = %if.else451
  %151 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 22), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %151)
  br label %return

if.else454:                                       ; preds = %if.else451
  %call455 = call i32 @scriptIsEval() #38
  %tobool456.not = icmp eq i32 %call455, 0
  br i1 %tobool456.not, label %if.else458, label %if.then457

if.then457:                                       ; preds = %if.else454
  %152 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 20), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %152)
  br label %return

if.else458:                                       ; preds = %if.else454
  %153 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 21), align 8
  call void @rejectCommand(ptr noundef nonnull %c, ptr noundef %153)
  br label %return

if.end462:                                        ; preds = %land.lhs.true441, %if.end438
  %154 = load i64, ptr %flags198, align 8
  %and464 = and i64 %154, 1
  %tobool465.not = icmp ne i64 %and464, 0
  %or.cond10 = select i1 %60, i1 true, i1 %40
  %or.cond11 = select i1 %or.cond10, i1 true, i1 %35
  %or.cond168 = select i1 %tobool465.not, i1 %or.cond11, i1 false
  br i1 %or.cond168, label %if.then472, label %if.end473

if.then472:                                       ; preds = %if.end462
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.190)
  br label %return

if.end473:                                        ; preds = %if.end462
  %tobool476.not = icmp eq i64 %and464, 0
  br i1 %tobool476.not, label %land.lhs.true477, label %if.end486

land.lhs.true477:                                 ; preds = %if.end473
  %call478 = call i32 @isPausedActions(i32 noundef 2) #38
  %tobool479.not = icmp eq i32 %call478, 0
  br i1 %tobool479.not, label %lor.lhs.false480, label %if.then485

lor.lhs.false480:                                 ; preds = %land.lhs.true477
  %call481 = call i32 @isPausedActions(i32 noundef 1) #38
  %tobool482 = icmp ne i32 %call481, 0
  %or.cond12 = select i1 %tobool482, i1 %60, i1 false
  br i1 %or.cond12, label %if.then485, label %lor.lhs.false480.if.end486_crit_edge

lor.lhs.false480.if.end486_crit_edge:             ; preds = %lor.lhs.false480
  %.pre220 = load i64, ptr %flags198, align 8
  br label %if.end486

if.then485:                                       ; preds = %lor.lhs.false480, %land.lhs.true477
  call void @blockPostponeClient(ptr noundef nonnull %c) #38
  br label %return

if.end486:                                        ; preds = %lor.lhs.false480.if.end486_crit_edge, %if.end473
  %155 = phi i64 [ %.pre220, %lor.lhs.false480.if.end486_crit_edge ], [ %154, %if.end473 ]
  %and488 = and i64 %155, 8
  %tobool489.not = icmp eq i64 %and488, 0
  br i1 %tobool489.not, label %if.else521, label %land.lhs.true490

land.lhs.true490:                                 ; preds = %if.end486
  %156 = load ptr, ptr %cmd, align 8
  %proc492 = getelementptr inbounds %struct.redisCommand, ptr %156, i64 0, i32 12
  %157 = load ptr, ptr %proc492, align 8
  %cmp493.not = icmp eq ptr %157, @execCommand
  %cmp498.not = icmp eq ptr %157, @discardCommand
  %or.cond169 = or i1 %cmp493.not, %cmp498.not
  %cmp503.not = icmp eq ptr %157, @multiCommand
  %or.cond170 = or i1 %cmp503.not, %or.cond169
  %cmp508.not = icmp eq ptr %157, @watchCommand
  %or.cond171 = or i1 %cmp508.not, %or.cond170
  %cmp513.not = icmp eq ptr %157, @quitCommand
  %or.cond172 = or i1 %cmp513.not, %or.cond171
  %cmp518.not = icmp eq ptr %157, @resetCommand
  %or.cond173 = or i1 %cmp518.not, %or.cond172
  br i1 %or.cond173, label %if.else521, label %if.then520

if.then520:                                       ; preds = %land.lhs.true490
  call void @queueMultiCommand(ptr noundef nonnull %c, i64 noundef %cmd_flags.0.i) #38
  %158 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 7), align 8
  call void @addReply(ptr noundef nonnull %c, ptr noundef %158) #38
  br label %return

if.else521:                                       ; preds = %land.lhs.true490, %if.end486
  %. = select i1 %tobool18.not, i32 3, i32 7
  call void @call(ptr noundef nonnull %c, i32 noundef %.)
  %159 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 328), align 8
  %len = getelementptr inbounds %struct.list, ptr %159, i64 0, i32 5
  %160 = load i64, ptr %len, align 8
  %tobool526.not = icmp eq i64 %160, 0
  br i1 %tobool526.not, label %return, label %land.lhs.true527

land.lhs.true527:                                 ; preds = %if.else521
  %call.i210 = call i32 @scriptIsTimedout() #38
  %tobool.i211 = icmp eq i32 %call.i210, 0
  %161 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 31), align 8
  %tobool1.i212 = icmp eq i32 %161, 0
  %.not218 = select i1 %tobool.i211, i1 %tobool1.i212, i1 false
  br i1 %.not218, label %if.then530, label %return

if.then530:                                       ; preds = %land.lhs.true527
  call void @handleClientsBlockedOnKeys() #38
  br label %return

return:                                           ; preds = %if.else.i197, %if.then5.i198, %if.else.i, %if.then5.i, %if.then520, %if.then530, %land.lhs.true527, %if.else521, %if.then450, %if.then457, %if.else458, %if.then453, %if.then269, %if.end260, %if.then485, %if.then472, %if.then437, %if.then432, %if.then425, %if.then413, %if.then360, %if.then351, %if.else341, %if.then305, %if.end256, %if.then211, %if.then206, %if.then67, %if.then47, %if.then34, %if.then30
  %retval.0 = phi i32 [ 0, %if.then206 ], [ 0, %if.then211 ], [ 0, %if.then360 ], [ 0, %if.then413 ], [ 0, %if.then425 ], [ 0, %if.then432 ], [ 0, %if.then437 ], [ 0, %if.then472 ], [ 0, %if.then485 ], [ 0, %if.then351 ], [ 0, %if.else341 ], [ 0, %if.then305 ], [ 0, %if.end256 ], [ 0, %if.then67 ], [ 0, %if.then47 ], [ 0, %if.then34 ], [ -1, %if.then30 ], [ -1, %if.end260 ], [ -1, %if.then269 ], [ 0, %if.then453 ], [ 0, %if.else458 ], [ 0, %if.then457 ], [ 0, %if.then450 ], [ 0, %if.else521 ], [ 0, %land.lhs.true527 ], [ 0, %if.then530 ], [ 0, %if.then520 ], [ 0, %if.then5.i ], [ 0, %if.else.i ], [ 0, %if.then5.i198 ], [ 0, %if.else.i197 ]
  ret i32 %retval.0
}

declare i32 @scriptIsRunning() local_unnamed_addr #4

declare void @moduleCallCommandFilters(ptr noundef) local_unnamed_addr #4

declare i64 @reqresAppendRequest(ptr noundef) local_unnamed_addr #4

declare void @securityWarningCommand(ptr noundef) local_unnamed_addr #4

declare void @blockPostponeClient(ptr noundef) local_unnamed_addr #4

declare void @debugCommand(ptr noundef) #4

declare i32 @allowProtectedAction(i32 noundef, ptr noundef) local_unnamed_addr #4

declare void @moduleCommand(ptr noundef) #4

declare i32 @authRequired(ptr noundef) local_unnamed_addr #4

declare i32 @ACLCheckAllPerm(ptr noundef, ptr noundef) local_unnamed_addr #4

declare void @addACLLogEntry(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

declare ptr @getAclErrorMessage(i32 noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare ptr @getNodeByQuery(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

declare i32 @clusterNodeIsMyself(ptr noundef) local_unnamed_addr #4

declare void @discardTransaction(ptr noundef) local_unnamed_addr #4

declare void @clusterRedirectClient(ptr noundef, ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

declare i32 @performEvictions() local_unnamed_addr #4

declare void @discardCommand(ptr noundef) #4

declare void @quitCommand(ptr noundef) #4

declare void @resetCommand(ptr noundef) #4

; Function Attrs: mustprogress nofree norecurse nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) uwtable
define dso_local noundef i32 @writeCommandsDeniedByDiskError() local_unnamed_addr #28 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 236), align 4
  %tobool = icmp ne i32 %0, 0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 224), align 8
  %cmp = icmp sgt i32 %1, 0
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 235), align 8
  %cmp2 = icmp eq i32 %2, -1
  %or.cond1 = select i1 %or.cond, i1 %cmp2, i1 false
  br i1 %or.cond1, label %return, label %if.else

if.else:                                          ; preds = %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp3.not = icmp eq i32 %3, 0
  br i1 %cmp3.not, label %return, label %if.then4

if.then4:                                         ; preds = %if.else
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 211), align 8
  %cmp5 = icmp eq i32 %4, -1
  br i1 %cmp5, label %return, label %do.body

do.body:                                          ; preds = %if.then4
  %5 = load atomic i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 215) monotonic, align 8
  %cmp7 = icmp eq i32 %5, -1
  br i1 %cmp7, label %do.body9, label %return

do.body9:                                         ; preds = %do.body
  %6 = load atomic i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 216) monotonic, align 4
  store i32 %6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 212), align 4
  br label %return

return:                                           ; preds = %do.body, %if.else, %if.then4, %entry, %do.body9
  %retval.0 = phi i32 [ 1, %do.body9 ], [ 2, %entry ], [ 1, %if.then4 ], [ 0, %if.else ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @pingCommand(ptr noundef %c) #0 {
entry:
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %0 = load i32, ptr %argc, align 8
  %cmp = icmp sgt i32 %0, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @addReplyErrorArity(ptr noundef nonnull %c) #38
  br label %if.end15

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %and = and i64 %1, 262144
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.else7, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %resp = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 3
  %2 = load i32, ptr %resp, align 8
  %cmp1 = icmp eq i32 %2, 2
  br i1 %cmp1, label %if.then2, label %if.else7

if.then2:                                         ; preds = %land.lhs.true
  %3 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 87, i64 2), align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %3) #38
  tail call void @addReplyBulkCBuffer(ptr noundef nonnull %c, ptr noundef nonnull @.str.218, i64 noundef 4) #38
  %4 = load i32, ptr %argc, align 8
  %cmp4 = icmp eq i32 %4, 1
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then2
  tail call void @addReplyBulkCBuffer(ptr noundef nonnull %c, ptr noundef nonnull @.str.219, i64 noundef 0) #38
  br label %if.end15

if.else:                                          ; preds = %if.then2
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %5 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx, align 8
  tail call void @addReplyBulk(ptr noundef nonnull %c, ptr noundef %6) #38
  br label %if.end15

if.else7:                                         ; preds = %land.lhs.true, %if.end
  %cmp9 = icmp eq i32 %0, 1
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  %7 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 5), align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %7) #38
  br label %if.end15

if.else11:                                        ; preds = %if.else7
  %argv12 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %8 = load ptr, ptr %argv12, align 8
  %arrayidx13 = getelementptr inbounds ptr, ptr %8, i64 1
  %9 = load ptr, ptr %arrayidx13, align 8
  tail call void @addReplyBulk(ptr noundef nonnull %c, ptr noundef %9) #38
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %if.else11, %if.then5, %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @writeCommandsGetDiskErrorMessage(i32 noundef %error_code) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq i32 %error_code, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 23), align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i64 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %call = tail call ptr @sdsdup(ptr noundef %1) #38
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = tail call ptr @sdsempty() #38
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 212), align 4
  %call2 = tail call ptr @strerror(i32 noundef %2) #38
  %call3 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call1, ptr noundef nonnull @.str.217, ptr noundef %call2) #38
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %ret.0 = phi ptr [ %call, %if.then ], [ %call3, %if.else ]
  ret ptr %ret.0
}

declare void @sdssubstr(ptr noundef, i64 noundef, i64 noundef) local_unnamed_addr #4

declare i32 @checkGoodReplicasStatus() local_unnamed_addr #4

declare void @subscribeCommand(ptr noundef) #4

declare void @ssubscribeCommand(ptr noundef) #4

declare void @unsubscribeCommand(ptr noundef) #4

declare void @sunsubscribeCommand(ptr noundef) #4

declare void @psubscribeCommand(ptr noundef) #4

declare void @punsubscribeCommand(ptr noundef) #4

declare i32 @scriptIsEval() local_unnamed_addr #4

declare i32 @isPausedActions(i32 noundef) local_unnamed_addr #4

declare void @multiCommand(ptr noundef) #4

declare void @watchCommand(ptr noundef) #4

declare void @queueMultiCommand(ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @addReply(ptr noundef, ptr noundef) local_unnamed_addr #4

declare void @handleClientsBlockedOnKeys() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @incrementErrorCount(ptr noundef %fullerr, i64 noundef %namelen) local_unnamed_addr #0 {
entry:
  %result = alloca ptr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 15), align 8
  %call = call i32 @raxFind(ptr noundef %0, ptr noundef %fullerr, i64 noundef %namelen, ptr noundef nonnull %result) #38
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call noalias dereferenceable_or_null(8) ptr @zmalloc(i64 noundef 8) #42
  store i64 1, ptr %call1, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 15), align 8
  %call2 = call i32 @raxInsert(ptr noundef %1, ptr noundef %fullerr, i64 noundef %namelen, ptr noundef nonnull %call1, ptr noundef null) #38
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %result, align 8
  %3 = load i64, ptr %2, align 8
  %inc = add nsw i64 %3, 1
  store i64 %inc, ptr %2, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare i32 @raxFind(ptr noundef, ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #4

declare i32 @raxInsert(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @closeListeningSockets(i32 noundef %unlink_unix_socket) local_unnamed_addr #0 {
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc7
  %indvars.iv18 = phi i64 [ 0, %entry ], [ %indvars.iv.next19, %for.inc7 ]
  %arrayidx = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv18
  %ct = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv18, i32 5
  %0 = load ptr, ptr %ct, align 8
  %cmp1 = icmp eq ptr %0, null
  br i1 %cmp1, label %for.inc7, label %for.cond2.preheader

for.cond2.preheader:                              ; preds = %for.body
  %count = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv18, i32 1
  %1 = load i32, ptr %count, align 8
  %cmp311 = icmp sgt i32 %1, 0
  br i1 %cmp311, label %for.body4, label %for.inc7

for.body4:                                        ; preds = %for.cond2.preheader, %for.body4
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body4 ], [ 0, %for.cond2.preheader ]
  %arrayidx6 = getelementptr inbounds [16 x i32], ptr %arrayidx, i64 0, i64 %indvars.iv
  %2 = load i32, ptr %arrayidx6, align 4
  %call = tail call i32 @close(i32 noundef %2) #38
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %3 = load i32, ptr %count, align 8
  %4 = sext i32 %3 to i64
  %cmp3 = icmp slt i64 %indvars.iv.next, %4
  br i1 %cmp3, label %for.body4, label %for.inc7, !llvm.loop !47

for.inc7:                                         ; preds = %for.body4, %for.cond2.preheader, %for.body
  %indvars.iv.next19 = add nuw nsw i64 %indvars.iv18, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next19, 8
  br i1 %exitcond.not, label %for.end9, label %for.body, !llvm.loop !48

for.end9:                                         ; preds = %for.inc7
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp ne i32 %5, 0
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 1), align 8
  %cmp1214 = icmp sgt i32 %6, 0
  %or.cond16 = select i1 %tobool.not, i1 %cmp1214, i1 false
  br i1 %or.cond16, label %for.body13, label %if.end20

for.body13:                                       ; preds = %for.end9, %for.body13
  %indvars.iv21 = phi i64 [ %indvars.iv.next22, %for.body13 ], [ 0, %for.end9 ]
  %arrayidx15 = getelementptr inbounds [16 x i32], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54), i64 0, i64 %indvars.iv21
  %7 = load i32, ptr %arrayidx15, align 4
  %call16 = tail call i32 @close(i32 noundef %7) #38
  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 1), align 8
  %9 = sext i32 %8 to i64
  %cmp12 = icmp slt i64 %indvars.iv.next22, %9
  br i1 %cmp12, label %for.body13, label %if.end20, !llvm.loop !49

if.end20:                                         ; preds = %for.body13, %for.end9
  %tobool21 = icmp ne i32 %unlink_unix_socket, 0
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 50), align 8
  %tobool22 = icmp ne ptr %10, null
  %or.cond = select i1 %tobool21, i1 %tobool22, i1 false
  br i1 %or.cond, label %do.body, label %if.end38

do.body:                                          ; preds = %if.end20
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp24 = icmp sgt i32 %11, 2
  br i1 %cmp24, label %do.end, label %if.end26

if.end26:                                         ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.191)
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 50), align 8
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end26
  %12 = phi ptr [ %10, %do.body ], [ %.pre, %if.end26 ]
  %call27 = tail call i32 @unlink(ptr noundef %12) #38
  %cmp28 = icmp eq i32 %call27, 0
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp31 = icmp sgt i32 %13, 3
  %or.cond1 = select i1 %cmp28, i1 true, i1 %cmp31
  br i1 %or.cond1, label %if.end38, label %if.end33

if.end33:                                         ; preds = %do.end
  %call34 = tail call ptr @__errno_location() #41
  %14 = load i32, ptr %call34, align 4
  %call35 = tail call ptr @strerror(i32 noundef %14) #38
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.192, ptr noundef %call35)
  br label %if.end38

if.end38:                                         ; preds = %do.end, %if.end33, %if.end20
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @unlink(ptr nocapture noundef readonly) local_unnamed_addr #2

; Function Attrs: nounwind uwtable
define dso_local i32 @redisCommunicateSystemd(ptr noundef %sd_notify_msg) local_unnamed_addr #0 {
entry:
  %call = tail call i32 @sd_notify(i32 noundef 0, ptr noundef %sd_notify_msg) #38
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %do.body, label %if.else

do.body:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %0, 3
  br i1 %cmp1, label %if.end11, label %if.end

if.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %if.end11

if.else:                                          ; preds = %entry
  %cmp3 = icmp sgt i32 %call, -1
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6 = icmp sgt i32 %1, 3
  %or.cond = select i1 %cmp3, i1 true, i1 %cmp6
  br i1 %or.cond, label %if.end11, label %if.end8

if.end8:                                          ; preds = %if.else
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.end8, %if.end, %do.body
  ret i32 %call
}

declare void @pauseActions(i32 noundef, i64 noundef, i32 noundef) local_unnamed_addr #4

declare void @listRewind(ptr noundef, ptr noundef) local_unnamed_addr #4

declare ptr @listNext(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @abortShutdown() local_unnamed_addr #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 18), align 8
  %cmp.i.not = icmp eq i64 %0, 0
  br i1 %cmp.i.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 18), i8 0, i64 16, i1 false)
  tail call void @replyToClientsBlockedOnShutdown() #38
  tail call void @unpauseActions(i32 noundef 1) #38
  br label %do.body

if.else:                                          ; preds = %entry
  %1 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  %tobool1.not = icmp eq i32 %1, 0
  br i1 %tobool1.not, label %return, label %if.then2

if.then2:                                         ; preds = %if.else
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  br label %do.body

do.body:                                          ; preds = %if.then, %if.then2
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %2, 2
  br i1 %cmp, label %return, label %if.end6

if.end6:                                          ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.196)
  br label %return

return:                                           ; preds = %if.end6, %do.body, %if.else
  %retval.0 = phi i32 [ -1, %if.else ], [ 0, %do.body ], [ 0, %if.end6 ]
  ret i32 %retval.0
}

declare ptr @replicationGetSlaveName(ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local noundef nonnull ptr @replstateToString(i32 noundef %replstate) local_unnamed_addr #18 {
entry:
  %switch.tableidx = add i32 %replstate, -6
  %0 = icmp ult i32 %switch.tableidx, 4
  br i1 %0, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %entry
  %1 = zext nneg i32 %switch.tableidx to i64
  %switch.gep = getelementptr inbounds [4 x ptr], ptr @switch.table.replstateToString, i64 0, i64 %1
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %return

return:                                           ; preds = %entry, %switch.lookup
  %retval.0 = phi ptr [ %switch.load, %switch.lookup ], [ @.str.219, %entry ]
  ret ptr %retval.0
}

declare void @ldbKillForkedSessions() local_unnamed_addr #4

declare void @killRDBChild() local_unnamed_addr #4

declare void @rdbRemoveTempFile(i32 noundef, i32 noundef) local_unnamed_addr #4

declare i32 @TerminateModuleForkChild(i32 noundef, i32 noundef) local_unnamed_addr #4

declare void @killAppendOnlyChild() local_unnamed_addr #4

declare i32 @fdatasync(i32 noundef) local_unnamed_addr #4

declare i32 @rdbSave(i32 noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare void @aofManifestFree(ptr noundef) local_unnamed_addr #4

declare void @flushSlavesOutputBuffers() local_unnamed_addr #4

; Function Attrs: nounwind
declare i32 @flock(i32 noundef, i32 noundef) local_unnamed_addr #3

declare void @addReplyErrorArity(ptr noundef) local_unnamed_addr #4

declare void @addReplyBulkCBuffer(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @addReplyBulk(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @echoCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %0 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 1
  %1 = load ptr, ptr %arrayidx, align 8
  tail call void @addReplyBulk(ptr noundef %c, ptr noundef %1) #38
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @timeCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef 2) #38
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  tail call void @addReplyBulkLongLong(ptr noundef %c, i64 noundef %atomic-load) #38
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %atomic-load1 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %mul.neg = mul i64 %atomic-load1, -1000000
  %sub = add i64 %mul.neg, %0
  tail call void @addReplyBulkLongLong(ptr noundef %c, i64 noundef %sub) #38
  ret void
}

declare void @addReplyArrayLen(ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @addReplyBulkLongLong(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandFlags(ptr noundef %c, i64 noundef %flags, ptr nocapture noundef readonly %replyFlags) local_unnamed_addr #0 {
entry:
  %name14 = getelementptr inbounds %struct.replyFlagNames, ptr %replyFlags, i64 0, i32 1
  %0 = load ptr, ptr %name14, align 8
  %tobool.not15 = icmp eq ptr %0, null
  br i1 %tobool.not15, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %while.body ], [ 0, %entry ]
  %count.016 = phi i32 [ %spec.select, %while.body ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds %struct.replyFlagNames, ptr %replyFlags, i64 %indvars.iv
  %1 = load i64, ptr %arrayidx, align 8
  %and = and i64 %1, %flags
  %tobool3.not = icmp ne i64 %and, 0
  %inc = zext i1 %tobool3.not to i32
  %spec.select = add nuw nsw i32 %count.016, %inc
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %name = getelementptr inbounds %struct.replyFlagNames, ptr %replyFlags, i64 %indvars.iv.next, i32 1
  %2 = load ptr, ptr %name, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %while.end.loopexit, label %while.body, !llvm.loop !50

while.end.loopexit:                               ; preds = %while.body
  %3 = zext nneg i32 %spec.select to i64
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %entry
  %count.0.lcssa = phi i64 [ 0, %entry ], [ %3, %while.end.loopexit ]
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %count.0.lcssa) #38
  %4 = load ptr, ptr %name14, align 8
  %tobool9.not20 = icmp eq ptr %4, null
  br i1 %tobool9.not20, label %while.end22, label %while.body10

while.body10:                                     ; preds = %while.end, %if.end20
  %indvars.iv24 = phi i64 [ %indvars.iv.next25, %if.end20 ], [ 0, %while.end ]
  %5 = phi ptr [ %7, %if.end20 ], [ %4, %while.end ]
  %arrayidx7 = getelementptr inbounds %struct.replyFlagNames, ptr %replyFlags, i64 %indvars.iv24
  %6 = load i64, ptr %arrayidx7, align 8
  %and14 = and i64 %6, %flags
  %tobool15.not = icmp eq i64 %and14, 0
  br i1 %tobool15.not, label %if.end20, label %if.then16

if.then16:                                        ; preds = %while.body10
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %5) #38
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %while.body10
  %indvars.iv.next25 = add nuw i64 %indvars.iv24, 1
  %name8 = getelementptr inbounds %struct.replyFlagNames, ptr %replyFlags, i64 %indvars.iv.next25, i32 1
  %7 = load ptr, ptr %name8, align 8
  %tobool9.not = icmp eq ptr %7, null
  br i1 %tobool9.not, label %while.end22, label %while.body10, !llvm.loop !51

while.end22:                                      ; preds = %if.end20, %while.end
  ret void
}

declare void @addReplySetLen(ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @addReplyStatus(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @addReplyFlagsForCommand(ptr noundef %c, ptr nocapture noundef readonly %cmd) local_unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 14
  %0 = load i64, ptr %flags, align 8
  br label %while.body.i

while.body.i:                                     ; preds = %entry, %while.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %while.body.i ], [ 0, %entry ]
  %count.016.i = phi i32 [ %spec.select.i, %while.body.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForCommand.flagNames, i64 %indvars.iv.i
  %1 = load i64, ptr %arrayidx.i, align 16
  %and.i = and i64 %1, %0
  %tobool3.not.i = icmp ne i64 %and.i, 0
  %inc.i = zext i1 %tobool3.not.i to i32
  %spec.select.i = add nuw nsw i32 %count.016.i, %inc.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond = icmp eq i64 %indvars.iv.next.i, 20
  br i1 %exitcond, label %while.end.i, label %while.body.i, !llvm.loop !50

while.end.i:                                      ; preds = %while.body.i
  %2 = zext nneg i32 %spec.select.i to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %2) #38
  br label %while.body10.i

while.body10.i:                                   ; preds = %while.end.i, %if.end20.i
  %indvars.iv24.i = phi i64 [ %indvars.iv.next25.i, %if.end20.i ], [ 0, %while.end.i ]
  %3 = phi ptr [ %5, %if.end20.i ], [ @.str.220, %while.end.i ]
  %arrayidx7.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForCommand.flagNames, i64 %indvars.iv24.i
  %4 = load i64, ptr %arrayidx7.i, align 16
  %and14.i = and i64 %4, %0
  %tobool15.not.i = icmp eq i64 %and14.i, 0
  br i1 %tobool15.not.i, label %if.end20.i, label %if.then16.i

if.then16.i:                                      ; preds = %while.body10.i
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %3) #38
  br label %if.end20.i

if.end20.i:                                       ; preds = %if.then16.i, %while.body10.i
  %indvars.iv.next25.i = add nuw nsw i64 %indvars.iv24.i, 1
  %name8.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForCommand.flagNames, i64 %indvars.iv.next25.i, i32 1
  %5 = load ptr, ptr %name8.i, align 8
  %exitcond2 = icmp eq i64 %indvars.iv.next25.i, 20
  br i1 %exitcond2, label %addReplyCommandFlags.exit, label %while.body10.i, !llvm.loop !51

addReplyCommandFlags.exit:                        ; preds = %if.end20.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyDocFlagsForCommand(ptr noundef %c, ptr nocapture noundef readonly %cmd) local_unnamed_addr #0 {
entry:
  %doc_flags = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 4
  %0 = load i32, ptr %doc_flags, align 8
  %conv = sext i32 %0 to i64
  br label %while.body.i

while.body.i:                                     ; preds = %entry, %while.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %while.body.i ], [ 0, %entry ]
  %count.016.i = phi i32 [ %spec.select.i, %while.body.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyDocFlagsForCommand.docFlagNames, i64 %indvars.iv.i
  %1 = load i64, ptr %arrayidx.i, align 16
  %and.i = and i64 %1, %conv
  %tobool3.not.i = icmp ne i64 %and.i, 0
  %inc.i = zext i1 %tobool3.not.i to i32
  %spec.select.i = add nuw nsw i32 %count.016.i, %inc.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond = icmp eq i64 %indvars.iv.next.i, 2
  br i1 %exitcond, label %while.end.i, label %while.body.i, !llvm.loop !50

while.end.i:                                      ; preds = %while.body.i
  %2 = zext nneg i32 %spec.select.i to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %2) #38
  br label %while.body10.i

while.body10.i:                                   ; preds = %while.end.i, %if.end20.i
  %indvars.iv24.i = phi i64 [ %indvars.iv.next25.i, %if.end20.i ], [ 0, %while.end.i ]
  %3 = phi ptr [ %5, %if.end20.i ], [ @.str.240, %while.end.i ]
  %arrayidx7.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyDocFlagsForCommand.docFlagNames, i64 %indvars.iv24.i
  %4 = load i64, ptr %arrayidx7.i, align 16
  %and14.i = and i64 %4, %conv
  %tobool15.not.i = icmp eq i64 %and14.i, 0
  br i1 %tobool15.not.i, label %if.end20.i, label %if.then16.i

if.then16.i:                                      ; preds = %while.body10.i
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %3) #38
  br label %if.end20.i

if.end20.i:                                       ; preds = %if.then16.i, %while.body10.i
  %indvars.iv.next25.i = add nuw nsw i64 %indvars.iv24.i, 1
  %name8.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyDocFlagsForCommand.docFlagNames, i64 %indvars.iv.next25.i, i32 1
  %5 = load ptr, ptr %name8.i, align 8
  %exitcond2 = icmp eq i64 %indvars.iv.next25.i, 2
  br i1 %exitcond2, label %addReplyCommandFlags.exit, label %while.body10.i, !llvm.loop !51

addReplyCommandFlags.exit:                        ; preds = %if.end20.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyFlagsForKeyArgs(ptr noundef %c, i64 noundef %flags) local_unnamed_addr #0 {
entry:
  br label %while.body.i

while.body.i:                                     ; preds = %entry, %while.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %while.body.i ], [ 0, %entry ]
  %count.016.i = phi i32 [ %spec.select.i, %while.body.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv.i
  %0 = load i64, ptr %arrayidx.i, align 16
  %and.i = and i64 %0, %flags
  %tobool3.not.i = icmp ne i64 %and.i, 0
  %inc.i = zext i1 %tobool3.not.i to i32
  %spec.select.i = add nuw nsw i32 %count.016.i, %inc.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond = icmp eq i64 %indvars.iv.next.i, 11
  br i1 %exitcond, label %while.end.i, label %while.body.i, !llvm.loop !50

while.end.i:                                      ; preds = %while.body.i
  %1 = zext nneg i32 %spec.select.i to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %1) #38
  br label %while.body10.i

while.body10.i:                                   ; preds = %while.end.i, %if.end20.i
  %indvars.iv24.i = phi i64 [ %indvars.iv.next25.i, %if.end20.i ], [ 0, %while.end.i ]
  %2 = phi ptr [ %4, %if.end20.i ], [ @.str.242, %while.end.i ]
  %arrayidx7.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv24.i
  %3 = load i64, ptr %arrayidx7.i, align 16
  %and14.i = and i64 %3, %flags
  %tobool15.not.i = icmp eq i64 %and14.i, 0
  br i1 %tobool15.not.i, label %if.end20.i, label %if.then16.i

if.then16.i:                                      ; preds = %while.body10.i
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %2) #38
  br label %if.end20.i

if.end20.i:                                       ; preds = %if.then16.i, %while.body10.i
  %indvars.iv.next25.i = add nuw nsw i64 %indvars.iv24.i, 1
  %name8.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv.next25.i, i32 1
  %4 = load ptr, ptr %name8.i, align 8
  %exitcond2 = icmp eq i64 %indvars.iv.next25.i, 11
  br i1 %exitcond2, label %addReplyCommandFlags.exit, label %while.body10.i, !llvm.loop !51

addReplyCommandFlags.exit:                        ; preds = %if.end20.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyFlagsForArg(ptr noundef %c, i64 noundef %flags) local_unnamed_addr #0 {
entry:
  br label %while.body.i

while.body.i:                                     ; preds = %entry, %while.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %while.body.i ], [ 0, %entry ]
  %count.016.i = phi i32 [ %spec.select.i, %while.body.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForArg.argFlagNames, i64 %indvars.iv.i
  %0 = load i64, ptr %arrayidx.i, align 16
  %and.i = and i64 %0, %flags
  %tobool3.not.i = icmp ne i64 %and.i, 0
  %inc.i = zext i1 %tobool3.not.i to i32
  %spec.select.i = add nuw nsw i32 %count.016.i, %inc.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond = icmp eq i64 %indvars.iv.next.i, 3
  br i1 %exitcond, label %while.end.i, label %while.body.i, !llvm.loop !50

while.end.i:                                      ; preds = %while.body.i
  %1 = zext nneg i32 %spec.select.i to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %1) #38
  br label %while.body10.i

while.body10.i:                                   ; preds = %while.end.i, %if.end20.i
  %indvars.iv24.i = phi i64 [ %indvars.iv.next25.i, %if.end20.i ], [ 0, %while.end.i ]
  %2 = phi ptr [ %4, %if.end20.i ], [ @.str.262, %while.end.i ]
  %arrayidx7.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForArg.argFlagNames, i64 %indvars.iv24.i
  %3 = load i64, ptr %arrayidx7.i, align 16
  %and14.i = and i64 %3, %flags
  %tobool15.not.i = icmp eq i64 %and14.i, 0
  br i1 %tobool15.not.i, label %if.end20.i, label %if.then16.i

if.then16.i:                                      ; preds = %while.body10.i
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %2) #38
  br label %if.end20.i

if.end20.i:                                       ; preds = %if.then16.i, %while.body10.i
  %indvars.iv.next25.i = add nuw nsw i64 %indvars.iv24.i, 1
  %name8.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForArg.argFlagNames, i64 %indvars.iv.next25.i, i32 1
  %4 = load ptr, ptr %name8.i, align 8
  %exitcond2 = icmp eq i64 %indvars.iv.next25.i, 3
  br i1 %exitcond2, label %addReplyCommandFlags.exit, label %while.body10.i, !llvm.loop !51

addReplyCommandFlags.exit:                        ; preds = %if.end20.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandArgList(ptr noundef %c, ptr nocapture noundef readonly %args, i32 noundef %num_args) local_unnamed_addr #0 {
entry:
  %conv = sext i32 %num_args to i64
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef %conv) #38
  %cmp97 = icmp sgt i32 %num_args, 0
  br i1 %cmp97, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext nneg i32 %num_args to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv
  %key_spec_index = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 2
  %0 = load i32, ptr %key_spec_index, align 4
  %cmp2.not = icmp eq i32 %0, -1
  %spec.select = select i1 %cmp2.not, i64 2, i64 3
  %token = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 3
  %summary = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 4
  %1 = load <2 x ptr>, ptr %token, align 8
  %since = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 5
  %2 = load ptr, ptr %since, align 8
  %deprecated_since = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 7
  %3 = load ptr, ptr %deprecated_since, align 8
  %4 = shufflevector <2 x ptr> %1, <2 x ptr> poison, <4 x i32> <i32 0, i32 1, i32 poison, i32 poison>
  %5 = insertelement <4 x ptr> %4, ptr %2, i64 2
  %6 = insertelement <4 x ptr> %5, ptr %3, i64 3
  %7 = icmp ne <4 x ptr> %6, zeroinitializer
  %flags = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 6
  %8 = load i32, ptr %flags, align 8
  %tobool29.not = icmp ne i32 %8, 0
  %inc31 = zext i1 %tobool29.not to i64
  %type = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 1
  %9 = load i32, ptr %type, align 8
  %.off93 = add i32 %9, -7
  %switch94 = icmp ult i32 %.off93, 2
  %inc43 = zext i1 %switch94 to i64
  %not.switch94 = xor i1 %switch94, true
  %inc47 = zext i1 %not.switch94 to i64
  %10 = bitcast <4 x i1> %7 to i4
  %11 = tail call i4 @llvm.ctpop.i4(i4 %10), !range !52
  %12 = zext nneg i4 %11 to i64
  %op.rdx = add nuw nsw i64 %12, %inc31
  %op.rdx100 = add nuw nsw i64 %inc43, %inc47
  %op.rdx101 = add nuw nsw i64 %op.rdx, %op.rdx100
  %op.rdx102 = add nuw nsw i64 %op.rdx101, %spec.select
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef %op.rdx102) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.265) #38
  %13 = load ptr, ptr %arrayidx, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %13) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.266) #38
  %14 = load i32, ptr %type, align 8
  %idxprom54 = zext i32 %14 to i64
  %arrayidx55 = getelementptr inbounds [9 x ptr], ptr @ARG_TYPE_STR, i64 0, i64 %idxprom54
  %15 = load ptr, ptr %arrayidx55, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %15) #38
  br i1 %switch94, label %if.end67, label %if.then57

if.then57:                                        ; preds = %for.body
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.267) #38
  %display_text = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 10
  %16 = load ptr, ptr %display_text, align 8
  %tobool60.not = icmp eq ptr %16, null
  br i1 %tobool60.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.then57
  %17 = load ptr, ptr %arrayidx, align 8
  br label %cond.end

cond.end:                                         ; preds = %if.then57, %cond.false
  %cond = phi ptr [ %17, %cond.false ], [ %16, %if.then57 ]
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %cond) #38
  br label %if.end67

if.end67:                                         ; preds = %cond.end, %for.body
  %18 = load i32, ptr %key_spec_index, align 4
  %cmp71.not = icmp eq i32 %18, -1
  br i1 %cmp71.not, label %if.end78, label %if.then73

if.then73:                                        ; preds = %if.end67
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.268) #38
  %19 = load i32, ptr %key_spec_index, align 4
  %conv77 = sext i32 %19 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv77) #38
  br label %if.end78

if.end78:                                         ; preds = %if.then73, %if.end67
  %20 = load ptr, ptr %token, align 8
  %tobool82.not = icmp eq ptr %20, null
  br i1 %tobool82.not, label %if.end87, label %if.then83

if.then83:                                        ; preds = %if.end78
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.269) #38
  %21 = load ptr, ptr %token, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %21) #38
  br label %if.end87

if.end87:                                         ; preds = %if.then83, %if.end78
  %22 = load ptr, ptr %summary, align 8
  %tobool91.not = icmp eq ptr %22, null
  br i1 %tobool91.not, label %if.end96, label %if.then92

if.then92:                                        ; preds = %if.end87
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.270) #38
  %23 = load ptr, ptr %summary, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %23) #38
  br label %if.end96

if.end96:                                         ; preds = %if.then92, %if.end87
  %24 = load ptr, ptr %since, align 8
  %tobool100.not = icmp eq ptr %24, null
  br i1 %tobool100.not, label %if.end105, label %if.then101

if.then101:                                       ; preds = %if.end96
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.271) #38
  %25 = load ptr, ptr %since, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %25) #38
  br label %if.end105

if.end105:                                        ; preds = %if.then101, %if.end96
  %26 = load ptr, ptr %deprecated_since, align 8
  %tobool109.not = icmp eq ptr %26, null
  br i1 %tobool109.not, label %if.end114, label %if.then110

if.then110:                                       ; preds = %if.end105
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.272) #38
  %27 = load ptr, ptr %deprecated_since, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %27) #38
  br label %if.end114

if.end114:                                        ; preds = %if.then110, %if.end105
  %28 = load i32, ptr %flags, align 8
  %tobool118.not = icmp eq i32 %28, 0
  br i1 %tobool118.not, label %if.end124, label %if.then119

if.then119:                                       ; preds = %if.end114
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.273) #38
  %29 = load i32, ptr %flags, align 8
  %conv123 = sext i32 %29 to i64
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %if.then119
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %while.body.i.i ], [ 0, %if.then119 ]
  %count.016.i.i = phi i32 [ %spec.select.i.i, %while.body.i.i ], [ 0, %if.then119 ]
  %arrayidx.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForArg.argFlagNames, i64 %indvars.iv.i.i
  %30 = load i64, ptr %arrayidx.i.i, align 16
  %and.i.i = and i64 %30, %conv123
  %tobool3.not.i.i = icmp ne i64 %and.i.i, 0
  %inc.i.i = zext i1 %tobool3.not.i.i to i32
  %spec.select.i.i = add nuw nsw i32 %count.016.i.i, %inc.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i.i, 3
  br i1 %exitcond.i, label %while.end.i.i, label %while.body.i.i, !llvm.loop !50

while.end.i.i:                                    ; preds = %while.body.i.i
  %31 = zext nneg i32 %spec.select.i.i to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %31) #38
  br label %while.body10.i.i

while.body10.i.i:                                 ; preds = %if.end20.i.i, %while.end.i.i
  %indvars.iv24.i.i = phi i64 [ %indvars.iv.next25.i.i, %if.end20.i.i ], [ 0, %while.end.i.i ]
  %32 = phi ptr [ %34, %if.end20.i.i ], [ @.str.262, %while.end.i.i ]
  %arrayidx7.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForArg.argFlagNames, i64 %indvars.iv24.i.i
  %33 = load i64, ptr %arrayidx7.i.i, align 16
  %and14.i.i = and i64 %33, %conv123
  %tobool15.not.i.i = icmp eq i64 %and14.i.i, 0
  br i1 %tobool15.not.i.i, label %if.end20.i.i, label %if.then16.i.i

if.then16.i.i:                                    ; preds = %while.body10.i.i
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %32) #38
  br label %if.end20.i.i

if.end20.i.i:                                     ; preds = %if.then16.i.i, %while.body10.i.i
  %indvars.iv.next25.i.i = add nuw nsw i64 %indvars.iv24.i.i, 1
  %name8.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForArg.argFlagNames, i64 %indvars.iv.next25.i.i, i32 1
  %34 = load ptr, ptr %name8.i.i, align 8
  %exitcond2.i = icmp eq i64 %indvars.iv.next25.i.i, 3
  br i1 %exitcond2.i, label %if.end124, label %while.body10.i.i, !llvm.loop !51

if.end124:                                        ; preds = %if.end20.i.i, %if.end114
  %35 = load i32, ptr %type, align 8
  %.off = add i32 %35, -7
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %if.then136, label %for.inc

if.then136:                                       ; preds = %if.end124
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.274) #38
  %subargs = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 9
  %36 = load ptr, ptr %subargs, align 8
  %num_args141 = getelementptr inbounds %struct.redisCommandArg, ptr %args, i64 %indvars.iv, i32 8
  %37 = load i32, ptr %num_args141, align 8
  tail call void @addReplyCommandArgList(ptr noundef %c, ptr noundef %36, i32 noundef %37)
  br label %for.inc

for.inc:                                          ; preds = %if.end124, %if.then136
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !53

for.end:                                          ; preds = %for.inc, %entry
  ret void
}

declare void @addReplyMapLen(ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @addReplyBulkCString(ptr noundef, ptr noundef) local_unnamed_addr #4

declare void @addReplyLongLong(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandHistory(ptr noundef %c, ptr nocapture noundef readonly %cmd) local_unnamed_addr #0 {
entry:
  %num_history = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 9
  %0 = load i32, ptr %num_history, align 8
  %conv = sext i32 %0 to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %conv) #38
  %1 = load i32, ptr %num_history, align 8
  %cmp10 = icmp sgt i32 %1, 0
  br i1 %cmp10, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %history = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 8
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef 2) #38
  %2 = load ptr, ptr %history, align 8
  %arrayidx = getelementptr inbounds %struct.commandHistory, ptr %2, i64 %indvars.iv
  %3 = load ptr, ptr %arrayidx, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %3) #38
  %4 = load ptr, ptr %history, align 8
  %changes = getelementptr inbounds %struct.commandHistory, ptr %4, i64 %indvars.iv, i32 1
  %5 = load ptr, ptr %changes, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %5) #38
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %6 = load i32, ptr %num_history, align 8
  %7 = sext i32 %6 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %7
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !54

for.end:                                          ; preds = %for.body, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandTips(ptr noundef %c, ptr nocapture noundef readonly %cmd) local_unnamed_addr #0 {
entry:
  %num_tips = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 11
  %0 = load i32, ptr %num_tips, align 8
  %conv = sext i32 %0 to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %conv) #38
  %1 = load i32, ptr %num_tips, align 8
  %cmp6 = icmp sgt i32 %1, 0
  br i1 %cmp6, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %tips = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 10
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %2 = load ptr, ptr %tips, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 %indvars.iv
  %3 = load ptr, ptr %arrayidx, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %3) #38
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %4 = load i32, ptr %num_tips, align 8
  %5 = sext i32 %4 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %5
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !55

for.end:                                          ; preds = %for.body, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandKeySpecs(ptr noundef %c, ptr nocapture noundef readonly %cmd) local_unnamed_addr #0 {
entry:
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 17
  %0 = load i32, ptr %key_specs_num, align 8
  %conv = sext i32 %0 to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %conv) #38
  %1 = load i32, ptr %key_specs_num, align 8
  %cmp96 = icmp sgt i32 %1, 0
  br i1 %cmp96, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 16
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %2 = load ptr, ptr %key_specs, align 8
  %arrayidx = getelementptr inbounds %struct.keySpec, ptr %2, i64 %indvars.iv
  %3 = load ptr, ptr %arrayidx, align 8
  %tobool.not = icmp eq ptr %3, null
  %spec.select = select i1 %tobool.not, i64 3, i64 4
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef %spec.select) #38
  %4 = load ptr, ptr %key_specs, align 8
  %arrayidx6 = getelementptr inbounds %struct.keySpec, ptr %4, i64 %indvars.iv
  %5 = load ptr, ptr %arrayidx6, align 8
  %tobool8.not = icmp eq ptr %5, null
  br i1 %tobool8.not, label %if.end14, label %if.then9

if.then9:                                         ; preds = %for.body
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.275) #38
  %6 = load ptr, ptr %key_specs, align 8
  %arrayidx12 = getelementptr inbounds %struct.keySpec, ptr %6, i64 %indvars.iv
  %7 = load ptr, ptr %arrayidx12, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %7) #38
  br label %if.end14

if.end14:                                         ; preds = %if.then9, %for.body
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.273) #38
  %8 = load ptr, ptr %key_specs, align 8
  %flags = getelementptr inbounds %struct.keySpec, ptr %8, i64 %indvars.iv, i32 1
  %9 = load i64, ptr %flags, align 8
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %if.end14
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %while.body.i.i ], [ 0, %if.end14 ]
  %count.016.i.i = phi i32 [ %spec.select.i.i, %while.body.i.i ], [ 0, %if.end14 ]
  %arrayidx.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv.i.i
  %10 = load i64, ptr %arrayidx.i.i, align 16
  %and.i.i = and i64 %10, %9
  %tobool3.not.i.i = icmp ne i64 %and.i.i, 0
  %inc.i.i = zext i1 %tobool3.not.i.i to i32
  %spec.select.i.i = add nuw nsw i32 %count.016.i.i, %inc.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i.i, 11
  br i1 %exitcond.i, label %while.end.i.i, label %while.body.i.i, !llvm.loop !50

while.end.i.i:                                    ; preds = %while.body.i.i
  %11 = zext nneg i32 %spec.select.i.i to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %11) #38
  br label %while.body10.i.i

while.body10.i.i:                                 ; preds = %if.end20.i.i, %while.end.i.i
  %indvars.iv24.i.i = phi i64 [ %indvars.iv.next25.i.i, %if.end20.i.i ], [ 0, %while.end.i.i ]
  %12 = phi ptr [ %14, %if.end20.i.i ], [ @.str.242, %while.end.i.i ]
  %arrayidx7.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv24.i.i
  %13 = load i64, ptr %arrayidx7.i.i, align 16
  %and14.i.i = and i64 %13, %9
  %tobool15.not.i.i = icmp eq i64 %and14.i.i, 0
  br i1 %tobool15.not.i.i, label %if.end20.i.i, label %if.then16.i.i

if.then16.i.i:                                    ; preds = %while.body10.i.i
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %12) #38
  br label %if.end20.i.i

if.end20.i.i:                                     ; preds = %if.then16.i.i, %while.body10.i.i
  %indvars.iv.next25.i.i = add nuw nsw i64 %indvars.iv24.i.i, 1
  %name8.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv.next25.i.i, i32 1
  %14 = load ptr, ptr %name8.i.i, align 8
  %exitcond2.i = icmp eq i64 %indvars.iv.next25.i.i, 11
  br i1 %exitcond2.i, label %addReplyFlagsForKeyArgs.exit, label %while.body10.i.i, !llvm.loop !51

addReplyFlagsForKeyArgs.exit:                     ; preds = %if.end20.i.i
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.276) #38
  %15 = load ptr, ptr %key_specs, align 8
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %15, i64 %indvars.iv, i32 2
  %16 = load i32, ptr %begin_search_type, align 8
  switch i32 %16, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb21
    i32 3, label %sw.bb26
  ]

sw.bb:                                            ; preds = %addReplyFlagsForKeyArgs.exit
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 2) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.266) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.277) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.278) #38
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 0) #38
  br label %sw.epilog

sw.bb21:                                          ; preds = %addReplyFlagsForKeyArgs.exit
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 2) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.266) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.279) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.278) #38
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 1) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.279) #38
  %17 = load ptr, ptr %key_specs, align 8
  %bs = getelementptr inbounds %struct.keySpec, ptr %17, i64 %indvars.iv, i32 3
  %18 = load i32, ptr %bs, align 8
  %conv25 = sext i32 %18 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv25) #38
  br label %sw.epilog

sw.bb26:                                          ; preds = %addReplyFlagsForKeyArgs.exit
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 2) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.266) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.280) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.278) #38
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 2) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.280) #38
  %19 = load ptr, ptr %key_specs, align 8
  %bs30 = getelementptr inbounds %struct.keySpec, ptr %19, i64 %indvars.iv, i32 3
  %20 = load ptr, ptr %bs30, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %20) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.281) #38
  %21 = load ptr, ptr %key_specs, align 8
  %startfrom = getelementptr inbounds %struct.keySpec, ptr %21, i64 %indvars.iv, i32 3, i32 0, i32 1
  %22 = load i32, ptr %startfrom, align 8
  %conv35 = sext i32 %22 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv35) #38
  br label %sw.epilog

sw.default:                                       ; preds = %addReplyFlagsForKeyArgs.exit
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 4898, ptr noundef nonnull @.str.282, i32 noundef %16) #38
  tail call void @abort() #40
  unreachable

sw.epilog:                                        ; preds = %sw.bb26, %sw.bb21, %sw.bb
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.283) #38
  %23 = load ptr, ptr %key_specs, align 8
  %find_keys_type = getelementptr inbounds %struct.keySpec, ptr %23, i64 %indvars.iv, i32 4
  %24 = load i32, ptr %find_keys_type, align 8
  switch i32 %24, label %sw.default76 [
    i32 1, label %sw.bb43
    i32 2, label %sw.bb44
    i32 3, label %sw.bb59
  ]

sw.bb43:                                          ; preds = %sw.epilog
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 2) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.266) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.277) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.278) #38
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 0) #38
  br label %for.inc

sw.bb44:                                          ; preds = %sw.epilog
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 2) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.266) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.284) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.278) #38
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 3) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.285) #38
  %25 = load ptr, ptr %key_specs, align 8
  %fk = getelementptr inbounds %struct.keySpec, ptr %25, i64 %indvars.iv, i32 5
  %26 = load i32, ptr %fk, align 4
  %conv48 = sext i32 %26 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv48) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.286) #38
  %27 = load ptr, ptr %key_specs, align 8
  %keystep = getelementptr inbounds %struct.keySpec, ptr %27, i64 %indvars.iv, i32 5, i32 0, i32 1
  %28 = load i32, ptr %keystep, align 4
  %conv53 = sext i32 %28 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv53) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.287) #38
  %29 = load ptr, ptr %key_specs, align 8
  %limit = getelementptr inbounds %struct.keySpec, ptr %29, i64 %indvars.iv, i32 5, i32 0, i32 2
  %30 = load i32, ptr %limit, align 4
  %conv58 = sext i32 %30 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv58) #38
  br label %for.inc

sw.bb59:                                          ; preds = %sw.epilog
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 2) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.266) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.288) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.278) #38
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 3) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.289) #38
  %31 = load ptr, ptr %key_specs, align 8
  %fk63 = getelementptr inbounds %struct.keySpec, ptr %31, i64 %indvars.iv, i32 5
  %32 = load i32, ptr %fk63, align 4
  %conv64 = sext i32 %32 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv64) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.290) #38
  %33 = load ptr, ptr %key_specs, align 8
  %firstkey = getelementptr inbounds %struct.keySpec, ptr %33, i64 %indvars.iv, i32 5, i32 0, i32 1
  %34 = load i32, ptr %firstkey, align 4
  %conv69 = sext i32 %34 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv69) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.286) #38
  %35 = load ptr, ptr %key_specs, align 8
  %keystep74 = getelementptr inbounds %struct.keySpec, ptr %35, i64 %indvars.iv, i32 5, i32 0, i32 2
  %36 = load i32, ptr %keystep74, align 4
  %conv75 = sext i32 %36 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv75) #38
  br label %for.inc

sw.default76:                                     ; preds = %sw.epilog
  %begin_search_type80 = getelementptr inbounds %struct.keySpec, ptr %23, i64 %indvars.iv, i32 2
  %37 = load i32, ptr %begin_search_type80, align 8
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 4940, ptr noundef nonnull @.str.291, i32 noundef %37) #38
  tail call void @abort() #40
  unreachable

for.inc:                                          ; preds = %sw.bb43, %sw.bb44, %sw.bb59
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %38 = load i32, ptr %key_specs_num, align 8
  %39 = sext i32 %38 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %39
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !56

for.end:                                          ; preds = %for.inc, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandSubCommands(ptr noundef %c, ptr nocapture noundef readonly %cmd, ptr nocapture noundef readonly %reply_function, i32 noundef %use_map) local_unnamed_addr #0 {
entry:
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 30
  %0 = load ptr, ptr %subcommands_dict, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef 0) #38
  br label %return

if.end:                                           ; preds = %entry
  %tobool1.not = icmp eq i32 %use_map, 0
  %ht_used8 = getelementptr inbounds %struct.dict, ptr %0, i64 0, i32 2
  %1 = load i64, ptr %ht_used8, align 8
  %arrayidx12 = getelementptr inbounds %struct.dict, ptr %0, i64 0, i32 2, i64 1
  %2 = load i64, ptr %arrayidx12, align 8
  %add13 = add i64 %2, %1
  br i1 %tobool1.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef %add13) #38
  br label %if.end14

if.else:                                          ; preds = %if.end
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef %add13) #38
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then2
  %3 = load ptr, ptr %subcommands_dict, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %3) #38
  %call1614 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not15 = icmp eq ptr %call1614, null
  br i1 %cmp.not15, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end14
  br i1 %tobool1.not, label %while.body.us, label %while.body

while.body.us:                                    ; preds = %while.body.lr.ph, %while.body.us
  %call1616.us = phi ptr [ %call16.us, %while.body.us ], [ %call1614, %while.body.lr.ph ]
  %call17.us = tail call ptr @dictGetVal(ptr noundef nonnull %call1616.us) #38
  tail call void %reply_function(ptr noundef %c, ptr noundef %call17.us) #38
  %call16.us = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not.us = icmp eq ptr %call16.us, null
  br i1 %cmp.not.us, label %while.end, label %while.body.us, !llvm.loop !57

while.body:                                       ; preds = %while.body.lr.ph, %sdslen.exit
  %call1616 = phi ptr [ %call16, %sdslen.exit ], [ %call1614, %while.body.lr.ph ]
  %call17 = tail call ptr @dictGetVal(ptr noundef nonnull %call1616) #38
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %call17, i64 0, i32 27
  %4 = load ptr, ptr %fullname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %4, i64 -1
  %5 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %5 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %while.body
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %while.body
  %add.ptr.i = getelementptr inbounds i8, ptr %4, i64 -3
  %6 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %6 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %while.body
  %add.ptr6.i = getelementptr inbounds i8, ptr %4, i64 -5
  %7 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %7 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %while.body
  %add.ptr10.i = getelementptr inbounds i8, ptr %4, i64 -9
  %8 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %8 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %while.body
  %add.ptr14.i = getelementptr inbounds i8, ptr %4, i64 -17
  %9 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %while.body, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %9, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %while.body ]
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %4, i64 noundef %retval.0.i) #38
  tail call void %reply_function(ptr noundef %c, ptr noundef nonnull %call17) #38
  %call16 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not = icmp eq ptr %call16, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !57

while.end:                                        ; preds = %sdslen.exit, %while.body.us, %if.end14
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandInfo(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %tobool.not = icmp eq ptr %cmd, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  tail call void @addReplyNull(ptr noundef %c) #38
  br label %if.end15

if.else:                                          ; preds = %entry
  %begin_search_type = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 29, i32 2
  %0 = load i32, ptr %begin_search_type, align 8
  %cmp.not = icmp eq i32 %0, 0
  br i1 %cmp.not, label %if.end10, label %if.then1

if.then1:                                         ; preds = %if.else
  %bs = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 29, i32 3
  %1 = load i32, ptr %bs, align 8
  %fk = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 29, i32 5
  %2 = load i32, ptr %fk, align 4
  %cmp529 = icmp slt i32 %2, 0
  %add = select i1 %cmp529, i32 0, i32 %1
  %spec.select = add nsw i32 %add, %2
  %keystep9 = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 29, i32 5, i32 0, i32 1
  %3 = load i32, ptr %keystep9, align 4
  %4 = sext i32 %1 to i64
  %5 = sext i32 %spec.select to i64
  %6 = sext i32 %3 to i64
  br label %if.end10

if.end10:                                         ; preds = %if.then1, %if.else
  %firstkey.0 = phi i64 [ %4, %if.then1 ], [ 0, %if.else ]
  %lastkey.1 = phi i64 [ %5, %if.then1 ], [ 0, %if.else ]
  %keystep.0 = phi i64 [ %6, %if.then1 ], [ 0, %if.else ]
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef 10) #38
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 27
  %7 = load ptr, ptr %fullname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %7, i64 -1
  %8 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %8 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end10
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end10
  %add.ptr.i = getelementptr inbounds i8, ptr %7, i64 -3
  %9 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %9 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end10
  %add.ptr6.i = getelementptr inbounds i8, ptr %7, i64 -5
  %10 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %10 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end10
  %add.ptr10.i = getelementptr inbounds i8, ptr %7, i64 -9
  %11 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %11 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end10
  %add.ptr14.i = getelementptr inbounds i8, ptr %7, i64 -17
  %12 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end10, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %12, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end10 ]
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %7, i64 noundef %retval.0.i) #38
  %arity = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 13
  %13 = load i32, ptr %arity, align 8
  %conv = sext i32 %13 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv) #38
  %flags.i = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 14
  %14 = load i64, ptr %flags.i, align 8
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %sdslen.exit
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %while.body.i.i ], [ 0, %sdslen.exit ]
  %count.016.i.i = phi i32 [ %spec.select.i.i, %while.body.i.i ], [ 0, %sdslen.exit ]
  %arrayidx.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForCommand.flagNames, i64 %indvars.iv.i.i
  %15 = load i64, ptr %arrayidx.i.i, align 16
  %and.i.i = and i64 %15, %14
  %tobool3.not.i.i = icmp ne i64 %and.i.i, 0
  %inc.i.i = zext i1 %tobool3.not.i.i to i32
  %spec.select.i.i = add nuw nsw i32 %count.016.i.i, %inc.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i.i, 20
  br i1 %exitcond.i, label %while.end.i.i, label %while.body.i.i, !llvm.loop !50

while.end.i.i:                                    ; preds = %while.body.i.i
  %16 = zext nneg i32 %spec.select.i.i to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %16) #38
  br label %while.body10.i.i

while.body10.i.i:                                 ; preds = %if.end20.i.i, %while.end.i.i
  %indvars.iv24.i.i = phi i64 [ %indvars.iv.next25.i.i, %if.end20.i.i ], [ 0, %while.end.i.i ]
  %17 = phi ptr [ %19, %if.end20.i.i ], [ @.str.220, %while.end.i.i ]
  %arrayidx7.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForCommand.flagNames, i64 %indvars.iv24.i.i
  %18 = load i64, ptr %arrayidx7.i.i, align 16
  %and14.i.i = and i64 %18, %14
  %tobool15.not.i.i = icmp eq i64 %and14.i.i, 0
  br i1 %tobool15.not.i.i, label %if.end20.i.i, label %if.then16.i.i

if.then16.i.i:                                    ; preds = %while.body10.i.i
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %17) #38
  br label %if.end20.i.i

if.end20.i.i:                                     ; preds = %if.then16.i.i, %while.body10.i.i
  %indvars.iv.next25.i.i = add nuw nsw i64 %indvars.iv24.i.i, 1
  %name8.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForCommand.flagNames, i64 %indvars.iv.next25.i.i, i32 1
  %19 = load ptr, ptr %name8.i.i, align 8
  %exitcond2.i = icmp eq i64 %indvars.iv.next25.i.i, 20
  br i1 %exitcond2.i, label %addReplyFlagsForCommand.exit, label %while.body10.i.i, !llvm.loop !51

addReplyFlagsForCommand.exit:                     ; preds = %if.end20.i.i
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %firstkey.0) #38
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %lastkey.1) #38
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %keystep.0) #38
  tail call void @addReplyCommandCategories(ptr noundef %c, ptr noundef nonnull %cmd) #38
  %num_tips.i = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 11
  %20 = load i32, ptr %num_tips.i, align 8
  %conv.i27 = sext i32 %20 to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %conv.i27) #38
  %21 = load i32, ptr %num_tips.i, align 8
  %cmp6.i = icmp sgt i32 %21, 0
  br i1 %cmp6.i, label %for.body.lr.ph.i, label %addReplyCommandTips.exit

for.body.lr.ph.i:                                 ; preds = %addReplyFlagsForCommand.exit
  %tips.i = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 10
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %22 = load ptr, ptr %tips.i, align 8
  %arrayidx.i28 = getelementptr inbounds ptr, ptr %22, i64 %indvars.iv.i
  %23 = load ptr, ptr %arrayidx.i28, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %23) #38
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %24 = load i32, ptr %num_tips.i, align 8
  %25 = sext i32 %24 to i64
  %cmp.i = icmp slt i64 %indvars.iv.next.i, %25
  br i1 %cmp.i, label %for.body.i, label %addReplyCommandTips.exit, !llvm.loop !55

addReplyCommandTips.exit:                         ; preds = %for.body.i, %addReplyFlagsForCommand.exit
  tail call void @addReplyCommandKeySpecs(ptr noundef %c, ptr noundef nonnull %cmd)
  tail call void @addReplyCommandSubCommands(ptr noundef %c, ptr noundef nonnull %cmd, ptr noundef nonnull @addReplyCommandInfo, i32 noundef 0)
  br label %if.end15

if.end15:                                         ; preds = %addReplyCommandTips.exit, %if.then
  ret void
}

declare void @addReplyNull(ptr noundef) local_unnamed_addr #4

declare void @addReplyCommandCategories(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandDocs(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %summary = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 1
  %0 = load ptr, ptr %summary, align 8
  %tobool.not = icmp eq ptr %0, null
  %spec.select = select i1 %tobool.not, i64 1, i64 2
  %since = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 3
  %1 = load ptr, ptr %since, align 8
  %tobool1.not = icmp ne ptr %1, null
  %inc3 = zext i1 %tobool1.not to i64
  %flags = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 14
  %2 = load i64, ptr %flags, align 8
  %and = lshr i64 %2, 3
  %3 = and i64 %and, 1
  %complexity = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 2
  %4 = load ptr, ptr %complexity, align 8
  %tobool9.not = icmp ne ptr %4, null
  %inc11 = zext i1 %tobool9.not to i64
  %doc_flags = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 4
  %5 = load i32, ptr %doc_flags, align 8
  %tobool13.not = icmp ne i32 %5, 0
  %inc15 = zext i1 %tobool13.not to i64
  %deprecated_since = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 6
  %6 = load ptr, ptr %deprecated_since, align 8
  %tobool17.not = icmp ne ptr %6, null
  %inc19 = zext i1 %tobool17.not to i64
  %replaced_by = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 5
  %7 = load ptr, ptr %replaced_by, align 8
  %history = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 8
  %8 = load ptr, ptr %history, align 8
  %args = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 21
  %9 = load ptr, ptr %args, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 30
  %10 = load ptr, ptr %subcommands_dict, align 8
  %11 = insertelement <4 x ptr> poison, ptr %7, i64 0
  %12 = insertelement <4 x ptr> %11, ptr %8, i64 1
  %13 = insertelement <4 x ptr> %12, ptr %9, i64 2
  %14 = insertelement <4 x ptr> %13, ptr %10, i64 3
  %15 = icmp ne <4 x ptr> %14, zeroinitializer
  %16 = bitcast <4 x i1> %15 to i4
  %17 = tail call i4 @llvm.ctpop.i4(i4 %16), !range !52
  %18 = zext nneg i4 %17 to i64
  %op.rdx = add nuw nsw i64 %18, %inc3
  %op.rdx65 = add nuw nsw i64 %inc11, %inc15
  %op.rdx66 = add nuw nsw i64 %3, %inc19
  %op.rdx67 = add nuw nsw i64 %op.rdx, %op.rdx65
  %op.rdx68 = add nuw nsw i64 %op.rdx66, %spec.select
  %op.rdx69 = add nuw nsw i64 %op.rdx67, %op.rdx68
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef %op.rdx69) #38
  %19 = load ptr, ptr %summary, align 8
  %tobool38.not = icmp eq ptr %19, null
  br i1 %tobool38.not, label %if.end41, label %if.then39

if.then39:                                        ; preds = %entry
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.270) #38
  %20 = load ptr, ptr %summary, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %20) #38
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %entry
  %21 = load ptr, ptr %since, align 8
  %tobool43.not = icmp eq ptr %21, null
  br i1 %tobool43.not, label %if.end46, label %if.then44

if.then44:                                        ; preds = %if.end41
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.271) #38
  %22 = load ptr, ptr %since, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %22) #38
  br label %if.end46

if.end46:                                         ; preds = %if.then44, %if.end41
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.292) #38
  %group = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 7
  %23 = load i32, ptr %group, align 8
  %call = tail call ptr @commandGroupStr(i32 noundef %23) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %call) #38
  %24 = load ptr, ptr %complexity, align 8
  %tobool48.not = icmp eq ptr %24, null
  br i1 %tobool48.not, label %if.end51, label %if.then49

if.then49:                                        ; preds = %if.end46
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.293) #38
  %25 = load ptr, ptr %complexity, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %25) #38
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %if.end46
  %26 = load i64, ptr %flags, align 8
  %and53 = and i64 %26, 8
  %tobool54.not = icmp eq i64 %and53, 0
  br i1 %tobool54.not, label %if.end57, label %if.then55

if.then55:                                        ; preds = %if.end51
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.223) #38
  %call56 = tail call ptr @moduleNameFromCommand(ptr noundef nonnull %cmd) #38
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %call56) #38
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %if.end51
  %27 = load i32, ptr %doc_flags, align 8
  %tobool59.not = icmp eq i32 %27, 0
  br i1 %tobool59.not, label %if.end61, label %if.then60

if.then60:                                        ; preds = %if.end57
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.294) #38
  %28 = load i32, ptr %doc_flags, align 8
  %conv.i = sext i32 %28 to i64
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %if.then60
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %while.body.i.i ], [ 0, %if.then60 ]
  %count.016.i.i = phi i32 [ %spec.select.i.i, %while.body.i.i ], [ 0, %if.then60 ]
  %arrayidx.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyDocFlagsForCommand.docFlagNames, i64 %indvars.iv.i.i
  %29 = load i64, ptr %arrayidx.i.i, align 16
  %and.i.i = and i64 %29, %conv.i
  %tobool3.not.i.i = icmp ne i64 %and.i.i, 0
  %inc.i.i = zext i1 %tobool3.not.i.i to i32
  %spec.select.i.i = add nuw nsw i32 %count.016.i.i, %inc.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i.i, 2
  br i1 %exitcond.i, label %while.end.i.i, label %while.body.i.i, !llvm.loop !50

while.end.i.i:                                    ; preds = %while.body.i.i
  %30 = zext nneg i32 %spec.select.i.i to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %30) #38
  br label %while.body10.i.i

while.body10.i.i:                                 ; preds = %if.end20.i.i, %while.end.i.i
  %indvars.iv24.i.i = phi i64 [ %indvars.iv.next25.i.i, %if.end20.i.i ], [ 0, %while.end.i.i ]
  %31 = phi ptr [ %33, %if.end20.i.i ], [ @.str.240, %while.end.i.i ]
  %arrayidx7.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyDocFlagsForCommand.docFlagNames, i64 %indvars.iv24.i.i
  %32 = load i64, ptr %arrayidx7.i.i, align 16
  %and14.i.i = and i64 %32, %conv.i
  %tobool15.not.i.i = icmp eq i64 %and14.i.i, 0
  br i1 %tobool15.not.i.i, label %if.end20.i.i, label %if.then16.i.i

if.then16.i.i:                                    ; preds = %while.body10.i.i
  tail call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %31) #38
  br label %if.end20.i.i

if.end20.i.i:                                     ; preds = %if.then16.i.i, %while.body10.i.i
  %indvars.iv.next25.i.i = add nuw nsw i64 %indvars.iv24.i.i, 1
  %name8.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyDocFlagsForCommand.docFlagNames, i64 %indvars.iv.next25.i.i, i32 1
  %33 = load ptr, ptr %name8.i.i, align 8
  %exitcond2.i = icmp eq i64 %indvars.iv.next25.i.i, 2
  br i1 %exitcond2.i, label %if.end61, label %while.body10.i.i, !llvm.loop !51

if.end61:                                         ; preds = %if.end20.i.i, %if.end57
  %34 = load ptr, ptr %deprecated_since, align 8
  %tobool63.not = icmp eq ptr %34, null
  br i1 %tobool63.not, label %if.end66, label %if.then64

if.then64:                                        ; preds = %if.end61
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.272) #38
  %35 = load ptr, ptr %deprecated_since, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %35) #38
  br label %if.end66

if.end66:                                         ; preds = %if.then64, %if.end61
  %36 = load ptr, ptr %replaced_by, align 8
  %tobool68.not = icmp eq ptr %36, null
  br i1 %tobool68.not, label %if.end71, label %if.then69

if.then69:                                        ; preds = %if.end66
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.295) #38
  %37 = load ptr, ptr %replaced_by, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %37) #38
  br label %if.end71

if.end71:                                         ; preds = %if.then69, %if.end66
  %38 = load ptr, ptr %history, align 8
  %tobool73.not = icmp eq ptr %38, null
  br i1 %tobool73.not, label %if.end75, label %if.then74

if.then74:                                        ; preds = %if.end71
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.296) #38
  %num_history.i = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 9
  %39 = load i32, ptr %num_history.i, align 8
  %conv.i64 = sext i32 %39 to i64
  tail call void @addReplySetLen(ptr noundef %c, i64 noundef %conv.i64) #38
  %40 = load i32, ptr %num_history.i, align 8
  %cmp10.i = icmp sgt i32 %40, 0
  br i1 %cmp10.i, label %for.body.i, label %if.end75

for.body.i:                                       ; preds = %if.then74, %for.body.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body.i ], [ 0, %if.then74 ]
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef 2) #38
  %41 = load ptr, ptr %history, align 8
  %arrayidx.i = getelementptr inbounds %struct.commandHistory, ptr %41, i64 %indvars.iv.i
  %42 = load ptr, ptr %arrayidx.i, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %42) #38
  %43 = load ptr, ptr %history, align 8
  %changes.i = getelementptr inbounds %struct.commandHistory, ptr %43, i64 %indvars.iv.i, i32 1
  %44 = load ptr, ptr %changes.i, align 8
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %44) #38
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %45 = load i32, ptr %num_history.i, align 8
  %46 = sext i32 %45 to i64
  %cmp.i = icmp slt i64 %indvars.iv.next.i, %46
  br i1 %cmp.i, label %for.body.i, label %if.end75, !llvm.loop !54

if.end75:                                         ; preds = %for.body.i, %if.then74, %if.end71
  %47 = load ptr, ptr %args, align 8
  %tobool77.not = icmp eq ptr %47, null
  br i1 %tobool77.not, label %if.end80, label %if.then78

if.then78:                                        ; preds = %if.end75
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.274) #38
  %48 = load ptr, ptr %args, align 8
  %num_args = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 19
  %49 = load i32, ptr %num_args, align 8
  tail call void @addReplyCommandArgList(ptr noundef %c, ptr noundef %48, i32 noundef %49)
  br label %if.end80

if.end80:                                         ; preds = %if.then78, %if.end75
  %50 = load ptr, ptr %subcommands_dict, align 8
  %tobool82.not = icmp eq ptr %50, null
  br i1 %tobool82.not, label %if.end84, label %if.then83

if.then83:                                        ; preds = %if.end80
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.297) #38
  tail call void @addReplyCommandSubCommands(ptr noundef %c, ptr noundef nonnull %cmd, ptr noundef nonnull @addReplyCommandDocs, i32 noundef 1)
  br label %if.end84

if.end84:                                         ; preds = %if.then83, %if.end80
  ret void
}

declare ptr @commandGroupStr(i32 noundef) local_unnamed_addr #4

declare ptr @moduleNameFromCommand(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @getKeysSubcommandImpl(ptr noundef %c, i32 noundef %with_flags) local_unnamed_addr #0 {
entry:
  %result = alloca %struct.getKeysResult, align 8
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %0 = load ptr, ptr %argv, align 8
  %add.ptr = getelementptr inbounds ptr, ptr %0, i64 2
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %1 = load i32, ptr %argc, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %3 = load ptr, ptr %add.ptr, align 8
  %ptr.i.i = getelementptr inbounds %struct.redisObject, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %ptr.i.i, align 8
  %call.i.i = tail call ptr @dictFetchValue(ptr noundef %2, ptr noundef %4) #38
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %if.then, label %land.end.i.i

land.end.i.i:                                     ; preds = %entry
  %subcommands_dict.i.i = getelementptr inbounds %struct.redisCommand, ptr %call.i.i, i64 0, i32 30
  %5 = load ptr, ptr %subcommands_dict.i.i, align 8
  %tobool1.i.i = icmp ne ptr %5, null
  %cmp.i.i = icmp ne i32 %1, 3
  %or.cond.i.i = select i1 %cmp.i.i, i1 %tobool1.i.i, i1 false
  br i1 %or.cond.i.i, label %lookupCommand.exit, label %lookupCommand.exit.thread30

lookupCommand.exit.thread30:                      ; preds = %land.end.i.i
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2064) %result, i8 0, i64 2064, i1 false)
  %6 = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 3
  store i32 256, ptr %6, align 4
  br label %if.else

lookupCommand.exit:                               ; preds = %land.end.i.i
  %arrayidx11.i.i = getelementptr inbounds ptr, ptr %0, i64 3
  %7 = load ptr, ptr %arrayidx11.i.i, align 8
  %ptr12.i.i = getelementptr inbounds %struct.redisObject, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %ptr12.i.i, align 8
  %call.i.i.i = tail call ptr @dictFetchValue(ptr noundef nonnull %5, ptr noundef %8) #38
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2064) %result, i8 0, i64 2064, i1 false)
  %9 = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 3
  store i32 256, ptr %9, align 4
  %tobool.not = icmp eq ptr %call.i.i.i, null
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry, %lookupCommand.exit
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.298) #38
  br label %return

if.else:                                          ; preds = %lookupCommand.exit.thread30, %lookupCommand.exit
  %retval.0.i.i33 = phi ptr [ %call.i.i, %lookupCommand.exit.thread30 ], [ %call.i.i.i, %lookupCommand.exit ]
  %call1 = tail call i32 @doesCommandHaveKeys(ptr noundef nonnull %retval.0.i.i33) #38
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.else
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.299) #38
  br label %return

if.else4:                                         ; preds = %if.else
  %arity = getelementptr inbounds %struct.redisCommand, ptr %retval.0.i.i33, i64 0, i32 13
  %10 = load i32, ptr %arity, align 8
  %cmp = icmp sgt i32 %10, 0
  %.pre = load i32, ptr %argc, align 8
  %sub7 = add nsw i32 %.pre, -2
  %cmp8.not = icmp ne i32 %10, %sub7
  %or.cond.not44 = select i1 %cmp, i1 %cmp8.not, i1 false
  %sub12 = sub nsw i32 0, %10
  %cmp13 = icmp slt i32 %sub7, %sub12
  %or.cond43 = select i1 %or.cond.not44, i1 true, i1 %cmp13
  br i1 %or.cond43, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.else4
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.300) #38
  br label %return

if.end16:                                         ; preds = %if.else4
  %11 = load ptr, ptr %argv, align 8
  %add.ptr18 = getelementptr inbounds ptr, ptr %11, i64 2
  %call21 = call i32 @getKeysFromCommandWithSpecs(ptr noundef nonnull %retval.0.i.i33, ptr noundef nonnull %add.ptr18, i32 noundef %sub7, i32 noundef 0, ptr noundef nonnull %result) #38
  %tobool22.not = icmp eq i32 %call21, 0
  br i1 %tobool22.not, label %if.then23, label %if.else28

if.then23:                                        ; preds = %if.end16
  %flags = getelementptr inbounds %struct.redisCommand, ptr %retval.0.i.i33, i64 0, i32 14
  %12 = load i64, ptr %flags, align 8
  %and = and i64 %12, 524288
  %tobool24.not = icmp eq i64 %and, 0
  br i1 %tobool24.not, label %if.else26, label %if.then25

if.then25:                                        ; preds = %if.then23
  call void @addReplyArrayLen(ptr noundef nonnull %c, i64 noundef 0) #38
  br label %if.end52

if.else26:                                        ; preds = %if.then23
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.301) #38
  br label %if.end52

if.else28:                                        ; preds = %if.end16
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 2
  %13 = load i32, ptr %numkeys, align 8
  %conv = sext i32 %13 to i64
  call void @addReplyArrayLen(ptr noundef nonnull %c, i64 noundef %conv) #38
  %14 = load i32, ptr %numkeys, align 8
  %cmp3034 = icmp sgt i32 %14, 0
  br i1 %cmp3034, label %for.body.lr.ph, label %if.end52

for.body.lr.ph:                                   ; preds = %if.else28
  %tobool32.not = icmp eq i32 %with_flags, 0
  %keys39 = getelementptr inbounds %struct.getKeysResult, ptr %result, i64 0, i32 1
  br i1 %tobool32.not, label %for.body.us, label %for.body

for.body.us:                                      ; preds = %for.body.lr.ph, %for.body.us
  %indvars.iv38 = phi i64 [ %indvars.iv.next39, %for.body.us ], [ 0, %for.body.lr.ph ]
  %15 = load ptr, ptr %argv, align 8
  %16 = load ptr, ptr %keys39, align 8
  %arrayidx.us = getelementptr inbounds %struct.keyReference, ptr %16, i64 %indvars.iv38
  %17 = load i32, ptr %arrayidx.us, align 4
  %18 = sext i32 %17 to i64
  %19 = getelementptr ptr, ptr %15, i64 %18
  %arrayidx36.us = getelementptr ptr, ptr %19, i64 2
  %20 = load ptr, ptr %arrayidx36.us, align 8
  call void @addReplyBulk(ptr noundef nonnull %c, ptr noundef %20) #38
  %indvars.iv.next39 = add nuw nsw i64 %indvars.iv38, 1
  %21 = load i32, ptr %numkeys, align 8
  %22 = sext i32 %21 to i64
  %cmp30.us = icmp slt i64 %indvars.iv.next39, %22
  br i1 %cmp30.us, label %for.body.us, label %if.end52, !llvm.loop !58

for.body:                                         ; preds = %for.body.lr.ph, %for.inc.loopexit
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc.loopexit ], [ 0, %for.body.lr.ph ]
  call void @addReplyArrayLen(ptr noundef %c, i64 noundef 2) #38
  %23 = load ptr, ptr %argv, align 8
  %24 = load ptr, ptr %keys39, align 8
  %arrayidx41 = getelementptr inbounds %struct.keyReference, ptr %24, i64 %indvars.iv
  %25 = load i32, ptr %arrayidx41, align 4
  %26 = sext i32 %25 to i64
  %27 = getelementptr ptr, ptr %23, i64 %26
  %arrayidx45 = getelementptr ptr, ptr %27, i64 2
  %28 = load ptr, ptr %arrayidx45, align 8
  call void @addReplyBulk(ptr noundef %c, ptr noundef %28) #38
  %29 = load ptr, ptr %keys39, align 8
  %flags49 = getelementptr inbounds %struct.keyReference, ptr %29, i64 %indvars.iv, i32 1
  %30 = load i32, ptr %flags49, align 4
  %conv50 = sext i32 %30 to i64
  br label %while.body.i.i

while.body.i.i:                                   ; preds = %while.body.i.i, %for.body
  %indvars.iv.i.i = phi i64 [ %indvars.iv.next.i.i, %while.body.i.i ], [ 0, %for.body ]
  %count.016.i.i = phi i32 [ %spec.select.i.i, %while.body.i.i ], [ 0, %for.body ]
  %arrayidx.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv.i.i
  %31 = load i64, ptr %arrayidx.i.i, align 16
  %and.i.i = and i64 %31, %conv50
  %tobool3.not.i.i = icmp ne i64 %and.i.i, 0
  %inc.i.i = zext i1 %tobool3.not.i.i to i32
  %spec.select.i.i = add nuw nsw i32 %count.016.i.i, %inc.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.i = icmp eq i64 %indvars.iv.next.i.i, 11
  br i1 %exitcond.i, label %while.end.i.i, label %while.body.i.i, !llvm.loop !50

while.end.i.i:                                    ; preds = %while.body.i.i
  %32 = zext nneg i32 %spec.select.i.i to i64
  call void @addReplySetLen(ptr noundef %c, i64 noundef %32) #38
  br label %while.body10.i.i

while.body10.i.i:                                 ; preds = %if.end20.i.i, %while.end.i.i
  %indvars.iv24.i.i = phi i64 [ %indvars.iv.next25.i.i, %if.end20.i.i ], [ 0, %while.end.i.i ]
  %33 = phi ptr [ %35, %if.end20.i.i ], [ @.str.242, %while.end.i.i ]
  %arrayidx7.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv24.i.i
  %34 = load i64, ptr %arrayidx7.i.i, align 16
  %and14.i.i = and i64 %34, %conv50
  %tobool15.not.i.i = icmp eq i64 %and14.i.i, 0
  br i1 %tobool15.not.i.i, label %if.end20.i.i, label %if.then16.i.i

if.then16.i.i:                                    ; preds = %while.body10.i.i
  call void @addReplyStatus(ptr noundef %c, ptr noundef nonnull %33) #38
  br label %if.end20.i.i

if.end20.i.i:                                     ; preds = %if.then16.i.i, %while.body10.i.i
  %indvars.iv.next25.i.i = add nuw nsw i64 %indvars.iv24.i.i, 1
  %name8.i.i = getelementptr inbounds %struct.replyFlagNames, ptr @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 %indvars.iv.next25.i.i, i32 1
  %35 = load ptr, ptr %name8.i.i, align 8
  %exitcond2.i = icmp eq i64 %indvars.iv.next25.i.i, 11
  br i1 %exitcond2.i, label %for.inc.loopexit, label %while.body10.i.i, !llvm.loop !51

for.inc.loopexit:                                 ; preds = %if.end20.i.i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %36 = load i32, ptr %numkeys, align 8
  %37 = sext i32 %36 to i64
  %cmp30 = icmp slt i64 %indvars.iv.next, %37
  br i1 %cmp30, label %for.body, label %if.end52, !llvm.loop !58

if.end52:                                         ; preds = %for.inc.loopexit, %for.body.us, %if.else28, %if.then25, %if.else26
  call void @getKeysFreeResult(ptr noundef nonnull %result) #38
  br label %return

return:                                           ; preds = %if.end52, %if.then14, %if.then3, %if.then
  ret void
}

declare void @addReplyError(ptr noundef, ptr noundef) local_unnamed_addr #4

declare i32 @doesCommandHaveKeys(ptr noundef) local_unnamed_addr #4

declare i32 @getKeysFromCommandWithSpecs(ptr noundef, ptr noundef, i32 noundef, i32 noundef, ptr noundef) local_unnamed_addr #4

declare void @getKeysFreeResult(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @commandGetKeysAndFlagsCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  tail call void @getKeysSubcommandImpl(ptr noundef %c, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @getKeysSubcommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  tail call void @getKeysSubcommandImpl(ptr noundef %c, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %0, i64 0, i32 2
  %1 = load i64, ptr %ht_used, align 8
  %arrayidx2 = getelementptr inbounds %struct.dict, ptr %0, i64 0, i32 2, i64 1
  %2 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %2, %1
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef %add) #38
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %3) #38
  %call33 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not4 = icmp eq ptr %call33, null
  br i1 %cmp.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body
  %call35 = phi ptr [ %call3, %while.body ], [ %call33, %entry ]
  %call4 = tail call ptr @dictGetVal(ptr noundef nonnull %call35) #38
  tail call void @addReplyCommandInfo(ptr noundef %c, ptr noundef %call4)
  %call3 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not = icmp eq ptr %call3, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !59

while.end:                                        ; preds = %while.body, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  ret void
}

declare ptr @dictGetIterator(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @commandCountCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %0, i64 0, i32 2
  %1 = load i64, ptr %ht_used, align 8
  %arrayidx2 = getelementptr inbounds %struct.dict, ptr %0, i64 0, i32 2, i64 1
  %2 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %2, %1
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %add) #38
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @shouldFilterFromCommandList(ptr noundef %cmd, ptr nocapture noundef %filter) local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr %filter, align 8
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb8
    i32 2, label %sw.bb27
  ]

sw.bb:                                            ; preds = %entry
  %cache = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 2
  %1 = load i32, ptr %cache, align 8
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %if.then, label %sw.bb.if.end_crit_edge

sw.bb.if.end_crit_edge:                           ; preds = %sw.bb
  %u5.phi.trans.insert = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 2, i32 1
  %.pre37 = load ptr, ptr %u5.phi.trans.insert, align 8
  br label %if.end

if.then:                                          ; preds = %sw.bb
  %arg = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 1
  %2 = load ptr, ptr %arg, align 8
  %call = tail call ptr @moduleGetHandleByName(ptr noundef %2) #38
  %u = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 2, i32 1
  store ptr %call, ptr %u, align 8
  store i32 1, ptr %cache, align 8
  br label %if.end

if.end:                                           ; preds = %sw.bb.if.end_crit_edge, %if.then
  %3 = phi ptr [ %.pre37, %sw.bb.if.end_crit_edge ], [ %call, %if.then ]
  %call6 = tail call i32 @moduleIsModuleCommand(ptr noundef %3, ptr noundef %cmd) #38
  %tobool7.not = icmp eq i32 %call6, 0
  br label %return

sw.bb8:                                           ; preds = %entry
  %cache9 = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 2
  %4 = load i32, ptr %cache9, align 8
  %tobool11.not = icmp eq i32 %4, 0
  br i1 %tobool11.not, label %if.then12, label %sw.bb8.if.end19_crit_edge

sw.bb8.if.end19_crit_edge:                        ; preds = %sw.bb8
  %u21.phi.trans.insert = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 2, i32 1
  %.pre = load i64, ptr %u21.phi.trans.insert, align 8
  br label %if.end19

if.then12:                                        ; preds = %sw.bb8
  %arg13 = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 1
  %5 = load ptr, ptr %arg13, align 8
  %call14 = tail call i64 @ACLGetCommandCategoryFlagByName(ptr noundef %5) #38
  %u16 = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 2, i32 1
  store i64 %call14, ptr %u16, align 8
  store i32 1, ptr %cache9, align 8
  br label %if.end19

if.end19:                                         ; preds = %sw.bb8.if.end19_crit_edge, %if.then12
  %6 = phi i64 [ %.pre, %sw.bb8.if.end19_crit_edge ], [ %call14, %if.then12 ]
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %return, label %if.end23

if.end23:                                         ; preds = %if.end19
  %acl_categories = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 15
  %7 = load i64, ptr %acl_categories, align 8
  %and = and i64 %7, %6
  %tobool24.not = icmp eq i64 %and, 0
  br label %return

sw.bb27:                                          ; preds = %entry
  %arg28 = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 1
  %8 = load ptr, ptr %arg28, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %8, i64 -1
  %9 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %9 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %sw.bb27
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %sw.bb27
  %add.ptr.i = getelementptr inbounds i8, ptr %8, i64 -3
  %10 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %10 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %sw.bb27
  %add.ptr6.i = getelementptr inbounds i8, ptr %8, i64 -5
  %11 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %11 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %sw.bb27
  %add.ptr10.i = getelementptr inbounds i8, ptr %8, i64 -9
  %12 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %12 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %sw.bb27
  %add.ptr14.i = getelementptr inbounds i8, ptr %8, i64 -17
  %13 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb27, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %13, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %sw.bb27 ]
  %conv = trunc i64 %retval.0.i to i32
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %cmd, i64 0, i32 27
  %14 = load ptr, ptr %fullname, align 8
  %arrayidx.i18 = getelementptr inbounds i8, ptr %14, i64 -1
  %15 = load i8, ptr %arrayidx.i18, align 1
  %conv.i19 = zext i8 %15 to i32
  %and.i20 = and i32 %conv.i19, 7
  switch i32 %and.i20, label %sdslen.exit36 [
    i32 0, label %sw.bb.i33
    i32 1, label %sw.bb3.i30
    i32 2, label %sw.bb5.i27
    i32 3, label %sw.bb9.i24
    i32 4, label %sw.bb13.i21
  ]

sw.bb.i33:                                        ; preds = %sdslen.exit
  %shr.i34 = lshr i32 %conv.i19, 3
  %conv2.i35 = zext nneg i32 %shr.i34 to i64
  br label %sdslen.exit36

sw.bb3.i30:                                       ; preds = %sdslen.exit
  %add.ptr.i31 = getelementptr inbounds i8, ptr %14, i64 -3
  %16 = load i8, ptr %add.ptr.i31, align 1
  %conv4.i32 = zext i8 %16 to i64
  br label %sdslen.exit36

sw.bb5.i27:                                       ; preds = %sdslen.exit
  %add.ptr6.i28 = getelementptr inbounds i8, ptr %14, i64 -5
  %17 = load i16, ptr %add.ptr6.i28, align 1
  %conv8.i29 = zext i16 %17 to i64
  br label %sdslen.exit36

sw.bb9.i24:                                       ; preds = %sdslen.exit
  %add.ptr10.i25 = getelementptr inbounds i8, ptr %14, i64 -9
  %18 = load i32, ptr %add.ptr10.i25, align 1
  %conv12.i26 = zext i32 %18 to i64
  br label %sdslen.exit36

sw.bb13.i21:                                      ; preds = %sdslen.exit
  %add.ptr14.i22 = getelementptr inbounds i8, ptr %14, i64 -17
  %19 = load i64, ptr %add.ptr14.i22, align 1
  br label %sdslen.exit36

sdslen.exit36:                                    ; preds = %sdslen.exit, %sw.bb.i33, %sw.bb3.i30, %sw.bb5.i27, %sw.bb9.i24, %sw.bb13.i21
  %retval.0.i23 = phi i64 [ %19, %sw.bb13.i21 ], [ %conv12.i26, %sw.bb9.i24 ], [ %conv8.i29, %sw.bb5.i27 ], [ %conv4.i32, %sw.bb3.i30 ], [ %conv2.i35, %sw.bb.i33 ], [ 0, %sdslen.exit ]
  %conv33 = trunc i64 %retval.0.i23 to i32
  %call34 = tail call i32 @stringmatchlen(ptr noundef nonnull %8, i32 noundef %conv, ptr noundef nonnull %14, i32 noundef %conv33, i32 noundef 1) #38
  %tobool35.not = icmp eq i32 %call34, 0
  br label %return

sw.default:                                       ; preds = %entry
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 5175, ptr noundef nonnull @.str.302, i32 noundef %0) #38
  tail call void @abort() #40
  unreachable

return:                                           ; preds = %if.end19, %sdslen.exit36, %if.end23, %if.end
  %retval.0.shrunk = phi i1 [ %tobool35.not, %sdslen.exit36 ], [ %tobool24.not, %if.end23 ], [ %tobool7.not, %if.end ], [ true, %if.end19 ]
  %retval.0 = zext i1 %retval.0.shrunk to i32
  ret i32 %retval.0
}

declare ptr @moduleGetHandleByName(ptr noundef) local_unnamed_addr #4

declare i32 @moduleIsModuleCommand(ptr noundef, ptr noundef) local_unnamed_addr #4

declare i64 @ACLGetCommandCategoryFlagByName(ptr noundef) local_unnamed_addr #4

declare i32 @stringmatchlen(ptr noundef, i32 noundef, ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @commandListWithFilter(ptr noundef %c, ptr noundef %commands, ptr nocapture noundef byval(%struct.commandListFilter) align 8 %filter, ptr nocapture noundef %numcmds) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @dictGetIterator(ptr noundef %commands) #38
  %call18 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not9 = icmp eq ptr %call18, null
  br i1 %cmp.not9, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end9
  %call110 = phi ptr [ %call1, %if.end9 ], [ %call18, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call110) #38
  %call3 = call i32 @shouldFilterFromCommandList(ptr noundef %call2, ptr noundef nonnull %filter), !range !13
  %tobool.not = icmp eq i32 %call3, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 27
  %0 = load ptr, ptr %fullname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then ]
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %0, i64 noundef %retval.0.i) #38
  %6 = load i32, ptr %numcmds, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %numcmds, align 4
  br label %if.end

if.end:                                           ; preds = %sdslen.exit, %while.body
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 30
  %7 = load ptr, ptr %subcommands_dict, align 8
  %tobool6.not = icmp eq ptr %7, null
  br i1 %tobool6.not, label %if.end9, label %if.then7

if.then7:                                         ; preds = %if.end
  tail call void @commandListWithFilter(ptr noundef %c, ptr noundef nonnull %7, ptr noundef nonnull byval(%struct.commandListFilter) align 8 %filter, ptr noundef %numcmds)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  %call1 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !60

while.end:                                        ; preds = %if.end9, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandListWithoutFilter(ptr noundef %c, ptr noundef %commands, ptr nocapture noundef %numcmds) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @dictGetIterator(ptr noundef %commands) #38
  %call17 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not8 = icmp eq ptr %call17, null
  br i1 %cmp.not8, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call19 = phi ptr [ %call1, %if.end ], [ %call17, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call19) #38
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 27
  %0 = load ptr, ptr %fullname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %while.body
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %while.body
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %while.body
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %while.body
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %while.body
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %while.body, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %while.body ]
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %0, i64 noundef %retval.0.i) #38
  %6 = load i32, ptr %numcmds, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %numcmds, align 4
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 30
  %7 = load ptr, ptr %subcommands_dict, align 8
  %tobool.not = icmp eq ptr %7, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %sdslen.exit
  tail call void @commandListWithoutFilter(ptr noundef %c, ptr noundef nonnull %7, ptr noundef nonnull %numcmds)
  br label %if.end

if.end:                                           ; preds = %if.then, %sdslen.exit
  %call1 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !61

while.end:                                        ; preds = %if.end, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandListCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %filter = alloca %struct.commandListFilter, align 8
  %numcmds = alloca i32, align 4
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %filter, i8 0, i64 32, i1 false)
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %0 = load i32, ptr %argc, align 8
  %cmp23 = icmp slt i32 %0, 3
  br i1 %cmp23, label %for.end.thread, label %for.body.lr.ph

for.end.thread:                                   ; preds = %entry
  store i32 0, ptr %numcmds, align 4
  %call3139 = tail call ptr @addReplyDeferredLen(ptr noundef nonnull %c) #38
  br label %if.else34

for.body.lr.ph:                                   ; preds = %entry
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %1 = load ptr, ptr %argv, align 8
  %invariant.gep = getelementptr ptr, ptr %1, i64 2
  %arg = getelementptr inbounds %struct.commandListFilter, ptr %filter, i64 0, i32 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %if.end22
  %indvars.iv = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next, %if.end22 ]
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i64 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call = tail call i32 @strcasecmp(ptr noundef %3, ptr noundef nonnull @.str.303) #39
  %tobool = icmp eq i32 %call, 0
  %4 = trunc i64 %indvars.iv to i32
  %5 = sub i32 %4, %0
  %cmp3 = icmp eq i32 %5, -3
  %or.cond = and i1 %cmp3, %tobool
  br i1 %or.cond, label %if.then, label %if.else29

if.then:                                          ; preds = %for.body
  %arrayidx6 = getelementptr ptr, ptr %arrayidx, i64 1
  %6 = load ptr, ptr %arrayidx6, align 8
  %ptr7 = getelementptr inbounds %struct.redisObject, ptr %6, i64 0, i32 2
  %7 = load ptr, ptr %ptr7, align 8
  %call8 = tail call i32 @strcasecmp(ptr noundef %7, ptr noundef nonnull @.str.223) #39
  %tobool9.not = icmp eq i32 %call8, 0
  br i1 %tobool9.not, label %if.end22, label %if.else

if.else:                                          ; preds = %if.then
  %call11 = tail call i32 @strcasecmp(ptr noundef %7, ptr noundef nonnull @.str.304) #39
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %if.end22, label %if.else15

if.else15:                                        ; preds = %if.else
  %call16 = tail call i32 @strcasecmp(ptr noundef %7, ptr noundef nonnull @.str.257) #39
  %tobool17.not = icmp eq i32 %call16, 0
  br i1 %tobool17.not, label %if.end22, label %if.else20

if.else20:                                        ; preds = %if.else15
  %8 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 15), align 8
  tail call void @addReplyErrorObject(ptr noundef nonnull %c, ptr noundef %8) #38
  br label %return

if.end22:                                         ; preds = %if.else15, %if.else, %if.then
  %9 = phi i32 [ 0, %if.then ], [ 1, %if.else ], [ 2, %if.else15 ]
  %indvars.iv.next = add nuw i64 %indvars.iv, 3
  %10 = trunc i64 %indvars.iv.next to i32
  %cmp = icmp sgt i32 %0, %10
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !62

if.else29:                                        ; preds = %for.body
  %11 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 15), align 8
  tail call void @addReplyErrorObject(ptr noundef nonnull %c, ptr noundef %11) #38
  br label %return

for.end:                                          ; preds = %if.end22
  %gep.le = getelementptr ptr, ptr %invariant.gep, i64 %indvars.iv
  %12 = load ptr, ptr %gep.le, align 8
  %ptr27.le = getelementptr inbounds %struct.redisObject, ptr %12, i64 0, i32 2
  %13 = load ptr, ptr %ptr27.le, align 8
  store ptr %13, ptr %arg, align 8
  store i32 %9, ptr %filter, align 8
  store i32 0, ptr %numcmds, align 4
  %call31 = tail call ptr @addReplyDeferredLen(ptr noundef nonnull %c) #38
  br i1 %cmp23, label %if.else34, label %if.then33

if.then33:                                        ; preds = %for.end
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  call void @commandListWithFilter(ptr noundef nonnull %c, ptr noundef %14, ptr noundef nonnull byval(%struct.commandListFilter) align 8 %filter, ptr noundef nonnull %numcmds)
  br label %if.end35

if.else34:                                        ; preds = %for.end.thread, %for.end
  %call3141 = phi ptr [ %call3139, %for.end.thread ], [ %call31, %for.end ]
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  call void @commandListWithoutFilter(ptr noundef nonnull %c, ptr noundef %15, ptr noundef nonnull %numcmds)
  br label %if.end35

if.end35:                                         ; preds = %if.else34, %if.then33
  %call3140 = phi ptr [ %call3141, %if.else34 ], [ %call31, %if.then33 ]
  %16 = load i32, ptr %numcmds, align 4
  %conv = sext i32 %16 to i64
  tail call void @setDeferredArrayLen(ptr noundef nonnull %c, ptr noundef %call3140, i64 noundef %conv) #38
  br label %return

return:                                           ; preds = %if.end35, %if.else29, %if.else20
  ret void
}

declare ptr @addReplyDeferredLen(ptr noundef) local_unnamed_addr #4

declare void @setDeferredArrayLen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @commandInfoCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %0 = load i32, ptr %argc, align 8
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2
  %2 = load i64, ptr %ht_used, align 8
  %arrayidx2 = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2, i64 1
  %3 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %3, %2
  tail call void @addReplyArrayLen(ptr noundef nonnull %c, i64 noundef %add) #38
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %4) #38
  %call313 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp4.not14 = icmp eq ptr %call313, null
  br i1 %cmp4.not14, label %while.end, label %while.body

while.body:                                       ; preds = %if.then, %while.body
  %call315 = phi ptr [ %call3, %while.body ], [ %call313, %if.then ]
  %call5 = tail call ptr @dictGetVal(ptr noundef nonnull %call315) #38
  tail call void @addReplyCommandInfo(ptr noundef %c, ptr noundef %call5)
  %call3 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp4.not = icmp eq ptr %call3, null
  br i1 %cmp4.not, label %while.end, label %while.body, !llvm.loop !63

while.end:                                        ; preds = %while.body, %if.then
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  br label %if.end

if.else:                                          ; preds = %entry
  %sub = add nsw i32 %0, -2
  %conv = sext i32 %sub to i64
  tail call void @addReplyArrayLen(ptr noundef nonnull %c, i64 noundef %conv) #38
  %5 = load i32, ptr %argc, align 8
  %cmp811 = icmp sgt i32 %5, 2
  br i1 %cmp811, label %for.body.lr.ph, label %if.end

for.body.lr.ph:                                   ; preds = %if.else
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %6 = load ptr, ptr %argv, align 8
  %arrayidx10 = getelementptr inbounds ptr, ptr %6, i64 %indvars.iv
  %7 = load ptr, ptr %arrayidx10, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %ptr, align 8
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call.i = tail call ptr @lookupCommandBySdsLogic(ptr noundef %9, ptr noundef %8)
  tail call void @addReplyCommandInfo(ptr noundef nonnull %c, ptr noundef %call.i)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %10 = load i32, ptr %argc, align 8
  %11 = sext i32 %10 to i64
  %cmp8 = icmp slt i64 %indvars.iv.next, %11
  br i1 %cmp8, label %for.body, label %if.end, !llvm.loop !64

if.end:                                           ; preds = %for.body, %if.else, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandDocsCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %0 = load i32, ptr %argc, align 8
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2
  %2 = load i64, ptr %ht_used, align 8
  %arrayidx2 = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2, i64 1
  %3 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %3, %2
  tail call void @addReplyMapLen(ptr noundef nonnull %c, i64 noundef %add) #38
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call = tail call ptr @dictGetIterator(ptr noundef %4) #38
  %call341 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp4.not42 = icmp eq ptr %call341, null
  br i1 %cmp4.not42, label %while.end, label %while.body

while.body:                                       ; preds = %if.then, %sdslen.exit
  %call343 = phi ptr [ %call3, %sdslen.exit ], [ %call341, %if.then ]
  %call5 = tail call ptr @dictGetVal(ptr noundef nonnull %call343) #38
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %call5, i64 0, i32 27
  %5 = load ptr, ptr %fullname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %5, i64 -1
  %6 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %6 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %while.body
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %while.body
  %add.ptr.i = getelementptr inbounds i8, ptr %5, i64 -3
  %7 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %7 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %while.body
  %add.ptr6.i = getelementptr inbounds i8, ptr %5, i64 -5
  %8 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %8 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %while.body
  %add.ptr10.i = getelementptr inbounds i8, ptr %5, i64 -9
  %9 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %9 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %while.body
  %add.ptr14.i = getelementptr inbounds i8, ptr %5, i64 -17
  %10 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %while.body, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %10, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %while.body ]
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %5, i64 noundef %retval.0.i) #38
  tail call void @addReplyCommandDocs(ptr noundef %c, ptr noundef nonnull %call5)
  %call3 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp4.not = icmp eq ptr %call3, null
  br i1 %cmp4.not, label %while.end, label %while.body, !llvm.loop !65

while.end:                                        ; preds = %sdslen.exit, %if.then
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  br label %if.end19

if.else:                                          ; preds = %entry
  %call8 = tail call ptr @addReplyDeferredLen(ptr noundef nonnull %c) #38
  %11 = load i32, ptr %argc, align 8
  %cmp1038 = icmp sgt i32 %11, 2
  br i1 %cmp1038, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.else
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 2, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %numcmds.039 = phi i32 [ 0, %for.body.lr.ph ], [ %numcmds.1, %for.inc ]
  %12 = load ptr, ptr %argv, align 8
  %arrayidx12 = getelementptr inbounds ptr, ptr %12, i64 %indvars.iv
  %13 = load ptr, ptr %arrayidx12, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %13, i64 0, i32 2
  %14 = load ptr, ptr %ptr, align 8
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call.i = tail call ptr @lookupCommandBySdsLogic(ptr noundef %15, ptr noundef %14)
  %tobool.not = icmp eq ptr %call.i, null
  br i1 %tobool.not, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %fullname15 = getelementptr inbounds %struct.redisCommand, ptr %call.i, i64 0, i32 27
  %16 = load ptr, ptr %fullname15, align 8
  %arrayidx.i19 = getelementptr inbounds i8, ptr %16, i64 -1
  %17 = load i8, ptr %arrayidx.i19, align 1
  %conv.i20 = zext i8 %17 to i32
  %and.i21 = and i32 %conv.i20, 7
  switch i32 %and.i21, label %sdslen.exit37 [
    i32 0, label %sw.bb.i34
    i32 1, label %sw.bb3.i31
    i32 2, label %sw.bb5.i28
    i32 3, label %sw.bb9.i25
    i32 4, label %sw.bb13.i22
  ]

sw.bb.i34:                                        ; preds = %if.end
  %shr.i35 = lshr i32 %conv.i20, 3
  %conv2.i36 = zext nneg i32 %shr.i35 to i64
  br label %sdslen.exit37

sw.bb3.i31:                                       ; preds = %if.end
  %add.ptr.i32 = getelementptr inbounds i8, ptr %16, i64 -3
  %18 = load i8, ptr %add.ptr.i32, align 1
  %conv4.i33 = zext i8 %18 to i64
  br label %sdslen.exit37

sw.bb5.i28:                                       ; preds = %if.end
  %add.ptr6.i29 = getelementptr inbounds i8, ptr %16, i64 -5
  %19 = load i16, ptr %add.ptr6.i29, align 1
  %conv8.i30 = zext i16 %19 to i64
  br label %sdslen.exit37

sw.bb9.i25:                                       ; preds = %if.end
  %add.ptr10.i26 = getelementptr inbounds i8, ptr %16, i64 -9
  %20 = load i32, ptr %add.ptr10.i26, align 1
  %conv12.i27 = zext i32 %20 to i64
  br label %sdslen.exit37

sw.bb13.i22:                                      ; preds = %if.end
  %add.ptr14.i23 = getelementptr inbounds i8, ptr %16, i64 -17
  %21 = load i64, ptr %add.ptr14.i23, align 1
  br label %sdslen.exit37

sdslen.exit37:                                    ; preds = %if.end, %sw.bb.i34, %sw.bb3.i31, %sw.bb5.i28, %sw.bb9.i25, %sw.bb13.i22
  %retval.0.i24 = phi i64 [ %21, %sw.bb13.i22 ], [ %conv12.i27, %sw.bb9.i25 ], [ %conv8.i30, %sw.bb5.i28 ], [ %conv4.i33, %sw.bb3.i31 ], [ %conv2.i36, %sw.bb.i34 ], [ 0, %if.end ]
  tail call void @addReplyBulkCBuffer(ptr noundef nonnull %c, ptr noundef nonnull %16, i64 noundef %retval.0.i24) #38
  tail call void @addReplyCommandDocs(ptr noundef nonnull %c, ptr noundef nonnull %call.i)
  %inc = add nsw i32 %numcmds.039, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %sdslen.exit37
  %numcmds.1 = phi i32 [ %inc, %sdslen.exit37 ], [ %numcmds.039, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %22 = load i32, ptr %argc, align 8
  %23 = sext i32 %22 to i64
  %cmp10 = icmp slt i64 %indvars.iv.next, %23
  br i1 %cmp10, label %for.body, label %for.end.loopexit, !llvm.loop !66

for.end.loopexit:                                 ; preds = %for.inc
  %24 = sext i32 %numcmds.1 to i64
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.else
  %numcmds.0.lcssa = phi i64 [ 0, %if.else ], [ %24, %for.end.loopexit ]
  tail call void @setDeferredMapLen(ptr noundef nonnull %c, ptr noundef %call8, i64 noundef %numcmds.0.lcssa) #38
  br label %if.end19

if.end19:                                         ; preds = %for.end, %while.end
  ret void
}

declare void @setDeferredMapLen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @commandGetKeysCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  tail call void @getKeysSubcommandImpl(ptr noundef %c, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandHelpCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %help = alloca [19 x ptr], align 16
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(152) %help, ptr noundef nonnull align 16 dereferenceable(152) @__const.commandHelpCommand.help, i64 152, i1 false)
  call void @addReplyHelp(ptr noundef %c, ptr noundef nonnull %help) #38
  ret void
}

declare void @addReplyHelp(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nofree nounwind uwtable
define dso_local void @bytesToHuman(ptr nocapture noundef writeonly %s, i64 noundef %size, i64 noundef %n) local_unnamed_addr #8 {
entry:
  %cmp = icmp ult i64 %n, 1024
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %s, i64 noundef %size, ptr noundef nonnull @.str.321, i64 noundef %n) #38
  br label %if.end38

if.else:                                          ; preds = %entry
  %cmp1 = icmp ult i64 %n, 1048576
  br i1 %cmp1, label %if.then2, label %if.else4

if.then2:                                         ; preds = %if.else
  %conv = uitofp i64 %n to double
  %div = fmul double %conv, 0x3F50000000000000
  %call3 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %s, i64 noundef %size, ptr noundef nonnull @.str.322, double noundef %div) #38
  br label %if.end38

if.else4:                                         ; preds = %if.else
  %cmp5 = icmp ult i64 %n, 1073741824
  br i1 %cmp5, label %if.then7, label %if.else11

if.then7:                                         ; preds = %if.else4
  %conv8 = uitofp i64 %n to double
  %div9 = fmul double %conv8, 0x3EB0000000000000
  %call10 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %s, i64 noundef %size, ptr noundef nonnull @.str.323, double noundef %div9) #38
  br label %if.end38

if.else11:                                        ; preds = %if.else4
  %cmp12 = icmp ult i64 %n, 1099511627776
  br i1 %cmp12, label %if.then14, label %if.else18

if.then14:                                        ; preds = %if.else11
  %conv15 = uitofp i64 %n to double
  %div16 = fmul double %conv15, 0x3E10000000000000
  %call17 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %s, i64 noundef %size, ptr noundef nonnull @.str.324, double noundef %div16) #38
  br label %if.end38

if.else18:                                        ; preds = %if.else11
  %cmp19 = icmp ult i64 %n, 1125899906842624
  br i1 %cmp19, label %if.then21, label %if.else25

if.then21:                                        ; preds = %if.else18
  %conv22 = uitofp i64 %n to double
  %div23 = fmul double %conv22, 0x3D70000000000000
  %call24 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %s, i64 noundef %size, ptr noundef nonnull @.str.325, double noundef %div23) #38
  br label %if.end38

if.else25:                                        ; preds = %if.else18
  %cmp26 = icmp ult i64 %n, 1152921504606846976
  br i1 %cmp26, label %if.then28, label %if.else32

if.then28:                                        ; preds = %if.else25
  %conv29 = uitofp i64 %n to double
  %div30 = fmul double %conv29, 0x3CD0000000000000
  %call31 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %s, i64 noundef %size, ptr noundef nonnull @.str.326, double noundef %div30) #38
  br label %if.end38

if.else32:                                        ; preds = %if.else25
  %call33 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %s, i64 noundef %size, ptr noundef nonnull @.str.321, i64 noundef %n) #38
  br label %if.end38

if.end38:                                         ; preds = %if.then2, %if.then14, %if.then28, %if.else32, %if.then21, %if.then7, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @fillPercentileDistributionLatencies(ptr noundef %info, ptr noundef %histogram_name, ptr noundef %histogram) local_unnamed_addr #0 {
entry:
  %fbuf = alloca [128 x i8], align 16
  %call = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %info, ptr noundef nonnull @.str.327, ptr noundef %histogram_name) #38
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 183), align 8
  %cmp9 = icmp sgt i32 %0, 0
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %info.addr.011 = phi ptr [ %info.addr.1, %for.inc ], [ %call, %entry ]
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 182), align 8
  %arrayidx = getelementptr inbounds double, ptr %1, i64 %indvars.iv
  %2 = load double, ptr %arrayidx, align 8
  %call1 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %fbuf, i64 noundef 128, ptr noundef nonnull @.str.328, double noundef %2) #38
  %conv = sext i32 %call1 to i64
  %call3 = call i32 @trimDoubleString(ptr noundef nonnull %fbuf, i64 noundef %conv) #38
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 182), align 8
  %arrayidx6 = getelementptr inbounds double, ptr %3, i64 %indvars.iv
  %4 = load double, ptr %arrayidx6, align 8
  %call7 = call i64 @hdr_value_at_percentile(ptr noundef %histogram, double noundef %4) #38
  %conv8 = sitofp i64 %call7 to double
  %div = fdiv double %conv8, 1.000000e+03
  %call9 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.addr.011, ptr noundef nonnull @.str.329, ptr noundef nonnull %fbuf, double noundef %div) #38
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 183), align 8
  %sub = add nsw i32 %5, -1
  %6 = zext i32 %sub to i64
  %cmp10.not = icmp eq i64 %indvars.iv, %6
  br i1 %cmp10.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %call12 = call ptr @sdscatlen(ptr noundef %call9, ptr noundef nonnull @.str.330, i64 noundef 1) #38
  %.pre = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 183), align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %7 = phi i32 [ %.pre, %if.then ], [ %5, %for.body ]
  %info.addr.1 = phi ptr [ %call12, %if.then ], [ %call9, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %8 = sext i32 %7 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %8
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !67

for.end:                                          ; preds = %for.inc, %entry
  %info.addr.0.lcssa = phi ptr [ %call, %entry ], [ %info.addr.1, %for.inc ]
  %call13 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.addr.0.lcssa, ptr noundef nonnull @.str.170) #38
  ret ptr %call13
}

declare i32 @trimDoubleString(ptr noundef, i64 noundef) local_unnamed_addr #4

declare i64 @hdr_value_at_percentile(ptr noundef, double noundef) local_unnamed_addr #4

declare ptr @sdscatlen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local ptr @getSafeInfoString(ptr noundef %s, i64 noundef %len, ptr nocapture noundef writeonly %tmp) local_unnamed_addr #0 {
entry:
  store ptr null, ptr %tmp, align 8
  %call = tail call ptr @mempbrk(ptr noundef %s, i64 noundef %len, ptr noundef nonnull @unsafe_info_chars, i64 noundef 4) #38
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %add = add i64 %len, 1
  %call1 = tail call noalias ptr @zmalloc(i64 noundef %add) #42
  store ptr %call1, ptr %tmp, align 8
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call1, ptr align 1 %s, i64 %len, i1 false)
  %arrayidx = getelementptr inbounds i8, ptr %call1, i64 %len
  store i8 0, ptr %arrayidx, align 1
  %call2 = tail call ptr @memmapchars(ptr noundef %call1, i64 noundef %len, ptr noundef nonnull @unsafe_info_chars, ptr noundef nonnull @unsafe_info_chars_substs, i64 noundef 4) #38
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi ptr [ %call2, %if.end ], [ %s, %entry ]
  ret ptr %retval.0
}

declare ptr @mempbrk(ptr noundef, i64 noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

declare ptr @memmapchars(ptr noundef, i64 noundef, ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local ptr @genRedisInfoStringCommandStats(ptr noundef %info, ptr noundef %commands) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %commands) #38
  %call121 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not22 = icmp eq ptr %call121, null
  br i1 %cmp.not22, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end27
  %call124 = phi ptr [ %call1, %if.end27 ], [ %call121, %entry ]
  %info.addr.023 = phi ptr [ %info.addr.2, %if.end27 ], [ %info, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call124) #38
  %calls = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 23
  %0 = load i64, ptr %calls, align 8
  %tobool.not = icmp eq i64 %0, 0
  br i1 %tobool.not, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %while.body
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 25
  %1 = load i64, ptr %failed_calls, align 8
  %tobool3.not = icmp eq i64 %1, 0
  br i1 %tobool3.not, label %lor.lhs.false4, label %if.then

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 24
  %2 = load i64, ptr %rejected_calls, align 8
  %tobool5.not = icmp eq i64 %2, 0
  br i1 %tobool5.not, label %if.end22, label %if.then

if.then:                                          ; preds = %lor.lhs.false4, %lor.lhs.false, %while.body
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 27
  %3 = load ptr, ptr %fullname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %3, i64 -1
  %4 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %4 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then
  %add.ptr.i = getelementptr inbounds i8, ptr %3, i64 -3
  %5 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %5 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then
  %add.ptr6.i = getelementptr inbounds i8, ptr %3, i64 -5
  %6 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %6 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then
  %add.ptr10.i = getelementptr inbounds i8, ptr %3, i64 -9
  %7 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %7 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then
  %add.ptr14.i = getelementptr inbounds i8, ptr %3, i64 -17
  %8 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %8, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then ]
  %call.i = tail call ptr @mempbrk(ptr noundef nonnull %3, i64 noundef %retval.0.i, ptr noundef nonnull @unsafe_info_chars, i64 noundef 4) #38
  %cmp.i = icmp eq ptr %call.i, null
  br i1 %cmp.i, label %getSafeInfoString.exit, label %if.end.i

if.end.i:                                         ; preds = %sdslen.exit
  %add.i = add i64 %retval.0.i, 1
  %call1.i = tail call noalias ptr @zmalloc(i64 noundef %add.i) #42
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call1.i, ptr nonnull align 1 %3, i64 %retval.0.i, i1 false)
  %arrayidx.i19 = getelementptr inbounds i8, ptr %call1.i, i64 %retval.0.i
  store i8 0, ptr %arrayidx.i19, align 1
  %call2.i = tail call ptr @memmapchars(ptr noundef %call1.i, i64 noundef %retval.0.i, ptr noundef nonnull @unsafe_info_chars, ptr noundef nonnull @unsafe_info_chars_substs, i64 noundef 4) #38
  br label %getSafeInfoString.exit

getSafeInfoString.exit:                           ; preds = %sdslen.exit, %if.end.i
  %tmpsafe.0 = phi ptr [ null, %sdslen.exit ], [ %call1.i, %if.end.i ]
  %retval.0.i20 = phi ptr [ %3, %sdslen.exit ], [ %call2.i, %if.end.i ]
  %9 = load i64, ptr %calls, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 22
  %10 = load i64, ptr %microseconds, align 8
  %cmp11 = icmp eq i64 %9, 0
  %conv = sitofp i64 %10 to float
  %conv14 = sitofp i64 %9 to float
  %div = fdiv float %conv, %conv14
  %11 = fpext float %div to double
  %conv15 = select i1 %cmp11, double 0.000000e+00, double %11
  %rejected_calls16 = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 24
  %12 = load i64, ptr %rejected_calls16, align 8
  %failed_calls17 = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 25
  %13 = load i64, ptr %failed_calls17, align 8
  %call18 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.addr.023, ptr noundef nonnull @.str.334, ptr noundef %retval.0.i20, i64 noundef %9, i64 noundef %10, double noundef %conv15, i64 noundef %12, i64 noundef %13) #38
  %cmp19.not = icmp eq ptr %tmpsafe.0, null
  br i1 %cmp19.not, label %if.end22, label %if.then21

if.then21:                                        ; preds = %getSafeInfoString.exit
  tail call void @zfree(ptr noundef nonnull %tmpsafe.0) #38
  br label %if.end22

if.end22:                                         ; preds = %getSafeInfoString.exit, %if.then21, %lor.lhs.false4
  %info.addr.1 = phi ptr [ %call18, %if.then21 ], [ %call18, %getSafeInfoString.exit ], [ %info.addr.023, %lor.lhs.false4 ]
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 30
  %14 = load ptr, ptr %subcommands_dict, align 8
  %tobool23.not = icmp eq ptr %14, null
  br i1 %tobool23.not, label %if.end27, label %if.then24

if.then24:                                        ; preds = %if.end22
  %call26 = tail call ptr @genRedisInfoStringCommandStats(ptr noundef %info.addr.1, ptr noundef nonnull %14)
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %if.end22
  %info.addr.2 = phi ptr [ %call26, %if.then24 ], [ %info.addr.1, %if.end22 ]
  %call1 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !68

while.end:                                        ; preds = %if.end27, %entry
  %info.addr.0.lcssa = phi ptr [ %info, %entry ], [ %info.addr.2, %if.end27 ]
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  ret ptr %info.addr.0.lcssa
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genRedisInfoStringACLStats(ptr noundef %info) local_unnamed_addr #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399), align 8
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399, i32 1), align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399, i32 2), align 8
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399, i32 3), align 8
  %call = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info, ptr noundef nonnull @.str.335, i64 noundef %0, i64 noundef %1, i64 noundef %2, i64 noundef %3) #38
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genRedisInfoStringLatencyStats(ptr noundef %info, ptr noundef %commands) local_unnamed_addr #0 {
entry:
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %commands) #38
  %call116 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not17 = icmp eq ptr %call116, null
  br i1 %cmp.not17, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end15
  %call119 = phi ptr [ %call1, %if.end15 ], [ %call116, %entry ]
  %info.addr.018 = phi ptr [ %info.addr.2, %if.end15 ], [ %info, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call119) #38
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 28
  %0 = load ptr, ptr %latency_histogram, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end10, label %if.then

if.then:                                          ; preds = %while.body
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 27
  %1 = load ptr, ptr %fullname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then ]
  %call.i = tail call ptr @mempbrk(ptr noundef nonnull %1, i64 noundef %retval.0.i, ptr noundef nonnull @unsafe_info_chars, i64 noundef 4) #38
  %cmp.i = icmp eq ptr %call.i, null
  br i1 %cmp.i, label %getSafeInfoString.exit.thread, label %if.then9

getSafeInfoString.exit.thread:                    ; preds = %sdslen.exit
  %7 = load ptr, ptr %latency_histogram, align 8
  %call714 = tail call ptr @fillPercentileDistributionLatencies(ptr noundef %info.addr.018, ptr noundef nonnull %1, ptr noundef %7)
  br label %if.end10

if.then9:                                         ; preds = %sdslen.exit
  %add.i = add i64 %retval.0.i, 1
  %call1.i = tail call noalias ptr @zmalloc(i64 noundef %add.i) #42
  tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call1.i, ptr nonnull align 1 %1, i64 %retval.0.i, i1 false)
  %arrayidx.i10 = getelementptr inbounds i8, ptr %call1.i, i64 %retval.0.i
  store i8 0, ptr %arrayidx.i10, align 1
  %call2.i = tail call ptr @memmapchars(ptr noundef %call1.i, i64 noundef %retval.0.i, ptr noundef nonnull @unsafe_info_chars, ptr noundef nonnull @unsafe_info_chars_substs, i64 noundef 4) #38
  %8 = load ptr, ptr %latency_histogram, align 8
  %call7 = tail call ptr @fillPercentileDistributionLatencies(ptr noundef %info.addr.018, ptr noundef %call2.i, ptr noundef %8)
  tail call void @zfree(ptr noundef nonnull %call1.i) #38
  br label %if.end10

if.end10:                                         ; preds = %getSafeInfoString.exit.thread, %if.then9, %while.body
  %info.addr.1 = phi ptr [ %call7, %if.then9 ], [ %info.addr.018, %while.body ], [ %call714, %getSafeInfoString.exit.thread ]
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %call2, i64 0, i32 30
  %9 = load ptr, ptr %subcommands_dict, align 8
  %tobool11.not = icmp eq ptr %9, null
  br i1 %tobool11.not, label %if.end15, label %if.then12

if.then12:                                        ; preds = %if.end10
  %call14 = tail call ptr @genRedisInfoStringLatencyStats(ptr noundef %info.addr.1, ptr noundef nonnull %9)
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  %info.addr.2 = phi ptr [ %call14, %if.then12 ], [ %info.addr.1, %if.end10 ]
  %call1 = tail call ptr @dictNext(ptr noundef %call) #38
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !69

while.end:                                        ; preds = %if.end15, %entry
  %info.addr.0.lcssa = phi ptr [ %info, %entry ], [ %info.addr.2, %if.end15 ]
  tail call void @dictReleaseIterator(ptr noundef %call) #38
  ret ptr %info.addr.0.lcssa
}

; Function Attrs: nounwind uwtable
define dso_local void @addInfoSectionsToDict(ptr noundef %section_dict, ptr nocapture noundef readonly %sections) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr %sections, align 8
  %tobool.not4 = icmp eq ptr %0, null
  br i1 %tobool.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %1 = phi ptr [ %2, %if.end ], [ %0, %entry ]
  %sections.addr.05 = phi ptr [ %incdec.ptr, %if.end ], [ %sections, %entry ]
  %call = tail call ptr @sdsnew(ptr noundef nonnull %1) #38
  %call1 = tail call i32 @dictAdd(ptr noundef %section_dict, ptr noundef %call, ptr noundef null) #38
  %cmp = icmp eq i32 %call1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  tail call void @sdsfree(ptr noundef %call) #38
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %incdec.ptr = getelementptr inbounds ptr, ptr %sections.addr.05, i64 1
  %2 = load ptr, ptr %incdec.ptr, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !70

while.end:                                        ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @releaseInfoSectionDict(ptr noundef %sec) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @cached_default_info_sections, align 8
  %cmp.not = icmp eq ptr %0, %sec
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @dictRelease(ptr noundef %sec) #38
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @dictRelease(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local ptr @genInfoSectionDict(ptr nocapture noundef readonly %argv, i32 noundef %argc, ptr noundef readonly %defaults, ptr noundef writeonly %out_all, ptr noundef writeonly %out_everything) local_unnamed_addr #0 {
entry:
  %tobool.not = icmp eq ptr %defaults, null
  %spec.select = select i1 %tobool.not, ptr @__const.genInfoSectionDict.default_sections, ptr %defaults
  %cmp = icmp eq i32 %argc, 0
  br i1 %cmp, label %if.then1, label %if.end6

if.then1:                                         ; preds = %entry
  %0 = load ptr, ptr @cached_default_info_sections, align 8
  %tobool2.not = icmp eq ptr %0, null
  br i1 %tobool2.not, label %if.end4, label %return

if.end4:                                          ; preds = %if.then1
  %call = tail call ptr @dictCreate(ptr noundef nonnull @stringSetDictType) #38
  store ptr %call, ptr @cached_default_info_sections, align 8
  %call5 = tail call i32 @dictExpand(ptr noundef %call, i64 noundef 16) #38
  %1 = load ptr, ptr @cached_default_info_sections, align 8
  %2 = load ptr, ptr %spec.select, align 8
  %tobool.not4.i = icmp eq ptr %2, null
  br i1 %tobool.not4.i, label %return, label %while.body.i

while.body.i:                                     ; preds = %if.end4, %if.end.i
  %3 = phi ptr [ %4, %if.end.i ], [ %2, %if.end4 ]
  %sections.addr.05.i = phi ptr [ %incdec.ptr.i, %if.end.i ], [ %spec.select, %if.end4 ]
  %call.i = tail call ptr @sdsnew(ptr noundef nonnull %3) #38
  %call1.i = tail call i32 @dictAdd(ptr noundef %1, ptr noundef %call.i, ptr noundef null) #38
  %cmp.i = icmp eq i32 %call1.i, 1
  br i1 %cmp.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %while.body.i
  tail call void @sdsfree(ptr noundef %call.i) #38
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %while.body.i
  %incdec.ptr.i = getelementptr inbounds ptr, ptr %sections.addr.05.i, i64 1
  %4 = load ptr, ptr %incdec.ptr.i, align 8
  %tobool.not.i = icmp eq ptr %4, null
  br i1 %tobool.not.i, label %addInfoSectionsToDict.exit.loopexit, label %while.body.i, !llvm.loop !70

addInfoSectionsToDict.exit.loopexit:              ; preds = %if.end.i
  %.pre = load ptr, ptr @cached_default_info_sections, align 8
  br label %return

if.end6:                                          ; preds = %entry
  %call7 = tail call ptr @dictCreate(ptr noundef nonnull @stringSetDictType) #38
  %cond = tail call i32 @llvm.smin.i32(i32 %argc, i32 16)
  %conv = sext i32 %cond to i64
  %call9 = tail call i32 @dictExpand(ptr noundef %call7, i64 noundef %conv) #38
  %cmp1033 = icmp sgt i32 %argc, 0
  br i1 %cmp1033, label %for.body.lr.ph, label %return

for.body.lr.ph:                                   ; preds = %if.end6
  %tobool31.not = icmp eq ptr %out_everything, null
  %tobool34.not = icmp eq ptr %out_all, null
  %wide.trip.count = zext nneg i32 %argc to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds ptr, ptr %argv, i64 %indvars.iv
  %5 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %5, i64 0, i32 2
  %6 = load ptr, ptr %ptr, align 8
  %call12 = tail call i32 @strcasecmp(ptr noundef %6, ptr noundef nonnull @.str.108) #39
  %tobool13.not = icmp eq i32 %call12, 0
  br i1 %tobool13.not, label %if.then14, label %if.else

if.then14:                                        ; preds = %for.body
  %7 = load ptr, ptr %spec.select, align 8
  %tobool.not4.i22 = icmp eq ptr %7, null
  br i1 %tobool.not4.i22, label %for.inc, label %while.body.i23

while.body.i23:                                   ; preds = %if.then14, %if.end.i28
  %8 = phi ptr [ %9, %if.end.i28 ], [ %7, %if.then14 ]
  %sections.addr.05.i24 = phi ptr [ %incdec.ptr.i29, %if.end.i28 ], [ %spec.select, %if.then14 ]
  %call.i25 = tail call ptr @sdsnew(ptr noundef nonnull %8) #38
  %call1.i26 = tail call i32 @dictAdd(ptr noundef %call7, ptr noundef %call.i25, ptr noundef null) #38
  %cmp.i27 = icmp eq i32 %call1.i26, 1
  br i1 %cmp.i27, label %if.then.i31, label %if.end.i28

if.then.i31:                                      ; preds = %while.body.i23
  tail call void @sdsfree(ptr noundef %call.i25) #38
  br label %if.end.i28

if.end.i28:                                       ; preds = %if.then.i31, %while.body.i23
  %incdec.ptr.i29 = getelementptr inbounds ptr, ptr %sections.addr.05.i24, i64 1
  %9 = load ptr, ptr %incdec.ptr.i29, align 8
  %tobool.not.i30 = icmp eq ptr %9, null
  br i1 %tobool.not.i30, label %for.inc, label %while.body.i23, !llvm.loop !70

if.else:                                          ; preds = %for.body
  %call18 = tail call i32 @strcasecmp(ptr noundef %6, ptr noundef nonnull @.str.347) #39
  %tobool19.not = icmp eq i32 %call18, 0
  br i1 %tobool19.not, label %if.then20, label %if.else24

if.then20:                                        ; preds = %if.else
  br i1 %tobool34.not, label %for.inc, label %if.then22

if.then22:                                        ; preds = %if.then20
  store i32 1, ptr %out_all, align 4
  br label %for.inc

if.else24:                                        ; preds = %if.else
  %call28 = tail call i32 @strcasecmp(ptr noundef %6, ptr noundef nonnull @.str.348) #39
  %tobool29.not = icmp eq i32 %call28, 0
  br i1 %tobool29.not, label %if.then30, label %if.else37

if.then30:                                        ; preds = %if.else24
  br i1 %tobool31.not, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.then30
  store i32 1, ptr %out_everything, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.then30
  br i1 %tobool34.not, label %for.inc, label %if.then35

if.then35:                                        ; preds = %if.end33
  store i32 1, ptr %out_all, align 4
  br label %for.inc

if.else37:                                        ; preds = %if.else24
  %call41 = tail call ptr @sdsnew(ptr noundef %6) #38
  %call42 = tail call i32 @dictAdd(ptr noundef %call7, ptr noundef %call41, ptr noundef null) #38
  %cmp43.not = icmp eq i32 %call42, 0
  br i1 %cmp43.not, label %for.inc, label %if.then45

if.then45:                                        ; preds = %if.else37
  tail call void @sdsfree(ptr noundef %call41) #38
  br label %for.inc

for.inc:                                          ; preds = %if.end.i28, %if.then14, %if.then35, %if.end33, %if.then45, %if.else37, %if.then20, %if.then22
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %return, label %for.body, !llvm.loop !71

return:                                           ; preds = %for.inc, %if.end4, %addInfoSectionsToDict.exit.loopexit, %if.end6, %if.then1
  %retval.0 = phi ptr [ %0, %if.then1 ], [ %call7, %if.end6 ], [ %.pre, %addInfoSectionsToDict.exit.loopexit ], [ %1, %if.end4 ], [ %call7, %for.inc ]
  ret ptr %retval.0
}

declare i32 @dictExpand(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local ptr @genRedisInfoString(ptr noundef %section_dict, i32 noundef %all_sections, i32 noundef %everything) local_unnamed_addr #0 {
entry:
  %blocking_keys = alloca i64, align 8
  %blocking_keys_on_nokey = alloca i64, align 8
  %hmem = alloca [64 x i8], align 16
  %peak_hmem = alloca [64 x i8], align 16
  %total_system_hmem = alloca [64 x i8], align 16
  %used_memory_lua_hmem = alloca [64 x i8], align 16
  %used_memory_vm_total_hmem = alloca [64 x i8], align 16
  %used_memory_scripts_hmem = alloca [64 x i8], align 16
  %used_memory_rss_hmem = alloca [64 x i8], align 16
  %maxmemory_hmem = alloca [64 x i8], align 16
  %li = alloca %struct.listIter, align 8
  %ip = alloca [46 x i8], align 16
  %port = alloca i32, align 4
  %self_ru = alloca %struct.rusage, align 8
  %c_ru = alloca %struct.rusage, align 8
  %m_ru = alloca %struct.rusage, align 8
  %ri = alloca %struct.raxIterator, align 8
  %call = tail call ptr @sdsempty() #38
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 88), align 8
  %sub = sub nsw i64 %atomic-load, %0
  %tobool.not = icmp eq i32 %everything, 0
  %1 = or i32 %everything, %all_sections
  %tobool1.not = icmp eq i32 %1, 0
  br i1 %tobool1.not, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %entry
  %call2 = tail call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.336) #38
  %cmp.not = icmp eq ptr %call2, null
  br i1 %cmp.not, label %lor.lhs.false62, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool4.not = icmp eq i32 %2, 0
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool6.not = icmp eq i32 %3, 0
  %.str.350..str.349 = select i1 %tobool6.not, ptr @.str.350, ptr @.str.349
  %mode.0 = select i1 %tobool4.not, ptr %.str.350..str.349, ptr @.str.345
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 174), align 4
  %tobool11.not = icmp eq i32 %4, 0
  br i1 %tobool11.not, label %if.end26, label %if.then12

if.then12:                                        ; preds = %if.then3
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  %switch.selectcmp = icmp eq i32 %5, 2
  %switch.select = select i1 %switch.selectcmp, ptr @.str.352, ptr @.str.277
  %switch.selectcmp175 = icmp eq i32 %5, 3
  %switch.select176 = select i1 %switch.selectcmp175, ptr @.str.351, ptr %switch.select
  br label %if.end26

if.end26:                                         ; preds = %if.then12, %if.then3
  %supervised.0 = phi ptr [ @.str.353, %if.then3 ], [ %switch.select176, %if.then12 ]
  %.b = load i1, ptr @genRedisInfoString.call_uname, align 4
  br i1 %.b, label %if.end30, label %if.then28

if.then28:                                        ; preds = %if.end26
  %call29 = tail call i32 @uname(ptr noundef nonnull @genRedisInfoString.name) #38
  store i1 true, ptr @genRedisInfoString.call_uname, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end26
  %call31 = tail call ptr @redisGitSHA1() #38
  %call32 = tail call ptr @redisGitDirty() #38
  %call33 = tail call i64 @strtol(ptr nocapture noundef %call32, ptr noundef null, i32 noundef 10) #38
  %cmp34 = icmp sgt i64 %call33, 0
  %conv = zext i1 %cmp34 to i32
  %call35 = tail call ptr @redisBuildIdString() #38
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 24), align 8
  %call36 = tail call ptr @monotonicInfoString() #38
  %call37 = tail call ptr @aeGetApiName() #38
  %call38 = tail call i32 @getpid() #38
  %conv39 = sext i32 %call38 to i64
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %tobool40.not = icmp eq i32 %7, 0
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %cond = select i1 %tobool40.not, i32 %8, i32 %7
  %9 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 353), align 8
  %div = sdiv i64 %sub, 86400
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 8), align 4
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 6), align 4
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 16), align 8
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 3), align 8
  %tobool41.not = icmp eq ptr %13, null
  %cond45 = select i1 %tobool41.not, ptr @.str.219, ptr %13
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 2), align 8
  %tobool46.not = icmp eq ptr %14, null
  %cond50 = select i1 %tobool46.not, ptr @.str.219, ptr %14
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 76), align 4
  %call51 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call, ptr noundef nonnull @.str.354, ptr noundef nonnull @.str.355, ptr noundef %call31, i32 noundef %conv, ptr noundef %call35, ptr noundef nonnull %mode.0, ptr noundef nonnull @genRedisInfoString.name, ptr noundef nonnull getelementptr inbounds (%struct.utsname, ptr @genRedisInfoString.name, i64 0, i32 2), ptr noundef nonnull getelementptr inbounds (%struct.utsname, ptr @genRedisInfoString.name, i64 0, i32 4), i32 noundef %6, ptr noundef %call36, ptr noundef %call37, ptr noundef nonnull @.str.356, ptr noundef nonnull @.str.357, i64 noundef %conv39, ptr noundef nonnull %supervised.0, ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 26), i32 noundef %cond, i64 noundef %9, i64 noundef %sub, i64 noundef %div, i32 noundef %10, i32 noundef %11, i32 noundef %12, ptr noundef nonnull %cond45, ptr noundef nonnull %cond50, i32 noundef %15) #38
  %16 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 18), align 8
  %cmp.i.not = icmp eq i64 %16, 0
  br i1 %cmp.i.not, label %if.end60, label %if.then54

if.then54:                                        ; preds = %if.end30
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 354), align 8
  %sub56 = sub nsw i64 %16, %17
  %call57 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call51, ptr noundef nonnull @.str.358, i64 noundef %sub56) #38
  br label %if.end60

if.end60:                                         ; preds = %if.end30, %if.then54
  %info.1 = phi ptr [ %call57, %if.then54 ], [ %call51, %if.end30 ]
  %call59 = tail call ptr @getListensInfoString(ptr noundef %info.1) #38
  br i1 %tobool1.not, label %lor.lhs.false62, label %if.then66

lor.lhs.false62:                                  ; preds = %lor.lhs.false, %if.end60
  %info.2257 = phi ptr [ %call59, %if.end60 ], [ %call, %lor.lhs.false ]
  %sections.0255 = phi i32 [ 1, %if.end60 ], [ 0, %lor.lhs.false ]
  %tobool68.not253 = phi i1 [ false, %if.end60 ], [ true, %lor.lhs.false ]
  %call63 = tail call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.337) #38
  %cmp64.not = icmp eq ptr %call63, null
  br i1 %cmp64.not, label %lor.lhs.false79, label %if.then66

if.then66:                                        ; preds = %lor.lhs.false62, %if.end60
  %info.2256 = phi ptr [ %info.2257, %lor.lhs.false62 ], [ %call59, %if.end60 ]
  %sections.0254 = phi i32 [ %sections.0255, %lor.lhs.false62 ], [ 1, %if.end60 ]
  %tobool68.not252 = phi i1 [ %tobool68.not253, %lor.lhs.false62 ], [ false, %if.end60 ]
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %if.then66
  %indvars.iv.i = phi i64 [ 0, %if.then66 ], [ %indvars.iv.next.i, %for.body.i ]
  %o.010.i = phi i64 [ 0, %if.then66 ], [ %o.1.i, %for.body.i ]
  %i.09.i = phi i64 [ 0, %if.then66 ], [ %spec.select.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %indvars.iv.i
  %18 = load i64, ptr %arrayidx.i, align 8
  %spec.select.i = tail call i64 @llvm.umax.i64(i64 %18, i64 %i.09.i)
  %arrayidx5.i = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %indvars.iv.i
  %19 = load i64, ptr %arrayidx5.i, align 8
  %o.1.i = tail call i64 @llvm.umax.i64(i64 %19, i64 %o.010.i)
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 8
  br i1 %exitcond.not.i, label %getExpansiveClientsInfo.exit, label %for.body.i, !llvm.loop !11

getExpansiveClientsInfo.exit:                     ; preds = %for.body.i
  call void @totalNumberOfBlockingKeys(ptr noundef nonnull %blocking_keys, ptr noundef nonnull %blocking_keys_on_nokey) #38
  %inc67 = add nuw nsw i32 %sections.0254, 1
  br i1 %tobool68.not252, label %if.end77, label %if.then69

if.then69:                                        ; preds = %getExpansiveClientsInfo.exit
  %call70 = call ptr @sdscat(ptr noundef %info.2256, ptr noundef nonnull @.str.170) #38
  br label %if.end77

if.end77:                                         ; preds = %getExpansiveClientsInfo.exit, %if.then69
  %info.3 = phi ptr [ %call70, %if.then69 ], [ %info.2256, %getExpansiveClientsInfo.exit ]
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  %len = getelementptr inbounds %struct.list, ptr %20, i64 0, i32 5
  %21 = load i64, ptr %len, align 8
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len72 = getelementptr inbounds %struct.list, ptr %22, i64 0, i32 5
  %23 = load i64, ptr %len72, align 8
  %sub73 = sub i64 %21, %23
  %call74 = call i64 @getClusterConnectionsCount() #38
  %24 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 313), align 4
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 325), align 4
  %26 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 329), align 8
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 361), align 8
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 64), align 8
  %call75 = call i64 @raxSize(ptr noundef %28) #38
  %29 = load i64, ptr %blocking_keys, align 8
  %30 = load i64, ptr %blocking_keys_on_nokey, align 8
  %call76 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.3, ptr noundef nonnull @.str.359, i64 noundef %sub73, i64 noundef %call74, i32 noundef %24, i64 noundef %spec.select.i, i64 noundef %o.1.i, i32 noundef %25, i32 noundef %26, i32 noundef %27, i64 noundef %call75, i64 noundef %29, i64 noundef %30) #38
  br i1 %tobool1.not, label %lor.lhs.false79, label %if.then83

lor.lhs.false79:                                  ; preds = %lor.lhs.false62, %if.end77
  %info.4263 = phi ptr [ %call76, %if.end77 ], [ %info.2257, %lor.lhs.false62 ]
  %sections.1261 = phi i32 [ %inc67, %if.end77 ], [ %sections.0255, %lor.lhs.false62 ]
  %call80 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.338) #38
  %cmp81.not = icmp eq ptr %call80, null
  br i1 %cmp81.not, label %lor.lhs.false139, label %if.then83

if.then83:                                        ; preds = %lor.lhs.false79, %if.end77
  %info.4262 = phi ptr [ %info.4263, %lor.lhs.false79 ], [ %call76, %if.end77 ]
  %sections.1260 = phi i32 [ %sections.1261, %lor.lhs.false79 ], [ %inc67, %if.end77 ]
  %call84 = call i64 @zmalloc_used_memory() #38
  %31 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 401), align 8
  %call85 = call ptr @evictPolicyToString() #38
  %call86 = call i64 @evalMemory() #38
  %call87 = call i64 @functionsMemory() #38
  %call88 = call ptr @getMemoryOverheadData() #38
  %32 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  %cmp89 = icmp ugt i64 %call84, %32
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %if.then83
  store i64 %call84, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  br label %if.end92

if.end92:                                         ; preds = %if.then91, %if.then83
  call void @bytesToHuman(ptr noundef nonnull %hmem, i64 noundef 64, i64 noundef %call84)
  %33 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  call void @bytesToHuman(ptr noundef nonnull %peak_hmem, i64 noundef 64, i64 noundef %33)
  call void @bytesToHuman(ptr noundef nonnull %total_system_hmem, i64 noundef 64, i64 noundef %31)
  call void @bytesToHuman(ptr noundef nonnull %used_memory_lua_hmem, i64 noundef 64, i64 noundef %call86)
  %add = add nsw i64 %call87, %call86
  call void @bytesToHuman(ptr noundef nonnull %used_memory_vm_total_hmem, i64 noundef 64, i64 noundef %add)
  %lua_caches = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 8
  %34 = load i64, ptr %lua_caches, align 8
  %functions_caches = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 9
  %35 = load i64, ptr %functions_caches, align 8
  %add98 = add i64 %35, %34
  call void @bytesToHuman(ptr noundef nonnull %used_memory_scripts_hmem, i64 noundef 64, i64 noundef %add98)
  %36 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 1), align 8
  call void @bytesToHuman(ptr noundef nonnull %used_memory_rss_hmem, i64 noundef 64, i64 noundef %36)
  %37 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 314), align 8
  call void @bytesToHuman(ptr noundef nonnull %maxmemory_hmem, i64 noundef 64, i64 noundef %37)
  %inc101 = add nuw nsw i32 %sections.1260, 1
  %tobool102.not = icmp eq i32 %sections.1260, 0
  br i1 %tobool102.not, label %if.end137, label %if.then103

if.then103:                                       ; preds = %if.end92
  %call104 = call ptr @sdscat(ptr noundef %info.4262, ptr noundef nonnull @.str.170) #38
  br label %if.end137

if.end137:                                        ; preds = %if.end92, %if.then103
  %info.5 = phi ptr [ %call104, %if.then103 ], [ %info.4262, %if.end92 ]
  %38 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 1), align 8
  %39 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 108), align 8
  %peak_perc = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 15
  %40 = load float, ptr %peak_perc, align 4
  %conv109 = fpext float %40 to double
  %overhead_total = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 10
  %41 = load i64, ptr %overhead_total, align 8
  %startup_allocated = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 2
  %42 = load i64, ptr %startup_allocated, align 8
  %dataset = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 11
  %43 = load i64, ptr %dataset, align 8
  %dataset_perc = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 14
  %44 = load float, ptr %dataset_perc, align 8
  %conv110 = fpext float %44 to double
  %45 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 2), align 8
  %46 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 3), align 8
  %47 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 123, i32 4), align 8
  %48 = load i64, ptr %lua_caches, align 8
  %call114 = call ptr @evalScriptsDict() #38
  %ht_used = getelementptr inbounds %struct.dict, ptr %call114, i64 0, i32 2
  %49 = load i64, ptr %ht_used, align 8
  %call115 = call ptr @evalScriptsDict() #38
  %arrayidx117 = getelementptr inbounds %struct.dict, ptr %call115, i64 0, i32 2, i64 1
  %50 = load i64, ptr %arrayidx117, align 8
  %add118 = add i64 %50, %49
  %call119 = call i64 @functionsNum() #38
  %call120 = call i64 @functionsLibNum() #38
  %51 = load i64, ptr %functions_caches, align 8
  %52 = load i64, ptr %lua_caches, align 8
  %add126 = add nsw i64 %52, %51
  %53 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 314), align 8
  %allocator_frag = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 18
  %54 = load float, ptr %allocator_frag, align 8
  %conv129 = fpext float %54 to double
  %allocator_frag_bytes = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 19
  %55 = load i64, ptr %allocator_frag_bytes, align 8
  %allocator_rss = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 20
  %56 = load float, ptr %allocator_rss, align 8
  %conv130 = fpext float %56 to double
  %allocator_rss_bytes = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 21
  %57 = load i64, ptr %allocator_rss_bytes, align 8
  %rss_extra = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 22
  %58 = load float, ptr %rss_extra, align 8
  %conv131 = fpext float %58 to double
  %rss_extra_bytes = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 23
  %59 = load i64, ptr %rss_extra_bytes, align 8
  %total_frag = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 16
  %60 = load float, ptr %total_frag, align 8
  %conv132 = fpext float %60 to double
  %total_frag_bytes = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 17
  %61 = load i64, ptr %total_frag_bytes, align 8
  %call133 = call i64 @freeMemoryGetNotCountedMemory() #38
  %repl_backlog = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 3
  %62 = load i64, ptr %repl_backlog, align 8
  %63 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 279), align 8
  %clients_slaves = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 4
  %64 = load i64, ptr %clients_slaves, align 8
  %clients_normal = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 5
  %65 = load i64, ptr %clients_normal, align 8
  %cluster_links = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 6
  %66 = load i64, ptr %cluster_links, align 8
  %aof_buffer = getelementptr inbounds %struct.redisMemOverhead, ptr %call88, i64 0, i32 7
  %67 = load i64, ptr %aof_buffer, align 8
  %68 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 22), align 4
  %call134 = call i64 @lazyfreeGetPendingObjectsCount() #38
  %call135 = call i64 @lazyfreeGetFreedObjectsCount() #38
  %call136 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.5, ptr noundef nonnull @.str.360, i64 noundef %call84, ptr noundef nonnull %hmem, i64 noundef %38, ptr noundef nonnull %used_memory_rss_hmem, i64 noundef %39, ptr noundef nonnull %peak_hmem, double noundef %conv109, i64 noundef %41, i64 noundef %42, i64 noundef %43, double noundef %conv110, i64 noundef %45, i64 noundef %46, i64 noundef %47, i64 noundef %31, ptr noundef nonnull %total_system_hmem, i64 noundef %call86, i64 noundef %call86, ptr noundef nonnull %used_memory_lua_hmem, i64 noundef %48, i64 noundef %add118, i64 noundef %call119, i64 noundef %call120, i64 noundef %call87, i64 noundef %add, ptr noundef nonnull %used_memory_vm_total_hmem, i64 noundef %51, i64 noundef %add126, ptr noundef nonnull %used_memory_scripts_hmem, i64 noundef %53, ptr noundef nonnull %maxmemory_hmem, ptr noundef %call85, double noundef %conv129, i64 noundef %55, double noundef %conv130, i64 noundef %57, double noundef %conv131, i64 noundef %59, double noundef %conv132, i64 noundef %61, i64 noundef %call133, i64 noundef %62, i64 noundef %63, i64 noundef %64, i64 noundef %65, i64 noundef %66, i64 noundef %67, ptr noundef nonnull @.str.361, i32 noundef %68, i64 noundef %call134, i64 noundef %call135) #38
  call void @freeMemoryOverheadData(ptr noundef nonnull %call88) #38
  br i1 %tobool1.not, label %lor.lhs.false139, label %if.then143.thread

if.then143.thread:                                ; preds = %if.end137
  %inc144272 = add nuw nsw i32 %sections.1260, 2
  br label %if.then146

lor.lhs.false139:                                 ; preds = %lor.lhs.false79, %if.end137
  %info.6269 = phi ptr [ %call136, %if.end137 ], [ %info.4263, %lor.lhs.false79 ]
  %sections.2267 = phi i32 [ %inc101, %if.end137 ], [ %sections.1261, %lor.lhs.false79 ]
  %call140 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.339) #38
  %cmp141.not = icmp eq ptr %call140, null
  br i1 %cmp141.not, label %lor.lhs.false255, label %if.then143

if.then143:                                       ; preds = %lor.lhs.false139
  %inc144 = add nsw i32 %sections.2267, 1
  %tobool145.not = icmp eq i32 %sections.2267, 0
  br i1 %tobool145.not, label %if.end148, label %if.then146

if.then146:                                       ; preds = %if.then143.thread, %if.then143
  %inc144275 = phi i32 [ %inc144272, %if.then143.thread ], [ %inc144, %if.then143 ]
  %info.6268274 = phi ptr [ %call136, %if.then143.thread ], [ %info.6269, %if.then143 ]
  %call147 = call ptr @sdscat(ptr noundef %info.6268274, ptr noundef nonnull @.str.170) #38
  br label %if.end148

if.end148:                                        ; preds = %if.then146, %if.then143
  %inc144276 = phi i32 [ %inc144275, %if.then146 ], [ 1, %if.then143 ]
  %info.7 = phi ptr [ %call147, %if.then146 ], [ %info.6269, %if.then143 ]
  %69 = load double, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 136), align 8
  %tobool149 = fcmp une double %69, 0.000000e+00
  br i1 %tobool149, label %if.then150, label %if.else151

if.then150:                                       ; preds = %if.end148
  %mul = fmul double %69, 1.000000e+02
  br label %do.body

if.else151:                                       ; preds = %if.end148
  %70 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 132), align 8
  %tobool152.not = icmp eq i64 %70, 0
  br i1 %tobool152.not, label %do.body, label %if.then153

if.then153:                                       ; preds = %if.else151
  %71 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 131), align 8
  %conv154 = uitofp i64 %71 to double
  %conv155 = uitofp i64 %70 to double
  %div156 = fdiv double %conv154, %conv155
  %mul157 = fmul double %div156, 1.000000e+02
  br label %do.body

do.body:                                          ; preds = %if.then150, %if.then153, %if.else151
  %fork_perc.0 = phi double [ %mul, %if.then150 ], [ %mul157, %if.then153 ], [ 0.000000e+00, %if.else151 ]
  %72 = load atomic i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 215) monotonic, align 8
  %73 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool160.not = icmp eq i32 %73, 0
  br i1 %tobool160.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %do.body
  %74 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 82), align 8
  %tobool161.not = icmp eq i32 %74, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.body
  %75 = phi i1 [ false, %do.body ], [ %tobool161.not, %land.rhs ]
  %land.ext = zext i1 %75 to i32
  %76 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 82), align 8
  %77 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 128), align 8
  %78 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 129), align 8
  %79 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 130), align 8
  %tobool162.not = icmp eq i64 %79, 0
  br i1 %tobool162.not, label %cond.end167, label %cond.true163

cond.true163:                                     ; preds = %land.end
  %80 = load ptr, ptr @getMonotonicUs, align 8
  %call.i.i = call i64 %80() #38
  %sub.i.i = sub i64 %call.i.i, %79
  %div165 = udiv i64 %sub.i.i, 1000000
  br label %cond.end167

cond.end167:                                      ; preds = %land.end, %cond.true163
  %cond168 = phi i64 [ %div165, %cond.true163 ], [ 0, %land.end ]
  %81 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 131), align 8
  %82 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 132), align 8
  %83 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  %84 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  %cmp169 = icmp eq i32 %84, 1
  %conv170 = zext i1 %cmp169 to i32
  %85 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 229), align 8
  %86 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 235), align 8
  %cmp171 = icmp eq i32 %86, 0
  %cond173 = select i1 %cmp171, ptr @.str.363, ptr @.str.364
  %87 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 231), align 8
  br i1 %cmp169, label %cond.false177, label %cond.end180

cond.false177:                                    ; preds = %cond.end167
  %call178 = call i64 @time(ptr noundef null) #38
  %88 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 232), align 8
  %sub179 = sub nsw i64 %call178, %88
  %.pre = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  br label %cond.end180

cond.end180:                                      ; preds = %cond.end167, %cond.false177
  %89 = phi i32 [ %.pre, %cond.false177 ], [ %84, %cond.end167 ]
  %cond181 = phi i64 [ %sub179, %cond.false177 ], [ -1, %cond.end167 ]
  %90 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 111), align 8
  %91 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 133), align 8
  %92 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 221), align 8
  %93 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 222), align 8
  %94 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp182 = icmp ne i32 %94, 0
  %conv183 = zext i1 %cmp182 to i32
  %cmp184 = icmp eq i32 %89, 2
  %conv185 = zext i1 %cmp184 to i32
  %95 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 197), align 4
  %96 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 203), align 8
  br i1 %cmp184, label %cond.false189, label %cond.end192

cond.false189:                                    ; preds = %cond.end180
  %call190 = call i64 @time(ptr noundef null) #38
  %97 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 204), align 8
  %sub191 = sub nsw i64 %call190, %97
  %.pre401 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  br label %cond.end192

cond.end192:                                      ; preds = %cond.end180, %cond.false189
  %98 = phi i32 [ %.pre401, %cond.false189 ], [ %89, %cond.end180 ]
  %cond193 = phi i64 [ %sub191, %cond.false189 ], [ -1, %cond.end180 ]
  %99 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 207), align 4
  %cmp194 = icmp eq i32 %99, 0
  %cond196 = select i1 %cmp194, ptr @.str.363, ptr @.str.364
  %100 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 109), align 8
  %101 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 110), align 8
  %102 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 211), align 8
  %cmp197 = icmp eq i32 %102, 0
  %cmp200 = icmp eq i32 %72, 0
  %103 = select i1 %cmp197, i1 %cmp200, i1 false
  %cond204 = select i1 %103, ptr @.str.363, ptr @.str.364
  %104 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 134), align 8
  %cmp205 = icmp eq i32 %98, 4
  %conv206 = zext i1 %cmp205 to i32
  %105 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 135), align 8
  %call207 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.7, ptr noundef nonnull @.str.362, i32 noundef %land.ext, i32 noundef %76, i64 noundef %77, i64 noundef %78, i64 noundef %cond168, double noundef %fork_perc.0, i64 noundef %81, i64 noundef %82, i64 noundef %83, i32 noundef %conv170, i64 noundef %85, ptr noundef nonnull %cond173, i64 noundef %87, i64 noundef %cond181, i64 noundef %90, i64 noundef %91, i64 noundef %92, i64 noundef %93, i32 noundef %conv183, i32 noundef %conv185, i32 noundef %95, i64 noundef %96, i64 noundef %cond193, ptr noundef nonnull %cond196, i64 noundef %100, i64 noundef %101, ptr noundef nonnull %cond204, i64 noundef %104, i32 noundef %conv206, i64 noundef %105) #38
  %106 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 184), align 4
  %tobool208.not = icmp eq i32 %106, 0
  br i1 %tobool208.not, label %if.end213, label %if.then209

if.then209:                                       ; preds = %cond.end192
  %107 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 193), align 8
  %108 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 192), align 8
  %109 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 197), align 4
  %110 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 198), align 8
  %arrayidx.i178 = getelementptr inbounds i8, ptr %110, i64 -1
  %111 = load i8, ptr %arrayidx.i178, align 1
  %conv.i179 = zext i8 %111 to i32
  %and.i = and i32 %conv.i179, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then209
  %shr.i = lshr i32 %conv.i179, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then209
  %add.ptr.i = getelementptr inbounds i8, ptr %110, i64 -3
  %112 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %112 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then209
  %add.ptr6.i = getelementptr inbounds i8, ptr %110, i64 -5
  %113 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %113 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then209
  %add.ptr10.i = getelementptr inbounds i8, ptr %110, i64 -9
  %114 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %114 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then209
  %add.ptr14.i = getelementptr inbounds i8, ptr %110, i64 -17
  %115 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then209, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %115, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then209 ]
  %call211 = call i64 @bioPendingJobsOfType(i32 noundef 1) #38
  %116 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 208), align 8
  %call212 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call207, ptr noundef nonnull @.str.365, i64 noundef %107, i64 noundef %108, i32 noundef %109, i64 noundef %retval.0.i, i64 noundef %call211, i64 noundef %116) #38
  br label %if.end213

if.end213:                                        ; preds = %sdslen.exit, %cond.end192
  %info.8 = phi ptr [ %call212, %sdslen.exit ], [ %call207, %cond.end192 ]
  %117 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool214.not = icmp eq i32 %117, 0
  br i1 %tobool214.not, label %if.end253, label %if.then215

if.then215:                                       ; preds = %if.end213
  %118 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 83), align 8
  %tobool216.not = icmp eq i64 %118, 0
  br i1 %tobool216.not, label %if.else223, label %if.then217

if.then217:                                       ; preds = %if.then215
  %119 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 85), align 8
  %conv218 = sitofp i64 %119 to double
  %conv219 = sitofp i64 %118 to double
  %div220 = fdiv double %conv218, %conv219
  %mul221 = fmul double %div220, 1.000000e+02
  %sub222 = sub nsw i64 %118, %119
  br label %if.end240

if.else223:                                       ; preds = %if.then215
  %120 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 84), align 8
  %tobool224.not = icmp eq i64 %120, 0
  br i1 %tobool224.not, label %if.end240, label %if.then225

if.then225:                                       ; preds = %if.else223
  %121 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 85), align 8
  %conv226 = sitofp i64 %121 to double
  %conv227 = sitofp i64 %120 to double
  %div228 = fdiv double %conv226, %conv227
  %mul229 = fmul double %div228, 1.000000e+02
  %sub230 = sub nsw i64 %120, %121
  %cmp231 = fcmp ogt double %mul229, 0x4058FF5C28F5C28F
  %perc.0 = select i1 %cmp231, double 0x4058FF5C28F5C28F, double %mul229
  %spec.store.select = call i64 @llvm.smax.i64(i64 %sub230, i64 1)
  br label %if.end240

if.end240:                                        ; preds = %if.else223, %if.then225, %if.then217
  %remaining_bytes.0 = phi i64 [ %sub222, %if.then217 ], [ %spec.store.select, %if.then225 ], [ 1, %if.else223 ]
  %perc.1 = phi double [ %mul221, %if.then217 ], [ %perc.0, %if.then225 ], [ 0.000000e+00, %if.else223 ]
  %call241 = call i64 @time(ptr noundef null) #38
  %122 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 86), align 8
  %cmp243 = icmp eq i64 %call241, %122
  %.pre402 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 85), align 8
  br i1 %cmp243, label %if.end250, label %if.else246

if.else246:                                       ; preds = %if.end240
  %sub242 = sub nsw i64 %call241, %122
  %mul247 = mul nsw i64 %sub242, %remaining_bytes.0
  %add248 = add nsw i64 %.pre402, 1
  %div249 = sdiv i64 %mul247, %add248
  br label %if.end250

if.end250:                                        ; preds = %if.end240, %if.else246
  %eta.0 = phi i64 [ %div249, %if.else246 ], [ 1, %if.end240 ]
  %123 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 83), align 8
  %124 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 84), align 8
  %call251 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.8, ptr noundef nonnull @.str.366, i64 noundef %122, i64 noundef %123, i64 noundef %124, i64 noundef %.pre402, double noundef %perc.1, i64 noundef %eta.0) #38
  br label %if.end253

if.end253:                                        ; preds = %if.end213, %if.end250
  %info.9 = phi ptr [ %call251, %if.end250 ], [ %info.8, %if.end213 ]
  br i1 %tobool1.not, label %lor.lhs.false255, label %if.then259

lor.lhs.false255:                                 ; preds = %lor.lhs.false139, %if.end253
  %info.9282 = phi ptr [ %info.9, %if.end253 ], [ %info.6269, %lor.lhs.false139 ]
  %sections.3280 = phi i32 [ %inc144276, %if.end253 ], [ %sections.2267, %lor.lhs.false139 ]
  %call256 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.340) #38
  %cmp257.not = icmp eq ptr %call256, null
  br i1 %cmp257.not, label %lor.lhs.false355, label %if.then259

if.then259:                                       ; preds = %lor.lhs.false255, %if.end253
  %info.9281 = phi ptr [ %info.9282, %lor.lhs.false255 ], [ %info.9, %if.end253 ]
  %sections.3279 = phi i32 [ %sections.3280, %lor.lhs.false255 ], [ %inc144276, %if.end253 ]
  %125 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 98), align 8
  %tobool260.not = icmp eq i64 %125, 0
  br i1 %tobool260.not, label %cond.end264, label %cond.true261

cond.true261:                                     ; preds = %if.then259
  %126 = load ptr, ptr @getMonotonicUs, align 8
  %call.i = call i64 %126() #38
  %sub.i = sub i64 %call.i, %125
  br label %cond.end264

cond.end264:                                      ; preds = %if.then259, %cond.true261
  %cond265 = phi i64 [ %sub.i, %cond.true261 ], [ 0, %if.then259 ]
  %127 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 107), align 8
  %tobool266.not = icmp eq i64 %127, 0
  br i1 %tobool266.not, label %cond.end270, label %cond.true267

cond.true267:                                     ; preds = %cond.end264
  %128 = load ptr, ptr @getMonotonicUs, align 8
  %call.i180 = call i64 %128() #38
  %sub.i181 = sub i64 %call.i180, %127
  br label %cond.end270

cond.end270:                                      ; preds = %cond.end264, %cond.true267
  %cond271 = phi i64 [ %sub.i181, %cond.true267 ], [ 0, %cond.end264 ]
  %129 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 144) monotonic, align 8
  %130 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 145) monotonic, align 8
  %131 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 124) monotonic, align 8
  %132 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 125) monotonic, align 8
  %133 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 126) monotonic, align 8
  %134 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 127) monotonic, align 8
  %135 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 146) monotonic, align 8
  %inc293 = add nsw i32 %sections.3279, 1
  %tobool294.not = icmp eq i32 %sections.3279, 0
  br i1 %tobool294.not, label %if.end297, label %if.then295

if.then295:                                       ; preds = %cond.end270
  %call296 = call ptr @sdscat(ptr noundef %info.9281, ptr noundef nonnull @.str.170) #38
  br label %if.end297

if.end297:                                        ; preds = %if.then295, %cond.end270
  %info.10 = phi ptr [ %call296, %if.then295 ], [ %info.9281, %cond.end270 ]
  %136 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 90), align 8
  %137 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 89), align 8
  br label %for.body.i182

for.body.i182:                                    ; preds = %for.body.i182, %if.end297
  %indvars.iv.i183 = phi i64 [ 0, %if.end297 ], [ %indvars.iv.next.i184, %for.body.i182 ]
  %sum.05.i = phi i64 [ 0, %if.end297 ], [ %add.i, %for.body.i182 ]
  %arrayidx2.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 0, i32 2, i64 %indvars.iv.i183
  %138 = load i64, ptr %arrayidx2.i, align 8
  %add.i = add nsw i64 %138, %sum.05.i
  %indvars.iv.next.i184 = add nuw nsw i64 %indvars.iv.i183, 1
  %exitcond.not.i185 = icmp eq i64 %indvars.iv.next.i184, 16
  br i1 %exitcond.not.i185, label %getInstantaneousMetric.exit, label %for.body.i182, !llvm.loop !9

getInstantaneousMetric.exit:                      ; preds = %for.body.i182
  %add299 = add nsw i64 %133, %131
  br label %for.body.i187

for.body.i187:                                    ; preds = %for.body.i187, %getInstantaneousMetric.exit
  %indvars.iv.i188 = phi i64 [ 0, %getInstantaneousMetric.exit ], [ %indvars.iv.next.i192, %for.body.i187 ]
  %sum.05.i189 = phi i64 [ 0, %getInstantaneousMetric.exit ], [ %add.i191, %for.body.i187 ]
  %arrayidx2.i190 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 1, i32 2, i64 %indvars.iv.i188
  %139 = load i64, ptr %arrayidx2.i190, align 8
  %add.i191 = add nsw i64 %139, %sum.05.i189
  %indvars.iv.next.i192 = add nuw nsw i64 %indvars.iv.i188, 1
  %exitcond.not.i193 = icmp eq i64 %indvars.iv.next.i192, 16
  br i1 %exitcond.not.i193, label %getInstantaneousMetric.exit195, label %for.body.i187, !llvm.loop !9

getInstantaneousMetric.exit195:                   ; preds = %for.body.i187
  %div.i186 = sdiv i64 %add.i, 16
  %div.i194 = sdiv i64 %add.i191, 16
  %conv302 = sitofp i64 %div.i194 to float
  %div303 = fmul float %conv302, 0x3F50000000000000
  br label %for.body.i196

for.body.i196:                                    ; preds = %for.body.i196, %getInstantaneousMetric.exit195
  %indvars.iv.i197 = phi i64 [ 0, %getInstantaneousMetric.exit195 ], [ %indvars.iv.next.i201, %for.body.i196 ]
  %sum.05.i198 = phi i64 [ 0, %getInstantaneousMetric.exit195 ], [ %add.i200, %for.body.i196 ]
  %arrayidx2.i199 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 2, i32 2, i64 %indvars.iv.i197
  %140 = load i64, ptr %arrayidx2.i199, align 8
  %add.i200 = add nsw i64 %140, %sum.05.i198
  %indvars.iv.next.i201 = add nuw nsw i64 %indvars.iv.i197, 1
  %exitcond.not.i202 = icmp eq i64 %indvars.iv.next.i201, 16
  br i1 %exitcond.not.i202, label %getInstantaneousMetric.exit204, label %for.body.i196, !llvm.loop !9

getInstantaneousMetric.exit204:                   ; preds = %for.body.i196
  %add300 = add nsw i64 %134, %132
  %div.i203 = sdiv i64 %add.i200, 16
  %conv306 = sitofp i64 %div.i203 to float
  %div307 = fmul float %conv306, 0x3F50000000000000
  br label %for.body.i205

for.body.i205:                                    ; preds = %for.body.i205, %getInstantaneousMetric.exit204
  %indvars.iv.i206 = phi i64 [ 0, %getInstantaneousMetric.exit204 ], [ %indvars.iv.next.i210, %for.body.i205 ]
  %sum.05.i207 = phi i64 [ 0, %getInstantaneousMetric.exit204 ], [ %add.i209, %for.body.i205 ]
  %arrayidx2.i208 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 3, i32 2, i64 %indvars.iv.i206
  %141 = load i64, ptr %arrayidx2.i208, align 8
  %add.i209 = add nsw i64 %141, %sum.05.i207
  %indvars.iv.next.i210 = add nuw nsw i64 %indvars.iv.i206, 1
  %exitcond.not.i211 = icmp eq i64 %indvars.iv.next.i210, 16
  br i1 %exitcond.not.i211, label %getInstantaneousMetric.exit213, label %for.body.i205, !llvm.loop !9

getInstantaneousMetric.exit213:                   ; preds = %for.body.i205
  %conv304 = fpext float %div303 to double
  %div.i212 = sdiv i64 %add.i209, 16
  %conv310 = sitofp i64 %div.i212 to float
  %div311 = fmul float %conv310, 0x3F50000000000000
  br label %for.body.i214

for.body.i214:                                    ; preds = %for.body.i214, %getInstantaneousMetric.exit213
  %indvars.iv.i215 = phi i64 [ 0, %getInstantaneousMetric.exit213 ], [ %indvars.iv.next.i219, %for.body.i214 ]
  %sum.05.i216 = phi i64 [ 0, %getInstantaneousMetric.exit213 ], [ %add.i218, %for.body.i214 ]
  %arrayidx2.i217 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 4, i32 2, i64 %indvars.iv.i215
  %142 = load i64, ptr %arrayidx2.i217, align 8
  %add.i218 = add nsw i64 %142, %sum.05.i216
  %indvars.iv.next.i219 = add nuw nsw i64 %indvars.iv.i215, 1
  %exitcond.not.i220 = icmp eq i64 %indvars.iv.next.i219, 16
  br i1 %exitcond.not.i220, label %getInstantaneousMetric.exit222, label %for.body.i214, !llvm.loop !9

getInstantaneousMetric.exit222:                   ; preds = %for.body.i214
  %conv308 = fpext float %div307 to double
  %div.i221 = sdiv i64 %add.i218, 16
  %conv314 = sitofp i64 %div.i221 to float
  %div315 = fmul float %conv314, 0x3F50000000000000
  %143 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 115), align 8
  %144 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 116), align 8
  %145 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 117), align 8
  %146 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 118), align 8
  %147 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 91), align 8
  %148 = load double, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 92), align 8
  %149 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 93), align 8
  %150 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 94), align 8
  %151 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 95), align 8
  %152 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 96), align 8
  %153 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 97), align 8
  %add319 = add nsw i64 %153, %cond265
  %div320 = sdiv i64 %add319, 1000
  %154 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 99), align 8
  %155 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 100), align 8
  %156 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 357), align 8
  %ht_used322 = getelementptr inbounds %struct.dict, ptr %156, i64 0, i32 2
  %157 = load i64, ptr %ht_used322, align 8
  %arrayidx325 = getelementptr inbounds %struct.dict, ptr %156, i64 0, i32 2, i64 1
  %158 = load i64, ptr %arrayidx325, align 8
  %159 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 358), align 8
  %ht_used327 = getelementptr inbounds %struct.dict, ptr %159, i64 0, i32 2
  %160 = load i64, ptr %ht_used327, align 8
  %arrayidx330 = getelementptr inbounds %struct.dict, ptr %159, i64 0, i32 2, i64 1
  %161 = load i64, ptr %arrayidx330, align 8
  %162 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 360), align 8
  %ht_used332 = getelementptr inbounds %struct.dict, ptr %162, i64 0, i32 2
  %163 = load i64, ptr %ht_used332, align 8
  %arrayidx335 = getelementptr inbounds %struct.dict, ptr %162, i64 0, i32 2, i64 1
  %164 = load i64, ptr %arrayidx335, align 8
  %165 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 112), align 8
  %166 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 114), align 8
  %167 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 71), align 8
  %ht_used337 = getelementptr inbounds %struct.dict, ptr %167, i64 0, i32 2
  %168 = load i64, ptr %ht_used337, align 8
  %arrayidx340 = getelementptr inbounds %struct.dict, ptr %167, i64 0, i32 2, i64 1
  %169 = load i64, ptr %arrayidx340, align 8
  %call342 = call i64 @getSlaveKeyWithExpireCount() #38
  %170 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 101), align 8
  %171 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 102), align 8
  %172 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 103), align 8
  %173 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 104), align 8
  %174 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 106), align 8
  %add343 = add nsw i64 %174, %cond271
  %div344 = sdiv i64 %add343, 1000
  %call346 = call i64 @trackingGetTotalKeys() #38
  %call347 = call i64 @trackingGetTotalItems() #38
  %call348 = call i64 @trackingGetTotalPrefixes() #38
  %175 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 139), align 8
  %176 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 140), align 8
  %177 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 141), align 8
  %178 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 142), align 8
  %179 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 143), align 8
  %180 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 147), align 8
  %181 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 149), align 8
  %182 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 150), align 8
  %183 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155), align 8
  %184 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155, i64 0, i32 1), align 8
  %185 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155, i64 1, i32 1), align 8
  br label %for.body.i223

for.body.i223:                                    ; preds = %for.body.i223, %getInstantaneousMetric.exit222
  %indvars.iv.i224 = phi i64 [ 0, %getInstantaneousMetric.exit222 ], [ %indvars.iv.next.i228, %for.body.i223 ]
  %sum.05.i225 = phi i64 [ 0, %getInstantaneousMetric.exit222 ], [ %add.i227, %for.body.i223 ]
  %arrayidx2.i226 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 5, i32 2, i64 %indvars.iv.i224
  %186 = load i64, ptr %arrayidx2.i226, align 8
  %add.i227 = add nsw i64 %186, %sum.05.i225
  %indvars.iv.next.i228 = add nuw nsw i64 %indvars.iv.i224, 1
  %exitcond.not.i229 = icmp eq i64 %indvars.iv.next.i228, 16
  br i1 %exitcond.not.i229, label %getInstantaneousMetric.exit231, label %for.body.i223, !llvm.loop !9

getInstantaneousMetric.exit231:                   ; preds = %for.body.i223
  %conv316 = fpext float %div315 to double
  %div318 = sdiv i64 %150, 1000
  %add326 = add i64 %158, %157
  %add336 = add i64 %164, %163
  %div345 = sdiv i64 %cond271, 1000
  br label %for.body.i232

for.body.i232:                                    ; preds = %for.body.i232, %getInstantaneousMetric.exit231
  %indvars.iv.i233 = phi i64 [ 0, %getInstantaneousMetric.exit231 ], [ %indvars.iv.next.i237, %for.body.i232 ]
  %sum.05.i234 = phi i64 [ 0, %getInstantaneousMetric.exit231 ], [ %add.i236, %for.body.i232 ]
  %arrayidx2.i235 = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 148, i64 6, i32 2, i64 %indvars.iv.i233
  %187 = load i64, ptr %arrayidx2.i235, align 8
  %add.i236 = add nsw i64 %187, %sum.05.i234
  %indvars.iv.next.i237 = add nuw nsw i64 %indvars.iv.i233, 1
  %exitcond.not.i238 = icmp eq i64 %indvars.iv.next.i237, 16
  br i1 %exitcond.not.i238, label %if.end353, label %for.body.i232, !llvm.loop !9

if.end353:                                        ; preds = %for.body.i232
  %conv312 = fpext float %div311 to double
  %mul317 = fmul double %148, 1.000000e+02
  %div321 = sdiv i64 %cond265, 1000
  %add331 = add i64 %161, %160
  %add341 = add i64 %169, %168
  %div.i230 = sdiv i64 %add.i227, 16
  %div.i239 = sdiv i64 %add.i236, 16
  %call351 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.10, ptr noundef nonnull @.str.367, i64 noundef %136, i64 noundef %137, i64 noundef %div.i186, i64 noundef %add299, i64 noundef %add300, i64 noundef %133, i64 noundef %134, double noundef %conv304, double noundef %conv308, double noundef %conv312, double noundef %conv316, i64 noundef %143, i64 noundef %144, i64 noundef %145, i64 noundef %146, i64 noundef %147, double noundef %mul317, i64 noundef %149, i64 noundef %div318, i64 noundef %151, i64 noundef %152, i64 noundef %div320, i64 noundef %div321, i64 noundef %154, i64 noundef %155, i64 noundef %add326, i64 noundef %add331, i64 noundef %add336, i64 noundef %165, i64 noundef %166, i64 noundef %add341, i64 noundef %call342, i64 noundef %170, i64 noundef %171, i64 noundef %172, i64 noundef %173, i64 noundef %div344, i64 noundef %div345, i64 noundef %call346, i64 noundef %call347, i64 noundef %call348, i64 noundef %175, i64 noundef %176, i64 noundef %177, i64 noundef %129, i64 noundef %130, i64 noundef %178, i64 noundef %179, i64 noundef %135, i64 noundef %180, i64 noundef %181, i64 noundef %182, i64 noundef %183, i64 noundef %184, i64 noundef %185, i64 noundef %div.i230, i64 noundef %div.i239) #38
  %188 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399), align 8
  %189 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399, i32 1), align 8
  %190 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399, i32 2), align 8
  %191 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 399, i32 3), align 8
  %call.i241 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call351, ptr noundef nonnull @.str.335, i64 noundef %188, i64 noundef %189, i64 noundef %190, i64 noundef %191) #38
  br i1 %tobool1.not, label %lor.lhs.false355, label %if.then359

lor.lhs.false355:                                 ; preds = %lor.lhs.false255, %if.end353
  %info.11288 = phi ptr [ %call.i241, %if.end353 ], [ %info.9282, %lor.lhs.false255 ]
  %sections.4286 = phi i32 [ %inc293, %if.end353 ], [ %sections.3280, %lor.lhs.false255 ]
  %call356 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.341) #38
  %cmp357.not = icmp eq ptr %call356, null
  br i1 %cmp357.not, label %lor.lhs.false480, label %if.then359

if.then359:                                       ; preds = %lor.lhs.false355, %if.end353
  %info.11287 = phi ptr [ %info.11288, %lor.lhs.false355 ], [ %call.i241, %if.end353 ]
  %sections.4285 = phi i32 [ %sections.4286, %lor.lhs.false355 ], [ %inc293, %if.end353 ]
  %inc360 = add nsw i32 %sections.4285, 1
  %tobool361.not = icmp eq i32 %sections.4285, 0
  br i1 %tobool361.not, label %if.end364, label %if.then362

if.then362:                                       ; preds = %if.then359
  %call363 = call ptr @sdscat(ptr noundef %info.11287, ptr noundef nonnull @.str.170) #38
  br label %if.end364

if.end364:                                        ; preds = %if.then362, %if.then359
  %info.12 = phi ptr [ %call363, %if.then362 ], [ %info.11287, %if.then359 ]
  %192 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp365 = icmp eq ptr %192, null
  %cond367 = select i1 %cmp365, ptr @.str.369, ptr @.str.370
  %call368 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.12, ptr noundef nonnull @.str.368, ptr noundef nonnull %cond367) #38
  %193 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %tobool369.not = icmp eq ptr %193, null
  br i1 %tobool369.not, label %if.end424, label %if.then370

if.then370:                                       ; preds = %if.end364
  %194 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 286), align 8
  %tobool371.not = icmp eq ptr %194, null
  br i1 %tobool371.not, label %if.else373, label %cond.true384

if.else373:                                       ; preds = %if.then370
  %195 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 287), align 8
  %tobool374.not = icmp eq ptr %195, null
  br i1 %tobool374.not, label %if.end379.thread, label %if.then375

if.then375:                                       ; preds = %if.else373
  %reploff376 = getelementptr inbounds %struct.client, ptr %195, i64 0, i32 42
  %196 = load i64, ptr %reploff376, align 8
  %read_reploff377 = getelementptr inbounds %struct.client, ptr %195, i64 0, i32 41
  %197 = load i64, ptr %read_reploff377, align 8
  br label %if.end379.thread

if.end379.thread:                                 ; preds = %if.else373, %if.then375
  %slave_repl_offset.0.ph = phi i64 [ 1, %if.else373 ], [ %196, %if.then375 ]
  %slave_read_repl_offset.0.ph = phi i64 [ 1, %if.else373 ], [ %197, %if.then375 ]
  %198 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 284), align 8
  %199 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  %cmp380291 = icmp eq i32 %199, 12
  %cond382292 = select i1 %cmp380291, ptr @.str.372, ptr @.str.373
  br label %cond.end389

cond.true384:                                     ; preds = %if.then370
  %reploff = getelementptr inbounds %struct.client, ptr %194, i64 0, i32 42
  %200 = load i64, ptr %reploff, align 8
  %read_reploff = getelementptr inbounds %struct.client, ptr %194, i64 0, i32 41
  %201 = load i64, ptr %read_reploff, align 8
  %202 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 284), align 8
  %203 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  %cmp380 = icmp eq i32 %203, 12
  %cond382 = select i1 %cmp380, ptr @.str.372, ptr @.str.373
  %atomic-load385 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %204 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 286), align 8
  %lastinteraction = getelementptr inbounds %struct.client, ptr %204, i64 0, i32 32
  %205 = load i64, ptr %lastinteraction, align 8
  %sub386 = sub nsw i64 %atomic-load385, %205
  %conv387 = trunc i64 %sub386 to i32
  %.pre403 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  br label %cond.end389

cond.end389:                                      ; preds = %if.end379.thread, %cond.true384
  %206 = phi i32 [ %.pre403, %cond.true384 ], [ %199, %if.end379.thread ]
  %cond382295 = phi ptr [ %cond382, %cond.true384 ], [ %cond382292, %if.end379.thread ]
  %207 = phi i32 [ %202, %cond.true384 ], [ %198, %if.end379.thread ]
  %slave_read_repl_offset.0294 = phi i64 [ %201, %cond.true384 ], [ %slave_read_repl_offset.0.ph, %if.end379.thread ]
  %slave_repl_offset.0293 = phi i64 [ %200, %cond.true384 ], [ %slave_repl_offset.0.ph, %if.end379.thread ]
  %cond390 = phi i32 [ %conv387, %cond.true384 ], [ -1, %if.end379.thread ]
  %cmp391 = icmp eq i32 %206, 11
  %conv392 = zext i1 %cmp391 to i32
  %call393 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call368, ptr noundef nonnull @.str.371, ptr noundef nonnull %193, i32 noundef %207, ptr noundef nonnull %cond382295, i32 noundef %cond390, i32 noundef %conv392, i64 noundef %slave_read_repl_offset.0294, i64 noundef %slave_repl_offset.0293) #38
  %208 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  %cmp394 = icmp eq i32 %208, 11
  br i1 %cmp394, label %if.then396, label %if.end410

if.then396:                                       ; preds = %cond.end389
  %209 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 290), align 8
  %tobool398.not = icmp eq i64 %209, 0
  %.pre404 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 291), align 8
  %conv400 = sitofp i64 %.pre404 to double
  %conv401 = sitofp i64 %209 to double
  %div402 = fdiv double %conv400, %conv401
  %mul403 = fmul double %div402, 1.000000e+02
  %perc397.0 = select i1 %tobool398.not, double 0.000000e+00, double %mul403
  %sub405 = sub nsw i64 %209, %.pre404
  %atomic-load406 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %210 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 296), align 8
  %sub407 = sub nsw i64 %atomic-load406, %210
  %conv408 = trunc i64 %sub407 to i32
  %call409 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call393, ptr noundef nonnull @.str.374, i64 noundef %209, i64 noundef %.pre404, i64 noundef %sub405, double noundef %perc397.0, i32 noundef %conv408) #38
  %.pr = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  br label %if.end410

if.end410:                                        ; preds = %if.then396, %cond.end389
  %211 = phi i32 [ %.pr, %if.then396 ], [ %208, %cond.end389 ]
  %info.13 = phi ptr [ %call409, %if.then396 ], [ %call393, %cond.end389 ]
  %cmp411.not = icmp eq i32 %211, 12
  br i1 %cmp411.not, label %if.end422, label %if.then413

if.then413:                                       ; preds = %if.end410
  %212 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 300), align 8
  %tobool414.not = icmp eq i64 %212, 0
  br i1 %tobool414.not, label %cond.end419, label %cond.true415

cond.true415:                                     ; preds = %if.then413
  %atomic-load416 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %213 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 300), align 8
  %sub417 = sub nsw i64 %atomic-load416, %213
  br label %cond.end419

cond.end419:                                      ; preds = %if.then413, %cond.true415
  %cond420 = phi i64 [ %sub417, %cond.true415 ], [ -1, %if.then413 ]
  %call421 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.13, ptr noundef nonnull @.str.375, i64 noundef %cond420) #38
  br label %if.end422

if.end422:                                        ; preds = %cond.end419, %if.end410
  %info.14 = phi ptr [ %call421, %cond.end419 ], [ %info.13, %if.end410 ]
  %214 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 302), align 4
  %215 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 298), align 4
  %216 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 303), align 8
  %call423 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.14, ptr noundef nonnull @.str.376, i32 noundef %214, i32 noundef %215, i32 noundef %216) #38
  br label %if.end424

if.end424:                                        ; preds = %if.end422, %if.end364
  %info.15 = phi ptr [ %call423, %if.end422 ], [ %call368, %if.end364 ]
  %217 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len425 = getelementptr inbounds %struct.list, ptr %217, i64 0, i32 5
  %218 = load i64, ptr %len425, align 8
  %call426 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.15, ptr noundef nonnull @.str.377, i64 noundef %218) #38
  %219 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 272), align 8
  %tobool427 = icmp ne i32 %219, 0
  %220 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 273), align 4
  %tobool428 = icmp ne i32 %220, 0
  %or.cond = select i1 %tobool427, i1 %tobool428, i1 false
  br i1 %or.cond, label %if.then429, label %if.end431

if.then429:                                       ; preds = %if.end424
  %221 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 274), align 8
  %call430 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call426, ptr noundef nonnull @.str.378, i32 noundef %221) #38
  br label %if.end431

if.end431:                                        ; preds = %if.then429, %if.end424
  %info.16 = phi ptr [ %call430, %if.then429 ], [ %call426, %if.end424 ]
  %222 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len432 = getelementptr inbounds %struct.list, ptr %222, i64 0, i32 5
  %223 = load i64, ptr %len432, align 8
  %tobool433.not = icmp eq i64 %223, 0
  br i1 %tobool433.not, label %if.end463, label %if.then434

if.then434:                                       ; preds = %if.end431
  call void @listRewind(ptr noundef nonnull %222, ptr noundef nonnull %li) #38
  %call435369373 = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool436.not370374 = icmp eq ptr %call435369373, null
  br i1 %tobool436.not370374, label %if.end463, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.then434, %if.end460
  %call435369378 = phi ptr [ %call435369, %if.end460 ], [ %call435369373, %if.then434 ]
  %info.17.ph376 = phi ptr [ %call461, %if.end460 ], [ %info.16, %if.then434 ]
  %slaveid.0.ph375 = phi i32 [ %inc462, %if.end460 ], [ 0, %if.then434 ]
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %call435371 = phi ptr [ %call435369378, %while.body.lr.ph ], [ %call435, %while.cond.backedge ]
  %value = getelementptr inbounds %struct.listNode, ptr %call435371, i64 0, i32 2
  %224 = load ptr, ptr %value, align 8
  %slave_addr = getelementptr inbounds %struct.client, ptr %224, i64 0, i32 51
  %225 = load ptr, ptr %slave_addr, align 8
  %tobool437.not = icmp eq ptr %225, null
  br i1 %tobool437.not, label %if.then438, label %if.end446

if.then438:                                       ; preds = %while.body
  %conn = getelementptr inbounds %struct.client, ptr %224, i64 0, i32 2
  %226 = load ptr, ptr %conn, align 8
  %tobool.not.i.i = icmp eq ptr %226, null
  br i1 %tobool.not.i.i, label %while.cond.backedge, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.then438
  %227 = load ptr, ptr %226, align 8
  %addr.i.i = getelementptr inbounds %struct.ConnectionType, ptr %227, i64 0, i32 6
  %228 = load ptr, ptr %addr.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %228, null
  br i1 %tobool1.not.i.i, label %while.cond.backedge, label %connAddrPeerName.exit

connAddrPeerName.exit:                            ; preds = %land.lhs.true.i.i
  %call.i.i242 = call i32 %228(ptr noundef nonnull %226, ptr noundef nonnull %ip, i64 noundef 46, ptr noundef nonnull %port, i32 noundef 1) #38
  %cmp441 = icmp eq i32 %call.i.i242, -1
  br i1 %cmp441, label %while.cond.backedge, label %if.end446

while.cond.backedge:                              ; preds = %if.then438, %land.lhs.true.i.i, %connAddrPeerName.exit, %replstateToString.exit
  %call435 = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool436.not = icmp eq ptr %call435, null
  br i1 %tobool436.not, label %if.end463, label %while.body, !llvm.loop !72

if.end446:                                        ; preds = %connAddrPeerName.exit, %while.body
  %slaveip.0 = phi ptr [ %225, %while.body ], [ %ip, %connAddrPeerName.exit ]
  %replstate = getelementptr inbounds %struct.client, ptr %224, i64 0, i32 35
  %229 = load i32, ptr %replstate, align 4
  switch i32 %229, label %sw.default.i [
    i32 6, label %replstateToString.exit
    i32 7, label %replstateToString.exit
    i32 8, label %if.end460
    i32 9, label %if.then457
  ]

sw.default.i:                                     ; preds = %if.end446
  br label %replstateToString.exit

replstateToString.exit:                           ; preds = %if.end446, %if.end446, %sw.default.i
  %retval.0.i243 = phi ptr [ @.str.219, %sw.default.i ], [ @.str.331, %if.end446 ], [ @.str.331, %if.end446 ]
  %230 = load i8, ptr %retval.0.i243, align 1
  %cmp450 = icmp eq i8 %230, 0
  br i1 %cmp450, label %while.cond.backedge, label %if.end460

if.then457:                                       ; preds = %if.end446
  %call458 = call i64 @time(ptr noundef null) #38
  %repl_ack_time = getelementptr inbounds %struct.client, ptr %224, i64 0, i32 46
  %231 = load i64, ptr %repl_ack_time, align 8
  %sub459 = sub nsw i64 %call458, %231
  br label %if.end460

if.end460:                                        ; preds = %if.end446, %replstateToString.exit, %if.then457
  %retval.0.i243298301 = phi ptr [ @.str.333, %if.then457 ], [ @.str.332, %if.end446 ], [ %retval.0.i243, %replstateToString.exit ]
  %lag.0 = phi i64 [ %sub459, %if.then457 ], [ 0, %replstateToString.exit ], [ 0, %if.end446 ]
  %slave_listening_port = getelementptr inbounds %struct.client, ptr %224, i64 0, i32 50
  %232 = load i32, ptr %slave_listening_port, align 4
  %repl_ack_off = getelementptr inbounds %struct.client, ptr %224, i64 0, i32 44
  %233 = load i64, ptr %repl_ack_off, align 8
  %call461 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.17.ph376, ptr noundef nonnull @.str.379, i32 noundef %slaveid.0.ph375, ptr noundef nonnull %slaveip.0, i32 noundef %232, ptr noundef nonnull %retval.0.i243298301, i64 noundef %233, i64 noundef %lag.0) #38
  %inc462 = add nuw nsw i32 %slaveid.0.ph375, 1
  %call435369 = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool436.not370 = icmp eq ptr %call435369, null
  br i1 %tobool436.not370, label %if.end463, label %while.body.lr.ph, !llvm.loop !72

if.end463:                                        ; preds = %if.end460, %while.cond.backedge, %if.then434, %if.end431
  %info.18 = phi ptr [ %info.16, %if.end431 ], [ %info.16, %if.then434 ], [ %info.17.ph376, %while.cond.backedge ], [ %call461, %if.end460 ]
  %call464 = call ptr @getFailoverStateString() #38
  %234 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %235 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 263), align 8
  %236 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 268), align 8
  %cmp465 = icmp ne ptr %236, null
  %conv466 = zext i1 %cmp465 to i32
  %237 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 269), align 8
  br i1 %cmp465, label %cond.true473, label %if.end478

cond.true473:                                     ; preds = %if.end463
  %offset = getelementptr inbounds %struct.replBacklog, ptr %236, i64 0, i32 4
  %238 = load i64, ptr %offset, align 8
  %histlen = getelementptr inbounds %struct.replBacklog, ptr %236, i64 0, i32 3
  %239 = load i64, ptr %histlen, align 8
  br label %if.end478

if.end478:                                        ; preds = %if.end463, %cond.true473
  %cond471311 = phi i64 [ %238, %cond.true473 ], [ 0, %if.end463 ]
  %cond476 = phi i64 [ %239, %cond.true473 ], [ 0, %if.end463 ]
  %call477 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.18, ptr noundef nonnull @.str.380, ptr noundef %call464, ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 260), ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 261), i64 noundef %234, i64 noundef %235, i32 noundef %conv466, i64 noundef %237, i64 noundef %cond471311, i64 noundef %cond476) #38
  br i1 %tobool1.not, label %lor.lhs.false480, label %if.then484

lor.lhs.false480:                                 ; preds = %lor.lhs.false355, %if.end478
  %info.19317 = phi ptr [ %call477, %if.end478 ], [ %info.11288, %lor.lhs.false355 ]
  %sections.5315 = phi i32 [ %inc360, %if.end478 ], [ %sections.4286, %lor.lhs.false355 ]
  %call481 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.342) #38
  %cmp482.not = icmp eq ptr %call481, null
  br i1 %cmp482.not, label %lor.lhs.false517, label %if.then484

if.then484:                                       ; preds = %lor.lhs.false480, %if.end478
  %info.19316 = phi ptr [ %info.19317, %lor.lhs.false480 ], [ %call477, %if.end478 ]
  %sections.5314 = phi i32 [ %sections.5315, %lor.lhs.false480 ], [ %inc360, %if.end478 ]
  %inc485 = add nsw i32 %sections.5314, 1
  %tobool486.not = icmp eq i32 %sections.5314, 0
  br i1 %tobool486.not, label %if.end515, label %if.then487

if.then487:                                       ; preds = %if.then484
  %call488 = call ptr @sdscat(ptr noundef %info.19316, ptr noundef nonnull @.str.170) #38
  br label %if.end515

if.end515:                                        ; preds = %if.then484, %if.then487
  %info.20 = phi ptr [ %call488, %if.then487 ], [ %info.19316, %if.then484 ]
  %call490 = call i32 @getrusage(i32 noundef 0, ptr noundef nonnull %self_ru) #38
  %call491 = call i32 @getrusage(i32 noundef -1, ptr noundef nonnull %c_ru) #38
  %ru_stime = getelementptr inbounds %struct.rusage, ptr %self_ru, i64 0, i32 1
  %240 = load i64, ptr %ru_stime, align 8
  %tv_usec = getelementptr inbounds %struct.rusage, ptr %self_ru, i64 0, i32 1, i32 1
  %241 = load i64, ptr %tv_usec, align 8
  %242 = load i64, ptr %self_ru, align 8
  %tv_usec495 = getelementptr inbounds %struct.timeval, ptr %self_ru, i64 0, i32 1
  %243 = load i64, ptr %tv_usec495, align 8
  %ru_stime496 = getelementptr inbounds %struct.rusage, ptr %c_ru, i64 0, i32 1
  %244 = load i64, ptr %ru_stime496, align 8
  %tv_usec499 = getelementptr inbounds %struct.rusage, ptr %c_ru, i64 0, i32 1, i32 1
  %245 = load i64, ptr %tv_usec499, align 8
  %246 = load i64, ptr %c_ru, align 8
  %tv_usec503 = getelementptr inbounds %struct.timeval, ptr %c_ru, i64 0, i32 1
  %247 = load i64, ptr %tv_usec503, align 8
  %call504 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.20, ptr noundef nonnull @.str.381, i64 noundef %240, i64 noundef %241, i64 noundef %242, i64 noundef %243, i64 noundef %244, i64 noundef %245, i64 noundef %246, i64 noundef %247) #38
  %call505 = call i32 @getrusage(i32 noundef 1, ptr noundef nonnull %m_ru) #38
  %ru_stime506 = getelementptr inbounds %struct.rusage, ptr %m_ru, i64 0, i32 1
  %248 = load i64, ptr %ru_stime506, align 8
  %tv_usec509 = getelementptr inbounds %struct.rusage, ptr %m_ru, i64 0, i32 1, i32 1
  %249 = load i64, ptr %tv_usec509, align 8
  %250 = load i64, ptr %m_ru, align 8
  %tv_usec513 = getelementptr inbounds %struct.timeval, ptr %m_ru, i64 0, i32 1
  %251 = load i64, ptr %tv_usec513, align 8
  %call514 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call504, ptr noundef nonnull @.str.382, i64 noundef %248, i64 noundef %249, i64 noundef %250, i64 noundef %251) #38
  br i1 %tobool1.not, label %lor.lhs.false517, label %if.then525

lor.lhs.false517:                                 ; preds = %lor.lhs.false480, %if.end515
  %info.21323 = phi ptr [ %call514, %if.end515 ], [ %info.19317, %lor.lhs.false480 ]
  %sections.6321 = phi i32 [ %inc485, %if.end515 ], [ %sections.5315, %lor.lhs.false480 ]
  %call518 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.343) #38
  %cmp519.not = icmp eq ptr %call518, null
  br i1 %cmp519.not, label %lor.lhs.false521, label %if.then525

lor.lhs.false521:                                 ; preds = %lor.lhs.false517
  %call522 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.383) #38
  %cmp523.not = icmp eq ptr %call522, null
  br i1 %cmp523.not, label %lor.lhs.false535, label %if.then525

if.then525:                                       ; preds = %lor.lhs.false521, %lor.lhs.false517, %if.end515
  %info.21322 = phi ptr [ %info.21323, %lor.lhs.false521 ], [ %info.21323, %lor.lhs.false517 ], [ %call514, %if.end515 ]
  %sections.6320 = phi i32 [ %sections.6321, %lor.lhs.false521 ], [ %sections.6321, %lor.lhs.false517 ], [ %inc485, %if.end515 ]
  %inc526 = add nsw i32 %sections.6320, 1
  %tobool527.not = icmp eq i32 %sections.6320, 0
  br i1 %tobool527.not, label %if.end533, label %if.then528

if.then528:                                       ; preds = %if.then525
  %call529 = call ptr @sdscat(ptr noundef %info.21322, ptr noundef nonnull @.str.170) #38
  br label %if.end533

if.end533:                                        ; preds = %if.then525, %if.then528
  %info.22 = phi ptr [ %call529, %if.then528 ], [ %info.21322, %if.then525 ]
  %call531 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.22, ptr noundef nonnull @.str.384) #38
  %call532 = call ptr @genModulesInfoString(ptr noundef %call531) #38
  br i1 %tobool1.not, label %lor.lhs.false535, label %if.then539

lor.lhs.false535:                                 ; preds = %lor.lhs.false521, %if.end533
  %info.23329 = phi ptr [ %call532, %if.end533 ], [ %info.21323, %lor.lhs.false521 ]
  %sections.7327 = phi i32 [ %inc526, %if.end533 ], [ %sections.6321, %lor.lhs.false521 ]
  %call536 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.385) #38
  %cmp537.not = icmp eq ptr %call536, null
  br i1 %cmp537.not, label %lor.lhs.false549, label %if.then539

if.then539:                                       ; preds = %lor.lhs.false535, %if.end533
  %info.23328 = phi ptr [ %info.23329, %lor.lhs.false535 ], [ %call532, %if.end533 ]
  %sections.7326 = phi i32 [ %sections.7327, %lor.lhs.false535 ], [ %inc526, %if.end533 ]
  %inc540 = add nsw i32 %sections.7326, 1
  %tobool541.not = icmp eq i32 %sections.7326, 0
  br i1 %tobool541.not, label %if.end547, label %if.then542

if.then542:                                       ; preds = %if.then539
  %call543 = call ptr @sdscat(ptr noundef %info.23328, ptr noundef nonnull @.str.170) #38
  br label %if.end547

if.end547:                                        ; preds = %if.then539, %if.then542
  %info.24 = phi ptr [ %call543, %if.then542 ], [ %info.23328, %if.then539 ]
  %call545 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.24, ptr noundef nonnull @.str.386) #38
  %252 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call546 = call ptr @genRedisInfoStringCommandStats(ptr noundef %call545, ptr noundef %252)
  br i1 %tobool1.not, label %lor.lhs.false549, label %if.then553

lor.lhs.false549:                                 ; preds = %lor.lhs.false535, %if.end547
  %info.25335 = phi ptr [ %call546, %if.end547 ], [ %info.23329, %lor.lhs.false535 ]
  %sections.8333 = phi i32 [ %inc540, %if.end547 ], [ %sections.7327, %lor.lhs.false535 ]
  %call550 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.344) #38
  %cmp551.not = icmp eq ptr %call550, null
  br i1 %cmp551.not, label %lor.lhs.false576, label %if.then553

if.then553:                                       ; preds = %lor.lhs.false549, %if.end547
  %info.25334 = phi ptr [ %info.25335, %lor.lhs.false549 ], [ %call546, %if.end547 ]
  %sections.8332 = phi i32 [ %sections.8333, %lor.lhs.false549 ], [ %inc540, %if.end547 ]
  %inc554 = add nsw i32 %sections.8332, 1
  %tobool555.not = icmp eq i32 %sections.8332, 0
  br i1 %tobool555.not, label %if.end558, label %if.then556

if.then556:                                       ; preds = %if.then553
  %call557 = call ptr @sdscat(ptr noundef %info.25334, ptr noundef nonnull @.str.170) #38
  br label %if.end558

if.end558:                                        ; preds = %if.then556, %if.then553
  %info.26 = phi ptr [ %call557, %if.then556 ], [ %info.25334, %if.then553 ]
  %call559 = call ptr @sdscat(ptr noundef %info.26, ptr noundef nonnull @.str.387) #38
  %253 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 15), align 8
  call void @raxStart(ptr noundef nonnull %ri, ptr noundef %253) #38
  %call560 = call i32 @raxSeek(ptr noundef nonnull %ri, ptr noundef nonnull @.str.388, ptr noundef null, i64 noundef 0) #38
  %call562380 = call i32 @raxNext(ptr noundef nonnull %ri) #38
  %tobool563.not381 = icmp eq i32 %call562380, 0
  br i1 %tobool563.not381, label %if.end574, label %while.body564.lr.ph

while.body564.lr.ph:                              ; preds = %if.end558
  %data = getelementptr inbounds %struct.raxIterator, ptr %ri, i64 0, i32 3
  %key_len = getelementptr inbounds %struct.raxIterator, ptr %ri, i64 0, i32 4
  %key = getelementptr inbounds %struct.raxIterator, ptr %ri, i64 0, i32 2
  br label %while.body564

while.body564:                                    ; preds = %while.body564.lr.ph, %if.end572
  %info.27382 = phi ptr [ %call559, %while.body564.lr.ph ], [ %call568340, %if.end572 ]
  %254 = load ptr, ptr %data, align 8
  %255 = load i64, ptr %key_len, align 8
  %conv565 = trunc i64 %255 to i32
  %256 = load ptr, ptr %key, align 8
  %call.i244 = call ptr @mempbrk(ptr noundef %256, i64 noundef %255, ptr noundef nonnull @unsafe_info_chars, i64 noundef 4) #38
  %cmp.i245 = icmp eq ptr %call.i244, null
  br i1 %cmp.i245, label %getSafeInfoString.exit.thread, label %if.then571

getSafeInfoString.exit.thread:                    ; preds = %while.body564
  %257 = load i64, ptr %254, align 8
  %call568338 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.27382, ptr noundef nonnull @.str.389, i32 noundef %conv565, ptr noundef %256, i64 noundef %257) #38
  br label %if.end572

if.then571:                                       ; preds = %while.body564
  %add.i246 = add i64 %255, 1
  %call1.i = call noalias ptr @zmalloc(i64 noundef %add.i246) #42
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %call1.i, ptr align 1 %256, i64 %255, i1 false)
  %arrayidx.i247 = getelementptr inbounds i8, ptr %call1.i, i64 %255
  store i8 0, ptr %arrayidx.i247, align 1
  %call2.i = call ptr @memmapchars(ptr noundef %call1.i, i64 noundef %255, ptr noundef nonnull @unsafe_info_chars, ptr noundef nonnull @unsafe_info_chars_substs, i64 noundef 4) #38
  %258 = load i64, ptr %254, align 8
  %call568 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.27382, ptr noundef nonnull @.str.389, i32 noundef %conv565, ptr noundef %call2.i, i64 noundef %258) #38
  call void @zfree(ptr noundef nonnull %call1.i) #38
  br label %if.end572

if.end572:                                        ; preds = %getSafeInfoString.exit.thread, %if.then571
  %call568340 = phi ptr [ %call568338, %getSafeInfoString.exit.thread ], [ %call568, %if.then571 ]
  %call562 = call i32 @raxNext(ptr noundef nonnull %ri) #38
  %tobool563.not = icmp eq i32 %call562, 0
  br i1 %tobool563.not, label %if.end574, label %while.body564, !llvm.loop !73

if.end574:                                        ; preds = %if.end572, %if.end558
  %info.27.lcssa = phi ptr [ %call559, %if.end558 ], [ %call568340, %if.end572 ]
  call void @raxStop(ptr noundef nonnull %ri) #38
  br i1 %tobool1.not, label %lor.lhs.false576, label %if.then580

lor.lhs.false576:                                 ; preds = %lor.lhs.false549, %if.end574
  %info.28346 = phi ptr [ %info.27.lcssa, %if.end574 ], [ %info.25335, %lor.lhs.false549 ]
  %sections.9344 = phi i32 [ %inc554, %if.end574 ], [ %sections.8333, %lor.lhs.false549 ]
  %call577 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.390) #38
  %cmp578.not = icmp eq ptr %call577, null
  br i1 %cmp578.not, label %lor.lhs.false593, label %if.then580

if.then580:                                       ; preds = %lor.lhs.false576, %if.end574
  %info.28345 = phi ptr [ %info.28346, %lor.lhs.false576 ], [ %info.27.lcssa, %if.end574 ]
  %sections.9343 = phi i32 [ %sections.9344, %lor.lhs.false576 ], [ %inc554, %if.end574 ]
  %inc581 = add nsw i32 %sections.9343, 1
  %tobool582.not = icmp eq i32 %sections.9343, 0
  br i1 %tobool582.not, label %if.end585, label %if.then583

if.then583:                                       ; preds = %if.then580
  %call584 = call ptr @sdscat(ptr noundef %info.28345, ptr noundef nonnull @.str.170) #38
  br label %if.end585

if.end585:                                        ; preds = %if.then583, %if.then580
  %info.29 = phi ptr [ %call584, %if.then583 ], [ %info.28345, %if.then580 ]
  %call586 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.29, ptr noundef nonnull @.str.391) #38
  %259 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 181), align 4
  %tobool587.not = icmp eq i32 %259, 0
  br i1 %tobool587.not, label %if.end591, label %if.then588

if.then588:                                       ; preds = %if.end585
  %260 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 12), align 8
  %call589 = call ptr @genRedisInfoStringLatencyStats(ptr noundef %call586, ptr noundef %260)
  br label %if.end591

if.end591:                                        ; preds = %if.end585, %if.then588
  %info.30 = phi ptr [ %call589, %if.then588 ], [ %call586, %if.end585 ]
  br i1 %tobool1.not, label %lor.lhs.false593, label %if.then597

lor.lhs.false593:                                 ; preds = %lor.lhs.false576, %if.end591
  %info.30352 = phi ptr [ %info.30, %if.end591 ], [ %info.28346, %lor.lhs.false576 ]
  %sections.10350 = phi i32 [ %inc581, %if.end591 ], [ %sections.9344, %lor.lhs.false576 ]
  %call594 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.345) #38
  %cmp595.not = icmp eq ptr %call594, null
  br i1 %cmp595.not, label %lor.lhs.false606, label %if.then597

if.then597:                                       ; preds = %lor.lhs.false593, %if.end591
  %info.30351 = phi ptr [ %info.30352, %lor.lhs.false593 ], [ %info.30, %if.end591 ]
  %sections.10349 = phi i32 [ %sections.10350, %lor.lhs.false593 ], [ %inc581, %if.end591 ]
  %inc598 = add nsw i32 %sections.10349, 1
  %tobool599.not = icmp eq i32 %sections.10349, 0
  br i1 %tobool599.not, label %if.end604, label %if.then600

if.then600:                                       ; preds = %if.then597
  %call601 = call ptr @sdscat(ptr noundef %info.30351, ptr noundef nonnull @.str.170) #38
  br label %if.end604

if.end604:                                        ; preds = %if.then597, %if.then600
  %info.31 = phi ptr [ %call601, %if.then600 ], [ %info.30351, %if.then597 ]
  %261 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %call603 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.31, ptr noundef nonnull @.str.392, i32 noundef %261) #38
  br i1 %tobool1.not, label %lor.lhs.false606, label %if.then610

lor.lhs.false606:                                 ; preds = %lor.lhs.false593, %if.end604
  %info.32358 = phi ptr [ %call603, %if.end604 ], [ %info.30352, %lor.lhs.false593 ]
  %sections.11356 = phi i32 [ %inc598, %if.end604 ], [ %sections.10350, %lor.lhs.false593 ]
  %call607 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.346) #38
  %cmp608.not = icmp eq ptr %call607, null
  br i1 %cmp608.not, label %if.end633, label %if.then610

if.then610:                                       ; preds = %lor.lhs.false606, %if.end604
  %info.32357 = phi ptr [ %info.32358, %lor.lhs.false606 ], [ %call603, %if.end604 ]
  %sections.11355 = phi i32 [ %sections.11356, %lor.lhs.false606 ], [ %inc598, %if.end604 ]
  %inc611 = add nsw i32 %sections.11355, 1
  %tobool612.not = icmp eq i32 %sections.11355, 0
  br i1 %tobool612.not, label %if.end615, label %if.then613

if.then613:                                       ; preds = %if.then610
  %call614 = call ptr @sdscat(ptr noundef %info.32357, ptr noundef nonnull @.str.170) #38
  br label %if.end615

if.end615:                                        ; preds = %if.then613, %if.then610
  %info.33 = phi ptr [ %call614, %if.then613 ], [ %info.32357, %if.then610 ]
  %call616 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.33, ptr noundef nonnull @.str.393) #38
  %262 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %cmp617384 = icmp sgt i32 %262, 0
  br i1 %cmp617384, label %for.body, label %if.end633

for.body:                                         ; preds = %if.end615, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %if.end615 ]
  %info.34386 = phi ptr [ %info.35, %for.inc ], [ %call616, %if.end615 ]
  %263 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %arrayidx619 = getelementptr inbounds %struct.redisDb, ptr %263, i64 %indvars.iv
  %call620 = call i64 @dbSize(ptr noundef %arrayidx619, i32 noundef 0) #38
  %264 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %arrayidx622 = getelementptr inbounds %struct.redisDb, ptr %264, i64 %indvars.iv
  %call623 = call i64 @dbSize(ptr noundef %arrayidx622, i32 noundef 1) #38
  %tobool624 = icmp ne i64 %call620, 0
  %tobool626 = icmp ne i64 %call623, 0
  %or.cond1 = select i1 %tobool624, i1 true, i1 %tobool626
  br i1 %or.cond1, label %if.then627, label %for.inc

if.then627:                                       ; preds = %for.body
  %265 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %avg_ttl = getelementptr inbounds %struct.redisDb, ptr %265, i64 %indvars.iv, i32 7
  %266 = load i64, ptr %avg_ttl, align 8
  %267 = trunc i64 %indvars.iv to i32
  %call630 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.34386, ptr noundef nonnull @.str.394, i32 noundef %267, i64 noundef %call620, i64 noundef %call623, i64 noundef %266) #38
  br label %for.inc

for.inc:                                          ; preds = %if.then627, %for.body
  %info.35 = phi ptr [ %call630, %if.then627 ], [ %info.34386, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %268 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %269 = sext i32 %268 to i64
  %cmp617 = icmp slt i64 %indvars.iv.next, %269
  br i1 %cmp617, label %for.body, label %if.end633, !llvm.loop !74

if.end633:                                        ; preds = %for.inc, %if.end615, %lor.lhs.false606
  %sections.12 = phi i32 [ %sections.11356, %lor.lhs.false606 ], [ %inc611, %if.end615 ], [ %inc611, %for.inc ]
  %info.36 = phi ptr [ %info.32358, %lor.lhs.false606 ], [ %call616, %if.end615 ], [ %info.35, %for.inc ]
  br i1 %tobool.not, label %lor.lhs.false635, label %cond.end665

lor.lhs.false635:                                 ; preds = %if.end633
  %call636 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.383) #38
  %cmp637.not = icmp eq ptr %call636, null
  br i1 %cmp637.not, label %lor.lhs.false639, label %lor.lhs.false659

lor.lhs.false639:                                 ; preds = %lor.lhs.false635
  %ht_used640 = getelementptr inbounds %struct.dict, ptr %section_dict, i64 0, i32 2
  %270 = load i64, ptr %ht_used640, align 8
  %arrayidx643 = getelementptr inbounds %struct.dict, ptr %section_dict, i64 0, i32 2, i64 1
  %271 = load i64, ptr %arrayidx643, align 8
  %add644 = add i64 %271, %270
  %conv645 = trunc i64 %add644 to i32
  %cmp646 = icmp sge i32 %sections.12, %conv645
  %tobool656.not = icmp eq i64 %add644, 0
  %or.cond174 = or i1 %tobool1.not, %tobool656.not
  %or.cond177 = and i1 %cmp646, %or.cond174
  br i1 %or.cond177, label %if.end668, label %lor.lhs.false659

lor.lhs.false659:                                 ; preds = %lor.lhs.false635, %lor.lhs.false639
  %call660 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.383) #38
  %cmp661.not = icmp eq ptr %call660, null
  %spec.select = select i1 %cmp661.not, ptr %section_dict, ptr null
  br label %cond.end665

cond.end665:                                      ; preds = %if.end633, %lor.lhs.false659
  %cond666 = phi ptr [ %spec.select, %lor.lhs.false659 ], [ null, %if.end633 ]
  %call667 = call ptr @modulesCollectInfo(ptr noundef %info.36, ptr noundef %cond666, i32 noundef 0, i32 noundef %sections.12) #38
  br label %if.end668

if.end668:                                        ; preds = %lor.lhs.false639, %cond.end665
  %info.37 = phi ptr [ %call667, %cond.end665 ], [ %info.36, %lor.lhs.false639 ]
  %call669 = call ptr @dictFind(ptr noundef %section_dict, ptr noundef nonnull @.str.395) #38
  %cmp670.not = icmp eq ptr %call669, null
  br i1 %cmp670.not, label %if.end679, label %if.then672

if.then672:                                       ; preds = %if.end668
  %tobool674.not = icmp eq i32 %sections.12, 0
  br i1 %tobool674.not, label %if.end677, label %if.then675

if.then675:                                       ; preds = %if.then672
  %call676 = call ptr @sdscat(ptr noundef %info.37, ptr noundef nonnull @.str.170) #38
  br label %if.end677

if.end677:                                        ; preds = %if.then675, %if.then672
  %info.38 = phi ptr [ %call676, %if.then675 ], [ %info.37, %if.then672 ]
  %272 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155, i64 2, i32 1), align 8
  %273 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155, i64 3, i32 1), align 8
  %274 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 155, i64 0, i32 2), align 8
  %275 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 153), align 8
  %call678 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.38, ptr noundef nonnull @.str.396, i64 noundef %272, i64 noundef %273, i64 noundef %274, i64 noundef %275) #38
  br label %if.end679

if.end679:                                        ; preds = %if.end677, %if.end668
  %info.39 = phi ptr [ %call678, %if.end677 ], [ %info.37, %if.end668 ]
  ret ptr %info.39
}

declare ptr @dictFind(ptr noundef, ptr noundef) local_unnamed_addr #4

declare ptr @sdscat(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nofree nounwind
declare noundef i32 @uname(ptr nocapture noundef) local_unnamed_addr #2

declare ptr @redisGitSHA1() local_unnamed_addr #4

; Function Attrs: mustprogress nofree nounwind willreturn
declare i64 @strtol(ptr noundef readonly, ptr nocapture noundef, i32 noundef) local_unnamed_addr #29

declare ptr @redisGitDirty() local_unnamed_addr #4

declare ptr @redisBuildIdString() local_unnamed_addr #4

declare ptr @monotonicInfoString() local_unnamed_addr #4

declare ptr @aeGetApiName() local_unnamed_addr #4

declare ptr @getListensInfoString(ptr noundef) local_unnamed_addr #4

declare void @totalNumberOfBlockingKeys(ptr noundef, ptr noundef) local_unnamed_addr #4

declare i64 @getClusterConnectionsCount() local_unnamed_addr #4

declare i64 @raxSize(ptr noundef) local_unnamed_addr #4

declare ptr @evictPolicyToString() local_unnamed_addr #4

declare i64 @functionsMemory() local_unnamed_addr #4

declare ptr @getMemoryOverheadData() local_unnamed_addr #4

declare ptr @evalScriptsDict() local_unnamed_addr #4

declare i64 @functionsNum() local_unnamed_addr #4

declare i64 @functionsLibNum() local_unnamed_addr #4

declare i64 @freeMemoryGetNotCountedMemory() local_unnamed_addr #4

declare i64 @lazyfreeGetPendingObjectsCount() local_unnamed_addr #4

declare i64 @lazyfreeGetFreedObjectsCount() local_unnamed_addr #4

declare void @freeMemoryOverheadData(ptr noundef) local_unnamed_addr #4

declare i64 @bioPendingJobsOfType(i32 noundef) local_unnamed_addr #4

declare i64 @getSlaveKeyWithExpireCount() local_unnamed_addr #4

declare i64 @trackingGetTotalKeys() local_unnamed_addr #4

declare i64 @trackingGetTotalItems() local_unnamed_addr #4

declare i64 @trackingGetTotalPrefixes() local_unnamed_addr #4

declare ptr @getFailoverStateString() local_unnamed_addr #4

; Function Attrs: nounwind
declare i32 @getrusage(i32 noundef, ptr noundef) local_unnamed_addr #3

declare ptr @genModulesInfoString(ptr noundef) local_unnamed_addr #4

declare void @raxStart(ptr noundef, ptr noundef) local_unnamed_addr #4

declare i32 @raxSeek(ptr noundef, ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

declare i32 @raxNext(ptr noundef) local_unnamed_addr #4

declare void @raxStop(ptr noundef) local_unnamed_addr #4

declare ptr @modulesCollectInfo(ptr noundef, ptr noundef, i32 noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @infoCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %all_sections = alloca i32, align 4
  %everything = alloca i32, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @sentinelInfoCommand(ptr noundef %c) #38
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %all_sections, align 4
  store i32 0, ptr %everything, align 4
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %1 = load ptr, ptr %argv, align 8
  %add.ptr = getelementptr inbounds ptr, ptr %1, i64 1
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %2 = load i32, ptr %argc, align 8
  %sub = add nsw i32 %2, -1
  %call = call ptr @genInfoSectionDict(ptr noundef nonnull %add.ptr, i32 noundef %sub, ptr noundef null, ptr noundef nonnull %all_sections, ptr noundef nonnull %everything)
  %3 = load i32, ptr %all_sections, align 4
  %4 = load i32, ptr %everything, align 4
  %call1 = call ptr @genRedisInfoString(ptr noundef %call, i32 noundef %3, i32 noundef %4)
  %arrayidx.i = getelementptr inbounds i8, ptr %call1, i64 -1
  %5 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %5 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end
  %add.ptr.i = getelementptr inbounds i8, ptr %call1, i64 -3
  %6 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %6 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end
  %add.ptr6.i = getelementptr inbounds i8, ptr %call1, i64 -5
  %7 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %7 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end
  %add.ptr10.i = getelementptr inbounds i8, ptr %call1, i64 -9
  %8 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %8 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end
  %add.ptr14.i = getelementptr inbounds i8, ptr %call1, i64 -17
  %9 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %9, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end ]
  call void @addReplyVerbatim(ptr noundef nonnull %c, ptr noundef nonnull %call1, i64 noundef %retval.0.i, ptr noundef nonnull @.str.397) #38
  call void @sdsfree(ptr noundef nonnull %call1) #38
  %10 = load ptr, ptr @cached_default_info_sections, align 8
  %cmp.not.i = icmp eq ptr %10, %call
  br i1 %cmp.not.i, label %return, label %if.then.i

if.then.i:                                        ; preds = %sdslen.exit
  call void @dictRelease(ptr noundef %call) #38
  br label %return

return:                                           ; preds = %if.then.i, %sdslen.exit, %if.then
  ret void
}

declare void @sentinelInfoCommand(ptr noundef) local_unnamed_addr #4

declare void @addReplyVerbatim(ptr noundef, ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @monitorCommand(ptr noundef %c) local_unnamed_addr #0 {
entry:
  %flags = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 1
  %0 = load i64, ptr %flags, align 8
  %and = and i64 %0, 2199023255552
  %tobool.not = icmp eq i64 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.398) #38
  br label %return

if.end:                                           ; preds = %entry
  %and2 = and i64 %0, 1
  %tobool3.not = icmp eq i64 %and2, 0
  br i1 %tobool3.not, label %if.end5, label %return

if.end5:                                          ; preds = %if.end
  %or = or i64 %0, 5
  store i64 %or, ptr %flags, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 60), align 8
  %call = tail call ptr @listAddNodeTail(ptr noundef %1, ptr noundef nonnull %c) #38
  %2 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %2) #38
  br label %return

return:                                           ; preds = %if.end, %if.end5, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @checkIgnoreWarning(ptr nocapture noundef readonly %warning) local_unnamed_addr #0 {
entry:
  %argc = alloca i32, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 33), align 8
  %call = call ptr @sdssplitargs(ptr noundef %0, ptr noundef nonnull %argc) #38
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %return, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %1 = load i32, ptr %argc, align 4
  %cmp16 = icmp sgt i32 %1, 0
  br i1 %cmp16, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %for.cond.preheader
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @strcasecmp(ptr noundef %2, ptr noundef %warning) #39
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %for.end.loopexit.split.loop.exit, label %for.inc

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !75

for.end.loopexit.split.loop.exit:                 ; preds = %for.body
  %3 = trunc i64 %indvars.iv to i32
  br label %for.end

for.end:                                          ; preds = %for.inc, %for.end.loopexit.split.loop.exit, %for.cond.preheader
  %j.0.lcssa = phi i32 [ 0, %for.cond.preheader ], [ %3, %for.end.loopexit.split.loop.exit ], [ %1, %for.inc ]
  call void @sdsfreesplitres(ptr noundef nonnull %call, i32 noundef %1) #38
  %4 = load i32, ptr %argc, align 4
  %cmp5 = icmp slt i32 %j.0.lcssa, %4
  %conv = zext i1 %cmp5 to i32
  br label %return

return:                                           ; preds = %entry, %for.end
  %retval.0 = phi i32 [ %conv, %for.end ], [ 0, %entry ]
  ret i32 %retval.0
}

declare ptr @sdssplitargs(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @linuxMemoryWarnings() local_unnamed_addr #0 {
entry:
  %err_msg = alloca ptr, align 8
  store ptr null, ptr %err_msg, align 8
  %call = call i32 @checkOvercommit(ptr noundef nonnull %err_msg) #38
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %do.body, label %if.end3

do.body:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %0, 3
  br i1 %cmp1, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %1 = load ptr, ptr %err_msg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.399, ptr noundef %1)
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  %2 = load ptr, ptr %err_msg, align 8
  call void @sdsfree(ptr noundef %2) #38
  br label %if.end3

if.end3:                                          ; preds = %do.end, %entry
  %call4 = call i32 @checkTHPEnabled(ptr noundef nonnull %err_msg) #38
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end16

if.then6:                                         ; preds = %if.end3
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 35), align 4
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 324), align 8
  %tobool.not.i = icmp eq i32 %3, 0
  br i1 %tobool.not.i, label %do.body10, label %THPDisable.exit

THPDisable.exit:                                  ; preds = %if.then6
  %call.i = call i32 (i32, ...) @prctl(i32 noundef 41, i32 noundef 1, i32 noundef 0, i32 noundef 0, i32 noundef 0) #38
  %cmp8 = icmp eq i32 %call.i, 0
  br i1 %cmp8, label %if.then9, label %do.body10

if.then9:                                         ; preds = %THPDisable.exit
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 35), align 4
  br label %if.end15

do.body10:                                        ; preds = %if.then6, %THPDisable.exit
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp11 = icmp sgt i32 %4, 3
  br i1 %cmp11, label %if.end15, label %if.end13

if.end13:                                         ; preds = %do.body10
  %5 = load ptr, ptr %err_msg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.399, ptr noundef %5)
  br label %if.end15

if.end15:                                         ; preds = %if.end13, %do.body10, %if.then9
  %6 = load ptr, ptr %err_msg, align 8
  call void @sdsfree(ptr noundef %6) #38
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.end3
  ret void
}

declare i32 @checkOvercommit(ptr noundef) local_unnamed_addr #4

declare i32 @checkTHPEnabled(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @createPidFile() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 23), align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call noalias ptr @zstrdup(ptr noundef nonnull @.str.400) #38
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 23), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = phi ptr [ %call, %if.then ], [ %0, %entry ]
  %call1 = tail call noalias ptr @fopen64(ptr noundef %1, ptr noundef nonnull @.str.401)
  %tobool2.not = icmp eq ptr %call1, null
  br i1 %tobool2.not, label %do.body, label %if.then3

if.then3:                                         ; preds = %if.end
  %call4 = tail call i32 @getpid() #38
  %call5 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef nonnull %call1, ptr noundef nonnull @.str.132, i32 noundef %call4)
  %call6 = tail call i32 @fclose(ptr noundef nonnull %call1)
  br label %if.end11

do.body:                                          ; preds = %if.end
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %2, 3
  br i1 %cmp, label %if.end11, label %if.end8

if.end8:                                          ; preds = %do.body
  %call9 = tail call ptr @__errno_location() #41
  %3 = load i32, ptr %call9, align 4
  %call10 = tail call ptr @strerror(i32 noundef %3) #38
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.402, ptr noundef %call10)
  br label %if.end11

if.end11:                                         ; preds = %if.end8, %do.body, %if.then3
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @daemonize() local_unnamed_addr #0 {
entry:
  %call = tail call i32 @fork() #38
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @exit(i32 noundef 0) #40
  unreachable

if.end:                                           ; preds = %entry
  %call1 = tail call i32 @setsid() #38
  %call2 = tail call i32 (ptr, i32, ...) @open64(ptr noundef nonnull @.str.403, i32 noundef 2, i32 noundef 0) #38
  %cmp3.not = icmp eq i32 %call2, -1
  br i1 %cmp3.not, label %if.end12, label %if.then4

if.then4:                                         ; preds = %if.end
  %call5 = tail call i32 @dup2(i32 noundef %call2, i32 noundef 0) #38
  %call6 = tail call i32 @dup2(i32 noundef %call2, i32 noundef 1) #38
  %call7 = tail call i32 @dup2(i32 noundef %call2, i32 noundef 2) #38
  %cmp8 = icmp sgt i32 %call2, 2
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.then4
  %call10 = tail call i32 @close(i32 noundef %call2) #38
  br label %if.end12

if.end12:                                         ; preds = %if.then4, %if.then9, %if.end
  ret void
}

; Function Attrs: nofree nounwind
declare i32 @fork() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @setsid() local_unnamed_addr #3

; Function Attrs: nounwind
declare i32 @dup2(i32 noundef, i32 noundef) local_unnamed_addr #3

; Function Attrs: noreturn nounwind uwtable
define dso_local void @version() local_unnamed_addr #10 {
entry:
  %call = tail call ptr @redisGitSHA1() #38
  %call1 = tail call ptr @redisGitDirty() #38
  %call2 = tail call i32 @atoi(ptr nocapture noundef %call1) #39
  %cmp = icmp sgt i32 %call2, 0
  %conv = zext i1 %cmp to i32
  %call3 = tail call i64 @redisBuildId() #38
  %call4 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.404, ptr noundef nonnull @.str.355, ptr noundef %call, i32 noundef %conv, ptr noundef nonnull @.str.361, i32 noundef 64, i64 noundef %call3)
  tail call void @exit(i32 noundef 0) #40
  unreachable
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

declare i64 @redisBuildId() local_unnamed_addr #4

; Function Attrs: noreturn nounwind uwtable
define dso_local void @usage() local_unnamed_addr #10 {
entry:
  %0 = load ptr, ptr @stderr, align 8
  %1 = tail call i64 @fwrite(ptr nonnull @.str.405, i64 58, i64 1, ptr %0) #44
  %2 = load ptr, ptr @stderr, align 8
  %3 = tail call i64 @fwrite(ptr nonnull @.str.406, i64 49, i64 1, ptr %2) #44
  %4 = load ptr, ptr @stderr, align 8
  %5 = tail call i64 @fwrite(ptr nonnull @.str.407, i64 38, i64 1, ptr %4) #44
  %6 = load ptr, ptr @stderr, align 8
  %7 = tail call i64 @fwrite(ptr nonnull @.str.408, i64 35, i64 1, ptr %6) #44
  %8 = load ptr, ptr @stderr, align 8
  %9 = tail call i64 @fwrite(ptr nonnull @.str.409, i64 48, i64 1, ptr %8) #44
  %10 = load ptr, ptr @stderr, align 8
  %11 = tail call i64 @fwrite(ptr nonnull @.str.410, i64 37, i64 1, ptr %10) #44
  %12 = load ptr, ptr @stderr, align 8
  %fputc = tail call i32 @fputc(i32 10, ptr %12)
  %13 = load ptr, ptr @stderr, align 8
  %14 = tail call i64 @fwrite(ptr nonnull @.str.411, i64 10, i64 1, ptr %13) #44
  %15 = load ptr, ptr @stderr, align 8
  %16 = tail call i64 @fwrite(ptr nonnull @.str.412, i64 57, i64 1, ptr %15) #44
  %17 = load ptr, ptr @stderr, align 8
  %18 = tail call i64 @fwrite(ptr nonnull @.str.413, i64 49, i64 1, ptr %17) #44
  %19 = load ptr, ptr @stderr, align 8
  %20 = tail call i64 @fwrite(ptr nonnull @.str.414, i64 43, i64 1, ptr %19) #44
  %21 = load ptr, ptr @stderr, align 8
  %22 = tail call i64 @fwrite(ptr nonnull @.str.415, i64 34, i64 1, ptr %21) #44
  %23 = load ptr, ptr @stderr, align 8
  %24 = tail call i64 @fwrite(ptr nonnull @.str.416, i64 61, i64 1, ptr %23) #44
  %25 = load ptr, ptr @stderr, align 8
  %26 = tail call i64 @fwrite(ptr nonnull @.str.417, i64 61, i64 1, ptr %25) #44
  %27 = load ptr, ptr @stderr, align 8
  %28 = tail call i64 @fwrite(ptr nonnull @.str.418, i64 60, i64 1, ptr %27) #44
  %29 = load ptr, ptr @stderr, align 8
  %30 = tail call i64 @fwrite(ptr nonnull @.str.419, i64 15, i64 1, ptr %29) #44
  %31 = load ptr, ptr @stderr, align 8
  %32 = tail call i64 @fwrite(ptr nonnull @.str.420, i64 52, i64 1, ptr %31) #44
  tail call void @exit(i32 noundef 1) #40
  unreachable
}

; Function Attrs: nounwind uwtable
define dso_local void @redisAsciiArt() local_unnamed_addr #0 {
entry:
  %call = tail call noalias dereferenceable_or_null(16384) ptr @zmalloc(i64 noundef 16384) #42
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool1.not = icmp eq i32 %1, 0
  %.str.350..str.349 = select i1 %tobool1.not, ptr @.str.350, ptr @.str.349
  %mode.0 = select i1 %tobool.not, ptr %.str.350..str.349, ptr @.str.345
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 251), align 8
  %tobool5.not = icmp eq i32 %2, 0
  br i1 %tobool5.not, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 250), align 8
  %4 = load i8, ptr %3, align 1
  %cmp = icmp eq i8 %4, 0
  br i1 %cmp, label %land.lhs.true7, label %lor.rhs

land.lhs.true7:                                   ; preds = %land.lhs.true
  %5 = load ptr, ptr @stdout, align 8
  %call8 = tail call i32 @fileno(ptr noundef %5) #38
  %call9 = tail call i32 @isatty(i32 noundef %call8) #38
  %tobool10.not = icmp ne i32 %call9, 0
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 29), align 8
  %tobool11 = icmp ne i32 %6, 0
  %or.cond = select i1 %tobool10.not, i1 true, i1 %tobool11
  br i1 %or.cond, label %if.else19, label %do.body

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %.old = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 29), align 8
  %tobool11.old.not = icmp eq i32 %.old, 0
  br i1 %tobool11.old.not, label %do.body, label %if.else19

do.body:                                          ; preds = %land.lhs.true7, %lor.rhs
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp14 = icmp sgt i32 %7, 2
  br i1 %cmp14, label %if.end33, label %if.end17

if.end17:                                         ; preds = %do.body
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %tobool18.not = icmp eq i32 %8, 0
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %cond = select i1 %tobool18.not, i32 %9, i32 %8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.422, ptr noundef nonnull %mode.0, i32 noundef %cond)
  br label %if.end33

if.else19:                                        ; preds = %land.lhs.true7, %lor.rhs
  %call20 = tail call ptr @redisGitSHA1() #38
  %call21 = tail call ptr @redisGitDirty() #38
  %call22 = tail call i64 @strtol(ptr nocapture noundef %call21, ptr noundef null, i32 noundef 10) #38
  %cmp23 = icmp sgt i64 %call22, 0
  %conv24 = zext i1 %cmp23 to i32
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %tobool25.not = icmp eq i32 %10, 0
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %cond29 = select i1 %tobool25.not, i32 %11, i32 %10
  %call30 = tail call i32 @getpid() #38
  %conv31 = sext i32 %call30 to i64
  %call32 = tail call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef nonnull dereferenceable(1) %call, i64 noundef 16384, ptr noundef nonnull @.str.421, ptr noundef nonnull @.str.355, ptr noundef %call20, i32 noundef %conv24, ptr noundef nonnull @.str.423, ptr noundef nonnull %mode.0, i32 noundef %cond29, i64 noundef %conv31) #38
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 250), align 8
  %13 = load i8, ptr %12, align 1
  %cmp.i = icmp eq i8 %13, 0
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3.i = icmp sgt i32 %14, 2
  br i1 %cmp3.i, label %if.end33, label %if.end.i

if.end.i:                                         ; preds = %if.else19
  br i1 %cmp.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %if.end.i
  %15 = load ptr, ptr @stdout, align 8
  br label %cond.end.i

cond.false.i:                                     ; preds = %if.end.i
  %call.i = tail call noalias ptr @fopen64(ptr noundef nonnull %12, ptr noundef nonnull @.str.1)
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %15, %cond.true.i ], [ %call.i, %cond.false.i ]
  %tobool5.not.i = icmp eq ptr %cond.i, null
  br i1 %tobool5.not.i, label %if.end33, label %if.end7.i

if.end7.i:                                        ; preds = %cond.end.i
  %fputs.i = tail call i32 @fputs(ptr %call, ptr nonnull %cond.i)
  %call36.i = tail call i32 @fflush(ptr noundef nonnull %cond.i)
  br i1 %cmp.i, label %if.end40.i, label %if.then38.i

if.then38.i:                                      ; preds = %if.end7.i
  %call39.i = tail call i32 @fclose(ptr noundef nonnull %cond.i)
  br label %if.end40.i

if.end40.i:                                       ; preds = %if.then38.i, %if.end7.i
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 251), align 8
  %tobool41.not.i = icmp eq i32 %16, 0
  br i1 %tobool41.not.i, label %if.end33, label %if.then42.i

if.then42.i:                                      ; preds = %if.end40.i
  tail call void (i32, ptr, ...) @syslog(i32 noundef 5, ptr noundef nonnull @.str.2, ptr noundef %call) #38
  br label %if.end33

if.end33:                                         ; preds = %if.then42.i, %if.end40.i, %cond.end.i, %if.else19, %if.end17, %do.body
  tail call void @zfree(ptr noundef %call) #38
  ret void
}

; Function Attrs: nounwind
declare i32 @isatty(i32 noundef) local_unnamed_addr #3

; Function Attrs: nofree nounwind
declare noundef i32 @fileno(ptr nocapture noundef) local_unnamed_addr #2

; Function Attrs: nounwind uwtable
define dso_local ptr @listenerByType(ptr noundef %typename) local_unnamed_addr #0 {
entry:
  %call = tail call i32 @connectionIndexByType(ptr noundef %typename) #38
  %cmp = icmp slt i32 %call, 0
  %idxprom = zext nneg i32 %call to i64
  %arrayidx = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %idxprom
  %retval.0 = select i1 %cmp, ptr null, ptr %arrayidx
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @changeListener(ptr noundef %listener) local_unnamed_addr #0 {
entry:
  %count.i = getelementptr inbounds %struct.connListener, ptr %listener, i64 0, i32 1
  %0 = load i32, ptr %count.i, align 8
  %cmp9.i = icmp sgt i32 %0, 0
  br i1 %cmp9.i, label %for.body.i, label %closeListener.exit

for.body.i:                                       ; preds = %entry, %for.inc.i
  %1 = phi i32 [ %5, %for.inc.i ], [ %0, %entry ]
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.inc.i ], [ 0, %entry ]
  %arrayidx.i = getelementptr inbounds [16 x i32], ptr %listener, i64 0, i64 %indvars.iv.i
  %2 = load i32, ptr %arrayidx.i, align 4
  %cmp1.i = icmp eq i32 %2, -1
  br i1 %cmp1.i, label %for.inc.i, label %if.end.i

if.end.i:                                         ; preds = %for.body.i
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  tail call void @aeDeleteFileEvent(ptr noundef %3, i32 noundef %2, i32 noundef 1) #38
  %4 = load i32, ptr %arrayidx.i, align 4
  %call.i = tail call i32 @close(i32 noundef %4) #38
  %.pre.i = load i32, ptr %count.i, align 8
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.end.i, %for.body.i
  %5 = phi i32 [ %1, %for.body.i ], [ %.pre.i, %if.end.i ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %6 = sext i32 %5 to i64
  %cmp.i = icmp slt i64 %indvars.iv.next.i, %6
  br i1 %cmp.i, label %for.body.i, label %closeListener.exit, !llvm.loop !29

closeListener.exit:                               ; preds = %for.inc.i, %entry
  store i32 0, ptr %count.i, align 8
  %port = getelementptr inbounds %struct.connListener, ptr %listener, i64 0, i32 4
  %7 = load i32, ptr %port, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %if.then, label %if.end2

if.then:                                          ; preds = %closeListener.exit
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 177), align 8
  %tobool.not = icmp eq i32 %8, 0
  br i1 %tobool.not, label %return, label %if.then1

if.then1:                                         ; preds = %if.then
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 178), align 8
  %call.i.i = tail call ptr @sdstemplate(ptr noundef %11, ptr noundef nonnull @redisProcTitleGetVariable, ptr noundef %10) #38
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %return, label %expandProcTitleTemplate.exit.i

expandProcTitleTemplate.exit.i:                   ; preds = %if.then1
  %call1.i.i = tail call ptr @sdstrim(ptr noundef nonnull %call.i.i, ptr noundef nonnull @.str.40) #38
  %tobool1.not.i = icmp eq ptr %call1.i.i, null
  br i1 %tobool1.not.i, label %return, label %return.sink.split

if.end2:                                          ; preds = %closeListener.exit
  %ct.i = getelementptr inbounds %struct.connListener, ptr %listener, i64 0, i32 5
  %12 = load ptr, ptr %ct.i, align 8
  %listen.i = getelementptr inbounds %struct.ConnectionType, ptr %12, i64 0, i32 8
  %13 = load ptr, ptr %listen.i, align 8
  %call.i7 = tail call i32 %13(ptr noundef nonnull %listener) #38
  %cmp4.not = icmp eq i32 %call.i7, 0
  br i1 %cmp4.not, label %if.end6, label %return

if.end6:                                          ; preds = %if.end2
  %14 = load ptr, ptr %ct.i, align 8
  %accept_handler = getelementptr inbounds %struct.ConnectionType, ptr %14, i64 0, i32 5
  %15 = load ptr, ptr %accept_handler, align 8
  %16 = load i32, ptr %count.i, align 8
  %cmp12.i = icmp sgt i32 %16, 0
  br i1 %cmp12.i, label %for.body.i10, label %if.end12

for.body.i10:                                     ; preds = %if.end6, %for.inc8.i
  %indvars.iv.i11 = phi i64 [ %indvars.iv.next.i15, %for.inc8.i ], [ 0, %if.end6 ]
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %arrayidx.i12 = getelementptr inbounds [16 x i32], ptr %listener, i64 0, i64 %indvars.iv.i11
  %18 = load i32, ptr %arrayidx.i12, align 4
  %call.i13 = tail call i32 @aeCreateFileEvent(ptr noundef %17, i32 noundef %18, i32 noundef 1, ptr noundef %15, ptr noundef nonnull %listener) #38
  %cmp1.i14 = icmp eq i32 %call.i13, -1
  br i1 %cmp1.i14, label %for.cond2.preheader.i, label %for.inc8.i

for.cond2.preheader.i:                            ; preds = %for.body.i10
  %19 = and i64 %indvars.iv.i11, 4294967295
  %cmp314.not.i = icmp eq i64 %19, 0
  br i1 %cmp314.not.i, label %if.then9, label %for.body4.i

for.body4.i:                                      ; preds = %for.cond2.preheader.i, %for.body4.i
  %indvars.iv20.i = phi i64 [ %indvars.iv.next21.i, %for.body4.i ], [ %indvars.iv.i11, %for.cond2.preheader.i ]
  %indvars.iv.next21.i = add nsw i64 %indvars.iv20.i, -1
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  %idxprom6.i = and i64 %indvars.iv.next21.i, 4294967295
  %arrayidx7.i = getelementptr inbounds [16 x i32], ptr %listener, i64 0, i64 %idxprom6.i
  %21 = load i32, ptr %arrayidx7.i, align 4
  tail call void @aeDeleteFileEvent(ptr noundef %20, i32 noundef %21, i32 noundef 1) #38
  %22 = icmp sgt i64 %indvars.iv20.i, 1
  br i1 %22, label %for.body4.i, label %if.then9, !llvm.loop !30

for.inc8.i:                                       ; preds = %for.body.i10
  %indvars.iv.next.i15 = add nuw nsw i64 %indvars.iv.i11, 1
  %23 = load i32, ptr %count.i, align 8
  %24 = sext i32 %23 to i64
  %cmp.i16 = icmp slt i64 %indvars.iv.next.i15, %24
  br i1 %cmp.i16, label %for.body.i10, label %if.end12, !llvm.loop !31

if.then9:                                         ; preds = %for.body4.i, %for.cond2.preheader.i
  %25 = load ptr, ptr %ct.i, align 8
  %26 = load ptr, ptr %25, align 8
  %call11 = tail call ptr %26(ptr noundef null) #38
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 6350, ptr noundef nonnull @.str.424, ptr noundef %call11) #38
  tail call void @abort() #40
  unreachable

if.end12:                                         ; preds = %for.inc8.i, %if.end6
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 177), align 8
  %tobool13.not = icmp eq i32 %27, 0
  br i1 %tobool13.not, label %return, label %if.then14

if.then14:                                        ; preds = %if.end12
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 178), align 8
  %call.i.i18 = tail call ptr @sdstemplate(ptr noundef %30, ptr noundef nonnull @redisProcTitleGetVariable, ptr noundef %29) #38
  %tobool.not.i.i19 = icmp eq ptr %call.i.i18, null
  br i1 %tobool.not.i.i19, label %return, label %expandProcTitleTemplate.exit.i20

expandProcTitleTemplate.exit.i20:                 ; preds = %if.then14
  %call1.i.i21 = tail call ptr @sdstrim(ptr noundef nonnull %call.i.i18, ptr noundef nonnull @.str.40) #38
  %tobool1.not.i22 = icmp eq ptr %call1.i.i21, null
  br i1 %tobool1.not.i22, label %return, label %return.sink.split

return.sink.split:                                ; preds = %expandProcTitleTemplate.exit.i20, %expandProcTitleTemplate.exit.i
  %call1.i.i21.sink31 = phi ptr [ %call1.i.i, %expandProcTitleTemplate.exit.i ], [ %call1.i.i21, %expandProcTitleTemplate.exit.i20 ]
  tail call void (ptr, ...) @setproctitle(ptr noundef nonnull @.str.2, ptr noundef nonnull %call1.i.i21.sink31) #38
  tail call void @sdsfree(ptr noundef nonnull %call1.i.i21.sink31) #38
  br label %return

return:                                           ; preds = %return.sink.split, %expandProcTitleTemplate.exit.i20, %if.then14, %expandProcTitleTemplate.exit.i, %if.then1, %if.end12, %if.end2, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ -1, %if.end2 ], [ 0, %if.end12 ], [ 0, %if.then1 ], [ 0, %expandProcTitleTemplate.exit.i ], [ 0, %if.then14 ], [ 0, %expandProcTitleTemplate.exit.i20 ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @redisSetProcTitle(ptr noundef %title) local_unnamed_addr #0 {
entry:
  %tobool.not = icmp eq ptr %title, null
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %1 = load ptr, ptr %0, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %title.addr.0 = phi ptr [ %title, %entry ], [ %1, %if.then ]
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 178), align 8
  %call.i = tail call ptr @sdstemplate(ptr noundef %2, ptr noundef nonnull @redisProcTitleGetVariable, ptr noundef %title.addr.0) #38
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %return, label %expandProcTitleTemplate.exit

expandProcTitleTemplate.exit:                     ; preds = %if.end
  %call1.i = tail call ptr @sdstrim(ptr noundef nonnull %call.i, ptr noundef nonnull @.str.40) #38
  %tobool1.not = icmp eq ptr %call1.i, null
  br i1 %tobool1.not, label %return, label %if.end3

if.end3:                                          ; preds = %expandProcTitleTemplate.exit
  tail call void (ptr, ...) @setproctitle(ptr noundef nonnull @.str.2, ptr noundef nonnull %call1.i) #38
  tail call void @sdsfree(ptr noundef nonnull %call1.i) #38
  br label %return

return:                                           ; preds = %if.end, %expandProcTitleTemplate.exit, %if.end3
  %retval.0 = phi i32 [ 0, %if.end3 ], [ -1, %expandProcTitleTemplate.exit ], [ -1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare i32 @sigemptyset(ptr noundef) local_unnamed_addr #3

; Function Attrs: nounwind uwtable
define internal void @sigShutdownHandler(i32 noundef %sig) #0 {
entry:
  %switch.selectcmp3 = icmp eq i32 %sig, 2
  %0 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  %tobool = icmp ne i32 %0, 0
  %or.cond = and i1 %switch.selectcmp3, %tobool
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  tail call void @serverLogRawFromHandler(i32 noundef 3, ptr noundef nonnull @.str.468)
  %call = tail call i32 @getpid() #38
  tail call void @rdbRemoveTempFile(i32 noundef %call, i32 noundef 1) #38
  tail call void @exit(i32 noundef 1) #40
  unreachable

if.else:                                          ; preds = %entry
  %switch.selectcmp = icmp eq i32 %sig, 15
  %switch.select = select i1 %switch.selectcmp, ptr @.str.466, ptr @.str.467
  %switch.select4 = select i1 %switch.selectcmp3, ptr @.str.465, ptr %switch.select
  %1 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool2.not = icmp eq i32 %1, 0
  %spec.select = select i1 %tobool2.not, ptr %switch.select4, ptr @.str.469
  tail call void @serverLogRawFromHandler(i32 noundef 3, ptr noundef nonnull %spec.select)
  store volatile i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 17), align 4
  store i32 %sig, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 19), align 8
  ret void
}

; Function Attrs: nounwind
declare i32 @sigaction(i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #3

declare void @setupDebugSigHandlers() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @setupChildSignalHandlers() local_unnamed_addr #0 {
entry:
  %act = alloca %struct.sigaction, align 8
  %sa_mask = getelementptr inbounds %struct.sigaction, ptr %act, i64 0, i32 1
  %call = call i32 @sigemptyset(ptr noundef nonnull %sa_mask) #38
  %sa_flags = getelementptr inbounds %struct.sigaction, ptr %act, i64 0, i32 2
  store i32 0, ptr %sa_flags, align 8
  store ptr @sigKillChildHandler, ptr %act, align 8
  %call1 = call i32 @sigaction(i32 noundef 10, ptr noundef nonnull %act, ptr noundef null) #38
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @sigKillChildHandler(i32 %sig) #10 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %cmp = icmp eq i32 %0, 4
  %cond = select i1 %cmp, i32 1, i32 3
  tail call void @serverLogRawFromHandler(i32 noundef %cond, ptr noundef nonnull @.str.470)
  tail call void @_exit(i32 noundef 255) #40
  unreachable
}

; Function Attrs: nounwind uwtable
define dso_local void @closeChildUnusedResourceAfterFork() local_unnamed_addr #0 {
entry:
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc7.i, %entry
  %indvars.iv18.i = phi i64 [ 0, %entry ], [ %indvars.iv.next19.i, %for.inc7.i ]
  %arrayidx.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv18.i
  %ct.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv18.i, i32 5
  %0 = load ptr, ptr %ct.i, align 8
  %cmp1.i = icmp eq ptr %0, null
  br i1 %cmp1.i, label %for.inc7.i, label %for.cond2.preheader.i

for.cond2.preheader.i:                            ; preds = %for.body.i
  %count.i = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv18.i, i32 1
  %1 = load i32, ptr %count.i, align 8
  %cmp311.i = icmp sgt i32 %1, 0
  br i1 %cmp311.i, label %for.body4.i, label %for.inc7.i

for.body4.i:                                      ; preds = %for.cond2.preheader.i, %for.body4.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.body4.i ], [ 0, %for.cond2.preheader.i ]
  %arrayidx6.i = getelementptr inbounds [16 x i32], ptr %arrayidx.i, i64 0, i64 %indvars.iv.i
  %2 = load i32, ptr %arrayidx6.i, align 4
  %call.i = tail call i32 @close(i32 noundef %2) #38
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %3 = load i32, ptr %count.i, align 8
  %4 = sext i32 %3 to i64
  %cmp3.i = icmp slt i64 %indvars.iv.next.i, %4
  br i1 %cmp3.i, label %for.body4.i, label %for.inc7.i, !llvm.loop !47

for.inc7.i:                                       ; preds = %for.body4.i, %for.cond2.preheader.i, %for.body.i
  %indvars.iv.next19.i = add nuw nsw i64 %indvars.iv18.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next19.i, 8
  br i1 %exitcond.not.i, label %for.end9.i, label %for.body.i, !llvm.loop !48

for.end9.i:                                       ; preds = %for.inc7.i
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not.i = icmp ne i32 %5, 0
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 1), align 8
  %cmp1214.i = icmp sgt i32 %6, 0
  %or.cond16.i = select i1 %tobool.not.i, i1 %cmp1214.i, i1 false
  br i1 %or.cond16.i, label %for.body13.i, label %closeListeningSockets.exit

for.body13.i:                                     ; preds = %for.end9.i, %for.body13.i
  %indvars.iv21.i = phi i64 [ %indvars.iv.next22.i, %for.body13.i ], [ 0, %for.end9.i ]
  %arrayidx15.i = getelementptr inbounds [16 x i32], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54), i64 0, i64 %indvars.iv21.i
  %7 = load i32, ptr %arrayidx15.i, align 4
  %call16.i = tail call i32 @close(i32 noundef %7) #38
  %indvars.iv.next22.i = add nuw nsw i64 %indvars.iv21.i, 1
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 1), align 8
  %9 = sext i32 %8 to i64
  %cmp12.i = icmp slt i64 %indvars.iv.next22.i, %9
  br i1 %cmp12.i, label %for.body13.i, label %closeListeningSockets.exit.loopexit, !llvm.loop !49

closeListeningSockets.exit.loopexit:              ; preds = %for.body13.i
  %.pre = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  br label %closeListeningSockets.exit

closeListeningSockets.exit:                       ; preds = %closeListeningSockets.exit.loopexit, %for.end9.i
  %10 = phi i32 [ %.pre, %closeListeningSockets.exit.loopexit ], [ %5, %for.end9.i ]
  %tobool = icmp ne i32 %10, 0
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 382), align 8
  %cmp = icmp ne i32 %11, -1
  %or.cond = select i1 %tobool, i1 %cmp, i1 false
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %closeListeningSockets.exit
  %call = tail call i32 @close(i32 noundef %11) #38
  br label %if.end

if.end:                                           ; preds = %if.then, %closeListeningSockets.exit
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 23), align 8
  tail call void @zfree(ptr noundef %12) #38
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 23), align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @redisFork(i32 noundef %purpose) local_unnamed_addr #0 {
entry:
  %tv.i13 = alloca %struct.timeval, align 8
  %act.i = alloca %struct.sigaction, align 8
  %tv.i = alloca %struct.timeval, align 8
  switch i32 %purpose, label %if.end5 [
    i32 4, label %if.then
    i32 2, label %if.then
    i32 1, label %if.then
  ]

if.then:                                          ; preds = %entry, %entry, %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i.not = icmp eq i32 %0, -1
  br i1 %cmp.i.not, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  %call4 = tail call ptr @__errno_location() #41
  store i32 17, ptr %call4, align 4
  br label %return

if.end:                                           ; preds = %if.then
  tail call void @openChildInfoPipe() #38
  br label %if.end5

if.end5:                                          ; preds = %entry, %if.end
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i)
  %call.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i, ptr noundef null) #38
  %1 = load i64, ptr %tv.i, align 8
  %tv_usec.i = getelementptr inbounds %struct.timeval, ptr %tv.i, i64 0, i32 1
  %2 = load i64, ptr %tv_usec.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i)
  %call7 = tail call i32 @fork() #38
  switch i32 %call7, label %if.end22 [
    i32 0, label %if.then8
    i32 -1, label %if.then15
  ]

if.then8:                                         ; preds = %if.end5
  store i32 %purpose, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  call void @llvm.lifetime.start.p0(i64 152, ptr nonnull %act.i)
  %sa_mask.i = getelementptr inbounds %struct.sigaction, ptr %act.i, i64 0, i32 1
  %call.i8 = call i32 @sigemptyset(ptr noundef nonnull %sa_mask.i) #38
  %sa_flags.i = getelementptr inbounds %struct.sigaction, ptr %act.i, i64 0, i32 2
  store i32 0, ptr %sa_flags.i, align 8
  store ptr @sigKillChildHandler, ptr %act.i, align 8
  %call1.i = call i32 @sigaction(i32 noundef 10, ptr noundef nonnull %act.i, ptr noundef null) #38
  call void @llvm.lifetime.end.p0(i64 152, ptr nonnull %act.i)
  %call9 = call i32 @setOOMScoreAdj(i32 noundef 2), !range !16
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %cmp.not.i = icmp eq i32 %3, 0
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i.not.i = icmp ne i32 %4, -1
  %..i = zext i1 %cmp.i.not.i to i32
  %.sink.i = select i1 %cmp.not.i, i32 %..i, i32 2
  call void @dictSetResizeEnabled(i32 noundef %.sink.i) #38
  call void @dismissMemoryInChild()
  call void @closeChildUnusedResourceAfterFork()
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 246), align 4
  %cmp10.not = icmp eq i32 %5, -1
  br i1 %cmp10.not, label %return, label %if.then11

if.then11:                                        ; preds = %if.then8
  %call12 = call i32 @close(i32 noundef %5) #38
  br label %return

if.then15:                                        ; preds = %if.end5
  %call16 = tail call ptr @__errno_location() #41
  %6 = load i32, ptr %call16, align 4
  switch i32 %purpose, label %if.end20 [
    i32 4, label %if.then19
    i32 2, label %if.then19
    i32 1, label %if.then19
  ]

if.then19:                                        ; preds = %if.then15, %if.then15, %if.then15
  tail call void @closeChildInfoPipe() #38
  br label %if.end20

if.end20:                                         ; preds = %if.then15, %if.then19
  store i32 %6, ptr %call16, align 4
  br label %return

if.end22:                                         ; preds = %if.end5
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 114), align 8
  %inc = add nsw i64 %7, 1
  store i64 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 114), align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i13)
  %call.i14 = call i32 @gettimeofday(ptr noundef nonnull %tv.i13, ptr noundef null) #38
  %8 = load i64, ptr %tv.i13, align 8
  %tv_usec.i16 = getelementptr inbounds %struct.timeval, ptr %tv.i13, i64 0, i32 1
  %9 = load i64, ptr %tv_usec.i16, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i13)
  %reass.add = sub i64 %8, %1
  %reass.mul = mul i64 %reass.add, 1000000
  %add.i17 = sub i64 %9, %2
  %sub = add i64 %add.i17, %reass.mul
  store i64 %sub, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 112), align 8
  %call24 = tail call i64 @zmalloc_used_memory() #38
  %conv = uitofp i64 %call24 to double
  %mul = fmul double %conv, 1.000000e+06
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 112), align 8
  %conv25 = sitofp i64 %10 to double
  %div = fdiv double %mul, %conv25
  %div26 = fmul double %div, 0x3E10000000000000
  store double %div26, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 113), align 8
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 393), align 8
  %tobool27.not = icmp eq i64 %11, 0
  br i1 %tobool27.not, label %if.end33, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end22
  %div28 = sdiv i64 %10, 1000
  %cmp29.not = icmp slt i64 %div28, %11
  br i1 %cmp29.not, label %if.end33, label %if.then31

if.then31:                                        ; preds = %land.lhs.true
  tail call void @latencyAddSample(ptr noundef nonnull @.str.425, i64 noundef %div28) #38
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %land.lhs.true, %if.end22
  switch i32 %purpose, label %if.end38 [
    i32 4, label %if.then36
    i32 2, label %if.then36
    i32 1, label %if.then36
  ]

if.then36:                                        ; preds = %if.end33, %if.end33, %if.end33
  store i32 %call7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  store i32 %purpose, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 43), align 4
  store double 0.000000e+00, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 136), align 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 128), i8 0, i64 32, i1 false)
  %call37 = tail call i64 @dbTotalServerKeyCount() #38
  store i64 %call37, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 132), align 8
  br label %if.end38

if.end38:                                         ; preds = %if.end33, %if.then36
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 9), align 8
  %cmp.not.i22 = icmp eq i32 %12, 0
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 42), align 8
  %cmp.i.not.i23 = icmp ne i32 %13, -1
  %..i24 = zext i1 %cmp.i.not.i23 to i32
  %.sink.i25 = select i1 %cmp.not.i22, i32 %..i24, i32 2
  tail call void @dictSetResizeEnabled(i32 noundef %.sink.i25) #38
  tail call void @moduleFireServerEvent(i64 noundef 13, i32 noundef 0, ptr noundef null) #38
  br label %return

return:                                           ; preds = %if.end38, %if.then11, %if.then8, %if.end20, %if.then3
  %retval.0 = phi i32 [ -1, %if.then3 ], [ -1, %if.end20 ], [ 0, %if.then8 ], [ 0, %if.then11 ], [ %call7, %if.end38 ]
  ret i32 %retval.0
}

declare void @openChildInfoPipe() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @dismissMemoryInChild() local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 35), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %while.end7

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 280), align 8
  call void @listRewind(ptr noundef %1, ptr noundef nonnull %li) #38
  %call4 = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool1.not5 = icmp eq ptr %call4, null
  br i1 %tobool1.not5, label %while.end, label %if.end.i

if.end.i:                                         ; preds = %if.end, %dismissMemory.exit
  %call6 = phi ptr [ %call, %dismissMemory.exit ], [ %call4, %if.end ]
  %value = getelementptr inbounds %struct.listNode, ptr %call6, i64 0, i32 2
  %2 = load ptr, ptr %value, align 8
  %size = getelementptr inbounds %struct.replBufBlock, ptr %2, i64 0, i32 3
  %3 = load i64, ptr %size, align 8
  %tobool.not.i = icmp eq i64 %3, 0
  br i1 %tobool.not.i, label %if.end3.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 36), align 8
  %div3.i = lshr i64 %4, 1
  %cmp1.not.i = icmp ult i64 %div3.i, %3
  br i1 %cmp1.not.i, label %if.end3.i, label %dismissMemory.exit

if.end3.i:                                        ; preds = %land.lhs.true.i, %if.end.i
  call void @zmadvise_dontneed(ptr noundef nonnull %2) #38
  br label %dismissMemory.exit

dismissMemory.exit:                               ; preds = %land.lhs.true.i, %if.end3.i
  %call = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool1.not = icmp eq ptr %call, null
  br i1 %tobool1.not, label %while.end, label %if.end.i, !llvm.loop !76

while.end:                                        ; preds = %dismissMemory.exit, %if.end
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 55), align 8
  call void @listRewind(ptr noundef %5, ptr noundef nonnull %li) #38
  %call37 = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool4.not8 = icmp eq ptr %call37, null
  br i1 %tobool4.not8, label %while.end7, label %while.body5

while.body5:                                      ; preds = %while.end, %while.body5
  %call39 = phi ptr [ %call3, %while.body5 ], [ %call37, %while.end ]
  %value6 = getelementptr inbounds %struct.listNode, ptr %call39, i64 0, i32 2
  %6 = load ptr, ptr %value6, align 8
  call void @dismissClientMemory(ptr noundef %6)
  %call3 = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool4.not = icmp eq ptr %call3, null
  br i1 %tobool4.not, label %while.end7, label %while.body5, !llvm.loop !77

while.end7:                                       ; preds = %while.body5, %while.end, %entry
  ret void
}

declare i64 @dbTotalServerKeyCount() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @sendChildCowInfo(i32 noundef %info_type, ptr noundef %pname) local_unnamed_addr #0 {
entry:
  tail call void @sendChildInfoGeneric(i32 noundef %info_type, i64 noundef 0, double noundef -1.000000e+00, ptr noundef %pname) #38
  ret void
}

declare void @sendChildInfoGeneric(i32 noundef, i64 noundef, double noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @sendChildInfo(i32 noundef %info_type, i64 noundef %keys, ptr noundef %pname) local_unnamed_addr #0 {
entry:
  tail call void @sendChildInfoGeneric(i32 noundef %info_type, i64 noundef %keys, double noundef -1.000000e+00, ptr noundef %pname) #38
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @dismissMemory(ptr noundef %ptr, i64 noundef %size_hint) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq ptr %ptr, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tobool.not = icmp eq i64 %size_hint, 0
  br i1 %tobool.not, label %if.end3, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 36), align 8
  %div3 = lshr i64 %0, 1
  %cmp1.not = icmp ult i64 %div3, %size_hint
  br i1 %cmp1.not, label %if.end3, label %return

if.end3:                                          ; preds = %land.lhs.true, %if.end
  tail call void @zmadvise_dontneed(ptr noundef nonnull %ptr) #38
  br label %return

return:                                           ; preds = %land.lhs.true, %entry, %if.end3
  ret void
}

declare void @zmadvise_dontneed(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @dismissClientMemory(ptr nocapture noundef readonly %c) local_unnamed_addr #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %buf = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 84
  %0 = load ptr, ptr %buf, align 8
  %buf_usable_size = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 83
  %1 = load i64, ptr %buf_usable_size, align 8
  %cmp.i = icmp eq ptr %0, null
  br i1 %cmp.i, label %dismissMemory.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %tobool.not.i = icmp eq i64 %1, 0
  br i1 %tobool.not.i, label %if.end3.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 36), align 8
  %div3.i = lshr i64 %2, 1
  %cmp1.not.i = icmp ult i64 %div3.i, %1
  br i1 %cmp1.not.i, label %if.end3.i, label %dismissMemory.exit

if.end3.i:                                        ; preds = %land.lhs.true.i, %if.end.i
  tail call void @zmadvise_dontneed(ptr noundef nonnull %0) #38
  br label %dismissMemory.exit

dismissMemory.exit:                               ; preds = %entry, %land.lhs.true.i, %if.end3.i
  %querybuf = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 8
  %3 = load ptr, ptr %querybuf, align 8
  tail call void @dismissSds(ptr noundef %3) #38
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %4 = load i32, ptr %argc, align 8
  %tobool.not = icmp eq i32 %4, 0
  br i1 %tobool.not, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %dismissMemory.exit
  %argv_len_sum = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 16
  %5 = load i64, ptr %argv_len_sum, align 8
  %conv = sext i32 %4 to i64
  %div = udiv i64 %5, %conv
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 36), align 8
  %cmp.not = icmp uge i64 %div, %6
  %cmp439 = icmp sgt i32 %4, 0
  %or.cond = and i1 %cmp.not, %cmp439
  br i1 %or.cond, label %for.body.lr.ph, label %if.then8

for.body.lr.ph:                                   ; preds = %land.lhs.true
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %7 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 %indvars.iv
  %8 = load ptr, ptr %arrayidx, align 8
  tail call void @dismissObject(ptr noundef %8, i64 noundef 0) #38
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %9 = load i32, ptr %argc, align 8
  %10 = sext i32 %9 to i64
  %cmp4 = icmp slt i64 %indvars.iv.next, %10
  br i1 %cmp4, label %for.body, label %if.end, !llvm.loop !78

if.end:                                           ; preds = %for.body
  %tobool7.not = icmp eq i32 %9, 0
  br i1 %tobool7.not, label %if.end12, label %if.then8

if.then8:                                         ; preds = %land.lhs.true, %if.end
  %11 = phi i32 [ %9, %if.end ], [ %4, %land.lhs.true ]
  %argv9 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %12 = load ptr, ptr %argv9, align 8
  %cmp.i22 = icmp eq ptr %12, null
  br i1 %cmp.i22, label %if.end12, label %land.lhs.true.i25

land.lhs.true.i25:                                ; preds = %if.then8
  %conv11 = sext i32 %11 to i64
  %mul = shl nsw i64 %conv11, 3
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 36), align 8
  %div3.i26 = lshr i64 %13, 1
  %cmp1.not.i27 = icmp ult i64 %div3.i26, %mul
  br i1 %cmp1.not.i27, label %if.end3.i28, label %if.end12

if.end3.i28:                                      ; preds = %land.lhs.true.i25
  tail call void @zmadvise_dontneed(ptr noundef nonnull %12) #38
  br label %if.end12

if.end12:                                         ; preds = %dismissMemory.exit, %if.end3.i28, %land.lhs.true.i25, %if.then8, %if.end
  %reply = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 24
  %14 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.list, ptr %14, i64 0, i32 5
  %15 = load i64, ptr %len, align 8
  %tobool13.not = icmp eq i64 %15, 0
  br i1 %tobool13.not, label %if.end26, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %if.end12
  %reply_bytes = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 25
  %16 = load i64, ptr %reply_bytes, align 8
  %div17 = udiv i64 %16, %15
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 36), align 8
  %cmp18.not = icmp ult i64 %div17, %17
  br i1 %cmp18.not, label %if.end26, label %if.then20

if.then20:                                        ; preds = %land.lhs.true14
  call void @listRewind(ptr noundef nonnull %14, ptr noundef nonnull %li) #38
  %call41 = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool22.not42 = icmp eq ptr %call41, null
  br i1 %tobool22.not42, label %if.end26, label %while.body

while.body:                                       ; preds = %if.then20, %if.end25
  %call43 = phi ptr [ %call, %if.end25 ], [ %call41, %if.then20 ]
  %value = getelementptr inbounds %struct.listNode, ptr %call43, i64 0, i32 2
  %18 = load ptr, ptr %value, align 8
  %tobool23.not = icmp eq ptr %18, null
  br i1 %tobool23.not, label %if.end25, label %if.end.i31

if.end.i31:                                       ; preds = %while.body
  %19 = load i64, ptr %18, align 8
  %tobool.not.i32 = icmp eq i64 %19, 0
  br i1 %tobool.not.i32, label %if.end3.i36, label %land.lhs.true.i33

land.lhs.true.i33:                                ; preds = %if.end.i31
  %20 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 36), align 8
  %div3.i34 = lshr i64 %20, 1
  %cmp1.not.i35 = icmp ult i64 %div3.i34, %19
  br i1 %cmp1.not.i35, label %if.end3.i36, label %if.end25

if.end3.i36:                                      ; preds = %land.lhs.true.i33, %if.end.i31
  call void @zmadvise_dontneed(ptr noundef nonnull %18) #38
  br label %if.end25

if.end25:                                         ; preds = %if.end3.i36, %land.lhs.true.i33, %while.body
  %call = call ptr @listNext(ptr noundef nonnull %li) #38
  %tobool22.not = icmp eq ptr %call, null
  br i1 %tobool22.not, label %if.end26, label %while.body, !llvm.loop !79

if.end26:                                         ; preds = %if.end25, %if.then20, %land.lhs.true14, %if.end12
  ret void
}

declare void @dismissSds(ptr noundef) local_unnamed_addr #4

declare void @dismissObject(ptr noundef, i64 noundef) local_unnamed_addr #4

; Function Attrs: nofree nounwind memory(read, inaccessiblemem: none) uwtable
define dso_local noundef i32 @checkForSentinelMode(i32 noundef %argc, ptr nocapture noundef readonly %argv, ptr noundef readonly %exec_name) local_unnamed_addr #30 {
entry:
  %call = tail call ptr @strstr(ptr noundef nonnull dereferenceable(1) %exec_name, ptr noundef nonnull dereferenceable(1) @.str.426) #39
  %cmp.not = icmp eq ptr %call, null
  br i1 %cmp.not, label %for.cond.preheader, label %return

for.cond.preheader:                               ; preds = %entry
  %cmp13 = icmp sgt i32 %argc, 1
  br i1 %cmp13, label %for.body.preheader, label %return

for.body.preheader:                               ; preds = %for.cond.preheader
  %wide.trip.count = zext nneg i32 %argc to i64
  br label %for.body

for.cond:                                         ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %return, label %for.body, !llvm.loop !80

for.body:                                         ; preds = %for.body.preheader, %for.cond
  %indvars.iv = phi i64 [ 1, %for.body.preheader ], [ %indvars.iv.next, %for.cond ]
  %arrayidx = getelementptr inbounds ptr, ptr %argv, i64 %indvars.iv
  %0 = load ptr, ptr %arrayidx, align 8
  %call2 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %0, ptr noundef nonnull dereferenceable(11) @.str.427) #39
  %tobool.not = icmp eq i32 %call2, 0
  br i1 %tobool.not, label %return, label %for.cond

return:                                           ; preds = %for.body, %for.cond, %for.cond.preheader, %entry
  %retval.0 = phi i32 [ 1, %entry ], [ 0, %for.cond.preheader ], [ 1, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strstr(ptr noundef, ptr nocapture noundef) local_unnamed_addr #7

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i32 @strcmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #7

; Function Attrs: nounwind uwtable
define dso_local void @loadDataFromDisk() local_unnamed_addr #0 {
entry:
  %tv.i16 = alloca %struct.timeval, align 8
  %tv.i10 = alloca %struct.timeval, align 8
  %tv.i = alloca %struct.timeval, align 8
  %rsi = alloca %struct.rdbSaveInfo, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i)
  %call.i = call i32 @gettimeofday(ptr noundef nonnull %tv.i, ptr noundef null) #38
  %0 = load i64, ptr %tv.i, align 8
  %mul.i.neg = mul i64 %0, -1000000
  %tv_usec.i = getelementptr inbounds %struct.timeval, ptr %tv.i, i64 0, i32 1
  %1 = load i64, ptr %tv_usec.i, align 8
  %add.i.neg33 = sub i64 %mul.i.neg, %1
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i)
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp = icmp eq i32 %2, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 217), align 8
  %call1 = tail call i32 @loadAppendOnlyFiles(ptr noundef %3) #38
  %4 = add i32 %call1, -3
  %or.cond = icmp ult i32 %4, 2
  br i1 %or.cond, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  tail call void @exit(i32 noundef 1) #40
  unreachable

if.end:                                           ; preds = %if.then
  %cmp5 = icmp eq i32 %call1, 1
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp7 = icmp sgt i32 %5, 2
  %or.cond4 = select i1 %cmp5, i1 true, i1 %cmp7
  br i1 %or.cond4, label %if.end78, label %if.end9

if.end9:                                          ; preds = %if.end
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i10)
  %call.i11 = call i32 @gettimeofday(ptr noundef nonnull %tv.i10, ptr noundef null) #38
  %6 = load i64, ptr %tv.i10, align 8
  %mul.i12 = mul nsw i64 %6, 1000000
  %tv_usec.i13 = getelementptr inbounds %struct.timeval, ptr %tv.i10, i64 0, i32 1
  %7 = load i64, ptr %tv_usec.i13, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i10)
  %add.i14 = add i64 %7, %add.i.neg33
  %sub = add i64 %add.i14, %mul.i12
  %conv = sitofp i64 %sub to float
  %div = fdiv float %conv, 1.000000e+06
  %conv11 = fpext float %div to double
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.428, double noundef %conv11)
  br label %if.end78

if.else:                                          ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(64) %rsi, ptr noundef nonnull align 8 dereferenceable(64) @__const.loadDataFromDisk.rsi, i64 64, i1 false)
  %call13 = tail call ptr @__errno_location() #41
  store i32 0, ptr %call13, align 4
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.i = icmp eq i32 %8, 0
  br i1 %tobool.i, label %iAmMaster.exit, label %land.rhs.i

land.rhs.i:                                       ; preds = %if.else
  %call.i15 = tail call ptr @getMyClusterNode() #38
  %call2.i = tail call i32 @clusterNodeIsMaster(ptr noundef %call.i15) #38
  %tobool3.i.not = icmp eq i32 %call2.i, 0
  br i1 %tobool3.i.not, label %if.end16, label %if.then15

iAmMaster.exit:                                   ; preds = %if.else
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp.i = icmp eq ptr %9, null
  br i1 %cmp.i, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.rhs.i, %iAmMaster.exit
  tail call void @createReplicationBacklog() #38
  br label %if.end16

if.end16:                                         ; preds = %land.rhs.i, %if.then15, %iAmMaster.exit
  %rdb_flags.0 = phi i32 [ 8, %if.then15 ], [ 0, %iAmMaster.exit ], [ 0, %land.rhs.i ]
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 225), align 8
  %call17 = call i32 @rdbLoad(ptr noundef %10, ptr noundef nonnull %rsi, i32 noundef %rdb_flags.0) #38
  switch i32 %call17, label %do.body65 [
    i32 0, label %do.body21
    i32 1, label %if.end72
  ]

do.body21:                                        ; preds = %if.end16
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp22 = icmp sgt i32 %11, 2
  br i1 %cmp22, label %do.end31, label %if.end25

if.end25:                                         ; preds = %do.body21
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %tv.i16)
  %call.i17 = call i32 @gettimeofday(ptr noundef nonnull %tv.i16, ptr noundef null) #38
  %12 = load i64, ptr %tv.i16, align 8
  %mul.i18 = mul nsw i64 %12, 1000000
  %tv_usec.i19 = getelementptr inbounds %struct.timeval, ptr %tv.i16, i64 0, i32 1
  %13 = load i64, ptr %tv_usec.i19, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %tv.i16)
  %add.i20 = add i64 %13, %add.i.neg33
  %sub27 = add i64 %add.i20, %mul.i18
  %conv28 = sitofp i64 %sub27 to float
  %div29 = fdiv float %conv28, 1.000000e+06
  %conv30 = fpext float %div29 to double
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.429, double noundef %conv30)
  br label %do.end31

do.end31:                                         ; preds = %do.body21, %if.end25
  %repl_id_is_set = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i64 0, i32 1
  %14 = load i32, ptr %repl_id_is_set, align 4
  %tobool32 = icmp ne i32 %14, 0
  %repl_offset = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i64 0, i32 3
  %15 = load i64, ptr %repl_offset, align 8
  %cmp33 = icmp ne i64 %15, -1
  %or.cond1 = select i1 %tobool32, i1 %cmp33, i1 false
  %16 = load i32, ptr %rsi, align 8
  %cmp36 = icmp ne i32 %16, -1
  %or.cond2 = select i1 %or.cond1, i1 %cmp36, i1 false
  br i1 %or.cond2, label %if.then38, label %if.end72

if.then38:                                        ; preds = %do.end31
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.i21 = icmp eq i32 %17, 0
  br i1 %tobool.i21, label %iAmMaster.exit29, label %land.rhs.i23

land.rhs.i23:                                     ; preds = %if.then38
  %call.i24 = call ptr @getMyClusterNode() #38
  %call2.i25 = call i32 @clusterNodeIsMaster(ptr noundef %call.i24) #38
  %tobool3.i26.not = icmp eq i32 %call2.i25, 0
  br i1 %tobool3.i26.not, label %if.then41, label %if.else45

iAmMaster.exit29:                                 ; preds = %if.then38
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp.i22 = icmp eq ptr %18, null
  br i1 %cmp.i22, label %if.else45, label %if.then41

if.then41:                                        ; preds = %land.rhs.i23, %iAmMaster.exit29
  %repl_id = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i64 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 4 dereferenceable(41) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 260), ptr noundef nonnull align 8 dereferenceable(41) %repl_id, i64 41, i1 false)
  %19 = load i64, ptr %repl_offset, align 8
  store i64 %19, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  call void @replicationCacheMasterUsingMyself() #38
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 287), align 8
  %21 = load i32, ptr %rsi, align 8
  %call44 = call i32 @selectDb(ptr noundef %20, i32 noundef %21) #38
  br label %if.end78

if.else45:                                        ; preds = %land.rhs.i23, %iAmMaster.exit29
  %repl_id46 = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i64 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(41) getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 261), ptr noundef nonnull align 8 dereferenceable(41) %repl_id46, i64 41, i1 false)
  %22 = load i64, ptr %repl_offset, align 8
  %add = add nsw i64 %22, 1
  store i64 %add, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 263), align 8
  %23 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %add50 = add nsw i64 %23, %22
  store i64 %add50, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 268), align 8
  %tobool51.not = icmp eq ptr %24, null
  br i1 %tobool51.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.else45
  call void @_serverAssert(ptr noundef nonnull @.str.430, ptr noundef nonnull @.str.9, i32 noundef 6661) #38
  call void @abort() #40
  unreachable

cond.end:                                         ; preds = %if.else45
  %histlen = getelementptr inbounds %struct.replBacklog, ptr %24, i64 0, i32 3
  %25 = load i64, ptr %histlen, align 8
  %sub55 = add i64 %add50, 1
  %add56 = sub i64 %sub55, %25
  %offset = getelementptr inbounds %struct.replBacklog, ptr %24, i64 0, i32 4
  store i64 %add56, ptr %offset, align 8
  %26 = load i64, ptr %repl_offset, align 8
  call void @rebaseReplicationBuffer(i64 noundef %26) #38
  %call58 = call i64 @time(ptr noundef null) #38
  store i64 %call58, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 271), align 8
  br label %if.end78

do.body65:                                        ; preds = %if.end16
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp66 = icmp sgt i32 %27, 3
  br i1 %cmp66, label %do.end70, label %if.end69

if.end69:                                         ; preds = %do.body65
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.431)
  br label %do.end70

do.end70:                                         ; preds = %do.body65, %if.end69
  call void @exit(i32 noundef 1) #40
  unreachable

if.end72:                                         ; preds = %if.end16, %do.end31
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 268), align 8
  %tobool75.not = icmp eq ptr %28, null
  br i1 %tobool75.not, label %if.end78, label %if.then76

if.then76:                                        ; preds = %if.end72
  call void @freeReplicationBacklog() #38
  br label %if.end78

if.end78:                                         ; preds = %if.then41, %cond.end, %if.end72, %if.then76, %if.end, %if.end9
  ret void
}

declare i32 @loadAppendOnlyFiles(ptr noundef) local_unnamed_addr #4

declare void @createReplicationBacklog() local_unnamed_addr #4

declare i32 @rdbLoad(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare void @replicationCacheMasterUsingMyself() local_unnamed_addr #4

declare i32 @selectDb(ptr noundef, i32 noundef) local_unnamed_addr #4

declare void @rebaseReplicationBuffer(i64 noundef) local_unnamed_addr #4

declare void @freeReplicationBacklog() local_unnamed_addr #4

; Function Attrs: noreturn nounwind uwtable
define dso_local void @redisOutOfMemoryHandler(i64 noundef %allocation_size) #10 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %0, 3
  br i1 %cmp, label %do.end, label %if.end

if.end:                                           ; preds = %entry
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.432, i64 noundef %allocation_size)
  br label %do.end

do.end:                                           ; preds = %entry, %if.end
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.9, i32 noundef 6687, ptr noundef nonnull @.str.433, i64 noundef %allocation_size) #38
  tail call void @abort() #40
  unreachable
}

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @validateProcTitleTemplate(ptr noundef %template) local_unnamed_addr #0 {
entry:
  %call.i = tail call ptr @sdstemplate(ptr noundef %template, ptr noundef nonnull @redisProcTitleGetVariable, ptr noundef nonnull @.str.219) #38
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %return, label %expandProcTitleTemplate.exit

expandProcTitleTemplate.exit:                     ; preds = %entry
  %call1.i = tail call ptr @sdstrim(ptr noundef nonnull %call.i, ptr noundef nonnull @.str.40) #38
  %tobool.not = icmp eq ptr %call1.i, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %expandProcTitleTemplate.exit
  %arrayidx.i = getelementptr inbounds i8, ptr %call1.i, i64 -1
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit.thread [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end
  %add.ptr.i = getelementptr inbounds i8, ptr %call1.i, i64 -3
  %1 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %1 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end
  %add.ptr6.i = getelementptr inbounds i8, ptr %call1.i, i64 -5
  %2 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %2 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end
  %add.ptr10.i = getelementptr inbounds i8, ptr %call1.i, i64 -9
  %3 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %3 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end
  %add.ptr14.i = getelementptr inbounds i8, ptr %call1.i, i64 -17
  %4 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i3 = phi i64 [ %4, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %retval.0.i3.fr = freeze i64 %retval.0.i3
  %cmp = icmp eq i64 %retval.0.i3.fr, 0
  br i1 %cmp, label %sdslen.exit.thread, label %5

sdslen.exit.thread:                               ; preds = %if.end, %sdslen.exit
  br label %5

5:                                                ; preds = %sdslen.exit, %sdslen.exit.thread
  %6 = phi i32 [ 0, %sdslen.exit.thread ], [ 1, %sdslen.exit ]
  tail call void @sdsfree(ptr noundef nonnull %call1.i) #38
  br label %return

return:                                           ; preds = %entry, %expandProcTitleTemplate.exit, %5
  %retval.0 = phi i32 [ %6, %5 ], [ 0, %expandProcTitleTemplate.exit ], [ 0, %entry ]
  ret i32 %retval.0
}

declare void @setproctitle(ptr noundef, ...) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local void @redisSetCpuAffinity(ptr noundef %cpulist) local_unnamed_addr #0 {
entry:
  tail call void @setcpuaffinity(ptr noundef %cpulist) #38
  ret void
}

declare void @setcpuaffinity(ptr noundef) local_unnamed_addr #4

declare i32 @sd_notify(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @redisIsSupervised(i32 noundef %mode) local_unnamed_addr #0 {
entry:
  switch i32 %mode, label %if.end20 [
    i32 1, label %if.then
    i32 3, label %sw.bbthread-pre-split
    i32 2, label %sw.bb16
  ]

if.then:                                          ; preds = %entry
  %call = tail call ptr @getenv(ptr noundef nonnull @.str.436) #38
  %tobool.not = icmp eq ptr %call, null
  br i1 %tobool.not, label %if.else, label %do.body

do.body:                                          ; preds = %if.then
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2 = icmp sgt i32 %0, 1
  br i1 %cmp2, label %sw.bb, label %if.end

if.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.437)
  br label %sw.bbthread-pre-split

if.else:                                          ; preds = %if.then
  %call4 = tail call ptr @getenv(ptr noundef nonnull @.str.438) #38
  %tobool5.not = icmp eq ptr %call4, null
  br i1 %tobool5.not, label %if.end20, label %do.body7

do.body7:                                         ; preds = %if.else
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp8 = icmp sgt i32 %1, 1
  br i1 %cmp8, label %sw.bb16, label %if.end10

if.end10:                                         ; preds = %do.body7
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.439)
  br label %sw.bb16

sw.bbthread-pre-split:                            ; preds = %entry, %if.end
  %.pr = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  br label %sw.bb

sw.bb:                                            ; preds = %sw.bbthread-pre-split, %do.body
  %2 = phi i32 [ %.pr, %sw.bbthread-pre-split ], [ %0, %do.body ]
  %call.i = tail call ptr @getenv(ptr noundef nonnull @.str.436) #38
  %tobool.not.i = icmp eq ptr %call.i, null
  br i1 %tobool.not.i, label %do.body.i, label %do.body3.i

do.body.i:                                        ; preds = %sw.bb
  %cmp.i = icmp sgt i32 %2, 3
  br i1 %cmp.i, label %if.end20, label %if.end.i

if.end.i:                                         ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.484)
  br label %if.end20

do.body3.i:                                       ; preds = %sw.bb
  %cmp4.i = icmp sgt i32 %2, 2
  br i1 %cmp4.i, label %do.end7.i, label %if.end6.i

if.end6.i:                                        ; preds = %do.body3.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.485)
  br label %do.end7.i

do.end7.i:                                        ; preds = %if.end6.i, %do.body3.i
  %call8.i = tail call i32 @raise(i32 noundef 19) #38
  %call9.i = tail call i32 @unsetenv(ptr noundef nonnull @.str.436) #38
  br label %if.then19

sw.bb16:                                          ; preds = %entry, %if.end10, %do.body7
  %call.i.i = tail call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.486) #38
  %cmp.i.i = icmp eq i32 %call.i.i, 0
  br i1 %cmp.i.i, label %do.body.i.i, label %if.else.i.i

do.body.i.i:                                      ; preds = %sw.bb16
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i.i = icmp sgt i32 %3, 3
  br i1 %cmp1.i.i, label %if.end20, label %if.end.i.i

if.end.i.i:                                       ; preds = %do.body.i.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %if.end20

if.else.i.i:                                      ; preds = %sw.bb16
  %cmp3.i.i = icmp sgt i32 %call.i.i, -1
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i.i = icmp sgt i32 %4, 3
  %or.cond.i.i = select i1 %cmp3.i.i, i1 true, i1 %cmp6.i.i
  br i1 %or.cond.i.i, label %redisCommunicateSystemd.exit.i, label %if.end8.i.i

if.end8.i.i:                                      ; preds = %if.else.i.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i.i)
  br label %if.end20

redisCommunicateSystemd.exit.i:                   ; preds = %if.else.i.i
  %cmp.i5 = icmp slt i32 %call.i.i, 1
  br i1 %cmp.i5, label %if.end20, label %do.body.i6

do.body.i6:                                       ; preds = %redisCommunicateSystemd.exit.i
  %cmp1.i = icmp sgt i32 %4, 2
  br i1 %cmp1.i, label %if.then19, label %if.end3.i

if.end3.i:                                        ; preds = %do.body.i6
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.487)
  br label %if.then19

if.then19:                                        ; preds = %do.end7.i, %do.body.i6, %if.end3.i
  %mode.addr.09 = phi i32 [ 3, %do.end7.i ], [ 2, %do.body.i6 ], [ 2, %if.end3.i ]
  store i32 %mode.addr.09, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  br label %if.end20

if.end20:                                         ; preds = %entry, %if.else, %if.end8.i.i, %if.end.i.i, %do.body.i.i, %redisCommunicateSystemd.exit.i, %if.end.i, %do.body.i, %if.then19
  %ret.019 = phi i32 [ 1, %if.then19 ], [ 0, %do.body.i ], [ 0, %if.end.i ], [ 0, %redisCommunicateSystemd.exit.i ], [ 0, %do.body.i.i ], [ 0, %if.end.i.i ], [ 0, %if.end8.i.i ], [ 0, %if.else ], [ 0, %entry ]
  ret i32 %ret.019
}

; Function Attrs: nofree nounwind memory(read)
declare noundef ptr @getenv(ptr nocapture noundef) local_unnamed_addr #31

declare i32 @clusterNodeIsMaster(ptr noundef) local_unnamed_addr #4

declare ptr @getMyClusterNode() local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define dso_local noundef i32 @main(i32 noundef %argc, ptr noundef %argv) local_unnamed_addr #0 {
entry:
  %buf.i = alloca [1024 x i8], align 16
  %tv = alloca %struct.timeval, align 8
  %hashseed = alloca [16 x i8], align 16
  %argc_tmp = alloca i32, align 4
  %err_msg = alloca ptr, align 8
  tail call void @spt_init(i32 noundef %argc, ptr noundef %argv) #38
  tail call void @tzset() #38
  tail call void @zmalloc_set_oom_handler(ptr noundef nonnull @redisOutOfMemoryHandler) #38
  %call = call i32 @gettimeofday(ptr noundef nonnull %tv, ptr noundef null) #38
  %call1 = tail call i64 @time(ptr noundef null) #38
  %call2 = tail call i32 @getpid() #38
  %conv = zext i32 %call2 to i64
  %xor = xor i64 %call1, %conv
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i64 0, i32 1
  %0 = load i64, ptr %tv_usec, align 8
  %xor3 = xor i64 %xor, %0
  %conv4 = trunc i64 %xor3 to i32
  tail call void @srand(i32 noundef %conv4) #38
  %call5 = tail call i64 @time(ptr noundef null) #38
  %call6 = tail call i32 @getpid() #38
  %conv7 = zext i32 %call6 to i64
  %1 = xor i64 %call5, %conv7
  %xor10 = xor i64 %1, %0
  %conv11 = trunc i64 %xor10 to i32
  tail call void @srandom(i32 noundef %conv11) #38
  %2 = load i64, ptr %tv, align 8
  %mul = mul nsw i64 %2, 1000000
  %add = add nsw i64 %mul, %0
  %call13 = tail call i32 @getpid() #38
  %conv14 = sext i32 %call13 to i64
  %xor15 = xor i64 %add, %conv14
  tail call void @init_genrand64(i64 noundef %xor15) #38
  tail call void @crc64_init() #38
  %call16 = tail call i32 @umask(i32 noundef 511) #38
  store i32 %call16, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 7), align 8
  %call17 = tail call i32 @umask(i32 noundef %call16) #38
  call void @getRandomBytes(ptr noundef nonnull %hashseed, i64 noundef 16) #38
  call void @dictSetHashFunctionSeed(ptr noundef nonnull %hashseed) #38
  %3 = load ptr, ptr %argv, align 8
  %call19 = call ptr @strrchr(ptr noundef nonnull dereferenceable(1) %3, i32 noundef 47) #39
  %cmp = icmp eq ptr %call19, null
  %spec.select = select i1 %cmp, ptr %3, ptr %call19
  %call.i = call ptr @strstr(ptr noundef nonnull dereferenceable(1) %spec.select, ptr noundef nonnull dereferenceable(1) @.str.426) #39
  %cmp.not.i = icmp eq ptr %call.i, null
  br i1 %cmp.not.i, label %for.cond.preheader.i, label %checkForSentinelMode.exit

for.cond.preheader.i:                             ; preds = %entry
  %cmp13.i = icmp sgt i32 %argc, 1
  br i1 %cmp13.i, label %for.body.preheader.i, label %checkForSentinelMode.exit

for.body.preheader.i:                             ; preds = %for.cond.preheader.i
  %wide.trip.count.i = zext nneg i32 %argc to i64
  br label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %checkForSentinelMode.exit, label %for.body.i, !llvm.loop !80

for.body.i:                                       ; preds = %for.cond.i, %for.body.preheader.i
  %indvars.iv.i = phi i64 [ 1, %for.body.preheader.i ], [ %indvars.iv.next.i, %for.cond.i ]
  %arrayidx.i = getelementptr inbounds ptr, ptr %argv, i64 %indvars.iv.i
  %4 = load ptr, ptr %arrayidx.i, align 8
  %call2.i = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %4, ptr noundef nonnull dereferenceable(11) @.str.427) #39
  %tobool.not.i = icmp eq i32 %call2.i, 0
  br i1 %tobool.not.i, label %checkForSentinelMode.exit, label %for.cond.i

checkForSentinelMode.exit:                        ; preds = %for.cond.i, %for.body.i, %entry, %for.cond.preheader.i
  %retval.0.i = phi i32 [ 1, %entry ], [ 0, %for.cond.preheader.i ], [ 0, %for.cond.i ], [ 1, %for.body.i ]
  store i32 %retval.0.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  call void @initServerConfig()
  call void @ACLInit() #38
  call void @moduleInitModulesSystem() #38
  %call23 = call i32 @connTypeInitialize() #38
  %5 = load ptr, ptr %argv, align 8
  %call25 = call ptr @getAbsolutePath(ptr noundef %5) #38
  store ptr %call25, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 3), align 8
  %add26 = add nsw i32 %argc, 1
  %conv27 = sext i32 %add26 to i64
  %mul28 = shl nsw i64 %conv27, 3
  %call29 = call noalias ptr @zmalloc(i64 noundef %mul28) #42
  store ptr %call29, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %idxprom = sext i32 %argc to i64
  %arrayidx30 = getelementptr inbounds ptr, ptr %call29, i64 %idxprom
  store ptr null, ptr %arrayidx30, align 8
  %cmp31164 = icmp sgt i32 %argc, 0
  br i1 %cmp31164, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %checkForSentinelMode.exit
  %wide.trip.count = zext nneg i32 %argc to i64
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx34 = getelementptr inbounds ptr, ptr %argv, i64 %indvars.iv
  %6 = load ptr, ptr %arrayidx34, align 8
  %call35 = call noalias ptr @zstrdup(ptr noundef %6) #38
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %arrayidx37 = getelementptr inbounds ptr, ptr %7, i64 %indvars.iv
  store ptr %call35, ptr %arrayidx37, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !81

for.end:                                          ; preds = %for.body, %checkForSentinelMode.exit
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool.not = icmp eq i32 %8, 0
  br i1 %tobool.not, label %if.end39, label %if.then38

if.then38:                                        ; preds = %for.end
  call void @initSentinelConfig() #38
  call void @initSentinel() #38
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %for.end
  %call40 = call ptr @strstr(ptr noundef nonnull dereferenceable(1) %spec.select, ptr noundef nonnull dereferenceable(1) @.str.440) #39
  %cmp41.not = icmp eq ptr %call40, null
  br i1 %cmp41.not, label %if.else, label %if.then43

if.then43:                                        ; preds = %if.end39
  %call44 = call i32 @redis_check_rdb_main(i32 noundef %argc, ptr noundef nonnull %argv, ptr noundef null) #38
  br label %if.end51

if.else:                                          ; preds = %if.end39
  %call45 = call ptr @strstr(ptr noundef nonnull dereferenceable(1) %spec.select, ptr noundef nonnull dereferenceable(1) @.str.441) #39
  %cmp46.not = icmp eq ptr %call45, null
  br i1 %cmp46.not, label %if.end51, label %if.then48

if.then48:                                        ; preds = %if.else
  %call49 = call i32 @redis_check_aof_main(i32 noundef %argc, ptr noundef nonnull %argv) #38
  br label %if.end51

if.end51:                                         ; preds = %if.else, %if.then48, %if.then43
  %cmp52 = icmp sgt i32 %argc, 1
  br i1 %cmp52, label %if.then54, label %if.end260

if.then54:                                        ; preds = %if.end51
  %call55 = call ptr @sdsempty() #38
  %arrayidx56 = getelementptr inbounds ptr, ptr %argv, i64 1
  %9 = load ptr, ptr %arrayidx56, align 8
  %call57 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %9, ptr noundef nonnull dereferenceable(3) @.str.442) #39
  %cmp58 = icmp eq i32 %call57, 0
  br i1 %cmp58, label %if.then64, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then54
  %call61 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %9, ptr noundef nonnull dereferenceable(10) @.str.443) #39
  %cmp62 = icmp eq i32 %call61, 0
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %lor.lhs.false, %if.then54
  %call.i99 = call ptr @redisGitSHA1() #38
  %call1.i = call ptr @redisGitDirty() #38
  %call2.i100 = call i32 @atoi(ptr nocapture noundef %call1.i) #39
  %cmp.i = icmp sgt i32 %call2.i100, 0
  %conv.i = zext i1 %cmp.i to i32
  %call3.i = call i64 @redisBuildId() #38
  %call4.i = call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.404, ptr noundef nonnull @.str.355, ptr noundef %call.i99, i32 noundef %conv.i, ptr noundef nonnull @.str.361, i32 noundef 64, i64 noundef %call3.i)
  call void @exit(i32 noundef 0) #40
  unreachable

if.end65:                                         ; preds = %lor.lhs.false
  %call67 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %9, ptr noundef nonnull dereferenceable(7) @.str.444) #39
  %cmp68 = icmp eq i32 %call67, 0
  br i1 %cmp68, label %if.then75, label %lor.lhs.false70

lor.lhs.false70:                                  ; preds = %if.end65
  %call72 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %9, ptr noundef nonnull dereferenceable(3) @.str.445) #39
  %cmp73 = icmp eq i32 %call72, 0
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %lor.lhs.false70, %if.end65
  call void @usage()
  unreachable

if.end76:                                         ; preds = %lor.lhs.false70
  %call78 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %9, ptr noundef nonnull dereferenceable(14) @.str.446) #39
  %cmp79 = icmp eq i32 %call78, 0
  br i1 %cmp79, label %if.then81, label %if.end91

if.then81:                                        ; preds = %if.end76
  %cmp82 = icmp eq i32 %argc, 3
  br i1 %cmp82, label %if.then84, label %if.else88

if.then84:                                        ; preds = %if.then81
  %arrayidx85 = getelementptr inbounds ptr, ptr %argv, i64 2
  %10 = load ptr, ptr %arrayidx85, align 8
  %call86 = call i32 @atoi(ptr nocapture noundef %10) #39
  %conv87 = sext i32 %call86 to i64
  call void @memtest(i64 noundef %conv87, i32 noundef 50) #38
  call void @exit(i32 noundef 0) #40
  unreachable

if.else88:                                        ; preds = %if.then81
  %11 = load ptr, ptr @stderr, align 8
  %12 = call i64 @fwrite(ptr nonnull @.str.447, i64 58, i64 1, ptr %11) #44
  %13 = load ptr, ptr @stderr, align 8
  %14 = call i64 @fwrite(ptr nonnull @.str.448, i64 44, i64 1, ptr %13) #44
  call void @exit(i32 noundef 1) #40
  unreachable

if.end91:                                         ; preds = %if.end76
  %call93 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %9, ptr noundef nonnull dereferenceable(15) @.str.449) #39
  %cmp94 = icmp eq i32 %call93, 0
  br i1 %cmp94, label %if.then96, label %if.end99

if.then96:                                        ; preds = %if.end91
  %call97 = call i32 @syscheck() #38
  %tobool98.not = icmp eq i32 %call97, 0
  %cond = zext i1 %tobool98.not to i32
  call void @exit(i32 noundef %cond) #40
  unreachable

if.end99:                                         ; preds = %if.end91
  %15 = load i8, ptr %9, align 1
  %cmp103.not = icmp eq i8 %15, 45
  br i1 %cmp103.not, label %if.end111, label %if.then105

if.then105:                                       ; preds = %if.end99
  %call107 = call ptr @getAbsolutePath(ptr noundef nonnull %9) #38
  store ptr %call107, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 2), align 8
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %arrayidx108 = getelementptr inbounds ptr, ptr %16, i64 1
  %17 = load ptr, ptr %arrayidx108, align 8
  call void @zfree(ptr noundef %17) #38
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 2), align 8
  %call109 = call noalias ptr @zstrdup(ptr noundef %18) #38
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %arrayidx110 = getelementptr inbounds ptr, ptr %19, i64 1
  store ptr %call109, ptr %arrayidx110, align 8
  br label %if.end111

if.end111:                                        ; preds = %if.then105, %if.end99
  %j.1 = phi i32 [ 2, %if.then105 ], [ 1, %if.end99 ]
  %cmp112166 = icmp ult i32 %j.1, %argc
  br i1 %cmp112166, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %if.end111
  %sub = add nsw i32 %argc, -1
  %20 = zext nneg i32 %j.1 to i64
  %21 = zext nneg i32 %sub to i64
  %wide.trip.count178 = zext nneg i32 %argc to i64
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end255
  %indvars.iv176 = phi i64 [ %20, %while.body.lr.ph ], [ %indvars.iv.next177, %if.end255 ]
  %config_from_stdin.0169 = phi i8 [ 0, %while.body.lr.ph ], [ %config_from_stdin.1, %if.end255 ]
  %handled_last_config_arg.0168 = phi i32 [ 1, %while.body.lr.ph ], [ %handled_last_config_arg.2, %if.end255 ]
  %options.0167 = phi ptr [ %call55, %while.body.lr.ph ], [ %options.3, %if.end255 ]
  %arrayidx115 = getelementptr inbounds ptr, ptr %argv, i64 %indvars.iv176
  %22 = load ptr, ptr %arrayidx115, align 8
  %23 = load i8, ptr %22, align 1
  %cmp118.not = icmp eq i8 %23, 45
  br i1 %cmp118.not, label %land.lhs.true, label %if.else246

land.lhs.true:                                    ; preds = %while.body
  %arrayidx122 = getelementptr inbounds i8, ptr %22, i64 1
  %24 = load i8, ptr %arrayidx122, align 1
  %cmp124 = icmp eq i8 %24, 0
  br i1 %cmp124, label %land.lhs.true126, label %if.else133

land.lhs.true126:                                 ; preds = %land.lhs.true
  %cmp127 = icmp eq i64 %indvars.iv176, 1
  %cmp130 = icmp eq i64 %indvars.iv176, %21
  %or.cond98 = select i1 %cmp127, i1 true, i1 %cmp130
  br i1 %or.cond98, label %if.end255, label %if.else246

if.else133:                                       ; preds = %land.lhs.true
  %tobool134.not = icmp ne i32 %handled_last_config_arg.0168, 0
  %cmp147 = icmp eq i8 %24, 45
  %or.cond188 = and i1 %tobool134.not, %cmp147
  br i1 %or.cond188, label %if.then149, label %if.else246

if.then149:                                       ; preds = %if.else133
  %arrayidx.i101 = getelementptr inbounds i8, ptr %options.0167, i64 -1
  %25 = load i8, ptr %arrayidx.i101, align 1
  %conv.i102 = zext i8 %25 to i32
  %and.i = and i32 %conv.i102, 7
  switch i32 %and.i, label %if.end154 [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then149
  %shr.i = lshr i32 %conv.i102, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then149
  %add.ptr.i = getelementptr inbounds i8, ptr %options.0167, i64 -3
  %26 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %26 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then149
  %add.ptr6.i = getelementptr inbounds i8, ptr %options.0167, i64 -5
  %27 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %27 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then149
  %add.ptr10.i = getelementptr inbounds i8, ptr %options.0167, i64 -9
  %28 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %28 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then149
  %add.ptr14.i = getelementptr inbounds i8, ptr %options.0167, i64 -17
  %29 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i103 = phi i64 [ %29, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %tobool151.not = icmp eq i64 %retval.0.i103, 0
  br i1 %tobool151.not, label %if.end154, label %if.then152

if.then152:                                       ; preds = %sdslen.exit
  %call153 = call ptr @sdscat(ptr noundef nonnull %options.0167, ptr noundef nonnull @.str.8) #38
  %.pre = load ptr, ptr %arrayidx115, align 8
  br label %if.end154

if.end154:                                        ; preds = %if.then149, %if.then152, %sdslen.exit
  %30 = phi ptr [ %.pre, %if.then152 ], [ %22, %sdslen.exit ], [ %22, %if.then149 ]
  %options.1 = phi ptr [ %call153, %if.then152 ], [ %options.0167, %sdslen.exit ], [ %options.0167, %if.then149 ]
  %add.ptr = getelementptr inbounds i8, ptr %30, i64 2
  %call157 = call ptr @sdscat(ptr noundef %options.1, ptr noundef nonnull %add.ptr) #38
  %call158 = call ptr @sdscat(ptr noundef %call157, ptr noundef nonnull @.str.40) #38
  %31 = load ptr, ptr %arrayidx115, align 8
  %call161 = call ptr @sdssplitargs(ptr noundef %31, ptr noundef nonnull %argc_tmp) #38
  %32 = load i32, ptr %argc_tmp, align 4
  %cmp162 = icmp eq i32 %32, 1
  br i1 %cmp162, label %if.then164, label %if.end245

if.then164:                                       ; preds = %if.end154
  %cmp166.not = icmp eq i64 %indvars.iv176, %21
  br i1 %cmp166.not, label %land.lhs.true195, label %land.lhs.true168

land.lhs.true168:                                 ; preds = %if.then164
  %arrayidx171 = getelementptr ptr, ptr %arrayidx115, i64 1
  %33 = load ptr, ptr %arrayidx171, align 8
  %34 = load i8, ptr %33, align 1
  %cmp174 = icmp eq i8 %34, 45
  br i1 %cmp174, label %land.lhs.true176, label %if.end245

land.lhs.true176:                                 ; preds = %land.lhs.true168
  %arrayidx180 = getelementptr inbounds i8, ptr %33, i64 1
  %35 = load i8, ptr %arrayidx180, align 1
  %cmp182 = icmp eq i8 %35, 45
  br i1 %cmp182, label %land.lhs.true184, label %land.lhs.true214

land.lhs.true184:                                 ; preds = %land.lhs.true176
  %36 = load ptr, ptr %arrayidx115, align 8
  %call187 = call i32 @strcasecmp(ptr noundef %36, ptr noundef nonnull @.str.450) #39
  %tobool188.not = icmp eq i32 %call187, 0
  br i1 %tobool188.not, label %if.end245.sink.split, label %land.lhs.true214

land.lhs.true195:                                 ; preds = %if.then164
  %37 = load ptr, ptr %arrayidx115, align 8
  %call198 = call i32 @strcasecmp(ptr noundef %37, ptr noundef nonnull @.str.450) #39
  %tobool199.not = icmp eq i32 %call198, 0
  br i1 %tobool199.not, label %if.end245.sink.split, label %land.lhs.true233

land.lhs.true214:                                 ; preds = %land.lhs.true176, %land.lhs.true184
  %arrayidx218 = getelementptr inbounds i8, ptr %33, i64 1
  %38 = load i8, ptr %arrayidx218, align 1
  %cmp220 = icmp eq i8 %38, 45
  br i1 %cmp220, label %land.lhs.true222, label %if.end245

land.lhs.true222:                                 ; preds = %land.lhs.true214
  %39 = load ptr, ptr %arrayidx115, align 8
  %call225 = call i32 @strcasecmp(ptr noundef %39, ptr noundef nonnull @.str.427) #39
  %tobool226.not = icmp eq i32 %call225, 0
  br i1 %tobool226.not, label %if.end245.sink.split, label %if.end245

land.lhs.true233:                                 ; preds = %land.lhs.true195
  %call236 = call i32 @strcasecmp(ptr noundef %37, ptr noundef nonnull @.str.427) #39
  %tobool237.not = icmp eq i32 %call236, 0
  br i1 %tobool237.not, label %if.end245.sink.split, label %if.end245

if.end245.sink.split:                             ; preds = %land.lhs.true233, %land.lhs.true222, %land.lhs.true195, %land.lhs.true184
  %.str.451.sink = phi ptr [ @.str.451, %land.lhs.true184 ], [ @.str.451, %land.lhs.true195 ], [ @.str.219, %land.lhs.true222 ], [ @.str.219, %land.lhs.true233 ]
  %handled_last_config_arg.1.ph = phi i32 [ 1, %land.lhs.true184 ], [ 0, %land.lhs.true195 ], [ 1, %land.lhs.true222 ], [ 0, %land.lhs.true233 ]
  %call190 = call ptr @sdscat(ptr noundef %call158, ptr noundef nonnull %.str.451.sink) #38
  br label %if.end245

if.end245:                                        ; preds = %if.end245.sink.split, %land.lhs.true168, %land.lhs.true214, %land.lhs.true222, %if.end154, %land.lhs.true233
  %options.2 = phi ptr [ %call158, %land.lhs.true233 ], [ %call158, %if.end154 ], [ %call158, %land.lhs.true222 ], [ %call158, %land.lhs.true214 ], [ %call158, %land.lhs.true168 ], [ %call190, %if.end245.sink.split ]
  %handled_last_config_arg.1 = phi i32 [ 0, %land.lhs.true233 ], [ 1, %if.end154 ], [ 0, %land.lhs.true222 ], [ 0, %land.lhs.true214 ], [ 0, %land.lhs.true168 ], [ %handled_last_config_arg.1.ph, %if.end245.sink.split ]
  %40 = load i32, ptr %argc_tmp, align 4
  call void @sdsfreesplitres(ptr noundef %call161, i32 noundef %40) #38
  br label %if.end255

if.else246:                                       ; preds = %land.lhs.true126, %if.else133, %while.body
  %call251 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %22) #39
  %call252 = call ptr @sdscatrepr(ptr noundef %options.0167, ptr noundef nonnull %22, i64 noundef %call251) #38
  %call253 = call ptr @sdscat(ptr noundef %call252, ptr noundef nonnull @.str.40) #38
  br label %if.end255

if.end255:                                        ; preds = %land.lhs.true126, %if.end245, %if.else246
  %options.3 = phi ptr [ %options.2, %if.end245 ], [ %call253, %if.else246 ], [ %options.0167, %land.lhs.true126 ]
  %handled_last_config_arg.2 = phi i32 [ %handled_last_config_arg.1, %if.end245 ], [ 1, %if.else246 ], [ %handled_last_config_arg.0168, %land.lhs.true126 ]
  %config_from_stdin.1 = phi i8 [ %config_from_stdin.0169, %if.end245 ], [ %config_from_stdin.0169, %if.else246 ], [ 1, %land.lhs.true126 ]
  %indvars.iv.next177 = add nuw nsw i64 %indvars.iv176, 1
  %exitcond179.not = icmp eq i64 %indvars.iv.next177, %wide.trip.count178
  br i1 %exitcond179.not, label %while.end, label %while.body, !llvm.loop !82

while.end:                                        ; preds = %if.end255, %if.end111
  %options.0.lcssa = phi ptr [ %call55, %if.end111 ], [ %options.3, %if.end255 ]
  %config_from_stdin.0.lcssa = phi i8 [ 0, %if.end111 ], [ %config_from_stdin.1, %if.end255 ]
  %41 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 2), align 8
  call void @loadServerConfig(ptr noundef %41, i8 noundef signext %config_from_stdin.0.lcssa, ptr noundef %options.0.lcssa) #38
  %42 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool257.not = icmp eq i32 %42, 0
  br i1 %tobool257.not, label %if.end259, label %if.then258

if.then258:                                       ; preds = %while.end
  call void @loadSentinelConfigFromQueue() #38
  br label %if.end259

if.end259:                                        ; preds = %if.then258, %while.end
  call void @sdsfree(ptr noundef %options.0.lcssa) #38
  br label %if.end260

if.end260:                                        ; preds = %if.end259, %if.end51
  %43 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool261.not = icmp eq i32 %43, 0
  br i1 %tobool261.not, label %if.end263, label %if.then262

if.then262:                                       ; preds = %if.end260
  call void @sentinelCheckConfigFile() #38
  br label %if.end263

if.end263:                                        ; preds = %if.then262, %if.end260
  call void @linuxMemoryWarnings()
  store ptr null, ptr %err_msg, align 8
  %call264 = call i32 @checkXenClocksource(ptr noundef nonnull %err_msg) #38
  %cmp265 = icmp slt i32 %call264, 0
  br i1 %cmp265, label %do.body, label %if.end272

do.body:                                          ; preds = %if.end263
  %44 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp268 = icmp sgt i32 %44, 3
  br i1 %cmp268, label %do.end, label %if.end271

if.end271:                                        ; preds = %do.body
  %45 = load ptr, ptr %err_msg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.399, ptr noundef %45)
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end271
  %46 = load ptr, ptr %err_msg, align 8
  call void @sdsfree(ptr noundef %46) #38
  br label %if.end272

if.end272:                                        ; preds = %do.end, %if.end263
  %47 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  %call273 = call i32 @redisIsSupervised(i32 noundef %47), !range !13
  store i32 %call273, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 174), align 4
  %48 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 176), align 4
  %tobool274 = icmp ne i32 %48, 0
  %tobool275.not = icmp eq i32 %call273, 0
  %49 = and i1 %tobool275.not, %tobool274
  br i1 %49, label %if.then277, label %do.body279

if.then277:                                       ; preds = %if.end272
  call void @daemonize()
  br label %do.body279

do.body279:                                       ; preds = %if.end272, %if.then277
  %50 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp280 = icmp sgt i32 %50, 2
  br i1 %cmp280, label %do.end296, label %do.body285

do.body285:                                       ; preds = %do.body279
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.452)
  %.pr = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp286 = icmp sgt i32 %.pr, 2
  br i1 %cmp286, label %do.end296, label %if.end289

if.end289:                                        ; preds = %do.body285
  %call290 = call ptr @redisGitSHA1() #38
  %call291 = call ptr @redisGitDirty() #38
  %call292 = call i64 @strtol(ptr nocapture noundef %call291, ptr noundef null, i32 noundef 10) #38
  %cmp293 = icmp sgt i64 %call292, 0
  %conv294 = zext i1 %cmp293 to i32
  %call295 = call i32 @getpid() #38
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.453, ptr noundef nonnull @.str.355, i32 noundef 64, ptr noundef %call290, i32 noundef %conv294, i32 noundef %call295)
  br label %do.end296

do.end296:                                        ; preds = %do.body279, %do.body285, %if.end289
  %cmp297 = icmp eq i32 %argc, 1
  %51 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  br i1 %cmp297, label %do.body300, label %do.body308

do.body300:                                       ; preds = %do.end296
  %cmp301 = icmp sgt i32 %51, 3
  br i1 %cmp301, label %if.end314, label %if.end304

if.end304:                                        ; preds = %do.body300
  %52 = load ptr, ptr %argv, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.454, ptr noundef %52)
  br label %if.end314

do.body308:                                       ; preds = %do.end296
  %cmp309 = icmp sgt i32 %51, 2
  br i1 %cmp309, label %if.end314, label %if.end312

if.end312:                                        ; preds = %do.body308
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.455)
  br label %if.end314

if.end314:                                        ; preds = %if.end312, %do.body308, %if.end304, %do.body300
  call void @initServer()
  %53 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 23), align 8
  %tobool317 = icmp ne ptr %53, null
  %or.cond = select i1 %49, i1 true, i1 %tobool317
  br i1 %or.cond, label %if.then318, label %if.end319

if.then318:                                       ; preds = %if.end314
  call void @createPidFile()
  br label %if.end319

if.end319:                                        ; preds = %if.end314, %if.then318
  %54 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 177), align 8
  %tobool320.not = icmp eq i32 %54, 0
  br i1 %tobool320.not, label %if.end323, label %if.then321

if.then321:                                       ; preds = %if.end319
  %55 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 4), align 8
  %56 = load ptr, ptr %55, align 8
  %57 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 178), align 8
  %call.i.i = call ptr @sdstemplate(ptr noundef %57, ptr noundef nonnull @redisProcTitleGetVariable, ptr noundef %56) #38
  %tobool.not.i.i = icmp eq ptr %call.i.i, null
  br i1 %tobool.not.i.i, label %if.end323, label %expandProcTitleTemplate.exit.i

expandProcTitleTemplate.exit.i:                   ; preds = %if.then321
  %call1.i.i = call ptr @sdstrim(ptr noundef nonnull %call.i.i, ptr noundef nonnull @.str.40) #38
  %tobool1.not.i = icmp eq ptr %call1.i.i, null
  br i1 %tobool1.not.i, label %if.end323, label %if.end3.i

if.end3.i:                                        ; preds = %expandProcTitleTemplate.exit.i
  call void (ptr, ...) @setproctitle(ptr noundef nonnull @.str.2, ptr noundef nonnull %call1.i.i) #38
  call void @sdsfree(ptr noundef nonnull %call1.i.i) #38
  br label %if.end323

if.end323:                                        ; preds = %if.end3.i, %expandProcTitleTemplate.exit.i, %if.then321, %if.end319
  call void @redisAsciiArt()
  call void @llvm.lifetime.start.p0(i64 1024, ptr nonnull %buf.i)
  %call.i105 = call noalias ptr @fopen64(ptr noundef nonnull @.str.140, ptr noundef nonnull @.str.141)
  %tobool.not.i106 = icmp eq ptr %call.i105, null
  br i1 %tobool.not.i106, label %checkTcpBacklogSettings.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end323
  %call1.i107 = call ptr @fgets(ptr noundef nonnull %buf.i, i32 noundef 1024, ptr noundef nonnull %call.i105)
  %cmp.not.i108 = icmp eq ptr %call1.i107, null
  br i1 %cmp.not.i108, label %if.end12.i, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %call4.i109 = call i32 @atoi(ptr nocapture noundef nonnull %buf.i) #39
  %cmp5.i = icmp sgt i32 %call4.i109, 0
  br i1 %cmp5.i, label %land.lhs.true.i, label %if.end12.i

land.lhs.true.i:                                  ; preds = %if.then2.i
  %58 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 46), align 8
  %cmp6.i = icmp sge i32 %call4.i109, %58
  %59 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp8.i = icmp sgt i32 %59, 3
  %or.cond.i = select i1 %cmp6.i, i1 true, i1 %cmp8.i
  br i1 %or.cond.i, label %if.end12.i, label %if.end10.i

if.end10.i:                                       ; preds = %land.lhs.true.i
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.142, i32 noundef %58, i32 noundef %call4.i109)
  br label %if.end12.i

if.end12.i:                                       ; preds = %if.end10.i, %land.lhs.true.i, %if.then2.i, %if.end.i
  %call13.i = call i32 @fclose(ptr noundef nonnull %call.i105)
  br label %checkTcpBacklogSettings.exit

checkTcpBacklogSettings.exit:                     ; preds = %if.end323, %if.end12.i
  call void @llvm.lifetime.end.p0(i64 1024, ptr nonnull %buf.i)
  %60 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool324.not = icmp eq i32 %60, 0
  br i1 %tobool324.not, label %if.end326, label %if.then325

if.then325:                                       ; preds = %checkTcpBacklogSettings.exit
  call void @clusterInit() #38
  br label %if.end326

if.end326:                                        ; preds = %if.then325, %checkTcpBacklogSettings.exit
  %61 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool327.not = icmp eq i32 %61, 0
  br i1 %tobool327.not, label %if.then328, label %if.end329

if.then328:                                       ; preds = %if.end326
  call void @moduleInitModulesSystemLast() #38
  call void @moduleLoadFromQueue() #38
  br label %if.end329

if.end329:                                        ; preds = %if.then328, %if.end326
  call void @ACLLoadUsersAtStartup() #38
  call void @initListeners()
  %62 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool330.not = icmp eq i32 %62, 0
  br i1 %tobool330.not, label %if.end332, label %if.then331

if.then331:                                       ; preds = %if.end329
  call void @clusterInitLast() #38
  br label %if.end332

if.end332:                                        ; preds = %if.then331, %if.end329
  call void @bioInit() #38
  call void @initThreadedIO() #38
  %63 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 165), align 4
  call void @set_jemalloc_bg_thread(i32 noundef %63) #38
  %call.i110 = call i64 @zmalloc_used_memory() #38
  store i64 %call.i110, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 28), align 8
  %64 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool333.not = icmp eq i32 %64, 0
  br i1 %tobool333.not, label %do.body335, label %if.else384

do.body335:                                       ; preds = %if.end332
  %65 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp336 = icmp sgt i32 %65, 2
  br i1 %cmp336, label %do.end340, label %if.end339

if.end339:                                        ; preds = %do.body335
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.456)
  br label %do.end340

do.end340:                                        ; preds = %do.body335, %if.end339
  call void @aofLoadManifestFromDisk() #38
  call void @loadDataFromDisk()
  call void @aofOpenIfNeededOnServerStart() #38
  %call341 = call i32 @aofDelHistoryFiles() #38
  %66 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool342.not = icmp eq i32 %66, 0
  br i1 %tobool342.not, label %if.end351, label %if.then343

if.then343:                                       ; preds = %do.end340
  %call344 = call i32 @verifyClusterConfigWithData() #38
  %cmp345 = icmp eq i32 %call344, 0
  br i1 %cmp345, label %if.end351, label %cond.false

cond.false:                                       ; preds = %if.then343
  call void @_serverAssert(ptr noundef nonnull @.str.457, ptr noundef nonnull @.str.9, i32 noundef 7177) #38
  call void @abort() #40
  unreachable

if.end351:                                        ; preds = %if.then343, %do.end340
  %.pre185 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  br label %for.body355

for.body355:                                      ; preds = %if.end351, %for.inc370
  %67 = phi i32 [ %.pre185, %if.end351 ], [ %70, %for.inc370 ]
  %indvars.iv180 = phi i64 [ 0, %if.end351 ], [ %indvars.iv.next181, %for.inc370 ]
  %ct = getelementptr inbounds %struct.redisServer, ptr @server, i64 0, i32 52, i64 %indvars.iv180, i32 5
  %68 = load ptr, ptr %ct, align 8
  %cmp358 = icmp eq ptr %68, null
  %cmp363 = icmp sgt i32 %67, 2
  %or.cond2 = select i1 %cmp358, i1 true, i1 %cmp363
  br i1 %or.cond2, label %for.inc370, label %if.end366

if.end366:                                        ; preds = %for.body355
  %69 = load ptr, ptr %68, align 8
  %call368 = call ptr %69(ptr noundef null) #38
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.458, ptr noundef %call368)
  %.pre184 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  br label %for.inc370

for.inc370:                                       ; preds = %if.end366, %for.body355
  %70 = phi i32 [ %.pre184, %if.end366 ], [ %67, %for.body355 ]
  %indvars.iv.next181 = add nuw nsw i64 %indvars.iv180, 1
  %exitcond183.not = icmp eq i64 %indvars.iv.next181, 8
  br i1 %exitcond183.not, label %for.end372, label %for.body355, !llvm.loop !83

for.end372:                                       ; preds = %for.inc370
  %71 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  %cmp373 = icmp eq i32 %71, 2
  br i1 %cmp373, label %if.then375, label %if.end391

if.then375:                                       ; preds = %for.end372
  %72 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %tobool376.not = icmp eq ptr %72, null
  br i1 %tobool376.not, label %if.then377, label %if.else379

if.then377:                                       ; preds = %if.then375
  %call.i111 = call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.459) #38
  %cmp.i112 = icmp eq i32 %call.i111, 0
  br i1 %cmp.i112, label %do.body.i, label %if.else.i

do.body.i:                                        ; preds = %if.then377
  %73 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i = icmp sgt i32 %73, 3
  br i1 %cmp1.i, label %if.end381, label %if.end.i115

if.end.i115:                                      ; preds = %do.body.i
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %if.end381

if.else.i:                                        ; preds = %if.then377
  %cmp3.i = icmp sgt i32 %call.i111, -1
  %74 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i113 = icmp sgt i32 %74, 3
  %or.cond.i114 = select i1 %cmp3.i, i1 true, i1 %cmp6.i113
  br i1 %or.cond.i114, label %if.end381, label %if.end8.i

if.end8.i:                                        ; preds = %if.else.i
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i111)
  br label %if.end381

if.else379:                                       ; preds = %if.then375
  %call.i116 = call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.460) #38
  %cmp.i117 = icmp eq i32 %call.i116, 0
  br i1 %cmp.i117, label %do.body.i123, label %if.else.i118

do.body.i123:                                     ; preds = %if.else379
  %75 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i124 = icmp sgt i32 %75, 3
  br i1 %cmp1.i124, label %if.end381, label %if.end.i125

if.end.i125:                                      ; preds = %do.body.i123
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %if.end381

if.else.i118:                                     ; preds = %if.else379
  %cmp3.i119 = icmp sgt i32 %call.i116, -1
  %76 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i120 = icmp sgt i32 %76, 3
  %or.cond.i121 = select i1 %cmp3.i119, i1 true, i1 %cmp6.i120
  br i1 %or.cond.i121, label %if.end381, label %if.end8.i122

if.end8.i122:                                     ; preds = %if.else.i118
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i116)
  br label %if.end381

if.end381:                                        ; preds = %if.end8.i122, %if.else.i118, %if.end.i125, %do.body.i123, %if.end8.i, %if.else.i, %if.end.i115, %do.body.i
  %call.i127 = call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.461) #38
  %cmp.i128 = icmp eq i32 %call.i127, 0
  br i1 %cmp.i128, label %do.body.i134, label %if.else.i129

do.body.i134:                                     ; preds = %if.end381
  %77 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i135 = icmp sgt i32 %77, 3
  br i1 %cmp1.i135, label %if.end391, label %if.end.i136

if.end.i136:                                      ; preds = %do.body.i134
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %if.end391

if.else.i129:                                     ; preds = %if.end381
  %cmp3.i130 = icmp sgt i32 %call.i127, -1
  %78 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i131 = icmp sgt i32 %78, 3
  %or.cond.i132 = select i1 %cmp3.i130, i1 true, i1 %cmp6.i131
  br i1 %or.cond.i132, label %if.end391, label %if.end8.i133

if.end8.i133:                                     ; preds = %if.else.i129
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i127)
  br label %if.end391

if.else384:                                       ; preds = %if.end332
  call void @sentinelIsRunning() #38
  %79 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 175), align 8
  %cmp385 = icmp eq i32 %79, 2
  br i1 %cmp385, label %if.then387, label %if.end391

if.then387:                                       ; preds = %if.else384
  %call.i138 = call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.459) #38
  %cmp.i139 = icmp eq i32 %call.i138, 0
  br i1 %cmp.i139, label %do.body.i145, label %if.else.i140

do.body.i145:                                     ; preds = %if.then387
  %80 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i146 = icmp sgt i32 %80, 3
  br i1 %cmp1.i146, label %redisCommunicateSystemd.exit148, label %if.end.i147

if.end.i147:                                      ; preds = %do.body.i145
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %redisCommunicateSystemd.exit148

if.else.i140:                                     ; preds = %if.then387
  %cmp3.i141 = icmp sgt i32 %call.i138, -1
  %81 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i142 = icmp sgt i32 %81, 3
  %or.cond.i143 = select i1 %cmp3.i141, i1 true, i1 %cmp6.i142
  br i1 %or.cond.i143, label %redisCommunicateSystemd.exit148, label %if.end8.i144

if.end8.i144:                                     ; preds = %if.else.i140
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i138)
  br label %redisCommunicateSystemd.exit148

redisCommunicateSystemd.exit148:                  ; preds = %do.body.i145, %if.end.i147, %if.else.i140, %if.end8.i144
  %call.i149 = call i32 @sd_notify(i32 noundef 0, ptr noundef nonnull @.str.461) #38
  %cmp.i150 = icmp eq i32 %call.i149, 0
  br i1 %cmp.i150, label %do.body.i156, label %if.else.i151

do.body.i156:                                     ; preds = %redisCommunicateSystemd.exit148
  %82 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i157 = icmp sgt i32 %82, 3
  br i1 %cmp1.i157, label %if.end391, label %if.end.i158

if.end.i158:                                      ; preds = %do.body.i156
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.434)
  br label %if.end391

if.else.i151:                                     ; preds = %redisCommunicateSystemd.exit148
  %cmp3.i152 = icmp sgt i32 %call.i149, -1
  %83 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i153 = icmp sgt i32 %83, 3
  %or.cond.i154 = select i1 %cmp3.i152, i1 true, i1 %cmp6.i153
  br i1 %or.cond.i154, label %if.end391, label %if.end8.i155

if.end8.i155:                                     ; preds = %if.else.i151
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.435, i32 noundef %call.i149)
  br label %if.end391

if.end391:                                        ; preds = %if.end8.i155, %if.else.i151, %if.end.i158, %do.body.i156, %if.end8.i133, %if.else.i129, %if.end.i136, %do.body.i134, %if.else384, %for.end372
  %84 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 314), align 8
  %85 = add i64 %84, -1048576
  %or.cond1 = icmp ult i64 %85, -1048575
  %86 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp399 = icmp sgt i32 %86, 3
  %or.cond3 = select i1 %or.cond1, i1 true, i1 %cmp399
  br i1 %or.cond3, label %if.end404, label %if.end402

if.end402:                                        ; preds = %if.end391
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.462, i64 noundef %84)
  br label %if.end404

if.end404:                                        ; preds = %if.end402, %if.end391
  %87 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 406), align 8
  call void @setcpuaffinity(ptr noundef %87) #38
  %call405 = call i32 @setOOMScoreAdj(i32 noundef -1), !range !16
  %88 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  call void @aeMain(ptr noundef %88) #38
  %89 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 14), align 8
  call void @aeDeleteEventLoop(ptr noundef %89) #38
  ret i32 0
}

declare void @spt_init(i32 noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare void @tzset() local_unnamed_addr #3

declare void @zmalloc_set_oom_handler(ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare void @srand(i32 noundef) local_unnamed_addr #3

; Function Attrs: nounwind
declare void @srandom(i32 noundef) local_unnamed_addr #3

declare void @init_genrand64(i64 noundef) local_unnamed_addr #4

declare void @crc64_init() local_unnamed_addr #4

; Function Attrs: nounwind
declare i32 @umask(i32 noundef) local_unnamed_addr #3

declare void @getRandomBytes(ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @dictSetHashFunctionSeed(ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strrchr(ptr noundef, i32 noundef) local_unnamed_addr #7

declare void @ACLInit() local_unnamed_addr #4

declare void @moduleInitModulesSystem() local_unnamed_addr #4

declare i32 @connTypeInitialize() local_unnamed_addr #4

declare ptr @getAbsolutePath(ptr noundef) local_unnamed_addr #4

declare void @initSentinelConfig() local_unnamed_addr #4

declare void @initSentinel() local_unnamed_addr #4

declare i32 @redis_check_rdb_main(i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

declare i32 @redis_check_aof_main(i32 noundef, ptr noundef) local_unnamed_addr #4

declare void @memtest(i64 noundef, i32 noundef) local_unnamed_addr #4

declare i32 @syscheck() local_unnamed_addr #4

declare ptr @sdscatrepr(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #4

declare void @loadServerConfig(ptr noundef, i8 noundef signext, ptr noundef) local_unnamed_addr #4

declare void @loadSentinelConfigFromQueue() local_unnamed_addr #4

declare void @sentinelCheckConfigFile() local_unnamed_addr #4

declare i32 @checkXenClocksource(ptr noundef) local_unnamed_addr #4

declare void @clusterInit() local_unnamed_addr #4

declare void @moduleInitModulesSystemLast() local_unnamed_addr #4

declare void @moduleLoadFromQueue() local_unnamed_addr #4

declare void @ACLLoadUsersAtStartup() local_unnamed_addr #4

declare void @clusterInitLast() local_unnamed_addr #4

declare void @aofLoadManifestFromDisk() local_unnamed_addr #4

declare void @aofOpenIfNeededOnServerStart() local_unnamed_addr #4

declare i32 @aofDelHistoryFiles() local_unnamed_addr #4

declare i32 @verifyClusterConfigWithData() local_unnamed_addr #4

declare void @sentinelIsRunning() local_unnamed_addr #4

declare void @aeMain(ptr noundef) local_unnamed_addr #4

declare void @aeDeleteEventLoop(ptr noundef) local_unnamed_addr #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #32

; Function Attrs: nounwind
declare ptr @localtime_r(ptr noundef, ptr noundef) local_unnamed_addr #3

declare void @replicationFeedSlaves(ptr noundef, i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal fastcc void @propagateNow(i32 noundef %dbid, ptr noundef %argv, i32 noundef %argc, i32 noundef %target) unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 249), align 8
  %tobool.i = icmp eq i32 %0, 0
  %cmp.i = icmp eq i32 %target, 0
  %or.cond.i = or i1 %cmp.i, %tobool.i
  br i1 %or.cond.i, label %if.end15, label %lor.lhs.false1.i

lor.lhs.false1.i:                                 ; preds = %entry
  %1 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool2.not.i = icmp eq i32 %1, 0
  br i1 %tobool2.not.i, label %if.end.i, label %if.end15

if.end.i:                                         ; preds = %lor.lhs.false1.i
  %and.i = and i32 %target, 1
  %tobool3.i = icmp ne i32 %and.i, 0
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp5.i = icmp ne i32 %2, 0
  %or.cond1.i = select i1 %tobool3.i, i1 %cmp5.i, i1 false
  br i1 %or.cond1.i, label %if.end, label %if.end8.i

if.end8.i:                                        ; preds = %if.end.i
  %and9.i = and i32 %target, 2
  %tobool10.i = icmp ne i32 %and9.i, 0
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp12.i = icmp eq ptr %3, null
  %or.cond2.i = select i1 %tobool10.i, i1 %cmp12.i, i1 false
  br i1 %or.cond2.i, label %land.lhs.true.i, label %if.end15

land.lhs.true.i:                                  ; preds = %if.end8.i
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 268), align 8
  %tobool13.not.i = icmp eq ptr %4, null
  br i1 %tobool13.not.i, label %lor.lhs.false14.i, label %if.end

lor.lhs.false14.i:                                ; preds = %land.lhs.true.i
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  %len.i = getelementptr inbounds %struct.list, ptr %5, i64 0, i32 5
  %6 = load i64, ptr %len.i, align 8
  %cmp15.not.i = icmp eq i64 %6, 0
  br i1 %cmp15.not.i, label %if.end15, label %if.end

if.end:                                           ; preds = %lor.lhs.false14.i, %land.lhs.true.i, %if.end.i
  %call1 = tail call i32 @isPausedActions(i32 noundef 16) #38
  %tobool2 = icmp eq i32 %call1, 0
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 34), align 8
  %tobool3.not = icmp ne i32 %7, 0
  %.not = select i1 %tobool2, i1 true, i1 %tobool3.not
  br i1 %.not, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.464, ptr noundef nonnull @.str.9, i32 noundef 3340) #38
  tail call void @abort() #40
  unreachable

cond.end:                                         ; preds = %if.end
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 185), align 8
  %cmp.not = icmp eq i32 %8, 0
  %tobool9.not = icmp eq i32 %and.i, 0
  %or.cond = or i1 %tobool9.not, %cmp.not
  br i1 %or.cond, label %if.end11, label %if.then10

if.then10:                                        ; preds = %cond.end
  tail call void @feedAppendOnlyFile(i32 noundef %dbid, ptr noundef %argv, i32 noundef %argc) #38
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %cond.end
  %and12 = and i32 %target, 2
  %tobool13.not = icmp eq i32 %and12, 0
  br i1 %tobool13.not, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end11
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 59), align 8
  tail call void @replicationFeedSlaves(ptr noundef %9, i32 noundef %dbid, ptr noundef %argv, i32 noundef %argc) #38
  br label %if.end15

if.end15:                                         ; preds = %if.end8.i, %lor.lhs.false14.i, %entry, %lor.lhs.false1.i, %if.then14, %if.end11
  ret void
}

declare void @feedAppendOnlyFile(i32 noundef, ptr noundef, i32 noundef) local_unnamed_addr #4

declare void @replyToClientsBlockedOnShutdown() local_unnamed_addr #4

declare void @unpauseActions(i32 noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare i32 @prctl(i32 noundef, ...) local_unnamed_addr #3

declare ptr @sdstemplate(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind uwtable
define internal ptr @redisProcTitleGetVariable(ptr nocapture noundef readonly %varname, ptr noundef %arg) #0 {
entry:
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %varname, ptr noundef nonnull dereferenceable(6) @.str.471) #39
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = tail call ptr @sdsnew(ptr noundef %arg) #38
  br label %return

if.else:                                          ; preds = %entry
  %call2 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %varname, ptr noundef nonnull dereferenceable(12) @.str.472) #39
  %tobool3.not = icmp eq i32 %call2, 0
  br i1 %tobool3.not, label %if.then4, label %if.else19

if.then4:                                         ; preds = %if.else
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %tobool5 = icmp ne i32 %0, 0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %tobool6 = icmp ne i32 %1, 0
  %or.cond = select i1 %tobool5, i1 true, i1 %tobool6
  %call8 = tail call ptr @sdsempty() #38
  br i1 %or.cond, label %if.then7, label %if.else16

if.then7:                                         ; preds = %if.then4
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 48), align 8
  %tobool9.not = icmp eq i32 %2, 0
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 47), align 8
  %cond = select i1 %tobool9.not, ptr @.str.116, ptr %3
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %tobool10.not = icmp eq i32 %4, 0
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %cond14 = select i1 %tobool10.not, i32 %5, i32 %4
  %call15 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call8, ptr noundef nonnull @.str.473, ptr noundef %cond, i32 noundef %cond14) #38
  br label %return

if.else16:                                        ; preds = %if.then4
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 50), align 8
  %call18 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call8, ptr noundef nonnull @.str.474, ptr noundef %6) #38
  br label %return

if.else19:                                        ; preds = %if.else
  %call20 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %varname, ptr noundef nonnull dereferenceable(12) @.str.475) #39
  %tobool21.not = icmp eq i32 %call20, 0
  br i1 %tobool21.not, label %if.then22, label %if.else32

if.then22:                                        ; preds = %if.else19
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool23.not = icmp eq i32 %7, 0
  br i1 %tobool23.not, label %if.else26, label %if.then24

if.then24:                                        ; preds = %if.then22
  %call25 = tail call ptr @sdsnew(ptr noundef nonnull @.str.476) #38
  br label %return

if.else26:                                        ; preds = %if.then22
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 27), align 4
  %tobool27.not = icmp eq i32 %8, 0
  br i1 %tobool27.not, label %if.else30, label %if.then28

if.then28:                                        ; preds = %if.else26
  %call29 = tail call ptr @sdsnew(ptr noundef nonnull @.str.477) #38
  br label %return

if.else30:                                        ; preds = %if.else26
  %call31 = tail call ptr @sdsempty() #38
  br label %return

if.else32:                                        ; preds = %if.else19
  %call33 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %varname, ptr noundef nonnull dereferenceable(12) @.str.478) #39
  %tobool34.not = icmp eq i32 %call33, 0
  br i1 %tobool34.not, label %if.then35, label %if.else42

if.then35:                                        ; preds = %if.else32
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 2), align 8
  %tobool36.not = icmp eq ptr %9, null
  %cond40 = select i1 %tobool36.not, ptr @.str.479, ptr %9
  %call41 = tail call ptr @sdsnew(ptr noundef nonnull %cond40) #38
  br label %return

if.else42:                                        ; preds = %if.else32
  %call43 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %varname, ptr noundef nonnull dereferenceable(5) @.str.480) #39
  %tobool44.not = icmp eq i32 %call43, 0
  br i1 %tobool44.not, label %if.then45, label %if.else48

if.then45:                                        ; preds = %if.else42
  %call46 = tail call ptr @sdsempty() #38
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %call47 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call46, ptr noundef nonnull @.str.481, i32 noundef %10) #38
  br label %return

if.else48:                                        ; preds = %if.else42
  %call49 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %varname, ptr noundef nonnull dereferenceable(9) @.str.482) #39
  %tobool50.not = icmp eq i32 %call49, 0
  br i1 %tobool50.not, label %if.then51, label %if.else54

if.then51:                                        ; preds = %if.else48
  %call52 = tail call ptr @sdsempty() #38
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %call53 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call52, ptr noundef nonnull @.str.481, i32 noundef %11) #38
  br label %return

if.else54:                                        ; preds = %if.else48
  %call55 = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %varname, ptr noundef nonnull dereferenceable(11) @.str.483) #39
  %tobool56.not = icmp eq i32 %call55, 0
  br i1 %tobool56.not, label %if.then57, label %return

if.then57:                                        ; preds = %if.else54
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 50), align 8
  %call58 = tail call ptr @sdsnew(ptr noundef %12) #38
  br label %return

return:                                           ; preds = %if.else54, %if.then57, %if.then51, %if.then45, %if.then35, %if.else30, %if.then28, %if.then24, %if.else16, %if.then7, %if.then
  %retval.0 = phi ptr [ %call58, %if.then57 ], [ %call53, %if.then51 ], [ %call47, %if.then45 ], [ %call41, %if.then35 ], [ %call25, %if.then24 ], [ %call29, %if.then28 ], [ %call31, %if.else30 ], [ %call15, %if.then7 ], [ %call18, %if.else16 ], [ %call1, %if.then ], [ null, %if.else54 ]
  ret ptr %retval.0
}

declare ptr @sdstrim(ptr noundef, ptr noundef) local_unnamed_addr #4

; Function Attrs: nounwind
declare i32 @raise(i32 noundef) local_unnamed_addr #3

; Function Attrs: nofree nounwind
declare noundef i32 @unsetenv(ptr nocapture noundef readonly) local_unnamed_addr #2

; Function Attrs: nofree nounwind
declare noundef i32 @fputs(ptr nocapture noundef readonly, ptr nocapture noundef) local_unnamed_addr #33

; Function Attrs: nofree nounwind willreturn memory(argmem: read)
declare i32 @bcmp(ptr nocapture, ptr nocapture, i64) local_unnamed_addr #34

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umin.i64(i64, i64) #35

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #35

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #35

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #35

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umax.i32(i32, i32) #35

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #35

; Function Attrs: nofree nounwind
declare noundef i64 @fwrite(ptr nocapture noundef, i64 noundef, i64 noundef, ptr nocapture noundef) local_unnamed_addr #33

; Function Attrs: nofree nounwind
declare noundef i32 @fputc(i32 noundef, ptr nocapture noundef) local_unnamed_addr #33

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #36

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #36

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write)
declare void @llvm.assume(i1 noundef) #37

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i4 @llvm.ctpop.i4(i4) #35

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nofree nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #6 = { nofree "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { mustprogress nofree nounwind willreturn memory(argmem: read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nofree nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { noreturn nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { mustprogress nofree nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { mustprogress nofree nounwind willreturn memory(read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { mustprogress nofree nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #16 = { mustprogress nofree nounwind willreturn memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #17 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #18 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #19 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #20 = { nofree norecurse nosync nounwind memory(read, argmem: none, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #21 = { nofree norecurse nosync nounwind memory(read, argmem: write, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #22 = { mustprogress nofree nosync nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #23 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #24 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #25 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #26 = { allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #27 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #28 = { mustprogress nofree norecurse nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #29 = { mustprogress nofree nounwind willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #30 = { nofree nounwind memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #31 = { nofree nounwind memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #32 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #33 = { nofree nounwind }
attributes #34 = { nofree nounwind willreturn memory(argmem: read) }
attributes #35 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #36 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #37 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: write) }
attributes #38 = { nounwind }
attributes #39 = { nounwind willreturn memory(read) }
attributes #40 = { noreturn nounwind }
attributes #41 = { nounwind willreturn memory(none) }
attributes #42 = { nounwind allocsize(0) }
attributes #43 = { nounwind allocsize(1) }
attributes #44 = { cold }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = !{i64 0, i64 65}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = !{i32 0, i32 2}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = !{i32 -1, i32 1}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = !{i32 0, i32 3}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = !{i4 0, i4 5}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
