; ModuleID = 'bench/redis/original/cluster_legacy.ll'
source_filename = "bench/redis/original/cluster_legacy.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.redisServer = type { i32, i64, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i32, i64, i32, i32, i32, ptr, ptr, i32, i32, i64, ptr, ptr, ptr, ptr, [2 x i32], i32, i32, i32, i32, i32, [16 x ptr], i32, ptr, ptr, i32, [8 x %struct.connListener], i32, %struct.connListener, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i32, ptr, [3 x %struct.pause_event], [256 x i8], ptr, i64, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, ptr, i64, i64, i64, %struct.malloc_stats, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, [4 x i64], i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [7 x %struct.anon], i64, i64, i64, i64, i64, i64, [4 x %struct.durationStats], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i32, ptr, [3 x %struct.clientBufferLimitsConfig], i32, i32, ptr, i32, i32, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, ptr, i32, i64, i64, i64, i64, ptr, i32, ptr, i32, i32, i32, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, ptr, i32, i32, ptr, i32, i32, i32, [2 x i32], i32, %struct.redisOpArray, i32, ptr, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [41 x i8], [41 x i8], i64, i64, i64, i64, i32, i32, ptr, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, ptr, ptr, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, ptr, i32, ptr, i64, i32, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i64, i32, ptr, i32, i32, i64, i64, i32, i32, i32, i32, i32, i64, [3 x i32], i32, i32, i32, [9 x i32], ptr, ptr, i32, i64, ptr, ptr, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i32, i64, i64, i64, i64, i64, ptr, ptr, i32, ptr, i32, i32, i32, i64, i64, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i64, i32, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, i64, ptr, i32, %struct.aclInfo, i32, i64, i32, i32, i32, %struct.redisTLSContextConfig, ptr, ptr, ptr, ptr, ptr, i64, i32, ptr, i32, i32, i32, i64, i32, ptr }
%struct.connListener = type { [16 x i32], i32, ptr, i32, i32, ptr, ptr }
%struct.pause_event = type { i32, i64 }
%struct.malloc_stats = type { i64, i64, i64, i64, i64 }
%struct.anon = type { i64, i64, [16 x i64], i32 }
%struct.durationStats = type { i64, i64, i64 }
%struct.clientBufferLimitsConfig = type { i64, i64, i64 }
%struct.redisOpArray = type { ptr, i32, i32 }
%struct.aclInfo = type { i64, i64, i64, i64 }
%struct.redisTLSContextConfig = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32 }
%struct.dictType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.auxFieldHandler = type { ptr, ptr, ptr, ptr }
%struct.redisNodeFlags = type { i16, ptr }
%struct.sharedObjectsStruct = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [4 x ptr], [4 x ptr], [4 x ptr], [4 x ptr], ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr], [10000 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], ptr, ptr }
%struct._clusterNode = type { i64, [40 x i8], [40 x i8], i32, i64, [2048 x i8], ptr, i32, i32, i32, ptr, ptr, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i8], ptr, ptr, i32, i32, i32, ptr, ptr, ptr }
%struct.clusterState = type { ptr, i64, i32, i32, ptr, ptr, ptr, [16384 x ptr], [16384 x ptr], [16384 x ptr], ptr, i64, i32, i32, i32, i64, i32, i64, ptr, i64, i32, i64, i32, [11 x i64], [11 x i64], i64, i64, [2048 x i8] }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }
%struct.list = type { ptr, ptr, ptr, ptr, ptr, i64 }
%struct.ConnectionType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.clusterLink = type { i64, ptr, ptr, i64, i64, ptr, i64, i64, ptr, i32 }
%struct.clusterMsgSendBlock = type { i64, i32, %struct.clusterMsg }
%struct.clusterMsg = type { [4 x i8], i32, i16, i16, i16, i16, i64, i64, i64, [40 x i8], [2048 x i8], [40 x i8], [46 x i8], i16, [30 x i8], i16, i16, i16, i8, [3 x i8], %union.clusterMsgData }
%union.clusterMsgData = type { %struct.anon.3 }
%struct.anon.3 = type { %struct.clusterMsgDataUpdate }
%struct.clusterMsgDataUpdate = type { i64, [40 x i8], [2048 x i8] }
%struct.connection = type { ptr, i32, i32, i32, i16, i16, i16, ptr, ptr, ptr, ptr }
%struct.dict = type { ptr, [2 x ptr], [2 x i64], i64, i16, [2 x i8], [0 x ptr] }
%struct.listIter = type { ptr, i32 }
%struct.listNode = type { ptr, ptr, ptr }
%struct.clusterNodeFailReport = type { ptr, i64 }
%struct.sockaddr_storage = type { i16, [118 x i8], i64 }
%struct.sockaddr_in = type { i16, i16, %struct.in_addr, [8 x i8] }
%struct.in_addr = type { i32 }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.in6_addr = type { %union.anon }
%union.anon = type { [4 x i32] }
%struct.clusterMsgDataGossip = type { [40 x i8], i32, i32, [46 x i8], i16, i16, i16, i16, i16 }
%struct.redisDb = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i64, i64, ptr, i32, [2 x %struct.dbDictState] }
%struct.dbDictState = type { i32, i32, i64, i64, ptr }
%struct.clusterMsgPingExt = type { i32, i16, i16, [0 x %union.anon.5] }
%union.anon.5 = type { %struct.clusterMsgPingExtForgottenNode }
%struct.clusterMsgPingExtForgottenNode = type { [40 x i8], i64 }
%struct.redisObject = type { i32, i32, ptr }
%struct.client = type { i64, i64, ptr, i32, ptr, ptr, ptr, ptr, ptr, i64, i64, i32, ptr, i32, i32, ptr, i64, ptr, ptr, ptr, ptr, i32, i32, i64, ptr, i64, ptr, i64, i64, i64, i32, ptr, i64, i64, i32, i32, i32, i32, i64, i64, ptr, i64, i64, i64, i64, i64, i64, i64, i64, [41 x i8], i32, ptr, i32, i32, %struct.multiState, %struct.blockingState, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, i32, ptr, ptr, ptr, i64, %struct.listNode, i64, i64, i32, i64, ptr }
%struct.multiState = type { ptr, i32, i32, i32, i64, i32 }
%struct.blockingState = type { i32, i64, i32, ptr, i32, i32, i64, ptr, ptr }
%struct.raxIterator = type { i32, ptr, ptr, ptr, i64, i64, [128 x i8], ptr, %struct.raxStack, ptr }
%struct.raxStack = type { ptr, i64, i64, [32 x ptr], i32 }

@myself = dso_local local_unnamed_addr global ptr null, align 8
@server = external global %struct.redisServer, align 8
@clusterNodesDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@clusterNodesBlackListDictType = dso_local global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@clusterSdsToListType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr @dictListDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@.str = private unnamed_addr constant [9 x i8] c"shard-id\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"nodename\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c"tcp-port\00", align 1
@.str.3 = private unnamed_addr constant [9 x i8] c"tls-port\00", align 1
@auxFieldHandlers = dso_local local_unnamed_addr global [4 x %struct.auxFieldHandler] [%struct.auxFieldHandler { ptr @.str, ptr @auxShardIdSetter, ptr @auxShardIdGetter, ptr @auxShardIdPresent }, %struct.auxFieldHandler { ptr @.str.1, ptr @auxHumanNodenameSetter, ptr @auxHumanNodenameGetter, ptr @auxHumanNodenamePresent }, %struct.auxFieldHandler { ptr @.str.2, ptr @auxTcpPortSetter, ptr @auxTcpPortGetter, ptr @auxTcpPortPresent }, %struct.auxFieldHandler { ptr @.str.3, ptr @auxTlsPortSetter, ptr @auxTlsPortGetter, ptr @auxTlsPortPresent }], align 16
@.str.4 = private unnamed_addr constant [6 x i8] c"%.40s\00", align 1
@.str.5 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.6 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.7 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.8 = private unnamed_addr constant [44 x i8] c"Loading the cluster node config from %s: %s\00", align 1
@.str.9 = private unnamed_addr constant [58 x i8] c"Unable to obtain the cluster node config file stat %s: %s\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"vars\00", align 1
@.str.11 = private unnamed_addr constant [13 x i8] c"currentEpoch\00", align 1
@.str.12 = private unnamed_addr constant [14 x i8] c"lastVoteEpoch\00", align 1
@.str.13 = private unnamed_addr constant [46 x i8] c"Skipping unknown cluster config variable '%s'\00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.15 = private unnamed_addr constant [2 x i8] c"=\00", align 1
@.str.16 = private unnamed_addr constant [7 x i8] c"myself\00", align 1
@.str.17 = private unnamed_addr constant [31 x i8] c"server.cluster->myself == NULL\00", align 1
@.str.18 = private unnamed_addr constant [17 x i8] c"cluster_legacy.c\00", align 1
@.str.19 = private unnamed_addr constant [7 x i8] c"master\00", align 1
@.str.20 = private unnamed_addr constant [6 x i8] c"slave\00", align 1
@.str.21 = private unnamed_addr constant [6 x i8] c"fail?\00", align 1
@.str.22 = private unnamed_addr constant [5 x i8] c"fail\00", align 1
@.str.23 = private unnamed_addr constant [10 x i8] c"handshake\00", align 1
@.str.24 = private unnamed_addr constant [7 x i8] c"noaddr\00", align 1
@.str.25 = private unnamed_addr constant [11 x i8] c"nofailover\00", align 1
@.str.26 = private unnamed_addr constant [8 x i8] c"noflags\00", align 1
@.str.27 = private unnamed_addr constant [42 x i8] c"Unknown flag in redis cluster config file\00", align 1
@.str.28 = private unnamed_addr constant [10 x i8] c"p != NULL\00", align 1
@.str.29 = private unnamed_addr constant [37 x i8] c"Node configuration loaded, I'm %.40s\00", align 1
@.str.30 = private unnamed_addr constant [57 x i8] c"Unrecoverable error: corrupted cluster config file \22%s\22.\00", align 1
@.str.31 = private unnamed_addr constant [43 x i8] c"vars currentEpoch %llu lastVoteEpoch %llu\0A\00", align 1
@.str.32 = private unnamed_addr constant [13 x i8] c"%s.tmp-%i-%I\00", align 1
@.str.33 = private unnamed_addr constant [44 x i8] c"Could not open temp cluster config file: %s\00", align 1
@.str.34 = private unnamed_addr constant [64 x i8] c"Failed after writing (%zd) bytes to tmp cluster config file: %s\00", align 1
@.str.35 = private unnamed_addr constant [43 x i8] c"Could not sync tmp cluster config file: %s\00", align 1
@.str.36 = private unnamed_addr constant [45 x i8] c"Could not rename tmp cluster config file: %s\00", align 1
@.str.37 = private unnamed_addr constant [43 x i8] c"Could not sync cluster config file dir: %s\00", align 1
@.str.38 = private unnamed_addr constant [41 x i8] c"Fatal: can't update cluster config file.\00", align 1
@.str.39 = private unnamed_addr constant [45 x i8] c"Can't open %s in order to acquire a lock: %s\00", align 1
@.str.40 = private unnamed_addr constant [173 x i8] c"Sorry, the cluster configuration file %s is already used by a different Redis Cluster node. Please make sure that different nodes use different cluster configuration files.\00", align 1
@.str.41 = private unnamed_addr constant [26 x i8] c"Impossible to lock %s: %s\00", align 1
@clusterUpdateMyselfIp.prev_ip = internal unnamed_addr global ptr null, align 8
@.str.42 = private unnamed_addr constant [42 x i8] c"No cluster configuration found, I'm %.40s\00", align 1
@.str.43 = private unnamed_addr constant [153 x i8] c"Redis port number too high. Cluster communication port is 10,000 port numbers higher than your Redis port. Your Redis port number must be 55535 or less.\00", align 1
@.str.44 = private unnamed_addr constant [71 x i8] c"No bind address is configured, but it is required for the Cluster bus.\00", align 1
@.str.45 = private unnamed_addr constant [68 x i8] c"Missing connection type %s, but it is required for the Cluster bus.\00", align 1
@.str.46 = private unnamed_addr constant [49 x i8] c"Failed listening on port %u (cluster), aborting.\00", align 1
@.str.47 = private unnamed_addr constant [66 x i8] c"Unrecoverable error creating Redis Cluster socket accept handler.\00", align 1
@.str.48 = private unnamed_addr constant [44 x i8] c"configEpoch set to 0 via CLUSTER RESET HARD\00", align 1
@.str.49 = private unnamed_addr constant [31 x i8] c"Node hard reset, now I'm %.40s\00", align 1
@.str.50 = private unnamed_addr constant [15 x i8] c"!link->inbound\00", align 1
@.str.51 = private unnamed_addr constant [14 x i8] c"link->inbound\00", align 1
@.str.52 = private unnamed_addr constant [12 x i8] c"!link->node\00", align 1
@.str.53 = private unnamed_addr constant [56 x i8] c"Replacing inbound link fd %d from node %.40s with fd %d\00", align 1
@.str.54 = private unnamed_addr constant [20 x i8] c"!node->inbound_link\00", align 1
@.str.55 = private unnamed_addr constant [33 x i8] c"Error accepting cluster node: %s\00", align 1
@.str.56 = private unnamed_addr constant [60 x i8] c"Error creating an accepting connection for cluster node: %s\00", align 1
@.str.57 = private unnamed_addr constant [45 x i8] c"Accepting cluster node connection from %s:%d\00", align 1
@.str.58 = private unnamed_addr constant [44 x i8] c"Error accepting cluster node connection: %s\00", align 1
@.str.59 = private unnamed_addr constant [54 x i8] c"dictDelete(server.cluster->nodes,nodename) == DICT_OK\00", align 1
@.str.60 = private unnamed_addr constant [18 x i8] c"retval == DICT_OK\00", align 1
@.str.61 = private unnamed_addr constant [31 x i8] c"Renaming node %.40s into %.40s\00", align 1
@.str.62 = private unnamed_addr constant [49 x i8] c"dictAdd(server.cluster->shards, s, l) == DICT_OK\00", align 1
@.str.63 = private unnamed_addr constant [28 x i8] c"New configEpoch set to %llu\00", align 1
@.str.64 = private unnamed_addr constant [77 x i8] c"WARNING: configEpoch collision with node %.40s (%s). configEpoch set to %llu\00", align 1
@.str.65 = private unnamed_addr constant [53 x i8] c"Marking node %.40s (%s) as failing (quorum reached).\00", align 1
@.str.66 = private unnamed_addr constant [17 x i8] c"nodeFailed(node)\00", align 1
@.str.67 = private unnamed_addr constant [60 x i8] c"Clear FAIL state for node %.40s (%s):%s is reachable again.\00", align 1
@.str.68 = private unnamed_addr constant [8 x i8] c"replica\00", align 1
@.str.69 = private unnamed_addr constant [21 x i8] c"master without slots\00", align 1
@.str.70 = private unnamed_addr constant [106 x i8] c"Clear FAIL state for node %.40s (%s): is reachable again and nobody is serving its slots after some time.\00", align 1
@.str.71 = private unnamed_addr constant [25 x i8] c"GOSSIP %.40s %s:%d@%d %s\00", align 1
@.str.72 = private unnamed_addr constant [59 x i8] c"Node %.40s (%s) reported node %.40s (%s) as not reachable.\00", align 1
@.str.73 = private unnamed_addr constant [57 x i8] c"Node %.40s (%s) reported node %.40s (%s) is back online.\00", align 1
@.str.74 = private unnamed_addr constant [39 x i8] c"Error converting peer IP to string: %s\00", align 1
@.str.75 = private unnamed_addr constant [8 x i8] c"no link\00", align 1
@.str.76 = private unnamed_addr constant [47 x i8] c"Address updated for node %.40s (%s), now %s:%d\00", align 1
@.str.77 = private unnamed_addr constant [40 x i8] c"Discarding UPDATE message about myself.\00", align 1
@.str.78 = private unnamed_addr constant [79 x i8] c"Configuration change detected. Reconfiguring myself as a replica of %.40s (%s)\00", align 1
@.str.79 = private unnamed_addr constant [79 x i8] c"I'm a sub-replica! Reconfiguring myself as a replica of grandmaster %.40s (%s)\00", align 1
@.str.80 = private unnamed_addr constant [35 x i8] c"Received unknown extension type %d\00", align 1
@.str.81 = private unnamed_addr constant [44 x i8] c"--- Processing packet of type %s, %lu bytes\00", align 1
@.str.82 = private unnamed_addr constant [47 x i8] c"Dropping packet that matches debug drop filter\00", align 1
@.str.83 = private unnamed_addr constant [55 x i8] c"Received a %s packet without proper padding (%d bytes)\00", align 1
@.str.84 = private unnamed_addr constant [87 x i8] c"Received invalid %s packet with extension data that exceeds total packet length (%lld)\00", align 1
@.str.85 = private unnamed_addr constant [67 x i8] c"Received invalid %s packet of length %lld but expected length %lld\00", align 1
@.str.86 = private unnamed_addr constant [68 x i8] c"Received replication offset for paused master manual failover: %lld\00", align 1
@.str.87 = private unnamed_addr constant [39 x i8] c"IP address for this node updated to %s\00", align 1
@.str.88 = private unnamed_addr constant [47 x i8] c"nodeIp2String(node->ip,link,hdr->myip) == C_OK\00", align 1
@.str.89 = private unnamed_addr constant [26 x i8] c"%s packet received: %.40s\00", align 1
@.str.90 = private unnamed_addr constant [5 x i8] c"NULL\00", align 1
@.str.91 = private unnamed_addr constant [76 x i8] c"Handshake: we already know node %.40s (%s), updating the address if needed.\00", align 1
@.str.92 = private unnamed_addr constant [37 x i8] c"Handshake with node %.40s completed.\00", align 1
@.str.93 = private unnamed_addr constant [87 x i8] c"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d\00", align 1
@.str.94 = private unnamed_addr constant [41 x i8] zeroinitializer, align 1
@.str.95 = private unnamed_addr constant [78 x i8] c"Node %.40s has old slots configuration, sending an UPDATE message about %.40s\00", align 1
@.str.96 = private unnamed_addr constant [55 x i8] c"FAIL message received from %.40s (%s) about %.40s (%s)\00", align 1
@.str.97 = private unnamed_addr constant [58 x i8] c"Ignoring FAIL message from unknown node %.40s about %.40s\00", align 1
@.str.98 = private unnamed_addr constant [49 x i8] c"Manual failover requested by replica %.40s (%s).\00", align 1
@.str.99 = private unnamed_addr constant [33 x i8] c"Received unknown packet type: %d\00", align 1
@.str.100 = private unnamed_addr constant [35 x i8] c"I/O error writing to node link: %s\00", align 1
@.str.101 = private unnamed_addr constant [12 x i8] c"short write\00", align 1
@.str.102 = private unnamed_addr constant [35 x i8] c"(msg_offset + nwritten) == msg_len\00", align 1
@.str.103 = private unnamed_addr constant [47 x i8] c"Connection with Node %.40s at %s:%d failed: %s\00", align 1
@.str.104 = private unnamed_addr constant [36 x i8] c"Connecting with Node %.40s at %s:%d\00", align 1
@.str.105 = private unnamed_addr constant [5 x i8] c"RCmb\00", align 1
@.str.106 = private unnamed_addr constant [61 x i8] c"Bad message length or signature received on the Cluster bus.\00", align 1
@.str.107 = private unnamed_addr constant [71 x i8] c"Bad message length or signature received on the Cluster bus from %s:%d\00", align 1
@.str.108 = private unnamed_addr constant [37 x i8] c"I/O error reading from node link: %s\00", align 1
@.str.109 = private unnamed_addr constant [18 x i8] c"connection closed\00", align 1
@clusterSendPing.cluster_pings_sent = internal unnamed_addr global i64 0, align 8
@.str.110 = private unnamed_addr constant [24 x i8] c"gossipcount < USHRT_MAX\00", align 1
@.str.111 = private unnamed_addr constant [23 x i8] c"nodes_for_slot != NULL\00", align 1
@.str.112 = private unnamed_addr constant [69 x i8] c"Failover auth denied to %.40s (%s): reqEpoch (%llu) < curEpoch(%llu)\00", align 1
@.str.113 = private unnamed_addr constant [65 x i8] c"Failover auth denied to %.40s (%s): already voted for epoch %llu\00", align 1
@.str.114 = private unnamed_addr constant [56 x i8] c"Failover auth denied to %.40s (%s): it is a master node\00", align 1
@.str.115 = private unnamed_addr constant [60 x i8] c"Failover auth denied to %.40s (%s): I don't know its master\00", align 1
@.str.116 = private unnamed_addr constant [53 x i8] c"Failover auth denied to %.40s (%s): its master is up\00", align 1
@.str.117 = private unnamed_addr constant [88 x i8] c"Failover auth denied to %.40s %s: can't vote about this master before %lld milliseconds\00", align 1
@.str.118 = private unnamed_addr constant [75 x i8] c"Failover auth denied to %.40s (%s): slot %d epoch (%llu) > reqEpoch (%llu)\00", align 1
@.str.119 = private unnamed_addr constant [51 x i8] c"Failover auth granted to %.40s (%s) for epoch %llu\00", align 1
@.str.120 = private unnamed_addr constant [20 x i8] c"nodeIsSlave(myself)\00", align 1
@clusterLogCantFailover.lastlog_time = internal unnamed_addr global i64 0, align 8
@.str.121 = private unnamed_addr constant [123 x i8] c"Disconnected from master for longer than allowed. Please check the 'cluster-replica-validity-factor' configuration option.\00", align 1
@.str.122 = private unnamed_addr constant [53 x i8] c"Waiting the delay before I can start a new failover.\00", align 1
@.str.123 = private unnamed_addr constant [26 x i8] c"Failover attempt expired.\00", align 1
@.str.124 = private unnamed_addr constant [51 x i8] c"Waiting for votes, but majority still not reached.\00", align 1
@.str.125 = private unnamed_addr constant [21 x i8] c"Unknown reason code.\00", align 1
@.str.126 = private unnamed_addr constant [33 x i8] c"Currently unable to failover: %s\00", align 1
@.str.127 = private unnamed_addr constant [55 x i8] c"Needed quorum: %d. Number of votes received so far: %d\00", align 1
@.str.128 = private unnamed_addr constant [73 x i8] c"Start of election delayed for %lld milliseconds (rank #%d, offset %lld).\00", align 1
@.str.129 = private unnamed_addr constant [63 x i8] c"Replica rank updated to #%d, added %lld milliseconds of delay.\00", align 1
@.str.130 = private unnamed_addr constant [45 x i8] c"Starting a failover election for epoch %llu.\00", align 1
@.str.131 = private unnamed_addr constant [43 x i8] c"Failover election won: I'm the new master.\00", align 1
@.str.132 = private unnamed_addr constant [50 x i8] c"configEpoch set to %llu after successful failover\00", align 1
@.str.133 = private unnamed_addr constant [35 x i8] c"Migrating to orphaned master %.40s\00", align 1
@.str.134 = private unnamed_addr constant [27 x i8] c"Manual failover timed out.\00", align 1
@.str.135 = private unnamed_addr constant [68 x i8] c"All master replication stream processed, manual failover can start.\00", align 1
@clusterCron.iteration = internal unnamed_addr global i64 0, align 8
@.str.136 = private unnamed_addr constant [19 x i8] c"Pinging node %.40s\00", align 1
@.str.137 = private unnamed_addr constant [32 x i8] c"*** NODE %.40s possibly failing\00", align 1
@.str.138 = private unnamed_addr constant [37 x i8] c"clusterNodeClearSlotBit(n,slot) == 1\00", align 1
@clusterUpdateState.among_minority_time = internal unnamed_addr global i64 0, align 8
@clusterUpdateState.first_call_time = internal unnamed_addr global i64 0, align 8
@.str.139 = private unnamed_addr constant [26 x i8] c"Cluster state changed: %s\00", align 1
@.str.140 = private unnamed_addr constant [3 x i8] c"ok\00", align 1
@.str.141 = private unnamed_addr constant [66 x i8] c"I have keys for unassigned slot %d. Taking responsibility for it.\00", align 1
@.str.142 = private unnamed_addr constant [98 x i8] c"I have keys for slot %d, but the slot is assigned to another node. Setting it to importing state.\00", align 1
@.str.143 = private unnamed_addr constant [12 x i8] c"n != myself\00", align 1
@.str.144 = private unnamed_addr constant [22 x i8] c"myself->numslots == 0\00", align 1
@redisNodeFlagsTable = internal unnamed_addr constant [8 x %struct.redisNodeFlags] [%struct.redisNodeFlags { i16 16, ptr @.str.309 }, %struct.redisNodeFlags { i16 1, ptr @.str.310 }, %struct.redisNodeFlags { i16 2, ptr @.str.311 }, %struct.redisNodeFlags { i16 4, ptr @.str.312 }, %struct.redisNodeFlags { i16 8, ptr @.str.313 }, %struct.redisNodeFlags { i16 32, ptr @.str.314 }, %struct.redisNodeFlags { i16 64, ptr @.str.315 }, %struct.redisNodeFlags { i16 512, ptr @.str.316 }], align 16
@.str.145 = private unnamed_addr constant [9 x i8] c"noflags,\00", align 1
@.str.146 = private unnamed_addr constant [4 x i8] c" %i\00", align 1
@.str.147 = private unnamed_addr constant [7 x i8] c" %i-%i\00", align 1
@.str.148 = private unnamed_addr constant [10 x i8] c" %s:%i@%i\00", align 1
@.str.149 = private unnamed_addr constant [4 x i8] c",%s\00", align 1
@.str.150 = private unnamed_addr constant [5 x i8] c",%s=\00", align 1
@.str.151 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.152 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.153 = private unnamed_addr constant [13 x i8] c" %I %I %U %s\00", align 1
@.str.154 = private unnamed_addr constant [10 x i8] c"connected\00", align 1
@.str.155 = private unnamed_addr constant [13 x i8] c"disconnected\00", align 1
@.str.156 = private unnamed_addr constant [14 x i8] c" [%d->-%.40s]\00", align 1
@.str.157 = private unnamed_addr constant [14 x i8] c" [%d-<-%.40s]\00", align 1
@.str.158 = private unnamed_addr constant [51 x i8] c"(n->slot_info_pairs_count + 1) < (2 * n->numslots)\00", align 1
@.str.159 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.160 = private unnamed_addr constant [10 x i8] c"direction\00", align 1
@.str.161 = private unnamed_addr constant [5 x i8] c"from\00", align 1
@.str.162 = private unnamed_addr constant [3 x i8] c"to\00", align 1
@.str.163 = private unnamed_addr constant [11 x i8] c"link->node\00", align 1
@.str.164 = private unnamed_addr constant [5 x i8] c"node\00", align 1
@.str.165 = private unnamed_addr constant [12 x i8] c"create-time\00", align 1
@.str.166 = private unnamed_addr constant [7 x i8] c"events\00", align 1
@.str.167 = private unnamed_addr constant [22 x i8] c"send-buffer-allocated\00", align 1
@.str.168 = private unnamed_addr constant [17 x i8] c"send-buffer-used\00", align 1
@.str.169 = private unnamed_addr constant [5 x i8] c"ping\00", align 1
@.str.170 = private unnamed_addr constant [5 x i8] c"pong\00", align 1
@.str.171 = private unnamed_addr constant [5 x i8] c"meet\00", align 1
@.str.172 = private unnamed_addr constant [8 x i8] c"publish\00", align 1
@.str.173 = private unnamed_addr constant [13 x i8] c"publishshard\00", align 1
@.str.174 = private unnamed_addr constant [9 x i8] c"auth-req\00", align 1
@.str.175 = private unnamed_addr constant [9 x i8] c"auth-ack\00", align 1
@.str.176 = private unnamed_addr constant [7 x i8] c"update\00", align 1
@.str.177 = private unnamed_addr constant [8 x i8] c"mfstart\00", align 1
@.str.178 = private unnamed_addr constant [7 x i8] c"module\00", align 1
@.str.179 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.180 = private unnamed_addr constant [29 x i8] c"Invalid or out of range slot\00", align 1
@.str.181 = private unnamed_addr constant [30 x i8] c"Slot %d is already unassigned\00", align 1
@.str.182 = private unnamed_addr constant [24 x i8] c"Slot %d is already busy\00", align 1
@.str.183 = private unnamed_addr constant [33 x i8] c"Slot %d specified multiple times\00", align 1
@.str.184 = private unnamed_addr constant [15 x i8] c"retval == C_OK\00", align 1
@.str.185 = private unnamed_addr constant [3 x i8] c"id\00", align 1
@.str.186 = private unnamed_addr constant [5 x i8] c"port\00", align 1
@.str.187 = private unnamed_addr constant [3 x i8] c"ip\00", align 1
@.str.188 = private unnamed_addr constant [9 x i8] c"endpoint\00", align 1
@.str.189 = private unnamed_addr constant [9 x i8] c"hostname\00", align 1
@.str.190 = private unnamed_addr constant [5 x i8] c"role\00", align 1
@.str.191 = private unnamed_addr constant [19 x i8] c"replication-offset\00", align 1
@.str.192 = private unnamed_addr constant [7 x i8] c"health\00", align 1
@.str.193 = private unnamed_addr constant [8 x i8] c"loading\00", align 1
@.str.194 = private unnamed_addr constant [7 x i8] c"online\00", align 1
@.str.195 = private unnamed_addr constant [22 x i8] c"listLength(nodes) > 0\00", align 1
@.str.196 = private unnamed_addr constant [6 x i8] c"slots\00", align 1
@.str.197 = private unnamed_addr constant [36 x i8] c"(n->slot_info_pairs_count % 2) == 0\00", align 1
@.str.198 = private unnamed_addr constant [6 x i8] c"nodes\00", align 1
@__const.genClusterInfoString.statestr = private unnamed_addr constant [2 x ptr] [ptr @.str.140, ptr @.str.22], align 16
@.str.199 = private unnamed_addr constant [207 x i8] c"cluster_state:%s\0D\0Acluster_slots_assigned:%d\0D\0Acluster_slots_ok:%d\0D\0Acluster_slots_pfail:%d\0D\0Acluster_slots_fail:%d\0D\0Acluster_known_nodes:%lu\0D\0Acluster_size:%d\0D\0Acluster_current_epoch:%llu\0D\0Acluster_my_epoch:%llu\0D\0A\00", align 1
@.str.200 = private unnamed_addr constant [38 x i8] c"cluster_stats_messages_%s_sent:%lld\0D\0A\00", align 1
@.str.201 = private unnamed_addr constant [35 x i8] c"cluster_stats_messages_sent:%lld\0D\0A\00", align 1
@.str.202 = private unnamed_addr constant [42 x i8] c"cluster_stats_messages_%s_received:%lld\0D\0A\00", align 1
@.str.203 = private unnamed_addr constant [39 x i8] c"cluster_stats_messages_received:%lld\0D\0A\00", align 1
@.str.204 = private unnamed_addr constant [49 x i8] c"total_cluster_links_buffer_limit_exceeded:%llu\0D\0A\00", align 1
@.str.205 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str.206 = private unnamed_addr constant [4 x i8] c"del\00", align 1
@.str.207 = private unnamed_addr constant [12 x i8] c"CLUSTERLINK\00", align 1
@.str.208 = private unnamed_addr constant [5 x i8] c"KILL\00", align 1
@.str.209 = private unnamed_addr constant [60 x i8] c"Debug option only available for cluster mode enabled setup!\00", align 1
@.str.210 = private unnamed_addr constant [16 x i8] c"Unknown node %s\00", align 1
@.str.211 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.212 = private unnamed_addr constant [21 x i8] c"Unknown direction %s\00", align 1
@shared = external local_unnamed_addr global %struct.sharedObjectsStruct, align 8
@clusterDebugCommandExtendedHelp.help = internal global [3 x ptr] [ptr @.str.213, ptr @.str.214, ptr null], align 16
@.str.213 = private unnamed_addr constant [41 x i8] c"CLUSTERLINK KILL <to|from|all> <node-id>\00", align 1
@.str.214 = private unnamed_addr constant [81 x i8] c"    Kills the link based on the direction to/from (both) with the provided node.\00", align 1
@.str.215 = private unnamed_addr constant [32 x i8] c"Invalid base port specified: %s\00", align 1
@.str.216 = private unnamed_addr constant [31 x i8] c"Invalid bus port specified: %s\00", align 1
@.str.217 = private unnamed_addr constant [38 x i8] c"Invalid node address specified: %s:%s\00", align 1
@.str.218 = private unnamed_addr constant [11 x i8] c"flushslots\00", align 1
@.str.219 = private unnamed_addr constant [48 x i8] c"DB must be empty to perform CLUSTER FLUSHSLOTS.\00", align 1
@.str.220 = private unnamed_addr constant [9 x i8] c"addslots\00", align 1
@.str.221 = private unnamed_addr constant [9 x i8] c"delslots\00", align 1
@.str.222 = private unnamed_addr constant [14 x i8] c"addslotsrange\00", align 1
@.str.223 = private unnamed_addr constant [14 x i8] c"delslotsrange\00", align 1
@.str.224 = private unnamed_addr constant [56 x i8] c"start slot number %d is greater than end slot number %d\00", align 1
@.str.225 = private unnamed_addr constant [8 x i8] c"setslot\00", align 1
@.str.226 = private unnamed_addr constant [38 x i8] c"Please use SETSLOT only with masters.\00", align 1
@.str.227 = private unnamed_addr constant [10 x i8] c"migrating\00", align 1
@.str.228 = private unnamed_addr constant [34 x i8] c"I'm not the owner of hash slot %u\00", align 1
@.str.229 = private unnamed_addr constant [27 x i8] c"I don't know about node %s\00", align 1
@.str.230 = private unnamed_addr constant [28 x i8] c"Target node is not a master\00", align 1
@.str.231 = private unnamed_addr constant [10 x i8] c"importing\00", align 1
@.str.232 = private unnamed_addr constant [38 x i8] c"I'm already the owner of hash slot %u\00", align 1
@.str.233 = private unnamed_addr constant [7 x i8] c"stable\00", align 1
@.str.234 = private unnamed_addr constant [89 x i8] c"Can't assign hashslot %d to a different node while I still hold keys for this hash slot.\00", align 1
@.str.235 = private unnamed_addr constant [44 x i8] c"configEpoch updated after importing slot %d\00", align 1
@.str.236 = private unnamed_addr constant [72 x i8] c"Invalid CLUSTER SETSLOT action or number of arguments. Try CLUSTER HELP\00", align 1
@.str.237 = private unnamed_addr constant [10 x i8] c"bumpepoch\00", align 1
@.str.238 = private unnamed_addr constant [11 x i8] c"+%s %llu\0D\0A\00", align 1
@.str.239 = private unnamed_addr constant [7 x i8] c"BUMPED\00", align 1
@.str.240 = private unnamed_addr constant [6 x i8] c"STILL\00", align 1
@.str.241 = private unnamed_addr constant [11 x i8] c"saveconfig\00", align 1
@.str.242 = private unnamed_addr constant [41 x i8] c"error saving the cluster node config: %s\00", align 1
@.str.243 = private unnamed_addr constant [7 x i8] c"forget\00", align 1
@.str.244 = private unnamed_addr constant [42 x i8] c"I tried hard but I can't forget myself...\00", align 1
@.str.245 = private unnamed_addr constant [24 x i8] c"Can't forget my master!\00", align 1
@.str.246 = private unnamed_addr constant [10 x i8] c"replicate\00", align 1
@.str.247 = private unnamed_addr constant [23 x i8] c"Can't replicate myself\00", align 1
@.str.248 = private unnamed_addr constant [46 x i8] c"I can only replicate a master, not a replica.\00", align 1
@.str.249 = private unnamed_addr constant [67 x i8] c"To set a master the node must be empty and without assigned slots.\00", align 1
@.str.250 = private unnamed_addr constant [22 x i8] c"count-failure-reports\00", align 1
@.str.251 = private unnamed_addr constant [9 x i8] c"failover\00", align 1
@.str.252 = private unnamed_addr constant [6 x i8] c"force\00", align 1
@.str.253 = private unnamed_addr constant [9 x i8] c"takeover\00", align 1
@.str.254 = private unnamed_addr constant [46 x i8] c"You should send CLUSTER FAILOVER to a replica\00", align 1
@.str.255 = private unnamed_addr constant [45 x i8] c"I'm a replica but my master is unknown to me\00", align 1
@.str.256 = private unnamed_addr constant [60 x i8] c"Master is down or failed, please use CLUSTER FAILOVER FORCE\00", align 1
@.str.257 = private unnamed_addr constant [39 x i8] c"Taking over the master (user request).\00", align 1
@.str.258 = private unnamed_addr constant [39 x i8] c"Forced failover user request accepted.\00", align 1
@.str.259 = private unnamed_addr constant [39 x i8] c"Manual failover user request accepted.\00", align 1
@.str.260 = private unnamed_addr constant [17 x i8] c"set-config-epoch\00", align 1
@.str.261 = private unnamed_addr constant [37 x i8] c"Invalid config epoch specified: %lld\00", align 1
@.str.262 = private unnamed_addr constant [84 x i8] c"The user can assign a config epoch only when the node does not know any other node.\00", align 1
@.str.263 = private unnamed_addr constant [38 x i8] c"Node config epoch is already non-zero\00", align 1
@.str.264 = private unnamed_addr constant [53 x i8] c"configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH\00", align 1
@.str.265 = private unnamed_addr constant [6 x i8] c"reset\00", align 1
@.str.266 = private unnamed_addr constant [5 x i8] c"hard\00", align 1
@.str.267 = private unnamed_addr constant [5 x i8] c"soft\00", align 1
@.str.268 = private unnamed_addr constant [64 x i8] c"CLUSTER RESET can't be called with master nodes containing keys\00", align 1
@.str.269 = private unnamed_addr constant [6 x i8] c"links\00", align 1
@clusterCommandExtendedHelp.help = internal global [34 x ptr] [ptr @.str.270, ptr @.str.271, ptr @.str.272, ptr @.str.273, ptr @.str.274, ptr @.str.275, ptr @.str.276, ptr @.str.277, ptr @.str.278, ptr @.str.279, ptr @.str.280, ptr @.str.281, ptr @.str.282, ptr @.str.283, ptr @.str.284, ptr @.str.285, ptr @.str.286, ptr @.str.287, ptr @.str.288, ptr @.str.289, ptr @.str.290, ptr @.str.291, ptr @.str.292, ptr @.str.293, ptr @.str.294, ptr @.str.295, ptr @.str.296, ptr @.str.297, ptr @.str.298, ptr @.str.299, ptr @.str.300, ptr @.str.301, ptr @.str.302, ptr null], align 16
@.str.270 = private unnamed_addr constant [29 x i8] c"ADDSLOTS <slot> [<slot> ...]\00", align 1
@.str.271 = private unnamed_addr constant [34 x i8] c"    Assign slots to current node.\00", align 1
@.str.272 = private unnamed_addr constant [68 x i8] c"ADDSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]\00", align 1
@.str.273 = private unnamed_addr constant [80 x i8] c"    Assign slots which are between <start-slot> and <end-slot> to current node.\00", align 1
@.str.274 = private unnamed_addr constant [10 x i8] c"BUMPEPOCH\00", align 1
@.str.275 = private unnamed_addr constant [38 x i8] c"    Advance the cluster config epoch.\00", align 1
@.str.276 = private unnamed_addr constant [32 x i8] c"COUNT-FAILURE-REPORTS <node-id>\00", align 1
@.str.277 = private unnamed_addr constant [52 x i8] c"    Return number of failure reports for <node-id>.\00", align 1
@.str.278 = private unnamed_addr constant [29 x i8] c"DELSLOTS <slot> [<slot> ...]\00", align 1
@.str.279 = private unnamed_addr constant [48 x i8] c"    Delete slots information from current node.\00", align 1
@.str.280 = private unnamed_addr constant [68 x i8] c"DELSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]\00", align 1
@.str.281 = private unnamed_addr constant [94 x i8] c"    Delete slots information which are between <start-slot> and <end-slot> from current node.\00", align 1
@.str.282 = private unnamed_addr constant [26 x i8] c"FAILOVER [FORCE|TAKEOVER]\00", align 1
@.str.283 = private unnamed_addr constant [52 x i8] c"    Promote current replica node to being a master.\00", align 1
@.str.284 = private unnamed_addr constant [17 x i8] c"FORGET <node-id>\00", align 1
@.str.285 = private unnamed_addr constant [36 x i8] c"    Remove a node from the cluster.\00", align 1
@.str.286 = private unnamed_addr constant [11 x i8] c"FLUSHSLOTS\00", align 1
@.str.287 = private unnamed_addr constant [47 x i8] c"    Delete current node own slots information.\00", align 1
@.str.288 = private unnamed_addr constant [30 x i8] c"MEET <ip> <port> [<bus-port>]\00", align 1
@.str.289 = private unnamed_addr constant [42 x i8] c"    Connect nodes into a working cluster.\00", align 1
@.str.290 = private unnamed_addr constant [20 x i8] c"REPLICATE <node-id>\00", align 1
@.str.291 = private unnamed_addr constant [52 x i8] c"    Configure current node as replica to <node-id>.\00", align 1
@.str.292 = private unnamed_addr constant [18 x i8] c"RESET [HARD|SOFT]\00", align 1
@.str.293 = private unnamed_addr constant [40 x i8] c"    Reset current node (default: soft).\00", align 1
@.str.294 = private unnamed_addr constant [25 x i8] c"SET-CONFIG-EPOCH <epoch>\00", align 1
@.str.295 = private unnamed_addr constant [38 x i8] c"    Set config epoch of current node.\00", align 1
@.str.296 = private unnamed_addr constant [79 x i8] c"SETSLOT <slot> (IMPORTING <node-id>|MIGRATING <node-id>|STABLE|NODE <node-id>)\00", align 1
@.str.297 = private unnamed_addr constant [20 x i8] c"    Set slot state.\00", align 1
@.str.298 = private unnamed_addr constant [11 x i8] c"SAVECONFIG\00", align 1
@.str.299 = private unnamed_addr constant [48 x i8] c"    Force saving cluster configuration on disk.\00", align 1
@.str.300 = private unnamed_addr constant [6 x i8] c"LINKS\00", align 1
@.str.301 = private unnamed_addr constant [80 x i8] c"    Return information about all network links between this node and its peers.\00", align 1
@.str.302 = private unnamed_addr constant [96 x i8] c"    Output format is an array where each array element is a map containing attributes of a link\00", align 1
@.str.303 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.304 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.305 = private unnamed_addr constant [76 x i8] c"FAILOVER not allowed in cluster mode. Use CLUSTER FAILOVER command instead.\00", align 1
@.str.306 = private unnamed_addr constant [24 x i8] c"msgblock->refcount >= 0\00", align 1
@.str.307 = private unnamed_addr constant [98 x i8] c"Freeing cluster link(%s node %.40s, used memory: %llu) due to exceeding send buffer memory limit.\00", align 1
@.str.308 = private unnamed_addr constant [48 x i8] c"Unable to connect to Cluster Node [%s]:%d -> %s\00", align 1
@.str.309 = private unnamed_addr constant [8 x i8] c"myself,\00", align 1
@.str.310 = private unnamed_addr constant [8 x i8] c"master,\00", align 1
@.str.311 = private unnamed_addr constant [7 x i8] c"slave,\00", align 1
@.str.312 = private unnamed_addr constant [7 x i8] c"fail?,\00", align 1
@.str.313 = private unnamed_addr constant [6 x i8] c"fail,\00", align 1
@.str.314 = private unnamed_addr constant [11 x i8] c"handshake,\00", align 1
@.str.315 = private unnamed_addr constant [8 x i8] c"noaddr,\00", align 1
@.str.316 = private unnamed_addr constant [12 x i8] c"nofailover,\00", align 1
@switch.table.clusterLogCantFailover = private unnamed_addr constant [4 x ptr] [ptr @.str.121, ptr @.str.122, ptr @.str.123, ptr @.str.124], align 8
@switch.table.genClusterInfoString.15 = private unnamed_addr constant [11 x ptr] [ptr @.str.169, ptr @.str.170, ptr @.str.171, ptr @.str.22, ptr @.str.172, ptr @.str.174, ptr @.str.175, ptr @.str.176, ptr @.str.177, ptr @.str.178, ptr @.str.173], align 8

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @getNodeDefaultClientPort(ptr nocapture noundef readonly %n) local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not = icmp eq i32 %0, 0
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 25
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 24
  %cond.in = select i1 %tobool.not, ptr %tcp_port, ptr %tls_port
  %cond = load i32, ptr %cond.in, align 4
  ret i32 %cond
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @clusterNodeClientPort(ptr nocapture noundef readonly %n, i32 noundef %use_tls) local_unnamed_addr #0 {
entry:
  %tobool.not = icmp eq i32 %use_tls, 0
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 25
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 24
  %cond.in = select i1 %tobool.not, ptr %tcp_port, ptr %tls_port
  %cond = load i32, ptr %cond.in, align 4
  ret i32 %cond
}

declare i64 @dictSdsHash(ptr noundef) #1

declare i32 @dictSdsKeyCompare(ptr noundef, ptr noundef, ptr noundef) #1

declare void @dictSdsDestructor(ptr noundef, ptr noundef) #1

declare i64 @dictSdsCaseHash(ptr noundef) #1

declare i32 @dictSdsKeyCaseCompare(ptr noundef, ptr noundef, ptr noundef) #1

declare void @dictListDestructor(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @auxShardIdSetter(ptr noundef %n, ptr noundef %value, i32 noundef %length) #2 {
entry:
  %call = tail call i32 @verifyClusterNodeId(ptr noundef %value, i32 noundef %length) #33
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 2
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %shard_id, ptr noundef nonnull align 1 dereferenceable(40) %value, i64 40, i1 false)
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 9
  %0 = load i32, ptr %numslaves, align 8
  %cmp19 = icmp sgt i32 %0, 0
  br i1 %cmp19, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %if.end
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 10
  %1 = load ptr, ptr %slaves, align 8
  %wide.trip.count = zext nneg i32 %0 to i64
  br label %for.body

for.cond:                                         ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !5

for.body:                                         ; preds = %for.body.lr.ph, %for.cond
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.cond ]
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %shard_id2 = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 2
  %bcmp = tail call i32 @bcmp(ptr noundef nonnull dereferenceable(40) %shard_id2, ptr noundef nonnull dereferenceable(40) %shard_id, i64 40)
  %cmp7.not = icmp eq i32 %bcmp, 0
  br i1 %cmp7.not, label %for.cond, label %return

for.end:                                          ; preds = %for.cond, %if.end
  tail call void @clusterAddNodeToShard(ptr noundef %value, ptr noundef nonnull %n)
  br label %return

return:                                           ; preds = %for.body, %entry, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ -1, %entry ], [ -1, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @auxShardIdGetter(ptr noundef %n, ptr noundef %s) #2 {
entry:
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 2
  %call = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %s, ptr noundef nonnull @.str.4, ptr noundef nonnull %shard_id) #33
  ret ptr %call
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @auxShardIdPresent(ptr nocapture noundef readonly %n) #3 {
entry:
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 2
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %shard_id) #34
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @auxHumanNodenameSetter(ptr noundef %n, ptr noundef %value, i32 noundef %length) #2 {
entry:
  %tobool.not = icmp eq ptr %n, null
  br i1 %tobool.not, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 23
  %0 = load ptr, ptr %human_nodename, align 8
  %conv = sext i32 %length to i64
  %call = tail call i32 @strncmp(ptr noundef %value, ptr noundef %0, i64 noundef %conv) #34
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %return, label %if.then8

if.else:                                          ; preds = %entry
  %cmp = icmp eq i32 %length, 0
  br i1 %cmp, label %return, label %if.else13

if.then8:                                         ; preds = %land.lhs.true
  %call11 = tail call ptr @sdscpylen(ptr noundef %0, ptr noundef %value, i64 noundef %conv) #33
  store ptr %call11, ptr %human_nodename, align 8
  br label %return

if.else13:                                        ; preds = %if.else
  %1 = load ptr, ptr inttoptr (i64 2320 to ptr), align 16
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %return [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.else13
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.else13
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.else13
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.else13
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.else13
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %cmp16.not = icmp eq i64 %retval.0.i, 0
  br i1 %cmp16.not, label %return, label %if.then18

if.then18:                                        ; preds = %sdslen.exit
  tail call void @sdsclear(ptr noundef nonnull %1) #33
  br label %return

return:                                           ; preds = %if.else13, %if.then8, %if.then18, %sdslen.exit, %if.else, %land.lhs.true
  %retval.0 = phi i32 [ 0, %land.lhs.true ], [ 0, %if.else ], [ -1, %sdslen.exit ], [ 0, %if.then18 ], [ 0, %if.then8 ], [ -1, %if.else13 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @auxHumanNodenameGetter(ptr nocapture noundef readonly %n, ptr noundef %s) #2 {
entry:
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 23
  %0 = load ptr, ptr %human_nodename, align 8
  %call = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %s, ptr noundef nonnull @.str.5, ptr noundef %0) #33
  ret ptr %call
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @auxHumanNodenamePresent(ptr nocapture noundef readonly %n) #0 {
entry:
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 23
  %0 = load ptr, ptr %human_nodename, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %conv = trunc i64 %retval.0.i to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nofree nounwind willreturn uwtable
define dso_local i32 @auxTcpPortSetter(ptr nocapture noundef writeonly %n, ptr nocapture noundef readonly %value, i32 noundef %length) #4 {
entry:
  %0 = add i32 %length, -6
  %or.cond = icmp ult i32 %0, -5
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %add = add nuw nsw i32 %length, 1
  %1 = zext nneg i32 %add to i64
  %2 = tail call ptr @llvm.stacksave.p0()
  %vla = alloca i8, i64 %1, align 16
  %conv = zext nneg i32 %length to i64
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 16 %vla, ptr align 1 %value, i64 %conv, i1 false)
  %arrayidx = getelementptr inbounds i8, ptr %vla, i64 %conv
  store i8 0, ptr %arrayidx, align 1
  %call = call i32 @atoi(ptr nocapture noundef nonnull %vla) #34
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 24
  store i32 %call, ptr %tcp_port, align 8
  %narrow = icmp ugt i32 %call, 65535
  %cond = sext i1 %narrow to i32
  tail call void @llvm.stackrestore.p0(ptr %2)
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %cond, %if.end ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @auxTcpPortGetter(ptr nocapture noundef readonly %n, ptr noundef %s) #2 {
entry:
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 24
  %0 = load i32, ptr %tcp_port, align 8
  %call = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %s, ptr noundef nonnull @.str.6, i32 noundef %0) #33
  ret ptr %call
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @auxTcpPortPresent(ptr nocapture noundef readonly %n) #5 {
entry:
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 24
  %0 = load i32, ptr %tcp_port, align 8
  %narrow = icmp ult i32 %0, 65536
  %land.ext = zext i1 %narrow to i32
  ret i32 %land.ext
}

; Function Attrs: mustprogress nofree nounwind willreturn uwtable
define dso_local i32 @auxTlsPortSetter(ptr nocapture noundef writeonly %n, ptr nocapture noundef readonly %value, i32 noundef %length) #4 {
entry:
  %0 = add i32 %length, -6
  %or.cond = icmp ult i32 %0, -5
  br i1 %or.cond, label %return, label %if.end

if.end:                                           ; preds = %entry
  %add = add nuw nsw i32 %length, 1
  %1 = zext nneg i32 %add to i64
  %2 = tail call ptr @llvm.stacksave.p0()
  %vla = alloca i8, i64 %1, align 16
  %conv = zext nneg i32 %length to i64
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 16 %vla, ptr align 1 %value, i64 %conv, i1 false)
  %arrayidx = getelementptr inbounds i8, ptr %vla, i64 %conv
  store i8 0, ptr %arrayidx, align 1
  %call = call i32 @atoi(ptr nocapture noundef nonnull %vla) #34
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 25
  store i32 %call, ptr %tls_port, align 4
  %narrow = icmp ugt i32 %call, 65535
  %cond = sext i1 %narrow to i32
  tail call void @llvm.stackrestore.p0(ptr %2)
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %cond, %if.end ], [ -1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @auxTlsPortGetter(ptr nocapture noundef readonly %n, ptr noundef %s) #2 {
entry:
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 25
  %0 = load i32, ptr %tls_port, align 4
  %call = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %s, ptr noundef nonnull @.str.6, i32 noundef %0) #33
  ret ptr %call
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @auxTlsPortPresent(ptr nocapture noundef readonly %n) #5 {
entry:
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 25
  %0 = load i32, ptr %tls_port, align 4
  %narrow = icmp ult i32 %0, 65536
  %land.ext = zext i1 %narrow to i32
  ret i32 %land.ext
}

declare i32 @verifyClusterNodeId(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i32 @memcmp(ptr nocapture noundef, ptr nocapture noundef, i64 noundef) local_unnamed_addr #7

; Function Attrs: nounwind uwtable
define dso_local void @clusterAddNodeToShard(ptr noundef %shard_id, ptr noundef %node) local_unnamed_addr #2 {
entry:
  %call = tail call ptr @sdsnewlen(ptr noundef %shard_id, i64 noundef 40) #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 5
  %1 = load ptr, ptr %shards, align 8
  %call1 = tail call ptr @dictFind(ptr noundef %1, ptr noundef %call) #33
  %cmp = icmp eq ptr %call1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call2 = tail call ptr @listCreate() #33
  %call3 = tail call ptr @listAddNodeTail(ptr noundef %call2, ptr noundef %node) #33
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards4 = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 5
  %3 = load ptr, ptr %shards4, align 8
  %call5 = tail call i32 @dictAdd(ptr noundef %3, ptr noundef %call, ptr noundef %call2) #33
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %if.end15, label %cond.false

cond.false:                                       ; preds = %if.then
  tail call void @_serverAssert(ptr noundef nonnull @.str.62, ptr noundef nonnull @.str.18, i32 noundef 1623) #33
  tail call void @abort() #35
  unreachable

if.else:                                          ; preds = %entry
  %call9 = tail call ptr @dictGetVal(ptr noundef nonnull %call1) #33
  %call10 = tail call ptr @listSearchKey(ptr noundef %call9, ptr noundef %node) #33
  %cmp11 = icmp eq ptr %call10, null
  br i1 %cmp11, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.else
  %call14 = tail call ptr @listAddNodeTail(ptr noundef %call9, ptr noundef %node) #33
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.else
  tail call void @sdsfree(ptr noundef %call) #33
  br label %if.end15

if.end15:                                         ; preds = %if.then, %if.end
  ret void
}

declare ptr @sdscatprintf(ptr noundef, ptr noundef, ...) local_unnamed_addr #1

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strlen(ptr nocapture noundef) local_unnamed_addr #7

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i32 @strncmp(ptr nocapture noundef, ptr nocapture noundef, i64 noundef) local_unnamed_addr #7

declare ptr @sdscpylen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define internal fastcc i64 @sdslen(ptr nocapture noundef readonly %s) unnamed_addr #5 {
entry:
  %arrayidx = getelementptr inbounds i8, ptr %s, i64 -1
  %0 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %return [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %shr = lshr i32 %conv, 3
  %conv2 = zext nneg i32 %shr to i64
  br label %return

sw.bb3:                                           ; preds = %entry
  %add.ptr = getelementptr inbounds i8, ptr %s, i64 -3
  %1 = load i8, ptr %add.ptr, align 1
  %conv4 = zext i8 %1 to i64
  br label %return

sw.bb5:                                           ; preds = %entry
  %add.ptr6 = getelementptr inbounds i8, ptr %s, i64 -5
  %2 = load i16, ptr %add.ptr6, align 1
  %conv8 = zext i16 %2 to i64
  br label %return

sw.bb9:                                           ; preds = %entry
  %add.ptr10 = getelementptr inbounds i8, ptr %s, i64 -9
  %3 = load i32, ptr %add.ptr10, align 1
  %conv12 = zext i32 %3 to i64
  br label %return

sw.bb13:                                          ; preds = %entry
  %add.ptr14 = getelementptr inbounds i8, ptr %s, i64 -17
  %4 = load i64, ptr %add.ptr14, align 1
  br label %return

return:                                           ; preds = %entry, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb
  %retval.0 = phi i64 [ %4, %sw.bb13 ], [ %conv12, %sw.bb9 ], [ %conv8, %sw.bb5 ], [ %conv4, %sw.bb3 ], [ %conv2, %sw.bb ], [ 0, %entry ]
  ret i64 %retval.0
}

declare void @sdsclear(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #8

; Function Attrs: mustprogress nofree nounwind willreturn memory(read)
declare i32 @atoi(ptr nocapture noundef) local_unnamed_addr #9

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore.p0(ptr) #8

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterLoadConfig(ptr noundef %filename) local_unnamed_addr #2 {
entry:
  %sb = alloca %struct.stat, align 8
  %argc = alloca i32, align 4
  %aux_argc = alloca i32, align 4
  %field_argc = alloca i32, align 4
  %call = tail call noalias ptr @fopen64(ptr noundef %filename, ptr noundef nonnull @.str.7)
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %call1 = tail call ptr @__errno_location() #36
  %0 = load i32, ptr %call1, align 4
  %cmp2 = icmp eq i32 %0, 2
  br i1 %cmp2, label %return, label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp4 = icmp sgt i32 %1, 3
  br i1 %cmp4, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %call7 = tail call ptr @strerror(i32 noundef %0) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.8, ptr noundef %filename, ptr noundef %call7) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end8:                                          ; preds = %entry
  %call9 = tail call i32 @fileno(ptr noundef nonnull %call) #33
  %call10 = call i32 @fstat64(i32 noundef %call9, ptr noundef nonnull %sb) #33
  %cmp11 = icmp eq i32 %call10, -1
  br i1 %cmp11, label %do.body13, label %if.end20

do.body13:                                        ; preds = %if.end8
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp14 = icmp sgt i32 %2, 3
  br i1 %cmp14, label %do.end19, label %if.end16

if.end16:                                         ; preds = %do.body13
  %call17 = tail call ptr @__errno_location() #36
  %3 = load i32, ptr %call17, align 4
  %call18 = tail call ptr @strerror(i32 noundef %3) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.9, ptr noundef %filename, ptr noundef %call18) #33
  br label %do.end19

do.end19:                                         ; preds = %do.body13, %if.end16
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end20:                                         ; preds = %if.end8
  %st_size = getelementptr inbounds %struct.stat, ptr %sb, i64 0, i32 8
  %4 = load i64, ptr %st_size, align 8
  %cmp21 = icmp eq i64 %4, 0
  br i1 %cmp21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end20
  %call23 = tail call i32 @fclose(ptr noundef nonnull %call)
  br label %return

if.end24:                                         ; preds = %if.end20
  %call25 = tail call noalias dereferenceable_or_null(2098176) ptr @zmalloc(i64 noundef 2098176) #37
  %call26639 = tail call ptr @fgets(ptr noundef %call25, i32 noundef 2098176, ptr noundef nonnull %call)
  %cmp27.not640 = icmp eq ptr %call26639, null
  br i1 %cmp27.not640, label %while.end532, label %while.body

while.body:                                       ; preds = %if.end24, %while.cond.backedge
  %5 = load i8, ptr %call25, align 1
  switch i8 %5, label %if.end37 [
    i8 10, label %while.cond.backedge
    i8 0, label %while.cond.backedge
  ]

while.cond.backedge.sink.split:                   ; preds = %for.inc529, %for.inc, %cond.end426, %for.cond.preheader
  %.lcssa567.sink = phi i32 [ %7, %for.cond.preheader ], [ %152, %cond.end426 ], [ %15, %for.inc ], [ %182, %for.inc529 ]
  call void @sdsfreesplitres(ptr noundef nonnull %call38, i32 noundef %.lcssa567.sink) #33
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %while.cond.backedge.sink.split, %while.body, %while.body
  %call26 = call ptr @fgets(ptr noundef nonnull %call25, i32 noundef 2098176, ptr noundef nonnull %call)
  %cmp27.not = icmp eq ptr %call26, null
  br i1 %cmp27.not, label %while.end532, label %while.body, !llvm.loop !7

if.end37:                                         ; preds = %while.body
  %call38 = call ptr @sdssplitargs(ptr noundef nonnull %call25, ptr noundef nonnull %argc) #33
  %cmp39 = icmp eq ptr %call38, null
  br i1 %cmp39, label %do.body554, label %if.end42

if.end42:                                         ; preds = %if.end37
  %6 = load ptr, ptr %call38, align 8
  %call44 = call i32 @strcasecmp(ptr noundef %6, ptr noundef nonnull @.str.10) #34
  %cmp45 = icmp eq i32 %call44, 0
  %7 = load i32, ptr %argc, align 4
  br i1 %cmp45, label %if.then47, label %if.end83

if.then47:                                        ; preds = %if.end42
  %8 = and i32 %7, 1
  %tobool.not = icmp eq i32 %8, 0
  br i1 %tobool.not, label %do.body554, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then47
  %cmp50636 = icmp sgt i32 %7, 1
  br i1 %cmp50636, label %for.body, label %while.cond.backedge.sink.split

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv732 = phi i64 [ %indvars.iv.next733, %for.inc ], [ 1, %for.cond.preheader ]
  %arrayidx52 = getelementptr inbounds ptr, ptr %call38, i64 %indvars.iv732
  %9 = load ptr, ptr %arrayidx52, align 8
  %call53 = call i32 @strcasecmp(ptr noundef %9, ptr noundef nonnull @.str.11) #34
  %cmp54 = icmp eq i32 %call53, 0
  br i1 %cmp54, label %if.then56, label %if.else60

if.then56:                                        ; preds = %for.body
  %arrayidx58 = getelementptr ptr, ptr %arrayidx52, i64 1
  %10 = load ptr, ptr %arrayidx58, align 8
  %call59 = call i64 @strtoull(ptr nocapture noundef %10, ptr noundef null, i32 noundef 10) #33
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %11, i64 0, i32 1
  store i64 %call59, ptr %currentEpoch, align 8
  br label %for.inc

if.else60:                                        ; preds = %for.body
  %call63 = call i32 @strcasecmp(ptr noundef %9, ptr noundef nonnull @.str.12) #34
  %cmp64 = icmp eq i32 %call63, 0
  br i1 %cmp64, label %if.then66, label %do.body72

if.then66:                                        ; preds = %if.else60
  %arrayidx69 = getelementptr ptr, ptr %arrayidx52, i64 1
  %12 = load ptr, ptr %arrayidx69, align 8
  %call70 = call i64 @strtoull(ptr nocapture noundef %12, ptr noundef null, i32 noundef 10) #33
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %13, i64 0, i32 21
  store i64 %call70, ptr %lastVoteEpoch, align 8
  br label %for.inc

do.body72:                                        ; preds = %if.else60
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp73 = icmp sgt i32 %14, 2
  br i1 %cmp73, label %for.inc, label %if.end76

if.end76:                                         ; preds = %do.body72
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.13, ptr noundef %9) #33
  br label %for.inc

for.inc:                                          ; preds = %if.then56, %if.end76, %do.body72, %if.then66
  %indvars.iv.next733 = add nuw i64 %indvars.iv732, 2
  %15 = load i32, ptr %argc, align 4
  %16 = trunc i64 %indvars.iv.next733 to i32
  %cmp50 = icmp sgt i32 %15, %16
  br i1 %cmp50, label %for.body, label %while.cond.backedge.sink.split, !llvm.loop !8

if.end83:                                         ; preds = %if.end42
  %cmp84 = icmp slt i32 %7, 8
  br i1 %cmp84, label %do.body554.sink.split, label %if.end87

if.end87:                                         ; preds = %if.end83
  %arrayidx.i = getelementptr inbounds i8, ptr %6, i64 -1
  %17 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %17 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end87
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end87
  %add.ptr.i = getelementptr inbounds i8, ptr %6, i64 -3
  %18 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %18 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end87
  %add.ptr6.i = getelementptr inbounds i8, ptr %6, i64 -5
  %19 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %19 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end87
  %add.ptr10.i = getelementptr inbounds i8, ptr %6, i64 -9
  %20 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %20 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end87
  %add.ptr14.i = getelementptr inbounds i8, ptr %6, i64 -17
  %21 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end87, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %21, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end87 ]
  %conv91 = trunc i64 %retval.0.i to i32
  %call92 = call i32 @verifyClusterNodeId(ptr noundef nonnull %6, i32 noundef %conv91) #33
  %cmp93 = icmp eq i32 %call92, -1
  br i1 %cmp93, label %if.then95, label %if.end96

if.then95:                                        ; preds = %sdslen.exit
  %22 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

if.end96:                                         ; preds = %sdslen.exit
  %23 = load ptr, ptr %call38, align 8
  %arrayidx.i216 = getelementptr inbounds i8, ptr %23, i64 -1
  %24 = load i8, ptr %arrayidx.i216, align 1
  %conv.i217 = zext i8 %24 to i32
  %and.i218 = and i32 %conv.i217, 7
  switch i32 %and.i218, label %sdslen.exit234 [
    i32 0, label %sw.bb.i231
    i32 1, label %sw.bb3.i228
    i32 2, label %sw.bb5.i225
    i32 3, label %sw.bb9.i222
    i32 4, label %sw.bb13.i219
  ]

sw.bb.i231:                                       ; preds = %if.end96
  %shr.i232 = lshr i32 %conv.i217, 3
  %conv2.i233 = zext nneg i32 %shr.i232 to i64
  br label %sdslen.exit234

sw.bb3.i228:                                      ; preds = %if.end96
  %add.ptr.i229 = getelementptr inbounds i8, ptr %23, i64 -3
  %25 = load i8, ptr %add.ptr.i229, align 1
  %conv4.i230 = zext i8 %25 to i64
  br label %sdslen.exit234

sw.bb5.i225:                                      ; preds = %if.end96
  %add.ptr6.i226 = getelementptr inbounds i8, ptr %23, i64 -5
  %26 = load i16, ptr %add.ptr6.i226, align 1
  %conv8.i227 = zext i16 %26 to i64
  br label %sdslen.exit234

sw.bb9.i222:                                      ; preds = %if.end96
  %add.ptr10.i223 = getelementptr inbounds i8, ptr %23, i64 -9
  %27 = load i32, ptr %add.ptr10.i223, align 1
  %conv12.i224 = zext i32 %27 to i64
  br label %sdslen.exit234

sw.bb13.i219:                                     ; preds = %if.end96
  %add.ptr14.i220 = getelementptr inbounds i8, ptr %23, i64 -17
  %28 = load i64, ptr %add.ptr14.i220, align 1
  br label %sdslen.exit234

sdslen.exit234:                                   ; preds = %if.end96, %sw.bb.i231, %sw.bb3.i228, %sw.bb5.i225, %sw.bb9.i222, %sw.bb13.i219
  %retval.0.i221 = phi i64 [ %28, %sw.bb13.i219 ], [ %conv12.i224, %sw.bb9.i222 ], [ %conv8.i227, %sw.bb5.i225 ], [ %conv4.i230, %sw.bb3.i228 ], [ %conv2.i233, %sw.bb.i231 ], [ 0, %if.end96 ]
  %conv100 = trunc i64 %retval.0.i221 to i32
  %call.i = call i32 @verifyClusterNodeId(ptr noundef nonnull %23, i32 noundef %conv100) #33
  %cmp.not.i = icmp eq i32 %call.i, 0
  br i1 %cmp.not.i, label %if.end.i, label %if.then103

if.end.i:                                         ; preds = %sdslen.exit234
  %sext = shl i64 %retval.0.i221, 32
  %conv.i236 = ashr exact i64 %sext, 32
  %call1.i = call ptr @sdsnewlen(ptr noundef nonnull %23, i64 noundef %conv.i236) #33
  %29 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %29, i64 0, i32 4
  %30 = load ptr, ptr %nodes.i, align 8
  %call2.i = call ptr @dictFind(ptr noundef %30, ptr noundef %call1.i) #33
  call void @sdsfree(ptr noundef %call1.i) #33
  %cmp3.i = icmp eq ptr %call2.i, null
  br i1 %cmp3.i, label %if.then103, label %clusterLookupNode.exit

clusterLookupNode.exit:                           ; preds = %if.end.i
  %call7.i = call ptr @dictGetVal(ptr noundef nonnull %call2.i) #33
  %tobool102.not = icmp eq ptr %call7.i, null
  br i1 %tobool102.not, label %if.then103, label %if.end106

if.then103:                                       ; preds = %if.end.i, %sdslen.exit234, %clusterLookupNode.exit
  %31 = load ptr, ptr %call38, align 8
  %call105 = call ptr @createClusterNode(ptr noundef %31, i32 noundef 0)
  %32 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i237 = getelementptr inbounds %struct.clusterState, ptr %32, i64 0, i32 4
  %33 = load ptr, ptr %nodes.i237, align 8
  %name.i = getelementptr inbounds %struct._clusterNode, ptr %call105, i64 0, i32 1
  %call.i238 = call ptr @sdsnewlen(ptr noundef nonnull %name.i, i64 noundef 40) #33
  %call1.i239 = call i32 @dictAdd(ptr noundef %33, ptr noundef %call.i238, ptr noundef %call105) #33
  %cmp.i = icmp eq i32 %call1.i239, 0
  br i1 %cmp.i, label %if.end106, label %cond.false.i

cond.false.i:                                     ; preds = %if.then103
  call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  call void @abort() #35
  unreachable

if.end106:                                        ; preds = %if.then103, %clusterLookupNode.exit
  %n.0 = phi ptr [ %call7.i, %clusterLookupNode.exit ], [ %call105, %if.then103 ]
  %arrayidx107 = getelementptr inbounds ptr, ptr %call38, i64 1
  %34 = load ptr, ptr %arrayidx107, align 8
  %arrayidx.i240 = getelementptr inbounds i8, ptr %34, i64 -1
  %35 = load i8, ptr %arrayidx.i240, align 1
  %conv.i241 = zext i8 %35 to i32
  %and.i242 = and i32 %conv.i241, 7
  switch i32 %and.i242, label %sdslen.exit258 [
    i32 0, label %sw.bb.i255
    i32 1, label %sw.bb3.i252
    i32 2, label %sw.bb5.i249
    i32 3, label %sw.bb9.i246
    i32 4, label %sw.bb13.i243
  ]

sw.bb.i255:                                       ; preds = %if.end106
  %shr.i256 = lshr i32 %conv.i241, 3
  %conv2.i257 = zext nneg i32 %shr.i256 to i64
  br label %sdslen.exit258

sw.bb3.i252:                                      ; preds = %if.end106
  %add.ptr.i253 = getelementptr inbounds i8, ptr %34, i64 -3
  %36 = load i8, ptr %add.ptr.i253, align 1
  %conv4.i254 = zext i8 %36 to i64
  br label %sdslen.exit258

sw.bb5.i249:                                      ; preds = %if.end106
  %add.ptr6.i250 = getelementptr inbounds i8, ptr %34, i64 -5
  %37 = load i16, ptr %add.ptr6.i250, align 1
  %conv8.i251 = zext i16 %37 to i64
  br label %sdslen.exit258

sw.bb9.i246:                                      ; preds = %if.end106
  %add.ptr10.i247 = getelementptr inbounds i8, ptr %34, i64 -9
  %38 = load i32, ptr %add.ptr10.i247, align 1
  %conv12.i248 = zext i32 %38 to i64
  br label %sdslen.exit258

sw.bb13.i243:                                     ; preds = %if.end106
  %add.ptr14.i244 = getelementptr inbounds i8, ptr %34, i64 -17
  %39 = load i64, ptr %add.ptr14.i244, align 1
  br label %sdslen.exit258

sdslen.exit258:                                   ; preds = %if.end106, %sw.bb.i255, %sw.bb3.i252, %sw.bb5.i249, %sw.bb9.i246, %sw.bb13.i243
  %retval.0.i245 = phi i64 [ %39, %sw.bb13.i243 ], [ %conv12.i248, %sw.bb9.i246 ], [ %conv8.i251, %sw.bb5.i249 ], [ %conv4.i254, %sw.bb3.i252 ], [ %conv2.i257, %sw.bb.i255 ], [ 0, %if.end106 ]
  %call110 = call ptr @sdssplitlen(ptr noundef nonnull %34, i64 noundef %retval.0.i245, ptr noundef nonnull @.str.14, i32 noundef 1, ptr noundef nonnull %aux_argc) #33
  %cmp111 = icmp eq ptr %call110, null
  br i1 %cmp111, label %if.then113, label %if.end114

if.then113:                                       ; preds = %sdslen.exit258
  %40 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

if.end114:                                        ; preds = %sdslen.exit258
  %41 = load i32, ptr %aux_argc, align 4
  %cmp115 = icmp sgt i32 %41, 1
  br i1 %cmp115, label %land.lhs.true, label %if.else125

land.lhs.true:                                    ; preds = %if.end114
  %arrayidx117 = getelementptr inbounds ptr, ptr %call110, i64 1
  %42 = load ptr, ptr %arrayidx117, align 8
  %arrayidx.i259 = getelementptr inbounds i8, ptr %42, i64 -1
  %43 = load i8, ptr %arrayidx.i259, align 1
  %conv.i260 = zext i8 %43 to i32
  %and.i261 = and i32 %conv.i260, 7
  switch i32 %and.i261, label %if.else125 [
    i32 0, label %sw.bb.i274
    i32 1, label %sw.bb3.i271
    i32 2, label %sw.bb5.i268
    i32 3, label %sw.bb9.i265
    i32 4, label %sw.bb13.i262
  ]

sw.bb.i274:                                       ; preds = %land.lhs.true
  %shr.i275 = lshr i32 %conv.i260, 3
  %conv2.i276 = zext nneg i32 %shr.i275 to i64
  br label %sdslen.exit277

sw.bb3.i271:                                      ; preds = %land.lhs.true
  %add.ptr.i272 = getelementptr inbounds i8, ptr %42, i64 -3
  %44 = load i8, ptr %add.ptr.i272, align 1
  %conv4.i273 = zext i8 %44 to i64
  br label %sdslen.exit277

sw.bb5.i268:                                      ; preds = %land.lhs.true
  %add.ptr6.i269 = getelementptr inbounds i8, ptr %42, i64 -5
  %45 = load i16, ptr %add.ptr6.i269, align 1
  %conv8.i270 = zext i16 %45 to i64
  br label %sdslen.exit277

sw.bb9.i265:                                      ; preds = %land.lhs.true
  %add.ptr10.i266 = getelementptr inbounds i8, ptr %42, i64 -9
  %46 = load i32, ptr %add.ptr10.i266, align 1
  %conv12.i267 = zext i32 %46 to i64
  br label %sdslen.exit277

sw.bb13.i262:                                     ; preds = %land.lhs.true
  %add.ptr14.i263 = getelementptr inbounds i8, ptr %42, i64 -17
  %47 = load i64, ptr %add.ptr14.i263, align 1
  br label %sdslen.exit277

sdslen.exit277:                                   ; preds = %sw.bb.i274, %sw.bb3.i271, %sw.bb5.i268, %sw.bb9.i265, %sw.bb13.i262
  %retval.0.i264 = phi i64 [ %47, %sw.bb13.i262 ], [ %conv12.i267, %sw.bb9.i265 ], [ %conv8.i270, %sw.bb5.i268 ], [ %conv4.i273, %sw.bb3.i271 ], [ %conv2.i276, %sw.bb.i274 ]
  %cmp119.not = icmp eq i64 %retval.0.i264, 0
  br i1 %cmp119.not, label %if.else125, label %if.then121

if.then121:                                       ; preds = %sdslen.exit277
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 22
  %48 = load ptr, ptr %hostname, align 8
  %call123 = call ptr @sdscpy(ptr noundef %48, ptr noundef nonnull %42) #33
  store ptr %call123, ptr %hostname, align 8
  br label %if.end133

if.else125:                                       ; preds = %land.lhs.true, %sdslen.exit277, %if.end114
  %hostname126 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 22
  %49 = load ptr, ptr %hostname126, align 8
  %arrayidx.i278 = getelementptr inbounds i8, ptr %49, i64 -1
  %50 = load i8, ptr %arrayidx.i278, align 1
  %conv.i279 = zext i8 %50 to i32
  %and.i280 = and i32 %conv.i279, 7
  switch i32 %and.i280, label %if.end133 [
    i32 0, label %sw.bb.i293
    i32 1, label %sw.bb3.i290
    i32 2, label %sw.bb5.i287
    i32 3, label %sw.bb9.i284
    i32 4, label %sw.bb13.i281
  ]

sw.bb.i293:                                       ; preds = %if.else125
  %shr.i294 = lshr i32 %conv.i279, 3
  %conv2.i295 = zext nneg i32 %shr.i294 to i64
  br label %sdslen.exit296

sw.bb3.i290:                                      ; preds = %if.else125
  %add.ptr.i291 = getelementptr inbounds i8, ptr %49, i64 -3
  %51 = load i8, ptr %add.ptr.i291, align 1
  %conv4.i292 = zext i8 %51 to i64
  br label %sdslen.exit296

sw.bb5.i287:                                      ; preds = %if.else125
  %add.ptr6.i288 = getelementptr inbounds i8, ptr %49, i64 -5
  %52 = load i16, ptr %add.ptr6.i288, align 1
  %conv8.i289 = zext i16 %52 to i64
  br label %sdslen.exit296

sw.bb9.i284:                                      ; preds = %if.else125
  %add.ptr10.i285 = getelementptr inbounds i8, ptr %49, i64 -9
  %53 = load i32, ptr %add.ptr10.i285, align 1
  %conv12.i286 = zext i32 %53 to i64
  br label %sdslen.exit296

sw.bb13.i281:                                     ; preds = %if.else125
  %add.ptr14.i282 = getelementptr inbounds i8, ptr %49, i64 -17
  %54 = load i64, ptr %add.ptr14.i282, align 1
  br label %sdslen.exit296

sdslen.exit296:                                   ; preds = %sw.bb.i293, %sw.bb3.i290, %sw.bb5.i287, %sw.bb9.i284, %sw.bb13.i281
  %retval.0.i283 = phi i64 [ %54, %sw.bb13.i281 ], [ %conv12.i286, %sw.bb9.i284 ], [ %conv8.i289, %sw.bb5.i287 ], [ %conv4.i292, %sw.bb3.i290 ], [ %conv2.i295, %sw.bb.i293 ]
  %cmp128.not = icmp eq i64 %retval.0.i283, 0
  br i1 %cmp128.not, label %if.end133, label %if.then130

if.then130:                                       ; preds = %sdslen.exit296
  call void @sdsclear(ptr noundef nonnull %49) #33
  br label %if.end133

if.end133:                                        ; preds = %if.else125, %sdslen.exit296, %if.then130, %if.then121
  %55 = load i32, ptr %aux_argc, align 4
  %cmp135623 = icmp sgt i32 %55, 2
  br i1 %cmp135623, label %for.body137, label %for.end222

for.body137:                                      ; preds = %if.end133, %if.end219
  %indvars.iv723 = phi i64 [ %indvars.iv.next724, %if.end219 ], [ 2, %if.end133 ]
  %aux_tls_port.0625 = phi i32 [ %aux_tls_port.2743749, %if.end219 ], [ 0, %if.end133 ]
  %aux_tcp_port.0624 = phi i32 [ %aux_tcp_port.2742750, %if.end219 ], [ 0, %if.end133 ]
  %arrayidx139 = getelementptr inbounds ptr, ptr %call110, i64 %indvars.iv723
  %56 = load ptr, ptr %arrayidx139, align 8
  %arrayidx.i297 = getelementptr inbounds i8, ptr %56, i64 -1
  %57 = load i8, ptr %arrayidx.i297, align 1
  %conv.i298 = zext i8 %57 to i32
  %and.i299 = and i32 %conv.i298, 7
  switch i32 %and.i299, label %sdslen.exit315 [
    i32 0, label %sw.bb.i312
    i32 1, label %sw.bb3.i309
    i32 2, label %sw.bb5.i306
    i32 3, label %sw.bb9.i303
    i32 4, label %sw.bb13.i300
  ]

sw.bb.i312:                                       ; preds = %for.body137
  %shr.i313 = lshr i32 %conv.i298, 3
  %conv2.i314 = zext nneg i32 %shr.i313 to i64
  br label %sdslen.exit315

sw.bb3.i309:                                      ; preds = %for.body137
  %add.ptr.i310 = getelementptr inbounds i8, ptr %56, i64 -3
  %58 = load i8, ptr %add.ptr.i310, align 1
  %conv4.i311 = zext i8 %58 to i64
  br label %sdslen.exit315

sw.bb5.i306:                                      ; preds = %for.body137
  %add.ptr6.i307 = getelementptr inbounds i8, ptr %56, i64 -5
  %59 = load i16, ptr %add.ptr6.i307, align 1
  %conv8.i308 = zext i16 %59 to i64
  br label %sdslen.exit315

sw.bb9.i303:                                      ; preds = %for.body137
  %add.ptr10.i304 = getelementptr inbounds i8, ptr %56, i64 -9
  %60 = load i32, ptr %add.ptr10.i304, align 1
  %conv12.i305 = zext i32 %60 to i64
  br label %sdslen.exit315

sw.bb13.i300:                                     ; preds = %for.body137
  %add.ptr14.i301 = getelementptr inbounds i8, ptr %56, i64 -17
  %61 = load i64, ptr %add.ptr14.i301, align 1
  br label %sdslen.exit315

sdslen.exit315:                                   ; preds = %for.body137, %sw.bb.i312, %sw.bb3.i309, %sw.bb5.i306, %sw.bb9.i303, %sw.bb13.i300
  %retval.0.i302 = phi i64 [ %61, %sw.bb13.i300 ], [ %conv12.i305, %sw.bb9.i303 ], [ %conv8.i308, %sw.bb5.i306 ], [ %conv4.i311, %sw.bb3.i309 ], [ %conv2.i314, %sw.bb.i312 ], [ 0, %for.body137 ]
  %call143 = call ptr @sdssplitlen(ptr noundef nonnull %56, i64 noundef %retval.0.i302, ptr noundef nonnull @.str.15, i32 noundef 1, ptr noundef nonnull %field_argc) #33
  %cmp144 = icmp eq ptr %call143, null
  %62 = load i32, ptr %field_argc, align 4
  %cmp147 = icmp ne i32 %62, 2
  %or.cond = select i1 %cmp144, i1 true, i1 %cmp147
  br i1 %or.cond, label %if.then149, label %for.body159

if.then149:                                       ; preds = %sdslen.exit315
  br i1 %cmp144, label %if.end153, label %if.then152

if.then152:                                       ; preds = %if.then149
  call void @sdsfreesplitres(ptr noundef nonnull %call143, i32 noundef %62) #33
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.then149
  %63 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call110, i32 noundef %63) #33
  %64 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

for.cond156:                                      ; preds = %sdslen.exit334
  br i1 %cmp157, label %for.body159, label %for.cond173.preheader, !llvm.loop !9

for.cond173.preheader:                            ; preds = %for.cond156
  %arrayidx204 = getelementptr inbounds ptr, ptr %call143, i64 1
  br label %for.body177.outer

for.body177.outer:                                ; preds = %for.inc213.thread, %for.cond173.preheader
  %indvars.iv720.ph = phi i64 [ %indvars.iv.next721740, %for.inc213.thread ], [ 0, %for.cond173.preheader ]
  %cmp216 = phi i1 [ false, %for.inc213.thread ], [ true, %for.cond173.preheader ]
  %aux_tls_port.1620.ph = phi i32 [ %or201, %for.inc213.thread ], [ %aux_tls_port.0625, %for.cond173.preheader ]
  %aux_tcp_port.1619.ph = phi i32 [ %or, %for.inc213.thread ], [ %aux_tcp_port.0624, %for.cond173.preheader ]
  %65 = load ptr, ptr %call143, align 8
  %arrayidx.i335 = getelementptr inbounds i8, ptr %65, i64 -1
  %66 = load i8, ptr %arrayidx.i335, align 1
  %conv.i336 = zext i8 %66 to i32
  %and.i337 = and i32 %conv.i336, 7
  %add.ptr14.i339 = getelementptr inbounds i8, ptr %65, i64 -17
  %add.ptr10.i342 = getelementptr inbounds i8, ptr %65, i64 -9
  %add.ptr6.i345 = getelementptr inbounds i8, ptr %65, i64 -5
  %add.ptr.i348 = getelementptr inbounds i8, ptr %65, i64 -3
  %shr.i351 = lshr i32 %conv.i336, 3
  %conv2.i352 = zext nneg i32 %shr.i351 to i64
  %add.ptr14.i358 = getelementptr inbounds i8, ptr %65, i64 -17
  %add.ptr10.i361 = getelementptr inbounds i8, ptr %65, i64 -9
  %add.ptr6.i364 = getelementptr inbounds i8, ptr %65, i64 -5
  %add.ptr.i367 = getelementptr inbounds i8, ptr %65, i64 -3
  %shr.i370 = lshr i32 %conv.i336, 3
  %conv2.i371 = zext nneg i32 %shr.i370 to i64
  br label %for.body177

for.body159:                                      ; preds = %sdslen.exit315, %for.cond156
  %cmp157 = phi i1 [ false, %for.cond156 ], [ true, %sdslen.exit315 ]
  %indvars.iv = phi i64 [ 1, %for.cond156 ], [ 0, %sdslen.exit315 ]
  %arrayidx161 = getelementptr inbounds ptr, ptr %call143, i64 %indvars.iv
  %67 = load ptr, ptr %arrayidx161, align 8
  %arrayidx.i316 = getelementptr inbounds i8, ptr %67, i64 -1
  %68 = load i8, ptr %arrayidx.i316, align 1
  %conv.i317 = zext i8 %68 to i32
  %and.i318 = and i32 %conv.i317, 7
  switch i32 %and.i318, label %sdslen.exit334 [
    i32 0, label %sw.bb.i331
    i32 1, label %sw.bb3.i328
    i32 2, label %sw.bb5.i325
    i32 3, label %sw.bb9.i322
    i32 4, label %sw.bb13.i319
  ]

sw.bb.i331:                                       ; preds = %for.body159
  %shr.i332 = lshr i32 %conv.i317, 3
  %conv2.i333 = zext nneg i32 %shr.i332 to i64
  br label %sdslen.exit334

sw.bb3.i328:                                      ; preds = %for.body159
  %add.ptr.i329 = getelementptr inbounds i8, ptr %67, i64 -3
  %69 = load i8, ptr %add.ptr.i329, align 1
  %conv4.i330 = zext i8 %69 to i64
  br label %sdslen.exit334

sw.bb5.i325:                                      ; preds = %for.body159
  %add.ptr6.i326 = getelementptr inbounds i8, ptr %67, i64 -5
  %70 = load i16, ptr %add.ptr6.i326, align 1
  %conv8.i327 = zext i16 %70 to i64
  br label %sdslen.exit334

sw.bb9.i322:                                      ; preds = %for.body159
  %add.ptr10.i323 = getelementptr inbounds i8, ptr %67, i64 -9
  %71 = load i32, ptr %add.ptr10.i323, align 1
  %conv12.i324 = zext i32 %71 to i64
  br label %sdslen.exit334

sw.bb13.i319:                                     ; preds = %for.body159
  %add.ptr14.i320 = getelementptr inbounds i8, ptr %67, i64 -17
  %72 = load i64, ptr %add.ptr14.i320, align 1
  br label %sdslen.exit334

sdslen.exit334:                                   ; preds = %for.body159, %sw.bb.i331, %sw.bb3.i328, %sw.bb5.i325, %sw.bb9.i322, %sw.bb13.i319
  %retval.0.i321 = phi i64 [ %72, %sw.bb13.i319 ], [ %conv12.i324, %sw.bb9.i322 ], [ %conv8.i327, %sw.bb5.i325 ], [ %conv4.i330, %sw.bb3.i328 ], [ %conv2.i333, %sw.bb.i331 ], [ 0, %for.body159 ]
  %conv165 = trunc i64 %retval.0.i321 to i32
  %call166 = call i32 @isValidAuxString(ptr noundef nonnull %67, i32 noundef %conv165) #33
  %tobool167.not = icmp eq i32 %call166, 0
  br i1 %tobool167.not, label %if.then168, label %for.cond156

if.then168:                                       ; preds = %sdslen.exit334
  %73 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call143, i32 noundef %73) #33
  %74 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call110, i32 noundef %74) #33
  %75 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

for.body177:                                      ; preds = %for.body177.outer, %for.inc213
  %indvars.iv720 = phi i64 [ %indvars.iv.next721, %for.inc213 ], [ %indvars.iv720.ph, %for.body177.outer ]
  switch i32 %and.i337, label %sdslen.exit353 [
    i32 0, label %sw.bb.i350
    i32 1, label %sw.bb3.i347
    i32 2, label %sw.bb5.i344
    i32 3, label %sw.bb9.i341
    i32 4, label %sw.bb13.i338
  ]

sw.bb.i350:                                       ; preds = %for.body177
  br label %sdslen.exit353

sw.bb3.i347:                                      ; preds = %for.body177
  %76 = load i8, ptr %add.ptr.i348, align 1
  %conv4.i349 = zext i8 %76 to i64
  br label %sdslen.exit353

sw.bb5.i344:                                      ; preds = %for.body177
  %77 = load i16, ptr %add.ptr6.i345, align 1
  %conv8.i346 = zext i16 %77 to i64
  br label %sdslen.exit353

sw.bb9.i341:                                      ; preds = %for.body177
  %78 = load i32, ptr %add.ptr10.i342, align 1
  %conv12.i343 = zext i32 %78 to i64
  br label %sdslen.exit353

sw.bb13.i338:                                     ; preds = %for.body177
  %79 = load i64, ptr %add.ptr14.i339, align 1
  br label %sdslen.exit353

sdslen.exit353:                                   ; preds = %for.body177, %sw.bb.i350, %sw.bb3.i347, %sw.bb5.i344, %sw.bb9.i341, %sw.bb13.i338
  %retval.0.i340 = phi i64 [ %79, %sw.bb13.i338 ], [ %conv12.i343, %sw.bb9.i341 ], [ %conv8.i346, %sw.bb5.i344 ], [ %conv4.i349, %sw.bb3.i347 ], [ %conv2.i352, %sw.bb.i350 ], [ 0, %for.body177 ]
  %arrayidx181 = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %indvars.iv720
  %80 = load ptr, ptr %arrayidx181, align 16
  %call182 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %80) #34
  %cmp183.not = icmp eq i64 %retval.0.i340, %call182
  br i1 %cmp183.not, label %lor.lhs.false185, label %for.inc213

lor.lhs.false185:                                 ; preds = %sdslen.exit353
  switch i32 %and.i337, label %sdslen.exit372 [
    i32 0, label %sw.bb.i369
    i32 1, label %sw.bb3.i366
    i32 2, label %sw.bb5.i363
    i32 3, label %sw.bb9.i360
    i32 4, label %sw.bb13.i357
  ]

sw.bb.i369:                                       ; preds = %lor.lhs.false185
  br label %sdslen.exit372

sw.bb3.i366:                                      ; preds = %lor.lhs.false185
  %81 = load i8, ptr %add.ptr.i367, align 1
  %conv4.i368 = zext i8 %81 to i64
  br label %sdslen.exit372

sw.bb5.i363:                                      ; preds = %lor.lhs.false185
  %82 = load i16, ptr %add.ptr6.i364, align 1
  %conv8.i365 = zext i16 %82 to i64
  br label %sdslen.exit372

sw.bb9.i360:                                      ; preds = %lor.lhs.false185
  %83 = load i32, ptr %add.ptr10.i361, align 1
  %conv12.i362 = zext i32 %83 to i64
  br label %sdslen.exit372

sw.bb13.i357:                                     ; preds = %lor.lhs.false185
  %84 = load i64, ptr %add.ptr14.i358, align 1
  br label %sdslen.exit372

sdslen.exit372:                                   ; preds = %lor.lhs.false185, %sw.bb.i369, %sw.bb3.i366, %sw.bb5.i363, %sw.bb9.i360, %sw.bb13.i357
  %retval.0.i359 = phi i64 [ %84, %sw.bb13.i357 ], [ %conv12.i362, %sw.bb9.i360 ], [ %conv8.i365, %sw.bb5.i363 ], [ %conv4.i368, %sw.bb3.i366 ], [ %conv2.i371, %sw.bb.i369 ], [ 0, %lor.lhs.false185 ]
  %bcmp215 = call i32 @bcmp(ptr nonnull %65, ptr %80, i64 %retval.0.i359)
  %cmp193.not = icmp eq i32 %bcmp215, 0
  br i1 %cmp193.not, label %if.end196, label %for.inc213

if.end196:                                        ; preds = %sdslen.exit372
  %cmp197 = icmp eq i64 %indvars.iv720, 2
  %conv198 = zext i1 %cmp197 to i32
  %or = or i32 %aux_tcp_port.1619.ph, %conv198
  %cmp199 = icmp eq i64 %indvars.iv720, 3
  %conv200 = zext i1 %cmp199 to i32
  %or201 = or i32 %aux_tls_port.1620.ph, %conv200
  %setter = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %indvars.iv720, i32 1
  %85 = load ptr, ptr %setter, align 8
  %86 = load ptr, ptr %arrayidx204, align 8
  %arrayidx.i373 = getelementptr inbounds i8, ptr %86, i64 -1
  %87 = load i8, ptr %arrayidx.i373, align 1
  %conv.i374 = zext i8 %87 to i32
  %and.i375 = and i32 %conv.i374, 7
  switch i32 %and.i375, label %sdslen.exit391 [
    i32 0, label %sw.bb.i388
    i32 1, label %sw.bb3.i385
    i32 2, label %sw.bb5.i382
    i32 3, label %sw.bb9.i379
    i32 4, label %sw.bb13.i376
  ]

sw.bb.i388:                                       ; preds = %if.end196
  %shr.i389 = lshr i32 %conv.i374, 3
  %conv2.i390 = zext nneg i32 %shr.i389 to i64
  br label %sdslen.exit391

sw.bb3.i385:                                      ; preds = %if.end196
  %add.ptr.i386 = getelementptr inbounds i8, ptr %86, i64 -3
  %88 = load i8, ptr %add.ptr.i386, align 1
  %conv4.i387 = zext i8 %88 to i64
  br label %sdslen.exit391

sw.bb5.i382:                                      ; preds = %if.end196
  %add.ptr6.i383 = getelementptr inbounds i8, ptr %86, i64 -5
  %89 = load i16, ptr %add.ptr6.i383, align 1
  %conv8.i384 = zext i16 %89 to i64
  br label %sdslen.exit391

sw.bb9.i379:                                      ; preds = %if.end196
  %add.ptr10.i380 = getelementptr inbounds i8, ptr %86, i64 -9
  %90 = load i32, ptr %add.ptr10.i380, align 1
  %conv12.i381 = zext i32 %90 to i64
  br label %sdslen.exit391

sw.bb13.i376:                                     ; preds = %if.end196
  %add.ptr14.i377 = getelementptr inbounds i8, ptr %86, i64 -17
  %91 = load i64, ptr %add.ptr14.i377, align 1
  br label %sdslen.exit391

sdslen.exit391:                                   ; preds = %if.end196, %sw.bb.i388, %sw.bb3.i385, %sw.bb5.i382, %sw.bb9.i379, %sw.bb13.i376
  %retval.0.i378 = phi i64 [ %91, %sw.bb13.i376 ], [ %conv12.i381, %sw.bb9.i379 ], [ %conv8.i384, %sw.bb5.i382 ], [ %conv4.i387, %sw.bb3.i385 ], [ %conv2.i390, %sw.bb.i388 ], [ 0, %if.end196 ]
  %conv207 = trunc i64 %retval.0.i378 to i32
  %call208 = call i32 %85(ptr noundef %n.0, ptr noundef nonnull %86, i32 noundef %conv207) #33
  %cmp209.not = icmp eq i32 %call208, 0
  br i1 %cmp209.not, label %for.inc213.thread, label %if.then211

if.then211:                                       ; preds = %sdslen.exit391
  %92 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call143, i32 noundef %92) #33
  %93 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call110, i32 noundef %93) #33
  %94 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

for.inc213:                                       ; preds = %sdslen.exit353, %sdslen.exit372
  %indvars.iv.next721 = add nuw nsw i64 %indvars.iv720, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next721, 4
  br i1 %exitcond.not, label %for.end215, label %for.body177, !llvm.loop !10

for.inc213.thread:                                ; preds = %sdslen.exit391
  %indvars.iv.next721740 = add nuw nsw i64 %indvars.iv720, 1
  %exitcond.not741 = icmp eq i64 %indvars.iv.next721740, 4
  br i1 %exitcond.not741, label %if.end219, label %for.body177.outer, !llvm.loop !10

for.end215:                                       ; preds = %for.inc213
  br i1 %cmp216, label %if.then218, label %if.end219

if.then218:                                       ; preds = %for.end215
  %95 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call143, i32 noundef %95) #33
  %96 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call110, i32 noundef %96) #33
  %97 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

if.end219:                                        ; preds = %for.inc213.thread, %for.end215
  %aux_tcp_port.2742750 = phi i32 [ %aux_tcp_port.1619.ph, %for.end215 ], [ %or, %for.inc213.thread ]
  %aux_tls_port.2743749 = phi i32 [ %aux_tls_port.1620.ph, %for.end215 ], [ %or201, %for.inc213.thread ]
  %98 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call143, i32 noundef %98) #33
  %indvars.iv.next724 = add nuw nsw i64 %indvars.iv723, 1
  %99 = load i32, ptr %aux_argc, align 4
  %100 = sext i32 %99 to i64
  %cmp135 = icmp slt i64 %indvars.iv.next724, %100
  br i1 %cmp135, label %for.body137, label %for.end222, !llvm.loop !11

for.end222:                                       ; preds = %if.end219, %if.end133
  %aux_tcp_port.0.lcssa = phi i32 [ 0, %if.end133 ], [ %aux_tcp_port.2742750, %if.end219 ]
  %aux_tls_port.0.lcssa = phi i32 [ 0, %if.end133 ], [ %aux_tls_port.2743749, %if.end219 ]
  %.lcssa = phi i32 [ %55, %if.end133 ], [ %99, %if.end219 ]
  %101 = load ptr, ptr %call110, align 8
  %call224 = call ptr @strrchr(ptr noundef nonnull dereferenceable(1) %101, i32 noundef 58) #34
  %cmp225 = icmp eq ptr %call224, null
  br i1 %cmp225, label %if.then227, label %if.end228

if.then227:                                       ; preds = %for.end222
  call void @sdsfreesplitres(ptr noundef nonnull %call110, i32 noundef %.lcssa) #33
  %102 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

if.end228:                                        ; preds = %for.end222
  store i8 0, ptr %call224, align 1
  %ip = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 21
  %103 = load ptr, ptr %call110, align 8
  %call231 = call i64 @strlen(ptr noundef nonnull dereferenceable(1) %103) #34
  %add232 = add i64 %call231, 1
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %ip, ptr align 1 %103, i64 %add232, i1 false)
  %add.ptr = getelementptr inbounds i8, ptr %call224, i64 1
  %call233 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %add.ptr, i32 noundef 64) #34
  %tobool234.not = icmp eq ptr %call233, null
  br i1 %tobool234.not, label %if.end236, label %if.then235

if.then235:                                       ; preds = %if.end228
  store i8 0, ptr %call233, align 1
  %incdec.ptr = getelementptr inbounds i8, ptr %call233, i64 1
  br label %if.end236

if.end236:                                        ; preds = %if.then235, %if.end228
  %busp.0 = phi ptr [ %incdec.ptr, %if.then235 ], [ null, %if.end228 ]
  %tobool237 = icmp ne i32 %aux_tcp_port.0.lcssa, 0
  %tobool239 = icmp ne i32 %aux_tls_port.0.lcssa, 0
  %or.cond1 = select i1 %tobool237, i1 true, i1 %tobool239
  br i1 %or.cond1, label %if.else247, label %if.then240

if.then240:                                       ; preds = %if.end236
  %104 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool241.not = icmp eq i32 %104, 0
  %call245 = call i32 @atoi(ptr nocapture noundef nonnull %add.ptr) #34
  br i1 %tobool241.not, label %if.else244, label %if.then242

if.then242:                                       ; preds = %if.then240
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 25
  store i32 %call245, ptr %tls_port, align 4
  br label %if.end259

if.else244:                                       ; preds = %if.then240
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 24
  store i32 %call245, ptr %tcp_port, align 8
  br label %if.end259

if.else247:                                       ; preds = %if.end236
  br i1 %tobool237, label %if.else252, label %if.then249

if.then249:                                       ; preds = %if.else247
  %call250 = call i32 @atoi(ptr nocapture noundef nonnull %add.ptr) #34
  %tcp_port251 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 24
  store i32 %call250, ptr %tcp_port251, align 8
  br label %if.end259

if.else252:                                       ; preds = %if.else247
  br i1 %tobool239, label %if.end259, label %if.then254

if.then254:                                       ; preds = %if.else252
  %call255 = call i32 @atoi(ptr nocapture noundef nonnull %add.ptr) #34
  %tls_port256 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 25
  store i32 %call255, ptr %tls_port256, align 4
  br label %if.end259

if.end259:                                        ; preds = %if.then249, %if.then254, %if.else252, %if.then242, %if.else244
  %tobool260.not = icmp eq ptr %busp.0, null
  br i1 %tobool260.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end259
  %call261 = call i32 @atoi(ptr nocapture noundef nonnull %busp.0) #34
  br label %cond.end

cond.false:                                       ; preds = %if.end259
  %105 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i = icmp eq i32 %105, 0
  %tls_port.i = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 25
  %tcp_port.i = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 24
  %cond.in.i = select i1 %tobool.not.i, ptr %tcp_port.i, ptr %tls_port.i
  %cond.i = load i32, ptr %cond.in.i, align 4
  %add263 = add nsw i32 %cond.i, 10000
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call261, %cond.true ], [ %add263, %cond.false ]
  %cport = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 26
  store i32 %cond, ptr %cport, align 8
  %106 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef nonnull %call110, i32 noundef %106) #33
  %arrayidx264 = getelementptr inbounds ptr, ptr %call38, i64 2
  %107 = load ptr, ptr %arrayidx264, align 8
  %tobool266.not629 = icmp eq ptr %107, null
  br i1 %tobool266.not629, label %while.end, label %while.body267.lr.ph

while.body267.lr.ph:                              ; preds = %cond.end
  %flags326 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 3
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 16
  br label %while.body267

while.body267:                                    ; preds = %while.body267.lr.ph, %if.end341
  %s.0630 = phi ptr [ %107, %while.body267.lr.ph ], [ %add.ptr344, %if.end341 ]
  %call268 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %s.0630, i32 noundef 44) #34
  %tobool269.not = icmp eq ptr %call268, null
  br i1 %tobool269.not, label %if.end271, label %if.then270

if.then270:                                       ; preds = %while.body267
  store i8 0, ptr %call268, align 1
  br label %if.end271

if.end271:                                        ; preds = %if.then270, %while.body267
  %call272 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.16) #34
  %tobool273.not = icmp eq i32 %call272, 0
  br i1 %tobool273.not, label %if.then274, label %if.else285

if.then274:                                       ; preds = %if.end271
  %108 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %109 = load ptr, ptr %108, align 8
  %cmp275 = icmp eq ptr %109, null
  br i1 %cmp275, label %cond.end282, label %cond.false281

cond.false281:                                    ; preds = %if.then274
  call void @_serverAssert(ptr noundef nonnull @.str.17, ptr noundef nonnull @.str.18, i32 noundef 529) #33
  call void @abort() #35
  unreachable

cond.end282:                                      ; preds = %if.then274
  store ptr %n.0, ptr %108, align 8
  store ptr %n.0, ptr @myself, align 8
  %110 = load i32, ptr %flags326, align 8
  %or284 = or i32 %110, 16
  store i32 %or284, ptr %flags326, align 8
  br label %if.end341

if.else285:                                       ; preds = %if.end271
  %call286 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.19) #34
  %tobool287.not = icmp eq i32 %call286, 0
  br i1 %tobool287.not, label %if.then288, label %if.else291

if.then288:                                       ; preds = %if.else285
  %111 = load i32, ptr %flags326, align 8
  %or290 = or i32 %111, 1
  store i32 %or290, ptr %flags326, align 8
  br label %if.end341

if.else291:                                       ; preds = %if.else285
  %call292 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.20) #34
  %tobool293.not = icmp eq i32 %call292, 0
  br i1 %tobool293.not, label %if.then294, label %if.else297

if.then294:                                       ; preds = %if.else291
  %112 = load i32, ptr %flags326, align 8
  %or296 = or i32 %112, 2
  store i32 %or296, ptr %flags326, align 8
  br label %if.end341

if.else297:                                       ; preds = %if.else291
  %call298 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.21) #34
  %tobool299.not = icmp eq i32 %call298, 0
  br i1 %tobool299.not, label %if.then300, label %if.else303

if.then300:                                       ; preds = %if.else297
  %113 = load i32, ptr %flags326, align 8
  %or302 = or i32 %113, 4
  store i32 %or302, ptr %flags326, align 8
  br label %if.end341

if.else303:                                       ; preds = %if.else297
  %call304 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.22) #34
  %tobool305.not = icmp eq i32 %call304, 0
  br i1 %tobool305.not, label %if.then306, label %if.else310

if.then306:                                       ; preds = %if.else303
  %114 = load i32, ptr %flags326, align 8
  %or308 = or i32 %114, 8
  store i32 %or308, ptr %flags326, align 8
  %call309 = call i64 @mstime() #33
  store i64 %call309, ptr %fail_time, align 8
  br label %if.end341

if.else310:                                       ; preds = %if.else303
  %call311 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.23) #34
  %tobool312.not = icmp eq i32 %call311, 0
  br i1 %tobool312.not, label %if.then313, label %if.else316

if.then313:                                       ; preds = %if.else310
  %115 = load i32, ptr %flags326, align 8
  %or315 = or i32 %115, 32
  store i32 %or315, ptr %flags326, align 8
  br label %if.end341

if.else316:                                       ; preds = %if.else310
  %call317 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.24) #34
  %tobool318.not = icmp eq i32 %call317, 0
  br i1 %tobool318.not, label %if.then319, label %if.else322

if.then319:                                       ; preds = %if.else316
  %116 = load i32, ptr %flags326, align 8
  %or321 = or i32 %116, 64
  store i32 %or321, ptr %flags326, align 8
  br label %if.end341

if.else322:                                       ; preds = %if.else316
  %call323 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.25) #34
  %tobool324.not = icmp eq i32 %call323, 0
  br i1 %tobool324.not, label %if.then325, label %if.else328

if.then325:                                       ; preds = %if.else322
  %117 = load i32, ptr %flags326, align 8
  %or327 = or i32 %117, 512
  store i32 %or327, ptr %flags326, align 8
  br label %if.end341

if.else328:                                       ; preds = %if.else322
  %call329 = call i32 @strcasecmp(ptr noundef nonnull %s.0630, ptr noundef nonnull @.str.26) #34
  %tobool330.not = icmp eq i32 %call329, 0
  br i1 %tobool330.not, label %if.end341, label %if.else332

if.else332:                                       ; preds = %if.else328
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.18, i32 noundef 550, ptr noundef nonnull @.str.27) #33
  call void @abort() #35
  unreachable

if.end341:                                        ; preds = %if.then288, %if.then300, %if.then313, %if.then325, %if.else328, %if.then319, %if.then306, %if.then294, %cond.end282
  %add.ptr344 = getelementptr inbounds i8, ptr %call268, i64 1
  br i1 %tobool269.not, label %while.end, label %while.body267, !llvm.loop !12

while.end:                                        ; preds = %if.end341, %cond.end
  %arrayidx346 = getelementptr inbounds ptr, ptr %call38, i64 3
  %118 = load ptr, ptr %arrayidx346, align 8
  %119 = load i8, ptr %118, align 1
  %cmp349.not = icmp eq i8 %119, 45
  br i1 %cmp349.not, label %if.else396, label %if.then351

if.then351:                                       ; preds = %while.end
  %arrayidx.i392 = getelementptr inbounds i8, ptr %118, i64 -1
  %120 = load i8, ptr %arrayidx.i392, align 1
  %conv.i393 = zext i8 %120 to i32
  %and.i394 = and i32 %conv.i393, 7
  switch i32 %and.i394, label %sdslen.exit410 [
    i32 0, label %sw.bb.i407
    i32 1, label %sw.bb3.i404
    i32 2, label %sw.bb5.i401
    i32 3, label %sw.bb9.i398
    i32 4, label %sw.bb13.i395
  ]

sw.bb.i407:                                       ; preds = %if.then351
  %shr.i408 = lshr i32 %conv.i393, 3
  %conv2.i409 = zext nneg i32 %shr.i408 to i64
  br label %sdslen.exit410

sw.bb3.i404:                                      ; preds = %if.then351
  %add.ptr.i405 = getelementptr inbounds i8, ptr %118, i64 -3
  %121 = load i8, ptr %add.ptr.i405, align 1
  %conv4.i406 = zext i8 %121 to i64
  br label %sdslen.exit410

sw.bb5.i401:                                      ; preds = %if.then351
  %add.ptr6.i402 = getelementptr inbounds i8, ptr %118, i64 -5
  %122 = load i16, ptr %add.ptr6.i402, align 1
  %conv8.i403 = zext i16 %122 to i64
  br label %sdslen.exit410

sw.bb9.i398:                                      ; preds = %if.then351
  %add.ptr10.i399 = getelementptr inbounds i8, ptr %118, i64 -9
  %123 = load i32, ptr %add.ptr10.i399, align 1
  %conv12.i400 = zext i32 %123 to i64
  br label %sdslen.exit410

sw.bb13.i395:                                     ; preds = %if.then351
  %add.ptr14.i396 = getelementptr inbounds i8, ptr %118, i64 -17
  %124 = load i64, ptr %add.ptr14.i396, align 1
  br label %sdslen.exit410

sdslen.exit410:                                   ; preds = %if.then351, %sw.bb.i407, %sw.bb3.i404, %sw.bb5.i401, %sw.bb9.i398, %sw.bb13.i395
  %retval.0.i397 = phi i64 [ %124, %sw.bb13.i395 ], [ %conv12.i400, %sw.bb9.i398 ], [ %conv8.i403, %sw.bb5.i401 ], [ %conv4.i406, %sw.bb3.i404 ], [ %conv2.i409, %sw.bb.i407 ], [ 0, %if.then351 ]
  %conv355 = trunc i64 %retval.0.i397 to i32
  %call356 = call i32 @verifyClusterNodeId(ptr noundef nonnull %118, i32 noundef %conv355) #33
  %cmp357 = icmp eq i32 %call356, -1
  br i1 %cmp357, label %if.then359, label %if.end360

if.then359:                                       ; preds = %sdslen.exit410
  %125 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

if.end360:                                        ; preds = %sdslen.exit410
  %126 = load ptr, ptr %arrayidx346, align 8
  %arrayidx.i411 = getelementptr inbounds i8, ptr %126, i64 -1
  %127 = load i8, ptr %arrayidx.i411, align 1
  %conv.i412 = zext i8 %127 to i32
  %and.i413 = and i32 %conv.i412, 7
  switch i32 %and.i413, label %sdslen.exit429 [
    i32 0, label %sw.bb.i426
    i32 1, label %sw.bb3.i423
    i32 2, label %sw.bb5.i420
    i32 3, label %sw.bb9.i417
    i32 4, label %sw.bb13.i414
  ]

sw.bb.i426:                                       ; preds = %if.end360
  %shr.i427 = lshr i32 %conv.i412, 3
  %conv2.i428 = zext nneg i32 %shr.i427 to i64
  br label %sdslen.exit429

sw.bb3.i423:                                      ; preds = %if.end360
  %add.ptr.i424 = getelementptr inbounds i8, ptr %126, i64 -3
  %128 = load i8, ptr %add.ptr.i424, align 1
  %conv4.i425 = zext i8 %128 to i64
  br label %sdslen.exit429

sw.bb5.i420:                                      ; preds = %if.end360
  %add.ptr6.i421 = getelementptr inbounds i8, ptr %126, i64 -5
  %129 = load i16, ptr %add.ptr6.i421, align 1
  %conv8.i422 = zext i16 %129 to i64
  br label %sdslen.exit429

sw.bb9.i417:                                      ; preds = %if.end360
  %add.ptr10.i418 = getelementptr inbounds i8, ptr %126, i64 -9
  %130 = load i32, ptr %add.ptr10.i418, align 1
  %conv12.i419 = zext i32 %130 to i64
  br label %sdslen.exit429

sw.bb13.i414:                                     ; preds = %if.end360
  %add.ptr14.i415 = getelementptr inbounds i8, ptr %126, i64 -17
  %131 = load i64, ptr %add.ptr14.i415, align 1
  br label %sdslen.exit429

sdslen.exit429:                                   ; preds = %if.end360, %sw.bb.i426, %sw.bb3.i423, %sw.bb5.i420, %sw.bb9.i417, %sw.bb13.i414
  %retval.0.i416 = phi i64 [ %131, %sw.bb13.i414 ], [ %conv12.i419, %sw.bb9.i417 ], [ %conv8.i422, %sw.bb5.i420 ], [ %conv4.i425, %sw.bb3.i423 ], [ %conv2.i428, %sw.bb.i426 ], [ 0, %if.end360 ]
  %conv364 = trunc i64 %retval.0.i416 to i32
  %call.i430 = call i32 @verifyClusterNodeId(ptr noundef nonnull %126, i32 noundef %conv364) #33
  %cmp.not.i431 = icmp eq i32 %call.i430, 0
  br i1 %cmp.not.i431, label %if.end.i433, label %if.then367

if.end.i433:                                      ; preds = %sdslen.exit429
  %sext526 = shl i64 %retval.0.i416, 32
  %conv.i434 = ashr exact i64 %sext526, 32
  %call1.i435 = call ptr @sdsnewlen(ptr noundef nonnull %126, i64 noundef %conv.i434) #33
  %132 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i436 = getelementptr inbounds %struct.clusterState, ptr %132, i64 0, i32 4
  %133 = load ptr, ptr %nodes.i436, align 8
  %call2.i437 = call ptr @dictFind(ptr noundef %133, ptr noundef %call1.i435) #33
  call void @sdsfree(ptr noundef %call1.i435) #33
  %cmp3.i438 = icmp eq ptr %call2.i437, null
  br i1 %cmp3.i438, label %if.then367, label %clusterLookupNode.exit441

clusterLookupNode.exit441:                        ; preds = %if.end.i433
  %call7.i440 = call ptr @dictGetVal(ptr noundef nonnull %call2.i437) #33
  %tobool366.not = icmp eq ptr %call7.i440, null
  br i1 %tobool366.not, label %if.then367, label %if.end370

if.then367:                                       ; preds = %if.end.i433, %sdslen.exit429, %clusterLookupNode.exit441
  %134 = load ptr, ptr %arrayidx346, align 8
  %call369 = call ptr @createClusterNode(ptr noundef %134, i32 noundef 0)
  %135 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i442 = getelementptr inbounds %struct.clusterState, ptr %135, i64 0, i32 4
  %136 = load ptr, ptr %nodes.i442, align 8
  %name.i443 = getelementptr inbounds %struct._clusterNode, ptr %call369, i64 0, i32 1
  %call.i444 = call ptr @sdsnewlen(ptr noundef nonnull %name.i443, i64 noundef 40) #33
  %call1.i445 = call i32 @dictAdd(ptr noundef %136, ptr noundef %call.i444, ptr noundef %call369) #33
  %cmp.i446 = icmp eq i32 %call1.i445, 0
  br i1 %cmp.i446, label %if.end370, label %cond.false.i447

cond.false.i447:                                  ; preds = %if.then367
  call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  call void @abort() #35
  unreachable

if.end370:                                        ; preds = %if.then367, %clusterLookupNode.exit441
  %master.0 = phi ptr [ %call7.i440, %clusterLookupNode.exit441 ], [ %call369, %if.then367 ]
  %137 = load ptr, ptr getelementptr inbounds ([4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 0, i32 3), align 8
  %call371 = call i32 %137(ptr noundef %n.0) #33
  %cmp372 = icmp eq i32 %call371, 0
  br i1 %cmp372, label %if.then374, label %if.else380

if.then374:                                       ; preds = %if.end370
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 2
  %shard_id376 = getelementptr inbounds %struct._clusterNode, ptr %master.0, i64 0, i32 2
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %shard_id, ptr noundef nonnull align 8 dereferenceable(40) %shard_id376, i64 40, i1 false)
  call void @clusterAddNodeToShard(ptr noundef nonnull %shard_id376, ptr noundef %n.0)
  br label %if.end394

if.else380:                                       ; preds = %if.end370
  %shard_id.i = getelementptr inbounds %struct._clusterNode, ptr %master.0, i64 0, i32 2
  %call.i449 = call ptr @sdsnewlen(ptr noundef nonnull %shard_id.i, i64 noundef 40) #33
  %138 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards.i = getelementptr inbounds %struct.clusterState, ptr %138, i64 0, i32 5
  %139 = load ptr, ptr %shards.i, align 8
  %call1.i450 = call ptr @dictFind(ptr noundef %139, ptr noundef %call.i449) #33
  call void @sdsfree(ptr noundef %call.i449) #33
  %cmp.not.i451 = icmp eq ptr %call1.i450, null
  br i1 %cmp.not.i451, label %if.end394, label %clusterGetNodesInMyShard.exit

clusterGetNodesInMyShard.exit:                    ; preds = %if.else380
  %call2.i452 = call ptr @dictGetVal(ptr noundef nonnull %call1.i450) #33
  %cmp382.not = icmp eq ptr %call2.i452, null
  br i1 %cmp382.not, label %if.end394, label %land.lhs.true384

land.lhs.true384:                                 ; preds = %clusterGetNodesInMyShard.exit
  %shard_id387 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 2
  %bcmp = call i32 @bcmp(ptr noundef nonnull dereferenceable(40) %shard_id.i, ptr noundef nonnull dereferenceable(40) %shard_id387, i64 40)
  %cmp390.not = icmp eq i32 %bcmp, 0
  br i1 %cmp390.not, label %if.end394, label %do.body554

if.end394:                                        ; preds = %if.else380, %clusterGetNodesInMyShard.exit, %land.lhs.true384, %if.then374
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 11
  store ptr %master.0, ptr %slaveof, align 8
  %numslaves.i = getelementptr inbounds %struct._clusterNode, ptr %master.0, i64 0, i32 9
  %140 = load i32, ptr %numslaves.i, align 8
  %cmp14.i = icmp sgt i32 %140, 0
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %master.0, i64 0, i32 10
  %141 = load ptr, ptr %slaves.i, align 8
  br i1 %cmp14.i, label %for.body.lr.ph.i, label %for.end.i

for.body.lr.ph.i:                                 ; preds = %if.end394
  %wide.trip.count.i = zext nneg i32 %140 to i64
  br label %for.body.i

for.cond.i:                                       ; preds = %for.body.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %for.end.i, label %for.body.i, !llvm.loop !13

for.body.i:                                       ; preds = %for.cond.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.cond.i ]
  %arrayidx.i457 = getelementptr inbounds ptr, ptr %141, i64 %indvars.iv.i
  %142 = load ptr, ptr %arrayidx.i457, align 8
  %cmp1.i = icmp eq ptr %142, %n.0
  br i1 %cmp1.i, label %if.end404, label %for.cond.i

for.end.i:                                        ; preds = %for.cond.i, %if.end394
  %add.i = add nsw i32 %140, 1
  %conv.i454 = sext i32 %add.i to i64
  %mul.i = shl nsw i64 %conv.i454, 3
  %call.i455 = call ptr @zrealloc(ptr noundef %141, i64 noundef %mul.i) #38
  store ptr %call.i455, ptr %slaves.i, align 8
  %143 = load i32, ptr %numslaves.i, align 8
  %idxprom7.i = sext i32 %143 to i64
  %arrayidx8.i = getelementptr inbounds ptr, ptr %call.i455, i64 %idxprom7.i
  store ptr %n.0, ptr %arrayidx8.i, align 8
  %144 = load i32, ptr %numslaves.i, align 8
  %inc10.i = add nsw i32 %144, 1
  store i32 %inc10.i, ptr %numslaves.i, align 8
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %master.0, i64 0, i32 3
  %145 = load i32, ptr %flags.i, align 8
  %or.i = or i32 %145, 256
  store i32 %or.i, ptr %flags.i, align 8
  br label %if.end404

if.else396:                                       ; preds = %while.end
  %146 = load ptr, ptr getelementptr inbounds ([4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 0, i32 3), align 8
  %call397 = call i32 %146(ptr noundef %n.0) #33
  %cmp398 = icmp eq i32 %call397, 0
  br i1 %cmp398, label %if.then400, label %if.end404

if.then400:                                       ; preds = %if.else396
  %shard_id401 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 2
  call void @clusterAddNodeToShard(ptr noundef nonnull %shard_id401, ptr noundef %n.0)
  br label %if.end404

if.end404:                                        ; preds = %for.body.i, %for.end.i, %if.else396, %if.then400
  %arrayidx405 = getelementptr inbounds ptr, ptr %call38, i64 4
  %147 = load ptr, ptr %arrayidx405, align 8
  %call406 = call i32 @atoi(ptr nocapture noundef %147) #34
  %tobool407.not = icmp eq i32 %call406, 0
  br i1 %tobool407.not, label %if.end410, label %if.then408

if.then408:                                       ; preds = %if.end404
  %call409 = call i64 @mstime() #33
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 13
  store i64 %call409, ptr %ping_sent, align 8
  br label %if.end410

if.end410:                                        ; preds = %if.then408, %if.end404
  %arrayidx411 = getelementptr inbounds ptr, ptr %call38, i64 5
  %148 = load ptr, ptr %arrayidx411, align 8
  %call412 = call i32 @atoi(ptr nocapture noundef %148) #34
  %tobool413.not = icmp eq i32 %call412, 0
  br i1 %tobool413.not, label %if.end416, label %if.then414

if.then414:                                       ; preds = %if.end410
  %call415 = call i64 @mstime() #33
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 14
  store i64 %call415, ptr %pong_received, align 8
  br label %if.end416

if.end416:                                        ; preds = %if.then414, %if.end410
  %flags417 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 3
  %149 = load i32, ptr %flags417, align 8
  %and = and i32 %149, 2
  %tobool418.not = icmp eq i32 %and, 0
  br i1 %tobool418.not, label %cond.false423, label %land.lhs.true419

land.lhs.true419:                                 ; preds = %if.end416
  %slaveof420 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 11
  %150 = load ptr, ptr %slaveof420, align 8
  %tobool421.not = icmp eq ptr %150, null
  br i1 %tobool421.not, label %cond.false423, label %cond.end426

cond.false423:                                    ; preds = %land.lhs.true419, %if.end416
  %arrayidx424 = getelementptr inbounds ptr, ptr %call38, i64 6
  %151 = load ptr, ptr %arrayidx424, align 8
  %call425 = call i64 @strtoull(ptr nocapture noundef %151, ptr noundef null, i32 noundef 10) #33
  br label %cond.end426

cond.end426:                                      ; preds = %land.lhs.true419, %cond.false423
  %cond427 = phi i64 [ %call425, %cond.false423 ], [ 0, %land.lhs.true419 ]
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 4
  store i64 %cond427, ptr %configEpoch, align 8
  %152 = load i32, ptr %argc, align 4
  %cmp429633 = icmp sgt i32 %152, 8
  br i1 %cmp429633, label %for.body431.lr.ph, label %while.cond.backedge.sink.split

for.body431.lr.ph:                                ; preds = %cond.end426
  %slots.i509 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 5
  %numslots.i = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 8
  br label %for.body431

for.body431:                                      ; preds = %for.body431.lr.ph, %for.inc529
  %indvars.iv729 = phi i64 [ 8, %for.body431.lr.ph ], [ %indvars.iv.next730, %for.inc529 ]
  %arrayidx433 = getelementptr inbounds ptr, ptr %call38, i64 %indvars.iv729
  %153 = load ptr, ptr %arrayidx433, align 8
  %154 = load i8, ptr %153, align 1
  %cmp436 = icmp eq i8 %154, 91
  %call441 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %153, i32 noundef 45) #34
  %cmp442.not = icmp eq ptr %call441, null
  br i1 %cmp436, label %if.then438, label %if.else491

if.then438:                                       ; preds = %for.body431
  br i1 %cmp442.not, label %cond.false451, label %cond.end452

cond.false451:                                    ; preds = %if.then438
  call void @_serverAssert(ptr noundef nonnull @.str.28, ptr noundef nonnull @.str.18, i32 noundef 610) #33
  call void @abort() #35
  unreachable

cond.end452:                                      ; preds = %if.then438
  store i8 0, ptr %call441, align 1
  %arrayidx453 = getelementptr inbounds i8, ptr %call441, i64 1
  %155 = load i8, ptr %arrayidx453, align 1
  %156 = load ptr, ptr %arrayidx433, align 8
  %add.ptr456 = getelementptr inbounds i8, ptr %156, i64 1
  %call457 = call i32 @atoi(ptr nocapture noundef nonnull %add.ptr456) #34
  %or.cond2 = icmp ugt i32 %call457, 16383
  br i1 %or.cond2, label %if.then463, label %if.end464

if.then463:                                       ; preds = %cond.end452
  %157 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

if.end464:                                        ; preds = %cond.end452
  %add.ptr465 = getelementptr inbounds i8, ptr %call441, i64 3
  %call466 = call ptr @strchr(ptr noundef nonnull dereferenceable(1) %add.ptr465, i32 noundef 93) #34
  %cmp467 = icmp eq ptr %call466, null
  br i1 %cmp467, label %if.then474, label %lor.lhs.false469

lor.lhs.false469:                                 ; preds = %if.end464
  %sub.ptr.lhs.cast = ptrtoint ptr %call466 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %add.ptr465 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv470 = trunc i64 %sub.ptr.sub to i32
  %call471 = call i32 @verifyClusterNodeId(ptr noundef nonnull %add.ptr465, i32 noundef %conv470) #33
  %cmp472 = icmp eq i32 %call471, -1
  br i1 %cmp472, label %if.then474, label %if.end475

if.then474:                                       ; preds = %lor.lhs.false469, %if.end464
  %158 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

if.end475:                                        ; preds = %lor.lhs.false469
  %call.i458 = call i32 @verifyClusterNodeId(ptr noundef nonnull %add.ptr465, i32 noundef 40) #33
  %cmp.not.i459 = icmp eq i32 %call.i458, 0
  br i1 %cmp.not.i459, label %if.end.i461, label %if.then478

if.end.i461:                                      ; preds = %if.end475
  %call1.i462 = call ptr @sdsnewlen(ptr noundef nonnull %add.ptr465, i64 noundef 40) #33
  %159 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i463 = getelementptr inbounds %struct.clusterState, ptr %159, i64 0, i32 4
  %160 = load ptr, ptr %nodes.i463, align 8
  %call2.i464 = call ptr @dictFind(ptr noundef %160, ptr noundef %call1.i462) #33
  call void @sdsfree(ptr noundef %call1.i462) #33
  %cmp3.i465 = icmp eq ptr %call2.i464, null
  br i1 %cmp3.i465, label %if.then478, label %clusterLookupNode.exit468

clusterLookupNode.exit468:                        ; preds = %if.end.i461
  %call7.i467 = call ptr @dictGetVal(ptr noundef nonnull %call2.i464) #33
  %tobool477.not = icmp eq ptr %call7.i467, null
  br i1 %tobool477.not, label %if.then478, label %if.end480

if.then478:                                       ; preds = %if.end.i461, %if.end475, %clusterLookupNode.exit468
  %call.i469 = call noalias dereferenceable_or_null(2368) ptr @zmalloc(i64 noundef 2368) #37
  %name1.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %name1.i, ptr noundef nonnull align 1 dereferenceable(40) %add.ptr465, i64 40, i1 false)
  %shard_id.i471 = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 2
  call void @getRandomHexChars(ptr noundef nonnull %shard_id.i471, i64 noundef 40) #33
  %call4.i = call i64 @mstime() #33
  store i64 %call4.i, ptr %call.i469, align 8
  %configEpoch.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 4
  %flags5.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 3
  store i32 0, ptr %flags5.i, align 8
  %slaves.i472 = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 10
  %link.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 27
  %ip.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 21
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip.i, i8 0, i64 46, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) %slaves.i472, i8 0, i64 56, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %link.i, i8 0, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2076) %configEpoch.i, i8 0, i64 2076, i1 false)
  %call8.i = call ptr @sdsempty() #33
  %hostname.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 22
  store ptr %call8.i, ptr %hostname.i, align 8
  %call9.i = call ptr @sdsempty() #33
  %human_nodename.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 23
  store ptr %call9.i, ptr %human_nodename.i, align 8
  %tcp_port.i473 = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 24
  store i32 0, ptr %tcp_port.i473, align 8
  %cport.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 26
  store i32 0, ptr %cport.i, align 8
  %tls_port.i474 = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 25
  store i32 0, ptr %tls_port.i474, align 4
  %call10.i = call ptr @listCreate() #33
  %fail_reports.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 29
  store ptr %call10.i, ptr %fail_reports.i, align 8
  %voted_time.i = getelementptr inbounds %struct._clusterNode, ptr %call.i469, i64 0, i32 17
  %free.i = getelementptr inbounds %struct.list, ptr %call10.i, i64 0, i32 3
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %voted_time.i, i8 0, i64 32, i1 false)
  store ptr @zfree, ptr %free.i, align 8
  %161 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i475 = getelementptr inbounds %struct.clusterState, ptr %161, i64 0, i32 4
  %162 = load ptr, ptr %nodes.i475, align 8
  %call.i477 = call ptr @sdsnewlen(ptr noundef nonnull %name1.i, i64 noundef 40) #33
  %call1.i478 = call i32 @dictAdd(ptr noundef %162, ptr noundef %call.i477, ptr noundef nonnull %call.i469) #33
  %cmp.i479 = icmp eq i32 %call1.i478, 0
  br i1 %cmp.i479, label %if.end480, label %cond.false.i480

cond.false.i480:                                  ; preds = %if.then478
  call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  call void @abort() #35
  unreachable

if.end480:                                        ; preds = %if.then478, %clusterLookupNode.exit468
  %cn.0 = phi ptr [ %call7.i467, %clusterLookupNode.exit468 ], [ %call.i469, %if.then478 ]
  %cmp482 = icmp eq i8 %155, 62
  %163 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom485 = zext nneg i32 %call457 to i64
  %arrayidx486 = getelementptr inbounds %struct.clusterState, ptr %163, i64 0, i32 7, i64 %idxprom485
  %arrayidx489 = getelementptr inbounds %struct.clusterState, ptr %163, i64 0, i32 8, i64 %idxprom485
  %arrayidx486.sink = select i1 %cmp482, ptr %arrayidx486, ptr %arrayidx489
  store ptr %cn.0, ptr %arrayidx486.sink, align 8
  br label %for.inc529

if.else491:                                       ; preds = %for.body431
  br i1 %cmp442.not, label %if.else503, label %if.then497

if.then497:                                       ; preds = %if.else491
  store i8 0, ptr %call441, align 1
  %164 = load ptr, ptr %arrayidx433, align 8
  %call500 = call i32 @atoi(ptr nocapture noundef %164) #34
  %add.ptr501 = getelementptr inbounds i8, ptr %call441, i64 1
  %call502 = call i32 @atoi(ptr nocapture noundef nonnull %add.ptr501) #34
  br label %if.end508

if.else503:                                       ; preds = %if.else491
  %call506 = call i32 @atoi(ptr nocapture noundef nonnull %153) #34
  br label %if.end508

if.end508:                                        ; preds = %if.then497, %if.else503
  %start.0 = phi i32 [ %call500, %if.then497 ], [ %call506, %if.else503 ]
  %stop.0 = phi i32 [ %call502, %if.then497 ], [ %call506, %if.else503 ]
  %or.cond3 = icmp ugt i32 %start.0, 16383
  %cmp515 = icmp slt i32 %stop.0, 0
  %or.cond4 = select i1 %or.cond3, i1 true, i1 %cmp515
  %cmp518 = icmp sgt i32 %stop.0, 16383
  %or.cond5 = select i1 %or.cond4, i1 true, i1 %cmp518
  br i1 %or.cond5, label %if.then520, label %while.cond522.preheader

while.cond522.preheader:                          ; preds = %if.end508
  %cmp523.not631 = icmp ugt i32 %start.0, %stop.0
  br i1 %cmp523.not631, label %for.inc529, label %while.body525.preheader

while.body525.preheader:                          ; preds = %while.cond522.preheader
  %165 = zext nneg i32 %start.0 to i64
  %.pre735 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %while.body525

if.then520:                                       ; preds = %if.end508
  %166 = load i32, ptr %argc, align 4
  br label %do.body554.sink.split

while.body525:                                    ; preds = %while.body525.preheader, %clusterAddSlot.exit
  %167 = phi ptr [ %.pre735, %while.body525.preheader ], [ %181, %clusterAddSlot.exit ]
  %indvars.iv726 = phi i64 [ %165, %while.body525.preheader ], [ %indvars.iv.next727, %clusterAddSlot.exit ]
  %indvars.iv.next727 = add nuw nsw i64 %indvars.iv726, 1
  %arrayidx.i482 = getelementptr inbounds %struct.clusterState, ptr %167, i64 0, i32 9, i64 %indvars.iv726
  %168 = load ptr, ptr %arrayidx.i482, align 8
  %tobool.not.i483 = icmp eq ptr %168, null
  %169 = trunc i64 %indvars.iv726 to i32
  br i1 %tobool.not.i483, label %if.end.i485, label %clusterAddSlot.exit

if.end.i485:                                      ; preds = %while.body525
  %div.i.i641 = lshr i64 %indvars.iv726, 3
  %conv.i.i = and i64 %div.i.i641, 536870911
  %and.i.i = and i32 %169, 7
  %arrayidx.i.i = getelementptr inbounds i8, ptr %slots.i509, i64 %conv.i.i
  %170 = load i8, ptr %arrayidx.i.i, align 1
  %conv1.i.i = zext i8 %170 to i32
  %171 = shl nuw nsw i32 1, %and.i.i
  %172 = and i32 %171, %conv1.i.i
  %tobool.not.i510 = icmp eq i32 %172, 0
  br i1 %tobool.not.i510, label %if.then.i, label %clusterNodeSetSlotBit.exit

if.then.i:                                        ; preds = %if.end.i485
  %173 = trunc i32 %171 to i8
  %conv2.i.i = or i8 %170, %173
  store i8 %conv2.i.i, ptr %arrayidx.i.i, align 1
  %174 = load i32, ptr %numslots.i, align 4
  %inc.i = add nsw i32 %174, 1
  store i32 %inc.i, ptr %numslots.i, align 4
  %cmp.i511 = icmp eq i32 %174, 0
  br i1 %cmp.i511, label %land.lhs.true.i, label %clusterNodeSetSlotBit.exit

land.lhs.true.i:                                  ; preds = %if.then.i
  %175 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i.i = getelementptr inbounds %struct.clusterState, ptr %175, i64 0, i32 4
  %176 = load ptr, ptr %nodes.i.i, align 8
  %call.i.i = call ptr @dictGetSafeIterator(ptr noundef %176) #33
  br label %while.cond.outer.i.i

while.cond.outer.i.i:                             ; preds = %if.end.i.i, %land.lhs.true.i
  %slaves.0.ph.i.i = phi i32 [ %add.i.i, %if.end.i.i ], [ 0, %land.lhs.true.i ]
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.body.i.i, %while.cond.outer.i.i
  %call1.i.i = call ptr @dictNext(ptr noundef %call.i.i) #33
  %cmp.not.i.i = icmp eq ptr %call1.i.i, null
  br i1 %cmp.not.i.i, label %clusterMastersHaveSlaves.exit.i, label %while.body.i.i

while.body.i.i:                                   ; preds = %while.cond.i.i
  %call2.i.i = call ptr @dictGetVal(ptr noundef nonnull %call1.i.i) #33
  %flags.i.i = getelementptr inbounds %struct._clusterNode, ptr %call2.i.i, i64 0, i32 3
  %177 = load i32, ptr %flags.i.i, align 8
  %and.i11.i = and i32 %177, 2
  %tobool.not.i.i = icmp eq i32 %and.i11.i, 0
  br i1 %tobool.not.i.i, label %if.end.i.i, label %while.cond.i.i, !llvm.loop !14

if.end.i.i:                                       ; preds = %while.body.i.i
  %numslaves.i.i = getelementptr inbounds %struct._clusterNode, ptr %call2.i.i, i64 0, i32 9
  %178 = load i32, ptr %numslaves.i.i, align 8
  %add.i.i = add nsw i32 %178, %slaves.0.ph.i.i
  br label %while.cond.outer.i.i, !llvm.loop !14

clusterMastersHaveSlaves.exit.i:                  ; preds = %while.cond.i.i
  call void @dictReleaseIterator(ptr noundef %call.i.i) #33
  %cmp3.i.not.i = icmp eq i32 %slaves.0.ph.i.i, 0
  br i1 %cmp3.i.not.i, label %clusterNodeSetSlotBit.exit, label %if.then6.i

if.then6.i:                                       ; preds = %clusterMastersHaveSlaves.exit.i
  %179 = load i32, ptr %flags417, align 8
  %or.i513 = or i32 %179, 256
  store i32 %or.i513, ptr %flags417, align 8
  br label %clusterNodeSetSlotBit.exit

clusterNodeSetSlotBit.exit:                       ; preds = %if.end.i485, %if.then.i, %clusterMastersHaveSlaves.exit.i, %if.then6.i
  %180 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx3.i = getelementptr inbounds %struct.clusterState, ptr %180, i64 0, i32 9, i64 %indvars.iv726
  store ptr %n.0, ptr %arrayidx3.i, align 8
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %clusterAddSlot.exit

clusterAddSlot.exit:                              ; preds = %while.body525, %clusterNodeSetSlotBit.exit
  %181 = phi ptr [ %.pre, %clusterNodeSetSlotBit.exit ], [ %167, %while.body525 ]
  %cmp523.not.not = icmp sgt i32 %stop.0, %169
  br i1 %cmp523.not.not, label %while.body525, label %for.inc529, !llvm.loop !15

for.inc529:                                       ; preds = %clusterAddSlot.exit, %if.end480, %while.cond522.preheader
  %indvars.iv.next730 = add nuw nsw i64 %indvars.iv729, 1
  %182 = load i32, ptr %argc, align 4
  %183 = sext i32 %182 to i64
  %cmp429 = icmp slt i64 %indvars.iv.next730, %183
  br i1 %cmp429, label %for.body431, label %while.cond.backedge.sink.split, !llvm.loop !16

while.end532:                                     ; preds = %while.cond.backedge, %if.end24
  %184 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %185 = load ptr, ptr %184, align 8
  %cmp534 = icmp eq ptr %185, null
  br i1 %cmp534, label %do.body554, label %if.end537

if.end537:                                        ; preds = %while.end532
  call void @zfree(ptr noundef %call25) #33
  %call538 = call i32 @fclose(ptr noundef nonnull %call)
  %186 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp540 = icmp sgt i32 %186, 2
  br i1 %cmp540, label %do.end545, label %if.end543

if.end543:                                        ; preds = %if.end537
  %187 = load ptr, ptr @myself, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %187, i64 0, i32 1
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.29, ptr noundef nonnull %name) #33
  br label %do.end545

do.end545:                                        ; preds = %if.end537, %if.end543
  %188 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i487 = getelementptr inbounds %struct.clusterState, ptr %188, i64 0, i32 4
  %189 = load ptr, ptr %nodes.i487, align 8
  %call.i488 = call ptr @dictGetSafeIterator(ptr noundef %189) #33
  %call17.i = call ptr @dictNext(ptr noundef %call.i488) #33
  %cmp.not8.i = icmp eq ptr %call17.i, null
  br i1 %cmp.not8.i, label %clusterGetMaxEpoch.exit, label %while.body.i

while.body.i:                                     ; preds = %do.end545, %while.body.i
  %call110.i = phi ptr [ %call1.i491, %while.body.i ], [ %call17.i, %do.end545 ]
  %max.09.i = phi i64 [ %spec.select.i, %while.body.i ], [ 0, %do.end545 ]
  %call2.i489 = call ptr @dictGetVal(ptr noundef nonnull %call110.i) #33
  %configEpoch.i490 = getelementptr inbounds %struct._clusterNode, ptr %call2.i489, i64 0, i32 4
  %190 = load i64, ptr %configEpoch.i490, align 8
  %spec.select.i = call i64 @llvm.umax.i64(i64 %190, i64 %max.09.i)
  %call1.i491 = call ptr @dictNext(ptr noundef %call.i488) #33
  %cmp.not.i492 = icmp eq ptr %call1.i491, null
  br i1 %cmp.not.i492, label %clusterGetMaxEpoch.exit, label %while.body.i, !llvm.loop !17

clusterGetMaxEpoch.exit:                          ; preds = %while.body.i, %do.end545
  %max.0.lcssa.i = phi i64 [ 0, %do.end545 ], [ %spec.select.i, %while.body.i ]
  call void @dictReleaseIterator(ptr noundef %call.i488) #33
  %191 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch.i = getelementptr inbounds %struct.clusterState, ptr %191, i64 0, i32 1
  %192 = load i64, ptr %currentEpoch.i, align 8
  %cmp548 = icmp ugt i64 %max.0.lcssa.i, %192
  br i1 %cmp548, label %if.then550, label %return

if.then550:                                       ; preds = %clusterGetMaxEpoch.exit
  %nodes.i493 = getelementptr inbounds %struct.clusterState, ptr %191, i64 0, i32 4
  %193 = load ptr, ptr %nodes.i493, align 8
  %call.i494 = call ptr @dictGetSafeIterator(ptr noundef %193) #33
  %call17.i495 = call ptr @dictNext(ptr noundef %call.i494) #33
  %cmp.not8.i496 = icmp eq ptr %call17.i495, null
  br i1 %cmp.not8.i496, label %clusterGetMaxEpoch.exit508, label %while.body.i497

while.body.i497:                                  ; preds = %if.then550, %while.body.i497
  %call110.i498 = phi ptr [ %call1.i503, %while.body.i497 ], [ %call17.i495, %if.then550 ]
  %max.09.i499 = phi i64 [ %spec.select.i502, %while.body.i497 ], [ 0, %if.then550 ]
  %call2.i500 = call ptr @dictGetVal(ptr noundef nonnull %call110.i498) #33
  %configEpoch.i501 = getelementptr inbounds %struct._clusterNode, ptr %call2.i500, i64 0, i32 4
  %194 = load i64, ptr %configEpoch.i501, align 8
  %spec.select.i502 = call i64 @llvm.umax.i64(i64 %194, i64 %max.09.i499)
  %call1.i503 = call ptr @dictNext(ptr noundef %call.i494) #33
  %cmp.not.i504 = icmp eq ptr %call1.i503, null
  br i1 %cmp.not.i504, label %clusterGetMaxEpoch.exit508, label %while.body.i497, !llvm.loop !17

clusterGetMaxEpoch.exit508:                       ; preds = %while.body.i497, %if.then550
  %max.0.lcssa.i505 = phi i64 [ 0, %if.then550 ], [ %spec.select.i502, %while.body.i497 ]
  call void @dictReleaseIterator(ptr noundef %call.i494) #33
  %195 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch.i506 = getelementptr inbounds %struct.clusterState, ptr %195, i64 0, i32 1
  %196 = load i64, ptr %currentEpoch.i506, align 8
  %spec.select6.i507 = call i64 @llvm.umax.i64(i64 %max.0.lcssa.i505, i64 %196)
  store i64 %spec.select6.i507, ptr %currentEpoch.i506, align 8
  br label %return

do.body554.sink.split:                            ; preds = %if.end83, %if.then520, %if.then474, %if.then463, %if.then359, %if.then227, %if.then218, %if.then211, %if.then168, %if.end153, %if.then113, %if.then95
  %.sink = phi i32 [ %22, %if.then95 ], [ %40, %if.then113 ], [ %64, %if.end153 ], [ %75, %if.then168 ], [ %94, %if.then211 ], [ %97, %if.then218 ], [ %102, %if.then227 ], [ %125, %if.then359 ], [ %157, %if.then463 ], [ %158, %if.then474 ], [ %166, %if.then520 ], [ %7, %if.end83 ]
  call void @sdsfreesplitres(ptr noundef nonnull %call38, i32 noundef %.sink) #33
  br label %do.body554

do.body554:                                       ; preds = %if.end37, %if.then47, %land.lhs.true384, %do.body554.sink.split, %while.end532
  %197 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp555 = icmp sgt i32 %197, 3
  br i1 %cmp555, label %do.end559, label %if.end558

if.end558:                                        ; preds = %do.body554
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.30, ptr noundef %call25) #33
  br label %do.end559

do.end559:                                        ; preds = %do.body554, %if.end558
  call void @zfree(ptr noundef %call25) #33
  %call562 = call i32 @fclose(ptr noundef nonnull %call)
  call void @exit(i32 noundef 1) #35
  unreachable

return:                                           ; preds = %clusterGetMaxEpoch.exit, %clusterGetMaxEpoch.exit508, %if.then, %if.then22
  %retval.0 = phi i32 [ -1, %if.then22 ], [ -1, %if.then ], [ 0, %clusterGetMaxEpoch.exit508 ], [ 0, %clusterGetMaxEpoch.exit ]
  ret i32 %retval.0
}

; Function Attrs: nofree nounwind
declare noalias noundef ptr @fopen64(ptr nocapture noundef readonly, ptr nocapture noundef readonly) local_unnamed_addr #10

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare ptr @__errno_location() local_unnamed_addr #11

declare void @_serverLog(i32 noundef, ptr noundef, ...) local_unnamed_addr #1

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) local_unnamed_addr #12

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) local_unnamed_addr #13

; Function Attrs: nofree nounwind
declare noundef i32 @fstat64(i32 noundef, ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: nofree nounwind
declare noundef i32 @fileno(ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: nofree nounwind
declare noundef i32 @fclose(ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: allocsize(0)
declare noalias ptr @zmalloc(i64 noundef) local_unnamed_addr #14

; Function Attrs: nofree nounwind
declare noundef ptr @fgets(ptr noundef, i32 noundef, ptr nocapture noundef) local_unnamed_addr #10

declare ptr @sdssplitargs(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree nounwind willreturn memory(read)
declare i32 @strcasecmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #9

; Function Attrs: mustprogress nofree nounwind willreturn
declare i64 @strtoull(ptr noundef readonly, ptr nocapture noundef, i32 noundef) local_unnamed_addr #15

declare void @sdsfreesplitres(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterLookupNode(ptr noundef %name, i32 noundef %length) local_unnamed_addr #2 {
entry:
  %call = tail call i32 @verifyClusterNodeId(ptr noundef %name, i32 noundef %length) #33
  %cmp.not = icmp eq i32 %call, 0
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %conv = sext i32 %length to i64
  %call1 = tail call ptr @sdsnewlen(ptr noundef %name, i64 noundef %conv) #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call2 = tail call ptr @dictFind(ptr noundef %1, ptr noundef %call1) #33
  tail call void @sdsfree(ptr noundef %call1) #33
  %cmp3 = icmp eq ptr %call2, null
  br i1 %cmp3, label %return, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = tail call ptr @dictGetVal(ptr noundef nonnull %call2) #33
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end6
  %retval.0 = phi ptr [ %call7, %if.end6 ], [ null, %entry ], [ null, %if.end ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @createClusterNode(ptr noundef readonly %nodename, i32 noundef %flags) local_unnamed_addr #2 {
entry:
  %call = tail call noalias dereferenceable_or_null(2368) ptr @zmalloc(i64 noundef 2368) #37
  %tobool.not = icmp eq ptr %nodename, null
  %name1 = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 1
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %name1, ptr noundef nonnull align 1 dereferenceable(40) %nodename, i64 40, i1 false)
  br label %if.end

if.else:                                          ; preds = %entry
  tail call void @getRandomHexChars(ptr noundef nonnull %name1, i64 noundef 40) #33
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 2
  tail call void @getRandomHexChars(ptr noundef nonnull %shard_id, i64 noundef 40) #33
  %call4 = tail call i64 @mstime() #33
  store i64 %call4, ptr %call, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 4
  store i64 0, ptr %configEpoch, align 8
  %flags5 = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 3
  store i32 %flags, ptr %flags5, align 8
  %slots = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 5
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 10
  %link = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 27
  %ip = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 21
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip, i8 0, i64 46, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2068) %slots, i8 0, i64 2068, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) %slaves, i8 0, i64 56, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %link, i8 0, i64 16, i1 false)
  %call8 = tail call ptr @sdsempty() #33
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 22
  store ptr %call8, ptr %hostname, align 8
  %call9 = tail call ptr @sdsempty() #33
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 23
  store ptr %call9, ptr %human_nodename, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 24
  store i32 0, ptr %tcp_port, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 26
  store i32 0, ptr %cport, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 25
  store i32 0, ptr %tls_port, align 4
  %call10 = tail call ptr @listCreate() #33
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 29
  store ptr %call10, ptr %fail_reports, align 8
  %voted_time = getelementptr inbounds %struct._clusterNode, ptr %call, i64 0, i32 17
  %free = getelementptr inbounds %struct.list, ptr %call10, i64 0, i32 3
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %voted_time, i8 0, i64 32, i1 false)
  store ptr @zfree, ptr %free, align 8
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterAddNode(ptr noundef %node) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %call = tail call ptr @sdsnewlen(ptr noundef nonnull %name, i64 noundef 40) #33
  %call1 = tail call i32 @dictAdd(ptr noundef %1, ptr noundef %call, ptr noundef %node) #33
  %cmp = icmp eq i32 %call1, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  ret void
}

declare ptr @sdssplitlen(ptr noundef, i64 noundef, ptr noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

declare ptr @sdscpy(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @isValidAuxString(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strrchr(ptr noundef, i32 noundef) local_unnamed_addr #7

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare ptr @strchr(ptr noundef, i32 noundef) local_unnamed_addr #7

declare void @_serverAssert(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: noreturn nounwind
declare void @abort() local_unnamed_addr #13

declare i64 @mstime() local_unnamed_addr #1

declare void @_serverPanic(ptr noundef, i32 noundef, ptr noundef, ...) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterGetNodesInMyShard(ptr noundef %node) local_unnamed_addr #2 {
entry:
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 2
  %call = tail call ptr @sdsnewlen(ptr noundef nonnull %shard_id, i64 noundef 40) #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 5
  %1 = load ptr, ptr %shards, align 8
  %call1 = tail call ptr @dictFind(ptr noundef %1, ptr noundef %call) #33
  tail call void @sdsfree(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call1) #33
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ null, %entry ]
  ret ptr %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeAddSlave(ptr nocapture noundef %master, ptr noundef %slave) local_unnamed_addr #2 {
entry:
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %master, i64 0, i32 9
  %0 = load i32, ptr %numslaves, align 8
  %cmp14 = icmp sgt i32 %0, 0
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %master, i64 0, i32 10
  %1 = load ptr, ptr %slaves, align 8
  br i1 %cmp14, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %wide.trip.count = zext nneg i32 %0 to i64
  br label %for.body

for.cond:                                         ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !13

for.body:                                         ; preds = %for.body.lr.ph, %for.cond
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.cond ]
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %cmp1 = icmp eq ptr %2, %slave
  br i1 %cmp1, label %return, label %for.cond

for.end:                                          ; preds = %for.cond, %entry
  %slaves2 = getelementptr inbounds %struct._clusterNode, ptr %master, i64 0, i32 10
  %add = add nsw i32 %0, 1
  %conv = sext i32 %add to i64
  %mul = shl nsw i64 %conv, 3
  %call = tail call ptr @zrealloc(ptr noundef %1, i64 noundef %mul) #38
  store ptr %call, ptr %slaves2, align 8
  %3 = load i32, ptr %numslaves, align 8
  %idxprom7 = sext i32 %3 to i64
  %arrayidx8 = getelementptr inbounds ptr, ptr %call, i64 %idxprom7
  store ptr %slave, ptr %arrayidx8, align 8
  %4 = load i32, ptr %numslaves, align 8
  %inc10 = add nsw i32 %4, 1
  store i32 %inc10, ptr %numslaves, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %master, i64 0, i32 3
  %5 = load i32, ptr %flags, align 8
  %or = or i32 %5, 256
  store i32 %or, ptr %flags, align 8
  br label %return

return:                                           ; preds = %for.body, %for.end
  %retval.0 = phi i32 [ 0, %for.end ], [ -1, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterAddSlot(ptr noundef %n, i32 noundef %slot) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom = sext i32 %slot to i64
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 9, i64 %idxprom
  %1 = load ptr, ptr %arrayidx, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %call = tail call i32 @clusterNodeSetSlotBit(ptr noundef %n, i32 noundef %slot), !range !18
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx3 = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 9, i64 %idxprom
  store ptr %n, ptr %arrayidx3, align 8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -1, %entry ]
  ret i32 %retval.0
}

declare void @zfree(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @clusterGetMaxEpoch() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  %call17 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not8 = icmp eq ptr %call17, null
  br i1 %cmp.not8, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body
  %call110 = phi ptr [ %call1, %while.body ], [ %call17, %entry ]
  %max.09 = phi i64 [ %spec.select, %while.body ], [ 0, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call110) #33
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 4
  %2 = load i64, ptr %configEpoch, align 8
  %spec.select = tail call i64 @llvm.umax.i64(i64 %2, i64 %max.09)
  %call1 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !17

while.end:                                        ; preds = %while.body, %entry
  %max.0.lcssa = phi i64 [ 0, %entry ], [ %spec.select, %while.body ]
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 1
  %4 = load i64, ptr %currentEpoch, align 8
  %spec.select6 = tail call i64 @llvm.umax.i64(i64 %max.0.lcssa, i64 %4)
  ret i64 %spec.select6
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterSaveConfig(i32 noundef %do_fsync) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 22
  %1 = load i32, ptr %todo_before_sleep, align 8
  %and = and i32 %1, -5
  store i32 %and, ptr %todo_before_sleep, align 8
  %call = tail call ptr @clusterGenNodesDescription(ptr noundef null, i32 noundef 32, i32 noundef 0)
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 1
  %3 = load i64, ptr %currentEpoch, align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 21
  %4 = load i64, ptr %lastVoteEpoch, align 8
  %call2 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call, ptr noundef nonnull @.str.31, i64 noundef %3, i64 noundef %4) #33
  %arrayidx.i = getelementptr inbounds i8, ptr %call2, i64 -1
  %5 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %5 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %call2, i64 -3
  %6 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %6 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %call2, i64 -5
  %7 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %7 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %call2, i64 -9
  %8 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %8 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %call2, i64 -17
  %9 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %9, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %call4 = tail call ptr @sdsempty() #33
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 366), align 8
  %call5 = tail call i32 @getpid() #33
  %call6 = tail call i64 @mstime() #33
  %call7 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call4, ptr noundef nonnull @.str.32, ptr noundef %10, i32 noundef %call5, i64 noundef %call6) #33
  %call8 = tail call i32 (ptr, i32, ...) @open64(ptr noundef %call7, i32 noundef 65, i32 noundef 420) #33
  %cmp = icmp eq i32 %call8, -1
  br i1 %cmp, label %do.body, label %while.cond.preheader

while.cond.preheader:                             ; preds = %sdslen.exit
  %cmp1430.not = icmp eq i64 %retval.0.i, 0
  br i1 %cmp1430.not, label %while.end, label %while.cond.outer.split

do.body:                                          ; preds = %sdslen.exit
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp9 = icmp sgt i32 %11, 3
  br i1 %cmp9, label %if.then75, label %if.end

if.end:                                           ; preds = %do.body
  %call11 = tail call ptr @__errno_location() #36
  %12 = load i32, ptr %call11, align 4
  %call12 = tail call ptr @strerror(i32 noundef %12) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.33, ptr noundef %call12) #33
  br label %if.then75

while.cond:                                       ; preds = %while.cond.outer.split, %if.then17
  %call15 = tail call i64 @write(i32 noundef %call8, ptr noundef %add.ptr32, i64 noundef %sub33) #33
  %cmp16 = icmp slt i64 %call15, 1
  br i1 %cmp16, label %if.then17, label %if.end29

if.then17:                                        ; preds = %while.cond
  %call18 = tail call ptr @__errno_location() #36
  %13 = load i32, ptr %call18, align 4
  %cmp19 = icmp eq i32 %13, 4
  br i1 %cmp19, label %while.cond, label %do.body22, !llvm.loop !19

do.body22:                                        ; preds = %if.then17
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp23 = icmp sgt i32 %14, 3
  br i1 %cmp23, label %if.then71.thread, label %if.end25

if.end25:                                         ; preds = %do.body22
  %call27 = tail call ptr @strerror(i32 noundef %13) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.34, i64 noundef %offset.0.ph31, ptr noundef %call27) #33
  br label %if.then71.thread

if.end29:                                         ; preds = %while.cond
  %add = add i64 %call15, %offset.0.ph31
  %cmp14 = icmp ult i64 %add, %retval.0.i
  %add.ptr = getelementptr inbounds i8, ptr %call2, i64 %add
  %sub = sub i64 %retval.0.i, %add
  br i1 %cmp14, label %while.cond.outer.split, label %while.end, !llvm.loop !19

while.cond.outer.split:                           ; preds = %while.cond.preheader, %if.end29
  %sub33 = phi i64 [ %sub, %if.end29 ], [ %retval.0.i, %while.cond.preheader ]
  %add.ptr32 = phi ptr [ %add.ptr, %if.end29 ], [ %call2, %while.cond.preheader ]
  %offset.0.ph31 = phi i64 [ %add, %if.end29 ], [ 0, %while.cond.preheader ]
  br label %while.cond

while.end:                                        ; preds = %if.end29, %while.cond.preheader
  %tobool.not = icmp eq i32 %do_fsync, 0
  br i1 %tobool.not, label %if.end44, label %if.then30

if.then30:                                        ; preds = %while.end
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep31 = getelementptr inbounds %struct.clusterState, ptr %15, i64 0, i32 22
  %16 = load i32, ptr %todo_before_sleep31, align 8
  %and32 = and i32 %16, -9
  store i32 %and32, ptr %todo_before_sleep31, align 8
  %call33 = tail call i32 @fdatasync(i32 noundef %call8) #33
  %cmp34 = icmp eq i32 %call33, -1
  br i1 %cmp34, label %do.body36, label %if.end44.thread

do.body36:                                        ; preds = %if.then30
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp37 = icmp sgt i32 %17, 3
  br i1 %cmp37, label %if.then71.thread, label %if.end39

if.end39:                                         ; preds = %do.body36
  %call40 = tail call ptr @__errno_location() #36
  %18 = load i32, ptr %call40, align 4
  %call41 = tail call ptr @strerror(i32 noundef %18) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.35, ptr noundef %call41) #33
  br label %if.then71.thread

if.end44:                                         ; preds = %while.end
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 366), align 8
  %call45 = tail call i32 @rename(ptr noundef %call7, ptr noundef %19) #33
  %cmp46 = icmp eq i32 %call45, -1
  br i1 %cmp46, label %do.body48, label %if.then71

if.end44.thread:                                  ; preds = %if.then30
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 366), align 8
  %call4518 = tail call i32 @rename(ptr noundef %call7, ptr noundef %20) #33
  %cmp4619 = icmp eq i32 %call4518, -1
  br i1 %cmp4619, label %do.body48, label %if.then57

do.body48:                                        ; preds = %if.end44.thread, %if.end44
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp49 = icmp sgt i32 %21, 3
  br i1 %cmp49, label %if.then71.thread, label %if.end51

if.end51:                                         ; preds = %do.body48
  %call52 = tail call ptr @__errno_location() #36
  %22 = load i32, ptr %call52, align 4
  %call53 = tail call ptr @strerror(i32 noundef %22) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.36, ptr noundef %call53) #33
  br label %if.then71.thread

if.then57:                                        ; preds = %if.end44.thread
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 366), align 8
  %call58 = tail call i32 @fsyncFileDir(ptr noundef %23) #33
  %cmp59 = icmp eq i32 %call58, -1
  br i1 %cmp59, label %do.body61, label %if.then71

do.body61:                                        ; preds = %if.then57
  %24 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp62 = icmp sgt i32 %24, 3
  br i1 %cmp62, label %if.then71.thread, label %if.end64

if.end64:                                         ; preds = %do.body61
  %call65 = tail call ptr @__errno_location() #36
  %25 = load i32, ptr %call65, align 4
  %call66 = tail call ptr @strerror(i32 noundef %25) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.37, ptr noundef %call66) #33
  br label %if.then71.thread

if.then71.thread:                                 ; preds = %do.body22, %if.end25, %do.body36, %if.end39, %do.body48, %if.end51, %do.body61, %if.end64
  %call7238 = tail call i32 @close(i32 noundef %call8) #33
  br label %if.then75

if.then71:                                        ; preds = %if.then57, %if.end44
  %call72 = tail call i32 @close(i32 noundef %call8) #33
  br label %if.end77

if.then75:                                        ; preds = %if.then71.thread, %if.end, %do.body
  %call76 = tail call i32 @unlink(ptr noundef %call7) #33
  br label %if.end77

if.end77:                                         ; preds = %if.then71, %if.then75
  %retval1.02327 = phi i32 [ -1, %if.then75 ], [ 0, %if.then71 ]
  tail call void @sdsfree(ptr noundef %call7) #33
  tail call void @sdsfree(ptr noundef %call2) #33
  ret i32 %retval1.02327
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterGenNodesDescription(ptr noundef %c, i32 noundef %filter, i32 noundef %tls_primary) local_unnamed_addr #2 {
entry:
  %call = tail call ptr @sdsempty() #33
  tail call void @clusterGenNodesSlotsInfo(i32 noundef %filter)
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call1 = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %if.end, %entry
  %ci.0.ph = phi ptr [ %call6, %if.end ], [ %call, %entry ]
  br label %while.cond

while.cond:                                       ; preds = %while.cond.outer, %while.body
  %call2 = tail call ptr @dictNext(ptr noundef %call1) #33
  %cmp.not = icmp eq ptr %call2, null
  br i1 %cmp.not, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %call3 = tail call ptr @dictGetVal(ptr noundef nonnull %call2) #33
  %flags = getelementptr inbounds %struct._clusterNode, ptr %call3, i64 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and = and i32 %2, %filter
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %while.cond, !llvm.loop !20

if.end:                                           ; preds = %while.body
  %call4 = tail call ptr @clusterGenNodeDescription(ptr noundef %c, ptr noundef nonnull %call3, i32 noundef %tls_primary)
  %call5 = tail call ptr @sdscatsds(ptr noundef %ci.0.ph, ptr noundef %call4) #33
  tail call void @sdsfree(ptr noundef %call4) #33
  %call6 = tail call ptr @sdscatlen(ptr noundef %call5, ptr noundef nonnull @.str.159, i64 noundef 1) #33
  %slot_info_pairs.i = getelementptr inbounds %struct._clusterNode, ptr %call3, i64 0, i32 6
  %3 = load ptr, ptr %slot_info_pairs.i, align 8
  tail call void @zfree(ptr noundef %3) #33
  store ptr null, ptr %slot_info_pairs.i, align 8
  %slot_info_pairs_count.i = getelementptr inbounds %struct._clusterNode, ptr %call3, i64 0, i32 7
  store i32 0, ptr %slot_info_pairs_count.i, align 8
  br label %while.cond.outer, !llvm.loop !20

while.end:                                        ; preds = %while.cond
  tail call void @dictReleaseIterator(ptr noundef %call1) #33
  ret ptr %ci.0.ph
}

declare ptr @sdscatfmt(ptr noundef, ptr noundef, ...) local_unnamed_addr #1

declare ptr @sdsempty() local_unnamed_addr #1

; Function Attrs: nounwind
declare i32 @getpid() local_unnamed_addr #12

; Function Attrs: nofree
declare noundef i32 @open64(ptr nocapture noundef readonly, i32 noundef, ...) local_unnamed_addr #16

; Function Attrs: nofree
declare noundef i64 @write(i32 noundef, ptr nocapture noundef readonly, i64 noundef) local_unnamed_addr #16

declare i32 @fdatasync(i32 noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noundef i32 @rename(ptr nocapture noundef readonly, ptr nocapture noundef readonly) local_unnamed_addr #10

declare i32 @fsyncFileDir(ptr noundef) local_unnamed_addr #1

declare i32 @close(i32 noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noundef i32 @unlink(ptr nocapture noundef readonly) local_unnamed_addr #10

declare void @sdsfree(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterSaveConfigOrDie(i32 noundef %do_fsync) local_unnamed_addr #2 {
entry:
  %call = tail call i32 @clusterSaveConfig(i32 noundef %do_fsync), !range !21
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %do.body, label %if.end3

do.body:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %0, 3
  br i1 %cmp1, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.38) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end3:                                          ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterLockConfig(ptr noundef %filename) local_unnamed_addr #2 {
entry:
  %call = tail call i32 (ptr, i32, ...) @open64(ptr noundef %filename, i32 noundef 524353, i32 noundef 420) #33
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %do.body, label %if.end5

do.body:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %0, 3
  br i1 %cmp1, label %return, label %if.end

if.end:                                           ; preds = %do.body
  %call3 = tail call ptr @__errno_location() #36
  %1 = load i32, ptr %call3, align 4
  %call4 = tail call ptr @strerror(i32 noundef %1) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.39, ptr noundef %filename, ptr noundef %call4) #33
  br label %return

if.end5:                                          ; preds = %entry
  %call6 = tail call i32 @flock(i32 noundef %call, i32 noundef 6) #33
  %cmp7 = icmp eq i32 %call6, -1
  br i1 %cmp7, label %if.then8, label %if.end26

if.then8:                                         ; preds = %if.end5
  %call9 = tail call ptr @__errno_location() #36
  %2 = load i32, ptr %call9, align 4
  %cmp10 = icmp eq i32 %2, 11
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp13 = icmp sgt i32 %3, 3
  br i1 %cmp10, label %do.body12, label %do.body17

do.body12:                                        ; preds = %if.then8
  br i1 %cmp13, label %if.end24, label %if.end15

if.end15:                                         ; preds = %do.body12
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.40, ptr noundef %filename) #33
  br label %if.end24

do.body17:                                        ; preds = %if.then8
  br i1 %cmp13, label %if.end24, label %if.end20

if.end20:                                         ; preds = %do.body17
  %call22 = tail call ptr @strerror(i32 noundef %2) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.41, ptr noundef %filename, ptr noundef %call22) #33
  br label %if.end24

if.end24:                                         ; preds = %if.end20, %do.body17, %if.end15, %do.body12
  %call25 = tail call i32 @close(i32 noundef %call) #33
  br label %return

if.end26:                                         ; preds = %if.end5
  store i32 %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 382), align 8
  br label %return

return:                                           ; preds = %if.end, %do.body, %if.end26, %if.end24
  %retval.0 = phi i32 [ -1, %if.end24 ], [ 0, %if.end26 ], [ -1, %do.body ], [ -1, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare i32 @flock(i32 noundef, i32 noundef) local_unnamed_addr #12

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: write, inaccessiblemem: none) uwtable
define dso_local void @deriveAnnouncedPorts(ptr nocapture noundef writeonly %announced_tcp_port, ptr nocapture noundef writeonly %announced_tls_port, ptr nocapture noundef writeonly %announced_cport) local_unnamed_addr #17 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 377), align 4
  %tobool.not = icmp eq i32 %0, 0
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %cond = select i1 %tobool.not, i32 %1, i32 %0
  store i32 %cond, ptr %announced_tcp_port, align 4
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 378), align 8
  %tobool1.not = icmp eq i32 %2, 0
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %cond5 = select i1 %tobool1.not, i32 %3, i32 %2
  store i32 %cond5, ptr %announced_tls_port, align 4
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 379), align 4
  %tobool6.not = icmp eq i32 %4, 0
  br i1 %tobool6.not, label %if.else, label %if.end10

if.else:                                          ; preds = %entry
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 363), align 8
  %tobool7.not = icmp eq i32 %5, 0
  br i1 %tobool7.not, label %if.else9, label %if.end10

if.else9:                                         ; preds = %if.else
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i = icmp eq i32 %6, 0
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %cond.i = select i1 %tobool.not.i, i32 %8, i32 %7
  %add = add nsw i32 %cond.i, 10000
  br label %if.end10

if.end10:                                         ; preds = %if.else, %entry, %if.else9
  %.sink = phi i32 [ %add, %if.else9 ], [ %4, %entry ], [ %5, %if.else ]
  store i32 %.sink, ptr %announced_cport, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable
define dso_local void @clusterUpdateMyselfFlags() local_unnamed_addr #18 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end6, label %if.end

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 372), align 8
  %tobool1.not = icmp eq i32 %2, 0
  %cond = select i1 %tobool1.not, i32 0, i32 512
  %and = and i32 %1, -513
  %or = or disjoint i32 %cond, %and
  store i32 %or, ptr %flags, align 8
  %cmp.not = icmp eq i32 %or, %1
  br i1 %cmp.not, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 22
  %4 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %4, 6
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %if.end6

if.end6:                                          ; preds = %entry, %if.then5, %if.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable
define dso_local void @clusterDoBeforeSleep(i32 noundef %flags) local_unnamed_addr #18 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 22
  %1 = load i32, ptr %todo_before_sleep, align 8
  %or = or i32 %1, %flags
  store i32 %or, ptr %todo_before_sleep, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: write, inaccessiblemem: none) uwtable
define dso_local void @clusterUpdateMyselfAnnouncedPorts() local_unnamed_addr #19 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 24
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 25
  %cport = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 26
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 377), align 4
  %tobool.not.i = icmp eq i32 %1, 0
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %cond.i = select i1 %tobool.not.i, i32 %2, i32 %1
  store i32 %cond.i, ptr %tcp_port, align 4
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 378), align 8
  %tobool1.not.i = icmp eq i32 %3, 0
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %cond5.i = select i1 %tobool1.not.i, i32 %4, i32 %3
  store i32 %cond5.i, ptr %tls_port, align 4
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 379), align 4
  %tobool6.not.i = icmp eq i32 %5, 0
  br i1 %tobool6.not.i, label %if.else.i, label %deriveAnnouncedPorts.exit

if.else.i:                                        ; preds = %if.end
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 363), align 8
  %tobool7.not.i = icmp eq i32 %6, 0
  br i1 %tobool7.not.i, label %if.else9.i, label %deriveAnnouncedPorts.exit

if.else9.i:                                       ; preds = %if.else.i
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i.i = icmp eq i32 %7, 0
  %cond.i.i = select i1 %tobool.not.i.i, i32 %2, i32 %4
  %add.i = add nsw i32 %cond.i.i, 10000
  br label %deriveAnnouncedPorts.exit

deriveAnnouncedPorts.exit:                        ; preds = %if.end, %if.else.i, %if.else9.i
  %.sink.i = phi i32 [ %add.i, %if.else9.i ], [ %5, %if.end ], [ %6, %if.else.i ]
  store i32 %.sink.i, ptr %cport, align 4
  br label %return

return:                                           ; preds = %entry, %deriveAnnouncedPorts.exit
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateMyselfIp() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end29, label %if.end

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 373), align 8
  %2 = load ptr, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %cmp = icmp eq ptr %2, null
  %cmp1 = icmp ne ptr %1, null
  %or.cond = select i1 %cmp, i1 %cmp1, i1 false
  br i1 %or.cond, label %if.then23, label %if.else

if.else:                                          ; preds = %if.end
  %cmp3 = icmp ne ptr %2, null
  %cmp5 = icmp eq ptr %1, null
  %or.cond1 = select i1 %cmp3, i1 %cmp5, i1 false
  br i1 %or.cond1, label %if.else26, label %if.else7

if.else7:                                         ; preds = %if.else
  %or.cond2 = select i1 %cmp3, i1 %cmp1, i1 false
  br i1 %or.cond2, label %land.lhs.true11, label %if.end29

land.lhs.true11:                                  ; preds = %if.else7
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %2, ptr noundef nonnull dereferenceable(1) %1) #34
  %tobool12.not = icmp eq i32 %call, 0
  br i1 %tobool12.not, label %if.end29, label %if.end21.thread10

if.end21.thread10:                                ; preds = %land.lhs.true11
  tail call void @zfree(ptr noundef nonnull %2) #33
  br label %if.then23

if.then23:                                        ; preds = %if.end, %if.end21.thread10
  store ptr %1, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %call24 = tail call noalias ptr @zstrdup(ptr noundef nonnull %1) #33
  store ptr %call24, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %3 = load ptr, ptr @myself, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %3, i64 0, i32 21
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 373), align 8
  %call25 = tail call i64 @redis_strlcpy(ptr noundef nonnull %ip, ptr noundef %4, i64 noundef 46) #33
  br label %if.end29

if.else26:                                        ; preds = %if.else
  tail call void @zfree(ptr noundef nonnull %2) #33
  store ptr null, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %5 = load ptr, ptr @myself, align 8
  %ip27 = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 21
  store i8 0, ptr %ip27, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.else7, %if.then23, %if.else26, %entry, %land.lhs.true11
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i32 @strcmp(ptr nocapture noundef, ptr nocapture noundef) local_unnamed_addr #7

declare noalias ptr @zstrdup(ptr noundef) local_unnamed_addr #1

declare i64 @redis_strlcpy(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateMyselfHostname() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 374), align 8
  tail call fastcc void @updateAnnouncedHostname(ptr noundef nonnull %0, ptr noundef %1)
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @updateAnnouncedHostname(ptr nocapture noundef %node, ptr noundef %new) unnamed_addr #2 {
entry:
  %tobool.not = icmp eq ptr %new, null
  %hostname4 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 22
  %0 = load ptr, ptr %hostname4, align 8
  br i1 %tobool.not, label %land.lhs.true3, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %new, ptr noundef nonnull dereferenceable(1) %0) #34
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %return, label %if.then9

land.lhs.true3:                                   ; preds = %entry
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %return [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %land.lhs.true3
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %land.lhs.true3
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %land.lhs.true3
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %land.lhs.true3
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %land.lhs.true3
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %cmp = icmp eq i64 %retval.0.i, 0
  br i1 %cmp, label %return, label %if.else13

if.then9:                                         ; preds = %land.lhs.true
  %call11 = tail call ptr @sdscpy(ptr noundef %0, ptr noundef nonnull %new) #33
  store ptr %call11, ptr %hostname4, align 8
  br label %if.end20

if.else13:                                        ; preds = %sdslen.exit
  switch i32 %and.i, label %if.end20 [
    i32 0, label %sw.bb.i25
    i32 1, label %sw.bb3.i22
    i32 2, label %sw.bb5.i19
    i32 3, label %sw.bb9.i16
    i32 4, label %sw.bb13.i13
  ]

sw.bb.i25:                                        ; preds = %if.else13
  %shr.i26 = lshr i32 %conv.i, 3
  %conv2.i27 = zext nneg i32 %shr.i26 to i64
  br label %sdslen.exit28

sw.bb3.i22:                                       ; preds = %if.else13
  %add.ptr.i23 = getelementptr inbounds i8, ptr %0, i64 -3
  %6 = load i8, ptr %add.ptr.i23, align 1
  %conv4.i24 = zext i8 %6 to i64
  br label %sdslen.exit28

sw.bb5.i19:                                       ; preds = %if.else13
  %add.ptr6.i20 = getelementptr inbounds i8, ptr %0, i64 -5
  %7 = load i16, ptr %add.ptr6.i20, align 1
  %conv8.i21 = zext i16 %7 to i64
  br label %sdslen.exit28

sw.bb9.i16:                                       ; preds = %if.else13
  %add.ptr10.i17 = getelementptr inbounds i8, ptr %0, i64 -9
  %8 = load i32, ptr %add.ptr10.i17, align 1
  %conv12.i18 = zext i32 %8 to i64
  br label %sdslen.exit28

sw.bb13.i13:                                      ; preds = %if.else13
  %add.ptr14.i14 = getelementptr inbounds i8, ptr %0, i64 -17
  %9 = load i64, ptr %add.ptr14.i14, align 1
  br label %sdslen.exit28

sdslen.exit28:                                    ; preds = %sw.bb.i25, %sw.bb3.i22, %sw.bb5.i19, %sw.bb9.i16, %sw.bb13.i13
  %retval.0.i15 = phi i64 [ %9, %sw.bb13.i13 ], [ %conv12.i18, %sw.bb9.i16 ], [ %conv8.i21, %sw.bb5.i19 ], [ %conv4.i24, %sw.bb3.i22 ], [ %conv2.i27, %sw.bb.i25 ]
  %cmp16.not = icmp eq i64 %retval.0.i15, 0
  br i1 %cmp16.not, label %if.end20, label %if.then17

if.then17:                                        ; preds = %sdslen.exit28
  tail call void @sdsclear(ptr noundef nonnull %0) #33
  br label %if.end20

if.end20:                                         ; preds = %if.else13, %sdslen.exit28, %if.then17, %if.then9
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %10, i64 0, i32 22
  %11 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %11, 4
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %return

return:                                           ; preds = %land.lhs.true3, %sdslen.exit, %land.lhs.true, %if.end20
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateMyselfHumanNodename() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 375), align 8
  tail call fastcc void @updateAnnouncedHumanNodename(ptr noundef nonnull %0, ptr noundef %1)
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc void @updateAnnouncedHumanNodename(ptr nocapture noundef %node, ptr noundef %new) unnamed_addr #2 {
entry:
  %tobool.not = icmp eq ptr %new, null
  %human_nodename4 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %0 = load ptr, ptr %human_nodename4, align 8
  br i1 %tobool.not, label %land.lhs.true3, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call = tail call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %new, ptr noundef nonnull dereferenceable(1) %0) #34
  %tobool1.not = icmp eq i32 %call, 0
  br i1 %tobool1.not, label %return, label %if.then9

land.lhs.true3:                                   ; preds = %entry
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %return [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %land.lhs.true3
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %land.lhs.true3
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %land.lhs.true3
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %land.lhs.true3
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %land.lhs.true3
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %cmp = icmp eq i64 %retval.0.i, 0
  br i1 %cmp, label %return, label %if.else13

if.then9:                                         ; preds = %land.lhs.true
  %call11 = tail call ptr @sdscpy(ptr noundef %0, ptr noundef nonnull %new) #33
  store ptr %call11, ptr %human_nodename4, align 8
  br label %if.end20

if.else13:                                        ; preds = %sdslen.exit
  switch i32 %and.i, label %if.end20 [
    i32 0, label %sw.bb.i25
    i32 1, label %sw.bb3.i22
    i32 2, label %sw.bb5.i19
    i32 3, label %sw.bb9.i16
    i32 4, label %sw.bb13.i13
  ]

sw.bb.i25:                                        ; preds = %if.else13
  %shr.i26 = lshr i32 %conv.i, 3
  %conv2.i27 = zext nneg i32 %shr.i26 to i64
  br label %sdslen.exit28

sw.bb3.i22:                                       ; preds = %if.else13
  %add.ptr.i23 = getelementptr inbounds i8, ptr %0, i64 -3
  %6 = load i8, ptr %add.ptr.i23, align 1
  %conv4.i24 = zext i8 %6 to i64
  br label %sdslen.exit28

sw.bb5.i19:                                       ; preds = %if.else13
  %add.ptr6.i20 = getelementptr inbounds i8, ptr %0, i64 -5
  %7 = load i16, ptr %add.ptr6.i20, align 1
  %conv8.i21 = zext i16 %7 to i64
  br label %sdslen.exit28

sw.bb9.i16:                                       ; preds = %if.else13
  %add.ptr10.i17 = getelementptr inbounds i8, ptr %0, i64 -9
  %8 = load i32, ptr %add.ptr10.i17, align 1
  %conv12.i18 = zext i32 %8 to i64
  br label %sdslen.exit28

sw.bb13.i13:                                      ; preds = %if.else13
  %add.ptr14.i14 = getelementptr inbounds i8, ptr %0, i64 -17
  %9 = load i64, ptr %add.ptr14.i14, align 1
  br label %sdslen.exit28

sdslen.exit28:                                    ; preds = %sw.bb.i25, %sw.bb3.i22, %sw.bb5.i19, %sw.bb9.i16, %sw.bb13.i13
  %retval.0.i15 = phi i64 [ %9, %sw.bb13.i13 ], [ %conv12.i18, %sw.bb9.i16 ], [ %conv8.i21, %sw.bb5.i19 ], [ %conv4.i24, %sw.bb3.i22 ], [ %conv2.i27, %sw.bb.i25 ]
  %cmp16.not = icmp eq i64 %retval.0.i15, 0
  br i1 %cmp16.not, label %if.end20, label %if.then17

if.then17:                                        ; preds = %sdslen.exit28
  tail call void @sdsclear(ptr noundef nonnull %0) #33
  br label %if.end20

if.end20:                                         ; preds = %if.else13, %sdslen.exit28, %if.then17, %if.then9
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %10, i64 0, i32 22
  %11 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %11, 4
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %return

return:                                           ; preds = %land.lhs.true3, %sdslen.exit, %land.lhs.true, %if.end20
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterInit() local_unnamed_addr #2 {
entry:
  %call = tail call noalias dereferenceable_or_null(395600) ptr @zmalloc(i64 noundef 395600) #37
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %call, i64 0, i32 2
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %call, i8 0, i64 16, i1 false)
  store i32 1, ptr %state, align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %call, i64 0, i32 3
  store i32 1, ptr %size, align 4
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %call, i64 0, i32 22
  store i32 0, ptr %todo_before_sleep, align 8
  %call1 = tail call ptr @dictCreate(ptr noundef nonnull @clusterNodesDictType) #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  store ptr %call1, ptr %nodes, align 8
  %call2 = tail call ptr @dictCreate(ptr noundef nonnull @clusterSdsToListType) #33
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 5
  store ptr %call2, ptr %shards, align 8
  %call3 = tail call ptr @dictCreate(ptr noundef nonnull @clusterNodesBlackListDictType) #33
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 6
  store ptr %call3, ptr %nodes_black_list, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_time = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 11
  store i64 0, ptr %failover_auth_time, align 8
  %failover_auth_count = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 12
  store i32 0, ptr %failover_auth_count, align 8
  %failover_auth_rank = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 14
  store i32 0, ptr %failover_auth_rank, align 8
  %failover_auth_epoch = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 15
  store i64 0, ptr %failover_auth_epoch, align 8
  %cant_failover_reason = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 16
  store i32 0, ptr %cant_failover_reason, align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 21
  store i64 0, ptr %lastVoteEpoch, align 8
  br label %for.body

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 23, i64 %indvars.iv
  store i64 0, ptr %arrayidx, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5 = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 24, i64 %indvars.iv
  store i64 0, ptr %arrayidx5, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 11
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !22

for.end:                                          ; preds = %for.body
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %stats_pfail_nodes = getelementptr inbounds %struct.clusterState, ptr %6, i64 0, i32 25
  %slots = getelementptr inbounds %struct.clusterState, ptr %6, i64 0, i32 9
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %slots, i8 0, i64 131072, i1 false)
  %migrating_slots_to.i = getelementptr inbounds %struct.clusterState, ptr %6, i64 0, i32 7
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %migrating_slots_to.i, i8 0, i64 131072, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %stats_pfail_nodes, i8 0, i64 16, i1 false)
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %importing_slots_from.i = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %importing_slots_from.i, i8 0, i64 131072, i1 false)
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 27
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2048) %owner_not_claiming_slot, i8 0, i64 2048, i1 false)
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 382), align 8
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 366), align 8
  %call7 = tail call i32 @clusterLockConfig(ptr noundef %8), !range !21
  %cmp8 = icmp eq i32 %call7, -1
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end:                                           ; preds = %for.end
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 366), align 8
  %call9 = tail call i32 @clusterLoadConfig(ptr noundef %9), !range !21
  %cmp10.not = icmp eq i32 %call9, -1
  br i1 %cmp10.not, label %if.then11, label %if.end21

if.then11:                                        ; preds = %if.end
  %call.i = tail call noalias dereferenceable_or_null(2368) ptr @zmalloc(i64 noundef 2368) #37
  %name1.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 1
  tail call void @getRandomHexChars(ptr noundef nonnull %name1.i, i64 noundef 40) #33
  %shard_id.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 2
  tail call void @getRandomHexChars(ptr noundef nonnull %shard_id.i, i64 noundef 40) #33
  %call4.i = tail call i64 @mstime() #33
  store i64 %call4.i, ptr %call.i, align 8
  %configEpoch.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 4
  store i64 0, ptr %configEpoch.i, align 8
  %flags5.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 3
  store i32 17, ptr %flags5.i, align 8
  %slots.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 5
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 10
  %link.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 27
  %ip.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 21
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip.i, i8 0, i64 46, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2068) %slots.i, i8 0, i64 2068, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) %slaves.i, i8 0, i64 56, i1 false)
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %link.i, i8 0, i64 16, i1 false)
  %call8.i = tail call ptr @sdsempty() #33
  %hostname.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 22
  store ptr %call8.i, ptr %hostname.i, align 8
  %call9.i = tail call ptr @sdsempty() #33
  %human_nodename.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 23
  store ptr %call9.i, ptr %human_nodename.i, align 8
  %tcp_port.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 24
  store i32 0, ptr %tcp_port.i, align 8
  %cport.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 26
  store i32 0, ptr %cport.i, align 8
  %tls_port.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 25
  store i32 0, ptr %tls_port.i, align 4
  %call10.i = tail call ptr @listCreate() #33
  %fail_reports.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 29
  store ptr %call10.i, ptr %fail_reports.i, align 8
  %voted_time.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 17
  %free.i = getelementptr inbounds %struct.list, ptr %call10.i, i64 0, i32 3
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %voted_time.i, i8 0, i64 32, i1 false)
  store ptr @zfree, ptr %free.i, align 8
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  store ptr %call.i, ptr %10, align 8
  store ptr %call.i, ptr @myself, align 8
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp14 = icmp sgt i32 %11, 2
  br i1 %cmp14, label %do.end, label %if.end16

if.end16:                                         ; preds = %if.then11
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.42, ptr noundef nonnull %name1.i) #33
  %.pre = load ptr, ptr @myself, align 8
  br label %do.end

do.end:                                           ; preds = %if.then11, %if.end16
  %12 = phi ptr [ %call.i, %if.then11 ], [ %.pre, %if.end16 ]
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %13, i64 0, i32 4
  %14 = load ptr, ptr %nodes.i, align 8
  %name.i = getelementptr inbounds %struct._clusterNode, ptr %12, i64 0, i32 1
  %call.i4 = tail call ptr @sdsnewlen(ptr noundef nonnull %name.i, i64 noundef 40) #33
  %call1.i = tail call i32 @dictAdd(ptr noundef %14, ptr noundef %call.i4, ptr noundef %12) #33
  %cmp.i = icmp eq i32 %call1.i, 0
  br i1 %cmp.i, label %if.then20, label %cond.false.i

cond.false.i:                                     ; preds = %do.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  tail call void @abort() #35
  unreachable

if.then20:                                        ; preds = %do.end
  %15 = load ptr, ptr @myself, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %15, i64 0, i32 2
  tail call void @clusterAddNodeToShard(ptr noundef nonnull %shard_id, ptr noundef %15)
  %call.i5 = tail call i32 @clusterSaveConfig(i32 noundef 1), !range !21
  %cmp.i6 = icmp eq i32 %call.i5, -1
  br i1 %cmp.i6, label %do.body.i, label %if.end21

do.body.i:                                        ; preds = %if.then20
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i = icmp sgt i32 %16, 3
  br i1 %cmp1.i, label %do.end.i, label %if.end.i

if.end.i:                                         ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.38) #33
  br label %do.end.i

do.end.i:                                         ; preds = %if.end.i, %do.body.i
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end21:                                         ; preds = %if.then20, %if.end
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i = icmp eq i32 %17, 0
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %cond.i = select i1 %tobool.not.i, i32 %19, i32 %18
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 363), align 8
  %tobool23 = icmp eq i32 %20, 0
  %cmp24 = icmp sgt i32 %cond.i, 55535
  %or.cond = select i1 %tobool23, i1 %cmp24, i1 false
  br i1 %or.cond, label %do.body26, label %if.end31

do.body26:                                        ; preds = %if.end21
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp27 = icmp sgt i32 %21, 3
  br i1 %cmp27, label %do.end30, label %if.end29

if.end29:                                         ; preds = %do.body26
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.43) #33
  br label %do.end30

do.end30:                                         ; preds = %do.body26, %if.end29
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end31:                                         ; preds = %if.end21
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 48), align 8
  %tobool32.not = icmp eq i32 %22, 0
  br i1 %tobool32.not, label %do.body34, label %if.end39

do.body34:                                        ; preds = %if.end31
  %23 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp35 = icmp sgt i32 %23, 3
  br i1 %cmp35, label %do.end38, label %if.end37

if.end37:                                         ; preds = %do.body34
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.44) #33
  br label %do.end38

do.end38:                                         ; preds = %do.body34, %if.end37
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end39:                                         ; preds = %if.end31
  %call40 = tail call ptr @raxNew() #33
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %slots_to_channels = getelementptr inbounds %struct.clusterState, ptr %24, i64 0, i32 10
  store ptr %call40, ptr %slots_to_channels, align 8
  %25 = load ptr, ptr @myself, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %25, i64 0, i32 24
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %25, i64 0, i32 25
  %cport = getelementptr inbounds %struct._clusterNode, ptr %25, i64 0, i32 26
  %26 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 377), align 4
  %tobool.not.i7 = icmp eq i32 %26, 0
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %cond.i8 = select i1 %tobool.not.i7, i32 %27, i32 %26
  store i32 %cond.i8, ptr %tcp_port, align 4
  %28 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 378), align 8
  %tobool1.not.i = icmp eq i32 %28, 0
  %29 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %cond5.i = select i1 %tobool1.not.i, i32 %29, i32 %28
  store i32 %cond5.i, ptr %tls_port, align 4
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 379), align 4
  %tobool6.not.i = icmp eq i32 %30, 0
  br i1 %tobool6.not.i, label %if.else.i, label %if.end.i12

if.else.i:                                        ; preds = %if.end39
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 363), align 8
  %tobool7.not.i = icmp eq i32 %31, 0
  br i1 %tobool7.not.i, label %if.else9.i, label %if.end.i12

if.else9.i:                                       ; preds = %if.else.i
  %32 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i.i = icmp eq i32 %32, 0
  %cond.i.i = select i1 %tobool.not.i.i, i32 %27, i32 %29
  %add.i = add nsw i32 %cond.i.i, 10000
  br label %if.end.i12

if.end.i12:                                       ; preds = %if.end39, %if.else.i, %if.else9.i
  %.sink.i = phi i32 [ %add.i, %if.else9.i ], [ %30, %if.end39 ], [ %31, %if.else.i ]
  store i32 %.sink.i, ptr %cport, align 4
  %33 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %33, i64 0, i32 17
  %mf_can_start.i = getelementptr inbounds %struct.clusterState, ptr %33, i64 0, i32 20
  store i32 0, ptr %mf_can_start.i, align 8
  %mf_master_offset.i = getelementptr inbounds %struct.clusterState, ptr %33, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mf_end, i8 0, i64 16, i1 false)
  store i64 -1, ptr %mf_master_offset.i, align 8
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %25, i64 0, i32 3
  %34 = load i32, ptr %flags.i, align 8
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 372), align 8
  %tobool1.not.i13 = icmp eq i32 %35, 0
  %cond.i14 = select i1 %tobool1.not.i13, i32 0, i32 512
  %and.i = and i32 %34, -513
  %or.i = or disjoint i32 %cond.i14, %and.i
  store i32 %or.i, ptr %flags.i, align 8
  %cmp.not.i = icmp eq i32 %or.i, %34
  br i1 %cmp.not.i, label %clusterUpdateMyselfFlags.exit, label %if.then5.i

if.then5.i:                                       ; preds = %if.end.i12
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i.i = getelementptr inbounds %struct.clusterState, ptr %36, i64 0, i32 22
  %37 = load i32, ptr %todo_before_sleep.i.i, align 8
  %or.i.i = or i32 %37, 6
  store i32 %or.i.i, ptr %todo_before_sleep.i.i, align 8
  br label %clusterUpdateMyselfFlags.exit

clusterUpdateMyselfFlags.exit:                    ; preds = %if.end.i12, %if.then5.i
  tail call void @clusterUpdateMyselfIp()
  %38 = load ptr, ptr @myself, align 8
  %tobool.not.i15 = icmp eq ptr %38, null
  br i1 %tobool.not.i15, label %clusterUpdateMyselfHumanNodename.exit, label %clusterUpdateMyselfHostname.exit

clusterUpdateMyselfHostname.exit:                 ; preds = %clusterUpdateMyselfFlags.exit
  %39 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 374), align 8
  tail call fastcc void @updateAnnouncedHostname(ptr noundef nonnull %38, ptr noundef %39)
  %.pr = load ptr, ptr @myself, align 8
  %tobool.not.i17 = icmp eq ptr %.pr, null
  br i1 %tobool.not.i17, label %clusterUpdateMyselfHumanNodename.exit, label %if.end.i18

if.end.i18:                                       ; preds = %clusterUpdateMyselfHostname.exit
  %40 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 375), align 8
  tail call fastcc void @updateAnnouncedHumanNodename(ptr noundef nonnull %.pr, ptr noundef %40)
  br label %clusterUpdateMyselfHumanNodename.exit

clusterUpdateMyselfHumanNodename.exit:            ; preds = %clusterUpdateMyselfFlags.exit, %clusterUpdateMyselfHostname.exit, %if.end.i18
  ret void
}

declare ptr @dictCreate(ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #20

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, argmem: write, inaccessiblemem: none) uwtable
define dso_local void @clusterCloseAllSlots() local_unnamed_addr #21 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %migrating_slots_to = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 7
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %migrating_slots_to, i8 0, i64 131072, i1 false)
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %importing_slots_from, i8 0, i64 131072, i1 false)
  ret void
}

declare ptr @raxNew() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @resetManualFailover() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_slave = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 18
  %1 = load ptr, ptr %mf_slave, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @unpauseActions(i32 noundef 2) #33
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = phi ptr [ %.pre, %if.then ], [ %0, %entry ]
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 17
  %mf_can_start = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 20
  store i32 0, ptr %mf_can_start, align 8
  %mf_master_offset = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mf_end, i8 0, i64 16, i1 false)
  store i64 -1, ptr %mf_master_offset, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterInitLast() local_unnamed_addr #2 {
entry:
  %call = tail call ptr @connTypeOfCluster() #33
  %0 = load ptr, ptr %call, align 8
  %call1 = tail call ptr %0(ptr noundef null) #33
  %call2 = tail call i32 @connectionIndexByType(ptr noundef %call1) #33
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %do.body, label %if.end8

do.body:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3 = icmp sgt i32 %1, 3
  br i1 %cmp3, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %call5 = tail call ptr @connTypeOfCluster() #33
  %2 = load ptr, ptr %call5, align 8
  %call7 = tail call ptr %2(ptr noundef null) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.45, ptr noundef %call7) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end8:                                          ; preds = %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i = icmp eq i32 %3, 0
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %cond.i = select i1 %tobool.not.i, i32 %5, i32 %4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 1), align 8
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 47), ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 2), align 8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 48), align 8
  store i32 %6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 3), align 8
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 363), align 8
  %tobool.not = icmp eq i32 %7, 0
  %add = add nsw i32 %cond.i, 10000
  %cond = select i1 %tobool.not, i32 %add, i32 %7
  store i32 %cond, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 4), align 4
  %call11 = tail call ptr @connTypeOfCluster() #33
  store ptr %call11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 5), align 8
  %listen.i = getelementptr inbounds %struct.ConnectionType, ptr %call11, i64 0, i32 8
  %8 = load ptr, ptr %listen.i, align 8
  %call.i = tail call i32 %8(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54)) #33
  %cmp13 = icmp eq i32 %call.i, -1
  br i1 %cmp13, label %do.body15, label %if.end21

do.body15:                                        ; preds = %if.end8
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp16 = icmp sgt i32 %9, 3
  br i1 %cmp16, label %do.end20, label %if.end18

if.end18:                                         ; preds = %do.body15
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54, i32 4), align 4
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.46, i32 noundef %10) #33
  br label %do.end20

do.end20:                                         ; preds = %do.body15, %if.end18
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end21:                                         ; preds = %if.end8
  %call22 = tail call i32 @createSocketAcceptHandler(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 54), ptr noundef nonnull @clusterAcceptHandler) #33
  %cmp23.not = icmp eq i32 %call22, 0
  br i1 %cmp23.not, label %if.end25, label %if.then24

if.then24:                                        ; preds = %if.end21
  tail call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef nonnull @.str.18, i32 noundef 1060, ptr noundef nonnull @.str.47) #33
  tail call void @abort() #35
  unreachable

if.end25:                                         ; preds = %if.end21
  ret void
}

declare i32 @connectionIndexByType(ptr noundef) local_unnamed_addr #1

declare ptr @connTypeOfCluster() local_unnamed_addr #1

declare i32 @createSocketAcceptHandler(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterAcceptHandler(ptr nocapture readnone %el, i32 noundef %fd, ptr nocapture readnone %privdata, i32 %mask) #2 {
entry:
  %cport = alloca i32, align 4
  %cip = alloca [46 x i8], align 16
  %require_auth = alloca i32, align 4
  store i32 1, ptr %require_auth, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %while.cond.preheader

land.lhs.true:                                    ; preds = %entry
  %1 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 81), align 4
  %tobool.not = icmp eq i32 %1, 0
  br i1 %tobool.not, label %while.cond.preheader, label %while.end

while.cond.preheader:                             ; preds = %land.lhs.true, %entry
  br label %while.cond

while.cond:                                       ; preds = %while.cond.preheader, %do.end32
  %max.0 = phi i32 [ %dec, %do.end32 ], [ 1000, %while.cond.preheader ]
  %dec = add nsw i32 %max.0, -1
  %tobool1.not = icmp eq i32 %max.0, 0
  br i1 %tobool1.not, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %call = call i32 @anetTcpAccept(ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 70), i32 noundef %fd, ptr noundef nonnull %cip, i64 noundef 46, ptr noundef nonnull %cport) #33
  %cmp2 = icmp eq i32 %call, -1
  br i1 %cmp2, label %if.then3, label %if.end11

if.then3:                                         ; preds = %while.body
  %call4 = tail call ptr @__errno_location() #36
  %2 = load i32, ptr %call4, align 4
  %cmp5 = icmp eq i32 %2, 11
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp7 = icmp sgt i32 %3, 1
  %or.cond = select i1 %cmp5, i1 true, i1 %cmp7
  br i1 %or.cond, label %while.end, label %if.end9

if.end9:                                          ; preds = %if.then3
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.55, ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 70)) #33
  br label %while.end

if.end11:                                         ; preds = %while.body
  %call12 = call ptr @connTypeOfCluster() #33
  %4 = getelementptr i8, ptr %call12, i64 80
  %call12.val = load ptr, ptr %4, align 8
  %call.i = call ptr %call12.val(i32 noundef %call, ptr noundef nonnull %require_auth) #33
  %5 = getelementptr i8, ptr %call.i, i64 8
  %call13.val = load i32, ptr %5, align 8
  %cmp15.not = icmp eq i32 %call13.val, 2
  br i1 %cmp15.not, label %if.end23, label %do.body17

do.body17:                                        ; preds = %if.end11
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp18 = icmp sgt i32 %6, 1
  br i1 %cmp18, label %do.end22, label %if.end20

if.end20:                                         ; preds = %do.body17
  %7 = load ptr, ptr %call.i, align 8
  %get_last_error.i = getelementptr inbounds %struct.ConnectionType, ptr %7, i64 0, i32 21
  %8 = load ptr, ptr %get_last_error.i, align 8
  %call.i12 = call ptr %8(ptr noundef nonnull %call.i) #33
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.56, ptr noundef %call.i12) #33
  br label %do.end22

do.end22:                                         ; preds = %do.body17, %if.end20
  %9 = load ptr, ptr %call.i, align 8
  %close.i = getelementptr inbounds %struct.ConnectionType, ptr %9, i64 0, i32 12
  %10 = load ptr, ptr %close.i, align 8
  call void %10(ptr noundef nonnull %call.i) #33
  br label %while.end

if.end23:                                         ; preds = %if.end11
  %call24 = call i32 @connEnableTcpNoDelay(ptr noundef nonnull %call.i) #33
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %div = sdiv i64 %11, 1000
  %div.tr = trunc i64 %div to i32
  %conv = shl i32 %div.tr, 1
  %call25 = call i32 @connKeepAlive(ptr noundef nonnull %call.i, i32 noundef %conv) #33
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp27 = icmp sgt i32 %12, 1
  br i1 %cmp27, label %do.end32, label %if.end30

if.end30:                                         ; preds = %if.end23
  %13 = load i32, ptr %cport, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.57, ptr noundef nonnull %cip, i32 noundef %13) #33
  br label %do.end32

do.end32:                                         ; preds = %if.end23, %if.end30
  %14 = load ptr, ptr %call.i, align 8
  %accept.i = getelementptr inbounds %struct.ConnectionType, ptr %14, i64 0, i32 15
  %15 = load ptr, ptr %accept.i, align 8
  %call.i13 = call i32 %15(ptr noundef nonnull %call.i, ptr noundef nonnull @clusterConnAcceptHandler) #33
  %cmp34 = icmp eq i32 %call.i13, -1
  br i1 %cmp34, label %if.then36, label %while.cond, !llvm.loop !23

if.then36:                                        ; preds = %do.end32
  %16 = getelementptr i8, ptr %call.i, i64 8
  %call13.val11 = load i32, ptr %16, align 8
  %cmp38 = icmp ne i32 %call13.val11, 5
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp42 = icmp sgt i32 %17, 1
  %or.cond1 = select i1 %cmp38, i1 true, i1 %cmp42
  br i1 %or.cond1, label %if.end48, label %if.end45

if.end45:                                         ; preds = %if.then36
  %18 = load ptr, ptr %call.i, align 8
  %get_last_error.i14 = getelementptr inbounds %struct.ConnectionType, ptr %18, i64 0, i32 21
  %19 = load ptr, ptr %get_last_error.i14, align 8
  %call.i15 = call ptr %19(ptr noundef nonnull %call.i) #33
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.58, ptr noundef %call.i15) #33
  br label %if.end48

if.end48:                                         ; preds = %if.end45, %if.then36
  %20 = load ptr, ptr %call.i, align 8
  %close.i16 = getelementptr inbounds %struct.ConnectionType, ptr %20, i64 0, i32 12
  %21 = load ptr, ptr %close.i16, align 8
  call void %21(ptr noundef nonnull %call.i) #33
  br label %while.end

while.end:                                        ; preds = %while.cond, %if.then3, %if.end9, %land.lhs.true, %if.end48, %do.end22
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterReset(i32 noundef %hard) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %and.i.i = and i32 %1, 1
  %tobool.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool.not.i, label %if.end.i, label %clusterSetNodeAsMaster.exit

if.end.i:                                         ; preds = %if.then
  %slaveof.i = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 11
  %2 = load ptr, ptr %slaveof.i, align 8
  %tobool1.not.i = icmp eq ptr %2, null
  br i1 %tobool1.not.i, label %if.end7.i, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %numslaves.i.i = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 9
  %3 = load i32, ptr %numslaves.i.i, align 8
  %cmp19.i.i = icmp sgt i32 %3, 0
  br i1 %cmp19.i.i, label %for.body.lr.ph.i.i, label %clusterNodeRemoveSlave.exit.i

for.body.lr.ph.i.i:                               ; preds = %if.then2.i
  %slaves.i.i = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 10
  %4 = load ptr, ptr %slaves.i.i, align 8
  %wide.trip.count.i.i = zext nneg i32 %3 to i64
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %for.body.lr.ph.i.i
  %indvars.iv.i.i = phi i64 [ 0, %for.body.lr.ph.i.i ], [ %indvars.iv.next.i.i, %for.inc.i.i ]
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv.i.i
  %5 = load ptr, ptr %arrayidx.i.i, align 8
  %cmp1.i.i = icmp eq ptr %5, %0
  br i1 %cmp1.i.i, label %if.then.i.i, label %for.inc.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %6 = trunc i64 %indvars.iv.i.i to i32
  %add.i.i = add nuw nsw i32 %6, 1
  %cmp3.i.i = icmp slt i32 %add.i.i, %3
  br i1 %cmp3.i.i, label %if.then4.i.i, label %if.end.i.i

if.then4.i.i:                                     ; preds = %if.then.i.i
  %arrayidx.i.i.le = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv.i.i
  %7 = xor i32 %6, -1
  %sub6.i.i = add nsw i32 %3, %7
  %idx.ext10.i.i = zext nneg i32 %add.i.i to i64
  %add.ptr11.i.i = getelementptr inbounds ptr, ptr %4, i64 %idx.ext10.i.i
  %conv.i.i = sext i32 %sub6.i.i to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 3
  tail call void @llvm.memmove.p0.p0.i64(ptr nonnull align 8 %arrayidx.i.i.le, ptr nonnull align 8 %add.ptr11.i.i, i64 %mul.i.i, i1 false)
  %.pre.i.i = load i32, ptr %numslaves.i.i, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then4.i.i, %if.then.i.i
  %8 = phi i32 [ %.pre.i.i, %if.then4.i.i ], [ %3, %if.then.i.i ]
  %dec.i.i = add nsw i32 %8, -1
  store i32 %dec.i.i, ptr %numslaves.i.i, align 8
  %cmp14.i.i = icmp eq i32 %dec.i.i, 0
  br i1 %cmp14.i.i, label %if.then16.i.i, label %clusterNodeRemoveSlave.exit.i

if.then16.i.i:                                    ; preds = %if.end.i.i
  %flags.i9.i = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 3
  %9 = load i32, ptr %flags.i9.i, align 8
  %and.i10.i = and i32 %9, -257
  store i32 %and.i10.i, ptr %flags.i9.i, align 8
  br label %clusterNodeRemoveSlave.exit.i

for.inc.i.i:                                      ; preds = %for.body.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.not.i.i = icmp eq i64 %indvars.iv.next.i.i, %wide.trip.count.i.i
  br i1 %exitcond.not.i.i, label %clusterNodeRemoveSlave.exit.i, label %for.body.i.i, !llvm.loop !24

clusterNodeRemoveSlave.exit.i:                    ; preds = %for.inc.i.i, %if.then16.i.i, %if.end.i.i, %if.then2.i
  %10 = load ptr, ptr @myself, align 8
  %cmp.not.i = icmp eq ptr %10, %0
  %.pre.i = load i32, ptr %flags, align 8
  %or.i = or i32 %.pre.i, 256
  %spec.select.i = select i1 %cmp.not.i, i32 %.pre.i, i32 %or.i
  br label %if.end7.i

if.end7.i:                                        ; preds = %clusterNodeRemoveSlave.exit.i, %if.end.i
  %11 = phi i32 [ %1, %if.end.i ], [ %spec.select.i, %clusterNodeRemoveSlave.exit.i ]
  %and.i = and i32 %11, -4
  %or10.i = or disjoint i32 %and.i, 1
  store i32 %or10.i, ptr %flags, align 8
  store ptr null, ptr %slaveof.i, align 8
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i.i = getelementptr inbounds %struct.clusterState, ptr %12, i64 0, i32 22
  %13 = load i32, ptr %todo_before_sleep.i.i, align 8
  %or.i.i = or i32 %13, 6
  store i32 %or.i.i, ptr %todo_before_sleep.i.i, align 8
  br label %clusterSetNodeAsMaster.exit

clusterSetNodeAsMaster.exit:                      ; preds = %if.then, %if.end7.i
  tail call void @replicationUnsetMaster() #33
  %call = tail call i64 @emptyData(i32 noundef -1, i32 noundef 0, ptr noundef null) #33
  br label %if.end

if.end:                                           ; preds = %clusterSetNodeAsMaster.exit, %entry
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %migrating_slots_to.i = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 7
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %migrating_slots_to.i, i8 0, i64 131072, i1 false)
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %importing_slots_from.i = getelementptr inbounds %struct.clusterState, ptr %15, i64 0, i32 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %importing_slots_from.i, i8 0, i64 131072, i1 false)
  %mf_slave.i = getelementptr inbounds %struct.clusterState, ptr %15, i64 0, i32 18
  %16 = load ptr, ptr %mf_slave.i, align 8
  %tobool.not.i6 = icmp eq ptr %16, null
  br i1 %tobool.not.i6, label %resetManualFailover.exit, label %if.then.i

if.then.i:                                        ; preds = %if.end
  tail call void @unpauseActions(i32 noundef 2) #33
  %.pre.i7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %resetManualFailover.exit

resetManualFailover.exit:                         ; preds = %if.end, %if.then.i
  %.pre28 = phi ptr [ %.pre.i7, %if.then.i ], [ %15, %if.end ]
  %mf_end.i = getelementptr inbounds %struct.clusterState, ptr %.pre28, i64 0, i32 17
  %mf_can_start.i = getelementptr inbounds %struct.clusterState, ptr %.pre28, i64 0, i32 20
  store i32 0, ptr %mf_can_start.i, align 8
  %mf_master_offset.i = getelementptr inbounds %struct.clusterState, ptr %.pre28, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mf_end.i, i8 0, i64 16, i1 false)
  store i64 -1, ptr %mf_master_offset.i, align 8
  br label %for.body

for.body:                                         ; preds = %resetManualFailover.exit, %clusterDelSlot.exit
  %17 = phi ptr [ %.pre28, %resetManualFailover.exit ], [ %29, %clusterDelSlot.exit ]
  %indvars.iv = phi i64 [ 0, %resetManualFailover.exit ], [ %indvars.iv.next, %clusterDelSlot.exit ]
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %17, i64 0, i32 9, i64 %indvars.iv
  %18 = load ptr, ptr %arrayidx.i, align 8
  %tobool.not.i9 = icmp eq ptr %18, null
  br i1 %tobool.not.i9, label %clusterDelSlot.exit, label %if.end.i10

if.end.i10:                                       ; preds = %for.body
  %19 = trunc i64 %indvars.iv to i32
  tail call void @removeChannelsInSlot(i32 noundef %19)
  %slots.i.i = getelementptr inbounds %struct._clusterNode, ptr %18, i64 0, i32 5
  %div.i.i.i161718 = lshr i64 %indvars.iv, 3
  %conv.i.i.i = and i64 %div.i.i.i161718, 536870911
  %and.i.i.i = and i32 %19, 7
  %arrayidx.i.i.i = getelementptr inbounds i8, ptr %slots.i.i, i64 %conv.i.i.i
  %20 = load i8, ptr %arrayidx.i.i.i, align 1
  %conv1.i.i.i = zext i8 %20 to i32
  %21 = shl nuw nsw i32 1, %and.i.i.i
  %22 = and i32 %21, %conv1.i.i.i
  %tobool.not.i.i = icmp eq i32 %22, 0
  br i1 %tobool.not.i.i, label %cond.false.i, label %cond.end.i

cond.false.i:                                     ; preds = %if.end.i10
  tail call void @_serverAssert(ptr noundef nonnull @.str.138, ptr noundef nonnull @.str.18, i32 noundef 4866) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %if.end.i10
  %23 = trunc i32 %21 to i8
  %24 = xor i8 %23, -1
  %conv3.i9.i.i = and i8 %20, %24
  store i8 %conv3.i9.i.i, ptr %arrayidx.i.i.i, align 1
  %numslots.i.i = getelementptr inbounds %struct._clusterNode, ptr %18, i64 0, i32 8
  %25 = load i32, ptr %numslots.i.i, align 4
  %dec.i.i11 = add nsw i32 %25, -1
  store i32 %dec.i.i11, ptr %numslots.i.i, align 4
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5.i = getelementptr inbounds %struct.clusterState, ptr %26, i64 0, i32 9, i64 %indvars.iv
  store ptr null, ptr %arrayidx5.i, align 8
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot.i = getelementptr inbounds %struct.clusterState, ptr %27, i64 0, i32 27
  %arrayidx.i.i12 = getelementptr inbounds i8, ptr %owner_not_claiming_slot.i, i64 %conv.i.i.i
  %28 = load i8, ptr %arrayidx.i.i12, align 1
  %conv3.i.i = and i8 %28, %24
  store i8 %conv3.i.i, ptr %arrayidx.i.i12, align 1
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %clusterDelSlot.exit

clusterDelSlot.exit:                              ; preds = %for.body, %cond.end.i
  %29 = phi ptr [ %17, %for.body ], [ %.pre, %cond.end.i ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !25

for.end:                                          ; preds = %clusterDelSlot.exit
  %shards = getelementptr inbounds %struct.clusterState, ptr %29, i64 0, i32 5
  %30 = load ptr, ptr %shards, align 8
  tail call void @dictEmpty(ptr noundef %30, ptr noundef null) #33
  %31 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %31, i64 0, i32 4
  %32 = load ptr, ptr %nodes, align 8
  %call2 = tail call ptr @dictGetSafeIterator(ptr noundef %32) #33
  %call323 = tail call ptr @dictNext(ptr noundef %call2) #33
  %cmp4.not24 = icmp eq ptr %call323, null
  br i1 %cmp4.not24, label %while.end, label %while.body

while.body:                                       ; preds = %for.end, %while.cond.backedge
  %call325 = phi ptr [ %call3, %while.cond.backedge ], [ %call323, %for.end ]
  %call5 = tail call ptr @dictGetVal(ptr noundef nonnull %call325) #33
  %33 = load ptr, ptr @myself, align 8
  %cmp6 = icmp eq ptr %call5, %33
  br i1 %cmp6, label %while.cond.backedge, label %if.end8

if.end8:                                          ; preds = %while.body
  tail call void @clusterDelNode(ptr noundef %call5)
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.end8, %while.body
  %call3 = tail call ptr @dictNext(ptr noundef %call2) #33
  %cmp4.not = icmp eq ptr %call3, null
  br i1 %cmp4.not, label %while.end, label %while.body, !llvm.loop !26

while.end:                                        ; preds = %while.cond.backedge, %for.end
  tail call void @dictReleaseIterator(ptr noundef %call2) #33
  %34 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %34, i64 0, i32 6
  %35 = load ptr, ptr %nodes_black_list, align 8
  tail call void @dictEmpty(ptr noundef %35, ptr noundef null) #33
  %tobool9.not = icmp eq i32 %hard, 0
  br i1 %tobool9.not, label %if.end27, label %if.then10

if.then10:                                        ; preds = %while.end
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %36, i64 0, i32 1
  store i64 0, ptr %currentEpoch, align 8
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %37, i64 0, i32 21
  store i64 0, ptr %lastVoteEpoch, align 8
  %38 = load ptr, ptr @myself, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %38, i64 0, i32 4
  store i64 0, ptr %configEpoch, align 8
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp11 = icmp sgt i32 %39, 2
  br i1 %cmp11, label %do.end, label %if.end13

if.end13:                                         ; preds = %if.then10
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.48) #33
  %.pre29 = load ptr, ptr @myself, align 8
  br label %do.end

do.end:                                           ; preds = %if.then10, %if.end13
  %40 = phi ptr [ %38, %if.then10 ], [ %.pre29, %if.end13 ]
  %name = getelementptr inbounds %struct._clusterNode, ptr %40, i64 0, i32 1
  %call14 = tail call ptr @sdsnewlen(ptr noundef nonnull %name, i64 noundef 40) #33
  %41 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes15 = getelementptr inbounds %struct.clusterState, ptr %41, i64 0, i32 4
  %42 = load ptr, ptr %nodes15, align 8
  %call16 = tail call i32 @dictDelete(ptr noundef %42, ptr noundef %call14) #33
  tail call void @sdsfree(ptr noundef %call14) #33
  %43 = load ptr, ptr @myself, align 8
  %name17 = getelementptr inbounds %struct._clusterNode, ptr %43, i64 0, i32 1
  tail call void @getRandomHexChars(ptr noundef nonnull %name17, i64 noundef 40) #33
  %44 = load ptr, ptr @myself, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %44, i64 0, i32 2
  tail call void @getRandomHexChars(ptr noundef nonnull %shard_id, i64 noundef 40) #33
  %45 = load ptr, ptr @myself, align 8
  %46 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %46, i64 0, i32 4
  %47 = load ptr, ptr %nodes.i, align 8
  %name.i = getelementptr inbounds %struct._clusterNode, ptr %45, i64 0, i32 1
  %call.i = tail call ptr @sdsnewlen(ptr noundef nonnull %name.i, i64 noundef 40) #33
  %call1.i = tail call i32 @dictAdd(ptr noundef %47, ptr noundef %call.i, ptr noundef %45) #33
  %cmp.i = icmp eq i32 %call1.i, 0
  br i1 %cmp.i, label %clusterAddNode.exit, label %cond.false.i13

cond.false.i13:                                   ; preds = %do.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  tail call void @abort() #35
  unreachable

clusterAddNode.exit:                              ; preds = %do.end
  %48 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp21 = icmp sgt i32 %48, 2
  br i1 %cmp21, label %if.end27, label %if.end23

if.end23:                                         ; preds = %clusterAddNode.exit
  %49 = load ptr, ptr @myself, align 8
  %name24 = getelementptr inbounds %struct._clusterNode, ptr %49, i64 0, i32 1
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.49, ptr noundef nonnull %name24) #33
  br label %if.end27

if.end27:                                         ; preds = %if.end23, %clusterAddNode.exit, %while.end
  %50 = load ptr, ptr @myself, align 8
  %shard_id28 = getelementptr inbounds %struct._clusterNode, ptr %50, i64 0, i32 2
  tail call void @clusterAddNodeToShard(ptr noundef nonnull %shard_id28, ptr noundef %50)
  %51 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %51, i64 0, i32 22
  %52 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i15 = or i32 %52, 14
  store i32 %or.i15, ptr %todo_before_sleep.i, align 8
  ret void
}

; Function Attrs: nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local void @clusterSetNodeAsMaster(ptr noundef %n) local_unnamed_addr #22 {
entry:
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 3
  %0 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %0, 1
  %tobool.not = icmp eq i32 %and.i, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 11
  %1 = load ptr, ptr %slaveof, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %if.end7, label %if.then2

if.then2:                                         ; preds = %if.end
  %numslaves.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 9
  %2 = load i32, ptr %numslaves.i, align 8
  %cmp19.i = icmp sgt i32 %2, 0
  br i1 %cmp19.i, label %for.body.lr.ph.i, label %clusterNodeRemoveSlave.exit

for.body.lr.ph.i:                                 ; preds = %if.then2
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 10
  %3 = load ptr, ptr %slaves.i, align 8
  %wide.trip.count.i = zext nneg i32 %2 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.inc.i ]
  %arrayidx.i = getelementptr inbounds ptr, ptr %3, i64 %indvars.iv.i
  %4 = load ptr, ptr %arrayidx.i, align 8
  %cmp1.i = icmp eq ptr %4, %n
  br i1 %cmp1.i, label %if.then.i, label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  %5 = trunc i64 %indvars.iv.i to i32
  %add.i = add nuw nsw i32 %5, 1
  %cmp3.i = icmp slt i32 %add.i, %2
  br i1 %cmp3.i, label %if.then4.i, label %if.end.i

if.then4.i:                                       ; preds = %if.then.i
  %arrayidx.i.le = getelementptr inbounds ptr, ptr %3, i64 %indvars.iv.i
  %6 = xor i32 %5, -1
  %sub6.i = add nsw i32 %2, %6
  %idx.ext10.i = zext nneg i32 %add.i to i64
  %add.ptr11.i = getelementptr inbounds ptr, ptr %3, i64 %idx.ext10.i
  %conv.i = sext i32 %sub6.i to i64
  %mul.i = shl nsw i64 %conv.i, 3
  tail call void @llvm.memmove.p0.p0.i64(ptr nonnull align 8 %arrayidx.i.le, ptr nonnull align 8 %add.ptr11.i, i64 %mul.i, i1 false)
  %.pre.i = load i32, ptr %numslaves.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then4.i, %if.then.i
  %7 = phi i32 [ %.pre.i, %if.then4.i ], [ %2, %if.then.i ]
  %dec.i = add nsw i32 %7, -1
  store i32 %dec.i, ptr %numslaves.i, align 8
  %cmp14.i = icmp eq i32 %dec.i, 0
  br i1 %cmp14.i, label %if.then16.i, label %clusterNodeRemoveSlave.exit

if.then16.i:                                      ; preds = %if.end.i
  %flags.i9 = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 3
  %8 = load i32, ptr %flags.i9, align 8
  %and.i10 = and i32 %8, -257
  store i32 %and.i10, ptr %flags.i9, align 8
  br label %clusterNodeRemoveSlave.exit

for.inc.i:                                        ; preds = %for.body.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %clusterNodeRemoveSlave.exit, label %for.body.i, !llvm.loop !24

clusterNodeRemoveSlave.exit:                      ; preds = %for.inc.i, %if.then2, %if.end.i, %if.then16.i
  %9 = load ptr, ptr @myself, align 8
  %cmp.not = icmp eq ptr %9, %n
  %.pre = load i32, ptr %flags.i, align 8
  %or = or i32 %.pre, 256
  %spec.select = select i1 %cmp.not, i32 %.pre, i32 %or
  br label %if.end7

if.end7:                                          ; preds = %clusterNodeRemoveSlave.exit, %if.end
  %10 = phi i32 [ %0, %if.end ], [ %spec.select, %clusterNodeRemoveSlave.exit ]
  %and = and i32 %10, -4
  %or10 = or disjoint i32 %and, 1
  store i32 %or10, ptr %flags.i, align 8
  store ptr null, ptr %slaveof, align 8
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %11, i64 0, i32 22
  %12 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %12, 6
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %return

return:                                           ; preds = %entry, %if.end7
  ret void
}

declare void @replicationUnsetMaster() local_unnamed_addr #1

declare i64 @emptyData(i32 noundef, i32 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterDelSlot(i32 noundef %slot) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom = sext i32 %slot to i64
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 9, i64 %idxprom
  %1 = load ptr, ptr %arrayidx, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  tail call void @removeChannelsInSlot(i32 noundef %slot)
  %slots.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 5
  %div.i.i = sdiv i32 %slot, 8
  %conv.i.i = sext i32 %div.i.i to i64
  %and.i.i = and i32 %slot, 7
  %arrayidx.i.i = getelementptr inbounds i8, ptr %slots.i, i64 %conv.i.i
  %2 = load i8, ptr %arrayidx.i.i, align 1
  %conv1.i.i = zext i8 %2 to i32
  %3 = shl nuw nsw i32 1, %and.i.i
  %4 = and i32 %3, %conv1.i.i
  %tobool.not.i = icmp eq i32 %4, 0
  br i1 %tobool.not.i, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.138, ptr noundef nonnull @.str.18, i32 noundef 4866) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.end
  %5 = trunc i32 %3 to i8
  %6 = xor i8 %5, -1
  %conv3.i9.i = and i8 %2, %6
  store i8 %conv3.i9.i, ptr %arrayidx.i.i, align 1
  %numslots.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 8
  %7 = load i32, ptr %numslots.i, align 4
  %dec.i = add nsw i32 %7, -1
  store i32 %dec.i, ptr %numslots.i, align 4
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5 = getelementptr inbounds %struct.clusterState, ptr %8, i64 0, i32 9, i64 %idxprom
  store ptr null, ptr %arrayidx5, align 8
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %9, i64 0, i32 27
  %arrayidx.i = getelementptr inbounds i8, ptr %owner_not_claiming_slot, i64 %conv.i.i
  %10 = load i8, ptr %arrayidx.i, align 1
  %conv3.i = and i8 %10, %6
  store i8 %conv3.i, ptr %arrayidx.i, align 1
  br label %return

return:                                           ; preds = %entry, %cond.end
  %retval.0 = phi i32 [ 0, %cond.end ], [ -1, %entry ]
  ret i32 %retval.0
}

declare void @dictEmpty(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @dictGetSafeIterator(ptr noundef) local_unnamed_addr #1

declare ptr @dictNext(ptr noundef) local_unnamed_addr #1

declare ptr @dictGetVal(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterDelNode(ptr noundef %delnode) local_unnamed_addr #2 {
entry:
  %.pre24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %tobool.not.i = icmp eq ptr %delnode, null
  %slots.i.i = getelementptr inbounds %struct._clusterNode, ptr %delnode, i64 0, i32 5
  %numslots.i.i = getelementptr inbounds %struct._clusterNode, ptr %delnode, i64 0, i32 8
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %0 = phi ptr [ %.pre24, %entry ], [ %16, %for.inc ]
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 8, i64 %indvars.iv
  %1 = load ptr, ptr %arrayidx, align 8
  %cmp1 = icmp eq ptr %1, %delnode
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store ptr null, ptr %arrayidx, align 8
  %.pre25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %2 = phi ptr [ %.pre25, %if.then ], [ %0, %for.body ]
  %arrayidx6 = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 7, i64 %indvars.iv
  %3 = load ptr, ptr %arrayidx6, align 8
  %cmp7 = icmp eq ptr %3, %delnode
  br i1 %cmp7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end
  store ptr null, ptr %arrayidx6, align 8
  %.pre26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then8, %if.end
  %4 = phi ptr [ %.pre26, %if.then8 ], [ %2, %if.end ]
  %arrayidx14 = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 9, i64 %indvars.iv
  %5 = load ptr, ptr %arrayidx14, align 8
  %cmp15 = icmp ne ptr %5, %delnode
  %brmerge = or i1 %cmp15, %tobool.not.i
  br i1 %brmerge, label %for.inc, label %if.end.i

if.end.i:                                         ; preds = %if.end12
  %6 = trunc i64 %indvars.iv to i32
  tail call void @removeChannelsInSlot(i32 noundef %6)
  %div.i.i.i161718 = lshr i64 %indvars.iv, 3
  %conv.i.i.i = and i64 %div.i.i.i161718, 536870911
  %and.i.i.i = and i32 %6, 7
  %arrayidx.i.i.i = getelementptr inbounds i8, ptr %slots.i.i, i64 %conv.i.i.i
  %7 = load i8, ptr %arrayidx.i.i.i, align 1
  %conv1.i.i.i = zext i8 %7 to i32
  %8 = shl nuw nsw i32 1, %and.i.i.i
  %9 = and i32 %8, %conv1.i.i.i
  %tobool.not.i.i = icmp eq i32 %9, 0
  br i1 %tobool.not.i.i, label %cond.false.i, label %cond.end.i

cond.false.i:                                     ; preds = %if.end.i
  tail call void @_serverAssert(ptr noundef nonnull @.str.138, ptr noundef nonnull @.str.18, i32 noundef 4866) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %if.end.i
  %10 = trunc i32 %8 to i8
  %11 = xor i8 %10, -1
  %conv3.i9.i.i = and i8 %7, %11
  store i8 %conv3.i9.i.i, ptr %arrayidx.i.i.i, align 1
  %12 = load i32, ptr %numslots.i.i, align 4
  %dec.i.i = add nsw i32 %12, -1
  store i32 %dec.i.i, ptr %numslots.i.i, align 4
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5.i = getelementptr inbounds %struct.clusterState, ptr %13, i64 0, i32 9, i64 %indvars.iv
  store ptr null, ptr %arrayidx5.i, align 8
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot.i = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 27
  %arrayidx.i.i = getelementptr inbounds i8, ptr %owner_not_claiming_slot.i, i64 %conv.i.i.i
  %15 = load i8, ptr %arrayidx.i.i, align 1
  %conv3.i.i = and i8 %15, %11
  store i8 %conv3.i.i, ptr %arrayidx.i.i, align 1
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %cond.end.i
  %16 = phi ptr [ %.pre, %cond.end.i ], [ %4, %if.end12 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !27

for.end:                                          ; preds = %for.inc
  %nodes = getelementptr inbounds %struct.clusterState, ptr %16, i64 0, i32 4
  %17 = load ptr, ptr %nodes, align 8
  %call18 = tail call ptr @dictGetSafeIterator(ptr noundef %17) #33
  %call1920 = tail call ptr @dictNext(ptr noundef %call18) #33
  %cmp20.not21 = icmp eq ptr %call1920, null
  br i1 %cmp20.not21, label %while.end, label %while.body

while.body:                                       ; preds = %for.end, %while.cond.backedge
  %call1922 = phi ptr [ %call19, %while.cond.backedge ], [ %call1920, %for.end ]
  %call21 = tail call ptr @dictGetVal(ptr noundef nonnull %call1922) #33
  %cmp22 = icmp eq ptr %call21, %delnode
  br i1 %cmp22, label %while.cond.backedge, label %if.end24

if.end24:                                         ; preds = %while.body
  %call25 = tail call i32 @clusterNodeDelFailureReport(ptr noundef %call21, ptr noundef %delnode), !range !18
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.end24, %while.body
  %call19 = tail call ptr @dictNext(ptr noundef %call18) #33
  %cmp20.not = icmp eq ptr %call19, null
  br i1 %cmp20.not, label %while.end, label %while.body, !llvm.loop !28

while.end:                                        ; preds = %while.cond.backedge, %for.end
  tail call void @dictReleaseIterator(ptr noundef %call18) #33
  tail call void @clusterRemoveNodeFromShard(ptr noundef %delnode)
  tail call void @freeClusterNode(ptr noundef %delnode)
  ret void
}

declare void @dictReleaseIterator(ptr noundef) local_unnamed_addr #1

declare ptr @sdsnewlen(ptr noundef, i64 noundef) local_unnamed_addr #1

declare i32 @dictDelete(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @getRandomHexChars(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @createClusterLink(ptr noundef %node) local_unnamed_addr #2 {
entry:
  %call = tail call noalias dereferenceable_or_null(80) ptr @zmalloc(i64 noundef 80) #37
  %call1 = tail call i64 @mstime() #33
  store i64 %call1, ptr %call, align 8
  %call2 = tail call ptr @listCreate() #33
  %send_msg_queue = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 2
  store ptr %call2, ptr %send_msg_queue, align 8
  %free = getelementptr inbounds %struct.list, ptr %call2, i64 0, i32 3
  store ptr @clusterMsgSendBlockDecrRefCount, ptr %free, align 8
  %head_msg_send_offset = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 3
  store i64 0, ptr %head_msg_send_offset, align 8
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 4
  store i64 48, ptr %send_msg_queue_mem, align 8
  %rcvbuf_alloc = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 7
  store i64 1024, ptr %rcvbuf_alloc, align 8
  %call4 = tail call noalias dereferenceable_or_null(1024) ptr @zmalloc(i64 noundef 1024) #37
  %rcvbuf = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 5
  store ptr %call4, ptr %rcvbuf, align 8
  %rcvbuf_len = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 6
  store i64 0, ptr %rcvbuf_len, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add7 = add i64 %0, 1072
  store i64 %add7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 1
  store ptr null, ptr %conn, align 8
  %node8 = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 8
  store ptr %node, ptr %node8, align 8
  %cmp = icmp eq ptr %node, null
  %conv = zext i1 %cmp to i32
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %call, i64 0, i32 9
  store i32 %conv, ptr %inbound, align 8
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %link10 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 27
  store ptr %call, ptr %link10, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %call
}

declare ptr @listCreate() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal void @clusterMsgSendBlockDecrRefCount(ptr noundef %node) #2 {
entry:
  %refcount = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %node, i64 0, i32 1
  %0 = load i32, ptr %refcount, align 8
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr %refcount, align 8
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %cmp4 = icmp eq i32 %dec, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %1 = load i64, ptr %node, align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub = sub i64 %2, %1
  store i64 %sub, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %node) #33
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @freeClusterLink(ptr noundef %link) local_unnamed_addr #2 {
entry:
  %conn = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %0 = load ptr, ptr %conn, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %0, align 8
  %close.i = getelementptr inbounds %struct.ConnectionType, ptr %1, i64 0, i32 12
  %2 = load ptr, ptr %close.i, align 8
  tail call void %2(ptr noundef nonnull %0) #33
  store ptr null, ptr %conn, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %send_msg_queue = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 2
  %3 = load ptr, ptr %send_msg_queue, align 8
  %len = getelementptr inbounds %struct.list, ptr %3, i64 0, i32 5
  %4 = load i64, ptr %len, align 8
  %mul.neg = mul i64 %4, -24
  %add.neg = add i64 %mul.neg, -48
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub = add i64 %add.neg, %5
  store i64 %sub, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %6 = load ptr, ptr %send_msg_queue, align 8
  tail call void @listRelease(ptr noundef %6) #33
  %rcvbuf_alloc = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 7
  %7 = load i64, ptr %rcvbuf_alloc, align 8
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub4 = sub i64 %8, %7
  store i64 %sub4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %rcvbuf = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 5
  %9 = load ptr, ptr %rcvbuf, align 8
  tail call void @zfree(ptr noundef %9) #33
  %node = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 8
  %10 = load ptr, ptr %node, align 8
  %tobool5.not = icmp eq ptr %10, null
  br i1 %tobool5.not, label %if.end35, label %if.then6

if.then6:                                         ; preds = %if.end
  %link8 = getelementptr inbounds %struct._clusterNode, ptr %10, i64 0, i32 27
  %11 = load ptr, ptr %link8, align 8
  %cmp = icmp eq ptr %11, %link
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then6
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 9
  %12 = load i32, ptr %inbound, align 8
  %tobool10.not = icmp eq i32 %12, 0
  br i1 %tobool10.not, label %if.end35.sink.split, label %cond.false

cond.false:                                       ; preds = %if.then9
  tail call void @_serverAssert(ptr noundef nonnull @.str.50, ptr noundef nonnull @.str.18, i32 noundef 1194) #33
  tail call void @abort() #35
  unreachable

if.else:                                          ; preds = %if.then6
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %10, i64 0, i32 28
  %13 = load ptr, ptr %inbound_link, align 8
  %cmp17 = icmp eq ptr %13, %link
  br i1 %cmp17, label %if.then19, label %if.end35

if.then19:                                        ; preds = %if.else
  %inbound20 = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 9
  %14 = load i32, ptr %inbound20, align 8
  %tobool21.not = icmp eq i32 %14, 0
  br i1 %tobool21.not, label %cond.false29, label %if.end35.sink.split

cond.false29:                                     ; preds = %if.then19
  tail call void @_serverAssert(ptr noundef nonnull @.str.51, ptr noundef nonnull @.str.18, i32 noundef 1197) #33
  tail call void @abort() #35
  unreachable

if.end35.sink.split:                              ; preds = %if.then19, %if.then9
  %link8.sink = phi ptr [ %link8, %if.then9 ], [ %inbound_link, %if.then19 ]
  store ptr null, ptr %link8.sink, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.end35.sink.split, %if.else, %if.end
  tail call void @zfree(ptr noundef nonnull %link) #33
  ret void
}

declare void @listRelease(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @setClusterNodeToInboundClusterLink(ptr noundef %node, ptr noundef %link) local_unnamed_addr #2 {
entry:
  %node1 = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 8
  %0 = load ptr, ptr %node1, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.52, ptr noundef nonnull @.str.18, i32 noundef 1205) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 9
  %1 = load i32, ptr %inbound, align 8
  %tobool5.not = icmp eq i32 %1, 0
  br i1 %tobool5.not, label %cond.false13, label %cond.end14

cond.false13:                                     ; preds = %cond.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.51, ptr noundef nonnull @.str.18, i32 noundef 1206) #33
  tail call void @abort() #35
  unreachable

cond.end14:                                       ; preds = %cond.end
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 28
  %2 = load ptr, ptr %inbound_link, align 8
  %tobool15.not = icmp eq ptr %2, null
  br i1 %tobool15.not, label %cond.end35, label %do.body

do.body:                                          ; preds = %cond.end14
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.end22, label %if.end

if.end:                                           ; preds = %do.body
  %conn = getelementptr inbounds %struct.clusterLink, ptr %2, i64 0, i32 1
  %4 = load ptr, ptr %conn, align 8
  %fd = getelementptr inbounds %struct.connection, ptr %4, i64 0, i32 3
  %5 = load i32, ptr %fd, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %conn19 = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %6 = load ptr, ptr %conn19, align 8
  %fd20 = getelementptr inbounds %struct.connection, ptr %6, i64 0, i32 3
  %7 = load i32, ptr %fd20, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.53, i32 noundef %5, ptr noundef nonnull %name, i32 noundef %7) #33
  %.pre = load ptr, ptr %inbound_link, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.end, %do.body
  %8 = phi ptr [ %.pre, %if.end ], [ %2, %do.body ]
  tail call void @freeClusterLink(ptr noundef %8)
  %.pr = load ptr, ptr %inbound_link, align 8
  %tobool24.not = icmp eq ptr %.pr, null
  br i1 %tobool24.not, label %cond.end35, label %cond.false34

cond.false34:                                     ; preds = %if.end22
  tail call void @_serverAssert(ptr noundef nonnull @.str.54, ptr noundef nonnull @.str.18, i32 noundef 1219) #33
  tail call void @abort() #35
  unreachable

cond.end35:                                       ; preds = %cond.end14, %if.end22
  store ptr %link, ptr %inbound_link, align 8
  store ptr %node, ptr %node1, align 8
  ret void
}

declare i32 @anetTcpAccept(ptr noundef, i32 noundef, ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

declare i32 @connEnableTcpNoDelay(ptr noundef) local_unnamed_addr #1

declare i32 @connKeepAlive(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal void @clusterConnAcceptHandler(ptr noundef %conn) #2 {
entry:
  %0 = getelementptr i8, ptr %conn, i64 8
  %conn.val = load i32, ptr %0, align 8
  %cmp.not = icmp eq i32 %conn.val, 3
  br i1 %cmp.not, label %if.end4, label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %1, 1
  br i1 %cmp1, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %conn, align 8
  %get_last_error.i = getelementptr inbounds %struct.ConnectionType, ptr %2, i64 0, i32 21
  %3 = load ptr, ptr %get_last_error.i, align 8
  %call.i = tail call ptr %3(ptr noundef nonnull %conn) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.58, ptr noundef %call.i) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  %4 = load ptr, ptr %conn, align 8
  %close.i = getelementptr inbounds %struct.ConnectionType, ptr %4, i64 0, i32 12
  %5 = load ptr, ptr %close.i, align 8
  tail call void %5(ptr noundef nonnull %conn) #33
  br label %return

if.end4:                                          ; preds = %entry
  %call.i7 = tail call noalias dereferenceable_or_null(80) ptr @zmalloc(i64 noundef 80) #37
  %call1.i = tail call i64 @mstime() #33
  store i64 %call1.i, ptr %call.i7, align 8
  %call2.i = tail call ptr @listCreate() #33
  %send_msg_queue.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 2
  store ptr %call2.i, ptr %send_msg_queue.i, align 8
  %free.i = getelementptr inbounds %struct.list, ptr %call2.i, i64 0, i32 3
  store ptr @clusterMsgSendBlockDecrRefCount, ptr %free.i, align 8
  %head_msg_send_offset.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 3
  store i64 0, ptr %head_msg_send_offset.i, align 8
  %send_msg_queue_mem.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 4
  store i64 48, ptr %send_msg_queue_mem.i, align 8
  %rcvbuf_alloc.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 7
  store i64 1024, ptr %rcvbuf_alloc.i, align 8
  %call4.i = tail call noalias dereferenceable_or_null(1024) ptr @zmalloc(i64 noundef 1024) #37
  %rcvbuf.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 5
  store ptr %call4.i, ptr %rcvbuf.i, align 8
  %rcvbuf_len.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 6
  store i64 0, ptr %rcvbuf_len.i, align 8
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add7.i = add i64 %6, 1072
  store i64 %add7.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 1
  %node8.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 8
  store ptr null, ptr %node8.i, align 8
  %inbound.i = getelementptr inbounds %struct.clusterLink, ptr %call.i7, i64 0, i32 9
  store i32 1, ptr %inbound.i, align 8
  store ptr %conn, ptr %conn.i, align 8
  %private_data.i = getelementptr inbounds %struct.connection, ptr %conn, i64 0, i32 7
  store ptr %call.i7, ptr %private_data.i, align 8
  %7 = load ptr, ptr %conn, align 8
  %set_read_handler.i = getelementptr inbounds %struct.ConnectionType, ptr %7, i64 0, i32 20
  %8 = load ptr, ptr %set_read_handler.i, align 8
  %call.i8 = tail call i32 %8(ptr noundef nonnull %conn, ptr noundef nonnull @clusterReadHandler) #33
  br label %return

return:                                           ; preds = %if.end4, %do.end
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i64 @getClusterConnectionsCount() local_unnamed_addr #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %2, i64 0, i32 2
  %3 = load i64, ptr %ht_used, align 8
  %arrayidx3 = getelementptr inbounds %struct.dict, ptr %2, i64 0, i32 2, i64 1
  %4 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %4, %3
  %sub = shl i64 %add, 1
  %mul = add i64 %sub, -2
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 0, %entry ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeAddFailureReport(ptr nocapture noundef readonly %failing, ptr noundef %sender) local_unnamed_addr #2 {
entry:
  %li = alloca %struct.listIter, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %failing, i64 0, i32 29
  %0 = load ptr, ptr %fail_reports, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #33
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call ptr @listNext(ptr noundef nonnull %li) #33
  %cmp.not = icmp eq ptr %call, null
  br i1 %cmp.not, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %value = getelementptr inbounds %struct.listNode, ptr %call, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp1 = icmp eq ptr %2, %sender
  br i1 %cmp1, label %if.then, label %while.cond, !llvm.loop !29

if.then:                                          ; preds = %while.body
  %call2 = call i64 @mstime() #33
  %time = getelementptr inbounds %struct.clusterNodeFailReport, ptr %1, i64 0, i32 1
  store i64 %call2, ptr %time, align 8
  br label %return

while.end:                                        ; preds = %while.cond
  %call3 = call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #37
  store ptr %sender, ptr %call3, align 8
  %call5 = call i64 @mstime() #33
  %time6 = getelementptr inbounds %struct.clusterNodeFailReport, ptr %call3, i64 0, i32 1
  store i64 %call5, ptr %time6, align 8
  %call7 = call ptr @listAddNodeTail(ptr noundef %0, ptr noundef nonnull %call3) #33
  br label %return

return:                                           ; preds = %while.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 1, %while.end ]
  ret i32 %retval.0
}

declare void @listRewind(ptr noundef, ptr noundef) local_unnamed_addr #1

declare ptr @listNext(ptr noundef) local_unnamed_addr #1

declare ptr @listAddNodeTail(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterNodeCleanupFailureReports(ptr nocapture noundef readonly %node) local_unnamed_addr #2 {
entry:
  %li = alloca %struct.listIter, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 29
  %0 = load ptr, ptr %fail_reports, align 8
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %mul = shl nsw i64 %1, 1
  %call = tail call i64 @mstime() #33
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #33
  %call13 = call ptr @listNext(ptr noundef nonnull %li) #33
  %cmp.not4 = icmp eq ptr %call13, null
  br i1 %cmp.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call15 = phi ptr [ %call1, %if.end ], [ %call13, %entry ]
  %value = getelementptr inbounds %struct.listNode, ptr %call15, i64 0, i32 2
  %2 = load ptr, ptr %value, align 8
  %time = getelementptr inbounds %struct.clusterNodeFailReport, ptr %2, i64 0, i32 1
  %3 = load i64, ptr %time, align 8
  %sub = sub nsw i64 %call, %3
  %cmp2 = icmp sgt i64 %sub, %mul
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  call void @listDelNode(ptr noundef %0, ptr noundef nonnull %call15) #33
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %call1 = call ptr @listNext(ptr noundef nonnull %li) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !30

while.end:                                        ; preds = %if.end, %entry
  ret void
}

declare void @listDelNode(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeDelFailureReport(ptr nocapture noundef readonly %node, ptr noundef readnone %sender) local_unnamed_addr #2 {
entry:
  %li.i = alloca %struct.listIter, align 8
  %li = alloca %struct.listIter, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 29
  %0 = load ptr, ptr %fail_reports, align 8
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li) #33
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call ptr @listNext(ptr noundef nonnull %li) #33
  %cmp.not = icmp eq ptr %call, null
  br i1 %cmp.not, label %return, label %while.body

while.body:                                       ; preds = %while.cond
  %value = getelementptr inbounds %struct.listNode, ptr %call, i64 0, i32 2
  %1 = load ptr, ptr %value, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp2 = icmp eq ptr %2, %sender
  br i1 %cmp2, label %if.end4, label %while.cond, !llvm.loop !31

if.end4:                                          ; preds = %while.body
  call void @listDelNode(ptr noundef %0, ptr noundef nonnull %call) #33
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i)
  %3 = load ptr, ptr %fail_reports, align 8
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %mul.i = shl nsw i64 %4, 1
  %call.i = call i64 @mstime() #33
  call void @listRewind(ptr noundef %3, ptr noundef nonnull %li.i) #33
  %call13.i = call ptr @listNext(ptr noundef nonnull %li.i) #33
  %cmp.not4.i = icmp eq ptr %call13.i, null
  br i1 %cmp.not4.i, label %clusterNodeCleanupFailureReports.exit, label %while.body.i

while.body.i:                                     ; preds = %if.end4, %if.end.i
  %call15.i = phi ptr [ %call1.i, %if.end.i ], [ %call13.i, %if.end4 ]
  %value.i = getelementptr inbounds %struct.listNode, ptr %call15.i, i64 0, i32 2
  %5 = load ptr, ptr %value.i, align 8
  %time.i = getelementptr inbounds %struct.clusterNodeFailReport, ptr %5, i64 0, i32 1
  %6 = load i64, ptr %time.i, align 8
  %sub.i = sub nsw i64 %call.i, %6
  %cmp2.i = icmp sgt i64 %sub.i, %mul.i
  br i1 %cmp2.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %while.body.i
  call void @listDelNode(ptr noundef %3, ptr noundef nonnull %call15.i) #33
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %while.body.i
  %call1.i = call ptr @listNext(ptr noundef nonnull %li.i) #33
  %cmp.not.i = icmp eq ptr %call1.i, null
  br i1 %cmp.not.i, label %clusterNodeCleanupFailureReports.exit, label %while.body.i, !llvm.loop !30

clusterNodeCleanupFailureReports.exit:            ; preds = %if.end.i, %if.end4
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  br label %return

return:                                           ; preds = %while.cond, %clusterNodeCleanupFailureReports.exit
  %retval.0 = phi i32 [ 1, %clusterNodeCleanupFailureReports.exit ], [ 0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeFailureReportsCount(ptr nocapture noundef readonly %node) local_unnamed_addr #2 {
entry:
  %li.i = alloca %struct.listIter, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i)
  %fail_reports.i = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 29
  %0 = load ptr, ptr %fail_reports.i, align 8
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %mul.i = shl nsw i64 %1, 1
  %call.i = tail call i64 @mstime() #33
  call void @listRewind(ptr noundef %0, ptr noundef nonnull %li.i) #33
  %call13.i = call ptr @listNext(ptr noundef nonnull %li.i) #33
  %cmp.not4.i = icmp eq ptr %call13.i, null
  br i1 %cmp.not4.i, label %clusterNodeCleanupFailureReports.exit, label %while.body.i

while.body.i:                                     ; preds = %entry, %if.end.i
  %call15.i = phi ptr [ %call1.i, %if.end.i ], [ %call13.i, %entry ]
  %value.i = getelementptr inbounds %struct.listNode, ptr %call15.i, i64 0, i32 2
  %2 = load ptr, ptr %value.i, align 8
  %time.i = getelementptr inbounds %struct.clusterNodeFailReport, ptr %2, i64 0, i32 1
  %3 = load i64, ptr %time.i, align 8
  %sub.i = sub nsw i64 %call.i, %3
  %cmp2.i = icmp sgt i64 %sub.i, %mul.i
  br i1 %cmp2.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %while.body.i
  call void @listDelNode(ptr noundef %0, ptr noundef nonnull %call15.i) #33
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %while.body.i
  %call1.i = call ptr @listNext(ptr noundef nonnull %li.i) #33
  %cmp.not.i = icmp eq ptr %call1.i, null
  br i1 %cmp.not.i, label %clusterNodeCleanupFailureReports.exit, label %while.body.i, !llvm.loop !30

clusterNodeCleanupFailureReports.exit:            ; preds = %if.end.i, %entry
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  %4 = load ptr, ptr %fail_reports.i, align 8
  %len = getelementptr inbounds %struct.list, ptr %4, i64 0, i32 5
  %5 = load i64, ptr %len, align 8
  %conv = trunc i64 %5 to i32
  ret i32 %conv
}

; Function Attrs: nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @clusterNodeRemoveSlave(ptr nocapture noundef %master, ptr noundef readnone %slave) local_unnamed_addr #22 {
entry:
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %master, i64 0, i32 9
  %0 = load i32, ptr %numslaves, align 8
  %cmp19 = icmp sgt i32 %0, 0
  br i1 %cmp19, label %for.body.lr.ph, label %return

for.body.lr.ph:                                   ; preds = %entry
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %master, i64 0, i32 10
  %1 = load ptr, ptr %slaves, align 8
  %wide.trip.count = zext nneg i32 %0 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %cmp1 = icmp eq ptr %2, %slave
  br i1 %cmp1, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %3 = trunc i64 %indvars.iv to i32
  %add = add nuw nsw i32 %3, 1
  %cmp3 = icmp slt i32 %add, %0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %arrayidx.le = getelementptr inbounds ptr, ptr %1, i64 %indvars.iv
  %4 = xor i32 %3, -1
  %sub6 = add nsw i32 %0, %4
  %idx.ext10 = zext nneg i32 %add to i64
  %add.ptr11 = getelementptr inbounds ptr, ptr %1, i64 %idx.ext10
  %conv = sext i32 %sub6 to i64
  %mul = shl nsw i64 %conv, 3
  tail call void @llvm.memmove.p0.p0.i64(ptr nonnull align 8 %arrayidx.le, ptr nonnull align 8 %add.ptr11, i64 %mul, i1 false)
  %.pre = load i32, ptr %numslaves, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %5 = phi i32 [ %.pre, %if.then4 ], [ %0, %if.then ]
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %numslaves, align 8
  %cmp14 = icmp eq i32 %dec, 0
  br i1 %cmp14, label %if.then16, label %return

if.then16:                                        ; preds = %if.end
  %flags = getelementptr inbounds %struct._clusterNode, ptr %master, i64 0, i32 3
  %6 = load i32, ptr %flags, align 8
  %and = and i32 %6, -257
  store i32 %and, ptr %flags, align 8
  br label %return

for.inc:                                          ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %return, label %for.body, !llvm.loop !24

return:                                           ; preds = %for.inc, %entry, %if.end, %if.then16
  %retval.0 = phi i32 [ 0, %if.then16 ], [ 0, %if.end ], [ -1, %entry ], [ -1, %for.inc ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #6

; Function Attrs: allocsize(1)
declare ptr @zrealloc(ptr noundef, i64 noundef) local_unnamed_addr #23

; Function Attrs: nofree norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @clusterCountNonFailingSlaves(ptr nocapture noundef readonly %n) local_unnamed_addr #24 {
entry:
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 9
  %0 = load i32, ptr %numslaves, align 8
  %cmp5 = icmp sgt i32 %0, 0
  br i1 %cmp5, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 10
  %1 = load ptr, ptr %slaves, align 8
  %wide.trip.count = zext nneg i32 %0 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %okslaves.07 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ]
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 3
  %3 = load i32, ptr %flags, align 8
  %and = lshr i32 %3, 3
  %4 = and i32 %and, 1
  %5 = xor i32 %4, 1
  %spec.select = add i32 %5, %okslaves.07
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !32

for.end:                                          ; preds = %for.body, %entry
  %okslaves.0.lcssa = phi i32 [ 0, %entry ], [ %spec.select, %for.body ]
  ret i32 %okslaves.0.lcssa
}

; Function Attrs: nounwind uwtable
define dso_local void @freeClusterNode(ptr noundef %n) local_unnamed_addr #2 {
entry:
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 9
  %0 = load i32, ptr %numslaves, align 8
  %cmp23 = icmp sgt i32 %0, 0
  br i1 %cmp23, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 10
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %1 = load ptr, ptr %slaves, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 11
  store ptr null, ptr %slaveof, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %3 = load i32, ptr %numslaves, align 8
  %4 = sext i32 %3 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %4
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !33

for.end:                                          ; preds = %for.body, %entry
  %flags = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 3
  %5 = load i32, ptr %flags, align 8
  %and = and i32 %5, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end
  %slaveof1 = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 11
  %6 = load ptr, ptr %slaveof1, align 8
  %tobool2.not = icmp eq ptr %6, null
  br i1 %tobool2.not, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %numslaves.i = getelementptr inbounds %struct._clusterNode, ptr %6, i64 0, i32 9
  %7 = load i32, ptr %numslaves.i, align 8
  %cmp19.i = icmp sgt i32 %7, 0
  br i1 %cmp19.i, label %for.body.lr.ph.i, label %if.end

for.body.lr.ph.i:                                 ; preds = %if.then
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %6, i64 0, i32 10
  %8 = load ptr, ptr %slaves.i, align 8
  %wide.trip.count.i = zext nneg i32 %7 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.inc.i ]
  %arrayidx.i = getelementptr inbounds ptr, ptr %8, i64 %indvars.iv.i
  %9 = load ptr, ptr %arrayidx.i, align 8
  %cmp1.i = icmp eq ptr %9, %n
  br i1 %cmp1.i, label %if.then.i, label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  %10 = trunc i64 %indvars.iv.i to i32
  %add.i = add nuw nsw i32 %10, 1
  %cmp3.i = icmp slt i32 %add.i, %7
  br i1 %cmp3.i, label %if.then4.i, label %if.end.i

if.then4.i:                                       ; preds = %if.then.i
  %arrayidx.i.le = getelementptr inbounds ptr, ptr %8, i64 %indvars.iv.i
  %11 = xor i32 %10, -1
  %sub6.i = add nsw i32 %7, %11
  %idx.ext10.i = zext nneg i32 %add.i to i64
  %add.ptr11.i = getelementptr inbounds ptr, ptr %8, i64 %idx.ext10.i
  %conv.i = sext i32 %sub6.i to i64
  %mul.i = shl nsw i64 %conv.i, 3
  tail call void @llvm.memmove.p0.p0.i64(ptr nonnull align 8 %arrayidx.i.le, ptr nonnull align 8 %add.ptr11.i, i64 %mul.i, i1 false)
  %.pre.i = load i32, ptr %numslaves.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then4.i, %if.then.i
  %12 = phi i32 [ %.pre.i, %if.then4.i ], [ %7, %if.then.i ]
  %dec.i = add nsw i32 %12, -1
  store i32 %dec.i, ptr %numslaves.i, align 8
  %cmp14.i = icmp eq i32 %dec.i, 0
  br i1 %cmp14.i, label %if.then16.i, label %if.end

if.then16.i:                                      ; preds = %if.end.i
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %6, i64 0, i32 3
  %13 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %13, -257
  store i32 %and.i, ptr %flags.i, align 8
  br label %if.end

for.inc.i:                                        ; preds = %for.body.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end, label %for.body.i, !llvm.loop !24

if.end:                                           ; preds = %for.inc.i, %if.then16.i, %if.end.i, %if.then, %land.lhs.true, %for.end
  %name = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 1
  %call4 = tail call ptr @sdsnewlen(ptr noundef nonnull %name, i64 noundef 40) #33
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 4
  %15 = load ptr, ptr %nodes, align 8
  %call5 = tail call i32 @dictDelete(ptr noundef %15, ptr noundef %call4) #33
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.59, ptr noundef nonnull @.str.18, i32 noundef 1511) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.end
  tail call void @sdsfree(ptr noundef %call4) #33
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 22
  %16 = load ptr, ptr %hostname, align 8
  tail call void @sdsfree(ptr noundef %16) #33
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 23
  %17 = load ptr, ptr %human_nodename, align 8
  tail call void @sdsfree(ptr noundef %17) #33
  %link = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 27
  %18 = load ptr, ptr %link, align 8
  %tobool9.not = icmp eq ptr %18, null
  br i1 %tobool9.not, label %if.end12, label %if.then10

if.then10:                                        ; preds = %cond.end
  tail call void @freeClusterLink(ptr noundef nonnull %18)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %cond.end
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 28
  %19 = load ptr, ptr %inbound_link, align 8
  %tobool13.not = icmp eq ptr %19, null
  br i1 %tobool13.not, label %if.end16, label %if.then14

if.then14:                                        ; preds = %if.end12
  tail call void @freeClusterLink(ptr noundef nonnull %19)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 29
  %20 = load ptr, ptr %fail_reports, align 8
  tail call void @listRelease(ptr noundef %20) #33
  %slaves17 = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 10
  %21 = load ptr, ptr %slaves17, align 8
  tail call void @zfree(ptr noundef %21) #33
  tail call void @zfree(ptr noundef nonnull %n) #33
  ret void
}

declare i32 @dictAdd(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterRemoveNodeFromShard(ptr noundef %node) local_unnamed_addr #2 {
entry:
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 2
  %call = tail call ptr @sdsnewlen(ptr noundef nonnull %shard_id, i64 noundef 40) #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 5
  %1 = load ptr, ptr %shards, align 8
  %call1 = tail call ptr @dictFind(ptr noundef %1, ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %if.end11, label %if.then

if.then:                                          ; preds = %entry
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call1) #33
  %call3 = tail call ptr @listSearchKey(ptr noundef %call2, ptr noundef %node) #33
  %cmp4.not = icmp eq ptr %call3, null
  br i1 %cmp4.not, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  tail call void @listDelNode(ptr noundef %call2, ptr noundef nonnull %call3) #33
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  %len = getelementptr inbounds %struct.list, ptr %call2, i64 0, i32 5
  %2 = load i64, ptr %len, align 8
  %cmp6 = icmp eq i64 %2, 0
  br i1 %cmp6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards8 = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 5
  %4 = load ptr, ptr %shards8, align 8
  %call9 = tail call i32 @dictDelete(ptr noundef %4, ptr noundef %call) #33
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then7, %entry
  tail call void @sdsfree(ptr noundef %call) #33
  ret void
}

declare ptr @dictFind(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterRenameNode(ptr noundef %node, ptr noundef %newname) local_unnamed_addr #2 {
entry:
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %call = tail call ptr @sdsnewlen(ptr noundef nonnull %name, i64 noundef 40) #33
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %do.end, label %if.end

if.end:                                           ; preds = %entry
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.61, ptr noundef nonnull %name, ptr noundef %newname) #33
  br label %do.end

do.end:                                           ; preds = %entry, %if.end
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %nodes, align 8
  %call3 = tail call i32 @dictDelete(ptr noundef %2, ptr noundef %call) #33
  tail call void @sdsfree(ptr noundef %call) #33
  %cmp4 = icmp eq i32 %call3, 0
  br i1 %cmp4, label %cond.end, label %cond.false

cond.false:                                       ; preds = %do.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1612) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %do.end
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %name, ptr noundef nonnull align 1 dereferenceable(40) %newname, i64 40, i1 false)
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 4
  %4 = load ptr, ptr %nodes.i, align 8
  %call.i = tail call ptr @sdsnewlen(ptr noundef nonnull %name, i64 noundef 40) #33
  %call1.i = tail call i32 @dictAdd(ptr noundef %4, ptr noundef %call.i, ptr noundef %node) #33
  %cmp.i = icmp eq i32 %call1.i, 0
  br i1 %cmp.i, label %clusterAddNode.exit, label %cond.false.i

cond.false.i:                                     ; preds = %cond.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  tail call void @abort() #35
  unreachable

clusterAddNode.exit:                              ; preds = %cond.end
  ret void
}

declare ptr @listSearchKey(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterBumpConfigEpochWithoutConsensus() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes.i, align 8
  %call.i = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  %call17.i = tail call ptr @dictNext(ptr noundef %call.i) #33
  %cmp.not8.i = icmp eq ptr %call17.i, null
  br i1 %cmp.not8.i, label %clusterGetMaxEpoch.exit, label %while.body.i

while.body.i:                                     ; preds = %entry, %while.body.i
  %call110.i = phi ptr [ %call1.i, %while.body.i ], [ %call17.i, %entry ]
  %max.09.i = phi i64 [ %spec.select.i, %while.body.i ], [ 0, %entry ]
  %call2.i = tail call ptr @dictGetVal(ptr noundef nonnull %call110.i) #33
  %configEpoch.i = getelementptr inbounds %struct._clusterNode, ptr %call2.i, i64 0, i32 4
  %2 = load i64, ptr %configEpoch.i, align 8
  %spec.select.i = tail call i64 @llvm.umax.i64(i64 %2, i64 %max.09.i)
  %call1.i = tail call ptr @dictNext(ptr noundef %call.i) #33
  %cmp.not.i = icmp eq ptr %call1.i, null
  br i1 %cmp.not.i, label %clusterGetMaxEpoch.exit, label %while.body.i, !llvm.loop !17

clusterGetMaxEpoch.exit:                          ; preds = %while.body.i, %entry
  %max.0.lcssa.i = phi i64 [ 0, %entry ], [ %spec.select.i, %while.body.i ]
  tail call void @dictReleaseIterator(ptr noundef %call.i) #33
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch.i = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 1
  %4 = load i64, ptr %currentEpoch.i, align 8
  %spec.select6.i = tail call i64 @llvm.umax.i64(i64 %max.0.lcssa.i, i64 %4)
  %5 = load ptr, ptr @myself, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 4
  %6 = load i64, ptr %configEpoch, align 8
  %cmp = icmp ne i64 %6, 0
  %cmp2.not = icmp eq i64 %6, %spec.select6.i
  %or.cond = select i1 %cmp, i1 %cmp2.not, i1 false
  br i1 %or.cond, label %return, label %if.then

if.then:                                          ; preds = %clusterGetMaxEpoch.exit
  %inc = add i64 %4, 1
  store i64 %inc, ptr %currentEpoch.i, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch3 = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 1
  %8 = load i64, ptr %currentEpoch3, align 8
  store i64 %8, ptr %configEpoch, align 8
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %9, i64 0, i32 22
  %10 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %10, 12
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp5 = icmp sgt i32 %11, 2
  br i1 %cmp5, label %return, label %if.end

if.end:                                           ; preds = %if.then
  %12 = load i64, ptr %configEpoch, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.63, i64 noundef %12) #33
  br label %return

return:                                           ; preds = %clusterGetMaxEpoch.exit, %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ 0, %if.end ], [ -1, %clusterGetMaxEpoch.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterHandleConfigEpochCollision(ptr noundef %sender) local_unnamed_addr #2 {
entry:
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %sender, i64 0, i32 4
  %0 = load i64, ptr %configEpoch, align 8
  %1 = load ptr, ptr @myself, align 8
  %configEpoch1 = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 4
  %2 = load i64, ptr %configEpoch1, align 8
  %cmp.not = icmp eq i64 %0, %2
  br i1 %cmp.not, label %lor.lhs.false, label %do.end

lor.lhs.false:                                    ; preds = %entry
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %sender, i64 0, i32 3
  %3 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %3, 1
  %tobool.not = icmp eq i32 %and.i, 0
  br i1 %tobool.not, label %do.end, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %flags.i5 = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 3
  %4 = load i32, ptr %flags.i5, align 8
  %and.i6 = and i32 %4, 1
  %tobool4.not = icmp eq i32 %and.i6, 0
  br i1 %tobool4.not, label %do.end, label %if.end

if.end:                                           ; preds = %lor.lhs.false2
  %name = getelementptr inbounds %struct._clusterNode, ptr %sender, i64 0, i32 1
  %name5 = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 1
  %call7 = tail call i32 @memcmp(ptr noundef nonnull dereferenceable(40) %name, ptr noundef nonnull dereferenceable(40) %name5, i64 noundef 40) #34
  %cmp8 = icmp slt i32 %call7, 1
  br i1 %cmp8, label %do.end, label %if.end10

if.end10:                                         ; preds = %if.end
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 1
  %6 = load i64, ptr %currentEpoch, align 8
  %inc = add i64 %6, 1
  store i64 %inc, ptr %currentEpoch, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch11 = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 1
  %8 = load i64, ptr %currentEpoch11, align 8
  store i64 %8, ptr %configEpoch1, align 8
  %call.i = tail call i32 @clusterSaveConfig(i32 noundef 1), !range !21
  %cmp.i = icmp eq i32 %call.i, -1
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  br i1 %cmp.i, label %do.body.i, label %clusterSaveConfigOrDie.exit

do.body.i:                                        ; preds = %if.end10
  %cmp1.i = icmp sgt i32 %9, 3
  br i1 %cmp1.i, label %do.end.i, label %if.end.i

if.end.i:                                         ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.38) #33
  br label %do.end.i

do.end.i:                                         ; preds = %if.end.i, %do.body.i
  tail call void @exit(i32 noundef 1) #35
  unreachable

clusterSaveConfigOrDie.exit:                      ; preds = %if.end10
  %cmp13 = icmp sgt i32 %9, 1
  br i1 %cmp13, label %do.end, label %if.end15

if.end15:                                         ; preds = %clusterSaveConfigOrDie.exit
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %sender, i64 0, i32 23
  %10 = load ptr, ptr %human_nodename, align 8
  %11 = load ptr, ptr @myself, align 8
  %configEpoch18 = getelementptr inbounds %struct._clusterNode, ptr %11, i64 0, i32 4
  %12 = load i64, ptr %configEpoch18, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.64, ptr noundef nonnull %name, ptr noundef %10, i64 noundef %12) #33
  br label %do.end

do.end:                                           ; preds = %clusterSaveConfigOrDie.exit, %if.end, %entry, %lor.lhs.false, %lor.lhs.false2, %if.end15
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @clusterNodeIsMaster(ptr nocapture noundef readonly %n) local_unnamed_addr #5 {
entry:
  %flags = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 3
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 1
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterBlacklistCleanup() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 6
  %1 = load ptr, ptr %nodes_black_list, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  %call13 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not4 = icmp eq ptr %call13, null
  br i1 %cmp.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call15 = phi ptr [ %call1, %if.end ], [ %call13, %entry ]
  %call2 = tail call i64 @dictGetUnsignedIntegerVal(ptr noundef nonnull %call15) #33
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %cmp3 = icmp slt i64 %call2, %atomic-load
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list4 = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 6
  %3 = load ptr, ptr %nodes_black_list4, align 8
  %call5 = tail call ptr @dictGetKey(ptr noundef nonnull %call15) #33
  %call6 = tail call i32 @dictDelete(ptr noundef %3, ptr noundef %call5) #33
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %call1 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !34

while.end:                                        ; preds = %if.end, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  ret void
}

declare i64 @dictGetUnsignedIntegerVal(ptr noundef) local_unnamed_addr #1

declare ptr @dictGetKey(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterBlacklistAddNode(ptr noundef %node) local_unnamed_addr #2 {
entry:
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %call = tail call ptr @sdsnewlen(ptr noundef nonnull %name, i64 noundef 40) #33
  tail call void @clusterBlacklistCleanup()
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 6
  %1 = load ptr, ptr %nodes_black_list, align 8
  %call1 = tail call i32 @dictAdd(ptr noundef %1, ptr noundef %call, ptr noundef null) #33
  %cmp = icmp eq i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = tail call ptr @sdsdup(ptr noundef %call) #33
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %id.0 = phi ptr [ %call2, %if.then ], [ %call, %entry ]
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list3 = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 6
  %3 = load ptr, ptr %nodes_black_list3, align 8
  %call4 = tail call ptr @dictFind(ptr noundef %3, ptr noundef %id.0) #33
  %call5 = tail call i64 @time(ptr noundef null) #33
  %add = add nsw i64 %call5, 60
  tail call void @dictSetUnsignedIntegerVal(ptr noundef %call4, i64 noundef %add) #33
  tail call void @sdsfree(ptr noundef %id.0) #33
  ret void
}

declare ptr @sdsdup(ptr noundef) local_unnamed_addr #1

declare void @dictSetUnsignedIntegerVal(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind
declare i64 @time(ptr noundef) local_unnamed_addr #12

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterBlacklistExists(ptr noundef %nodeid) local_unnamed_addr #2 {
entry:
  %call = tail call ptr @sdsnewlen(ptr noundef %nodeid, i64 noundef 40) #33
  tail call void @clusterBlacklistCleanup()
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 6
  %1 = load ptr, ptr %nodes_black_list, align 8
  %call2 = tail call ptr @dictFind(ptr noundef %1, ptr noundef %call) #33
  %cmp = icmp ne ptr %call2, null
  %conv = zext i1 %cmp to i32
  tail call void @sdsfree(ptr noundef %call) #33
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local void @markNodeAsFailingIfNeeded(ptr noundef %node) local_unnamed_addr #2 {
entry:
  %li.i.i = alloca %struct.listIter, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 3
  %1 = load i32, ptr %size, align 4
  %div = sdiv i32 %1, 2
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %3 = and i32 %2, 12
  %or.cond = icmp eq i32 %3, 4
  br i1 %or.cond, label %if.end5, label %return

if.end5:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i.i)
  %fail_reports.i.i = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 29
  %4 = load ptr, ptr %fail_reports.i.i, align 8
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %mul.i.i = shl nsw i64 %5, 1
  %call.i.i = tail call i64 @mstime() #33
  call void @listRewind(ptr noundef %4, ptr noundef nonnull %li.i.i) #33
  %call13.i.i = call ptr @listNext(ptr noundef nonnull %li.i.i) #33
  %cmp.not4.i.i = icmp eq ptr %call13.i.i, null
  br i1 %cmp.not4.i.i, label %clusterNodeFailureReportsCount.exit, label %while.body.i.i

while.body.i.i:                                   ; preds = %if.end5, %if.end.i.i
  %call15.i.i = phi ptr [ %call1.i.i, %if.end.i.i ], [ %call13.i.i, %if.end5 ]
  %value.i.i = getelementptr inbounds %struct.listNode, ptr %call15.i.i, i64 0, i32 2
  %6 = load ptr, ptr %value.i.i, align 8
  %time.i.i = getelementptr inbounds %struct.clusterNodeFailReport, ptr %6, i64 0, i32 1
  %7 = load i64, ptr %time.i.i, align 8
  %sub.i.i = sub nsw i64 %call.i.i, %7
  %cmp2.i.i = icmp sgt i64 %sub.i.i, %mul.i.i
  br i1 %cmp2.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %while.body.i.i
  call void @listDelNode(ptr noundef %4, ptr noundef nonnull %call15.i.i) #33
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i, %while.body.i.i
  %call1.i.i = call ptr @listNext(ptr noundef nonnull %li.i.i) #33
  %cmp.not.i.i = icmp eq ptr %call1.i.i, null
  br i1 %cmp.not.i.i, label %clusterNodeFailureReportsCount.exit, label %while.body.i.i, !llvm.loop !30

clusterNodeFailureReportsCount.exit:              ; preds = %if.end.i.i, %if.end5
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i.i)
  %8 = load ptr, ptr %fail_reports.i.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %8, i64 0, i32 5
  %9 = load i64, ptr %len.i, align 8
  %conv.i = trunc i64 %9 to i32
  %10 = load ptr, ptr @myself, align 8
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %10, i64 0, i32 3
  %11 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %11, 1
  %spec.select = add i32 %and.i, %conv.i
  %cmp.not = icmp sgt i32 %spec.select, %div
  br i1 %cmp.not, label %do.body, label %return

do.body:                                          ; preds = %clusterNodeFailureReportsCount.exit
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp12 = icmp sgt i32 %12, 2
  br i1 %cmp12, label %do.end, label %if.end14

if.end14:                                         ; preds = %do.body
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %13 = load ptr, ptr %human_nodename, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.65, ptr noundef nonnull %name, ptr noundef %13) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end14
  %14 = load i32, ptr %flags, align 8
  %and16 = and i32 %14, -13
  %or = or disjoint i32 %and16, 8
  store i32 %or, ptr %flags, align 8
  %call18 = call i64 @mstime() #33
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 16
  store i64 %call18, ptr %fail_time, align 8
  %name19 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %call.i = call fastcc ptr @createClusterMsgSendBlock(i32 noundef 3, i32 noundef 2296)
  %data.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call.i, i64 0, i32 2, i32 20
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %data.i, ptr noundef nonnull align 1 dereferenceable(40) %name19, i64 40, i1 false)
  call void @clusterBroadcastMessage(ptr noundef %call.i)
  %refcount.i.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call.i, i64 0, i32 1
  %15 = load i32, ptr %refcount.i.i, align 8
  %dec.i.i = add nsw i32 %15, -1
  store i32 %dec.i.i, ptr %refcount.i.i, align 8
  %cmp.i.i = icmp sgt i32 %15, 0
  br i1 %cmp.i.i, label %cond.end.i.i, label %cond.false.i.i

cond.false.i.i:                                   ; preds = %do.end
  call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  call void @abort() #35
  unreachable

cond.end.i.i:                                     ; preds = %do.end
  %cmp4.i.i = icmp eq i32 %dec.i.i, 0
  br i1 %cmp4.i.i, label %if.then.i.i10, label %clusterSendFail.exit

if.then.i.i10:                                    ; preds = %cond.end.i.i
  %16 = load i64, ptr %call.i, align 8
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i.i11 = sub i64 %17, %16
  store i64 %sub.i.i11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  call void @zfree(ptr noundef nonnull %call.i) #33
  br label %clusterSendFail.exit

clusterSendFail.exit:                             ; preds = %cond.end.i.i, %if.then.i.i10
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %18, i64 0, i32 22
  %19 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %19, 6
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %return

return:                                           ; preds = %clusterNodeFailureReportsCount.exit, %entry, %clusterSendFail.exit
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendFail(ptr nocapture noundef readonly %nodename) local_unnamed_addr #2 {
entry:
  %call = tail call fastcc ptr @createClusterMsgSendBlock(i32 noundef 3, i32 noundef 2296)
  %data = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %data, ptr noundef nonnull align 1 dereferenceable(40) %nodename, i64 40, i1 false)
  tail call void @clusterBroadcastMessage(ptr noundef %call)
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %0 = load i32, ptr %refcount.i, align 8
  %dec.i = add nsw i32 %0, -1
  store i32 %dec.i, ptr %refcount.i, align 8
  %cmp.i = icmp sgt i32 %0, 0
  br i1 %cmp.i, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %entry
  %cmp4.i = icmp eq i32 %dec.i, 0
  br i1 %cmp4.i, label %if.then.i, label %clusterMsgSendBlockDecrRefCount.exit

if.then.i:                                        ; preds = %cond.end.i
  %1 = load i64, ptr %call, align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i = sub i64 %2, %1
  store i64 %sub.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %call) #33
  br label %clusterMsgSendBlockDecrRefCount.exit

clusterMsgSendBlockDecrRefCount.exit:             ; preds = %cond.end.i, %if.then.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clearNodeFailureIfNeeded(ptr noundef %node) local_unnamed_addr #2 {
entry:
  %call = tail call i64 @mstime() #33
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 8
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.66, ptr noundef nonnull @.str.18, i32 noundef 1915) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %and4 = and i32 %0, 2
  %tobool5.not = icmp eq i32 %and4, 0
  br i1 %tobool5.not, label %lor.lhs.false, label %do.body

lor.lhs.false:                                    ; preds = %cond.end
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 8
  %1 = load i32, ptr %numslots, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %do.body, label %if.end15

do.body:                                          ; preds = %cond.end, %lor.lhs.false
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp7 = icmp sgt i32 %2, 2
  br i1 %cmp7, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %3 = load ptr, ptr %human_nodename, align 8
  %cond = select i1 %tobool5.not, ptr @.str.69, ptr @.str.68
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.67, ptr noundef nonnull %name, ptr noundef %3, ptr noundef nonnull %cond) #33
  %.pre = load i32, ptr %flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  %4 = phi i32 [ %0, %do.body ], [ %.pre, %if.end ]
  %and14 = and i32 %4, -9
  store i32 %and14, ptr %flags, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 22
  %6 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %6, 6
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  %.pre15 = load i32, ptr %flags, align 8
  br label %if.end15

if.end15:                                         ; preds = %do.end, %lor.lhs.false
  %7 = phi i32 [ %.pre15, %do.end ], [ %0, %lor.lhs.false ]
  %and.i = and i32 %7, 1
  %tobool17.not = icmp eq i32 %and.i, 0
  br i1 %tobool17.not, label %if.end36, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end15
  %numslots18 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 8
  %8 = load i32, ptr %numslots18, align 4
  %cmp19 = icmp sgt i32 %8, 0
  br i1 %cmp19, label %land.lhs.true21, label %if.end36

land.lhs.true21:                                  ; preds = %land.lhs.true
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 16
  %9 = load i64, ptr %fail_time, align 8
  %sub = sub nsw i64 %call, %9
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %mul = shl nsw i64 %10, 1
  %cmp22 = icmp sgt i64 %sub, %mul
  br i1 %cmp22, label %do.body25, label %if.end36

do.body25:                                        ; preds = %land.lhs.true21
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp26 = icmp sgt i32 %11, 2
  br i1 %cmp26, label %do.end33, label %if.end29

if.end29:                                         ; preds = %do.body25
  %name30 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename32 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %12 = load ptr, ptr %human_nodename32, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.70, ptr noundef nonnull %name30, ptr noundef %12) #33
  %.pre16 = load i32, ptr %flags, align 8
  br label %do.end33

do.end33:                                         ; preds = %do.body25, %if.end29
  %13 = phi i32 [ %7, %do.body25 ], [ %.pre16, %if.end29 ]
  %and35 = and i32 %13, -9
  store i32 %and35, ptr %flags, align 8
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i13 = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 22
  %15 = load i32, ptr %todo_before_sleep.i13, align 8
  %or.i14 = or i32 %15, 6
  store i32 %or.i14, ptr %todo_before_sleep.i13, align 8
  br label %if.end36

if.end36:                                         ; preds = %do.end33, %land.lhs.true21, %land.lhs.true, %if.end15
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterHandshakeInProgress(ptr nocapture noundef readonly %ip, i32 noundef %port, i32 noundef %cport) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  %call16 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp8.not = icmp eq ptr %call16, null
  br i1 %cmp8.not, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.cond.backedge
  %call19 = phi ptr [ %call1, %while.cond.backedge ], [ %call16, %entry ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call19) #33
  %flags = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and = and i32 %2, 32
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %while.cond.backedge, label %if.end

if.end:                                           ; preds = %while.body
  %ip3 = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 21
  %call4 = tail call i32 @strcasecmp(ptr noundef nonnull %ip3, ptr noundef %ip) #34
  %tobool5.not = icmp eq i32 %call4, 0
  br i1 %tobool5.not, label %land.lhs.true, label %while.cond.backedge

land.lhs.true:                                    ; preds = %if.end
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i = icmp eq i32 %3, 0
  %tls_port.i = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 25
  %tcp_port.i = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 24
  %cond.in.i = select i1 %tobool.not.i, ptr %tcp_port.i, ptr %tls_port.i
  %cond.i = load i32, ptr %cond.in.i, align 4
  %cmp7 = icmp eq i32 %cond.i, %port
  br i1 %cmp7, label %land.lhs.true8, label %while.cond.backedge

land.lhs.true8:                                   ; preds = %land.lhs.true
  %cport9 = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 26
  %4 = load i32, ptr %cport9, align 8
  %cmp10 = icmp eq i32 %4, %cport
  br i1 %cmp10, label %while.end, label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.end, %land.lhs.true, %land.lhs.true8, %while.body
  %call1 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !35

while.end:                                        ; preds = %while.cond.backedge, %land.lhs.true8, %entry
  %cmp.lcssa = phi i32 [ 0, %entry ], [ 1, %land.lhs.true8 ], [ 0, %while.cond.backedge ]
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  ret i32 %cmp.lcssa
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterStartHandshake(ptr noundef %ip, i32 noundef %port, i32 noundef %cport) local_unnamed_addr #2 {
entry:
  %norm_ip = alloca [46 x i8], align 16
  %sa = alloca %struct.sockaddr_storage, align 8
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, ptr %sa, i64 0, i32 2
  %call = call i32 @inet_pton(i32 noundef 2, ptr noundef %ip, ptr noundef nonnull %sin_addr) #33
  %tobool.not.not = icmp eq i32 %call, 0
  br i1 %tobool.not.not, label %if.else, label %if.end7

if.else:                                          ; preds = %entry
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, ptr %sa, i64 0, i32 3
  %call1 = call i32 @inet_pton(i32 noundef 10, ptr noundef %ip, ptr noundef nonnull %sin6_addr) #33
  %tobool2.not = icmp eq i32 %call1, 0
  br i1 %tobool2.not, label %return.sink.split, label %if.end7

if.end7:                                          ; preds = %if.else, %entry
  %storemerge = phi i16 [ 2, %entry ], [ 10, %if.else ]
  store i16 %storemerge, ptr %sa, align 8
  %0 = add i32 %port, -65536
  %or.cond = icmp ult i32 %0, -65535
  %1 = add i32 %cport, -65536
  %2 = icmp ult i32 %1, -65535
  %or.cond2 = or i1 %or.cond, %2
  br i1 %or.cond2, label %return.sink.split, label %if.end15

if.end15:                                         ; preds = %if.end7
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(46) %norm_ip, i8 0, i64 46, i1 false)
  br i1 %tobool.not.not, label %if.else23, label %if.then19

if.then19:                                        ; preds = %if.end15
  %call22 = call ptr @inet_ntop(i32 noundef 2, ptr noundef nonnull %sin_addr, ptr noundef nonnull %norm_ip, i32 noundef 46) #33
  br label %if.end27

if.else23:                                        ; preds = %if.end15
  %sin6_addr24 = getelementptr inbounds %struct.sockaddr_in6, ptr %sa, i64 0, i32 3
  %call26 = call ptr @inet_ntop(i32 noundef 10, ptr noundef nonnull %sin6_addr24, ptr noundef nonnull %norm_ip, i32 noundef 46) #33
  br label %if.end27

if.end27:                                         ; preds = %if.else23, %if.then19
  %call29 = call i32 @clusterHandshakeInProgress(ptr noundef nonnull %norm_ip, i32 noundef %port, i32 noundef %cport), !range !18
  %tobool30.not = icmp eq i32 %call29, 0
  br i1 %tobool30.not, label %if.end33, label %return.sink.split

if.end33:                                         ; preds = %if.end27
  %call.i = call noalias dereferenceable_or_null(2368) ptr @zmalloc(i64 noundef 2368) #37
  %name1.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 1
  call void @getRandomHexChars(ptr noundef nonnull %name1.i, i64 noundef 40) #33
  %shard_id.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 2
  call void @getRandomHexChars(ptr noundef nonnull %shard_id.i, i64 noundef 40) #33
  %call4.i = call i64 @mstime() #33
  store i64 %call4.i, ptr %call.i, align 8
  %configEpoch.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 4
  store i64 0, ptr %configEpoch.i, align 8
  %flags5.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 3
  store i32 160, ptr %flags5.i, align 8
  %slots.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 5
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 10
  %link.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 27
  %ip.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 21
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip.i, i8 0, i64 46, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2068) %slots.i, i8 0, i64 2068, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) %slaves.i, i8 0, i64 56, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %link.i, i8 0, i64 16, i1 false)
  %call8.i = call ptr @sdsempty() #33
  %hostname.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 22
  store ptr %call8.i, ptr %hostname.i, align 8
  %call9.i = call ptr @sdsempty() #33
  %human_nodename.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 23
  store ptr %call9.i, ptr %human_nodename.i, align 8
  %tcp_port.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 24
  store i32 0, ptr %tcp_port.i, align 8
  %cport.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 26
  store i32 0, ptr %cport.i, align 8
  %tls_port.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 25
  store i32 0, ptr %tls_port.i, align 4
  %call10.i = call ptr @listCreate() #33
  %fail_reports.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 29
  store ptr %call10.i, ptr %fail_reports.i, align 8
  %voted_time.i = getelementptr inbounds %struct._clusterNode, ptr %call.i, i64 0, i32 17
  %free.i = getelementptr inbounds %struct.list, ptr %call10.i, i64 0, i32 3
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %voted_time.i, i8 0, i64 32, i1 false)
  store ptr @zfree, ptr %free.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip.i, ptr noundef nonnull align 16 dereferenceable(46) %norm_ip, i64 46, i1 false)
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool38.not = icmp eq i32 %3, 0
  br i1 %tobool38.not, label %if.else40, label %if.then39

if.then39:                                        ; preds = %if.end33
  store i32 %port, ptr %tls_port.i, align 4
  br label %if.end41

if.else40:                                        ; preds = %if.end33
  store i32 %port, ptr %tcp_port.i, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.else40, %if.then39
  store i32 %cport, ptr %cport.i, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 4
  %5 = load ptr, ptr %nodes.i, align 8
  %call.i15 = call ptr @sdsnewlen(ptr noundef nonnull %name1.i, i64 noundef 40) #33
  %call1.i = call i32 @dictAdd(ptr noundef %5, ptr noundef %call.i15, ptr noundef nonnull %call.i) #33
  %cmp.i = icmp eq i32 %call1.i, 0
  br i1 %cmp.i, label %return, label %cond.false.i

cond.false.i:                                     ; preds = %if.end41
  call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  call void @abort() #35
  unreachable

return.sink.split:                                ; preds = %if.end27, %if.end7, %if.else
  %.sink = phi i32 [ 22, %if.else ], [ 22, %if.end7 ], [ 11, %if.end27 ]
  %call32 = tail call ptr @__errno_location() #36
  store i32 %.sink, ptr %call32, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %if.end41
  %retval.0 = phi i32 [ 1, %if.end41 ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare i32 @inet_pton(i32 noundef, ptr noundef, ptr noundef) local_unnamed_addr #12

; Function Attrs: nounwind
declare ptr @inet_ntop(i32 noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #12

; Function Attrs: nounwind uwtable
define dso_local void @clusterProcessGossipSection(ptr noundef %hdr, ptr nocapture noundef readonly %link) local_unnamed_addr #2 {
entry:
  %li.i.i = alloca %struct.listIter, align 8
  %li.i = alloca %struct.listIter, align 8
  %count1 = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 5
  %0 = load i16, ptr %count1, align 2
  %call = tail call zeroext i16 @ntohs(i16 noundef zeroext %0) #36
  %data = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 20
  %node = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 8
  %1 = load ptr, ptr %node, align 8
  %tobool.not = icmp eq ptr %1, null
  br i1 %tobool.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  %sender3 = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 9
  %call.i = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %sender3, i32 noundef 40) #33
  %cmp.not.i = icmp eq i32 %call.i, 0
  br i1 %cmp.not.i, label %if.end.i, label %cond.end

if.end.i:                                         ; preds = %cond.false
  %call1.i = tail call ptr @sdsnewlen(ptr noundef nonnull %sender3, i64 noundef 40) #33
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 4
  %3 = load ptr, ptr %nodes.i, align 8
  %call2.i = tail call ptr @dictFind(ptr noundef %3, ptr noundef %call1.i) #33
  tail call void @sdsfree(ptr noundef %call1.i) #33
  %cmp3.i = icmp eq ptr %call2.i, null
  br i1 %cmp3.i, label %cond.end, label %if.end6.i

if.end6.i:                                        ; preds = %if.end.i
  %call7.i = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i) #33
  br label %cond.end

cond.end:                                         ; preds = %if.end6.i, %if.end.i, %cond.false, %entry
  %cond = phi ptr [ %1, %entry ], [ %call7.i, %if.end6.i ], [ null, %cond.false ], [ null, %if.end.i ]
  %tobool6.not121 = icmp eq i16 %call, 0
  br i1 %tobool6.not121, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %cond.end
  %tobool25.not = icmp eq ptr %cond, null
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %cond, i64 0, i32 3
  %name = getelementptr inbounds %struct._clusterNode, ptr %cond, i64 0, i32 1
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %cond, i64 0, i32 23
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end188
  %dec123.in = phi i16 [ %call, %while.body.lr.ph ], [ %dec123, %if.end188 ]
  %g.0122 = phi ptr [ %data, %while.body.lr.ph ], [ %incdec.ptr, %if.end188 ]
  %dec123 = add i16 %dec123.in, -1
  %flags7 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 6
  %4 = load i16, ptr %flags7, align 2
  %call8 = call zeroext i16 @ntohs(i16 noundef zeroext %4) #36
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end19

if.then:                                          ; preds = %while.body
  %call10 = call ptr @sdsempty() #33
  %call11 = call ptr @representClusterNodeFlags(ptr noundef %call10, i16 noundef zeroext %call8)
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp12 = icmp sgt i32 %6, 0
  br i1 %cmp12, label %do.end, label %if.end

if.end:                                           ; preds = %if.then
  %ip = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 3
  %port = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 4
  %7 = load i16, ptr %port, align 2
  %call16 = call zeroext i16 @ntohs(i16 noundef zeroext %7) #36
  %conv = zext i16 %call16 to i32
  %cport = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 5
  %8 = load i16, ptr %cport, align 4
  %call17 = call zeroext i16 @ntohs(i16 noundef zeroext %8) #36
  %conv18 = zext i16 %call17 to i32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.71, ptr noundef nonnull %g.0122, ptr noundef nonnull %ip, i32 noundef %conv, i32 noundef %conv18, ptr noundef %call11) #33
  br label %do.end

do.end:                                           ; preds = %if.then, %if.end
  call void @sdsfree(ptr noundef %call11) #33
  br label %if.end19

if.end19:                                         ; preds = %do.end, %while.body
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i = icmp eq i32 %9, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %if.end19
  %port.i = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 4
  %10 = load i16, ptr %port.i, align 2
  %call.i74 = call zeroext i16 @ntohs(i16 noundef zeroext %10) #36
  %pport.i = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 7
  br label %getClientPortFromGossip.exit

if.else.i:                                        ; preds = %if.end19
  %pport3.i = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 7
  %11 = load i16, ptr %pport3.i, align 4
  %call4.i = call zeroext i16 @ntohs(i16 noundef zeroext %11) #36
  %port6.i = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 4
  br label %getClientPortFromGossip.exit

getClientPortFromGossip.exit:                     ; preds = %if.then.i, %if.else.i
  %msg_tls_port.0.in = phi i16 [ %call4.i, %if.else.i ], [ %call.i74, %if.then.i ]
  %.sink.in.i = phi ptr [ %port6.i, %if.else.i ], [ %pport.i, %if.then.i ]
  %msg_tls_port.0 = zext i16 %msg_tls_port.0.in to i32
  %.sink.i = load i16, ptr %.sink.in.i, align 2
  %call7.i76 = call zeroext i16 @ntohs(i16 noundef zeroext %.sink.i) #36
  %storemerge.i = zext i16 %call7.i76 to i32
  %call.i77 = call i32 @verifyClusterNodeId(ptr noundef nonnull %g.0122, i32 noundef 40) #33
  %cmp.not.i78 = icmp eq i32 %call.i77, 0
  br i1 %cmp.not.i78, label %if.end.i80, label %if.else160

if.end.i80:                                       ; preds = %getClientPortFromGossip.exit
  %call1.i81 = call ptr @sdsnewlen(ptr noundef nonnull %g.0122, i64 noundef 40) #33
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i82 = getelementptr inbounds %struct.clusterState, ptr %12, i64 0, i32 4
  %13 = load ptr, ptr %nodes.i82, align 8
  %call2.i83 = call ptr @dictFind(ptr noundef %13, ptr noundef %call1.i81) #33
  call void @sdsfree(ptr noundef %call1.i81) #33
  %cmp3.i84 = icmp eq ptr %call2.i83, null
  br i1 %cmp3.i84, label %if.else160, label %clusterLookupNode.exit87

clusterLookupNode.exit87:                         ; preds = %if.end.i80
  %call7.i86 = call ptr @dictGetVal(ptr noundef nonnull %call2.i83) #33
  %tobool23.not = icmp eq ptr %call7.i86, null
  br i1 %tobool23.not, label %if.else160, label %if.then24

if.then24:                                        ; preds = %clusterLookupNode.exit87
  br i1 %tobool25.not, label %if.end66, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then24
  %14 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %14, 1
  %tobool27.not = icmp eq i32 %and.i, 0
  %15 = load ptr, ptr @myself, align 8
  %cmp29.not = icmp eq ptr %call7.i86, %15
  %or.cond72 = select i1 %tobool27.not, i1 true, i1 %cmp29.not
  br i1 %or.cond72, label %if.end66, label %if.then31

if.then31:                                        ; preds = %land.lhs.true
  %16 = and i16 %call8, 12
  %tobool33.not = icmp eq i16 %16, 0
  br i1 %tobool33.not, label %if.else, label %if.then34

if.then34:                                        ; preds = %if.then31
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i)
  %fail_reports.i = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 29
  %17 = load ptr, ptr %fail_reports.i, align 8
  call void @listRewind(ptr noundef %17, ptr noundef nonnull %li.i) #33
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %if.then34
  %call.i88 = call ptr @listNext(ptr noundef nonnull %li.i) #33
  %cmp.not.i89 = icmp eq ptr %call.i88, null
  br i1 %cmp.not.i89, label %clusterNodeAddFailureReport.exit, label %while.body.i

while.body.i:                                     ; preds = %while.cond.i
  %value.i = getelementptr inbounds %struct.listNode, ptr %call.i88, i64 0, i32 2
  %18 = load ptr, ptr %value.i, align 8
  %19 = load ptr, ptr %18, align 8
  %cmp1.i = icmp eq ptr %19, %cond
  br i1 %cmp1.i, label %clusterNodeAddFailureReport.exit.thread, label %while.cond.i, !llvm.loop !29

clusterNodeAddFailureReport.exit.thread:          ; preds = %while.body.i
  %call2.i91 = call i64 @mstime() #33
  %time.i = getelementptr inbounds %struct.clusterNodeFailReport, ptr %18, i64 0, i32 1
  store i64 %call2.i91, ptr %time.i, align 8
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  br label %if.end48

clusterNodeAddFailureReport.exit:                 ; preds = %while.cond.i
  %call3.i = call noalias dereferenceable_or_null(16) ptr @zmalloc(i64 noundef 16) #37
  store ptr %cond, ptr %call3.i, align 8
  %call5.i = call i64 @mstime() #33
  %time6.i = getelementptr inbounds %struct.clusterNodeFailReport, ptr %call3.i, i64 0, i32 1
  store i64 %call5.i, ptr %time6.i, align 8
  %call7.i93 = call ptr @listAddNodeTail(ptr noundef %17, ptr noundef nonnull %call3.i) #33
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i)
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp39 = icmp sgt i32 %20, 1
  br i1 %cmp39, label %if.end48, label %if.end42

if.end42:                                         ; preds = %clusterNodeAddFailureReport.exit
  %21 = load ptr, ptr %human_nodename, align 8
  %name44 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 1
  %human_nodename46 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 23
  %22 = load ptr, ptr %human_nodename46, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.72, ptr noundef nonnull %name, ptr noundef %21, ptr noundef nonnull %name44, ptr noundef %22) #33
  br label %if.end48

if.end48:                                         ; preds = %clusterNodeAddFailureReport.exit.thread, %if.end42, %clusterNodeAddFailureReport.exit
  call void @markNodeAsFailingIfNeeded(ptr noundef nonnull %call7.i86)
  br label %if.end66

if.else:                                          ; preds = %if.then31
  %call49 = call i32 @clusterNodeDelFailureReport(ptr noundef nonnull %call7.i86, ptr noundef nonnull %cond), !range !18
  %tobool50 = icmp eq i32 %call49, 0
  %23 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp53 = icmp sgt i32 %23, 1
  %or.cond1 = select i1 %tobool50, i1 true, i1 %cmp53
  br i1 %or.cond1, label %if.end66, label %if.end56

if.end56:                                         ; preds = %if.else
  %24 = load ptr, ptr %human_nodename, align 8
  %name60 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 1
  %human_nodename62 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 23
  %25 = load ptr, ptr %human_nodename62, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.73, ptr noundef nonnull %name, ptr noundef %24, ptr noundef nonnull %name60, ptr noundef %25) #33
  br label %if.end66

if.end66:                                         ; preds = %if.end48, %if.end56, %if.else, %land.lhs.true, %if.then24
  %conv67 = zext i16 %call8 to i32
  %and68 = and i32 %conv67, 12
  %tobool69.not.not = icmp eq i32 %and68, 0
  br i1 %tobool69.not.not, label %land.lhs.true70, label %if.end89

land.lhs.true70:                                  ; preds = %if.end66
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 13
  %26 = load i64, ptr %ping_sent, align 8
  %cmp71 = icmp eq i64 %26, 0
  br i1 %cmp71, label %land.lhs.true73, label %if.end89

land.lhs.true73:                                  ; preds = %land.lhs.true70
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %li.i.i)
  %fail_reports.i.i = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 29
  %27 = load ptr, ptr %fail_reports.i.i, align 8
  %28 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %mul.i.i = shl nsw i64 %28, 1
  %call.i.i = call i64 @mstime() #33
  call void @listRewind(ptr noundef %27, ptr noundef nonnull %li.i.i) #33
  %call13.i.i = call ptr @listNext(ptr noundef nonnull %li.i.i) #33
  %cmp.not4.i.i = icmp eq ptr %call13.i.i, null
  br i1 %cmp.not4.i.i, label %clusterNodeFailureReportsCount.exit, label %while.body.i.i

while.body.i.i:                                   ; preds = %land.lhs.true73, %if.end.i.i
  %call15.i.i = phi ptr [ %call1.i.i, %if.end.i.i ], [ %call13.i.i, %land.lhs.true73 ]
  %value.i.i = getelementptr inbounds %struct.listNode, ptr %call15.i.i, i64 0, i32 2
  %29 = load ptr, ptr %value.i.i, align 8
  %time.i.i = getelementptr inbounds %struct.clusterNodeFailReport, ptr %29, i64 0, i32 1
  %30 = load i64, ptr %time.i.i, align 8
  %sub.i.i = sub nsw i64 %call.i.i, %30
  %cmp2.i.i = icmp sgt i64 %sub.i.i, %mul.i.i
  br i1 %cmp2.i.i, label %if.then.i.i, label %if.end.i.i

if.then.i.i:                                      ; preds = %while.body.i.i
  call void @listDelNode(ptr noundef %27, ptr noundef nonnull %call15.i.i) #33
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i.i, %while.body.i.i
  %call1.i.i = call ptr @listNext(ptr noundef nonnull %li.i.i) #33
  %cmp.not.i.i = icmp eq ptr %call1.i.i, null
  br i1 %cmp.not.i.i, label %clusterNodeFailureReportsCount.exit, label %while.body.i.i, !llvm.loop !30

clusterNodeFailureReportsCount.exit:              ; preds = %if.end.i.i, %land.lhs.true73
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %li.i.i)
  %31 = load ptr, ptr %fail_reports.i.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %31, i64 0, i32 5
  %32 = load i64, ptr %len.i, align 8
  %33 = and i64 %32, 4294967295
  %cmp75 = icmp eq i64 %33, 0
  br i1 %cmp75, label %if.then77, label %if.end89

if.then77:                                        ; preds = %clusterNodeFailureReportsCount.exit
  %pong_received = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 2
  %34 = load i32, ptr %pong_received, align 4
  %call78 = call i32 @ntohl(i32 noundef %34) #36
  %conv79 = zext i32 %call78 to i64
  %mul = mul nuw nsw i64 %conv79, 1000
  %35 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 352), align 8
  %add = add nsw i64 %35, 500
  %cmp80.not = icmp sgt i64 %mul, %add
  br i1 %cmp80.not, label %if.end89, label %land.lhs.true82

land.lhs.true82:                                  ; preds = %if.then77
  %pong_received83 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 14
  %36 = load i64, ptr %pong_received83, align 8
  %cmp84 = icmp sgt i64 %mul, %36
  br i1 %cmp84, label %if.then86, label %if.end89

if.then86:                                        ; preds = %land.lhs.true82
  store i64 %mul, ptr %pong_received83, align 8
  br label %if.end89

if.end89:                                         ; preds = %if.then77, %land.lhs.true82, %if.then86, %clusterNodeFailureReportsCount.exit, %land.lhs.true70, %if.end66
  %flags90 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 3
  %37 = load i32, ptr %flags90, align 8
  %and91 = and i32 %37, 12
  %tobool92.not = icmp eq i32 %and91, 0
  %38 = and i32 %conv67, 76
  %39 = icmp ne i32 %38, 0
  %brmerge = or i1 %39, %tobool92.not
  br i1 %brmerge, label %if.end188, label %land.lhs.true101

land.lhs.true101:                                 ; preds = %if.end89
  %ip102 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 21
  %ip104 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 3
  %call106 = call i32 @strcasecmp(ptr noundef nonnull %ip102, ptr noundef nonnull %ip104) #34
  %tobool107.not = icmp eq i32 %call106, 0
  br i1 %tobool107.not, label %lor.lhs.false, label %if.then141

lor.lhs.false:                                    ; preds = %land.lhs.true101
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 25
  %40 = load i32, ptr %tls_port, align 4
  %41 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool108.not = icmp eq i32 %41, 0
  br i1 %tobool108.not, label %cond.end116, label %cond.end116.thread

cond.end116:                                      ; preds = %lor.lhs.false
  %pport = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 7
  %42 = load i16, ptr %pport, align 4
  %call114 = call zeroext i16 @ntohs(i16 noundef zeroext %42) #36
  %cond117 = zext i16 %call114 to i32
  %cmp118.not = icmp eq i32 %40, %cond117
  br i1 %cmp118.not, label %cond.false126, label %if.then141

cond.end116.thread:                               ; preds = %lor.lhs.false
  %port110 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 4
  %43 = load i16, ptr %port110, align 2
  %call111 = call zeroext i16 @ntohs(i16 noundef zeroext %43) #36
  %cond117116 = zext i16 %call111 to i32
  %cmp118.not117 = icmp eq i32 %40, %cond117116
  br i1 %cmp118.not117, label %cond.true122, label %if.then141

cond.true122:                                     ; preds = %cond.end116.thread
  %pport123 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 7
  br label %cond.end130

cond.false126:                                    ; preds = %cond.end116
  %port127 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 4
  br label %cond.end130

cond.end130:                                      ; preds = %cond.false126, %cond.true122
  %.sink.in = phi ptr [ %port127, %cond.false126 ], [ %pport123, %cond.true122 ]
  %.sink = load i16, ptr %.sink.in, align 2
  %call128 = call zeroext i16 @ntohs(i16 noundef zeroext %.sink) #36
  %.in = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 24
  %44 = load i32, ptr %.in, align 8
  %cond131 = zext i16 %call128 to i32
  %cmp132.not = icmp eq i32 %44, %cond131
  br i1 %cmp132.not, label %lor.lhs.false134, label %if.then141

lor.lhs.false134:                                 ; preds = %cond.end130
  %cport135 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 26
  %45 = load i32, ptr %cport135, align 8
  %cport136 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 5
  %46 = load i16, ptr %cport136, align 4
  %call137 = call zeroext i16 @ntohs(i16 noundef zeroext %46) #36
  %conv138 = zext i16 %call137 to i32
  %cmp139.not = icmp eq i32 %45, %conv138
  br i1 %cmp139.not, label %if.end188, label %if.then141

if.then141:                                       ; preds = %cond.end116.thread, %lor.lhs.false134, %cond.end130, %cond.end116, %land.lhs.true101
  %link142 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 27
  %47 = load ptr, ptr %link142, align 8
  %tobool143.not = icmp eq ptr %47, null
  br i1 %tobool143.not, label %if.end146, label %if.then144

if.then144:                                       ; preds = %if.then141
  call void @freeClusterLink(ptr noundef nonnull %47)
  %.pre = load i32, ptr %flags90, align 8
  br label %if.end146

if.end146:                                        ; preds = %if.then144, %if.then141
  %48 = phi i32 [ %.pre, %if.then144 ], [ %37, %if.then141 ]
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip102, ptr noundef nonnull align 4 dereferenceable(46) %ip104, i64 46, i1 false)
  %tcp_port151 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 24
  store i32 %storemerge.i, ptr %tcp_port151, align 8
  %tls_port152 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 25
  store i32 %msg_tls_port.0, ptr %tls_port152, align 4
  %cport153 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 5
  %49 = load i16, ptr %cport153, align 4
  %call154 = call zeroext i16 @ntohs(i16 noundef zeroext %49) #36
  %conv155 = zext i16 %call154 to i32
  %cport156 = getelementptr inbounds %struct._clusterNode, ptr %call7.i86, i64 0, i32 26
  store i32 %conv155, ptr %cport156, align 8
  %and158 = and i32 %48, -65
  store i32 %and158, ptr %flags90, align 8
  br label %if.end188

if.else160:                                       ; preds = %if.end.i80, %getClientPortFromGossip.exit, %clusterLookupNode.exit87
  br i1 %tobool25.not, label %if.end188, label %land.lhs.true162

land.lhs.true162:                                 ; preds = %if.else160
  %conv163 = zext i16 %call8 to i32
  %and164 = and i32 %conv163, 64
  %tobool165.not = icmp eq i32 %and164, 0
  br i1 %tobool165.not, label %land.lhs.true166, label %if.end188

land.lhs.true166:                                 ; preds = %land.lhs.true162
  %call.i95 = call ptr @sdsnewlen(ptr noundef nonnull %g.0122, i64 noundef 40) #33
  call void @clusterBlacklistCleanup()
  %50 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list.i = getelementptr inbounds %struct.clusterState, ptr %50, i64 0, i32 6
  %51 = load ptr, ptr %nodes_black_list.i, align 8
  %call2.i96 = call ptr @dictFind(ptr noundef %51, ptr noundef %call.i95) #33
  %cmp.i.not = icmp eq ptr %call2.i96, null
  call void @sdsfree(ptr noundef %call.i95) #33
  br i1 %cmp.i.not, label %if.then171, label %if.end188

if.then171:                                       ; preds = %land.lhs.true166
  %call.i98 = call noalias dereferenceable_or_null(2368) ptr @zmalloc(i64 noundef 2368) #37
  %name1.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %name1.i, ptr noundef nonnull align 1 dereferenceable(40) %g.0122, i64 40, i1 false)
  %shard_id.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 2
  call void @getRandomHexChars(ptr noundef nonnull %shard_id.i, i64 noundef 40) #33
  %call4.i101 = call i64 @mstime() #33
  store i64 %call4.i101, ptr %call.i98, align 8
  %configEpoch.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 4
  store i64 0, ptr %configEpoch.i, align 8
  %flags5.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 3
  store i32 %conv163, ptr %flags5.i, align 8
  %slots.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 5
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 10
  %link.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 27
  %ip.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 21
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip.i, i8 0, i64 46, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(2068) %slots.i, i8 0, i64 2068, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(56) %slaves.i, i8 0, i64 56, i1 false)
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %link.i, i8 0, i64 16, i1 false)
  %call8.i = call ptr @sdsempty() #33
  %hostname.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 22
  store ptr %call8.i, ptr %hostname.i, align 8
  %call9.i = call ptr @sdsempty() #33
  %human_nodename.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 23
  store ptr %call9.i, ptr %human_nodename.i, align 8
  %tcp_port.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 24
  store i32 0, ptr %tcp_port.i, align 8
  %cport.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 26
  store i32 0, ptr %cport.i, align 8
  %tls_port.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 25
  store i32 0, ptr %tls_port.i, align 4
  %call10.i = call ptr @listCreate() #33
  %fail_reports.i102 = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 29
  store ptr %call10.i, ptr %fail_reports.i102, align 8
  %voted_time.i = getelementptr inbounds %struct._clusterNode, ptr %call.i98, i64 0, i32 17
  %free.i = getelementptr inbounds %struct.list, ptr %call10.i, i64 0, i32 3
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %voted_time.i, i8 0, i64 32, i1 false)
  store ptr @zfree, ptr %free.i, align 8
  %ip179 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 3
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip.i, ptr noundef nonnull align 4 dereferenceable(46) %ip179, i64 46, i1 false)
  store i32 %storemerge.i, ptr %tcp_port.i, align 8
  store i32 %msg_tls_port.0, ptr %tls_port.i, align 4
  %cport183 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 0, i32 5
  %52 = load i16, ptr %cport183, align 4
  %call184 = call zeroext i16 @ntohs(i16 noundef zeroext %52) #36
  %conv185 = zext i16 %call184 to i32
  store i32 %conv185, ptr %cport.i, align 8
  %53 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i103 = getelementptr inbounds %struct.clusterState, ptr %53, i64 0, i32 4
  %54 = load ptr, ptr %nodes.i103, align 8
  %call.i104 = call ptr @sdsnewlen(ptr noundef nonnull %name1.i, i64 noundef 40) #33
  %call1.i105 = call i32 @dictAdd(ptr noundef %54, ptr noundef %call.i104, ptr noundef nonnull %call.i98) #33
  %cmp.i106 = icmp eq i32 %call1.i105, 0
  br i1 %cmp.i106, label %if.end188, label %cond.false.i

cond.false.i:                                     ; preds = %if.then171
  call void @_serverAssert(ptr noundef nonnull @.str.60, ptr noundef nonnull @.str.18, i32 noundef 1530) #33
  call void @abort() #35
  unreachable

if.end188:                                        ; preds = %if.then171, %if.end89, %if.else160, %land.lhs.true162, %land.lhs.true166, %lor.lhs.false134, %if.end146
  %incdec.ptr = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %g.0122, i64 1
  %tobool6.not = icmp eq i16 %dec123, 0
  br i1 %tobool6.not, label %while.end, label %while.body, !llvm.loop !36

while.end:                                        ; preds = %if.end188, %cond.end
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare zeroext i16 @ntohs(i16 noundef zeroext) local_unnamed_addr #11

; Function Attrs: nounwind uwtable
define dso_local ptr @representClusterNodeFlags(ptr noundef %ci, i16 noundef zeroext %flags) local_unnamed_addr #2 {
entry:
  %arrayidx.i = getelementptr inbounds i8, ptr %ci, i64 -1
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %ci, i64 -3
  %1 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %1 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %ci, i64 -5
  %2 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %2 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %ci, i64 -9
  %3 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %3 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %ci, i64 -17
  %4 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %4, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  br label %for.body

for.body:                                         ; preds = %sdslen.exit, %for.inc
  %indvars.iv = phi i64 [ 0, %sdslen.exit ], [ %indvars.iv.next, %for.inc ]
  %ci.addr.030 = phi ptr [ %ci, %sdslen.exit ], [ %ci.addr.1, %for.inc ]
  %add.ptr = getelementptr inbounds %struct.redisNodeFlags, ptr @redisNodeFlagsTable, i64 %indvars.iv
  %5 = load i16, ptr %add.ptr, align 16
  %and9 = and i16 %5, %flags
  %tobool.not = icmp eq i16 %and9, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %name = getelementptr inbounds %struct.redisNodeFlags, ptr @redisNodeFlagsTable, i64 %indvars.iv, i32 1
  %6 = load ptr, ptr %name, align 8
  %call2 = tail call ptr @sdscat(ptr noundef %ci.addr.030, ptr noundef %6) #33
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  %ci.addr.1 = phi ptr [ %call2, %if.then ], [ %ci.addr.030, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 8
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !37

for.end:                                          ; preds = %for.inc
  %arrayidx.i10 = getelementptr inbounds i8, ptr %ci.addr.1, i64 -1
  %7 = load i8, ptr %arrayidx.i10, align 1
  %conv.i11 = zext i8 %7 to i32
  %and.i12 = and i32 %conv.i11, 7
  switch i32 %and.i12, label %sdslen.exit28 [
    i32 0, label %sw.bb.i25
    i32 1, label %sw.bb3.i22
    i32 2, label %sw.bb5.i19
    i32 3, label %sw.bb9.i16
    i32 4, label %sw.bb13.i13
  ]

sw.bb.i25:                                        ; preds = %for.end
  %shr.i26 = lshr i32 %conv.i11, 3
  %conv2.i27 = zext nneg i32 %shr.i26 to i64
  br label %sdslen.exit28

sw.bb3.i22:                                       ; preds = %for.end
  %add.ptr.i23 = getelementptr inbounds i8, ptr %ci.addr.1, i64 -3
  %8 = load i8, ptr %add.ptr.i23, align 1
  %conv4.i24 = zext i8 %8 to i64
  br label %sdslen.exit28

sw.bb5.i19:                                       ; preds = %for.end
  %add.ptr6.i20 = getelementptr inbounds i8, ptr %ci.addr.1, i64 -5
  %9 = load i16, ptr %add.ptr6.i20, align 1
  %conv8.i21 = zext i16 %9 to i64
  br label %sdslen.exit28

sw.bb9.i16:                                       ; preds = %for.end
  %add.ptr10.i17 = getelementptr inbounds i8, ptr %ci.addr.1, i64 -9
  %10 = load i32, ptr %add.ptr10.i17, align 1
  %conv12.i18 = zext i32 %10 to i64
  br label %sdslen.exit28

sw.bb13.i13:                                      ; preds = %for.end
  %add.ptr14.i14 = getelementptr inbounds i8, ptr %ci.addr.1, i64 -17
  %11 = load i64, ptr %add.ptr14.i14, align 1
  br label %sdslen.exit28

sdslen.exit28:                                    ; preds = %for.end, %sw.bb.i25, %sw.bb3.i22, %sw.bb5.i19, %sw.bb9.i16, %sw.bb13.i13
  %retval.0.i15 = phi i64 [ %11, %sw.bb13.i13 ], [ %conv12.i18, %sw.bb9.i16 ], [ %conv8.i21, %sw.bb5.i19 ], [ %conv4.i24, %sw.bb3.i22 ], [ %conv2.i27, %sw.bb.i25 ], [ 0, %for.end ]
  %cmp4 = icmp eq i64 %retval.0.i15, %retval.0.i
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %sdslen.exit28
  %call7 = tail call ptr @sdscat(ptr noundef nonnull %ci.addr.1, ptr noundef nonnull @.str.145) #33
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %sdslen.exit28
  %ci.addr.2 = phi ptr [ %call7, %if.then6 ], [ %ci.addr.1, %sdslen.exit28 ]
  tail call void @sdsIncrLen(ptr noundef %ci.addr.2, i64 noundef -1) #33
  ret ptr %ci.addr.2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare i32 @ntohl(i32 noundef) local_unnamed_addr #11

; Function Attrs: nounwind uwtable
define dso_local i32 @nodeIp2String(ptr noundef %buf, ptr nocapture noundef readonly %link, ptr nocapture noundef readonly %announced_ip) local_unnamed_addr #2 {
entry:
  %0 = load i8, ptr %announced_ip, align 1
  %cmp.not = icmp eq i8 %0, 0
  br i1 %cmp.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(46) %buf, ptr noundef nonnull align 1 dereferenceable(46) %announced_ip, i64 45, i1 false)
  %arrayidx2 = getelementptr inbounds i8, ptr %buf, i64 45
  store i8 0, ptr %arrayidx2, align 1
  br label %return

if.else:                                          ; preds = %entry
  %conn = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %1 = load ptr, ptr %conn, align 8
  %tobool.not.i.i = icmp eq ptr %1, null
  br i1 %tobool.not.i.i, label %do.body, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.else
  %2 = load ptr, ptr %1, align 8
  %addr.i.i = getelementptr inbounds %struct.ConnectionType, ptr %2, i64 0, i32 6
  %3 = load ptr, ptr %addr.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i.i, label %do.body, label %connAddrPeerName.exit

connAddrPeerName.exit:                            ; preds = %land.lhs.true.i.i
  %call.i.i = tail call i32 %3(ptr noundef nonnull %1, ptr noundef %buf, i64 noundef 46, ptr noundef null, i32 noundef 1) #33
  %cmp3 = icmp eq i32 %call.i.i, -1
  br i1 %cmp3, label %do.body, label %return

do.body:                                          ; preds = %if.else, %land.lhs.true.i.i, %connAddrPeerName.exit
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6 = icmp sgt i32 %4, 2
  br i1 %cmp6, label %return, label %if.end

if.end:                                           ; preds = %do.body
  %5 = load ptr, ptr %conn, align 8
  %tobool.not = icmp eq ptr %5, null
  br i1 %tobool.not, label %cond.end, label %cond.true

cond.true:                                        ; preds = %if.end
  %6 = load ptr, ptr %5, align 8
  %get_last_error.i = getelementptr inbounds %struct.ConnectionType, ptr %6, i64 0, i32 21
  %7 = load ptr, ptr %get_last_error.i, align 8
  %call.i = tail call ptr %7(ptr noundef nonnull %5) #33
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi ptr [ %call.i, %cond.true ], [ @.str.75, %if.end ]
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.74, ptr noundef %cond) #33
  br label %return

return:                                           ; preds = %connAddrPeerName.exit, %cond.end, %do.body, %if.then
  %retval.0 = phi i32 [ 0, %if.then ], [ -1, %do.body ], [ -1, %cond.end ], [ 0, %connAddrPeerName.exit ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @nodeUpdateAddressIfNeeded(ptr noundef %node, ptr noundef readonly %link, ptr nocapture noundef readonly %hdr) local_unnamed_addr #2 {
entry:
  %ip = alloca [46 x i8], align 16
  call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(46) %ip, i8 0, i64 46, i1 false)
  %cport1 = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 16
  %0 = load i16, ptr %cport1, align 8
  %call = tail call zeroext i16 @ntohs(i16 noundef zeroext %0) #36
  %conv = zext i16 %call to i32
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i = icmp eq i32 %1, 0
  br i1 %tobool.not.i, label %if.else.i, label %if.then.i

if.then.i:                                        ; preds = %entry
  %port.i = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 3
  %2 = load i16, ptr %port.i, align 2
  %call.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %2) #36
  %pport.i = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 15
  br label %getClientPortFromClusterMsg.exit

if.else.i:                                        ; preds = %entry
  %pport3.i = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 15
  %3 = load i16, ptr %pport3.i, align 2
  %call4.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %3) #36
  %port6.i = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 3
  br label %getClientPortFromClusterMsg.exit

getClientPortFromClusterMsg.exit:                 ; preds = %if.then.i, %if.else.i
  %tls_port.0.in = phi i16 [ %call4.i, %if.else.i ], [ %call.i, %if.then.i ]
  %port6.sink.i = phi ptr [ %port6.i, %if.else.i ], [ %pport.i, %if.then.i ]
  %tls_port.0 = zext i16 %tls_port.0.in to i32
  %4 = load i16, ptr %port6.sink.i, align 2
  %call7.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %4) #36
  %storemerge.i = zext i16 %call7.i to i32
  %link2 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 27
  %5 = load ptr, ptr %link2, align 8
  %cmp = icmp eq ptr %5, %link
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %getClientPortFromClusterMsg.exit
  %myip = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 12
  %6 = load i8, ptr %myip, align 1
  %cmp.not.i = icmp eq i8 %6, 0
  br i1 %cmp.not.i, label %if.else.i24, label %if.then.i23

if.then.i23:                                      ; preds = %if.end
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(46) %ip, ptr noundef nonnull align 1 dereferenceable(46) %myip, i64 45, i1 false)
  %arrayidx2.i = getelementptr inbounds i8, ptr %ip, i64 45
  store i8 0, ptr %arrayidx2.i, align 1
  br label %if.end9

if.else.i24:                                      ; preds = %if.end
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %7 = load ptr, ptr %conn.i, align 8
  %tobool.not.i.i.i = icmp eq ptr %7, null
  br i1 %tobool.not.i.i.i, label %do.body.i, label %land.lhs.true.i.i.i

land.lhs.true.i.i.i:                              ; preds = %if.else.i24
  %8 = load ptr, ptr %7, align 8
  %addr.i.i.i = getelementptr inbounds %struct.ConnectionType, ptr %8, i64 0, i32 6
  %9 = load ptr, ptr %addr.i.i.i, align 8
  %tobool1.not.i.i.i = icmp eq ptr %9, null
  br i1 %tobool1.not.i.i.i, label %do.body.i, label %connAddrPeerName.exit.i

connAddrPeerName.exit.i:                          ; preds = %land.lhs.true.i.i.i
  %call.i.i.i = call i32 %9(ptr noundef nonnull %7, ptr noundef nonnull %ip, i64 noundef 46, ptr noundef null, i32 noundef 1) #33
  %cmp3.i = icmp eq i32 %call.i.i.i, -1
  br i1 %cmp3.i, label %do.body.i, label %if.end9

do.body.i:                                        ; preds = %connAddrPeerName.exit.i, %land.lhs.true.i.i.i, %if.else.i24
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6.i = icmp sgt i32 %10, 2
  br i1 %cmp6.i, label %return, label %if.end.i

if.end.i:                                         ; preds = %do.body.i
  %11 = load ptr, ptr %conn.i, align 8
  %tobool.not.i25 = icmp eq ptr %11, null
  br i1 %tobool.not.i25, label %cond.end.i, label %cond.true.i

cond.true.i:                                      ; preds = %if.end.i
  %12 = load ptr, ptr %11, align 8
  %get_last_error.i.i = getelementptr inbounds %struct.ConnectionType, ptr %12, i64 0, i32 21
  %13 = load ptr, ptr %get_last_error.i.i, align 8
  %call.i.i = call ptr %13(ptr noundef nonnull %11) #33
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.true.i, %if.end.i
  %cond.i = phi ptr [ %call.i.i, %cond.true.i ], [ @.str.75, %if.end.i ]
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.74, ptr noundef %cond.i) #33
  br label %return

if.end9:                                          ; preds = %connAddrPeerName.exit.i, %if.then.i23
  %tcp_port10 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 24
  %14 = load i32, ptr %tcp_port10, align 8
  %cmp11 = icmp eq i32 %14, %storemerge.i
  br i1 %cmp11, label %land.lhs.true, label %if.end28

land.lhs.true:                                    ; preds = %if.end9
  %cport13 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 26
  %15 = load i32, ptr %cport13, align 8
  %cmp14 = icmp eq i32 %15, %conv
  br i1 %cmp14, label %land.lhs.true16, label %if.end28

land.lhs.true16:                                  ; preds = %land.lhs.true
  %tls_port17 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 25
  %16 = load i32, ptr %tls_port17, align 4
  %cmp18 = icmp eq i32 %16, %tls_port.0
  br i1 %cmp18, label %land.lhs.true20, label %if.end28

land.lhs.true20:                                  ; preds = %land.lhs.true16
  %ip22 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 21
  %call24 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %ip, ptr noundef nonnull dereferenceable(1) %ip22) #34
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %return, label %if.end28

if.end28:                                         ; preds = %land.lhs.true20, %land.lhs.true16, %land.lhs.true, %if.end9
  %ip29 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 21
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip29, ptr noundef nonnull align 16 dereferenceable(46) %ip, i64 46, i1 false)
  store i32 %storemerge.i, ptr %tcp_port10, align 8
  %tls_port33 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 25
  store i32 %tls_port.0, ptr %tls_port33, align 4
  %cport34 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 26
  store i32 %conv, ptr %cport34, align 8
  %17 = load ptr, ptr %link2, align 8
  %tobool.not = icmp eq ptr %17, null
  br i1 %tobool.not, label %if.end38, label %if.then36

if.then36:                                        ; preds = %if.end28
  call void @freeClusterLink(ptr noundef nonnull %17)
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end28
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %18 = load i32, ptr %flags, align 8
  %and = and i32 %18, -65
  store i32 %and, ptr %flags, align 8
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp39 = icmp sgt i32 %19, 2
  br i1 %cmp39, label %do.end, label %if.end42

if.end42:                                         ; preds = %if.end38
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %20 = load ptr, ptr %human_nodename, align 8
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i26 = icmp eq i32 %21, 0
  %cond.in.i = select i1 %tobool.not.i26, ptr %tcp_port10, ptr %tls_port33
  %cond.i27 = load i32, ptr %cond.in.i, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.76, ptr noundef nonnull %name, ptr noundef %20, ptr noundef nonnull %ip29, i32 noundef %cond.i27) #33
  br label %do.end

do.end:                                           ; preds = %if.end38, %if.end42
  %22 = load ptr, ptr @myself, align 8
  %flags47 = getelementptr inbounds %struct._clusterNode, ptr %22, i64 0, i32 3
  %23 = load i32, ptr %flags47, align 8
  %and48 = and i32 %23, 2
  %tobool49.not = icmp eq i32 %and48, 0
  br i1 %tobool49.not, label %return, label %land.lhs.true50

land.lhs.true50:                                  ; preds = %do.end
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %22, i64 0, i32 11
  %24 = load ptr, ptr %slaveof, align 8
  %cmp51 = icmp eq ptr %24, %node
  br i1 %cmp51, label %if.then53, label %return

if.then53:                                        ; preds = %land.lhs.true50
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 403), align 4
  %tobool.not.i28 = icmp eq i32 %25, 0
  %cond.in.i31 = select i1 %tobool.not.i28, ptr %tcp_port10, ptr %tls_port33
  %cond.i32 = load i32, ptr %cond.in.i31, align 4
  call void @replicationSetMaster(ptr noundef nonnull %ip29, i32 noundef %cond.i32) #33
  br label %return

return:                                           ; preds = %cond.end.i, %do.body.i, %do.end, %land.lhs.true50, %if.then53, %land.lhs.true20, %getClientPortFromClusterMsg.exit
  %retval.0 = phi i32 [ 0, %getClientPortFromClusterMsg.exit ], [ 0, %land.lhs.true20 ], [ 1, %if.then53 ], [ 1, %land.lhs.true50 ], [ 1, %do.end ], [ 0, %do.body.i ], [ 0, %cond.end.i ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define internal fastcc void @getClientPortFromClusterMsg(ptr nocapture noundef readonly %hdr, ptr nocapture noundef writeonly %tls_port, ptr nocapture noundef writeonly %tcp_port) unnamed_addr #25 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %port = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 3
  %1 = load i16, ptr %port, align 2
  %call = tail call zeroext i16 @ntohs(i16 noundef zeroext %1) #36
  %conv = zext i16 %call to i32
  store i32 %conv, ptr %tls_port, align 4
  %pport = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 15
  br label %if.end

if.else:                                          ; preds = %entry
  %pport3 = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 15
  %2 = load i16, ptr %pport3, align 2
  %call4 = tail call zeroext i16 @ntohs(i16 noundef zeroext %2) #36
  %conv5 = zext i16 %call4 to i32
  store i32 %conv5, ptr %tls_port, align 4
  %port6 = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 3
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %port6.sink = phi ptr [ %port6, %if.else ], [ %pport, %if.then ]
  %3 = load i16, ptr %port6.sink, align 2
  %call7 = tail call zeroext i16 @ntohs(i16 noundef zeroext %3) #36
  %storemerge = zext i16 %call7 to i32
  store i32 %storemerge, ptr %tcp_port, align 4
  ret void
}

declare void @replicationSetMaster(ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateSlotsConfigWith(ptr noundef %sender, i64 noundef %senderConfigEpoch, ptr nocapture noundef readonly %slots) local_unnamed_addr #2 {
entry:
  %dirty_slots = alloca [16384 x i16], align 16
  %0 = load ptr, ptr @myself, align 8
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 3
  %1 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %1, 1
  %tobool.not = icmp eq i32 %and.i, 0
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 11
  %cond.in = select i1 %tobool.not, ptr %slaveof, ptr @myself
  %cond = load ptr, ptr %cond.in, align 8
  %cmp = icmp eq ptr %0, %sender
  br i1 %cmp, label %do.body, label %for.body

do.body:                                          ; preds = %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1 = icmp sgt i32 %2, 2
  br i1 %cmp1, label %if.end130, label %if.end

if.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.77) #33
  br label %if.end130

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %migrated_our_slots.078 = phi i32 [ %migrated_our_slots.2, %for.inc ], [ 0, %entry ]
  %sender_slots.077 = phi i32 [ %sender_slots.1, %for.inc ], [ 0, %entry ]
  %dirty_slots_count.076 = phi i32 [ %dirty_slots_count.2, %for.inc ], [ 0, %entry ]
  %newmaster.075 = phi ptr [ %newmaster.2, %for.inc ], [ null, %entry ]
  %3 = trunc i64 %indvars.iv to i32
  %div.i666768 = lshr i64 %indvars.iv, 3
  %conv.i = and i64 %div.i666768, 536870911
  %and.i39 = and i32 %3, 7
  %arrayidx.i = getelementptr inbounds i8, ptr %slots, i64 %conv.i
  %4 = load i8, ptr %arrayidx.i, align 1
  %conv1.i = zext i8 %4 to i32
  %5 = shl nuw nsw i32 1, %and.i39
  %6 = and i32 %5, %conv1.i
  %tobool6.not = icmp eq i32 %6, 0
  br i1 %tobool6.not, label %if.else, label %if.then7

if.then7:                                         ; preds = %for.body
  %inc = add nsw i32 %sender_slots.077, 1
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 9, i64 %indvars.iv
  %8 = load ptr, ptr %arrayidx, align 8
  %cmp9 = icmp eq ptr %8, %sender
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then7
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 27
  %arrayidx.i43 = getelementptr inbounds i8, ptr %owner_not_claiming_slot, i64 %conv.i
  %9 = load i8, ptr %arrayidx.i43, align 1
  %10 = trunc i32 %5 to i8
  %11 = xor i8 %10, -1
  %conv3.i44 = and i8 %9, %11
  store i8 %conv3.i44, ptr %arrayidx.i43, align 1
  br label %for.inc

if.end11:                                         ; preds = %if.then7
  %arrayidx13 = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 8, i64 %indvars.iv
  %12 = load ptr, ptr %arrayidx13, align 8
  %tobool14.not = icmp eq ptr %12, null
  br i1 %tobool14.not, label %if.end16, label %for.inc

if.end16:                                         ; preds = %if.end11
  %cmp20 = icmp eq ptr %8, null
  br i1 %cmp20, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end16
  %owner_not_claiming_slot21 = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 27
  %arrayidx.i48 = getelementptr inbounds i8, ptr %owner_not_claiming_slot21, i64 %conv.i
  %13 = load i8, ptr %arrayidx.i48, align 1
  %conv1.i49 = zext i8 %13 to i32
  %14 = and i32 %5, %conv1.i49
  %tobool24.not = icmp eq i32 %14, 0
  br i1 %tobool24.not, label %lor.lhs.false25, label %if.then30

lor.lhs.false25:                                  ; preds = %lor.lhs.false
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %8, i64 0, i32 4
  %15 = load i64, ptr %configEpoch, align 8
  %cmp29 = icmp ult i64 %15, %senderConfigEpoch
  br i1 %cmp29, label %if.then30, label %for.inc

if.then30:                                        ; preds = %lor.lhs.false25, %lor.lhs.false, %if.end16
  %16 = load ptr, ptr @myself, align 8
  %cmp34 = icmp eq ptr %8, %16
  br i1 %cmp34, label %land.lhs.true, label %if.end43

land.lhs.true:                                    ; preds = %if.then30
  %call35 = tail call i32 @countKeysInSlot(i32 noundef %3) #33
  %tobool36.not = icmp eq i32 %call35, 0
  %17 = load ptr, ptr @myself, align 8
  %cmp38.not = icmp eq ptr %17, %sender
  %or.cond = select i1 %tobool36.not, i1 true, i1 %cmp38.not
  br i1 %or.cond, label %if.end43, label %if.then39

if.then39:                                        ; preds = %land.lhs.true
  %conv = trunc i64 %indvars.iv to i16
  %idxprom40 = sext i32 %dirty_slots_count.076 to i64
  %arrayidx41 = getelementptr inbounds [16384 x i16], ptr %dirty_slots, i64 0, i64 %idxprom40
  store i16 %conv, ptr %arrayidx41, align 2
  %inc42 = add nsw i32 %dirty_slots_count.076, 1
  br label %if.end43

if.end43:                                         ; preds = %if.then39, %land.lhs.true, %if.then30
  %dirty_slots_count.1 = phi i32 [ %inc42, %if.then39 ], [ %dirty_slots_count.076, %land.lhs.true ], [ %dirty_slots_count.076, %if.then30 ]
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx46 = getelementptr inbounds %struct.clusterState, ptr %18, i64 0, i32 9, i64 %indvars.iv
  %19 = load ptr, ptr %arrayidx46, align 8
  %cmp47 = icmp eq ptr %19, %cond
  %spec.select = select i1 %cmp47, ptr %sender, ptr %newmaster.075
  %inc50 = zext i1 %cmp47 to i32
  %spec.select36 = add nsw i32 %migrated_our_slots.078, %inc50
  %tobool.not.i = icmp eq ptr %19, null
  br i1 %tobool.not.i, label %if.end.i56, label %if.end.i

if.end.i:                                         ; preds = %if.end43
  tail call void @removeChannelsInSlot(i32 noundef %3)
  %slots.i.i = getelementptr inbounds %struct._clusterNode, ptr %19, i64 0, i32 5
  %arrayidx.i.i.i = getelementptr inbounds i8, ptr %slots.i.i, i64 %conv.i
  %20 = load i8, ptr %arrayidx.i.i.i, align 1
  %conv1.i.i.i = zext i8 %20 to i32
  %21 = and i32 %5, %conv1.i.i.i
  %tobool.not.i.i = icmp eq i32 %21, 0
  br i1 %tobool.not.i.i, label %cond.false.i, label %clusterDelSlot.exit

cond.false.i:                                     ; preds = %if.end.i
  tail call void @_serverAssert(ptr noundef nonnull @.str.138, ptr noundef nonnull @.str.18, i32 noundef 4866) #33
  tail call void @abort() #35
  unreachable

clusterDelSlot.exit:                              ; preds = %if.end.i
  %22 = trunc i32 %5 to i8
  %23 = xor i8 %22, -1
  %conv3.i9.i.i = and i8 %20, %23
  store i8 %conv3.i9.i.i, ptr %arrayidx.i.i.i, align 1
  %numslots.i.i = getelementptr inbounds %struct._clusterNode, ptr %19, i64 0, i32 8
  %24 = load i32, ptr %numslots.i.i, align 4
  %dec.i.i = add nsw i32 %24, -1
  store i32 %dec.i.i, ptr %numslots.i.i, align 4
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5.i = getelementptr inbounds %struct.clusterState, ptr %25, i64 0, i32 9, i64 %indvars.iv
  store ptr null, ptr %arrayidx5.i, align 8
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot.i = getelementptr inbounds %struct.clusterState, ptr %26, i64 0, i32 27
  %arrayidx.i.i = getelementptr inbounds i8, ptr %owner_not_claiming_slot.i, i64 %conv.i
  %27 = load i8, ptr %arrayidx.i.i, align 1
  %conv3.i.i = and i8 %27, %23
  store i8 %conv3.i.i, ptr %arrayidx.i.i, align 1
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx.i53.phi.trans.insert = getelementptr inbounds %struct.clusterState, ptr %.pre, i64 0, i32 9, i64 %indvars.iv
  %.pre87 = load ptr, ptr %arrayidx.i53.phi.trans.insert, align 8
  %tobool.not.i54 = icmp eq ptr %.pre87, null
  br i1 %tobool.not.i54, label %if.end.i56, label %clusterAddSlot.exit

if.end.i56:                                       ; preds = %if.end43, %clusterDelSlot.exit
  %call.i = tail call i32 @clusterNodeSetSlotBit(ptr noundef %sender, i32 noundef %3), !range !18
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx3.i = getelementptr inbounds %struct.clusterState, ptr %28, i64 0, i32 9, i64 %indvars.iv
  store ptr %sender, ptr %arrayidx3.i, align 8
  %.pre88 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %clusterAddSlot.exit

clusterAddSlot.exit:                              ; preds = %clusterDelSlot.exit, %if.end.i56
  %29 = phi ptr [ %.pre, %clusterDelSlot.exit ], [ %.pre88, %if.end.i56 ]
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %29, i64 0, i32 22
  %30 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %30, 14
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %for.inc

if.else:                                          ; preds = %for.body
  %31 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx57 = getelementptr inbounds %struct.clusterState, ptr %31, i64 0, i32 9, i64 %indvars.iv
  %32 = load ptr, ptr %arrayidx57, align 8
  %cmp58 = icmp eq ptr %32, %sender
  br i1 %cmp58, label %if.then60, label %for.inc

if.then60:                                        ; preds = %if.else
  %owner_not_claiming_slot61 = getelementptr inbounds %struct.clusterState, ptr %31, i64 0, i32 27
  %arrayidx.i61 = getelementptr inbounds i8, ptr %owner_not_claiming_slot61, i64 %conv.i
  %33 = load i8, ptr %arrayidx.i61, align 1
  %34 = trunc i32 %5 to i8
  %conv2.i = or i8 %33, %34
  store i8 %conv2.i, ptr %arrayidx.i61, align 1
  br label %for.inc

for.inc:                                          ; preds = %clusterAddSlot.exit, %lor.lhs.false25, %if.then60, %if.else, %if.end11, %if.then10
  %newmaster.2 = phi ptr [ %newmaster.075, %if.then10 ], [ %newmaster.075, %if.end11 ], [ %spec.select, %clusterAddSlot.exit ], [ %newmaster.075, %lor.lhs.false25 ], [ %newmaster.075, %if.then60 ], [ %newmaster.075, %if.else ]
  %dirty_slots_count.2 = phi i32 [ %dirty_slots_count.076, %if.then10 ], [ %dirty_slots_count.076, %if.end11 ], [ %dirty_slots_count.1, %clusterAddSlot.exit ], [ %dirty_slots_count.076, %lor.lhs.false25 ], [ %dirty_slots_count.076, %if.then60 ], [ %dirty_slots_count.076, %if.else ]
  %sender_slots.1 = phi i32 [ %inc, %if.then10 ], [ %inc, %if.end11 ], [ %inc, %clusterAddSlot.exit ], [ %inc, %lor.lhs.false25 ], [ %sender_slots.077, %if.then60 ], [ %sender_slots.077, %if.else ]
  %migrated_our_slots.2 = phi i32 [ %migrated_our_slots.078, %if.then10 ], [ %migrated_our_slots.078, %if.end11 ], [ %spec.select36, %clusterAddSlot.exit ], [ %migrated_our_slots.078, %lor.lhs.false25 ], [ %migrated_our_slots.078, %if.then60 ], [ %migrated_our_slots.078, %if.else ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !38

for.end:                                          ; preds = %for.inc
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  %and = and i32 %35, 4
  %tobool66.not = icmp eq i32 %and, 0
  br i1 %tobool66.not, label %if.end68, label %if.end130

if.end68:                                         ; preds = %for.end
  %tobool69.not = icmp eq ptr %newmaster.2, null
  br i1 %tobool69.not, label %if.else86, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %if.end68
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %cond, i64 0, i32 8
  %36 = load i32, ptr %numslots, align 4
  %cmp71 = icmp eq i32 %36, 0
  br i1 %cmp71, label %land.lhs.true73, label %if.else86

land.lhs.true73:                                  ; preds = %land.lhs.true70
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 369), align 4
  %tobool74.not = icmp ne i32 %37, 0
  %cmp76 = icmp eq i32 %sender_slots.1, %migrated_our_slots.2
  %or.cond37 = select i1 %tobool74.not, i1 true, i1 %cmp76
  br i1 %or.cond37, label %do.body79, label %if.else86

do.body79:                                        ; preds = %land.lhs.true73
  %38 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp80 = icmp sgt i32 %38, 2
  br i1 %cmp80, label %do.end85, label %if.end83

if.end83:                                         ; preds = %do.body79
  %name = getelementptr inbounds %struct._clusterNode, ptr %sender, i64 0, i32 1
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %sender, i64 0, i32 23
  %39 = load ptr, ptr %human_nodename, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.78, ptr noundef nonnull %name, ptr noundef %39) #33
  br label %do.end85

do.end85:                                         ; preds = %do.body79, %if.end83
  tail call void @clusterSetMaster(ptr noundef %sender)
  %40 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i62 = getelementptr inbounds %struct.clusterState, ptr %40, i64 0, i32 22
  %41 = load i32, ptr %todo_before_sleep.i62, align 8
  %or.i63 = or i32 %41, 14
  store i32 %or.i63, ptr %todo_before_sleep.i62, align 8
  br label %if.end130

if.else86:                                        ; preds = %land.lhs.true73, %land.lhs.true70, %if.end68
  %42 = load ptr, ptr @myself, align 8
  %slaveof87 = getelementptr inbounds %struct._clusterNode, ptr %42, i64 0, i32 11
  %43 = load ptr, ptr %slaveof87, align 8
  %tobool88.not = icmp eq ptr %43, null
  br i1 %tobool88.not, label %if.else114, label %land.lhs.true89

land.lhs.true89:                                  ; preds = %if.else86
  %slaveof91 = getelementptr inbounds %struct._clusterNode, ptr %43, i64 0, i32 11
  %44 = load ptr, ptr %slaveof91, align 8
  %tobool92.not = icmp eq ptr %44, null
  %cmp96.not = icmp eq ptr %44, %42
  %or.cond38 = or i1 %tobool92.not, %cmp96.not
  br i1 %or.cond38, label %if.else114, label %do.body99

do.body99:                                        ; preds = %land.lhs.true89
  %45 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp100 = icmp sgt i32 %45, 2
  br i1 %cmp100, label %do.end111, label %if.end103

if.end103:                                        ; preds = %do.body99
  %name106 = getelementptr inbounds %struct._clusterNode, ptr %44, i64 0, i32 1
  %human_nodename110 = getelementptr inbounds %struct._clusterNode, ptr %44, i64 0, i32 23
  %46 = load ptr, ptr %human_nodename110, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.79, ptr noundef nonnull %name106, ptr noundef %46) #33
  %.pre89 = load ptr, ptr @myself, align 8
  %slaveof112.phi.trans.insert = getelementptr inbounds %struct._clusterNode, ptr %.pre89, i64 0, i32 11
  %.pre90 = load ptr, ptr %slaveof112.phi.trans.insert, align 8
  %slaveof113.phi.trans.insert = getelementptr inbounds %struct._clusterNode, ptr %.pre90, i64 0, i32 11
  %.pre91 = load ptr, ptr %slaveof113.phi.trans.insert, align 8
  br label %do.end111

do.end111:                                        ; preds = %do.body99, %if.end103
  %47 = phi ptr [ %44, %do.body99 ], [ %.pre91, %if.end103 ]
  tail call void @clusterSetMaster(ptr noundef %47)
  %48 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i64 = getelementptr inbounds %struct.clusterState, ptr %48, i64 0, i32 22
  %49 = load i32, ptr %todo_before_sleep.i64, align 8
  %or.i65 = or i32 %49, 14
  store i32 %or.i65, ptr %todo_before_sleep.i64, align 8
  br label %if.end130

if.else114:                                       ; preds = %land.lhs.true89, %if.else86
  %cmp11879 = icmp sgt i32 %dirty_slots_count.2, 0
  br i1 %cmp11879, label %for.body120.preheader, label %if.end130

for.body120.preheader:                            ; preds = %if.else114
  %wide.trip.count = zext nneg i32 %dirty_slots_count.2 to i64
  br label %for.body120

for.body120:                                      ; preds = %for.body120.preheader, %for.body120
  %indvars.iv83 = phi i64 [ 0, %for.body120.preheader ], [ %indvars.iv.next84, %for.body120 ]
  %arrayidx122 = getelementptr inbounds [16384 x i16], ptr %dirty_slots, i64 0, i64 %indvars.iv83
  %50 = load i16, ptr %arrayidx122, align 2
  %conv123 = zext i16 %50 to i32
  %call124 = tail call i32 @delKeysInSlot(i32 noundef %conv123)
  %indvars.iv.next84 = add nuw nsw i64 %indvars.iv83, 1
  %exitcond86.not = icmp eq i64 %indvars.iv.next84, %wide.trip.count
  br i1 %exitcond86.not, label %if.end130, label %for.body120, !llvm.loop !39

if.end130:                                        ; preds = %for.body120, %do.end111, %if.else114, %for.end, %if.end, %do.body, %do.end85
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @bitmapTestBit(ptr nocapture noundef readonly %bitmap, i32 noundef %pos) local_unnamed_addr #5 {
entry:
  %div = sdiv i32 %pos, 8
  %conv = sext i32 %div to i64
  %and = and i32 %pos, 7
  %arrayidx = getelementptr inbounds i8, ptr %bitmap, i64 %conv
  %0 = load i8, ptr %arrayidx, align 1
  %conv1 = zext i8 %0 to i32
  %1 = lshr i32 %conv1, %and
  %conv3 = and i32 %1, 1
  ret i32 %conv3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local void @bitmapClearBit(ptr nocapture noundef %bitmap, i32 noundef %pos) local_unnamed_addr #26 {
entry:
  %div = sdiv i32 %pos, 8
  %conv = sext i32 %div to i64
  %and = and i32 %pos, 7
  %shl = shl nuw nsw i32 1, %and
  %arrayidx = getelementptr inbounds i8, ptr %bitmap, i64 %conv
  %0 = load i8, ptr %arrayidx, align 1
  %1 = trunc i32 %shl to i8
  %2 = xor i8 %1, -1
  %conv3 = and i8 %0, %2
  store i8 %conv3, ptr %arrayidx, align 1
  ret void
}

declare i32 @countKeysInSlot(i32 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local void @bitmapSetBit(ptr nocapture noundef %bitmap, i32 noundef %pos) local_unnamed_addr #26 {
entry:
  %div = sdiv i32 %pos, 8
  %conv = sext i32 %div to i64
  %and = and i32 %pos, 7
  %shl = shl nuw nsw i32 1, %and
  %arrayidx = getelementptr inbounds i8, ptr %bitmap, i64 %conv
  %0 = load i8, ptr %arrayidx, align 1
  %1 = trunc i32 %shl to i8
  %conv2 = or i8 %0, %1
  store i8 %conv2, ptr %arrayidx, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSetMaster(ptr noundef %n) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %cmp.not = icmp eq ptr %0, %n
  br i1 %cmp.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.143, ptr noundef nonnull @.str.18, i32 noundef 5094) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 8
  %1 = load i32, ptr %numslots, align 4
  %cmp2 = icmp eq i32 %1, 0
  br i1 %cmp2, label %cond.end12, label %cond.false11

cond.false11:                                     ; preds = %cond.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.144, ptr noundef nonnull @.str.18, i32 noundef 5095) #33
  tail call void @abort() #35
  unreachable

cond.end12:                                       ; preds = %cond.end
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 3
  %2 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %2, 1
  %tobool13.not = icmp eq i32 %and.i, 0
  br i1 %tobool13.not, label %if.else, label %if.then

if.then:                                          ; preds = %cond.end12
  %and = and i32 %2, -260
  %or = or disjoint i32 %and, 2
  store i32 %or, ptr %flags.i, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %migrating_slots_to.i = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 7
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %migrating_slots_to.i, i8 0, i64 131072, i1 false)
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %importing_slots_from.i = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(131072) %importing_slots_from.i, i8 0, i64 131072, i1 false)
  br label %if.end19

if.else:                                          ; preds = %cond.end12
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 11
  %5 = load ptr, ptr %slaveof, align 8
  %tobool15.not = icmp eq ptr %5, null
  br i1 %tobool15.not, label %if.end19, label %if.then16

if.then16:                                        ; preds = %if.else
  %numslaves.i = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 9
  %6 = load i32, ptr %numslaves.i, align 8
  %cmp19.i = icmp sgt i32 %6, 0
  br i1 %cmp19.i, label %for.body.lr.ph.i, label %if.end19

for.body.lr.ph.i:                                 ; preds = %if.then16
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 10
  %7 = load ptr, ptr %slaves.i, align 8
  %wide.trip.count.i = zext nneg i32 %6 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.inc.i ]
  %arrayidx.i = getelementptr inbounds ptr, ptr %7, i64 %indvars.iv.i
  %8 = load ptr, ptr %arrayidx.i, align 8
  %cmp1.i = icmp eq ptr %8, %0
  br i1 %cmp1.i, label %if.then.i, label %for.inc.i

if.then.i:                                        ; preds = %for.body.i
  %9 = trunc i64 %indvars.iv.i to i32
  %add.i = add nuw nsw i32 %9, 1
  %cmp3.i = icmp slt i32 %add.i, %6
  br i1 %cmp3.i, label %if.then4.i, label %if.end.i

if.then4.i:                                       ; preds = %if.then.i
  %arrayidx.i.le = getelementptr inbounds ptr, ptr %7, i64 %indvars.iv.i
  %10 = xor i32 %9, -1
  %sub6.i = add nsw i32 %6, %10
  %idx.ext10.i = zext nneg i32 %add.i to i64
  %add.ptr11.i = getelementptr inbounds ptr, ptr %7, i64 %idx.ext10.i
  %conv.i = sext i32 %sub6.i to i64
  %mul.i = shl nsw i64 %conv.i, 3
  tail call void @llvm.memmove.p0.p0.i64(ptr nonnull align 8 %arrayidx.i.le, ptr nonnull align 8 %add.ptr11.i, i64 %mul.i, i1 false)
  %.pre.i = load i32, ptr %numslaves.i, align 8
  br label %if.end.i

if.end.i:                                         ; preds = %if.then4.i, %if.then.i
  %11 = phi i32 [ %.pre.i, %if.then4.i ], [ %6, %if.then.i ]
  %dec.i = add nsw i32 %11, -1
  store i32 %dec.i, ptr %numslaves.i, align 8
  %cmp14.i = icmp eq i32 %dec.i, 0
  br i1 %cmp14.i, label %if.then16.i, label %if.end19

if.then16.i:                                      ; preds = %if.end.i
  %flags.i7 = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 3
  %12 = load i32, ptr %flags.i7, align 8
  %and.i8 = and i32 %12, -257
  store i32 %and.i8, ptr %flags.i7, align 8
  br label %if.end19

for.inc.i:                                        ; preds = %for.body.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end19, label %for.body.i, !llvm.loop !24

if.end19:                                         ; preds = %for.inc.i, %if.then16.i, %if.end.i, %if.then16, %if.else, %if.then
  %13 = load ptr, ptr @myself, align 8
  %slaveof20 = getelementptr inbounds %struct._clusterNode, ptr %13, i64 0, i32 11
  store ptr %n, ptr %slaveof20, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 2
  tail call fastcc void @updateShardId(ptr noundef %13, ptr noundef nonnull %shard_id)
  %14 = load ptr, ptr @myself, align 8
  %numslaves.i9 = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 9
  %15 = load i32, ptr %numslaves.i9, align 8
  %cmp14.i10 = icmp sgt i32 %15, 0
  %slaves.i11 = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 10
  %16 = load ptr, ptr %slaves.i11, align 8
  br i1 %cmp14.i10, label %for.body.lr.ph.i17, label %for.end.i

for.body.lr.ph.i17:                               ; preds = %if.end19
  %wide.trip.count.i18 = zext nneg i32 %15 to i64
  br label %for.body.i19

for.cond.i:                                       ; preds = %for.body.i19
  %indvars.iv.next.i23 = add nuw nsw i64 %indvars.iv.i20, 1
  %exitcond.not.i24 = icmp eq i64 %indvars.iv.next.i23, %wide.trip.count.i18
  br i1 %exitcond.not.i24, label %for.end.i, label %for.body.i19, !llvm.loop !13

for.body.i19:                                     ; preds = %for.cond.i, %for.body.lr.ph.i17
  %indvars.iv.i20 = phi i64 [ 0, %for.body.lr.ph.i17 ], [ %indvars.iv.next.i23, %for.cond.i ]
  %arrayidx.i21 = getelementptr inbounds ptr, ptr %16, i64 %indvars.iv.i20
  %17 = load ptr, ptr %arrayidx.i21, align 8
  %cmp1.i22 = icmp eq ptr %17, %14
  br i1 %cmp1.i22, label %clusterNodeAddSlave.exit, label %for.cond.i

for.end.i:                                        ; preds = %for.cond.i, %if.end19
  %add.i12 = add nsw i32 %15, 1
  %conv.i13 = sext i32 %add.i12 to i64
  %mul.i14 = shl nsw i64 %conv.i13, 3
  %call.i = tail call ptr @zrealloc(ptr noundef %16, i64 noundef %mul.i14) #38
  store ptr %call.i, ptr %slaves.i11, align 8
  %18 = load i32, ptr %numslaves.i9, align 8
  %idxprom7.i = sext i32 %18 to i64
  %arrayidx8.i = getelementptr inbounds ptr, ptr %call.i, i64 %idxprom7.i
  store ptr %14, ptr %arrayidx8.i, align 8
  %19 = load i32, ptr %numslaves.i9, align 8
  %inc10.i = add nsw i32 %19, 1
  store i32 %inc10.i, ptr %numslaves.i9, align 8
  %flags.i15 = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 3
  %20 = load i32, ptr %flags.i15, align 8
  %or.i = or i32 %20, 256
  store i32 %or.i, ptr %flags.i15, align 8
  br label %clusterNodeAddSlave.exit

clusterNodeAddSlave.exit:                         ; preds = %for.body.i19, %for.end.i
  %ip = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 21
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 403), align 4
  %tobool.not.i = icmp eq i32 %21, 0
  %tls_port.i = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 25
  %tcp_port.i = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 24
  %cond.in.i = select i1 %tobool.not.i, ptr %tcp_port.i, ptr %tls_port.i
  %cond.i = load i32, ptr %cond.in.i, align 4
  tail call void @replicationSetMaster(ptr noundef nonnull %ip, i32 noundef %cond.i) #33
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 360), align 8
  %ht_used.i = getelementptr inbounds %struct.dict, ptr %22, i64 0, i32 2
  %23 = load i64, ptr %ht_used.i, align 8
  %arrayidx2.i = getelementptr inbounds %struct.dict, ptr %22, i64 0, i32 2, i64 1
  %24 = load i64, ptr %arrayidx2.i, align 8
  %add.i25 = sub i64 0, %24
  %tobool.not.i26 = icmp eq i64 %23, %add.i25
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br i1 %tobool.not.i26, label %removeAllNotOwnedShardChannelSubscriptions.exit, label %if.end.i27

if.end.i27:                                       ; preds = %clusterNodeAddSlave.exit
  %25 = load ptr, ptr @myself, align 8
  %flags.i.i = getelementptr inbounds %struct._clusterNode, ptr %25, i64 0, i32 3
  %26 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %26, 1
  %tobool3.not.i = icmp eq i32 %and.i.i, 0
  %slaveof.i = getelementptr inbounds %struct._clusterNode, ptr %25, i64 0, i32 11
  %cond.in.i28 = select i1 %tobool3.not.i, ptr %slaveof.i, ptr @myself
  %cond.i29 = load ptr, ptr %cond.in.i28, align 8
  br label %for.body.i30

for.body.i30:                                     ; preds = %for.inc.i33, %if.end.i27
  %27 = phi ptr [ %.pre, %if.end.i27 ], [ %30, %for.inc.i33 ]
  %indvars.iv.i31 = phi i64 [ 0, %if.end.i27 ], [ %indvars.iv.next.i34, %for.inc.i33 ]
  %arrayidx4.i = getelementptr inbounds %struct.clusterState, ptr %27, i64 0, i32 9, i64 %indvars.iv.i31
  %28 = load ptr, ptr %arrayidx4.i, align 8
  %cmp5.not.i = icmp eq ptr %28, %cond.i29
  br i1 %cmp5.not.i, label %for.inc.i33, label %if.then6.i

if.then6.i:                                       ; preds = %for.body.i30
  %29 = trunc i64 %indvars.iv.i31 to i32
  tail call void @removeChannelsInSlot(i32 noundef %29)
  %.pre.i32 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %for.inc.i33

for.inc.i33:                                      ; preds = %if.then6.i, %for.body.i30
  %30 = phi ptr [ %27, %for.body.i30 ], [ %.pre.i32, %if.then6.i ]
  %indvars.iv.next.i34 = add nuw nsw i64 %indvars.iv.i31, 1
  %exitcond.not.i35 = icmp eq i64 %indvars.iv.next.i34, 16384
  br i1 %exitcond.not.i35, label %removeAllNotOwnedShardChannelSubscriptions.exit, label %for.body.i30, !llvm.loop !40

removeAllNotOwnedShardChannelSubscriptions.exit:  ; preds = %for.inc.i33, %clusterNodeAddSlave.exit
  %31 = phi ptr [ %.pre, %clusterNodeAddSlave.exit ], [ %30, %for.inc.i33 ]
  %mf_slave.i = getelementptr inbounds %struct.clusterState, ptr %31, i64 0, i32 18
  %32 = load ptr, ptr %mf_slave.i, align 8
  %tobool.not.i37 = icmp eq ptr %32, null
  br i1 %tobool.not.i37, label %resetManualFailover.exit, label %if.then.i38

if.then.i38:                                      ; preds = %removeAllNotOwnedShardChannelSubscriptions.exit
  tail call void @unpauseActions(i32 noundef 2) #33
  %.pre.i39 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %resetManualFailover.exit

resetManualFailover.exit:                         ; preds = %removeAllNotOwnedShardChannelSubscriptions.exit, %if.then.i38
  %33 = phi ptr [ %.pre.i39, %if.then.i38 ], [ %31, %removeAllNotOwnedShardChannelSubscriptions.exit ]
  %mf_end.i = getelementptr inbounds %struct.clusterState, ptr %33, i64 0, i32 17
  %mf_can_start.i = getelementptr inbounds %struct.clusterState, ptr %33, i64 0, i32 20
  store i32 0, ptr %mf_can_start.i, align 8
  %mf_master_offset.i = getelementptr inbounds %struct.clusterState, ptr %33, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mf_end.i, i8 0, i64 16, i1 false)
  store i64 -1, ptr %mf_master_offset.i, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @delKeysInSlot(i32 noundef %hashslot) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %1 = load ptr, ptr %0, align 8
  %idxprom = zext i32 %hashslot to i64
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %2) #33
  %call18 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not9 = icmp eq ptr %call18, null
  br i1 %cmp.not9, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %sdslen.exit
  %call111 = phi ptr [ %call1, %sdslen.exit ], [ %call18, %entry ]
  %j.010 = phi i32 [ %inc, %sdslen.exit ], [ 0, %entry ]
  tail call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0) #33
  %call2 = tail call ptr @dictGetKey(ptr noundef nonnull %call111) #33
  %arrayidx.i = getelementptr inbounds i8, ptr %call2, i64 -1
  %3 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %3 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %while.body
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %while.body
  %add.ptr.i = getelementptr inbounds i8, ptr %call2, i64 -3
  %4 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %4 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %while.body
  %add.ptr6.i = getelementptr inbounds i8, ptr %call2, i64 -5
  %5 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %5 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %while.body
  %add.ptr10.i = getelementptr inbounds i8, ptr %call2, i64 -9
  %6 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %6 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %while.body
  %add.ptr14.i = getelementptr inbounds i8, ptr %call2, i64 -17
  %7 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %while.body, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %7, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %while.body ]
  %call4 = tail call ptr @createStringObject(ptr noundef nonnull %call2, i64 noundef %retval.0.i) #33
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %call6 = tail call i32 @dbDelete(ptr noundef %8, ptr noundef %call4) #33
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 390), align 8
  tail call void @propagateDeletion(ptr noundef %9, ptr noundef %call4, i32 noundef %10) #33
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  tail call void @signalModifiedKey(ptr noundef null, ptr noundef %11, ptr noundef %call4) #33
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %12, i64 0, i32 6
  %13 = load i32, ptr %id, align 8
  tail call void @moduleNotifyKeyspaceEvent(i32 noundef 4, ptr noundef nonnull @.str.206, ptr noundef %call4, i32 noundef %13) #33
  tail call void @exitExecutionUnit() #33
  tail call void @postExecutionUnitOperations() #33
  tail call void @decrRefCount(ptr noundef %call4) #33
  %inc = add i32 %j.010, 1
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  %inc10 = add nsw i64 %14, 1
  store i64 %inc10, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 219), align 8
  %call1 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !41

while.end:                                        ; preds = %sdslen.exit, %entry
  %j.0.lcssa = phi i32 [ 0, %entry ], [ %inc, %sdslen.exit ]
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  ret i32 %j.0.lcssa
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local i32 @getAlignedPingExtSize(i32 noundef %dataSize) local_unnamed_addr #27 {
entry:
  %add = add i32 %dataSize, 7
  %div1 = and i32 %add, -8
  %add1 = add i32 %div1, 8
  ret i32 %add1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @getHostnamePingExtSize() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 22
  %1 = load ptr, ptr %hostname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %return [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %cmp = icmp eq i64 %retval.0.i, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %sdslen.exit
  switch i32 %and.i, label %sdslen.exit19 [
    i32 0, label %sw.bb.i16
    i32 1, label %sw.bb3.i13
    i32 2, label %sw.bb5.i10
    i32 3, label %sw.bb9.i7
    i32 4, label %sw.bb13.i4
  ]

sw.bb.i16:                                        ; preds = %if.end
  %shr.i17 = lshr i32 %conv.i, 3
  %conv2.i18 = zext nneg i32 %shr.i17 to i64
  br label %sdslen.exit19

sw.bb3.i13:                                       ; preds = %if.end
  %add.ptr.i14 = getelementptr inbounds i8, ptr %1, i64 -3
  %7 = load i8, ptr %add.ptr.i14, align 1
  %conv4.i15 = zext i8 %7 to i64
  br label %sdslen.exit19

sw.bb5.i10:                                       ; preds = %if.end
  %add.ptr6.i11 = getelementptr inbounds i8, ptr %1, i64 -5
  %8 = load i16, ptr %add.ptr6.i11, align 1
  %conv8.i12 = zext i16 %8 to i64
  br label %sdslen.exit19

sw.bb9.i7:                                        ; preds = %if.end
  %add.ptr10.i8 = getelementptr inbounds i8, ptr %1, i64 -9
  %9 = load i32, ptr %add.ptr10.i8, align 1
  %conv12.i9 = zext i32 %9 to i64
  br label %sdslen.exit19

sw.bb13.i4:                                       ; preds = %if.end
  %add.ptr14.i5 = getelementptr inbounds i8, ptr %1, i64 -17
  %10 = load i64, ptr %add.ptr14.i5, align 1
  br label %sdslen.exit19

sdslen.exit19:                                    ; preds = %if.end, %sw.bb.i16, %sw.bb3.i13, %sw.bb5.i10, %sw.bb9.i7, %sw.bb13.i4
  %retval.0.i6 = phi i64 [ %10, %sw.bb13.i4 ], [ %conv12.i9, %sw.bb9.i7 ], [ %conv8.i12, %sw.bb5.i10 ], [ %conv4.i15, %sw.bb3.i13 ], [ %conv2.i18, %sw.bb.i16 ], [ 0, %if.end ]
  %11 = trunc i64 %retval.0.i6 to i32
  %12 = and i32 %11, -8
  %add1.i = add i32 %12, 16
  br label %return

return:                                           ; preds = %entry, %sdslen.exit, %sdslen.exit19
  %retval.0 = phi i32 [ %add1.i, %sdslen.exit19 ], [ 0, %sdslen.exit ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @getHumanNodenamePingExtSize() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 23
  %1 = load ptr, ptr %human_nodename, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %return [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %cmp = icmp eq i64 %retval.0.i, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %sdslen.exit
  switch i32 %and.i, label %sdslen.exit19 [
    i32 0, label %sw.bb.i16
    i32 1, label %sw.bb3.i13
    i32 2, label %sw.bb5.i10
    i32 3, label %sw.bb9.i7
    i32 4, label %sw.bb13.i4
  ]

sw.bb.i16:                                        ; preds = %if.end
  %shr.i17 = lshr i32 %conv.i, 3
  %conv2.i18 = zext nneg i32 %shr.i17 to i64
  br label %sdslen.exit19

sw.bb3.i13:                                       ; preds = %if.end
  %add.ptr.i14 = getelementptr inbounds i8, ptr %1, i64 -3
  %7 = load i8, ptr %add.ptr.i14, align 1
  %conv4.i15 = zext i8 %7 to i64
  br label %sdslen.exit19

sw.bb5.i10:                                       ; preds = %if.end
  %add.ptr6.i11 = getelementptr inbounds i8, ptr %1, i64 -5
  %8 = load i16, ptr %add.ptr6.i11, align 1
  %conv8.i12 = zext i16 %8 to i64
  br label %sdslen.exit19

sw.bb9.i7:                                        ; preds = %if.end
  %add.ptr10.i8 = getelementptr inbounds i8, ptr %1, i64 -9
  %9 = load i32, ptr %add.ptr10.i8, align 1
  %conv12.i9 = zext i32 %9 to i64
  br label %sdslen.exit19

sw.bb13.i4:                                       ; preds = %if.end
  %add.ptr14.i5 = getelementptr inbounds i8, ptr %1, i64 -17
  %10 = load i64, ptr %add.ptr14.i5, align 1
  br label %sdslen.exit19

sdslen.exit19:                                    ; preds = %if.end, %sw.bb.i16, %sw.bb3.i13, %sw.bb5.i10, %sw.bb9.i7, %sw.bb13.i4
  %retval.0.i6 = phi i64 [ %10, %sw.bb13.i4 ], [ %conv12.i9, %sw.bb9.i7 ], [ %conv8.i12, %sw.bb5.i10 ], [ %conv4.i15, %sw.bb3.i13 ], [ %conv2.i18, %sw.bb.i16 ], [ 0, %if.end ]
  %11 = trunc i64 %retval.0.i6 to i32
  %12 = and i32 %11, -8
  %add1.i = add i32 %12, 16
  br label %return

return:                                           ; preds = %entry, %sdslen.exit, %sdslen.exit19
  %retval.0 = phi i32 [ %add1.i, %sdslen.exit19 ], [ 0, %sdslen.exit ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local i32 @getShardIdPingExtSize() local_unnamed_addr #27 {
entry:
  ret i32 48
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local i32 @getForgottenNodeExtSize() local_unnamed_addr #27 {
entry:
  ret i32 56
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: write) uwtable
define dso_local nonnull ptr @preparePingExt(ptr noundef writeonly %ext, i16 noundef zeroext %type, i32 noundef %length) local_unnamed_addr #28 {
entry:
  %call = tail call zeroext i16 @htons(i16 noundef zeroext %type) #36
  %type1 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %ext, i64 0, i32 1
  store i16 %call, ptr %type1, align 4
  %call2 = tail call i32 @htonl(i32 noundef %length) #36
  store i32 %call2, ptr %ext, align 8
  %ext4 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %ext, i64 0, i32 3
  ret ptr %ext4
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare zeroext i16 @htons(i16 noundef zeroext) local_unnamed_addr #11

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(none)
declare i32 @htonl(i32 noundef) local_unnamed_addr #11

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @nextPingExt(ptr noundef readonly %ext) local_unnamed_addr #29 {
entry:
  %0 = load i32, ptr %ext, align 8
  %call = tail call i32 @ntohl(i32 noundef %0) #36
  %idx.ext = zext i32 %call to i64
  %add.ptr = getelementptr inbounds i8, ptr %ext, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define dso_local i32 @writePingExt(ptr noundef %hdr, i32 noundef %gossipcount) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %hdr, null
  %data.i = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 20
  %idxprom.i = sext i32 %gossipcount to i64
  %arrayidx.i = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data.i, i64 0, i64 %idxprom.i
  %cursor.0 = select i1 %cmp.not, ptr null, ptr %arrayidx.i
  %0 = load ptr, ptr @myself, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 22
  %1 = load ptr, ptr %hostname, align 8
  %arrayidx.i29 = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i29, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %if.end15 [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %cmp2.not = icmp eq i64 %retval.0.i, 0
  br i1 %cmp2.not, label %if.end15, label %if.then3

if.then3:                                         ; preds = %sdslen.exit
  br i1 %cmp.not, label %if.end13, label %if.then5

if.then5:                                         ; preds = %if.then3
  switch i32 %and.i, label %getHostnamePingExtSize.exit [
    i32 0, label %sw.bb.i.i
    i32 1, label %sw.bb3.i.i
    i32 2, label %sw.bb5.i.i
    i32 3, label %sw.bb9.i.i
    i32 4, label %sw.bb13.i.i
  ]

sw.bb.i.i:                                        ; preds = %if.then5
  %shr.i.i = lshr i32 %conv.i, 3
  %conv2.i.i = zext nneg i32 %shr.i.i to i64
  br label %sdslen.exit.i

sw.bb3.i.i:                                       ; preds = %if.then5
  %add.ptr.i.i = getelementptr inbounds i8, ptr %1, i64 -3
  %7 = load i8, ptr %add.ptr.i.i, align 1
  %conv4.i.i = zext i8 %7 to i64
  br label %sdslen.exit.i

sw.bb5.i.i:                                       ; preds = %if.then5
  %add.ptr6.i.i = getelementptr inbounds i8, ptr %1, i64 -5
  %8 = load i16, ptr %add.ptr6.i.i, align 1
  %conv8.i.i = zext i16 %8 to i64
  br label %sdslen.exit.i

sw.bb9.i.i:                                       ; preds = %if.then5
  %add.ptr10.i.i = getelementptr inbounds i8, ptr %1, i64 -9
  %9 = load i32, ptr %add.ptr10.i.i, align 1
  %conv12.i.i = zext i32 %9 to i64
  br label %sdslen.exit.i

sw.bb13.i.i:                                      ; preds = %if.then5
  %add.ptr14.i.i = getelementptr inbounds i8, ptr %1, i64 -17
  %10 = load i64, ptr %add.ptr14.i.i, align 1
  br label %sdslen.exit.i

sdslen.exit.i:                                    ; preds = %sw.bb13.i.i, %sw.bb9.i.i, %sw.bb5.i.i, %sw.bb3.i.i, %sw.bb.i.i
  %retval.0.i.i = phi i64 [ %10, %sw.bb13.i.i ], [ %conv12.i.i, %sw.bb9.i.i ], [ %conv8.i.i, %sw.bb5.i.i ], [ %conv4.i.i, %sw.bb3.i.i ], [ %conv2.i.i, %sw.bb.i.i ]
  %cmp.i = icmp eq i64 %retval.0.i.i, 0
  br i1 %cmp.i, label %getHostnamePingExtSize.exit, label %if.end.i

if.end.i:                                         ; preds = %sdslen.exit.i
  switch i32 %and.i, label %sdslen.exit19.i [
    i32 0, label %sw.bb.i16.i
    i32 1, label %sw.bb3.i13.i
    i32 2, label %sw.bb5.i10.i
    i32 3, label %sw.bb9.i7.i
    i32 4, label %sw.bb13.i4.i
  ]

sw.bb.i16.i:                                      ; preds = %if.end.i
  %shr.i17.i = lshr i32 %conv.i, 3
  %conv2.i18.i = zext nneg i32 %shr.i17.i to i64
  br label %sdslen.exit19.i

sw.bb3.i13.i:                                     ; preds = %if.end.i
  %add.ptr.i14.i = getelementptr inbounds i8, ptr %1, i64 -3
  %11 = load i8, ptr %add.ptr.i14.i, align 1
  %conv4.i15.i = zext i8 %11 to i64
  br label %sdslen.exit19.i

sw.bb5.i10.i:                                     ; preds = %if.end.i
  %add.ptr6.i11.i = getelementptr inbounds i8, ptr %1, i64 -5
  %12 = load i16, ptr %add.ptr6.i11.i, align 1
  %conv8.i12.i = zext i16 %12 to i64
  br label %sdslen.exit19.i

sw.bb9.i7.i:                                      ; preds = %if.end.i
  %add.ptr10.i8.i = getelementptr inbounds i8, ptr %1, i64 -9
  %13 = load i32, ptr %add.ptr10.i8.i, align 1
  %conv12.i9.i = zext i32 %13 to i64
  br label %sdslen.exit19.i

sw.bb13.i4.i:                                     ; preds = %if.end.i
  %add.ptr14.i5.i = getelementptr inbounds i8, ptr %1, i64 -17
  %14 = load i64, ptr %add.ptr14.i5.i, align 1
  br label %sdslen.exit19.i

sdslen.exit19.i:                                  ; preds = %sw.bb13.i4.i, %sw.bb9.i7.i, %sw.bb5.i10.i, %sw.bb3.i13.i, %sw.bb.i16.i, %if.end.i
  %retval.0.i6.i = phi i64 [ %14, %sw.bb13.i4.i ], [ %conv12.i9.i, %sw.bb9.i7.i ], [ %conv8.i12.i, %sw.bb5.i10.i ], [ %conv4.i15.i, %sw.bb3.i13.i ], [ %conv2.i18.i, %sw.bb.i16.i ], [ 0, %if.end.i ]
  %15 = trunc i64 %retval.0.i6.i to i32
  %16 = and i32 %15, -8
  %add1.i.i = add i32 %16, 16
  br label %getHostnamePingExtSize.exit

getHostnamePingExtSize.exit:                      ; preds = %if.then5, %sdslen.exit.i, %sdslen.exit19.i
  %retval.0.i30 = phi i32 [ %add1.i.i, %sdslen.exit19.i ], [ 0, %sdslen.exit.i ], [ 0, %if.then5 ]
  %call.i = tail call zeroext i16 @htons(i16 noundef zeroext 0) #36
  %type1.i = getelementptr inbounds %struct.clusterMsgPingExt, ptr %arrayidx.i, i64 0, i32 1
  store i16 %call.i, ptr %type1.i, align 4
  %call2.i = tail call i32 @htonl(i32 noundef %retval.0.i30) #36
  store i32 %call2.i, ptr %arrayidx.i, align 8
  %ext4.i = getelementptr inbounds %struct.clusterMsgPingExt, ptr %arrayidx.i, i64 0, i32 3
  %17 = load ptr, ptr @myself, align 8
  %hostname9 = getelementptr inbounds %struct._clusterNode, ptr %17, i64 0, i32 22
  %18 = load ptr, ptr %hostname9, align 8
  %arrayidx.i31 = getelementptr inbounds i8, ptr %18, i64 -1
  %19 = load i8, ptr %arrayidx.i31, align 1
  %conv.i32 = zext i8 %19 to i32
  %and.i33 = and i32 %conv.i32, 7
  switch i32 %and.i33, label %sdslen.exit49 [
    i32 0, label %sw.bb.i46
    i32 1, label %sw.bb3.i43
    i32 2, label %sw.bb5.i40
    i32 3, label %sw.bb9.i37
    i32 4, label %sw.bb13.i34
  ]

sw.bb.i46:                                        ; preds = %getHostnamePingExtSize.exit
  %shr.i47 = lshr i32 %conv.i32, 3
  %conv2.i48 = zext nneg i32 %shr.i47 to i64
  br label %sdslen.exit49

sw.bb3.i43:                                       ; preds = %getHostnamePingExtSize.exit
  %add.ptr.i44 = getelementptr inbounds i8, ptr %18, i64 -3
  %20 = load i8, ptr %add.ptr.i44, align 1
  %conv4.i45 = zext i8 %20 to i64
  br label %sdslen.exit49

sw.bb5.i40:                                       ; preds = %getHostnamePingExtSize.exit
  %add.ptr6.i41 = getelementptr inbounds i8, ptr %18, i64 -5
  %21 = load i16, ptr %add.ptr6.i41, align 1
  %conv8.i42 = zext i16 %21 to i64
  br label %sdslen.exit49

sw.bb9.i37:                                       ; preds = %getHostnamePingExtSize.exit
  %add.ptr10.i38 = getelementptr inbounds i8, ptr %18, i64 -9
  %22 = load i32, ptr %add.ptr10.i38, align 1
  %conv12.i39 = zext i32 %22 to i64
  br label %sdslen.exit49

sw.bb13.i34:                                      ; preds = %getHostnamePingExtSize.exit
  %add.ptr14.i35 = getelementptr inbounds i8, ptr %18, i64 -17
  %23 = load i64, ptr %add.ptr14.i35, align 1
  br label %sdslen.exit49

sdslen.exit49:                                    ; preds = %getHostnamePingExtSize.exit, %sw.bb.i46, %sw.bb3.i43, %sw.bb5.i40, %sw.bb9.i37, %sw.bb13.i34
  %retval.0.i36 = phi i64 [ %23, %sw.bb13.i34 ], [ %conv12.i39, %sw.bb9.i37 ], [ %conv8.i42, %sw.bb5.i40 ], [ %conv4.i45, %sw.bb3.i43 ], [ %conv2.i48, %sw.bb.i46 ], [ 0, %getHostnamePingExtSize.exit ]
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %ext4.i, ptr nonnull align 1 %18, i64 %retval.0.i36, i1 false)
  %call.i50 = tail call i32 @ntohl(i32 noundef %call2.i) #36
  %idx.ext.i = zext i32 %call.i50 to i64
  %add.ptr.i51 = getelementptr inbounds i8, ptr %arrayidx.i, i64 %idx.ext.i
  %.pre = load ptr, ptr %hostname9, align 8
  %arrayidx.i.i53.phi.trans.insert = getelementptr inbounds i8, ptr %.pre, i64 -1
  %.pre248 = load i8, ptr %arrayidx.i.i53.phi.trans.insert, align 1
  %.pre252 = zext i8 %.pre248 to i32
  br label %if.end13

if.end13:                                         ; preds = %sdslen.exit49, %if.then3
  %conv.i.i54.pre-phi = phi i32 [ %.pre252, %sdslen.exit49 ], [ %conv.i, %if.then3 ]
  %24 = phi ptr [ %.pre, %sdslen.exit49 ], [ %1, %if.then3 ]
  %25 = phi ptr [ %17, %sdslen.exit49 ], [ %0, %if.then3 ]
  %cursor.1 = phi ptr [ %add.ptr.i51, %sdslen.exit49 ], [ null, %if.then3 ]
  %and.i.i55 = and i32 %conv.i.i54.pre-phi, 7
  switch i32 %and.i.i55, label %if.end15 [
    i32 0, label %sw.bb.i.i89
    i32 1, label %sw.bb3.i.i86
    i32 2, label %sw.bb5.i.i83
    i32 3, label %sw.bb9.i.i80
    i32 4, label %sw.bb13.i.i56
  ]

sw.bb.i.i89:                                      ; preds = %if.end13
  %shr.i.i90 = lshr i32 %conv.i.i54.pre-phi, 3
  %conv2.i.i91 = zext nneg i32 %shr.i.i90 to i64
  br label %sdslen.exit.i58

sw.bb3.i.i86:                                     ; preds = %if.end13
  %add.ptr.i.i87 = getelementptr inbounds i8, ptr %24, i64 -3
  %26 = load i8, ptr %add.ptr.i.i87, align 1
  %conv4.i.i88 = zext i8 %26 to i64
  br label %sdslen.exit.i58

sw.bb5.i.i83:                                     ; preds = %if.end13
  %add.ptr6.i.i84 = getelementptr inbounds i8, ptr %24, i64 -5
  %27 = load i16, ptr %add.ptr6.i.i84, align 1
  %conv8.i.i85 = zext i16 %27 to i64
  br label %sdslen.exit.i58

sw.bb9.i.i80:                                     ; preds = %if.end13
  %add.ptr10.i.i81 = getelementptr inbounds i8, ptr %24, i64 -9
  %28 = load i32, ptr %add.ptr10.i.i81, align 1
  %conv12.i.i82 = zext i32 %28 to i64
  br label %sdslen.exit.i58

sw.bb13.i.i56:                                    ; preds = %if.end13
  %add.ptr14.i.i57 = getelementptr inbounds i8, ptr %24, i64 -17
  %29 = load i64, ptr %add.ptr14.i.i57, align 1
  br label %sdslen.exit.i58

sdslen.exit.i58:                                  ; preds = %sw.bb13.i.i56, %sw.bb9.i.i80, %sw.bb5.i.i83, %sw.bb3.i.i86, %sw.bb.i.i89
  %retval.0.i.i59 = phi i64 [ %29, %sw.bb13.i.i56 ], [ %conv12.i.i82, %sw.bb9.i.i80 ], [ %conv8.i.i85, %sw.bb5.i.i83 ], [ %conv4.i.i88, %sw.bb3.i.i86 ], [ %conv2.i.i91, %sw.bb.i.i89 ]
  %cmp.i60 = icmp eq i64 %retval.0.i.i59, 0
  br i1 %cmp.i60, label %if.end15, label %if.end.i61

if.end.i61:                                       ; preds = %sdslen.exit.i58
  switch i32 %and.i.i55, label %sdslen.exit19.i64 [
    i32 0, label %sw.bb.i16.i77
    i32 1, label %sw.bb3.i13.i74
    i32 2, label %sw.bb5.i10.i71
    i32 3, label %sw.bb9.i7.i68
    i32 4, label %sw.bb13.i4.i62
  ]

sw.bb.i16.i77:                                    ; preds = %if.end.i61
  %shr.i17.i78 = lshr i32 %conv.i.i54.pre-phi, 3
  %conv2.i18.i79 = zext nneg i32 %shr.i17.i78 to i64
  br label %sdslen.exit19.i64

sw.bb3.i13.i74:                                   ; preds = %if.end.i61
  %add.ptr.i14.i75 = getelementptr inbounds i8, ptr %24, i64 -3
  %30 = load i8, ptr %add.ptr.i14.i75, align 1
  %conv4.i15.i76 = zext i8 %30 to i64
  br label %sdslen.exit19.i64

sw.bb5.i10.i71:                                   ; preds = %if.end.i61
  %add.ptr6.i11.i72 = getelementptr inbounds i8, ptr %24, i64 -5
  %31 = load i16, ptr %add.ptr6.i11.i72, align 1
  %conv8.i12.i73 = zext i16 %31 to i64
  br label %sdslen.exit19.i64

sw.bb9.i7.i68:                                    ; preds = %if.end.i61
  %add.ptr10.i8.i69 = getelementptr inbounds i8, ptr %24, i64 -9
  %32 = load i32, ptr %add.ptr10.i8.i69, align 1
  %conv12.i9.i70 = zext i32 %32 to i64
  br label %sdslen.exit19.i64

sw.bb13.i4.i62:                                   ; preds = %if.end.i61
  %add.ptr14.i5.i63 = getelementptr inbounds i8, ptr %24, i64 -17
  %33 = load i64, ptr %add.ptr14.i5.i63, align 1
  br label %sdslen.exit19.i64

sdslen.exit19.i64:                                ; preds = %sw.bb13.i4.i62, %sw.bb9.i7.i68, %sw.bb5.i10.i71, %sw.bb3.i13.i74, %sw.bb.i16.i77, %if.end.i61
  %retval.0.i6.i65 = phi i64 [ %33, %sw.bb13.i4.i62 ], [ %conv12.i9.i70, %sw.bb9.i7.i68 ], [ %conv8.i12.i73, %sw.bb5.i10.i71 ], [ %conv4.i15.i76, %sw.bb3.i13.i74 ], [ %conv2.i18.i79, %sw.bb.i16.i77 ], [ 0, %if.end.i61 ]
  %34 = trunc i64 %retval.0.i6.i65 to i32
  %35 = and i32 %34, -8
  %add1.i.i66 = add i32 %35, 16
  br label %if.end15

if.end15:                                         ; preds = %entry, %sdslen.exit19.i64, %sdslen.exit.i58, %if.end13, %sdslen.exit
  %36 = phi ptr [ %0, %sdslen.exit ], [ %25, %if.end13 ], [ %25, %sdslen.exit.i58 ], [ %25, %sdslen.exit19.i64 ], [ %0, %entry ]
  %cursor.2 = phi ptr [ %cursor.0, %sdslen.exit ], [ %cursor.1, %if.end13 ], [ %cursor.1, %sdslen.exit.i58 ], [ %cursor.1, %sdslen.exit19.i64 ], [ %cursor.0, %entry ]
  %totlen.0 = phi i32 [ 0, %sdslen.exit ], [ 0, %if.end13 ], [ 0, %sdslen.exit.i58 ], [ %add1.i.i66, %sdslen.exit19.i64 ], [ 0, %entry ]
  %extensions.0 = phi i16 [ 0, %sdslen.exit ], [ 1, %if.end13 ], [ 1, %sdslen.exit.i58 ], [ 1, %sdslen.exit19.i64 ], [ 0, %entry ]
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %36, i64 0, i32 23
  %37 = load ptr, ptr %human_nodename, align 8
  %arrayidx.i93 = getelementptr inbounds i8, ptr %37, i64 -1
  %38 = load i8, ptr %arrayidx.i93, align 1
  %conv.i94 = zext i8 %38 to i32
  %and.i95 = and i32 %conv.i94, 7
  switch i32 %and.i95, label %if.end34 [
    i32 0, label %sw.bb.i108
    i32 1, label %sw.bb3.i105
    i32 2, label %sw.bb5.i102
    i32 3, label %sw.bb9.i99
    i32 4, label %sw.bb13.i96
  ]

sw.bb.i108:                                       ; preds = %if.end15
  %shr.i109 = lshr i32 %conv.i94, 3
  %conv2.i110 = zext nneg i32 %shr.i109 to i64
  br label %sdslen.exit111

sw.bb3.i105:                                      ; preds = %if.end15
  %add.ptr.i106 = getelementptr inbounds i8, ptr %37, i64 -3
  %39 = load i8, ptr %add.ptr.i106, align 1
  %conv4.i107 = zext i8 %39 to i64
  br label %sdslen.exit111

sw.bb5.i102:                                      ; preds = %if.end15
  %add.ptr6.i103 = getelementptr inbounds i8, ptr %37, i64 -5
  %40 = load i16, ptr %add.ptr6.i103, align 1
  %conv8.i104 = zext i16 %40 to i64
  br label %sdslen.exit111

sw.bb9.i99:                                       ; preds = %if.end15
  %add.ptr10.i100 = getelementptr inbounds i8, ptr %37, i64 -9
  %41 = load i32, ptr %add.ptr10.i100, align 1
  %conv12.i101 = zext i32 %41 to i64
  br label %sdslen.exit111

sw.bb13.i96:                                      ; preds = %if.end15
  %add.ptr14.i97 = getelementptr inbounds i8, ptr %37, i64 -17
  %42 = load i64, ptr %add.ptr14.i97, align 1
  br label %sdslen.exit111

sdslen.exit111:                                   ; preds = %sw.bb.i108, %sw.bb3.i105, %sw.bb5.i102, %sw.bb9.i99, %sw.bb13.i96
  %retval.0.i98 = phi i64 [ %42, %sw.bb13.i96 ], [ %conv12.i101, %sw.bb9.i99 ], [ %conv8.i104, %sw.bb5.i102 ], [ %conv4.i107, %sw.bb3.i105 ], [ %conv2.i110, %sw.bb.i108 ]
  %cmp17.not = icmp eq i64 %retval.0.i98, 0
  br i1 %cmp17.not, label %if.end34, label %if.then18

if.then18:                                        ; preds = %sdslen.exit111
  %cmp19.not = icmp eq ptr %cursor.2, null
  br i1 %cmp19.not, label %if.end30, label %if.then20

if.then20:                                        ; preds = %if.then18
  switch i32 %and.i95, label %getHumanNodenamePingExtSize.exit [
    i32 0, label %sw.bb.i.i148
    i32 1, label %sw.bb3.i.i145
    i32 2, label %sw.bb5.i.i142
    i32 3, label %sw.bb9.i.i139
    i32 4, label %sw.bb13.i.i115
  ]

sw.bb.i.i148:                                     ; preds = %if.then20
  %shr.i.i149 = lshr i32 %conv.i94, 3
  %conv2.i.i150 = zext nneg i32 %shr.i.i149 to i64
  br label %sdslen.exit.i117

sw.bb3.i.i145:                                    ; preds = %if.then20
  %add.ptr.i.i146 = getelementptr inbounds i8, ptr %37, i64 -3
  %43 = load i8, ptr %add.ptr.i.i146, align 1
  %conv4.i.i147 = zext i8 %43 to i64
  br label %sdslen.exit.i117

sw.bb5.i.i142:                                    ; preds = %if.then20
  %add.ptr6.i.i143 = getelementptr inbounds i8, ptr %37, i64 -5
  %44 = load i16, ptr %add.ptr6.i.i143, align 1
  %conv8.i.i144 = zext i16 %44 to i64
  br label %sdslen.exit.i117

sw.bb9.i.i139:                                    ; preds = %if.then20
  %add.ptr10.i.i140 = getelementptr inbounds i8, ptr %37, i64 -9
  %45 = load i32, ptr %add.ptr10.i.i140, align 1
  %conv12.i.i141 = zext i32 %45 to i64
  br label %sdslen.exit.i117

sw.bb13.i.i115:                                   ; preds = %if.then20
  %add.ptr14.i.i116 = getelementptr inbounds i8, ptr %37, i64 -17
  %46 = load i64, ptr %add.ptr14.i.i116, align 1
  br label %sdslen.exit.i117

sdslen.exit.i117:                                 ; preds = %sw.bb13.i.i115, %sw.bb9.i.i139, %sw.bb5.i.i142, %sw.bb3.i.i145, %sw.bb.i.i148
  %retval.0.i.i118 = phi i64 [ %46, %sw.bb13.i.i115 ], [ %conv12.i.i141, %sw.bb9.i.i139 ], [ %conv8.i.i144, %sw.bb5.i.i142 ], [ %conv4.i.i147, %sw.bb3.i.i145 ], [ %conv2.i.i150, %sw.bb.i.i148 ]
  %cmp.i119 = icmp eq i64 %retval.0.i.i118, 0
  br i1 %cmp.i119, label %getHumanNodenamePingExtSize.exit, label %if.end.i120

if.end.i120:                                      ; preds = %sdslen.exit.i117
  switch i32 %and.i95, label %sdslen.exit19.i123 [
    i32 0, label %sw.bb.i16.i136
    i32 1, label %sw.bb3.i13.i133
    i32 2, label %sw.bb5.i10.i130
    i32 3, label %sw.bb9.i7.i127
    i32 4, label %sw.bb13.i4.i121
  ]

sw.bb.i16.i136:                                   ; preds = %if.end.i120
  %shr.i17.i137 = lshr i32 %conv.i94, 3
  %conv2.i18.i138 = zext nneg i32 %shr.i17.i137 to i64
  br label %sdslen.exit19.i123

sw.bb3.i13.i133:                                  ; preds = %if.end.i120
  %add.ptr.i14.i134 = getelementptr inbounds i8, ptr %37, i64 -3
  %47 = load i8, ptr %add.ptr.i14.i134, align 1
  %conv4.i15.i135 = zext i8 %47 to i64
  br label %sdslen.exit19.i123

sw.bb5.i10.i130:                                  ; preds = %if.end.i120
  %add.ptr6.i11.i131 = getelementptr inbounds i8, ptr %37, i64 -5
  %48 = load i16, ptr %add.ptr6.i11.i131, align 1
  %conv8.i12.i132 = zext i16 %48 to i64
  br label %sdslen.exit19.i123

sw.bb9.i7.i127:                                   ; preds = %if.end.i120
  %add.ptr10.i8.i128 = getelementptr inbounds i8, ptr %37, i64 -9
  %49 = load i32, ptr %add.ptr10.i8.i128, align 1
  %conv12.i9.i129 = zext i32 %49 to i64
  br label %sdslen.exit19.i123

sw.bb13.i4.i121:                                  ; preds = %if.end.i120
  %add.ptr14.i5.i122 = getelementptr inbounds i8, ptr %37, i64 -17
  %50 = load i64, ptr %add.ptr14.i5.i122, align 1
  br label %sdslen.exit19.i123

sdslen.exit19.i123:                               ; preds = %sw.bb13.i4.i121, %sw.bb9.i7.i127, %sw.bb5.i10.i130, %sw.bb3.i13.i133, %sw.bb.i16.i136, %if.end.i120
  %retval.0.i6.i124 = phi i64 [ %50, %sw.bb13.i4.i121 ], [ %conv12.i9.i129, %sw.bb9.i7.i127 ], [ %conv8.i12.i132, %sw.bb5.i10.i130 ], [ %conv4.i15.i135, %sw.bb3.i13.i133 ], [ %conv2.i18.i138, %sw.bb.i16.i136 ], [ 0, %if.end.i120 ]
  %51 = trunc i64 %retval.0.i6.i124 to i32
  %52 = and i32 %51, -8
  %add1.i.i125 = add i32 %52, 16
  br label %getHumanNodenamePingExtSize.exit

getHumanNodenamePingExtSize.exit:                 ; preds = %if.then20, %sdslen.exit.i117, %sdslen.exit19.i123
  %retval.0.i126 = phi i32 [ %add1.i.i125, %sdslen.exit19.i123 ], [ 0, %sdslen.exit.i117 ], [ 0, %if.then20 ]
  %call.i151 = tail call zeroext i16 @htons(i16 noundef zeroext 1) #36
  %type1.i152 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %cursor.2, i64 0, i32 1
  store i16 %call.i151, ptr %type1.i152, align 4
  %call2.i153 = tail call i32 @htonl(i32 noundef %retval.0.i126) #36
  store i32 %call2.i153, ptr %cursor.2, align 8
  %ext4.i154 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %cursor.2, i64 0, i32 3
  %53 = load ptr, ptr @myself, align 8
  %human_nodename26 = getelementptr inbounds %struct._clusterNode, ptr %53, i64 0, i32 23
  %54 = load ptr, ptr %human_nodename26, align 8
  %arrayidx.i155 = getelementptr inbounds i8, ptr %54, i64 -1
  %55 = load i8, ptr %arrayidx.i155, align 1
  %conv.i156 = zext i8 %55 to i32
  %and.i157 = and i32 %conv.i156, 7
  switch i32 %and.i157, label %sdslen.exit173 [
    i32 0, label %sw.bb.i170
    i32 1, label %sw.bb3.i167
    i32 2, label %sw.bb5.i164
    i32 3, label %sw.bb9.i161
    i32 4, label %sw.bb13.i158
  ]

sw.bb.i170:                                       ; preds = %getHumanNodenamePingExtSize.exit
  %shr.i171 = lshr i32 %conv.i156, 3
  %conv2.i172 = zext nneg i32 %shr.i171 to i64
  br label %sdslen.exit173

sw.bb3.i167:                                      ; preds = %getHumanNodenamePingExtSize.exit
  %add.ptr.i168 = getelementptr inbounds i8, ptr %54, i64 -3
  %56 = load i8, ptr %add.ptr.i168, align 1
  %conv4.i169 = zext i8 %56 to i64
  br label %sdslen.exit173

sw.bb5.i164:                                      ; preds = %getHumanNodenamePingExtSize.exit
  %add.ptr6.i165 = getelementptr inbounds i8, ptr %54, i64 -5
  %57 = load i16, ptr %add.ptr6.i165, align 1
  %conv8.i166 = zext i16 %57 to i64
  br label %sdslen.exit173

sw.bb9.i161:                                      ; preds = %getHumanNodenamePingExtSize.exit
  %add.ptr10.i162 = getelementptr inbounds i8, ptr %54, i64 -9
  %58 = load i32, ptr %add.ptr10.i162, align 1
  %conv12.i163 = zext i32 %58 to i64
  br label %sdslen.exit173

sw.bb13.i158:                                     ; preds = %getHumanNodenamePingExtSize.exit
  %add.ptr14.i159 = getelementptr inbounds i8, ptr %54, i64 -17
  %59 = load i64, ptr %add.ptr14.i159, align 1
  br label %sdslen.exit173

sdslen.exit173:                                   ; preds = %getHumanNodenamePingExtSize.exit, %sw.bb.i170, %sw.bb3.i167, %sw.bb5.i164, %sw.bb9.i161, %sw.bb13.i158
  %retval.0.i160 = phi i64 [ %59, %sw.bb13.i158 ], [ %conv12.i163, %sw.bb9.i161 ], [ %conv8.i166, %sw.bb5.i164 ], [ %conv4.i169, %sw.bb3.i167 ], [ %conv2.i172, %sw.bb.i170 ], [ 0, %getHumanNodenamePingExtSize.exit ]
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %ext4.i154, ptr nonnull align 1 %54, i64 %retval.0.i160, i1 false)
  %call.i174 = tail call i32 @ntohl(i32 noundef %call2.i153) #36
  %idx.ext.i175 = zext i32 %call.i174 to i64
  %add.ptr.i176 = getelementptr inbounds i8, ptr %cursor.2, i64 %idx.ext.i175
  %.pre249 = load ptr, ptr %human_nodename26, align 8
  %arrayidx.i.i178.phi.trans.insert = getelementptr inbounds i8, ptr %.pre249, i64 -1
  %.pre250 = load i8, ptr %arrayidx.i.i178.phi.trans.insert, align 1
  %.pre251 = zext i8 %.pre250 to i32
  br label %if.end30

if.end30:                                         ; preds = %sdslen.exit173, %if.then18
  %conv.i.i179.pre-phi = phi i32 [ %.pre251, %sdslen.exit173 ], [ %conv.i94, %if.then18 ]
  %60 = phi ptr [ %.pre249, %sdslen.exit173 ], [ %37, %if.then18 ]
  %cursor.3 = phi ptr [ %add.ptr.i176, %sdslen.exit173 ], [ null, %if.then18 ]
  %and.i.i180 = and i32 %conv.i.i179.pre-phi, 7
  switch i32 %and.i.i180, label %getHumanNodenamePingExtSize.exit217 [
    i32 0, label %sw.bb.i.i214
    i32 1, label %sw.bb3.i.i211
    i32 2, label %sw.bb5.i.i208
    i32 3, label %sw.bb9.i.i205
    i32 4, label %sw.bb13.i.i181
  ]

sw.bb.i.i214:                                     ; preds = %if.end30
  %shr.i.i215 = lshr i32 %conv.i.i179.pre-phi, 3
  %conv2.i.i216 = zext nneg i32 %shr.i.i215 to i64
  br label %sdslen.exit.i183

sw.bb3.i.i211:                                    ; preds = %if.end30
  %add.ptr.i.i212 = getelementptr inbounds i8, ptr %60, i64 -3
  %61 = load i8, ptr %add.ptr.i.i212, align 1
  %conv4.i.i213 = zext i8 %61 to i64
  br label %sdslen.exit.i183

sw.bb5.i.i208:                                    ; preds = %if.end30
  %add.ptr6.i.i209 = getelementptr inbounds i8, ptr %60, i64 -5
  %62 = load i16, ptr %add.ptr6.i.i209, align 1
  %conv8.i.i210 = zext i16 %62 to i64
  br label %sdslen.exit.i183

sw.bb9.i.i205:                                    ; preds = %if.end30
  %add.ptr10.i.i206 = getelementptr inbounds i8, ptr %60, i64 -9
  %63 = load i32, ptr %add.ptr10.i.i206, align 1
  %conv12.i.i207 = zext i32 %63 to i64
  br label %sdslen.exit.i183

sw.bb13.i.i181:                                   ; preds = %if.end30
  %add.ptr14.i.i182 = getelementptr inbounds i8, ptr %60, i64 -17
  %64 = load i64, ptr %add.ptr14.i.i182, align 1
  br label %sdslen.exit.i183

sdslen.exit.i183:                                 ; preds = %sw.bb13.i.i181, %sw.bb9.i.i205, %sw.bb5.i.i208, %sw.bb3.i.i211, %sw.bb.i.i214
  %retval.0.i.i184 = phi i64 [ %64, %sw.bb13.i.i181 ], [ %conv12.i.i207, %sw.bb9.i.i205 ], [ %conv8.i.i210, %sw.bb5.i.i208 ], [ %conv4.i.i213, %sw.bb3.i.i211 ], [ %conv2.i.i216, %sw.bb.i.i214 ]
  %cmp.i185 = icmp eq i64 %retval.0.i.i184, 0
  br i1 %cmp.i185, label %getHumanNodenamePingExtSize.exit217, label %if.end.i186

if.end.i186:                                      ; preds = %sdslen.exit.i183
  switch i32 %and.i.i180, label %sdslen.exit19.i189 [
    i32 0, label %sw.bb.i16.i202
    i32 1, label %sw.bb3.i13.i199
    i32 2, label %sw.bb5.i10.i196
    i32 3, label %sw.bb9.i7.i193
    i32 4, label %sw.bb13.i4.i187
  ]

sw.bb.i16.i202:                                   ; preds = %if.end.i186
  %shr.i17.i203 = lshr i32 %conv.i.i179.pre-phi, 3
  %conv2.i18.i204 = zext nneg i32 %shr.i17.i203 to i64
  br label %sdslen.exit19.i189

sw.bb3.i13.i199:                                  ; preds = %if.end.i186
  %add.ptr.i14.i200 = getelementptr inbounds i8, ptr %60, i64 -3
  %65 = load i8, ptr %add.ptr.i14.i200, align 1
  %conv4.i15.i201 = zext i8 %65 to i64
  br label %sdslen.exit19.i189

sw.bb5.i10.i196:                                  ; preds = %if.end.i186
  %add.ptr6.i11.i197 = getelementptr inbounds i8, ptr %60, i64 -5
  %66 = load i16, ptr %add.ptr6.i11.i197, align 1
  %conv8.i12.i198 = zext i16 %66 to i64
  br label %sdslen.exit19.i189

sw.bb9.i7.i193:                                   ; preds = %if.end.i186
  %add.ptr10.i8.i194 = getelementptr inbounds i8, ptr %60, i64 -9
  %67 = load i32, ptr %add.ptr10.i8.i194, align 1
  %conv12.i9.i195 = zext i32 %67 to i64
  br label %sdslen.exit19.i189

sw.bb13.i4.i187:                                  ; preds = %if.end.i186
  %add.ptr14.i5.i188 = getelementptr inbounds i8, ptr %60, i64 -17
  %68 = load i64, ptr %add.ptr14.i5.i188, align 1
  br label %sdslen.exit19.i189

sdslen.exit19.i189:                               ; preds = %sw.bb13.i4.i187, %sw.bb9.i7.i193, %sw.bb5.i10.i196, %sw.bb3.i13.i199, %sw.bb.i16.i202, %if.end.i186
  %retval.0.i6.i190 = phi i64 [ %68, %sw.bb13.i4.i187 ], [ %conv12.i9.i195, %sw.bb9.i7.i193 ], [ %conv8.i12.i198, %sw.bb5.i10.i196 ], [ %conv4.i15.i201, %sw.bb3.i13.i199 ], [ %conv2.i18.i204, %sw.bb.i16.i202 ], [ 0, %if.end.i186 ]
  %69 = trunc i64 %retval.0.i6.i190 to i32
  %70 = and i32 %69, -8
  %add1.i.i191 = add i32 %70, 16
  br label %getHumanNodenamePingExtSize.exit217

getHumanNodenamePingExtSize.exit217:              ; preds = %if.end30, %sdslen.exit.i183, %sdslen.exit19.i189
  %retval.0.i192 = phi i32 [ %add1.i.i191, %sdslen.exit19.i189 ], [ 0, %sdslen.exit.i183 ], [ 0, %if.end30 ]
  %add32 = add i32 %retval.0.i192, %totlen.0
  %inc33 = add nuw nsw i16 %extensions.0, 1
  br label %if.end34

if.end34:                                         ; preds = %if.end15, %getHumanNodenamePingExtSize.exit217, %sdslen.exit111
  %cursor.4 = phi ptr [ %cursor.3, %getHumanNodenamePingExtSize.exit217 ], [ %cursor.2, %sdslen.exit111 ], [ %cursor.2, %if.end15 ]
  %totlen.1 = phi i32 [ %add32, %getHumanNodenamePingExtSize.exit217 ], [ %totlen.0, %sdslen.exit111 ], [ %totlen.0, %if.end15 ]
  %extensions.1 = phi i16 [ %inc33, %getHumanNodenamePingExtSize.exit217 ], [ %extensions.0, %sdslen.exit111 ], [ %extensions.0, %if.end15 ]
  %71 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %71, i64 0, i32 6
  %72 = load ptr, ptr %nodes_black_list, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %72, i64 0, i32 2
  %73 = load i64, ptr %ht_used, align 8
  %arrayidx37 = getelementptr inbounds %struct.dict, ptr %72, i64 0, i32 2, i64 1
  %74 = load i64, ptr %arrayidx37, align 8
  %add38 = sub i64 0, %74
  %cmp39.not = icmp eq i64 %73, %add38
  br i1 %cmp39.not, label %if.end64, label %if.then40

if.then40:                                        ; preds = %if.end34
  %call42 = tail call ptr @dictGetIterator(ptr noundef nonnull %72) #33
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %if.end60, %if.then40
  %cursor.5.ph = phi ptr [ %cursor.6, %if.end60 ], [ %cursor.4, %if.then40 ]
  %totlen.2.ph = phi i32 [ %add62, %if.end60 ], [ %totlen.1, %if.then40 ]
  %extensions.2.ph = phi i16 [ %inc63, %if.end60 ], [ %extensions.1, %if.then40 ]
  %cursor.5.ph.fr = freeze ptr %cursor.5.ph
  %cmp45.not = icmp eq ptr %cursor.5.ph.fr, null
  br i1 %cmp45.not, label %while.cond.outer.split.us, label %while.cond

while.cond.outer.split.us:                        ; preds = %while.cond.outer
  %call43.us = tail call ptr @dictNext(ptr noundef %call42) #33
  %cmp44.not.us = icmp eq ptr %call43.us, null
  br i1 %cmp44.not.us, label %while.end, label %if.end60

while.cond:                                       ; preds = %while.cond.outer, %while.body
  %call43 = tail call ptr @dictNext(ptr noundef %call42) #33
  %cmp44.not = icmp eq ptr %call43, null
  br i1 %cmp44.not, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %call47 = tail call i64 @dictGetUnsignedIntegerVal(ptr noundef nonnull %call43) #33
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %cmp48 = icmp slt i64 %call47, %atomic-load
  br i1 %cmp48, label %while.cond, label %if.end50, !llvm.loop !42

if.end50:                                         ; preds = %while.body
  %atomic-load51 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %sub = sub i64 %call47, %atomic-load51
  %call.i218 = tail call zeroext i16 @htons(i16 noundef zeroext 2) #36
  %type1.i219 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %cursor.5.ph.fr, i64 0, i32 1
  store i16 %call.i218, ptr %type1.i219, align 4
  %call2.i220 = tail call i32 @htonl(i32 noundef 56) #36
  store i32 %call2.i220, ptr %cursor.5.ph.fr, align 8
  %ext4.i221 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %cursor.5.ph.fr, i64 0, i32 3
  %call56 = tail call ptr @dictGetKey(ptr noundef nonnull %call43) #33
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %ext4.i221, ptr noundef nonnull align 1 dereferenceable(40) %call56, i64 40, i1 false)
  %call57 = tail call i64 @intrev64(i64 noundef %sub) #33
  %ttl58 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %cursor.5.ph.fr, i64 6
  store i64 %call57, ptr %ttl58, align 8
  %75 = load i32, ptr %cursor.5.ph.fr, align 8
  %call.i222 = tail call i32 @ntohl(i32 noundef %75) #36
  %idx.ext.i223 = zext i32 %call.i222 to i64
  %add.ptr.i224 = getelementptr inbounds i8, ptr %cursor.5.ph.fr, i64 %idx.ext.i223
  br label %if.end60

if.end60:                                         ; preds = %while.cond.outer.split.us, %if.end50
  %cursor.6 = phi ptr [ %add.ptr.i224, %if.end50 ], [ null, %while.cond.outer.split.us ]
  %add62 = add i32 %totlen.2.ph, 56
  %inc63 = add i16 %extensions.2.ph, 1
  br label %while.cond.outer, !llvm.loop !42

while.end:                                        ; preds = %while.cond.outer.split.us, %while.cond
  tail call void @dictReleaseIterator(ptr noundef %call42) #33
  br label %if.end64

if.end64:                                         ; preds = %while.end, %if.end34
  %cursor.7 = phi ptr [ %cursor.5.ph.fr, %while.end ], [ %cursor.4, %if.end34 ]
  %totlen.3 = phi i32 [ %totlen.2.ph, %while.end ], [ %totlen.1, %if.end34 ]
  %extensions.3 = phi i16 [ %extensions.2.ph, %while.end ], [ %extensions.1, %if.end34 ]
  %cmp65.not = icmp eq ptr %cursor.7, null
  br i1 %cmp65.not, label %if.end74, label %if.then66

if.then66:                                        ; preds = %if.end64
  %call.i225 = tail call zeroext i16 @htons(i16 noundef zeroext 3) #36
  %type1.i226 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %cursor.7, i64 0, i32 1
  store i16 %call.i225, ptr %type1.i226, align 4
  %call2.i227 = tail call i32 @htonl(i32 noundef 48) #36
  store i32 %call2.i227, ptr %cursor.7, align 8
  %ext4.i228 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %cursor.7, i64 0, i32 3
  %76 = load ptr, ptr @myself, align 8
  %shard_id71 = getelementptr inbounds %struct._clusterNode, ptr %76, i64 0, i32 2
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(40) %ext4.i228, ptr noundef nonnull align 8 dereferenceable(40) %shard_id71, i64 40, i1 false)
  br label %if.end74

if.end74:                                         ; preds = %if.then66, %if.end64
  %inc77 = add i16 %extensions.3, 1
  br i1 %cmp.not, label %if.end89, label %if.then79

if.then79:                                        ; preds = %if.end74
  %cmp80.not = icmp eq i16 %inc77, 0
  br i1 %cmp80.not, label %if.end86, label %if.then82

if.then82:                                        ; preds = %if.then79
  %mflags = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 19
  %77 = load i8, ptr %mflags, align 1
  %78 = or i8 %77, 4
  store i8 %78, ptr %mflags, align 1
  br label %if.end86

if.end86:                                         ; preds = %if.then82, %if.then79
  %call87 = tail call zeroext i16 @htons(i16 noundef zeroext %inc77) #36
  %extensions88 = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 13
  store i16 %call87, ptr %extensions88, align 2
  br label %if.end89

if.end89:                                         ; preds = %if.end86, %if.end74
  %add76 = add i32 %totlen.3, 48
  ret i32 %add76
}

declare ptr @dictGetIterator(ptr noundef) local_unnamed_addr #1

declare i64 @intrev64(i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterProcessPingExtensions(ptr noundef %hdr, ptr nocapture noundef readonly %link) local_unnamed_addr #2 {
entry:
  %node = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 8
  %0 = load ptr, ptr %node, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  %sender2 = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 9
  %call.i = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %sender2, i32 noundef 40) #33
  %cmp.not.i = icmp eq i32 %call.i, 0
  br i1 %cmp.not.i, label %if.end.i, label %cond.end

if.end.i:                                         ; preds = %cond.false
  %call1.i = tail call ptr @sdsnewlen(ptr noundef nonnull %sender2, i64 noundef 40) #33
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %nodes.i, align 8
  %call2.i = tail call ptr @dictFind(ptr noundef %2, ptr noundef %call1.i) #33
  tail call void @sdsfree(ptr noundef %call1.i) #33
  %cmp3.i = icmp eq ptr %call2.i, null
  br i1 %cmp3.i, label %cond.end, label %if.end6.i

if.end6.i:                                        ; preds = %if.end.i
  %call7.i = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i) #33
  br label %cond.end

cond.end:                                         ; preds = %if.end6.i, %if.end.i, %cond.false, %entry
  %cond = phi ptr [ %0, %entry ], [ %call7.i, %if.end6.i ], [ null, %cond.false ], [ null, %if.end.i ]
  %extensions3 = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 13
  %3 = load i16, ptr %extensions3, align 2
  %call4 = tail call zeroext i16 @ntohs(i16 noundef zeroext %3) #36
  %tobool7.not36 = icmp eq i16 %call4, 0
  br i1 %tobool7.not36, label %while.end, label %while.body.preheader

while.body.preheader:                             ; preds = %cond.end
  %data.i = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 20
  %count = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 5
  %4 = load i16, ptr %count, align 2
  %call5 = tail call zeroext i16 @ntohs(i16 noundef zeroext %4) #36
  %idxprom.i = zext i16 %call5 to i64
  %arrayidx.i = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data.i, i64 0, i64 %idxprom.i
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %if.end61
  %dec41.in = phi i16 [ %dec41, %if.end61 ], [ %call4, %while.body.preheader ]
  %ext_hostname.040 = phi ptr [ %ext_hostname.1, %if.end61 ], [ null, %while.body.preheader ]
  %ext_humannodename.039 = phi ptr [ %ext_humannodename.1, %if.end61 ], [ null, %while.body.preheader ]
  %ext_shardid.038 = phi ptr [ %ext_shardid.1, %if.end61 ], [ null, %while.body.preheader ]
  %ext.037 = phi ptr [ %add.ptr.i, %if.end61 ], [ %arrayidx.i, %while.body.preheader ]
  %dec41 = add i16 %dec41.in, -1
  %type8 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %ext.037, i64 0, i32 1
  %5 = load i16, ptr %type8, align 4
  %call9 = tail call zeroext i16 @ntohs(i16 noundef zeroext %5) #36
  %conv10 = zext i16 %call9 to i32
  switch i16 %call9, label %do.body [
    i16 0, label %if.then
    i16 1, label %if.then17
    i16 2, label %if.then25
    i16 3, label %if.then48
  ]

if.then:                                          ; preds = %while.body
  %ext12 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %ext.037, i64 0, i32 3
  br label %if.end61

if.then17:                                        ; preds = %while.body
  %ext18 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %ext.037, i64 0, i32 3
  br label %if.end61

if.then25:                                        ; preds = %while.body
  %ext26 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %ext.037, i64 0, i32 3
  %call.i22 = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %ext26, i32 noundef 40) #33
  %cmp.not.i23 = icmp eq i32 %call.i22, 0
  br i1 %cmp.not.i23, label %if.end.i25, label %if.end61

if.end.i25:                                       ; preds = %if.then25
  %call1.i26 = tail call ptr @sdsnewlen(ptr noundef nonnull %ext26, i64 noundef 40) #33
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i27 = getelementptr inbounds %struct.clusterState, ptr %6, i64 0, i32 4
  %7 = load ptr, ptr %nodes.i27, align 8
  %call2.i28 = tail call ptr @dictFind(ptr noundef %7, ptr noundef %call1.i26) #33
  tail call void @sdsfree(ptr noundef %call1.i26) #33
  %cmp3.i29 = icmp eq ptr %call2.i28, null
  br i1 %cmp3.i29, label %if.end61, label %clusterLookupNode.exit32

clusterLookupNode.exit32:                         ; preds = %if.end.i25
  %call7.i31 = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i28) #33
  %tobool30.not = icmp eq ptr %call7.i31, null
  br i1 %tobool30.not, label %if.end61, label %land.lhs.true

land.lhs.true:                                    ; preds = %clusterLookupNode.exit32
  %8 = load ptr, ptr @myself, align 8
  %cmp31.not = icmp eq ptr %call7.i31, %8
  br i1 %cmp31.not, label %if.end61, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %land.lhs.true
  %flags = getelementptr inbounds %struct._clusterNode, ptr %8, i64 0, i32 3
  %9 = load i32, ptr %flags, align 8
  %and = and i32 %9, 2
  %tobool34.not = icmp eq i32 %and, 0
  br i1 %tobool34.not, label %if.then38, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %land.lhs.true33
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %8, i64 0, i32 11
  %10 = load ptr, ptr %slaveof, align 8
  %cmp36 = icmp eq ptr %10, %call7.i31
  br i1 %cmp36, label %if.end61, label %if.then38

if.then38:                                        ; preds = %land.lhs.true35, %land.lhs.true33
  %call41 = tail call ptr @sdsnewlen(ptr noundef nonnull %ext26, i64 noundef 40) #33
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %11, i64 0, i32 6
  %12 = load ptr, ptr %nodes_black_list, align 8
  %call42 = tail call ptr @dictAddOrFind(ptr noundef %12, ptr noundef %call41) #33
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %ttl = getelementptr inbounds %struct.clusterMsgPingExt, ptr %ext.037, i64 6
  %13 = load i64, ptr %ttl, align 8
  %call43 = tail call i64 @intrev64(i64 noundef %13) #33
  %add = add i64 %call43, %atomic-load
  tail call void @dictSetUnsignedIntegerVal(ptr noundef %call42, i64 noundef %add) #33
  tail call void @clusterDelNode(ptr noundef nonnull %call7.i31)
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 22
  %15 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %15, 6
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %if.end61

if.then48:                                        ; preds = %while.body
  %ext49 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %ext.037, i64 0, i32 3
  br label %if.end61

do.body:                                          ; preds = %while.body
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp53 = icmp sgt i32 %16, 3
  br i1 %cmp53, label %if.end61, label %if.end56

if.end56:                                         ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.80, i32 noundef %conv10) #33
  br label %if.end61

if.end61:                                         ; preds = %if.end.i25, %if.then25, %if.then17, %if.then48, %do.body, %if.end56, %clusterLookupNode.exit32, %land.lhs.true, %land.lhs.true35, %if.then38, %if.then
  %ext_shardid.1 = phi ptr [ %ext_shardid.038, %if.then ], [ %ext_shardid.038, %if.then17 ], [ %ext_shardid.038, %land.lhs.true35 ], [ %ext_shardid.038, %if.then38 ], [ %ext_shardid.038, %land.lhs.true ], [ %ext_shardid.038, %clusterLookupNode.exit32 ], [ %ext49, %if.then48 ], [ %ext_shardid.038, %do.body ], [ %ext_shardid.038, %if.end56 ], [ %ext_shardid.038, %if.then25 ], [ %ext_shardid.038, %if.end.i25 ]
  %ext_humannodename.1 = phi ptr [ %ext_humannodename.039, %if.then ], [ %ext18, %if.then17 ], [ %ext_humannodename.039, %land.lhs.true35 ], [ %ext_humannodename.039, %if.then38 ], [ %ext_humannodename.039, %land.lhs.true ], [ %ext_humannodename.039, %clusterLookupNode.exit32 ], [ %ext_humannodename.039, %if.then48 ], [ %ext_humannodename.039, %do.body ], [ %ext_humannodename.039, %if.end56 ], [ %ext_humannodename.039, %if.then25 ], [ %ext_humannodename.039, %if.end.i25 ]
  %ext_hostname.1 = phi ptr [ %ext12, %if.then ], [ %ext_hostname.040, %if.then17 ], [ %ext_hostname.040, %land.lhs.true35 ], [ %ext_hostname.040, %if.then38 ], [ %ext_hostname.040, %land.lhs.true ], [ %ext_hostname.040, %clusterLookupNode.exit32 ], [ %ext_hostname.040, %if.then48 ], [ %ext_hostname.040, %do.body ], [ %ext_hostname.040, %if.end56 ], [ %ext_hostname.040, %if.then25 ], [ %ext_hostname.040, %if.end.i25 ]
  %ext.val.i = load i32, ptr %ext.037, align 8
  %call.i.i = tail call i32 @ntohl(i32 noundef %ext.val.i) #36
  %idx.ext.i = zext i32 %call.i.i to i64
  %add.ptr.i = getelementptr inbounds i8, ptr %ext.037, i64 %idx.ext.i
  %tobool7.not = icmp eq i16 %dec41, 0
  br i1 %tobool7.not, label %while.end, label %while.body, !llvm.loop !43

while.end:                                        ; preds = %if.end61, %cond.end
  %ext_shardid.0.lcssa = phi ptr [ null, %cond.end ], [ %ext_shardid.1, %if.end61 ]
  %ext_humannodename.0.lcssa = phi ptr [ null, %cond.end ], [ %ext_humannodename.1, %if.end61 ]
  %ext_hostname.0.lcssa = phi ptr [ null, %cond.end ], [ %ext_hostname.1, %if.end61 ]
  tail call fastcc void @updateAnnouncedHostname(ptr noundef %cond, ptr noundef %ext_hostname.0.lcssa)
  tail call fastcc void @updateAnnouncedHumanNodename(ptr noundef %cond, ptr noundef %ext_humannodename.0.lcssa)
  tail call fastcc void @updateShardId(ptr noundef %cond, ptr noundef %ext_shardid.0.lcssa)
  ret void
}

declare ptr @dictAddOrFind(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define internal fastcc void @updateShardId(ptr noundef %node, ptr noundef %shard_id) unnamed_addr #2 {
entry:
  %tobool.not = icmp eq ptr %shard_id, null
  br i1 %tobool.not, label %if.end18, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %shard_id1 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 2
  %bcmp = tail call i32 @bcmp(ptr noundef nonnull dereferenceable(40) %shard_id1, ptr noundef nonnull dereferenceable(40) %shard_id, i64 40)
  %cmp.not = icmp eq i32 %bcmp, 0
  br i1 %cmp.not, label %land.lhs.true5, label %if.then

if.then:                                          ; preds = %land.lhs.true
  tail call void @clusterRemoveNodeFromShard(ptr noundef %node)
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %shard_id1, ptr noundef nonnull align 1 dereferenceable(40) %shard_id, i64 40, i1 false)
  tail call void @clusterAddNodeToShard(ptr noundef nonnull %shard_id, ptr noundef %node)
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 22
  %1 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %1, 4
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true, %if.then
  %2 = load ptr, ptr @myself, align 8
  %cmp6.not = icmp eq ptr %2, %node
  br i1 %cmp6.not, label %if.end18, label %land.lhs.true7

land.lhs.true7:                                   ; preds = %land.lhs.true5
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 11
  %3 = load ptr, ptr %slaveof, align 8
  %cmp8 = icmp eq ptr %3, %node
  br i1 %cmp8, label %if.then9, label %if.end18

if.then9:                                         ; preds = %land.lhs.true7
  %shard_id10 = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 2
  %bcmp13 = tail call i32 @bcmp(ptr noundef nonnull dereferenceable(40) %shard_id10, ptr noundef nonnull dereferenceable(40) %shard_id, i64 40)
  %cmp13.not = icmp eq i32 %bcmp13, 0
  br i1 %cmp13.not, label %if.end18, label %if.then14

if.then14:                                        ; preds = %if.then9
  tail call void @clusterRemoveNodeFromShard(ptr noundef nonnull %2)
  %4 = load ptr, ptr @myself, align 8
  %shard_id15 = getelementptr inbounds %struct._clusterNode, ptr %4, i64 0, i32 2
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %shard_id15, ptr noundef nonnull align 1 dereferenceable(40) %shard_id, i64 40, i1 false)
  tail call void @clusterAddNodeToShard(ptr noundef nonnull %shard_id, ptr noundef %4)
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i14 = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 22
  %6 = load i32, ptr %todo_before_sleep.i14, align 8
  %or.i15 = or i32 %6, 12
  store i32 %or.i15, ptr %todo_before_sleep.i14, align 8
  br label %if.end18

if.end18:                                         ; preds = %entry, %if.then9, %if.then14, %land.lhs.true7, %land.lhs.true5
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterProcessPacket(ptr noundef %link) local_unnamed_addr #2 {
entry:
  %ip254 = alloca [46 x i8], align 16
  %rcvbuf = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 5
  %0 = load ptr, ptr %rcvbuf, align 8
  %totlen1 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 1
  %1 = load i32, ptr %totlen1, align 4
  %call = tail call i32 @ntohl(i32 noundef %1) #36
  %type2 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 4
  %2 = load i16, ptr %type2, align 4
  %call3 = tail call zeroext i16 @ntohs(i16 noundef zeroext %2) #36
  %call4 = tail call i64 @mstime() #33
  %conv = zext i16 %call3 to i32
  %cmp = icmp ult i16 %call3, 11
  br i1 %cmp, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom = zext nneg i16 %call3 to i64
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 24, i64 %idxprom
  %4 = load i64, ptr %arrayidx, align 8
  %inc = add nsw i64 %4, 1
  store i64 %inc, ptr %arrayidx, align 8
  br label %do.body

do.body:                                          ; preds = %entry, %if.then
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp6 = icmp sgt i32 %5, 0
  br i1 %cmp6, label %do.end, label %if.end9

if.end9:                                          ; preds = %do.body
  %6 = icmp ult i16 %call3, 11
  br i1 %6, label %switch.lookup, label %clusterGetMessageTypeString.exit

switch.lookup:                                    ; preds = %if.end9
  %7 = zext nneg i16 %call3 to i64
  %switch.gep = getelementptr inbounds [11 x ptr], ptr @switch.table.genClusterInfoString.15, i64 0, i64 %7
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %clusterGetMessageTypeString.exit

clusterGetMessageTypeString.exit:                 ; preds = %if.end9, %switch.lookup
  %retval.0.i = phi ptr [ %switch.load, %switch.lookup ], [ @.str.179, %if.end9 ]
  %conv12 = zext i32 %call to i64
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.81, ptr noundef nonnull %retval.0.i, i64 noundef %conv12) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %clusterGetMessageTypeString.exit
  %cmp13 = icmp ult i32 %call, 16
  br i1 %cmp13, label %return, label %if.end16

if.end16:                                         ; preds = %do.end
  %conv17 = zext i32 %call to i64
  %rcvbuf_len = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 6
  %8 = load i64, ptr %rcvbuf_len, align 8
  %cmp18 = icmp ult i64 %8, %conv17
  br i1 %cmp18, label %return, label %if.end21

if.end21:                                         ; preds = %if.end16
  %ver = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 2
  %9 = load i16, ptr %ver, align 8
  %call22 = tail call zeroext i16 @ntohs(i16 noundef zeroext %9) #36
  %cmp24.not = icmp eq i16 %call22, 1
  br i1 %cmp24.not, label %if.end27, label %return

if.end27:                                         ; preds = %if.end21
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 384), align 8
  %cmp29 = icmp eq i32 %10, %conv
  br i1 %cmp29, label %do.body32, label %if.end38

do.body32:                                        ; preds = %if.end27
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp33 = icmp sgt i32 %11, 3
  br i1 %cmp33, label %return, label %if.end36

if.end36:                                         ; preds = %do.body32
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.82) #33
  br label %return

if.end38:                                         ; preds = %if.end27
  %flags39 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 17
  %12 = load i16, ptr %flags39, align 2
  %call40 = tail call zeroext i16 @ntohs(i16 noundef zeroext %12) #36
  %extensions41 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 13
  %13 = load i16, ptr %extensions41, align 2
  %call42 = tail call zeroext i16 @ntohs(i16 noundef zeroext %13) #36
  %cmp44 = icmp eq i16 %call3, 0
  %cmp47 = icmp eq i16 %call3, 1
  %cmp51 = icmp eq i16 %call3, 2
  %or.cond1 = icmp ult i16 %call3, 3
  br i1 %or.cond1, label %if.then53, label %if.else

if.then53:                                        ; preds = %if.end38
  %count54 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 5
  %14 = load i16, ptr %count54, align 2
  %call55 = tail call zeroext i16 @ntohs(i16 noundef zeroext %14) #36
  %conv56 = zext i16 %call55 to i32
  %mul = mul nuw nsw i32 %conv56, 104
  %add = add nuw nsw i32 %mul, 2256
  %mflags = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 19
  %15 = load i8, ptr %mflags, align 1
  %16 = and i8 %15, 4
  %tobool.not = icmp eq i8 %16, 0
  %tobool64.not364 = icmp eq i16 %call42, 0
  %or.cond379 = select i1 %tobool.not, i1 true, i1 %tobool64.not364
  br i1 %or.cond379, label %if.end166, label %while.body.preheader

while.body.preheader:                             ; preds = %if.then53
  %data.i = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20
  %idxprom.i = zext i16 %call55 to i64
  %arrayidx.i = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data.i, i64 0, i64 %idxprom.i
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %if.end94
  %dec367.in = phi i16 [ %dec367, %if.end94 ], [ %call42, %while.body.preheader ]
  %explen.0366 = phi i32 [ %add96, %if.end94 ], [ %add, %while.body.preheader ]
  %ext.0365 = phi ptr [ %add.ptr.i, %if.end94 ], [ %arrayidx.i, %while.body.preheader ]
  %dec367 = add i16 %dec367.in, -1
  %ext.0.val = load i32, ptr %ext.0365, align 8
  %call.i = tail call i32 @ntohl(i32 noundef %ext.0.val) #36
  %conv67 = and i32 %call.i, 65535
  %rem = and i32 %call.i, 7
  %cmp68.not = icmp eq i32 %rem, 0
  br i1 %cmp68.not, label %if.end80, label %do.body71

do.body71:                                        ; preds = %while.body
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp72 = icmp sgt i32 %17, 3
  br i1 %cmp72, label %return, label %if.end75

if.end75:                                         ; preds = %do.body71
  %call77 = tail call ptr @clusterGetMessageTypeString(i32 noundef %conv)
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.83, ptr noundef nonnull %call77, i32 noundef %conv67) #33
  br label %return

if.end80:                                         ; preds = %while.body
  %sub = sub i32 %call, %explen.0366
  %cmp82 = icmp ult i32 %sub, %conv67
  br i1 %cmp82, label %do.body85, label %if.end94

do.body85:                                        ; preds = %if.end80
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp86 = icmp sgt i32 %18, 3
  br i1 %cmp86, label %return, label %if.end89

if.end89:                                         ; preds = %do.body85
  %call91 = tail call ptr @clusterGetMessageTypeString(i32 noundef %conv)
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.84, ptr noundef nonnull %call91, i64 noundef %conv17) #33
  br label %return

if.end94:                                         ; preds = %if.end80
  %add96 = add i32 %conv67, %explen.0366
  %idx.ext.i = zext i32 %call.i to i64
  %add.ptr.i = getelementptr inbounds i8, ptr %ext.0365, i64 %idx.ext.i
  %tobool64.not = icmp eq i16 %dec367, 0
  br i1 %tobool64.not, label %if.end166, label %while.body, !llvm.loop !44

if.else:                                          ; preds = %if.end38
  switch i16 %call3, label %if.end180 [
    i16 3, label %if.end166
    i16 10, label %if.then114
    i16 4, label %if.then114
    i16 8, label %if.end166.fold.split
    i16 6, label %if.end166.fold.split
    i16 5, label %if.end166.fold.split
    i16 7, label %if.then143
    i16 9, label %if.then151
  ]

if.then114:                                       ; preds = %if.else, %if.else
  %data = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20
  %19 = load i32, ptr %data, align 8
  %call115 = tail call i32 @ntohl(i32 noundef %19) #36
  %message_len = getelementptr inbounds i8, ptr %0, i64 2260
  %20 = load i32, ptr %message_len, align 4
  %call120 = tail call i32 @ntohl(i32 noundef %20) #36
  %add122 = add i32 %call115, 2264
  %add124 = add i32 %add122, %call120
  br label %if.end166

if.then143:                                       ; preds = %if.else
  br label %if.end166

if.then151:                                       ; preds = %if.else
  %len = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20, i32 0, i32 0, i32 1
  %21 = load i32, ptr %len, align 8
  %call154 = tail call i32 @ntohl(i32 noundef %21) #36
  %add158 = add i32 %call154, 2269
  br label %if.end166

if.end166.fold.split:                             ; preds = %if.else, %if.else, %if.else
  br label %if.end166

if.end166:                                        ; preds = %if.end94, %if.else, %if.end166.fold.split, %if.then151, %if.then143, %if.then114, %if.then53
  %explen.1 = phi i32 [ %add, %if.then53 ], [ %add124, %if.then114 ], [ 4352, %if.then143 ], [ %add158, %if.then151 ], [ 2296, %if.else ], [ 2256, %if.end166.fold.split ], [ %add96, %if.end94 ]
  %cmp167.not = icmp eq i32 %call, %explen.1
  br i1 %cmp167.not, label %if.end180, label %do.body170

do.body170:                                       ; preds = %if.end166
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp171 = icmp sgt i32 %22, 3
  br i1 %cmp171, label %return, label %if.end174

if.end174:                                        ; preds = %do.body170
  %call176 = tail call ptr @clusterGetMessageTypeString(i32 noundef %conv)
  %conv178 = zext i32 %explen.1 to i64
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.85, ptr noundef nonnull %call176, i64 noundef %conv17, i64 noundef %conv178) #33
  br label %return

if.end180:                                        ; preds = %if.else, %if.end166
  %node.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 8
  %23 = load ptr, ptr %node.i, align 8
  %tobool.not.i = icmp eq ptr %23, null
  br i1 %tobool.not.i, label %if.else.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end180
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %23, i64 0, i32 3
  %24 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %24, 32
  %tobool2.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool2.not.i, label %if.then183, label %if.else.i

if.else.i:                                        ; preds = %land.lhs.true.i, %if.end180
  %sender4.i = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 9
  %call.i.i282 = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %sender4.i, i32 noundef 40) #33
  %cmp.not.i.i = icmp eq i32 %call.i.i282, 0
  br i1 %cmp.not.i.i, label %if.end.i.i, label %if.end233

if.end.i.i:                                       ; preds = %if.else.i
  %call1.i.i = tail call ptr @sdsnewlen(ptr noundef nonnull %sender4.i, i64 noundef 40) #33
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i.i = getelementptr inbounds %struct.clusterState, ptr %25, i64 0, i32 4
  %26 = load ptr, ptr %nodes.i.i, align 8
  %call2.i.i = tail call ptr @dictFind(ptr noundef %26, ptr noundef %call1.i.i) #33
  tail call void @sdsfree(ptr noundef %call1.i.i) #33
  %cmp3.i.i = icmp eq ptr %call2.i.i, null
  br i1 %cmp3.i.i, label %if.end233, label %clusterLookupNode.exit.i

clusterLookupNode.exit.i:                         ; preds = %if.end.i.i
  %call7.i.i = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i.i) #33
  %tobool5.not.i = icmp eq ptr %call7.i.i, null
  br i1 %tobool5.not.i, label %if.end233, label %land.lhs.true6.i

land.lhs.true6.i:                                 ; preds = %clusterLookupNode.exit.i
  %27 = load ptr, ptr %node.i, align 8
  %tobool8.not.i = icmp eq ptr %27, null
  br i1 %tobool8.not.i, label %if.then9.i, label %if.then183

if.then9.i:                                       ; preds = %land.lhs.true6.i
  tail call void @setClusterNodeToInboundClusterLink(ptr noundef nonnull %call7.i.i, ptr noundef nonnull %link)
  br label %if.then183

if.then183:                                       ; preds = %if.then9.i, %land.lhs.true6.i, %land.lhs.true.i
  %sender.0.i = phi ptr [ %call7.i.i, %land.lhs.true6.i ], [ %call7.i.i, %if.then9.i ], [ %23, %land.lhs.true.i ]
  %data_received = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i, i64 0, i32 15
  store i64 %call4, ptr %data_received, align 8
  %flags186 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i, i64 0, i32 3
  %28 = load i32, ptr %flags186, align 8
  %and187 = and i32 %28, 32
  %tobool188.not = icmp eq i32 %and187, 0
  br i1 %tobool188.not, label %if.then189, label %if.end233

if.then189:                                       ; preds = %if.then183
  %currentEpoch = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 6
  %29 = load i64, ptr %currentEpoch, align 8
  %call190 = tail call i64 @intrev64(i64 noundef %29) #33
  %configEpoch = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 7
  %30 = load i64, ptr %configEpoch, align 8
  %call191 = tail call i64 @intrev64(i64 noundef %30) #33
  %31 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch192 = getelementptr inbounds %struct.clusterState, ptr %31, i64 0, i32 1
  %32 = load i64, ptr %currentEpoch192, align 8
  %cmp193 = icmp ugt i64 %call190, %32
  br i1 %cmp193, label %if.then195, label %if.end197

if.then195:                                       ; preds = %if.then189
  store i64 %call190, ptr %currentEpoch192, align 8
  br label %if.end197

if.end197:                                        ; preds = %if.then195, %if.then189
  %configEpoch198 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i, i64 0, i32 4
  %33 = load i64, ptr %configEpoch198, align 8
  %cmp199 = icmp ugt i64 %call191, %33
  br i1 %cmp199, label %if.then201, label %if.end203

if.then201:                                       ; preds = %if.end197
  store i64 %call191, ptr %configEpoch198, align 8
  %34 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %34, i64 0, i32 22
  %35 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %35, 12
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %if.end203

if.end203:                                        ; preds = %if.then201, %if.end197
  %offset = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 8
  %36 = load i64, ptr %offset, align 8
  %call204 = tail call i64 @intrev64(i64 noundef %36) #33
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i, i64 0, i32 20
  store i64 %call204, ptr %repl_offset, align 8
  %repl_offset_time = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i, i64 0, i32 18
  store i64 %call4, ptr %repl_offset_time, align 8
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %37, i64 0, i32 17
  %38 = load i64, ptr %mf_end, align 8
  %tobool205.not = icmp eq i64 %38, 0
  br i1 %tobool205.not, label %if.end233, label %land.lhs.true206

land.lhs.true206:                                 ; preds = %if.end203
  %39 = load ptr, ptr @myself, align 8
  %flags207 = getelementptr inbounds %struct._clusterNode, ptr %39, i64 0, i32 3
  %40 = load i32, ptr %flags207, align 8
  %and208 = and i32 %40, 2
  %tobool209.not = icmp eq i32 %and208, 0
  br i1 %tobool209.not, label %if.end233, label %land.lhs.true210

land.lhs.true210:                                 ; preds = %land.lhs.true206
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %39, i64 0, i32 11
  %41 = load ptr, ptr %slaveof, align 8
  %cmp211 = icmp eq ptr %41, %sender.0.i
  br i1 %cmp211, label %land.lhs.true213, label %if.end233

land.lhs.true213:                                 ; preds = %land.lhs.true210
  %mflags214 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 19
  %42 = load i8, ptr %mflags214, align 1
  %43 = and i8 %42, 1
  %tobool218.not = icmp eq i8 %43, 0
  br i1 %tobool218.not, label %if.end233, label %land.lhs.true219

land.lhs.true219:                                 ; preds = %land.lhs.true213
  %mf_master_offset = getelementptr inbounds %struct.clusterState, ptr %37, i64 0, i32 19
  %44 = load i64, ptr %mf_master_offset, align 8
  %cmp220 = icmp eq i64 %44, -1
  br i1 %cmp220, label %if.then222, label %if.end233

if.then222:                                       ; preds = %land.lhs.true219
  store i64 %call204, ptr %mf_master_offset, align 8
  %todo_before_sleep.i283 = getelementptr inbounds %struct.clusterState, ptr %37, i64 0, i32 22
  %45 = load i32, ptr %todo_before_sleep.i283, align 8
  %or.i284 = or i32 %45, 16
  store i32 %or.i284, ptr %todo_before_sleep.i283, align 8
  %46 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp226 = icmp sgt i32 %46, 2
  br i1 %cmp226, label %if.end233, label %if.end229

if.end229:                                        ; preds = %if.then222
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.86, i64 noundef %call204) #33
  br label %if.end233

if.end233:                                        ; preds = %if.end.i.i, %if.else.i, %clusterLookupNode.exit.i, %if.end203, %land.lhs.true206, %land.lhs.true210, %land.lhs.true213, %land.lhs.true219, %if.then222, %if.end229, %if.then183
  %tobool182.not335 = phi i1 [ false, %if.then183 ], [ false, %if.then222 ], [ false, %if.end229 ], [ false, %land.lhs.true219 ], [ false, %land.lhs.true213 ], [ false, %land.lhs.true210 ], [ false, %land.lhs.true206 ], [ false, %if.end203 ], [ true, %clusterLookupNode.exit.i ], [ true, %if.else.i ], [ true, %if.end.i.i ]
  %sender.0.i334 = phi ptr [ %sender.0.i, %if.then183 ], [ %sender.0.i, %if.then222 ], [ %sender.0.i, %if.end229 ], [ %sender.0.i, %land.lhs.true219 ], [ %sender.0.i, %land.lhs.true213 ], [ %sender.0.i, %land.lhs.true210 ], [ %sender.0.i, %land.lhs.true206 ], [ %sender.0.i, %if.end203 ], [ null, %clusterLookupNode.exit.i ], [ null, %if.else.i ], [ null, %if.end.i.i ]
  %senderConfigEpoch.0 = phi i64 [ 0, %if.then183 ], [ %call191, %if.then222 ], [ %call191, %if.end229 ], [ %call191, %land.lhs.true219 ], [ %call191, %land.lhs.true213 ], [ %call191, %land.lhs.true210 ], [ %call191, %land.lhs.true206 ], [ %call191, %if.end203 ], [ 0, %clusterLookupNode.exit.i ], [ 0, %if.else.i ], [ 0, %if.end.i.i ]
  %senderCurrentEpoch.0 = phi i64 [ 0, %if.then183 ], [ %call190, %if.then222 ], [ %call190, %if.end229 ], [ %call190, %land.lhs.true219 ], [ %call190, %land.lhs.true213 ], [ %call190, %land.lhs.true210 ], [ %call190, %land.lhs.true206 ], [ %call190, %if.end203 ], [ 0, %clusterLookupNode.exit.i ], [ 0, %if.else.i ], [ 0, %if.end.i.i ]
  switch i16 %call3, label %if.end305 [
    i16 2, label %if.then241
    i16 0, label %if.then241
  ]

if.then241:                                       ; preds = %if.end233, %if.end233
  br i1 %cmp51, label %land.lhs.true250, label %lor.lhs.false245

lor.lhs.false245:                                 ; preds = %if.then241
  %47 = load ptr, ptr @myself, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %47, i64 0, i32 21
  %48 = load i8, ptr %ip, align 8
  %cmp248 = icmp eq i8 %48, 0
  %49 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 373), align 8
  %cmp251 = icmp eq ptr %49, null
  %or.cond6 = select i1 %cmp248, i1 %cmp251, i1 false
  br i1 %or.cond6, label %if.then253, label %if.end305.thread

land.lhs.true250:                                 ; preds = %if.then241
  %.old = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 373), align 8
  %cmp251.old = icmp eq ptr %.old, null
  br i1 %cmp251.old, label %if.then253, label %if.end277

if.then253:                                       ; preds = %lor.lhs.false245, %land.lhs.true250
  %conn = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %50 = load ptr, ptr %conn, align 8
  %tobool.not.i.i = icmp eq ptr %50, null
  br i1 %tobool.not.i.i, label %if.end277, label %land.lhs.true.i.i

land.lhs.true.i.i:                                ; preds = %if.then253
  %51 = load ptr, ptr %50, align 8
  %addr.i.i = getelementptr inbounds %struct.ConnectionType, ptr %51, i64 0, i32 6
  %52 = load ptr, ptr %addr.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %52, null
  br i1 %tobool1.not.i.i, label %if.end277, label %connAddrSockName.exit

connAddrSockName.exit:                            ; preds = %land.lhs.true.i.i
  %call.i.i285 = call i32 %52(ptr noundef nonnull %50, ptr noundef nonnull %ip254, i64 noundef 46, ptr noundef null, i32 noundef 0) #33
  %cmp256.not = icmp eq i32 %call.i.i285, -1
  br i1 %cmp256.not, label %if.end277, label %land.lhs.true258

land.lhs.true258:                                 ; preds = %connAddrSockName.exit
  %53 = load ptr, ptr @myself, align 8
  %ip260 = getelementptr inbounds %struct._clusterNode, ptr %53, i64 0, i32 21
  %call262 = call i32 @strcmp(ptr noundef nonnull dereferenceable(1) %ip254, ptr noundef nonnull dereferenceable(1) %ip260) #34
  %tobool263.not = icmp eq i32 %call262, 0
  br i1 %tobool263.not, label %if.end277, label %if.then264

if.then264:                                       ; preds = %land.lhs.true258
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %ip260, ptr noundef nonnull align 16 dereferenceable(46) %ip254, i64 46, i1 false)
  %54 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp269 = icmp sgt i32 %54, 2
  br i1 %cmp269, label %do.end275, label %if.end272

if.end272:                                        ; preds = %if.then264
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.87, ptr noundef nonnull %ip260) #33
  br label %do.end275

do.end275:                                        ; preds = %if.then264, %if.end272
  %55 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i286 = getelementptr inbounds %struct.clusterState, ptr %55, i64 0, i32 22
  %56 = load i32, ptr %todo_before_sleep.i286, align 8
  %or.i287 = or i32 %56, 4
  store i32 %or.i287, ptr %todo_before_sleep.i286, align 8
  br label %if.end277

if.end277:                                        ; preds = %if.then253, %land.lhs.true.i.i, %connAddrSockName.exit, %land.lhs.true258, %do.end275, %land.lhs.true250
  %or.cond8 = select i1 %tobool182.not335, i1 %cmp51, i1 false
  br i1 %or.cond8, label %if.then283, label %if.end305.thread

if.then283:                                       ; preds = %if.end277
  %call284 = call ptr @createClusterNode(ptr noundef null, i32 noundef 32)
  %ip285 = getelementptr inbounds %struct._clusterNode, ptr %call284, i64 0, i32 21
  %myip = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 12
  %call288 = call i32 @nodeIp2String(ptr noundef nonnull %ip285, ptr noundef nonnull %link, ptr noundef nonnull %myip), !range !21
  %cmp289 = icmp eq i32 %call288, 0
  br i1 %cmp289, label %if.then303, label %cond.false

cond.false:                                       ; preds = %if.then283
  call void @_serverAssert(ptr noundef nonnull @.str.88, ptr noundef nonnull @.str.18, i32 noundef 2808) #33
  call void @abort() #35
  unreachable

if.then303:                                       ; preds = %if.then283
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %call284, i64 0, i32 25
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %call284, i64 0, i32 24
  call fastcc void @getClientPortFromClusterMsg(ptr noundef %0, ptr noundef nonnull %tls_port, ptr noundef nonnull %tcp_port)
  %cport = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 16
  %57 = load i16, ptr %cport, align 8
  %call294 = call zeroext i16 @ntohs(i16 noundef zeroext %57) #36
  %conv295 = zext i16 %call294 to i32
  %cport296 = getelementptr inbounds %struct._clusterNode, ptr %call284, i64 0, i32 26
  store i32 %conv295, ptr %cport296, align 8
  call void @clusterAddNode(ptr noundef %call284)
  %58 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i288 = getelementptr inbounds %struct.clusterState, ptr %58, i64 0, i32 22
  %59 = load i32, ptr %todo_before_sleep.i288, align 8
  %or.i289 = or i32 %59, 4
  store i32 %or.i289, ptr %todo_before_sleep.i288, align 8
  call void @clusterProcessGossipSection(ptr noundef %0, ptr noundef nonnull %link)
  br label %if.end305.thread

if.end305.thread:                                 ; preds = %if.then303, %if.end277, %lor.lhs.false245
  call void @clusterSendPing(ptr noundef nonnull %link, i32 noundef 1)
  br label %do.body318

if.end305:                                        ; preds = %if.end233
  br i1 %or.cond1, label %do.body318, label %if.else601

do.body318:                                       ; preds = %if.end305.thread, %if.end305
  %60 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp319 = icmp sgt i32 %60, 0
  br i1 %cmp319, label %do.end332, label %if.end322

if.end322:                                        ; preds = %do.body318
  %call324 = call ptr @clusterGetMessageTypeString(i32 noundef %conv)
  %61 = load ptr, ptr %node.i, align 8
  %tobool326.not = icmp eq ptr %61, null
  %name = getelementptr inbounds %struct._clusterNode, ptr %61, i64 0, i32 1
  %spec.select = select i1 %tobool326.not, ptr @.str.90, ptr %name
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.89, ptr noundef nonnull %call324, ptr noundef nonnull %spec.select) #33
  br label %do.end332

do.end332:                                        ; preds = %do.body318, %if.end322
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 9
  %62 = load i32, ptr %inbound, align 8
  %tobool333.not = icmp eq i32 %62, 0
  br i1 %tobool333.not, label %if.then334, label %if.end413

if.then334:                                       ; preds = %do.end332
  %63 = load ptr, ptr %node.i, align 8
  %flags336 = getelementptr inbounds %struct._clusterNode, ptr %63, i64 0, i32 3
  %64 = load i32, ptr %flags336, align 8
  %and337 = and i32 %64, 32
  %tobool338.not = icmp eq i32 %and337, 0
  br i1 %tobool338.not, label %if.else375, label %if.then339

if.then339:                                       ; preds = %if.then334
  br i1 %tobool182.not335, label %if.end355, label %do.body342

do.body342:                                       ; preds = %if.then339
  %65 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp343 = icmp sgt i32 %65, 1
  br i1 %cmp343, label %do.end349, label %if.end346

if.end346:                                        ; preds = %do.body342
  %name347 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 1
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 23
  %66 = load ptr, ptr %human_nodename, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.91, ptr noundef nonnull %name347, ptr noundef %66) #33
  br label %do.end349

do.end349:                                        ; preds = %do.body342, %if.end346
  %call350 = call i32 @nodeUpdateAddressIfNeeded(ptr noundef %sender.0.i334, ptr noundef nonnull %link, ptr noundef %0), !range !18
  %tobool351.not = icmp eq i32 %call350, 0
  br i1 %tobool351.not, label %if.end353, label %if.then352

if.then352:                                       ; preds = %do.end349
  %67 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i290 = getelementptr inbounds %struct.clusterState, ptr %67, i64 0, i32 22
  %68 = load i32, ptr %todo_before_sleep.i290, align 8
  %or.i291 = or i32 %68, 6
  store i32 %or.i291, ptr %todo_before_sleep.i290, align 8
  br label %if.end353

if.end353:                                        ; preds = %if.then352, %do.end349
  %69 = load ptr, ptr %node.i, align 8
  call void @clusterDelNode(ptr noundef %69)
  br label %return

if.end355:                                        ; preds = %if.then339
  %sender357 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 9
  call void @clusterRenameNode(ptr noundef nonnull %63, ptr noundef nonnull %sender357)
  %70 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp360 = icmp sgt i32 %70, 0
  br i1 %cmp360, label %if.end413.thread, label %if.end363

if.end363:                                        ; preds = %if.end355
  %71 = load ptr, ptr %node.i, align 8
  %name365 = getelementptr inbounds %struct._clusterNode, ptr %71, i64 0, i32 1
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.92, ptr noundef nonnull %name365) #33
  br label %if.end413.thread

if.end413.thread:                                 ; preds = %if.end363, %if.end355
  %72 = load ptr, ptr %node.i, align 8
  %flags369 = getelementptr inbounds %struct._clusterNode, ptr %72, i64 0, i32 3
  %73 = load i32, ptr %flags369, align 8
  %and370 = and i32 %73, -33
  store i32 %and370, ptr %flags369, align 8
  %74 = and i16 %call40, 3
  %and372 = zext nneg i16 %74 to i32
  %75 = load ptr, ptr %node.i, align 8
  %flags374 = getelementptr inbounds %struct._clusterNode, ptr %75, i64 0, i32 3
  %76 = load i32, ptr %flags374, align 8
  %or = or i32 %76, %and372
  store i32 %or, ptr %flags374, align 8
  %77 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i292 = getelementptr inbounds %struct.clusterState, ptr %77, i64 0, i32 22
  %78 = load i32, ptr %todo_before_sleep.i292, align 8
  %or.i293 = or i32 %78, 4
  store i32 %or.i293, ptr %todo_before_sleep.i292, align 8
  br label %if.end436

if.else375:                                       ; preds = %if.then334
  %name377 = getelementptr inbounds %struct._clusterNode, ptr %63, i64 0, i32 1
  %sender379 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 9
  %bcmp = call i32 @bcmp(ptr noundef nonnull dereferenceable(40) %name377, ptr noundef nonnull dereferenceable(40) %sender379, i64 40)
  %cmp382.not = icmp eq i32 %bcmp, 0
  br i1 %cmp382.not, label %if.end413, label %do.body385

do.body385:                                       ; preds = %if.else375
  %79 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp386 = icmp sgt i32 %79, 0
  br i1 %cmp386, label %do.end398, label %if.end389

if.end389:                                        ; preds = %do.body385
  %80 = load i64, ptr %63, align 8
  %sub394 = sub nsw i64 %call4, %80
  %conv395 = trunc i64 %sub394 to i32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.93, ptr noundef nonnull %name377, i32 noundef %conv395, i32 noundef %64) #33
  %.pre372 = load ptr, ptr %node.i, align 8
  %flags400.phi.trans.insert = getelementptr inbounds %struct._clusterNode, ptr %.pre372, i64 0, i32 3
  %.pre373 = load i32, ptr %flags400.phi.trans.insert, align 8
  br label %do.end398

do.end398:                                        ; preds = %do.body385, %if.end389
  %81 = phi i32 [ %64, %do.body385 ], [ %.pre373, %if.end389 ]
  %82 = phi ptr [ %63, %do.body385 ], [ %.pre372, %if.end389 ]
  %flags400 = getelementptr inbounds %struct._clusterNode, ptr %82, i64 0, i32 3
  %or401 = or i32 %81, 64
  store i32 %or401, ptr %flags400, align 8
  %83 = load ptr, ptr %node.i, align 8
  %ip403 = getelementptr inbounds %struct._clusterNode, ptr %83, i64 0, i32 21
  store i8 0, ptr %ip403, align 8
  %84 = load ptr, ptr %node.i, align 8
  %tcp_port406 = getelementptr inbounds %struct._clusterNode, ptr %84, i64 0, i32 24
  store i32 0, ptr %tcp_port406, align 8
  %85 = load ptr, ptr %node.i, align 8
  %tls_port408 = getelementptr inbounds %struct._clusterNode, ptr %85, i64 0, i32 25
  store i32 0, ptr %tls_port408, align 4
  %86 = load ptr, ptr %node.i, align 8
  %cport410 = getelementptr inbounds %struct._clusterNode, ptr %86, i64 0, i32 26
  store i32 0, ptr %cport410, align 8
  call void @freeClusterLink(ptr noundef nonnull %link)
  %87 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i294 = getelementptr inbounds %struct.clusterState, ptr %87, i64 0, i32 22
  %88 = load i32, ptr %todo_before_sleep.i294, align 8
  %or.i295 = or i32 %88, 4
  store i32 %or.i295, ptr %todo_before_sleep.i294, align 8
  br label %return

if.end413:                                        ; preds = %if.else375, %do.end332
  br i1 %tobool182.not335, label %if.end436, label %if.then415

if.then415:                                       ; preds = %if.end413
  %89 = and i16 %call40, 512
  %and417 = zext nneg i16 %89 to i32
  %flags418 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 3
  %90 = load i32, ptr %flags418, align 8
  %and419 = and i32 %90, -513
  %or421 = or disjoint i32 %and419, %and417
  store i32 %or421, ptr %flags418, align 8
  br i1 %cmp44, label %land.lhs.true428, label %if.end436

land.lhs.true428:                                 ; preds = %if.then415
  %and430 = and i32 %90, 32
  %tobool431.not = icmp eq i32 %and430, 0
  br i1 %tobool431.not, label %land.lhs.true432, label %if.then465

land.lhs.true432:                                 ; preds = %land.lhs.true428
  %call433 = call i32 @nodeUpdateAddressIfNeeded(ptr noundef nonnull %sender.0.i334, ptr noundef nonnull %link, ptr noundef %0), !range !18
  %tobool434.not = icmp eq i32 %call433, 0
  br i1 %tobool434.not, label %if.then465, label %if.then435

if.then435:                                       ; preds = %land.lhs.true432
  %91 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i296 = getelementptr inbounds %struct.clusterState, ptr %91, i64 0, i32 22
  %92 = load i32, ptr %todo_before_sleep.i296, align 8
  %or.i297 = or i32 %92, 6
  store i32 %or.i297, ptr %todo_before_sleep.i296, align 8
  br label %if.then465

if.end436:                                        ; preds = %if.end413.thread, %if.end413, %if.then415
  %93 = load i32, ptr %inbound, align 8
  %tobool438 = icmp eq i32 %93, 0
  %or.cond18 = select i1 %tobool438, i1 %cmp47, i1 false
  br i1 %or.cond18, label %if.then443, label %if.end463

if.then443:                                       ; preds = %if.end436
  %94 = load ptr, ptr %node.i, align 8
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %94, i64 0, i32 14
  store i64 %call4, ptr %pong_received, align 8
  %95 = load ptr, ptr %node.i, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %95, i64 0, i32 13
  store i64 0, ptr %ping_sent, align 8
  %96 = load ptr, ptr %node.i, align 8
  %flags447 = getelementptr inbounds %struct._clusterNode, ptr %96, i64 0, i32 3
  %97 = load i32, ptr %flags447, align 8
  %and448 = and i32 %97, 4
  %tobool449.not = icmp eq i32 %and448, 0
  br i1 %tobool449.not, label %if.else454, label %if.then450

if.then450:                                       ; preds = %if.then443
  %and453 = and i32 %97, -5
  store i32 %and453, ptr %flags447, align 8
  %98 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i298 = getelementptr inbounds %struct.clusterState, ptr %98, i64 0, i32 22
  %99 = load i32, ptr %todo_before_sleep.i298, align 8
  %or.i299 = or i32 %99, 6
  store i32 %or.i299, ptr %todo_before_sleep.i298, align 8
  br label %if.end463

if.else454:                                       ; preds = %if.then443
  %and457 = and i32 %97, 8
  %tobool458.not = icmp eq i32 %and457, 0
  br i1 %tobool458.not, label %if.end463, label %if.then459

if.then459:                                       ; preds = %if.else454
  call void @clearNodeFailureIfNeeded(ptr noundef nonnull %96)
  br label %if.end463

if.end463:                                        ; preds = %if.then450, %if.then459, %if.else454, %if.end436
  br i1 %tobool182.not335, label %return, label %if.then465

if.then465:                                       ; preds = %if.then435, %land.lhs.true432, %land.lhs.true428, %if.end463
  %slaveof466 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 11
  %bcmp280 = call i32 @bcmp(ptr noundef nonnull dereferenceable(40) %slaveof466, ptr noundef nonnull dereferenceable(40) @.str.94, i64 40)
  %tobool469.not = icmp eq i32 %bcmp280, 0
  br i1 %tobool469.not, label %if.then470, label %if.else471

if.then470:                                       ; preds = %if.then465
  call void @clusterSetNodeAsMaster(ptr noundef %sender.0.i334)
  br label %if.then502

if.else471:                                       ; preds = %if.then465
  %call474 = call ptr @clusterLookupNode(ptr noundef nonnull %slaveof466, i32 noundef 40)
  %flags.i300 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 3
  %100 = load i32, ptr %flags.i300, align 8
  %and.i301 = and i32 %100, 1
  %tobool476.not = icmp eq i32 %and.i301, 0
  br i1 %tobool476.not, label %if.end483, label %if.then477

if.then477:                                       ; preds = %if.else471
  %call478 = call i32 @clusterDelNodeSlots(ptr noundef nonnull %sender.0.i334)
  %101 = load i32, ptr %flags.i300, align 8
  %and480 = and i32 %101, -260
  %or482 = or disjoint i32 %and480, 2
  store i32 %or482, ptr %flags.i300, align 8
  %102 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i302 = getelementptr inbounds %struct.clusterState, ptr %102, i64 0, i32 22
  %103 = load i32, ptr %todo_before_sleep.i302, align 8
  %or.i303 = or i32 %103, 6
  store i32 %or.i303, ptr %todo_before_sleep.i302, align 8
  br label %if.end483

if.end483:                                        ; preds = %if.then477, %if.else471
  %tobool484.not = icmp eq ptr %call474, null
  br i1 %tobool484.not, label %if.then502, label %land.lhs.true485

land.lhs.true485:                                 ; preds = %if.end483
  %slaveof486 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 11
  %104 = load ptr, ptr %slaveof486, align 8
  %cmp487.not = icmp eq ptr %104, %call474
  br i1 %cmp487.not, label %if.then502, label %if.then489

if.then489:                                       ; preds = %land.lhs.true485
  %tobool491.not = icmp eq ptr %104, null
  br i1 %tobool491.not, label %if.end495, label %if.then492

if.then492:                                       ; preds = %if.then489
  %call494 = call i32 @clusterNodeRemoveSlave(ptr noundef nonnull %104, ptr noundef nonnull %sender.0.i334), !range !21
  br label %if.end495

if.end495:                                        ; preds = %if.then492, %if.then489
  %call496 = call i32 @clusterNodeAddSlave(ptr noundef nonnull %call474, ptr noundef nonnull %sender.0.i334), !range !21
  store ptr %call474, ptr %slaveof486, align 8
  %105 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i304 = getelementptr inbounds %struct.clusterState, ptr %105, i64 0, i32 22
  %106 = load i32, ptr %todo_before_sleep.i304, align 8
  %or.i305 = or i32 %106, 4
  store i32 %or.i305, ptr %todo_before_sleep.i304, align 8
  br label %if.then502

if.then502:                                       ; preds = %if.end483, %land.lhs.true485, %if.end495, %if.then470
  %flags.i306 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 3
  %107 = load i32, ptr %flags.i306, align 8
  %and.i307 = and i32 %107, 1
  %tobool504.not = icmp eq i32 %and.i307, 0
  br i1 %tobool504.not, label %cond.end508, label %land.lhs.true520

cond.end508:                                      ; preds = %if.then502
  %slaveof507 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 11
  %108 = load ptr, ptr %slaveof507, align 8
  %tobool510.not = icmp eq ptr %108, null
  br i1 %tobool510.not, label %land.lhs.true586, label %land.lhs.true520

land.lhs.true520:                                 ; preds = %if.then502, %cond.end508
  %cond509343 = phi ptr [ %108, %cond.end508 ], [ %sender.0.i334, %if.then502 ]
  %slots = getelementptr inbounds %struct._clusterNode, ptr %cond509343, i64 0, i32 5
  %myslots = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 10
  %bcmp281 = call i32 @bcmp(ptr noundef nonnull dereferenceable(2048) %slots, ptr noundef nonnull dereferenceable(2048) %myslots, i64 2048)
  %cmp515 = icmp ne i32 %bcmp281, 0
  %tobool522 = icmp ne i32 %and.i307, 0
  %or.cond20 = select i1 %tobool522, i1 %cmp515, i1 false
  br i1 %or.cond20, label %if.then525, label %if.end528

if.then525:                                       ; preds = %land.lhs.true520
  call void @clusterUpdateSlotsConfigWith(ptr noundef nonnull %sender.0.i334, i64 noundef %senderConfigEpoch.0, ptr noundef nonnull %myslots)
  br label %for.cond.preheader

if.end528:                                        ; preds = %land.lhs.true520
  br i1 %cmp515, label %for.cond.preheader, label %land.lhs.true586

for.cond.preheader:                               ; preds = %if.end528, %if.then525
  %109 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %109, i64 0, i32 27
  br label %for.body

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %110 = trunc i64 %indvars.iv to i32
  %div.i357358359 = lshr i64 %indvars.iv, 3
  %conv.i = and i64 %div.i357358359, 536870911
  %and.i310 = and i32 %110, 7
  %arrayidx.i311 = getelementptr inbounds i8, ptr %myslots, i64 %conv.i
  %111 = load i8, ptr %arrayidx.i311, align 1
  %conv1.i = zext i8 %111 to i32
  %112 = shl nuw nsw i32 1, %and.i310
  %113 = and i32 %112, %conv1.i
  %tobool538.not = icmp eq i32 %113, 0
  br i1 %tobool538.not, label %for.inc, label %if.then539

if.then539:                                       ; preds = %for.body
  %arrayidx542 = getelementptr inbounds %struct.clusterState, ptr %109, i64 0, i32 9, i64 %indvars.iv
  %114 = load ptr, ptr %arrayidx542, align 8
  %cmp543 = icmp eq ptr %114, %sender.0.i334
  %cmp549 = icmp eq ptr %114, null
  %or.cond = or i1 %cmp543, %cmp549
  br i1 %or.cond, label %for.inc, label %lor.lhs.false551

lor.lhs.false551:                                 ; preds = %if.then539
  %arrayidx.i315 = getelementptr inbounds i8, ptr %owner_not_claiming_slot, i64 %conv.i
  %115 = load i8, ptr %arrayidx.i315, align 1
  %conv1.i316 = zext i8 %115 to i32
  %116 = and i32 %112, %conv1.i316
  %tobool554.not = icmp eq i32 %116, 0
  br i1 %tobool554.not, label %if.end556, label %for.inc

if.end556:                                        ; preds = %lor.lhs.false551
  %configEpoch560 = getelementptr inbounds %struct._clusterNode, ptr %114, i64 0, i32 4
  %117 = load i64, ptr %configEpoch560, align 8
  %cmp561 = icmp ugt i64 %117, %senderConfigEpoch.0
  br i1 %cmp561, label %do.body564, label %for.inc

do.body564:                                       ; preds = %if.end556
  %118 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp565 = icmp sgt i32 %118, 1
  br i1 %cmp565, label %do.end576, label %if.end568

if.end568:                                        ; preds = %do.body564
  %name569 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 1
  %name574 = getelementptr inbounds %struct._clusterNode, ptr %114, i64 0, i32 1
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.95, ptr noundef nonnull %name569, ptr noundef nonnull %name574) #33
  %.pre374 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx580.phi.trans.insert = getelementptr inbounds %struct.clusterState, ptr %.pre374, i64 0, i32 9, i64 %indvars.iv
  %.pre375 = load ptr, ptr %arrayidx580.phi.trans.insert, align 8
  br label %do.end576

do.end576:                                        ; preds = %do.body564, %if.end568
  %119 = phi ptr [ %114, %do.body564 ], [ %.pre375, %if.end568 ]
  %link577 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 27
  %120 = load ptr, ptr %link577, align 8
  call void @clusterSendUpdate(ptr noundef %120, ptr noundef %119)
  br label %land.lhs.true586

for.inc:                                          ; preds = %for.body, %if.end556, %if.then539, %lor.lhs.false551
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %land.lhs.true586, label %for.body, !llvm.loop !45

land.lhs.true586:                                 ; preds = %for.inc, %cond.end508, %if.end528, %do.end576
  %121 = load ptr, ptr @myself, align 8
  %flags.i318 = getelementptr inbounds %struct._clusterNode, ptr %121, i64 0, i32 3
  %122 = load i32, ptr %flags.i318, align 8
  %and.i319 = and i32 %122, 1
  %tobool588.not = icmp eq i32 %and.i319, 0
  br i1 %tobool588.not, label %if.then599, label %land.lhs.true589

land.lhs.true589:                                 ; preds = %land.lhs.true586
  %123 = load i32, ptr %flags.i306, align 8
  %and.i321 = and i32 %123, 1
  %tobool591.not = icmp eq i32 %and.i321, 0
  br i1 %tobool591.not, label %if.then599, label %land.lhs.true592

land.lhs.true592:                                 ; preds = %land.lhs.true589
  %configEpoch593 = getelementptr inbounds %struct._clusterNode, ptr %121, i64 0, i32 4
  %124 = load i64, ptr %configEpoch593, align 8
  %cmp594 = icmp eq i64 %senderConfigEpoch.0, %124
  br i1 %cmp594, label %if.then596, label %if.then599

if.then596:                                       ; preds = %land.lhs.true592
  call void @clusterHandleConfigEpochCollision(ptr noundef nonnull %sender.0.i334)
  br label %if.then599

if.then599:                                       ; preds = %land.lhs.true586, %land.lhs.true589, %land.lhs.true592, %if.then596
  call void @clusterProcessGossipSection(ptr noundef %0, ptr noundef %link)
  call void @clusterProcessPingExtensions(ptr noundef %0, ptr noundef %link)
  br label %return

if.else601:                                       ; preds = %if.end305
  %cmp603 = icmp eq i16 %call3, 3
  br i1 %cmp603, label %if.then605, label %if.else650

if.then605:                                       ; preds = %if.else601
  br i1 %tobool182.not335, label %do.body637, label %if.then607

if.then607:                                       ; preds = %if.then605
  %data608 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20
  %call610 = tail call ptr @clusterLookupNode(ptr noundef nonnull %data608, i32 noundef 40)
  %tobool611.not = icmp eq ptr %call610, null
  br i1 %tobool611.not, label %return, label %land.lhs.true612

land.lhs.true612:                                 ; preds = %if.then607
  %flags613 = getelementptr inbounds %struct._clusterNode, ptr %call610, i64 0, i32 3
  %125 = load i32, ptr %flags613, align 8
  %and614 = and i32 %125, 24
  %tobool615.not = icmp eq i32 %and614, 0
  br i1 %tobool615.not, label %do.body617, label %return

do.body617:                                       ; preds = %land.lhs.true612
  %126 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp618 = icmp sgt i32 %126, 2
  br i1 %cmp618, label %do.end630, label %if.end621

if.end621:                                        ; preds = %do.body617
  %sender622 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 9
  %human_nodename624 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 23
  %127 = load ptr, ptr %human_nodename624, align 8
  %human_nodename629 = getelementptr inbounds %struct._clusterNode, ptr %call610, i64 0, i32 23
  %128 = load ptr, ptr %human_nodename629, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.96, ptr noundef nonnull %sender622, ptr noundef %127, ptr noundef nonnull %data608, ptr noundef %128) #33
  %.pre = load i32, ptr %flags613, align 8
  br label %do.end630

do.end630:                                        ; preds = %do.body617, %if.end621
  %129 = phi i32 [ %125, %do.body617 ], [ %.pre, %if.end621 ]
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %call610, i64 0, i32 16
  store i64 %call4, ptr %fail_time, align 8
  %or632 = and i32 %129, -13
  %and634 = or disjoint i32 %or632, 8
  store i32 %and634, ptr %flags613, align 8
  %130 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i322 = getelementptr inbounds %struct.clusterState, ptr %130, i64 0, i32 22
  %131 = load i32, ptr %todo_before_sleep.i322, align 8
  %or.i323 = or i32 %131, 6
  store i32 %or.i323, ptr %todo_before_sleep.i322, align 8
  br label %return

do.body637:                                       ; preds = %if.then605
  %132 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp638 = icmp sgt i32 %132, 2
  br i1 %cmp638, label %return, label %if.end641

if.end641:                                        ; preds = %do.body637
  %sender642 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 9
  %data644 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.97, ptr noundef nonnull %sender642, ptr noundef nonnull %data644) #33
  br label %return

if.else650:                                       ; preds = %if.else601
  %cmp652 = icmp eq i16 %call3, 4
  %cmp656 = icmp eq i16 %call3, 10
  switch i16 %call3, label %do.body816 [
    i16 10, label %if.then658
    i16 4, label %if.then658
    i16 5, label %if.then708
    i16 6, label %if.then716
    i16 8, label %if.then735
    i16 7, label %if.then759
    i16 9, label %if.then793
  ]

if.then658:                                       ; preds = %if.else650, %if.else650
  br i1 %tobool182.not335, label %return, label %if.end661

if.end661:                                        ; preds = %if.then658
  br i1 %cmp652, label %land.lhs.true667, label %lor.lhs.false671

land.lhs.true667:                                 ; preds = %if.end661
  %call668 = tail call i32 @serverPubsubSubscriptionCount() #33
  %cmp669 = icmp sgt i32 %call668, 0
  br i1 %cmp669, label %if.then679, label %return

lor.lhs.false671:                                 ; preds = %if.end661
  br i1 %cmp656, label %land.lhs.true675, label %return

land.lhs.true675:                                 ; preds = %lor.lhs.false671
  %call676 = tail call i32 @serverPubsubShardSubscriptionCount() #33
  %cmp677 = icmp sgt i32 %call676, 0
  br i1 %cmp677, label %if.then679, label %return

if.then679:                                       ; preds = %land.lhs.true675, %land.lhs.true667
  %data680 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20
  %133 = load i32, ptr %data680, align 8
  %call683 = tail call i32 @ntohl(i32 noundef %133) #36
  %message_len686 = getelementptr inbounds i8, ptr %0, i64 2260
  %134 = load i32, ptr %message_len686, align 4
  %call687 = tail call i32 @ntohl(i32 noundef %134) #36
  %bulk_data = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20, i32 0, i32 0, i32 1
  %conv691 = zext i32 %call683 to i64
  %call692 = tail call ptr @createStringObject(ptr noundef nonnull %bulk_data, i64 noundef %conv691) #33
  %add.ptr = getelementptr inbounds i8, ptr %bulk_data, i64 %conv691
  %conv697 = zext i32 %call687 to i64
  %call698 = tail call ptr @createStringObject(ptr noundef nonnull %add.ptr, i64 noundef %conv697) #33
  %conv701 = zext i1 %cmp656 to i32
  %call702 = tail call i32 @pubsubPublishMessage(ptr noundef %call692, ptr noundef %call698, i32 noundef %conv701) #33
  tail call void @decrRefCount(ptr noundef %call692) #33
  tail call void @decrRefCount(ptr noundef %call698) #33
  br label %return

if.then708:                                       ; preds = %if.else650
  br i1 %tobool182.not335, label %return, label %if.end711

if.end711:                                        ; preds = %if.then708
  tail call void @clusterSendFailoverAuthIfNeeded(ptr noundef %sender.0.i334, ptr noundef %0)
  br label %return

if.then716:                                       ; preds = %if.else650
  br i1 %tobool182.not335, label %return, label %if.end719

if.end719:                                        ; preds = %if.then716
  %flags.i324 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 3
  %135 = load i32, ptr %flags.i324, align 8
  %and.i325 = and i32 %135, 1
  %tobool721.not = icmp eq i32 %and.i325, 0
  br i1 %tobool721.not, label %return, label %land.lhs.true722

land.lhs.true722:                                 ; preds = %if.end719
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 8
  %136 = load i32, ptr %numslots, align 4
  %cmp723 = icmp sgt i32 %136, 0
  br i1 %cmp723, label %land.lhs.true725, label %return

land.lhs.true725:                                 ; preds = %land.lhs.true722
  %137 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_epoch = getelementptr inbounds %struct.clusterState, ptr %137, i64 0, i32 15
  %138 = load i64, ptr %failover_auth_epoch, align 8
  %cmp726.not = icmp ult i64 %senderCurrentEpoch.0, %138
  br i1 %cmp726.not, label %return, label %if.then728

if.then728:                                       ; preds = %land.lhs.true725
  %failover_auth_count = getelementptr inbounds %struct.clusterState, ptr %137, i64 0, i32 12
  %139 = load i32, ptr %failover_auth_count, align 8
  %inc729 = add nsw i32 %139, 1
  store i32 %inc729, ptr %failover_auth_count, align 8
  %todo_before_sleep.i326 = getelementptr inbounds %struct.clusterState, ptr %137, i64 0, i32 22
  %140 = load i32, ptr %todo_before_sleep.i326, align 8
  %or.i327 = or i32 %140, 1
  store i32 %or.i327, ptr %todo_before_sleep.i326, align 8
  br label %return

if.then735:                                       ; preds = %if.else650
  br i1 %tobool182.not335, label %return, label %lor.lhs.false737

lor.lhs.false737:                                 ; preds = %if.then735
  %slaveof738 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 11
  %141 = load ptr, ptr %slaveof738, align 8
  %142 = load ptr, ptr @myself, align 8
  %cmp739.not = icmp eq ptr %141, %142
  br i1 %cmp739.not, label %if.end742, label %return

if.end742:                                        ; preds = %lor.lhs.false737
  tail call void @resetManualFailover()
  %add743 = add nsw i64 %call4, 5000
  %143 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end744 = getelementptr inbounds %struct.clusterState, ptr %143, i64 0, i32 17
  store i64 %add743, ptr %mf_end744, align 8
  %mf_slave = getelementptr inbounds %struct.clusterState, ptr %143, i64 0, i32 18
  store ptr %sender.0.i334, ptr %mf_slave, align 8
  %add745 = add nsw i64 %call4, 10000
  tail call void @pauseActions(i32 noundef 2, i64 noundef %add745, i32 noundef 29) #33
  %144 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp747 = icmp sgt i32 %144, 2
  br i1 %cmp747, label %do.end754, label %if.end750

if.end750:                                        ; preds = %if.end742
  %name751 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 1
  %human_nodename753 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 23
  %145 = load ptr, ptr %human_nodename753, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.98, ptr noundef nonnull %name751, ptr noundef %145) #33
  br label %do.end754

do.end754:                                        ; preds = %if.end742, %if.end750
  tail call void @clusterSendPing(ptr noundef nonnull %link, i32 noundef 0)
  br label %return

if.then759:                                       ; preds = %if.else650
  %data760 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20
  %146 = load i64, ptr %data760, align 8
  %call762 = tail call i64 @intrev64(i64 noundef %146) #33
  br i1 %tobool182.not335, label %return, label %if.end765

if.end765:                                        ; preds = %if.then759
  %nodename768 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20, i32 0, i32 0, i32 1
  %call770 = tail call ptr @clusterLookupNode(ptr noundef nonnull %nodename768, i32 noundef 40)
  %tobool771.not = icmp eq ptr %call770, null
  br i1 %tobool771.not, label %return, label %if.end773

if.end773:                                        ; preds = %if.end765
  %configEpoch774 = getelementptr inbounds %struct._clusterNode, ptr %call770, i64 0, i32 4
  %147 = load i64, ptr %configEpoch774, align 8
  %cmp775.not = icmp ult i64 %147, %call762
  br i1 %cmp775.not, label %if.end778, label %return

if.end778:                                        ; preds = %if.end773
  %flags779 = getelementptr inbounds %struct._clusterNode, ptr %call770, i64 0, i32 3
  %148 = load i32, ptr %flags779, align 8
  %and780 = and i32 %148, 2
  %tobool781.not = icmp eq i32 %and780, 0
  br i1 %tobool781.not, label %if.end783, label %if.then782

if.then782:                                       ; preds = %if.end778
  tail call void @clusterSetNodeAsMaster(ptr noundef nonnull %call770)
  br label %if.end783

if.end783:                                        ; preds = %if.then782, %if.end778
  store i64 %call762, ptr %configEpoch774, align 8
  %149 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i328 = getelementptr inbounds %struct.clusterState, ptr %149, i64 0, i32 22
  %150 = load i32, ptr %todo_before_sleep.i328, align 8
  %or.i329 = or i32 %150, 12
  store i32 %or.i329, ptr %todo_before_sleep.i328, align 8
  %slots787 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20, i32 0, i32 0, i32 2
  tail call void @clusterUpdateSlotsConfigWith(ptr noundef nonnull %call770, i64 noundef %call762, ptr noundef nonnull %slots787)
  br label %return

if.then793:                                       ; preds = %if.else650
  br i1 %tobool182.not335, label %return, label %if.end796

if.end796:                                        ; preds = %if.then793
  %data797 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20
  %151 = load i64, ptr %data797, align 8
  %len803 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20, i32 0, i32 0, i32 1
  %152 = load i32, ptr %len803, align 8
  %call804 = tail call i32 @ntohl(i32 noundef %152) #36
  %type808 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20, i32 0, i32 0, i32 1, i64 4
  %153 = load i8, ptr %type808, align 4
  %bulk_data811 = getelementptr inbounds %struct.clusterMsg, ptr %0, i64 0, i32 20, i32 0, i32 0, i32 1, i64 5
  %name813 = getelementptr inbounds %struct._clusterNode, ptr %sender.0.i334, i64 0, i32 1
  tail call void @moduleCallClusterReceivers(ptr noundef nonnull %name813, i64 noundef %151, i8 noundef zeroext %153, ptr noundef nonnull %bulk_data811, i32 noundef %call804) #33
  br label %return

do.body816:                                       ; preds = %if.else650
  %154 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp817 = icmp sgt i32 %154, 3
  br i1 %cmp817, label %return, label %if.end820

if.end820:                                        ; preds = %do.body816
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.99, i32 noundef %conv) #33
  br label %return

return:                                           ; preds = %land.lhs.true667, %if.end463, %if.then599, %if.then679, %land.lhs.true675, %lor.lhs.false671, %if.then728, %land.lhs.true725, %land.lhs.true722, %if.end719, %if.end783, %if.end820, %do.body816, %if.end796, %do.end754, %if.end711, %do.end630, %land.lhs.true612, %if.then607, %do.body637, %if.end641, %if.then793, %if.end773, %if.end765, %if.then759, %if.then735, %lor.lhs.false737, %if.then716, %if.then708, %if.then658, %if.end174, %do.body170, %if.end89, %do.body85, %if.end75, %do.body71, %if.end36, %do.body32, %if.end21, %if.end16, %do.end, %do.end398, %if.end353
  %retval.0 = phi i32 [ 0, %if.end353 ], [ 0, %do.end398 ], [ 1, %do.end ], [ 1, %if.end16 ], [ 1, %if.end21 ], [ 1, %do.body32 ], [ 1, %if.end36 ], [ 1, %do.body71 ], [ 1, %if.end75 ], [ 1, %do.body85 ], [ 1, %if.end89 ], [ 1, %do.body170 ], [ 1, %if.end174 ], [ 1, %if.then658 ], [ 1, %if.then708 ], [ 1, %if.then716 ], [ 1, %lor.lhs.false737 ], [ 1, %if.then735 ], [ 1, %if.then759 ], [ 1, %if.end765 ], [ 1, %if.end773 ], [ 1, %if.then793 ], [ 1, %if.end641 ], [ 1, %do.body637 ], [ 1, %if.then607 ], [ 1, %land.lhs.true612 ], [ 1, %do.end630 ], [ 1, %if.end711 ], [ 1, %do.end754 ], [ 1, %if.end796 ], [ 1, %do.body816 ], [ 1, %if.end820 ], [ 1, %if.end783 ], [ 1, %if.end719 ], [ 1, %land.lhs.true722 ], [ 1, %land.lhs.true725 ], [ 1, %if.then728 ], [ 1, %lor.lhs.false671 ], [ 1, %land.lhs.true675 ], [ 1, %if.then679 ], [ 1, %if.then599 ], [ 1, %if.end463 ], [ 1, %land.lhs.true667 ]
  ret i32 %retval.0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local nonnull ptr @clusterGetMessageTypeString(i32 noundef %type) local_unnamed_addr #27 {
entry:
  %0 = icmp ult i32 %type, 11
  br i1 %0, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %entry
  %1 = zext nneg i32 %type to i64
  %switch.gep = getelementptr inbounds [11 x ptr], ptr @switch.table.genClusterInfoString.15, i64 0, i64 %1
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %return

return:                                           ; preds = %entry, %switch.lookup
  %retval.0 = phi ptr [ %switch.load, %switch.lookup ], [ @.str.179, %entry ]
  ret ptr %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendPing(ptr noundef %link, i32 noundef %type) local_unnamed_addr #2 {
entry:
  %0 = load i64, ptr @clusterSendPing.cluster_pings_sent, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr @clusterSendPing.cluster_pings_sent, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 4
  %2 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %2, i64 0, i32 2
  %3 = load i64, ptr %ht_used, align 8
  %arrayidx3 = getelementptr inbounds %struct.dict, ptr %2, i64 0, i32 2, i64 1
  %4 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %4, %3
  %5 = trunc i64 %add to i32
  %conv = add i32 %5, -2
  %div = udiv i64 %add, 10
  %conv12 = trunc i64 %div to i32
  %spec.store.select = tail call i32 @llvm.smax.i32(i32 %conv12, i32 3)
  %spec.select = tail call i32 @llvm.smin.i32(i32 %spec.store.select, i32 %conv)
  %stats_pfail_nodes = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 25
  %6 = load i64, ptr %stats_pfail_nodes, align 8
  %.fr = freeze i64 %6
  %conv18 = trunc i64 %.fr to i32
  %add19 = add nsw i32 %spec.select, %conv18
  %mul = mul i32 %add19, 104
  %call = tail call i32 @writePingExt(ptr noundef null, i32 noundef 0)
  %add22 = add i32 %call, 2256
  %add24 = add i32 %add22, %mul
  %spec.store.select1 = tail call i32 @llvm.smax.i32(i32 %add24, i32 4352)
  %call29 = tail call fastcc ptr @createClusterMsgSendBlock(i32 noundef %type, i32 noundef %spec.store.select1)
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call29, i64 0, i32 2
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 9
  %7 = load i32, ptr %inbound, align 8
  %8 = or i32 %7, %type
  %or.cond = icmp eq i32 %8, 0
  br i1 %or.cond, label %if.then32, label %if.end34

if.then32:                                        ; preds = %entry
  %call33 = tail call i64 @mstime() #33
  %node = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 8
  %9 = load ptr, ptr %node, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %9, i64 0, i32 13
  store i64 %call33, ptr %ping_sent, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %entry
  %cmp3995 = icmp sgt i32 %conv, 0
  br i1 %cmp3995, label %land.rhs.lr.ph.lr.ph.preheader, label %while.end

land.rhs.lr.ph.lr.ph.preheader:                   ; preds = %if.end34
  %mul35 = mul nsw i32 %spec.select, 3
  br label %land.rhs.lr.ph.lr.ph

land.rhs.lr.ph.lr.ph:                             ; preds = %land.rhs.lr.ph.lr.ph.preheader, %if.end67
  %gossipcount.0.ph.ph100 = phi i32 [ %inc70, %if.end67 ], [ 0, %land.rhs.lr.ph.lr.ph.preheader ]
  %freshnodes.0.ph.ph99 = phi i32 [ %dec69, %if.end67 ], [ %conv, %land.rhs.lr.ph.lr.ph.preheader ]
  %maxiterations.0.ph.ph98 = phi i32 [ %dec.us84, %if.end67 ], [ %mul35, %land.rhs.lr.ph.lr.ph.preheader ]
  br label %land.rhs.lr.ph.split.us

land.rhs.lr.ph.split.us:                          ; preds = %if.then61, %land.rhs.lr.ph.lr.ph
  %freshnodes.0.ph90 = phi i32 [ %freshnodes.0.ph.ph99, %land.rhs.lr.ph.lr.ph ], [ %dec62, %if.then61 ]
  %maxiterations.0.ph89 = phi i32 [ %maxiterations.0.ph.ph98, %land.rhs.lr.ph.lr.ph ], [ %dec.us84, %if.then61 ]
  %tobool41.not.us83 = icmp eq i32 %maxiterations.0.ph89, 0
  br i1 %tobool41.not.us83, label %while.end, label %while.body.us

while.body.us:                                    ; preds = %land.rhs.lr.ph.split.us, %while.cond.backedge.us
  %dec.us84.in = phi i32 [ %dec.us84, %while.cond.backedge.us ], [ %maxiterations.0.ph89, %land.rhs.lr.ph.split.us ]
  %dec.us84 = add nsw i32 %dec.us84.in, -1
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes42.us = getelementptr inbounds %struct.clusterState, ptr %10, i64 0, i32 4
  %11 = load ptr, ptr %nodes42.us, align 8
  %call43.us = tail call ptr @dictGetRandomKey(ptr noundef %11) #33
  %call44.us = tail call ptr @dictGetVal(ptr noundef %call43.us) #33
  %12 = load ptr, ptr @myself, align 8
  %cmp45.us = icmp eq ptr %call44.us, %12
  br i1 %cmp45.us, label %while.cond.backedge.us, label %if.end48.us

if.end48.us:                                      ; preds = %while.body.us
  %flags.us = getelementptr inbounds %struct._clusterNode, ptr %call44.us, i64 0, i32 3
  %13 = load i32, ptr %flags.us, align 8
  %and.us = and i32 %13, 4
  %tobool49.not.us = icmp eq i32 %and.us, 0
  br i1 %tobool49.not.us, label %if.end51.us, label %while.cond.backedge.us

if.end51.us:                                      ; preds = %if.end48.us
  %and53.us = and i32 %13, 96
  %tobool54.not.us = icmp eq i32 %and53.us, 0
  br i1 %tobool54.not.us, label %lor.lhs.false.us, label %if.then61

lor.lhs.false.us:                                 ; preds = %if.end51.us
  %link55.us = getelementptr inbounds %struct._clusterNode, ptr %call44.us, i64 0, i32 27
  %14 = load ptr, ptr %link55.us, align 8
  %cmp56.us = icmp eq ptr %14, null
  br i1 %cmp56.us, label %land.lhs.true58.us, label %if.end63.us

land.lhs.true58.us:                               ; preds = %lor.lhs.false.us
  %numslots.us = getelementptr inbounds %struct._clusterNode, ptr %call44.us, i64 0, i32 8
  %15 = load i32, ptr %numslots.us, align 4
  %cmp59.us = icmp eq i32 %15, 0
  br i1 %cmp59.us, label %if.then61, label %if.end63.us

if.end63.us:                                      ; preds = %land.lhs.true58.us, %lor.lhs.false.us
  %last_in_ping_gossip.us = getelementptr inbounds %struct._clusterNode, ptr %call44.us, i64 0, i32 12
  %16 = load i64, ptr %last_in_ping_gossip.us, align 8
  %17 = load i64, ptr @clusterSendPing.cluster_pings_sent, align 8
  %cmp64.us = icmp eq i64 %16, %17
  br i1 %cmp64.us, label %while.cond.backedge.us, label %if.end67

while.cond.backedge.us:                           ; preds = %if.end63.us, %if.end48.us, %while.body.us
  %tobool41.not.us = icmp eq i32 %dec.us84, 0
  br i1 %tobool41.not.us, label %while.end, label %while.body.us

if.then61:                                        ; preds = %if.end51.us, %land.lhs.true58.us
  %dec62 = add nsw i32 %freshnodes.0.ph90, -1
  %cmp36 = icmp sgt i32 %freshnodes.0.ph90, 1
  br i1 %cmp36, label %land.rhs.lr.ph.split.us, label %while.end, !llvm.loop !46

if.end67:                                         ; preds = %if.end63.us
  %last_in_ping_gossip.le = getelementptr inbounds %struct._clusterNode, ptr %call44.us, i64 0, i32 12
  tail call void @clusterSetGossipEntry(ptr noundef nonnull %msg, i32 noundef %gossipcount.0.ph.ph100, ptr noundef nonnull %call44.us)
  store i64 %17, ptr %last_in_ping_gossip.le, align 8
  %dec69 = add nsw i32 %freshnodes.0.ph90, -1
  %inc70 = add nuw nsw i32 %gossipcount.0.ph.ph100, 1
  %cmp39 = icmp slt i32 %inc70, %spec.select
  %cmp3687 = icmp sgt i32 %freshnodes.0.ph90, 1
  %or.cond4788 = select i1 %cmp3687, i1 %cmp39, i1 false
  br i1 %or.cond4788, label %land.rhs.lr.ph.lr.ph, label %while.end, !llvm.loop !46

while.end:                                        ; preds = %if.end67, %land.rhs.lr.ph.split.us, %if.then61, %while.cond.backedge.us, %if.end34
  %gossipcount.0.ph.ph.lcssa = phi i32 [ 0, %if.end34 ], [ %gossipcount.0.ph.ph100, %while.cond.backedge.us ], [ %gossipcount.0.ph.ph100, %if.then61 ], [ %gossipcount.0.ph.ph100, %land.rhs.lr.ph.split.us ], [ %inc70, %if.end67 ]
  %tobool71.not = icmp eq i32 %conv18, 0
  br i1 %tobool71.not, label %if.end105, label %if.then72

if.then72:                                        ; preds = %while.end
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes74 = getelementptr inbounds %struct.clusterState, ptr %18, i64 0, i32 4
  %19 = load ptr, ptr %nodes74, align 8
  %call75 = tail call ptr @dictGetSafeIterator(ptr noundef %19) #33
  %cmp81107 = icmp sgt i32 %conv18, 0
  br i1 %cmp81107, label %while.cond76.outer.split.preheader, label %while.cond76.us

while.cond76.outer.split.preheader:               ; preds = %if.then72
  %20 = add i32 %gossipcount.0.ph.ph.lcssa, %conv18
  br label %while.cond76.outer.split

while.cond76.us:                                  ; preds = %if.end101, %if.then72
  %gossipcount.1.ph.lcssa105 = phi i32 [ %gossipcount.0.ph.ph.lcssa, %if.then72 ], [ %20, %if.end101 ]
  %call77.us = tail call ptr @dictNext(ptr noundef %call75) #33
  br label %while.end104

while.cond76.outer.split:                         ; preds = %while.cond76.outer.split.preheader, %if.end101
  %gossipcount.1.ph110 = phi i32 [ %inc102, %if.end101 ], [ %gossipcount.0.ph.ph.lcssa, %while.cond76.outer.split.preheader ]
  br label %while.cond76

while.cond76:                                     ; preds = %while.cond76.outer.split, %while.body84
  %call77 = tail call ptr @dictNext(ptr noundef %call75) #33
  %cmp78.not = icmp eq ptr %call77, null
  br i1 %cmp78.not, label %while.end104, label %while.body84

while.body84:                                     ; preds = %while.cond76
  %call86 = tail call ptr @dictGetVal(ptr noundef nonnull %call77) #33
  %flags87 = getelementptr inbounds %struct._clusterNode, ptr %call86, i64 0, i32 3
  %21 = load i32, ptr %flags87, align 8
  %22 = and i32 %21, 100
  %or.cond49.not = icmp eq i32 %22, 4
  br i1 %or.cond49.not, label %if.end101, label %while.cond76, !llvm.loop !47

if.end101:                                        ; preds = %while.body84
  tail call void @clusterSetGossipEntry(ptr noundef nonnull %msg, i32 noundef %gossipcount.1.ph110, ptr noundef nonnull %call86)
  %inc102 = add nuw i32 %gossipcount.1.ph110, 1
  %exitcond.not = icmp eq i32 %inc102, %20
  br i1 %exitcond.not, label %while.cond76.us, label %while.cond76.outer.split, !llvm.loop !47

while.end104:                                     ; preds = %while.cond76, %while.cond76.us
  %.us-phi104 = phi i32 [ %gossipcount.1.ph.lcssa105, %while.cond76.us ], [ %gossipcount.1.ph110, %while.cond76 ]
  tail call void @dictReleaseIterator(ptr noundef %call75) #33
  br label %if.end105

if.end105:                                        ; preds = %while.end104, %while.end
  %gossipcount.2 = phi i32 [ %.us-phi104, %while.end104 ], [ %gossipcount.0.ph.ph.lcssa, %while.end ]
  %call106 = tail call i32 @writePingExt(ptr noundef nonnull %msg, i32 noundef %gossipcount.2)
  %cmp116 = icmp slt i32 %gossipcount.2, 65535
  br i1 %cmp116, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end105
  tail call void @_serverAssert(ptr noundef nonnull @.str.110, ptr noundef nonnull @.str.18, i32 noundef 3600) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.end105
  %add109 = add i32 %call106, 2256
  %mul112 = mul i32 %gossipcount.2, 104
  %add114 = add i32 %add109, %mul112
  %conv121 = trunc i32 %gossipcount.2 to i16
  %call122 = tail call zeroext i16 @htons(i16 noundef zeroext %conv121) #36
  %count = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call29, i64 0, i32 2, i32 5
  store i16 %call122, ptr %count, align 2
  %call123 = tail call i32 @htonl(i32 noundef %add114) #36
  %totlen124 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call29, i64 0, i32 2, i32 1
  store i32 %call123, ptr %totlen124, align 4
  %tobool.not.i = icmp eq ptr %link, null
  br i1 %tobool.not.i, label %clusterSendMessage.exit, label %if.end.i

if.end.i:                                         ; preds = %cond.end
  %send_msg_queue.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 2
  %23 = load ptr, ptr %send_msg_queue.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %23, i64 0, i32 5
  %24 = load i64, ptr %len.i, align 8
  %cmp.i = icmp ne i64 %24, 0
  %cmp1.not.i = icmp eq i32 %call123, 0
  %or.cond53 = select i1 %cmp.i, i1 true, i1 %cmp1.not.i
  br i1 %or.cond53, label %if.end3.i, label %if.then2.i

if.then2.i:                                       ; preds = %if.end.i
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %25 = load ptr, ptr %conn.i, align 8
  %26 = load ptr, ptr %25, align 8
  %set_write_handler.i.i = getelementptr inbounds %struct.ConnectionType, ptr %26, i64 0, i32 19
  %27 = load ptr, ptr %set_write_handler.i.i, align 8
  %call.i.i = tail call i32 %27(ptr noundef nonnull %25, ptr noundef nonnull @clusterWriteHandler, i32 noundef 1) #33
  %.pre.i = load ptr, ptr %send_msg_queue.i, align 8
  br label %if.end3.i

if.end3.i:                                        ; preds = %if.then2.i, %if.end.i
  %28 = phi ptr [ %.pre.i, %if.then2.i ], [ %23, %if.end.i ]
  %call5.i = tail call ptr @listAddNodeTail(ptr noundef %28, ptr noundef nonnull %call29) #33
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call29, i64 0, i32 1
  %29 = load i32, ptr %refcount.i, align 8
  %inc.i = add nsw i32 %29, 1
  store i32 %inc.i, ptr %refcount.i, align 8
  %30 = load i64, ptr %call29, align 8
  %add.i = add i64 %30, 24
  %send_msg_queue_mem.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 4
  %31 = load i64, ptr %send_msg_queue_mem.i, align 8
  %add7.i = add i64 %add.i, %31
  store i64 %add7.i, ptr %send_msg_queue_mem.i, align 8
  %32 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add8.i = add i64 %32, 24
  store i64 %add8.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %type10.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call29, i64 0, i32 2, i32 4
  %33 = load i16, ptr %type10.i, align 4
  %call11.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %33) #36
  %cmp12.i = icmp ult i16 %call11.i, 11
  br i1 %cmp12.i, label %if.then14.i, label %clusterSendMessage.exit

if.then14.i:                                      ; preds = %if.end3.i
  %34 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom.i = zext nneg i16 %call11.i to i64
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %34, i64 0, i32 23, i64 %idxprom.i
  %35 = load i64, ptr %arrayidx.i, align 8
  %inc15.i = add nsw i64 %35, 1
  store i64 %inc15.i, ptr %arrayidx.i, align 8
  br label %clusterSendMessage.exit

clusterSendMessage.exit:                          ; preds = %cond.end, %if.end3.i, %if.then14.i
  %refcount.i50 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call29, i64 0, i32 1
  %36 = load i32, ptr %refcount.i50, align 8
  %dec.i = add nsw i32 %36, -1
  store i32 %dec.i, ptr %refcount.i50, align 8
  %cmp.i51 = icmp sgt i32 %36, 0
  br i1 %cmp.i51, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %clusterSendMessage.exit
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %clusterSendMessage.exit
  %cmp4.i = icmp eq i32 %dec.i, 0
  br i1 %cmp4.i, label %if.then.i, label %clusterMsgSendBlockDecrRefCount.exit

if.then.i:                                        ; preds = %cond.end.i
  %37 = load i64, ptr %call29, align 8
  %38 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i = sub i64 %38, %37
  store i64 %sub.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %call29) #33
  br label %clusterMsgSendBlockDecrRefCount.exit

clusterMsgSendBlockDecrRefCount.exit:             ; preds = %cond.end.i, %if.then.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterDelNodeSlots(ptr nocapture noundef readonly %node) local_unnamed_addr #2 {
entry:
  %slots.i = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 5
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %deleted.011 = phi i32 [ 0, %entry ], [ %deleted.1, %for.inc ]
  %0 = trunc i64 %indvars.iv to i32
  %div.i.i789 = lshr i64 %indvars.iv, 3
  %conv.i.i = and i64 %div.i.i789, 536870911
  %and.i.i = and i32 %0, 7
  %arrayidx.i.i = getelementptr inbounds i8, ptr %slots.i, i64 %conv.i.i
  %1 = load i8, ptr %arrayidx.i.i, align 1
  %conv1.i.i = zext i8 %1 to i32
  %2 = shl nuw nsw i32 1, %and.i.i
  %3 = and i32 %2, %conv1.i.i
  %tobool.not = icmp eq i32 %3, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 9, i64 %indvars.iv
  %5 = load ptr, ptr %arrayidx.i, align 8
  %tobool.not.i = icmp eq ptr %5, null
  br i1 %tobool.not.i, label %clusterDelSlot.exit, label %if.end.i

if.end.i:                                         ; preds = %if.then
  tail call void @removeChannelsInSlot(i32 noundef %0)
  %slots.i.i = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 5
  %arrayidx.i.i.i = getelementptr inbounds i8, ptr %slots.i.i, i64 %conv.i.i
  %6 = load i8, ptr %arrayidx.i.i.i, align 1
  %conv1.i.i.i = zext i8 %6 to i32
  %7 = and i32 %2, %conv1.i.i.i
  %tobool.not.i.i = icmp eq i32 %7, 0
  br i1 %tobool.not.i.i, label %cond.false.i, label %cond.end.i

cond.false.i:                                     ; preds = %if.end.i
  tail call void @_serverAssert(ptr noundef nonnull @.str.138, ptr noundef nonnull @.str.18, i32 noundef 4866) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %if.end.i
  %8 = trunc i32 %2 to i8
  %9 = xor i8 %8, -1
  %conv3.i9.i.i = and i8 %6, %9
  store i8 %conv3.i9.i.i, ptr %arrayidx.i.i.i, align 1
  %numslots.i.i = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 8
  %10 = load i32, ptr %numslots.i.i, align 4
  %dec.i.i = add nsw i32 %10, -1
  store i32 %dec.i.i, ptr %numslots.i.i, align 4
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5.i = getelementptr inbounds %struct.clusterState, ptr %11, i64 0, i32 9, i64 %indvars.iv
  store ptr null, ptr %arrayidx5.i, align 8
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot.i = getelementptr inbounds %struct.clusterState, ptr %12, i64 0, i32 27
  %arrayidx.i.i5 = getelementptr inbounds i8, ptr %owner_not_claiming_slot.i, i64 %conv.i.i
  %13 = load i8, ptr %arrayidx.i.i5, align 1
  %conv3.i.i6 = and i8 %13, %9
  store i8 %conv3.i.i6, ptr %arrayidx.i.i5, align 1
  br label %clusterDelSlot.exit

clusterDelSlot.exit:                              ; preds = %if.then, %cond.end.i
  %inc = add nsw i32 %deleted.011, 1
  br label %for.inc

for.inc:                                          ; preds = %for.body, %clusterDelSlot.exit
  %deleted.1 = phi i32 [ %inc, %clusterDelSlot.exit ], [ %deleted.011, %for.body ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !48

for.end:                                          ; preds = %for.inc
  ret i32 %deleted.1
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendUpdate(ptr noundef %link, ptr nocapture noundef readonly %node) local_unnamed_addr #2 {
entry:
  %cmp = icmp eq ptr %link, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call fastcc ptr @createClusterMsgSendBlock(i32 noundef 7, i32 noundef 4352)
  %data = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20
  %nodename = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20, i32 0, i32 0, i32 1
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %nodename, ptr noundef nonnull align 8 dereferenceable(40) %name, i64 40, i1 false)
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 4
  %0 = load i64, ptr %configEpoch, align 8
  %call2 = tail call i64 @intrev64(i64 noundef %0) #33
  store i64 %call2, ptr %data, align 8
  %slots = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20, i32 0, i32 0, i32 2
  %slots9 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 5
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(2048) %slots, ptr noundef nonnull align 8 dereferenceable(2048) %slots9, i64 2048, i1 false)
  br label %for.body

for.body:                                         ; preds = %if.end, %for.body
  %indvars.iv = phi i64 [ 0, %if.end ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20, i32 0, i32 0, i32 2, i64 %indvars.iv
  %1 = load i8, ptr %arrayidx, align 1
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx18 = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 27, i64 %indvars.iv
  %3 = load i8, ptr %arrayidx18, align 1
  %not = xor i8 %3, -1
  %and = and i8 %1, %not
  store i8 %and, ptr %arrayidx, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 2048
  br i1 %exitcond.not, label %if.end.i, label %for.body, !llvm.loop !49

if.end.i:                                         ; preds = %for.body
  %send_msg_queue.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 2
  %4 = load ptr, ptr %send_msg_queue.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %4, i64 0, i32 5
  %5 = load i64, ptr %len.i, align 8
  %cmp.i = icmp eq i64 %5, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end3.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %totlen.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 1
  %6 = load i32, ptr %totlen.i, align 4
  %cmp1.not.i = icmp eq i32 %6, 0
  br i1 %cmp1.not.i, label %if.end3.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %7 = load ptr, ptr %conn.i, align 8
  %8 = load ptr, ptr %7, align 8
  %set_write_handler.i.i = getelementptr inbounds %struct.ConnectionType, ptr %8, i64 0, i32 19
  %9 = load ptr, ptr %set_write_handler.i.i, align 8
  %call.i.i = tail call i32 %9(ptr noundef nonnull %7, ptr noundef nonnull @clusterWriteHandler, i32 noundef 1) #33
  %.pre.i = load ptr, ptr %send_msg_queue.i, align 8
  br label %if.end3.i

if.end3.i:                                        ; preds = %if.then2.i, %land.lhs.true.i, %if.end.i
  %10 = phi ptr [ %.pre.i, %if.then2.i ], [ %4, %land.lhs.true.i ], [ %4, %if.end.i ]
  %call5.i = tail call ptr @listAddNodeTail(ptr noundef %10, ptr noundef nonnull %call) #33
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %11 = load i32, ptr %refcount.i, align 8
  %inc.i = add nsw i32 %11, 1
  store i32 %inc.i, ptr %refcount.i, align 8
  %12 = load i64, ptr %call, align 8
  %add.i = add i64 %12, 24
  %send_msg_queue_mem.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 4
  %13 = load i64, ptr %send_msg_queue_mem.i, align 8
  %add7.i = add i64 %add.i, %13
  store i64 %add7.i, ptr %send_msg_queue_mem.i, align 8
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add8.i = add i64 %14, 24
  store i64 %add8.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %type10.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 4
  %15 = load i16, ptr %type10.i, align 4
  %call11.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %15) #36
  %cmp12.i = icmp ult i16 %call11.i, 11
  br i1 %cmp12.i, label %if.then14.i, label %clusterSendMessage.exit

if.then14.i:                                      ; preds = %if.end3.i
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom.i = zext nneg i16 %call11.i to i64
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %16, i64 0, i32 23, i64 %idxprom.i
  %17 = load i64, ptr %arrayidx.i, align 8
  %inc15.i = add nsw i64 %17, 1
  store i64 %inc15.i, ptr %arrayidx.i, align 8
  br label %clusterSendMessage.exit

clusterSendMessage.exit:                          ; preds = %if.end3.i, %if.then14.i
  %18 = load i32, ptr %refcount.i, align 8
  %dec.i = add nsw i32 %18, -1
  store i32 %dec.i, ptr %refcount.i, align 8
  %cmp.i15 = icmp sgt i32 %18, 0
  br i1 %cmp.i15, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %clusterSendMessage.exit
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %clusterSendMessage.exit
  %cmp4.i = icmp eq i32 %dec.i, 0
  br i1 %cmp4.i, label %if.then.i, label %return

if.then.i:                                        ; preds = %cond.end.i
  %19 = load i64, ptr %call, align 8
  %20 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i = sub i64 %20, %19
  store i64 %sub.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %call) #33
  br label %return

return:                                           ; preds = %if.then.i, %cond.end.i, %entry
  ret void
}

declare i32 @serverPubsubSubscriptionCount() local_unnamed_addr #1

declare i32 @serverPubsubShardSubscriptionCount() local_unnamed_addr #1

declare ptr @createStringObject(ptr noundef, i64 noundef) local_unnamed_addr #1

declare i32 @pubsubPublishMessage(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

declare void @decrRefCount(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendFailoverAuthIfNeeded(ptr noundef %node, ptr nocapture noundef readonly %request) local_unnamed_addr #2 {
entry:
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 11
  %0 = load ptr, ptr %slaveof, align 8
  %currentEpoch = getelementptr inbounds %struct.clusterMsg, ptr %request, i64 0, i32 6
  %1 = load i64, ptr %currentEpoch, align 8
  %call = tail call i64 @intrev64(i64 noundef %1) #33
  %configEpoch = getelementptr inbounds %struct.clusterMsg, ptr %request, i64 0, i32 7
  %2 = load i64, ptr %configEpoch, align 8
  %call1 = tail call i64 @intrev64(i64 noundef %2) #33
  %myslots = getelementptr inbounds %struct.clusterMsg, ptr %request, i64 0, i32 10
  %mflags = getelementptr inbounds %struct.clusterMsg, ptr %request, i64 0, i32 19
  %3 = load i8, ptr %mflags, align 1
  %4 = and i8 %3, 2
  %5 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 3
  %6 = load i32, ptr %flags, align 8
  %and2 = and i32 %6, 2
  %tobool.not = icmp eq i32 %and2, 0
  br i1 %tobool.not, label %lor.lhs.false, label %do.end154

lor.lhs.false:                                    ; preds = %entry
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 8
  %7 = load i32, ptr %numslots, align 4
  %cmp = icmp eq i32 %7, 0
  br i1 %cmp, label %do.end154, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch4 = getelementptr inbounds %struct.clusterState, ptr %8, i64 0, i32 1
  %9 = load i64, ptr %currentEpoch4, align 8
  %cmp5 = icmp ult i64 %call, %9
  br i1 %cmp5, label %do.body, label %if.end14

do.body:                                          ; preds = %if.end
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp8 = icmp sgt i32 %10, 3
  br i1 %cmp8, label %do.end154, label %if.end11

if.end11:                                         ; preds = %do.body
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %11 = load ptr, ptr %human_nodename, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.112, ptr noundef nonnull %name, ptr noundef %11, i64 noundef %call, i64 noundef %9) #33
  br label %do.end154

if.end14:                                         ; preds = %if.end
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %8, i64 0, i32 21
  %12 = load i64, ptr %lastVoteEpoch, align 8
  %cmp16 = icmp eq i64 %12, %9
  br i1 %cmp16, label %do.body19, label %if.end29

do.body19:                                        ; preds = %if.end14
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp20 = icmp sgt i32 %13, 3
  br i1 %cmp20, label %do.end154, label %if.end23

if.end23:                                         ; preds = %do.body19
  %name24 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename26 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %14 = load ptr, ptr %human_nodename26, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.113, ptr noundef nonnull %name24, ptr noundef %14, i64 noundef %9) #33
  br label %do.end154

if.end29:                                         ; preds = %if.end14
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %15 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %15, 1
  %tobool31 = icmp ne i32 %and.i, 0
  %cmp33 = icmp eq ptr %0, null
  %or.cond = select i1 %tobool31, i1 true, i1 %cmp33
  br i1 %or.cond, label %if.then40, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %if.end29
  %flags36 = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 3
  %16 = load i32, ptr %flags36, align 8
  %and37 = and i32 %16, 8
  %tobool38 = icmp ne i32 %and37, 0
  %tobool39 = icmp ne i8 %4, 0
  %or.cond1 = select i1 %tobool38, i1 true, i1 %tobool39
  br i1 %or.cond1, label %if.end82, label %if.else65

if.then40:                                        ; preds = %if.end29
  %tobool42.not = icmp eq i32 %and.i, 0
  br i1 %tobool42.not, label %if.else, label %do.body44

do.body44:                                        ; preds = %if.then40
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp45 = icmp sgt i32 %17, 3
  br i1 %cmp45, label %do.end154, label %if.end48

if.end48:                                         ; preds = %do.body44
  %name49 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename51 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %18 = load ptr, ptr %human_nodename51, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.114, ptr noundef nonnull %name49, ptr noundef %18) #33
  br label %do.end154

if.else:                                          ; preds = %if.then40
  br i1 %cmp33, label %do.body56, label %if.else.if.else65_crit_edge

if.else.if.else65_crit_edge:                      ; preds = %if.else
  %flags66.phi.trans.insert = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 3
  %.pre = load i32, ptr %flags66.phi.trans.insert, align 8
  br label %if.else65

do.body56:                                        ; preds = %if.else
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp57 = icmp sgt i32 %19, 3
  br i1 %cmp57, label %do.end154, label %if.end60

if.end60:                                         ; preds = %do.body56
  %name61 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename63 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %20 = load ptr, ptr %human_nodename63, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.115, ptr noundef nonnull %name61, ptr noundef %20) #33
  br label %do.end154

if.else65:                                        ; preds = %if.else.if.else65_crit_edge, %lor.lhs.false35
  %21 = phi i32 [ %.pre, %if.else.if.else65_crit_edge ], [ %16, %lor.lhs.false35 ]
  %and67 = and i32 %21, 8
  %tobool68 = icmp ne i32 %and67, 0
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp71 = icmp sgt i32 %22, 3
  %or.cond2 = select i1 %tobool68, i1 true, i1 %cmp71
  br i1 %or.cond2, label %do.end154, label %if.end74

if.end74:                                         ; preds = %if.else65
  %name75 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename77 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %23 = load ptr, ptr %human_nodename77, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.116, ptr noundef nonnull %name75, ptr noundef %23) #33
  br label %do.end154

if.end82:                                         ; preds = %lor.lhs.false35
  %call83 = tail call i64 @mstime() #33
  %24 = load ptr, ptr %slaveof, align 8
  %voted_time = getelementptr inbounds %struct._clusterNode, ptr %24, i64 0, i32 17
  %25 = load i64, ptr %voted_time, align 8
  %sub = sub nsw i64 %call83, %25
  %26 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %mul = shl nsw i64 %26, 1
  %cmp85 = icmp slt i64 %sub, %mul
  br i1 %cmp85, label %do.body88, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end82
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %27, i64 0, i32 27
  br label %for.body

do.body88:                                        ; preds = %if.end82
  %28 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp89 = icmp sgt i32 %28, 3
  br i1 %cmp89, label %do.end154, label %if.end92

if.end92:                                         ; preds = %do.body88
  %name93 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename95 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %29 = load ptr, ptr %human_nodename95, align 8
  %call97 = tail call i64 @mstime() #33
  %30 = load ptr, ptr %slaveof, align 8
  %voted_time99 = getelementptr inbounds %struct._clusterNode, ptr %30, i64 0, i32 17
  %31 = load i64, ptr %voted_time99, align 8
  %sub100.neg = sub i64 %mul, %call97
  %sub101 = add i64 %sub100.neg, %31
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.117, ptr noundef nonnull %name93, ptr noundef %29, i64 noundef %sub101) #33
  br label %do.end154

for.body:                                         ; preds = %for.cond.preheader, %for.inc
  %indvars.iv = phi i64 [ 0, %for.cond.preheader ], [ %indvars.iv.next, %for.inc ]
  %32 = trunc i64 %indvars.iv to i32
  %div.i535455 = lshr i64 %indvars.iv, 3
  %conv.i = and i64 %div.i535455, 536870911
  %and.i45 = and i32 %32, 7
  %arrayidx.i = getelementptr inbounds i8, ptr %myslots, i64 %conv.i
  %33 = load i8, ptr %arrayidx.i, align 1
  %conv1.i = zext i8 %33 to i32
  %34 = shl nuw nsw i32 1, %and.i45
  %35 = and i32 %34, %conv1.i
  %cmp107 = icmp eq i32 %35, 0
  br i1 %cmp107, label %for.inc, label %if.end110

if.end110:                                        ; preds = %for.body
  %arrayidx111 = getelementptr inbounds %struct.clusterState, ptr %27, i64 0, i32 9, i64 %indvars.iv
  %36 = load ptr, ptr %arrayidx111, align 8
  %cmp112 = icmp eq ptr %36, null
  br i1 %cmp112, label %for.inc, label %lor.lhs.false114

lor.lhs.false114:                                 ; preds = %if.end110
  %arrayidx.i49 = getelementptr inbounds i8, ptr %owner_not_claiming_slot, i64 %conv.i
  %37 = load i8, ptr %arrayidx.i49, align 1
  %conv1.i50 = zext i8 %37 to i32
  %38 = and i32 %34, %conv1.i50
  %tobool117.not = icmp eq i32 %38, 0
  br i1 %tobool117.not, label %lor.lhs.false118, label %for.inc

lor.lhs.false118:                                 ; preds = %lor.lhs.false114
  %configEpoch122 = getelementptr inbounds %struct._clusterNode, ptr %36, i64 0, i32 4
  %39 = load i64, ptr %configEpoch122, align 8
  %cmp123.not = icmp ugt i64 %39, %call1
  br i1 %cmp123.not, label %do.body127, label %for.inc

do.body127:                                       ; preds = %lor.lhs.false118
  %40 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp128 = icmp sgt i32 %40, 3
  br i1 %cmp128, label %do.end154, label %if.end131

if.end131:                                        ; preds = %do.body127
  %name132 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename134 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %41 = load ptr, ptr %human_nodename134, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.118, ptr noundef nonnull %name132, ptr noundef %41, i32 noundef %32, i64 noundef %39, i64 noundef %call1) #33
  br label %do.end154

for.inc:                                          ; preds = %if.end110, %lor.lhs.false114, %lor.lhs.false118, %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !50

for.end:                                          ; preds = %for.inc
  %currentEpoch140 = getelementptr inbounds %struct.clusterState, ptr %27, i64 0, i32 1
  %42 = load i64, ptr %currentEpoch140, align 8
  %lastVoteEpoch141 = getelementptr inbounds %struct.clusterState, ptr %27, i64 0, i32 21
  store i64 %42, ptr %lastVoteEpoch141, align 8
  %call142 = tail call i64 @mstime() #33
  %43 = load ptr, ptr %slaveof, align 8
  %voted_time144 = getelementptr inbounds %struct._clusterNode, ptr %43, i64 0, i32 17
  store i64 %call142, ptr %voted_time144, align 8
  %44 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %44, i64 0, i32 22
  %45 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %45, 12
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  tail call void @clusterSendFailoverAuth(ptr noundef %node)
  %46 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp146 = icmp sgt i32 %46, 2
  br i1 %cmp146, label %do.end154, label %if.end149

if.end149:                                        ; preds = %for.end
  %name150 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %human_nodename152 = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 23
  %47 = load ptr, ptr %human_nodename152, align 8
  %48 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch153 = getelementptr inbounds %struct.clusterState, ptr %48, i64 0, i32 1
  %49 = load i64, ptr %currentEpoch153, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.119, ptr noundef nonnull %name150, ptr noundef %47, i64 noundef %49) #33
  br label %do.end154

do.end154:                                        ; preds = %for.end, %if.end131, %do.body127, %if.end92, %do.body88, %do.body44, %if.end48, %if.else65, %if.end74, %if.end60, %do.body56, %if.end23, %do.body19, %if.end11, %do.body, %entry, %lor.lhs.false, %if.end149
  ret void
}

declare void @pauseActions(i32 noundef, i64 noundef, i32 noundef) local_unnamed_addr #1

declare void @moduleCallClusterReceivers(ptr noundef, i64 noundef, i8 noundef zeroext, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @handleLinkIOError(ptr noundef %link) local_unnamed_addr #2 {
entry:
  tail call void @freeClusterLink(ptr noundef %link)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterWriteHandler(ptr noundef %conn) #2 {
entry:
  %0 = getelementptr i8, ptr %conn, i64 32
  %conn.val = load ptr, ptr %0, align 8
  %send_msg_queue = getelementptr inbounds %struct.clusterLink, ptr %conn.val, i64 0, i32 2
  %head_msg_send_offset = getelementptr inbounds %struct.clusterLink, ptr %conn.val, i64 0, i32 3
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %conn.val, i64 0, i32 4
  br label %land.rhs

land.rhs:                                         ; preds = %entry, %cond.end30
  %totwritten.034 = phi i64 [ 0, %entry ], [ %add39, %cond.end30 ]
  %1 = load ptr, ptr %send_msg_queue, align 8
  %len = getelementptr inbounds %struct.list, ptr %1, i64 0, i32 5
  %2 = load i64, ptr %len, align 8
  %cmp1.not = icmp eq i64 %2, 0
  br i1 %cmp1.not, label %if.then44, label %while.body

while.body:                                       ; preds = %land.rhs
  %3 = load ptr, ptr %1, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %value, align 8
  %msg4 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %4, i64 0, i32 2
  %5 = load i64, ptr %head_msg_send_offset, align 8
  %totlen = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %4, i64 0, i32 2, i32 1
  %6 = load i32, ptr %totlen, align 4
  %call5 = tail call i32 @ntohl(i32 noundef %6) #36
  %conv = zext i32 %call5 to i64
  %add.ptr = getelementptr inbounds i8, ptr %msg4, i64 %5
  %sub = sub i64 %conv, %5
  %7 = load ptr, ptr %conn, align 8
  %write.i = getelementptr inbounds %struct.ConnectionType, ptr %7, i64 0, i32 16
  %8 = load ptr, ptr %write.i, align 8
  %call.i = tail call i32 %8(ptr noundef nonnull %conn, ptr noundef nonnull %add.ptr, i64 noundef %sub) #33
  %conv7 = sext i32 %call.i to i64
  %cmp8 = icmp slt i32 %call.i, 1
  br i1 %cmp8, label %do.body, label %if.end16

do.body:                                          ; preds = %while.body
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp10 = icmp sgt i32 %9, 0
  br i1 %cmp10, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %cmp13 = icmp eq i32 %call.i, -1
  br i1 %cmp13, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %10 = load ptr, ptr %conn, align 8
  %get_last_error.i = getelementptr inbounds %struct.ConnectionType, ptr %10, i64 0, i32 21
  %11 = load ptr, ptr %get_last_error.i, align 8
  %call.i26 = tail call ptr %11(ptr noundef nonnull %conn) #33
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi ptr [ %call.i26, %cond.true ], [ @.str.101, %if.end ]
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.100, ptr noundef %cond) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %cond.end
  tail call void @freeClusterLink(ptr noundef nonnull %conn.val)
  br label %if.end47

if.end16:                                         ; preds = %while.body
  %add = add i64 %5, %conv7
  %cmp17 = icmp ult i64 %add, %conv
  br i1 %cmp17, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end16
  %12 = load i64, ptr %head_msg_send_offset, align 8
  %add21 = add i64 %12, %conv7
  store i64 %add21, ptr %head_msg_send_offset, align 8
  br label %if.end47

if.end22:                                         ; preds = %if.end16
  %cmp24 = icmp eq i64 %add, %conv
  br i1 %cmp24, label %cond.end30, label %cond.false29

cond.false29:                                     ; preds = %if.end22
  tail call void @_serverAssert(ptr noundef nonnull @.str.102, ptr noundef nonnull @.str.18, i32 noundef 3195) #33
  tail call void @abort() #35
  unreachable

cond.end30:                                       ; preds = %if.end22
  store i64 0, ptr %head_msg_send_offset, align 8
  %13 = load i64, ptr %4, align 8
  %14 = load ptr, ptr %send_msg_queue, align 8
  tail call void @listDelNode(ptr noundef %14, ptr noundef nonnull %3) #33
  %15 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub35 = add i64 %15, -24
  store i64 %sub35, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %conv36 = and i64 %13, 4294967295
  %16 = load i64, ptr %send_msg_queue_mem, align 8
  %reass.sub = sub i64 %16, %conv36
  %sub38 = add i64 %reass.sub, -24
  store i64 %sub38, ptr %send_msg_queue_mem, align 8
  %add39 = add nuw nsw i64 %totwritten.034, %conv7
  %cmp = icmp ult i64 %add39, 65536
  br i1 %cmp, label %land.rhs, label %while.end, !llvm.loop !51

while.end:                                        ; preds = %cond.end30
  %.pre = load ptr, ptr %send_msg_queue, align 8
  %len41.phi.trans.insert = getelementptr inbounds %struct.list, ptr %.pre, i64 0, i32 5
  %.pre39 = load i64, ptr %len41.phi.trans.insert, align 8
  %17 = icmp eq i64 %.pre39, 0
  br i1 %17, label %if.then44, label %if.end47

if.then44:                                        ; preds = %land.rhs, %while.end
  %conn45 = getelementptr inbounds %struct.clusterLink, ptr %conn.val, i64 0, i32 1
  %18 = load ptr, ptr %conn45, align 8
  %19 = load ptr, ptr %18, align 8
  %set_write_handler.i = getelementptr inbounds %struct.ConnectionType, ptr %19, i64 0, i32 19
  %20 = load ptr, ptr %set_write_handler.i, align 8
  %call.i27 = tail call i32 %20(ptr noundef nonnull %18, ptr noundef null, i32 noundef 0) #33
  br label %if.end47

if.end47:                                         ; preds = %if.then44, %while.end, %if.then19, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterLinkConnectHandler(ptr noundef %conn) #2 {
entry:
  %0 = getelementptr i8, ptr %conn, i64 32
  %conn.val16 = load ptr, ptr %0, align 8
  %node1 = getelementptr inbounds %struct.clusterLink, ptr %conn.val16, i64 0, i32 8
  %1 = load ptr, ptr %node1, align 8
  %2 = getelementptr i8, ptr %conn, i64 8
  %conn.val = load i32, ptr %2, align 8
  %cmp.not = icmp eq i32 %conn.val, 3
  br i1 %cmp.not, label %if.end7, label %do.body

do.body:                                          ; preds = %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp3 = icmp sgt i32 %3, 1
  br i1 %cmp3, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %name = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 1
  %ip = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 21
  %cport = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 26
  %4 = load i32, ptr %cport, align 8
  %5 = load ptr, ptr %conn, align 8
  %get_last_error.i = getelementptr inbounds %struct.ConnectionType, ptr %5, i64 0, i32 21
  %6 = load ptr, ptr %get_last_error.i, align 8
  %call.i = tail call ptr %6(ptr noundef nonnull %conn) #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef nonnull @.str.103, ptr noundef nonnull %name, ptr noundef nonnull %ip, i32 noundef %4, ptr noundef %call.i) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  tail call void @freeClusterLink(ptr noundef nonnull %conn.val16)
  br label %do.end24

if.end7:                                          ; preds = %entry
  %7 = load ptr, ptr %conn, align 8
  %set_read_handler.i = getelementptr inbounds %struct.ConnectionType, ptr %7, i64 0, i32 20
  %8 = load ptr, ptr %set_read_handler.i, align 8
  %call.i17 = tail call i32 %8(ptr noundef nonnull %conn, ptr noundef nonnull @clusterReadHandler) #33
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 13
  %9 = load i64, ptr %ping_sent, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 3
  %10 = load i32, ptr %flags, align 8
  %and = lshr i32 %10, 6
  %cond = and i32 %and, 2
  tail call void @clusterSendPing(ptr noundef nonnull %conn.val16, i32 noundef %cond)
  %tobool9.not = icmp eq i64 %9, 0
  br i1 %tobool9.not, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.end7
  store i64 %9, ptr %ping_sent, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end7
  %11 = load i32, ptr %flags, align 8
  %and14 = and i32 %11, -129
  store i32 %and14, ptr %flags, align 8
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp16 = icmp sgt i32 %12, 0
  br i1 %cmp16, label %do.end24, label %if.end18

if.end18:                                         ; preds = %if.end12
  %name19 = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 1
  %ip21 = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 21
  %cport23 = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 26
  %13 = load i32, ptr %cport23, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.104, ptr noundef nonnull %name19, ptr noundef nonnull %ip21, i32 noundef %13) #33
  br label %do.end24

do.end24:                                         ; preds = %if.end12, %if.end18, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterReadHandler(ptr noundef %conn) #2 {
entry:
  %buf = alloca [1 x %struct.clusterMsg], align 16
  %ip = alloca [46 x i8], align 16
  %port = alloca i32, align 4
  %0 = getelementptr i8, ptr %conn, i64 32
  %conn.val48 = load ptr, ptr %0, align 8
  %rcvbuf_len = getelementptr inbounds %struct.clusterLink, ptr %conn.val48, i64 0, i32 6
  %rcvbuf = getelementptr inbounds %struct.clusterLink, ptr %conn.val48, i64 0, i32 5
  %rcvbuf_alloc = getelementptr inbounds %struct.clusterLink, ptr %conn.val48, i64 0, i32 7
  %.pre = load i64, ptr %rcvbuf_len, align 8
  br label %while.body

while.body:                                       ; preds = %while.body.backedge, %entry
  %1 = phi i64 [ %.pre, %entry ], [ %.be, %while.body.backedge ]
  %conv = trunc i64 %1 to i32
  %cmp = icmp ult i32 %conv, 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %sub = sub nuw nsw i32 8, %conv
  br label %if.end40

if.else:                                          ; preds = %while.body
  %2 = load ptr, ptr %rcvbuf, align 8
  %cmp2 = icmp eq i32 %conv, 8
  br i1 %cmp2, label %if.then4, label %if.else.if.end31_crit_edge

if.else.if.end31_crit_edge:                       ; preds = %if.else
  %totlen32.phi.trans.insert = getelementptr inbounds %struct.clusterMsg, ptr %2, i64 0, i32 1
  %.pre60 = load i32, ptr %totlen32.phi.trans.insert, align 4
  %.pre62 = call i32 @ntohl(i32 noundef %.pre60) #36
  br label %if.end31

if.then4:                                         ; preds = %if.else
  %bcmp = call i32 @bcmp(ptr noundef nonnull dereferenceable(4) %2, ptr noundef nonnull dereferenceable(4) @.str.105, i64 4)
  %cmp6.not = icmp eq i32 %bcmp, 0
  br i1 %cmp6.not, label %lor.lhs.false, label %land.lhs.true.i.i

lor.lhs.false:                                    ; preds = %if.then4
  %totlen = getelementptr inbounds %struct.clusterMsg, ptr %2, i64 0, i32 1
  %3 = load i32, ptr %totlen, align 4
  %call8 = call i32 @ntohl(i32 noundef %3) #36
  %cmp10 = icmp ult i32 %call8, 2256
  br i1 %cmp10, label %land.lhs.true.i.i, label %if.end31

land.lhs.true.i.i:                                ; preds = %if.then4, %lor.lhs.false
  %4 = load ptr, ptr %conn, align 8
  %addr.i.i = getelementptr inbounds %struct.ConnectionType, ptr %4, i64 0, i32 6
  %5 = load ptr, ptr %addr.i.i, align 8
  %tobool1.not.i.i = icmp eq ptr %5, null
  br i1 %tobool1.not.i.i, label %do.body, label %connAddrPeerName.exit

connAddrPeerName.exit:                            ; preds = %land.lhs.true.i.i
  %call.i.i = call i32 %5(ptr noundef nonnull %conn, ptr noundef nonnull %ip, i64 noundef 46, ptr noundef nonnull %port, i32 noundef 1) #33
  %cmp15 = icmp eq i32 %call.i.i, -1
  br i1 %cmp15, label %do.body, label %do.body22

do.body:                                          ; preds = %land.lhs.true.i.i, %connAddrPeerName.exit
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp18 = icmp sgt i32 %6, 3
  br i1 %cmp18, label %if.end29, label %if.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.106) #33
  br label %if.end29

do.body22:                                        ; preds = %connAddrPeerName.exit
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp23 = icmp sgt i32 %7, 3
  br i1 %cmp23, label %if.end29, label %if.end26

if.end26:                                         ; preds = %do.body22
  %8 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.107, ptr noundef nonnull %ip, i32 noundef %8) #33
  br label %if.end29

if.end29:                                         ; preds = %if.end26, %do.body22, %if.end, %do.body
  call void @freeClusterLink(ptr noundef nonnull %conn.val48)
  br label %return

if.end31:                                         ; preds = %if.else.if.end31_crit_edge, %lor.lhs.false
  %call33.pre-phi = phi i32 [ %.pre62, %if.else.if.end31_crit_edge ], [ %call8, %lor.lhs.false ]
  %sub34 = sub i32 %call33.pre-phi, %conv
  %spec.store.select = call i32 @llvm.umin.i32(i32 %sub34, i32 4352)
  br label %if.end40

if.end40:                                         ; preds = %if.end31, %if.then
  %readlen.0 = phi i32 [ %sub, %if.then ], [ %spec.store.select, %if.end31 ]
  %conv42 = zext nneg i32 %readlen.0 to i64
  %9 = load ptr, ptr %conn, align 8
  %read.i = getelementptr inbounds %struct.ConnectionType, ptr %9, i64 0, i32 18
  %10 = load ptr, ptr %read.i, align 8
  %call.i = call i32 %10(ptr noundef nonnull %conn, ptr noundef nonnull %buf, i64 noundef %conv42) #33
  %conv44 = sext i32 %call.i to i64
  %cmp45 = icmp eq i32 %call.i, -1
  br i1 %cmp45, label %land.lhs.true, label %if.end51

land.lhs.true:                                    ; preds = %if.end40
  %11 = getelementptr i8, ptr %conn, i64 8
  %conn.val = load i32, ptr %11, align 8
  %cmp48 = icmp eq i32 %conn.val, 3
  br i1 %cmp48, label %return, label %do.body55.thread

if.end51:                                         ; preds = %if.end40
  %cmp52 = icmp slt i32 %call.i, 1
  br i1 %cmp52, label %do.body55, label %if.else64

do.body55:                                        ; preds = %if.end51
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp56 = icmp sgt i32 %12, 0
  br i1 %cmp56, label %do.end63, label %if.end59

do.body55.thread:                                 ; preds = %land.lhs.true
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp5653 = icmp sgt i32 %13, 0
  br i1 %cmp5653, label %do.end63, label %cond.false

if.end59:                                         ; preds = %do.body55
  %cmp60 = icmp eq i32 %call.i, 0
  br i1 %cmp60, label %cond.end, label %cond.false

cond.false:                                       ; preds = %do.body55.thread, %if.end59
  %14 = load ptr, ptr %conn, align 8
  %get_last_error.i = getelementptr inbounds %struct.ConnectionType, ptr %14, i64 0, i32 21
  %15 = load ptr, ptr %get_last_error.i, align 8
  %call.i49 = call ptr %15(ptr noundef nonnull %conn) #33
  br label %cond.end

cond.end:                                         ; preds = %if.end59, %cond.false
  %cond = phi ptr [ %call.i49, %cond.false ], [ @.str.109, %if.end59 ]
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.108, ptr noundef %cond) #33
  br label %do.end63

do.end63:                                         ; preds = %do.body55.thread, %do.body55, %cond.end
  call void @freeClusterLink(ptr noundef %conn.val48)
  br label %return

if.else64:                                        ; preds = %if.end51
  %16 = load i64, ptr %rcvbuf_alloc, align 8
  %17 = load i64, ptr %rcvbuf_len, align 8
  %sub66 = sub i64 %16, %17
  %cmp67 = icmp ult i64 %sub66, %conv44
  br i1 %cmp67, label %if.then69, label %if.end87

if.then69:                                        ; preds = %if.else64
  %add = add i64 %17, %conv44
  %cmp72 = icmp ult i64 %add, 1048576
  %mul = shl i64 %add, 1
  %add76 = add i64 %add, 1048576
  %cond78 = select i1 %cmp72, i64 %mul, i64 %add76
  store i64 %cond78, ptr %rcvbuf_alloc, align 8
  %18 = load ptr, ptr %rcvbuf, align 8
  %call82 = call ptr @zrealloc(ptr noundef %18, i64 noundef %cond78) #38
  store ptr %call82, ptr %rcvbuf, align 8
  %19 = load i64, ptr %rcvbuf_alloc, align 8
  %sub85 = sub i64 %19, %16
  %20 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add86 = add i64 %sub85, %20
  store i64 %add86, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %.pre61 = load i64, ptr %rcvbuf_len, align 8
  br label %if.end87

if.end87:                                         ; preds = %if.then69, %if.else64
  %21 = phi i64 [ %.pre61, %if.then69 ], [ %17, %if.else64 ]
  %22 = load ptr, ptr %rcvbuf, align 8
  %add.ptr = getelementptr inbounds i8, ptr %22, i64 %21
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr nonnull align 16 %buf, i64 %conv44, i1 false)
  %23 = load i64, ptr %rcvbuf_len, align 8
  %add92 = add i64 %23, %conv44
  store i64 %add92, ptr %rcvbuf_len, align 8
  %conv96 = add i32 %call.i, %conv
  %cmp98 = icmp ugt i32 %conv96, 7
  br i1 %cmp98, label %land.lhs.true100, label %while.body.backedge

land.lhs.true100:                                 ; preds = %if.end87
  %24 = load ptr, ptr %rcvbuf, align 8
  %totlen101 = getelementptr inbounds %struct.clusterMsg, ptr %24, i64 0, i32 1
  %25 = load i32, ptr %totlen101, align 4
  %call102 = call i32 @ntohl(i32 noundef %25) #36
  %cmp103 = icmp eq i32 %conv96, %call102
  br i1 %cmp103, label %if.then105, label %while.body.backedge

if.then105:                                       ; preds = %land.lhs.true100
  %call106 = call i32 @clusterProcessPacket(ptr noundef nonnull %conn.val48), !range !18
  %tobool.not = icmp eq i32 %call106, 0
  br i1 %tobool.not, label %return, label %if.then107

if.then107:                                       ; preds = %if.then105
  %26 = load i64, ptr %rcvbuf_alloc, align 8
  %cmp109 = icmp ugt i64 %26, 1024
  br i1 %cmp109, label %if.then111, label %if.end121

if.then111:                                       ; preds = %if.then107
  %27 = load ptr, ptr %rcvbuf, align 8
  call void @zfree(ptr noundef %27) #33
  store i64 1024, ptr %rcvbuf_alloc, align 8
  %call116 = call noalias dereferenceable_or_null(1024) ptr @zmalloc(i64 noundef 1024) #37
  store ptr %call116, ptr %rcvbuf, align 8
  %28 = load i64, ptr %rcvbuf_alloc, align 8
  %sub119 = sub i64 %28, %26
  %29 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add120 = add i64 %sub119, %29
  store i64 %add120, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  br label %if.end121

if.end121:                                        ; preds = %if.then111, %if.then107
  store i64 0, ptr %rcvbuf_len, align 8
  br label %while.body.backedge

while.body.backedge:                              ; preds = %if.end121, %land.lhs.true100, %if.end87
  %.be = phi i64 [ 0, %if.end121 ], [ %add92, %land.lhs.true100 ], [ %add92, %if.end87 ]
  br label %while.body

return:                                           ; preds = %if.then105, %land.lhs.true, %do.end63, %if.end29
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendMessage(ptr noundef %link, ptr noundef %msgblock) local_unnamed_addr #2 {
entry:
  %tobool.not = icmp eq ptr %link, null
  br i1 %tobool.not, label %if.end16, label %if.end

if.end:                                           ; preds = %entry
  %send_msg_queue = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 2
  %0 = load ptr, ptr %send_msg_queue, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %if.end
  %totlen = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %msgblock, i64 0, i32 2, i32 1
  %2 = load i32, ptr %totlen, align 4
  %cmp1.not = icmp eq i32 %2, 0
  br i1 %cmp1.not, label %if.end3, label %if.then2

if.then2:                                         ; preds = %land.lhs.true
  %conn = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %3 = load ptr, ptr %conn, align 8
  %4 = load ptr, ptr %3, align 8
  %set_write_handler.i = getelementptr inbounds %struct.ConnectionType, ptr %4, i64 0, i32 19
  %5 = load ptr, ptr %set_write_handler.i, align 8
  %call.i = tail call i32 %5(ptr noundef nonnull %3, ptr noundef nonnull @clusterWriteHandler, i32 noundef 1) #33
  %.pre = load ptr, ptr %send_msg_queue, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %land.lhs.true, %if.end
  %6 = phi ptr [ %.pre, %if.then2 ], [ %0, %land.lhs.true ], [ %0, %if.end ]
  %call5 = tail call ptr @listAddNodeTail(ptr noundef %6, ptr noundef %msgblock) #33
  %refcount = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %msgblock, i64 0, i32 1
  %7 = load i32, ptr %refcount, align 8
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %refcount, align 8
  %8 = load i64, ptr %msgblock, align 8
  %add = add i64 %8, 24
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 4
  %9 = load i64, ptr %send_msg_queue_mem, align 8
  %add7 = add i64 %add, %9
  store i64 %add7, ptr %send_msg_queue_mem, align 8
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add8 = add i64 %10, 24
  store i64 %add8, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %type10 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %msgblock, i64 0, i32 2, i32 4
  %11 = load i16, ptr %type10, align 4
  %call11 = tail call zeroext i16 @ntohs(i16 noundef zeroext %11) #36
  %cmp12 = icmp ult i16 %call11, 11
  br i1 %cmp12, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end3
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom = zext nneg i16 %call11 to i64
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %12, i64 0, i32 23, i64 %idxprom
  %13 = load i64, ptr %arrayidx, align 8
  %inc15 = add nsw i64 %13, 1
  store i64 %inc15, ptr %arrayidx, align 8
  br label %if.end16

if.end16:                                         ; preds = %entry, %if.then14, %if.end3
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterBroadcastMessage(ptr noundef %msgblock) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  %call13 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not4 = icmp eq ptr %call13, null
  br i1 %cmp.not4, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %totlen.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %msgblock, i64 0, i32 2, i32 1
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %msgblock, i64 0, i32 1
  %type10.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %msgblock, i64 0, i32 2, i32 4
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %call15 = phi ptr [ %call13, %while.body.lr.ph ], [ %call1, %while.cond.backedge ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call15) #33
  %flags = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and = and i32 %2, 48
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %while.cond.backedge

if.end:                                           ; preds = %while.body
  %link = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 27
  %3 = load ptr, ptr %link, align 8
  %tobool.not.i = icmp eq ptr %3, null
  br i1 %tobool.not.i, label %while.cond.backedge, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %send_msg_queue.i = getelementptr inbounds %struct.clusterLink, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %send_msg_queue.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %4, i64 0, i32 5
  %5 = load i64, ptr %len.i, align 8
  %cmp.i = icmp eq i64 %5, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end3.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %6 = load i32, ptr %totlen.i, align 4
  %cmp1.not.i = icmp eq i32 %6, 0
  br i1 %cmp1.not.i, label %if.end3.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %3, i64 0, i32 1
  %7 = load ptr, ptr %conn.i, align 8
  %8 = load ptr, ptr %7, align 8
  %set_write_handler.i.i = getelementptr inbounds %struct.ConnectionType, ptr %8, i64 0, i32 19
  %9 = load ptr, ptr %set_write_handler.i.i, align 8
  %call.i.i = tail call i32 %9(ptr noundef nonnull %7, ptr noundef nonnull @clusterWriteHandler, i32 noundef 1) #33
  %.pre.i = load ptr, ptr %send_msg_queue.i, align 8
  br label %if.end3.i

if.end3.i:                                        ; preds = %if.then2.i, %land.lhs.true.i, %if.end.i
  %10 = phi ptr [ %.pre.i, %if.then2.i ], [ %4, %land.lhs.true.i ], [ %4, %if.end.i ]
  %call5.i = tail call ptr @listAddNodeTail(ptr noundef %10, ptr noundef %msgblock) #33
  %11 = load i32, ptr %refcount.i, align 8
  %inc.i = add nsw i32 %11, 1
  store i32 %inc.i, ptr %refcount.i, align 8
  %12 = load i64, ptr %msgblock, align 8
  %add.i = add i64 %12, 24
  %send_msg_queue_mem.i = getelementptr inbounds %struct.clusterLink, ptr %3, i64 0, i32 4
  %13 = load i64, ptr %send_msg_queue_mem.i, align 8
  %add7.i = add i64 %add.i, %13
  store i64 %add7.i, ptr %send_msg_queue_mem.i, align 8
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add8.i = add i64 %14, 24
  store i64 %add8.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %15 = load i16, ptr %type10.i, align 4
  %call11.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %15) #36
  %cmp12.i = icmp ult i16 %call11.i, 11
  br i1 %cmp12.i, label %if.then14.i, label %while.cond.backedge

if.then14.i:                                      ; preds = %if.end3.i
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom.i = zext nneg i16 %call11.i to i64
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %16, i64 0, i32 23, i64 %idxprom.i
  %17 = load i64, ptr %arrayidx.i, align 8
  %inc15.i = add nsw i64 %17, 1
  store i64 %inc15.i, ptr %arrayidx.i, align 8
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.then14.i, %if.end3.i, %if.end, %while.body
  %call1 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !52

while.end:                                        ; preds = %while.cond.backedge, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable
define dso_local void @clusterSetGossipEntry(ptr nocapture noundef writeonly %hdr, i32 noundef %i, ptr nocapture noundef readonly %n) local_unnamed_addr #25 {
entry:
  %data = getelementptr inbounds %struct.clusterMsg, ptr %hdr, i64 0, i32 20
  %idxprom = sext i32 %i to i64
  %arrayidx = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom
  %name = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 4 dereferenceable(40) %arrayidx, ptr noundef nonnull align 8 dereferenceable(40) %name, i64 40, i1 false)
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 13
  %0 = load i64, ptr %ping_sent, align 8
  %div = sdiv i64 %0, 1000
  %conv = trunc i64 %div to i32
  %call = tail call i32 @htonl(i32 noundef %conv) #36
  %ping_sent3 = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom, i32 1
  store i32 %call, ptr %ping_sent3, align 4
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 14
  %1 = load i64, ptr %pong_received, align 8
  %div4 = sdiv i64 %1, 1000
  %conv5 = trunc i64 %div4 to i32
  %call6 = tail call i32 @htonl(i32 noundef %conv5) #36
  %pong_received7 = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom, i32 2
  store i32 %call6, ptr %pong_received7, align 4
  %ip = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom, i32 3
  %ip9 = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 21
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 4 dereferenceable(46) %ip, ptr noundef nonnull align 8 dereferenceable(46) %ip9, i64 46, i1 false)
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not = icmp eq i32 %2, 0
  %port18 = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom, i32 4
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 25
  %3 = load i32, ptr %tls_port, align 4
  %conv11 = trunc i32 %3 to i16
  %call12 = tail call zeroext i16 @htons(i16 noundef zeroext %conv11) #36
  store i16 %call12, ptr %port18, align 2
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 24
  br label %if.end

if.else:                                          ; preds = %entry
  %tcp_port15 = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 24
  %4 = load i32, ptr %tcp_port15, align 8
  %conv16 = trunc i32 %4 to i16
  %call17 = tail call zeroext i16 @htons(i16 noundef zeroext %conv16) #36
  store i16 %call17, ptr %port18, align 2
  %tls_port19 = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 25
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %.sink.in = phi ptr [ %tls_port19, %if.else ], [ %tcp_port, %if.then ]
  %.sink = load i32, ptr %.sink.in, align 4
  %conv20 = trunc i32 %.sink to i16
  %call21 = tail call zeroext i16 @htons(i16 noundef zeroext %conv20) #36
  %5 = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom, i32 7
  store i16 %call21, ptr %5, align 4
  %cport = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 26
  %6 = load i32, ptr %cport, align 8
  %conv23 = trunc i32 %6 to i16
  %call24 = tail call zeroext i16 @htons(i16 noundef zeroext %conv23) #36
  %cport25 = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom, i32 5
  store i16 %call24, ptr %cport25, align 4
  %flags = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 3
  %7 = load i32, ptr %flags, align 8
  %conv26 = trunc i32 %7 to i16
  %call27 = tail call zeroext i16 @htons(i16 noundef zeroext %conv26) #36
  %flags28 = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom, i32 6
  store i16 %call27, ptr %flags28, align 2
  %notused1 = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %data, i64 0, i64 %idxprom, i32 8
  store i16 0, ptr %notused1, align 2
  ret void
}

; Function Attrs: nounwind uwtable
define internal fastcc ptr @createClusterMsgSendBlock(i32 noundef %type, i32 noundef %msglen) unnamed_addr #2 {
entry:
  %sub = add i32 %msglen, 16
  %conv2 = zext i32 %sub to i64
  %call = tail call noalias ptr @zcalloc(i64 noundef %conv2) #37
  %refcount = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  store i32 1, ptr %refcount, align 8
  store i64 %conv2, ptr %call, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add5 = add i64 %0, %conv2
  store i64 %add5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2
  %1 = load ptr, ptr @myself, align 8
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 3
  %2 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %2, 2
  %tobool.not.i = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i, label %cond.false.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %entry
  %slaveof.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 11
  %3 = load ptr, ptr %slaveof.i, align 8
  %tobool1.not.i = icmp eq ptr %3, null
  br i1 %tobool1.not.i, label %cond.false.i, label %cond.end.i

cond.false.i:                                     ; preds = %land.lhs.true.i, %entry
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false.i, %land.lhs.true.i
  %cond.i = phi ptr [ %1, %cond.false.i ], [ %3, %land.lhs.true.i ]
  %call.i = tail call zeroext i16 @htons(i16 noundef zeroext 1) #36
  %ver.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 2
  store i16 %call.i, ptr %ver.i, align 8
  store <4 x i8> <i8 82, i8 67, i8 109, i8 98>, ptr %msg, align 8
  %conv.i = trunc i32 %type to i16
  %call9.i = tail call zeroext i16 @htons(i16 noundef zeroext %conv.i) #36
  %type10.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 4
  store i16 %call9.i, ptr %type10.i, align 4
  %sender.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 9
  %name.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %sender.i, ptr noundef nonnull align 8 dereferenceable(40) %name.i, i64 40, i1 false)
  %myip.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 12
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(46) %myip.i, i8 0, i64 46, i1 false)
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 373), align 8
  %tobool13.not.i = icmp eq ptr %4, null
  br i1 %tobool13.not.i, label %if.end.i, label %if.then.i

if.then.i:                                        ; preds = %cond.end.i
  %call16.i = tail call i64 @redis_strlcpy(ptr noundef nonnull %myip.i, ptr noundef nonnull %4, i64 noundef 46) #33
  br label %if.end.i

if.end.i:                                         ; preds = %if.then.i, %cond.end.i
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 377), align 4
  %tobool.not.i.i = icmp eq i32 %5, 0
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 44), align 8
  %cond.i.i = select i1 %tobool.not.i.i, i32 %6, i32 %5
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 378), align 8
  %tobool1.not.i.i = icmp eq i32 %7, 0
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 45), align 4
  %cond5.i.i = select i1 %tobool1.not.i.i, i32 %8, i32 %7
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 379), align 4
  %tobool6.not.i.i = icmp eq i32 %9, 0
  br i1 %tobool6.not.i.i, label %if.else.i.i, label %deriveAnnouncedPorts.exit.i

if.else.i.i:                                      ; preds = %if.end.i
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 363), align 8
  %tobool7.not.i.i = icmp eq i32 %10, 0
  br i1 %tobool7.not.i.i, label %if.else9.i.i, label %deriveAnnouncedPorts.exit.i

if.else9.i.i:                                     ; preds = %if.else.i.i
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool.not.i.i.i = icmp eq i32 %11, 0
  %cond.i.i.i = select i1 %tobool.not.i.i.i, i32 %6, i32 %8
  %add.i.i = add nsw i32 %cond.i.i.i, 10000
  br label %deriveAnnouncedPorts.exit.i

deriveAnnouncedPorts.exit.i:                      ; preds = %if.else9.i.i, %if.else.i.i, %if.end.i
  %.sink.i.i = phi i32 [ %add.i.i, %if.else9.i.i ], [ %9, %if.end.i ], [ %10, %if.else.i.i ]
  %myslots.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 10
  %slots.i = getelementptr inbounds %struct._clusterNode, ptr %cond.i, i64 0, i32 5
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(2048) %myslots.i, ptr noundef nonnull align 8 dereferenceable(2048) %slots.i, i64 2048, i1 false)
  %slaveof19.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 11
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %slaveof19.i, i8 0, i64 40, i1 false)
  %12 = load ptr, ptr @myself, align 8
  %slaveof21.i = getelementptr inbounds %struct._clusterNode, ptr %12, i64 0, i32 11
  %13 = load ptr, ptr %slaveof21.i, align 8
  %cmp.not.i = icmp eq ptr %13, null
  br i1 %cmp.not.i, label %if.end29.i, label %if.then23.i

if.then23.i:                                      ; preds = %deriveAnnouncedPorts.exit.i
  %name27.i = getelementptr inbounds %struct._clusterNode, ptr %13, i64 0, i32 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %slaveof19.i, ptr noundef nonnull align 8 dereferenceable(40) %name27.i, i64 40, i1 false)
  br label %if.end29.i

if.end29.i:                                       ; preds = %if.then23.i, %deriveAnnouncedPorts.exit.i
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 402), align 8
  %tobool30.not.i = icmp eq i32 %14, 0
  %cond.i.cond5.i.i = select i1 %tobool30.not.i, i32 %cond.i.i, i32 %cond5.i.i
  %cond5.i.cond.i.i = select i1 %tobool30.not.i, i32 %cond5.i.i, i32 %cond.i.i
  %conv36.i = trunc i32 %cond.i.cond5.i.i to i16
  %call37.i = tail call zeroext i16 @htons(i16 noundef zeroext %conv36.i) #36
  %conv39.i = trunc i32 %cond5.i.cond.i.i to i16
  %call40.i = tail call zeroext i16 @htons(i16 noundef zeroext %conv39.i) #36
  %15 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 3
  store i16 %call37.i, ptr %15, align 2
  %16 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 15
  store i16 %call40.i, ptr %16, align 2
  %conv43.i = trunc i32 %.sink.i.i to i16
  %call44.i = tail call zeroext i16 @htons(i16 noundef zeroext %conv43.i) #36
  %cport.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 16
  store i16 %call44.i, ptr %cport.i, align 8
  %flags45.i = getelementptr inbounds %struct._clusterNode, ptr %12, i64 0, i32 3
  %17 = load i32, ptr %flags45.i, align 8
  %conv46.i = trunc i32 %17 to i16
  %call47.i = tail call zeroext i16 @htons(i16 noundef zeroext %conv46.i) #36
  %flags48.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 17
  store i16 %call47.i, ptr %flags48.i, align 2
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %state.i = getelementptr inbounds %struct.clusterState, ptr %18, i64 0, i32 2
  %19 = load i32, ptr %state.i, align 8
  %conv49.i = trunc i32 %19 to i8
  %state50.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 18
  store i8 %conv49.i, ptr %state50.i, align 4
  %currentEpoch.i = getelementptr inbounds %struct.clusterState, ptr %18, i64 0, i32 1
  %20 = load i64, ptr %currentEpoch.i, align 8
  %call51.i = tail call i64 @intrev64(i64 noundef %20) #33
  %currentEpoch52.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 6
  store i64 %call51.i, ptr %currentEpoch52.i, align 8
  %configEpoch.i = getelementptr inbounds %struct._clusterNode, ptr %cond.i, i64 0, i32 4
  %21 = load i64, ptr %configEpoch.i, align 8
  %call53.i = tail call i64 @intrev64(i64 noundef %21) #33
  %configEpoch54.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 7
  store i64 %call53.i, ptr %configEpoch54.i, align 8
  %22 = load ptr, ptr @myself, align 8
  %flags55.i = getelementptr inbounds %struct._clusterNode, ptr %22, i64 0, i32 3
  %23 = load i32, ptr %flags55.i, align 8
  %and56.i = and i32 %23, 2
  %tobool57.not.i = icmp eq i32 %and56.i, 0
  br i1 %tobool57.not.i, label %if.else60.i, label %if.then58.i

if.then58.i:                                      ; preds = %if.end29.i
  %call59.i = tail call i64 @replicationGetSlaveOffset() #33
  br label %if.end61.i

if.else60.i:                                      ; preds = %if.end29.i
  %24 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  br label %if.end61.i

if.end61.i:                                       ; preds = %if.else60.i, %if.then58.i
  %offset.0.i = phi i64 [ %call59.i, %if.then58.i ], [ %24, %if.else60.i ]
  %call62.i = tail call i64 @intrev64(i64 noundef %offset.0.i) #33
  %offset63.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 8
  store i64 %call62.i, ptr %offset63.i, align 8
  %25 = load ptr, ptr @myself, align 8
  %flags.i.i = getelementptr inbounds %struct._clusterNode, ptr %25, i64 0, i32 3
  %26 = load i32, ptr %flags.i.i, align 8
  %and.i.i = and i32 %26, 1
  %tobool65.not.i = icmp eq i32 %and.i.i, 0
  br i1 %tobool65.not.i, label %clusterBuildMessageHdr.exit, label %land.lhs.true66.i

land.lhs.true66.i:                                ; preds = %if.end61.i
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end.i = getelementptr inbounds %struct.clusterState, ptr %27, i64 0, i32 17
  %28 = load i64, ptr %mf_end.i, align 8
  %tobool67.not.i = icmp eq i64 %28, 0
  br i1 %tobool67.not.i, label %clusterBuildMessageHdr.exit, label %if.then68.i

if.then68.i:                                      ; preds = %land.lhs.true66.i
  %mflags.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 19
  %29 = load i8, ptr %mflags.i, align 1
  %30 = or i8 %29, 1
  store i8 %30, ptr %mflags.i, align 1
  br label %clusterBuildMessageHdr.exit

clusterBuildMessageHdr.exit:                      ; preds = %if.end61.i, %land.lhs.true66.i, %if.then68.i
  %call74.i = tail call i32 @htonl(i32 noundef %msglen) #36
  %totlen.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 1
  store i32 %call74.i, ptr %totlen.i, align 4
  ret ptr %call
}

declare ptr @dictGetRandomKey(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterBroadcastPong(i32 noundef %target) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  %call110 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not11 = icmp eq ptr %call110, null
  br i1 %cmp.not11, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %cmp7 = icmp eq i32 %target, 1
  br i1 %cmp7, label %while.body.us, label %while.body

while.body.us:                                    ; preds = %while.body.lr.ph, %while.cond.backedge.us
  %call112.us = phi ptr [ %call1.us, %while.cond.backedge.us ], [ %call110, %while.body.lr.ph ]
  %call2.us = tail call ptr @dictGetVal(ptr noundef nonnull %call112.us) #33
  %link.us = getelementptr inbounds %struct._clusterNode, ptr %call2.us, i64 0, i32 27
  %2 = load ptr, ptr %link.us, align 8
  %tobool.not.us = icmp eq ptr %2, null
  br i1 %tobool.not.us, label %while.cond.backedge.us, label %if.end.us

if.end.us:                                        ; preds = %while.body.us
  %3 = load ptr, ptr @myself, align 8
  %cmp3.us = icmp eq ptr %call2.us, %3
  br i1 %cmp3.us, label %while.cond.backedge.us, label %lor.lhs.false.us

lor.lhs.false.us:                                 ; preds = %if.end.us
  %flags.us = getelementptr inbounds %struct._clusterNode, ptr %call2.us, i64 0, i32 3
  %4 = load i32, ptr %flags.us, align 8
  %5 = and i32 %4, 34
  %or.cond.not = icmp eq i32 %5, 2
  br i1 %or.cond.not, label %land.lhs.true.us, label %while.cond.backedge.us

land.lhs.true.us:                                 ; preds = %lor.lhs.false.us
  %slaveof.us = getelementptr inbounds %struct._clusterNode, ptr %call2.us, i64 0, i32 11
  %6 = load ptr, ptr %slaveof.us, align 8
  %tobool12.not.us = icmp eq ptr %6, null
  br i1 %tobool12.not.us, label %while.cond.backedge.us, label %land.rhs.us

land.rhs.us:                                      ; preds = %land.lhs.true.us
  %cmp14.us = icmp eq ptr %6, %3
  br i1 %cmp14.us, label %if.end21.us, label %lor.rhs.us

lor.rhs.us:                                       ; preds = %land.rhs.us
  %slaveof16.us = getelementptr inbounds %struct._clusterNode, ptr %3, i64 0, i32 11
  %7 = load ptr, ptr %slaveof16.us, align 8
  %cmp17.us = icmp eq ptr %6, %7
  br i1 %cmp17.us, label %if.end21.us, label %while.cond.backedge.us

if.end21.us:                                      ; preds = %lor.rhs.us, %land.rhs.us
  tail call void @clusterSendPing(ptr noundef nonnull %2, i32 noundef 1)
  br label %while.cond.backedge.us

while.cond.backedge.us:                           ; preds = %if.end.us, %lor.lhs.false.us, %land.lhs.true.us, %if.end21.us, %lor.rhs.us, %while.body.us
  %call1.us = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not.us = icmp eq ptr %call1.us, null
  br i1 %cmp.not.us, label %while.end, label %while.body.us, !llvm.loop !53

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %call112 = phi ptr [ %call1, %while.cond.backedge ], [ %call110, %while.body.lr.ph ]
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call112) #33
  %link = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 27
  %8 = load ptr, ptr %link, align 8
  %tobool.not = icmp eq ptr %8, null
  %9 = load ptr, ptr @myself, align 8
  %cmp3 = icmp eq ptr %call2, %9
  %or.cond13 = select i1 %tobool.not, i1 true, i1 %cmp3
  br i1 %or.cond13, label %while.cond.backedge, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %flags = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 3
  %10 = load i32, ptr %flags, align 8
  %and = and i32 %10, 32
  %tobool4.not = icmp eq i32 %and, 0
  br i1 %tobool4.not, label %if.end6, label %while.cond.backedge

while.cond.backedge:                              ; preds = %lor.lhs.false, %if.end6, %while.body
  %call1 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body, !llvm.loop !53

if.end6:                                          ; preds = %lor.lhs.false
  tail call void @clusterSendPing(ptr noundef nonnull %8, i32 noundef 1)
  br label %while.cond.backedge

while.end:                                        ; preds = %while.cond.backedge, %while.cond.backedge.us, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterCreatePublishMsgBlock(ptr noundef %channel, ptr noundef %message, i16 noundef zeroext %type) local_unnamed_addr #2 {
entry:
  %call = tail call ptr @getDecodedObject(ptr noundef %channel) #33
  %call1 = tail call ptr @getDecodedObject(ptr noundef %message) #33
  %ptr = getelementptr inbounds %struct.redisObject, ptr %call, i64 0, i32 2
  %0 = load ptr, ptr %ptr, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %1 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %0, i64 -3
  %2 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %2 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %0, i64 -5
  %3 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %3 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %0, i64 -9
  %4 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %4 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %0, i64 -17
  %5 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %entry, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %5, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %entry ]
  %conv = trunc i64 %retval.0.i to i32
  %ptr3 = getelementptr inbounds %struct.redisObject, ptr %call1, i64 0, i32 2
  %6 = load ptr, ptr %ptr3, align 8
  %arrayidx.i17 = getelementptr inbounds i8, ptr %6, i64 -1
  %7 = load i8, ptr %arrayidx.i17, align 1
  %conv.i18 = zext i8 %7 to i32
  %and.i19 = and i32 %conv.i18, 7
  switch i32 %and.i19, label %sdslen.exit35 [
    i32 0, label %sw.bb.i32
    i32 1, label %sw.bb3.i29
    i32 2, label %sw.bb5.i26
    i32 3, label %sw.bb9.i23
    i32 4, label %sw.bb13.i20
  ]

sw.bb.i32:                                        ; preds = %sdslen.exit
  %shr.i33 = lshr i32 %conv.i18, 3
  %conv2.i34 = zext nneg i32 %shr.i33 to i64
  br label %sdslen.exit35

sw.bb3.i29:                                       ; preds = %sdslen.exit
  %add.ptr.i30 = getelementptr inbounds i8, ptr %6, i64 -3
  %8 = load i8, ptr %add.ptr.i30, align 1
  %conv4.i31 = zext i8 %8 to i64
  br label %sdslen.exit35

sw.bb5.i26:                                       ; preds = %sdslen.exit
  %add.ptr6.i27 = getelementptr inbounds i8, ptr %6, i64 -5
  %9 = load i16, ptr %add.ptr6.i27, align 1
  %conv8.i28 = zext i16 %9 to i64
  br label %sdslen.exit35

sw.bb9.i23:                                       ; preds = %sdslen.exit
  %add.ptr10.i24 = getelementptr inbounds i8, ptr %6, i64 -9
  %10 = load i32, ptr %add.ptr10.i24, align 1
  %conv12.i25 = zext i32 %10 to i64
  br label %sdslen.exit35

sw.bb13.i20:                                      ; preds = %sdslen.exit
  %add.ptr14.i21 = getelementptr inbounds i8, ptr %6, i64 -17
  %11 = load i64, ptr %add.ptr14.i21, align 1
  br label %sdslen.exit35

sdslen.exit35:                                    ; preds = %sdslen.exit, %sw.bb.i32, %sw.bb3.i29, %sw.bb5.i26, %sw.bb9.i23, %sw.bb13.i20
  %retval.0.i22 = phi i64 [ %11, %sw.bb13.i20 ], [ %conv12.i25, %sw.bb9.i23 ], [ %conv8.i28, %sw.bb5.i26 ], [ %conv4.i31, %sw.bb3.i29 ], [ %conv2.i34, %sw.bb.i32 ], [ 0, %sdslen.exit ]
  %conv5 = trunc i64 %retval.0.i22 to i32
  %add = add i64 %retval.0.i, 8
  %add8 = add i64 %add, %retval.0.i22
  %conv10 = zext i16 %type to i32
  %12 = trunc i64 %add8 to i32
  %conv11 = add i32 %12, 2256
  %call12 = tail call fastcc ptr @createClusterMsgSendBlock(i32 noundef %conv10, i32 noundef %conv11)
  %call13 = tail call i32 @htonl(i32 noundef %conv) #36
  %data = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call12, i64 0, i32 2, i32 20
  store i32 %call13, ptr %data, align 8
  %call16 = tail call i32 @htonl(i32 noundef %conv5) #36
  %message_len19 = getelementptr inbounds i8, ptr %call12, i64 2276
  store i32 %call16, ptr %message_len19, align 4
  %bulk_data = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call12, i64 0, i32 2, i32 20, i32 0, i32 0, i32 1
  %13 = load ptr, ptr %ptr, align 8
  %arrayidx.i36 = getelementptr inbounds i8, ptr %13, i64 -1
  %14 = load i8, ptr %arrayidx.i36, align 1
  %conv.i37 = zext i8 %14 to i32
  %and.i38 = and i32 %conv.i37, 7
  switch i32 %and.i38, label %sdslen.exit54 [
    i32 0, label %sw.bb.i51
    i32 1, label %sw.bb3.i48
    i32 2, label %sw.bb5.i45
    i32 3, label %sw.bb9.i42
    i32 4, label %sw.bb13.i39
  ]

sw.bb.i51:                                        ; preds = %sdslen.exit35
  %shr.i52 = lshr i32 %conv.i37, 3
  %conv2.i53 = zext nneg i32 %shr.i52 to i64
  br label %sdslen.exit54

sw.bb3.i48:                                       ; preds = %sdslen.exit35
  %add.ptr.i49 = getelementptr inbounds i8, ptr %13, i64 -3
  %15 = load i8, ptr %add.ptr.i49, align 1
  %conv4.i50 = zext i8 %15 to i64
  br label %sdslen.exit54

sw.bb5.i45:                                       ; preds = %sdslen.exit35
  %add.ptr6.i46 = getelementptr inbounds i8, ptr %13, i64 -5
  %16 = load i16, ptr %add.ptr6.i46, align 1
  %conv8.i47 = zext i16 %16 to i64
  br label %sdslen.exit54

sw.bb9.i42:                                       ; preds = %sdslen.exit35
  %add.ptr10.i43 = getelementptr inbounds i8, ptr %13, i64 -9
  %17 = load i32, ptr %add.ptr10.i43, align 1
  %conv12.i44 = zext i32 %17 to i64
  br label %sdslen.exit54

sw.bb13.i39:                                      ; preds = %sdslen.exit35
  %add.ptr14.i40 = getelementptr inbounds i8, ptr %13, i64 -17
  %18 = load i64, ptr %add.ptr14.i40, align 1
  br label %sdslen.exit54

sdslen.exit54:                                    ; preds = %sdslen.exit35, %sw.bb.i51, %sw.bb3.i48, %sw.bb5.i45, %sw.bb9.i42, %sw.bb13.i39
  %retval.0.i41 = phi i64 [ %18, %sw.bb13.i39 ], [ %conv12.i44, %sw.bb9.i42 ], [ %conv8.i47, %sw.bb5.i45 ], [ %conv4.i50, %sw.bb3.i48 ], [ %conv2.i53, %sw.bb.i51 ], [ 0, %sdslen.exit35 ]
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %bulk_data, ptr nonnull align 1 %13, i64 %retval.0.i41, i1 false)
  %19 = load ptr, ptr %ptr, align 8
  %arrayidx.i55 = getelementptr inbounds i8, ptr %19, i64 -1
  %20 = load i8, ptr %arrayidx.i55, align 1
  %conv.i56 = zext i8 %20 to i32
  %and.i57 = and i32 %conv.i56, 7
  switch i32 %and.i57, label %sdslen.exit73 [
    i32 0, label %sw.bb.i70
    i32 1, label %sw.bb3.i67
    i32 2, label %sw.bb5.i64
    i32 3, label %sw.bb9.i61
    i32 4, label %sw.bb13.i58
  ]

sw.bb.i70:                                        ; preds = %sdslen.exit54
  %shr.i71 = lshr i32 %conv.i56, 3
  %conv2.i72 = zext nneg i32 %shr.i71 to i64
  br label %sdslen.exit73

sw.bb3.i67:                                       ; preds = %sdslen.exit54
  %add.ptr.i68 = getelementptr inbounds i8, ptr %19, i64 -3
  %21 = load i8, ptr %add.ptr.i68, align 1
  %conv4.i69 = zext i8 %21 to i64
  br label %sdslen.exit73

sw.bb5.i64:                                       ; preds = %sdslen.exit54
  %add.ptr6.i65 = getelementptr inbounds i8, ptr %19, i64 -5
  %22 = load i16, ptr %add.ptr6.i65, align 1
  %conv8.i66 = zext i16 %22 to i64
  br label %sdslen.exit73

sw.bb9.i61:                                       ; preds = %sdslen.exit54
  %add.ptr10.i62 = getelementptr inbounds i8, ptr %19, i64 -9
  %23 = load i32, ptr %add.ptr10.i62, align 1
  %conv12.i63 = zext i32 %23 to i64
  br label %sdslen.exit73

sw.bb13.i58:                                      ; preds = %sdslen.exit54
  %add.ptr14.i59 = getelementptr inbounds i8, ptr %19, i64 -17
  %24 = load i64, ptr %add.ptr14.i59, align 1
  br label %sdslen.exit73

sdslen.exit73:                                    ; preds = %sdslen.exit54, %sw.bb.i70, %sw.bb3.i67, %sw.bb5.i64, %sw.bb9.i61, %sw.bb13.i58
  %retval.0.i60 = phi i64 [ %24, %sw.bb13.i58 ], [ %conv12.i63, %sw.bb9.i61 ], [ %conv8.i66, %sw.bb5.i64 ], [ %conv4.i69, %sw.bb3.i67 ], [ %conv2.i72, %sw.bb.i70 ], [ 0, %sdslen.exit54 ]
  %25 = load ptr, ptr %ptr3, align 8
  %arrayidx.i74 = getelementptr inbounds i8, ptr %25, i64 -1
  %26 = load i8, ptr %arrayidx.i74, align 1
  %conv.i75 = zext i8 %26 to i32
  %and.i76 = and i32 %conv.i75, 7
  switch i32 %and.i76, label %sdslen.exit92 [
    i32 0, label %sw.bb.i89
    i32 1, label %sw.bb3.i86
    i32 2, label %sw.bb5.i83
    i32 3, label %sw.bb9.i80
    i32 4, label %sw.bb13.i77
  ]

sw.bb.i89:                                        ; preds = %sdslen.exit73
  %shr.i90 = lshr i32 %conv.i75, 3
  %conv2.i91 = zext nneg i32 %shr.i90 to i64
  br label %sdslen.exit92

sw.bb3.i86:                                       ; preds = %sdslen.exit73
  %add.ptr.i87 = getelementptr inbounds i8, ptr %25, i64 -3
  %27 = load i8, ptr %add.ptr.i87, align 1
  %conv4.i88 = zext i8 %27 to i64
  br label %sdslen.exit92

sw.bb5.i83:                                       ; preds = %sdslen.exit73
  %add.ptr6.i84 = getelementptr inbounds i8, ptr %25, i64 -5
  %28 = load i16, ptr %add.ptr6.i84, align 1
  %conv8.i85 = zext i16 %28 to i64
  br label %sdslen.exit92

sw.bb9.i80:                                       ; preds = %sdslen.exit73
  %add.ptr10.i81 = getelementptr inbounds i8, ptr %25, i64 -9
  %29 = load i32, ptr %add.ptr10.i81, align 1
  %conv12.i82 = zext i32 %29 to i64
  br label %sdslen.exit92

sw.bb13.i77:                                      ; preds = %sdslen.exit73
  %add.ptr14.i78 = getelementptr inbounds i8, ptr %25, i64 -17
  %30 = load i64, ptr %add.ptr14.i78, align 1
  br label %sdslen.exit92

sdslen.exit92:                                    ; preds = %sdslen.exit73, %sw.bb.i89, %sw.bb3.i86, %sw.bb5.i83, %sw.bb9.i80, %sw.bb13.i77
  %retval.0.i79 = phi i64 [ %30, %sw.bb13.i77 ], [ %conv12.i82, %sw.bb9.i80 ], [ %conv8.i85, %sw.bb5.i83 ], [ %conv4.i88, %sw.bb3.i86 ], [ %conv2.i91, %sw.bb.i89 ], [ 0, %sdslen.exit73 ]
  %add.ptr = getelementptr inbounds i8, ptr %bulk_data, i64 %retval.0.i60
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %add.ptr, ptr nonnull align 1 %25, i64 %retval.0.i79, i1 false)
  tail call void @decrRefCount(ptr noundef nonnull %call) #33
  tail call void @decrRefCount(ptr noundef nonnull %call1) #33
  ret ptr %call12
}

declare ptr @getDecodedObject(ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendModule(ptr noundef %link, i64 noundef %module_id, i8 noundef zeroext %type, ptr nocapture noundef readonly %payload, i32 noundef %len) local_unnamed_addr #2 {
entry:
  %conv = zext i32 %len to i64
  %add2 = add i32 %len, 2269
  %call = tail call fastcc ptr @createClusterMsgSendBlock(i32 noundef 9, i32 noundef %add2)
  %data = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20
  store i64 %module_id, ptr %data, align 8
  %type8 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20, i32 0, i32 0, i32 1, i64 4
  store i8 %type, ptr %type8, align 4
  %call9 = tail call i32 @htonl(i32 noundef %len) #36
  %len12 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20, i32 0, i32 0, i32 1
  store i32 %call9, ptr %len12, align 8
  %bulk_data = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 20, i32 0, i32 0, i32 1, i64 5
  tail call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %bulk_data, ptr align 1 %payload, i64 %conv, i1 false)
  %tobool.not = icmp eq ptr %link, null
  br i1 %tobool.not, label %if.else, label %if.end.i

if.end.i:                                         ; preds = %entry
  %send_msg_queue.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 2
  %0 = load ptr, ptr %send_msg_queue.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %0, i64 0, i32 5
  %1 = load i64, ptr %len.i, align 8
  %cmp.i = icmp eq i64 %1, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end3.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %totlen.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 1
  %2 = load i32, ptr %totlen.i, align 4
  %cmp1.not.i = icmp eq i32 %2, 0
  br i1 %cmp1.not.i, label %if.end3.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %3 = load ptr, ptr %conn.i, align 8
  %4 = load ptr, ptr %3, align 8
  %set_write_handler.i.i = getelementptr inbounds %struct.ConnectionType, ptr %4, i64 0, i32 19
  %5 = load ptr, ptr %set_write_handler.i.i, align 8
  %call.i.i = tail call i32 %5(ptr noundef nonnull %3, ptr noundef nonnull @clusterWriteHandler, i32 noundef 1) #33
  %.pre.i = load ptr, ptr %send_msg_queue.i, align 8
  br label %if.end3.i

if.end3.i:                                        ; preds = %if.then2.i, %land.lhs.true.i, %if.end.i
  %6 = phi ptr [ %.pre.i, %if.then2.i ], [ %0, %land.lhs.true.i ], [ %0, %if.end.i ]
  %call5.i = tail call ptr @listAddNodeTail(ptr noundef %6, ptr noundef nonnull %call) #33
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %7 = load i32, ptr %refcount.i, align 8
  %inc.i = add nsw i32 %7, 1
  store i32 %inc.i, ptr %refcount.i, align 8
  %8 = load i64, ptr %call, align 8
  %add.i = add i64 %8, 24
  %send_msg_queue_mem.i = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 4
  %9 = load i64, ptr %send_msg_queue_mem.i, align 8
  %add7.i = add i64 %add.i, %9
  store i64 %add7.i, ptr %send_msg_queue_mem.i, align 8
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add8.i = add i64 %10, 24
  store i64 %add8.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %type10.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 4
  %11 = load i16, ptr %type10.i, align 4
  %call11.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %11) #36
  %cmp12.i = icmp ult i16 %call11.i, 11
  br i1 %cmp12.i, label %if.then14.i, label %if.end

if.then14.i:                                      ; preds = %if.end3.i
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom.i = zext nneg i16 %call11.i to i64
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %12, i64 0, i32 23, i64 %idxprom.i
  %13 = load i64, ptr %arrayidx.i, align 8
  %inc15.i = add nsw i64 %13, 1
  store i64 %inc15.i, ptr %arrayidx.i, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  tail call void @clusterBroadcastMessage(ptr noundef nonnull %call)
  br label %if.end

if.end:                                           ; preds = %if.then14.i, %if.end3.i, %if.else
  %refcount.i11 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %14 = load i32, ptr %refcount.i11, align 8
  %dec.i = add nsw i32 %14, -1
  store i32 %dec.i, ptr %refcount.i11, align 8
  %cmp.i12 = icmp sgt i32 %14, 0
  br i1 %cmp.i12, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %if.end
  %cmp4.i = icmp eq i32 %dec.i, 0
  br i1 %cmp4.i, label %if.then.i, label %clusterMsgSendBlockDecrRefCount.exit

if.then.i:                                        ; preds = %cond.end.i
  %15 = load i64, ptr %call, align 8
  %16 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i = sub i64 %16, %15
  store i64 %sub.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %call) #33
  br label %clusterMsgSendBlockDecrRefCount.exit

clusterMsgSendBlockDecrRefCount.exit:             ; preds = %cond.end.i, %if.then.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterSendModuleMessageToTarget(ptr noundef %target, i64 noundef %module_id, i8 noundef zeroext %type, ptr nocapture noundef readonly %payload, i32 noundef %len) local_unnamed_addr #2 {
entry:
  %cmp.not = icmp eq ptr %target, null
  br i1 %cmp.not, label %cond.end, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %target) #34
  %conv = trunc i64 %call to i32
  %call.i = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %target, i32 noundef %conv) #33
  %cmp.not.i = icmp eq i32 %call.i, 0
  br i1 %cmp.not.i, label %if.end.i, label %return

if.end.i:                                         ; preds = %if.then
  %sext = shl i64 %call, 32
  %conv.i = ashr exact i64 %sext, 32
  %call1.i = tail call ptr @sdsnewlen(ptr noundef nonnull %target, i64 noundef %conv.i) #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes.i, align 8
  %call2.i = tail call ptr @dictFind(ptr noundef %1, ptr noundef %call1.i) #33
  tail call void @sdsfree(ptr noundef %call1.i) #33
  %cmp3.i = icmp eq ptr %call2.i, null
  br i1 %cmp3.i, label %return, label %clusterLookupNode.exit

clusterLookupNode.exit:                           ; preds = %if.end.i
  %call7.i = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i) #33
  %cmp2 = icmp eq ptr %call7.i, null
  br i1 %cmp2, label %return, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %clusterLookupNode.exit
  %link = getelementptr inbounds %struct._clusterNode, ptr %call7.i, i64 0, i32 27
  %2 = load ptr, ptr %link, align 8
  %cmp4 = icmp eq ptr %2, null
  br i1 %cmp4, label %return, label %cond.end

cond.end:                                         ; preds = %lor.lhs.false, %entry
  %cond = phi ptr [ null, %entry ], [ %2, %lor.lhs.false ]
  tail call void @clusterSendModule(ptr noundef %cond, i64 noundef %module_id, i8 noundef zeroext %type, ptr noundef %payload, i32 noundef %len)
  br label %return

return:                                           ; preds = %if.end.i, %if.then, %clusterLookupNode.exit, %lor.lhs.false, %cond.end
  %retval.0 = phi i32 [ 0, %cond.end ], [ -1, %lor.lhs.false ], [ -1, %clusterLookupNode.exit ], [ -1, %if.then ], [ -1, %if.end.i ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterPropagatePublish(ptr noundef %channel, ptr noundef %message, i32 noundef %sharded) local_unnamed_addr #2 {
entry:
  %li = alloca %struct.listIter, align 8
  %tobool.not = icmp eq i32 %sharded, 0
  br i1 %tobool.not, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call ptr @clusterCreatePublishMsgBlock(ptr noundef %channel, ptr noundef %message, i16 noundef zeroext 4)
  tail call void @clusterBroadcastMessage(ptr noundef %call)
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %0 = load i32, ptr %refcount.i, align 8
  %dec.i = add nsw i32 %0, -1
  store i32 %dec.i, ptr %refcount.i, align 8
  %cmp.i = icmp sgt i32 %0, 0
  br i1 %cmp.i, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %if.then
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %if.then
  %cmp4.i = icmp eq i32 %dec.i, 0
  br i1 %cmp4.i, label %if.then.i, label %return

if.then.i:                                        ; preds = %cond.end.i
  %1 = load i64, ptr %call, align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i = sub i64 %2, %1
  store i64 %sub.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %call) #33
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %4 = load ptr, ptr %3, align 8
  %shard_id.i = getelementptr inbounds %struct._clusterNode, ptr %4, i64 0, i32 2
  %call.i = tail call ptr @sdsnewlen(ptr noundef nonnull %shard_id.i, i64 noundef 40) #33
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards.i = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 5
  %6 = load ptr, ptr %shards.i, align 8
  %call1.i = tail call ptr @dictFind(ptr noundef %6, ptr noundef %call.i) #33
  tail call void @sdsfree(ptr noundef %call.i) #33
  %cmp.not.i = icmp eq ptr %call1.i, null
  br i1 %cmp.not.i, label %cond.false, label %clusterGetNodesInMyShard.exit

clusterGetNodesInMyShard.exit:                    ; preds = %if.end
  %call2.i = tail call ptr @dictGetVal(ptr noundef nonnull %call1.i) #33
  %cmp.not = icmp eq ptr %call2.i, null
  br i1 %cmp.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end, %clusterGetNodesInMyShard.exit
  tail call void @_serverAssert(ptr noundef nonnull @.str.111, ptr noundef nonnull @.str.18, i32 noundef 3783) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %clusterGetNodesInMyShard.exit
  call void @listRewind(ptr noundef nonnull %call2.i, ptr noundef nonnull %li) #33
  %call4 = call ptr @clusterCreatePublishMsgBlock(ptr noundef %channel, ptr noundef %message, i16 noundef zeroext 10)
  %call523 = call ptr @listNext(ptr noundef nonnull %li) #33
  %tobool6.not24 = icmp eq ptr %call523, null
  br i1 %tobool6.not24, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %cond.end
  %totlen.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call4, i64 0, i32 2, i32 1
  %refcount.i10 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call4, i64 0, i32 1
  %type10.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call4, i64 0, i32 2, i32 4
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %while.cond.backedge
  %call525 = phi ptr [ %call523, %while.body.lr.ph ], [ %call5, %while.cond.backedge ]
  %value = getelementptr inbounds %struct.listNode, ptr %call525, i64 0, i32 2
  %7 = load ptr, ptr %value, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %7, i64 0, i32 3
  %8 = load i32, ptr %flags, align 8
  %and = and i32 %8, 48
  %tobool7.not = icmp eq i32 %and, 0
  br i1 %tobool7.not, label %if.end9, label %while.cond.backedge

if.end9:                                          ; preds = %while.body
  %link = getelementptr inbounds %struct._clusterNode, ptr %7, i64 0, i32 27
  %9 = load ptr, ptr %link, align 8
  %tobool.not.i = icmp eq ptr %9, null
  br i1 %tobool.not.i, label %while.cond.backedge, label %if.end.i

if.end.i:                                         ; preds = %if.end9
  %send_msg_queue.i = getelementptr inbounds %struct.clusterLink, ptr %9, i64 0, i32 2
  %10 = load ptr, ptr %send_msg_queue.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %10, i64 0, i32 5
  %11 = load i64, ptr %len.i, align 8
  %cmp.i9 = icmp eq i64 %11, 0
  br i1 %cmp.i9, label %land.lhs.true.i, label %if.end3.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %12 = load i32, ptr %totlen.i, align 4
  %cmp1.not.i = icmp eq i32 %12, 0
  br i1 %cmp1.not.i, label %if.end3.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %9, i64 0, i32 1
  %13 = load ptr, ptr %conn.i, align 8
  %14 = load ptr, ptr %13, align 8
  %set_write_handler.i.i = getelementptr inbounds %struct.ConnectionType, ptr %14, i64 0, i32 19
  %15 = load ptr, ptr %set_write_handler.i.i, align 8
  %call.i.i = call i32 %15(ptr noundef nonnull %13, ptr noundef nonnull @clusterWriteHandler, i32 noundef 1) #33
  %.pre.i = load ptr, ptr %send_msg_queue.i, align 8
  br label %if.end3.i

if.end3.i:                                        ; preds = %if.then2.i, %land.lhs.true.i, %if.end.i
  %16 = phi ptr [ %.pre.i, %if.then2.i ], [ %10, %land.lhs.true.i ], [ %10, %if.end.i ]
  %call5.i = call ptr @listAddNodeTail(ptr noundef %16, ptr noundef %call4) #33
  %17 = load i32, ptr %refcount.i10, align 8
  %inc.i = add nsw i32 %17, 1
  store i32 %inc.i, ptr %refcount.i10, align 8
  %18 = load i64, ptr %call4, align 8
  %add.i = add i64 %18, 24
  %send_msg_queue_mem.i = getelementptr inbounds %struct.clusterLink, ptr %9, i64 0, i32 4
  %19 = load i64, ptr %send_msg_queue_mem.i, align 8
  %add7.i = add i64 %add.i, %19
  store i64 %add7.i, ptr %send_msg_queue_mem.i, align 8
  %20 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add8.i = add i64 %20, 24
  store i64 %add8.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %21 = load i16, ptr %type10.i, align 4
  %call11.i = call zeroext i16 @ntohs(i16 noundef zeroext %21) #36
  %cmp12.i = icmp ult i16 %call11.i, 11
  br i1 %cmp12.i, label %if.then14.i, label %while.cond.backedge

if.then14.i:                                      ; preds = %if.end3.i
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom.i = zext nneg i16 %call11.i to i64
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %22, i64 0, i32 23, i64 %idxprom.i
  %23 = load i64, ptr %arrayidx.i, align 8
  %inc15.i = add nsw i64 %23, 1
  store i64 %inc15.i, ptr %arrayidx.i, align 8
  br label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.then14.i, %if.end3.i, %if.end9, %while.body
  %call5 = call ptr @listNext(ptr noundef nonnull %li) #33
  %tobool6.not = icmp eq ptr %call5, null
  br i1 %tobool6.not, label %while.end, label %while.body, !llvm.loop !54

while.end:                                        ; preds = %while.cond.backedge, %cond.end
  %refcount.i11 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call4, i64 0, i32 1
  %24 = load i32, ptr %refcount.i11, align 8
  %dec.i12 = add nsw i32 %24, -1
  store i32 %dec.i12, ptr %refcount.i11, align 8
  %cmp.i13 = icmp sgt i32 %24, 0
  br i1 %cmp.i13, label %cond.end.i15, label %cond.false.i14

cond.false.i14:                                   ; preds = %while.end
  call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  call void @abort() #35
  unreachable

cond.end.i15:                                     ; preds = %while.end
  %cmp4.i16 = icmp eq i32 %dec.i12, 0
  br i1 %cmp4.i16, label %if.then.i18, label %return

if.then.i18:                                      ; preds = %cond.end.i15
  %25 = load i64, ptr %call4, align 8
  %26 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i19 = sub i64 %26, %25
  store i64 %sub.i19, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  call void @zfree(ptr noundef nonnull %call4) #33
  br label %return

return:                                           ; preds = %if.then.i18, %cond.end.i15, %if.then.i, %cond.end.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterRequestFailoverAuth() local_unnamed_addr #2 {
entry:
  %call = tail call fastcc ptr @createClusterMsgSendBlock(i32 noundef 5, i32 noundef 2256)
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 17
  %1 = load i64, ptr %mf_end, align 8
  %tobool.not = icmp eq i64 %1, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mflags = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 19
  %2 = load i8, ptr %mflags, align 1
  %3 = or i8 %2, 2
  store i8 %3, ptr %mflags, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  tail call void @clusterBroadcastMessage(ptr noundef %call)
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %4 = load i32, ptr %refcount.i, align 8
  %dec.i = add nsw i32 %4, -1
  store i32 %dec.i, ptr %refcount.i, align 8
  %cmp.i = icmp sgt i32 %4, 0
  br i1 %cmp.i, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %if.end
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %if.end
  %cmp4.i = icmp eq i32 %dec.i, 0
  br i1 %cmp4.i, label %if.then.i, label %clusterMsgSendBlockDecrRefCount.exit

if.then.i:                                        ; preds = %cond.end.i
  %5 = load i64, ptr %call, align 8
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i = sub i64 %6, %5
  store i64 %sub.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %call) #33
  br label %clusterMsgSendBlockDecrRefCount.exit

clusterMsgSendBlockDecrRefCount.exit:             ; preds = %cond.end.i, %if.then.i
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendFailoverAuth(ptr nocapture noundef readonly %node) local_unnamed_addr #2 {
entry:
  %link = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 27
  %0 = load ptr, ptr %link, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call fastcc ptr @createClusterMsgSendBlock(i32 noundef 6, i32 noundef 2256)
  %1 = load ptr, ptr %link, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %clusterSendMessage.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %send_msg_queue.i = getelementptr inbounds %struct.clusterLink, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %send_msg_queue.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %2, i64 0, i32 5
  %3 = load i64, ptr %len.i, align 8
  %cmp.i = icmp eq i64 %3, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end3.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %totlen.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 1
  %4 = load i32, ptr %totlen.i, align 4
  %cmp1.not.i = icmp eq i32 %4, 0
  br i1 %cmp1.not.i, label %if.end3.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %1, i64 0, i32 1
  %5 = load ptr, ptr %conn.i, align 8
  %6 = load ptr, ptr %5, align 8
  %set_write_handler.i.i = getelementptr inbounds %struct.ConnectionType, ptr %6, i64 0, i32 19
  %7 = load ptr, ptr %set_write_handler.i.i, align 8
  %call.i.i = tail call i32 %7(ptr noundef nonnull %5, ptr noundef nonnull @clusterWriteHandler, i32 noundef 1) #33
  %.pre.i = load ptr, ptr %send_msg_queue.i, align 8
  br label %if.end3.i

if.end3.i:                                        ; preds = %if.then2.i, %land.lhs.true.i, %if.end.i
  %8 = phi ptr [ %.pre.i, %if.then2.i ], [ %2, %land.lhs.true.i ], [ %2, %if.end.i ]
  %call5.i = tail call ptr @listAddNodeTail(ptr noundef %8, ptr noundef %call) #33
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %9 = load i32, ptr %refcount.i, align 8
  %inc.i = add nsw i32 %9, 1
  store i32 %inc.i, ptr %refcount.i, align 8
  %10 = load i64, ptr %call, align 8
  %add.i = add i64 %10, 24
  %send_msg_queue_mem.i = getelementptr inbounds %struct.clusterLink, ptr %1, i64 0, i32 4
  %11 = load i64, ptr %send_msg_queue_mem.i, align 8
  %add7.i = add i64 %add.i, %11
  store i64 %add7.i, ptr %send_msg_queue_mem.i, align 8
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add8.i = add i64 %12, 24
  store i64 %add8.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %type10.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 4
  %13 = load i16, ptr %type10.i, align 4
  %call11.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %13) #36
  %cmp12.i = icmp ult i16 %call11.i, 11
  br i1 %cmp12.i, label %if.then14.i, label %clusterSendMessage.exit

if.then14.i:                                      ; preds = %if.end3.i
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom.i = zext nneg i16 %call11.i to i64
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 23, i64 %idxprom.i
  %15 = load i64, ptr %arrayidx.i, align 8
  %inc15.i = add nsw i64 %15, 1
  store i64 %inc15.i, ptr %arrayidx.i, align 8
  br label %clusterSendMessage.exit

clusterSendMessage.exit:                          ; preds = %if.end, %if.end3.i, %if.then14.i
  %refcount.i3 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %16 = load i32, ptr %refcount.i3, align 8
  %dec.i = add nsw i32 %16, -1
  store i32 %dec.i, ptr %refcount.i3, align 8
  %cmp.i4 = icmp sgt i32 %16, 0
  br i1 %cmp.i4, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %clusterSendMessage.exit
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %clusterSendMessage.exit
  %cmp4.i = icmp eq i32 %dec.i, 0
  br i1 %cmp4.i, label %if.then.i, label %return

if.then.i:                                        ; preds = %cond.end.i
  %17 = load i64, ptr %call, align 8
  %18 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i = sub i64 %18, %17
  store i64 %sub.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %call) #33
  br label %return

return:                                           ; preds = %if.then.i, %cond.end.i, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendMFStart(ptr nocapture noundef readonly %node) local_unnamed_addr #2 {
entry:
  %link = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 27
  %0 = load ptr, ptr %link, align 8
  %tobool.not = icmp eq ptr %0, null
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call fastcc ptr @createClusterMsgSendBlock(i32 noundef 8, i32 noundef 2256)
  %1 = load ptr, ptr %link, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %clusterSendMessage.exit, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %send_msg_queue.i = getelementptr inbounds %struct.clusterLink, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %send_msg_queue.i, align 8
  %len.i = getelementptr inbounds %struct.list, ptr %2, i64 0, i32 5
  %3 = load i64, ptr %len.i, align 8
  %cmp.i = icmp eq i64 %3, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %if.end3.i

land.lhs.true.i:                                  ; preds = %if.end.i
  %totlen.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 1
  %4 = load i32, ptr %totlen.i, align 4
  %cmp1.not.i = icmp eq i32 %4, 0
  br i1 %cmp1.not.i, label %if.end3.i, label %if.then2.i

if.then2.i:                                       ; preds = %land.lhs.true.i
  %conn.i = getelementptr inbounds %struct.clusterLink, ptr %1, i64 0, i32 1
  %5 = load ptr, ptr %conn.i, align 8
  %6 = load ptr, ptr %5, align 8
  %set_write_handler.i.i = getelementptr inbounds %struct.ConnectionType, ptr %6, i64 0, i32 19
  %7 = load ptr, ptr %set_write_handler.i.i, align 8
  %call.i.i = tail call i32 %7(ptr noundef nonnull %5, ptr noundef nonnull @clusterWriteHandler, i32 noundef 1) #33
  %.pre.i = load ptr, ptr %send_msg_queue.i, align 8
  br label %if.end3.i

if.end3.i:                                        ; preds = %if.then2.i, %land.lhs.true.i, %if.end.i
  %8 = phi ptr [ %.pre.i, %if.then2.i ], [ %2, %land.lhs.true.i ], [ %2, %if.end.i ]
  %call5.i = tail call ptr @listAddNodeTail(ptr noundef %8, ptr noundef %call) #33
  %refcount.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %9 = load i32, ptr %refcount.i, align 8
  %inc.i = add nsw i32 %9, 1
  store i32 %inc.i, ptr %refcount.i, align 8
  %10 = load i64, ptr %call, align 8
  %add.i = add i64 %10, 24
  %send_msg_queue_mem.i = getelementptr inbounds %struct.clusterLink, ptr %1, i64 0, i32 4
  %11 = load i64, ptr %send_msg_queue_mem.i, align 8
  %add7.i = add i64 %add.i, %11
  store i64 %add7.i, ptr %send_msg_queue_mem.i, align 8
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add8.i = add i64 %12, 24
  store i64 %add8.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %type10.i = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 2, i32 4
  %13 = load i16, ptr %type10.i, align 4
  %call11.i = tail call zeroext i16 @ntohs(i16 noundef zeroext %13) #36
  %cmp12.i = icmp ult i16 %call11.i, 11
  br i1 %cmp12.i, label %if.then14.i, label %clusterSendMessage.exit

if.then14.i:                                      ; preds = %if.end3.i
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom.i = zext nneg i16 %call11.i to i64
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 23, i64 %idxprom.i
  %15 = load i64, ptr %arrayidx.i, align 8
  %inc15.i = add nsw i64 %15, 1
  store i64 %inc15.i, ptr %arrayidx.i, align 8
  br label %clusterSendMessage.exit

clusterSendMessage.exit:                          ; preds = %if.end, %if.end3.i, %if.then14.i
  %refcount.i3 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %call, i64 0, i32 1
  %16 = load i32, ptr %refcount.i3, align 8
  %dec.i = add nsw i32 %16, -1
  store i32 %dec.i, ptr %refcount.i3, align 8
  %cmp.i4 = icmp sgt i32 %16, 0
  br i1 %cmp.i4, label %cond.end.i, label %cond.false.i

cond.false.i:                                     ; preds = %clusterSendMessage.exit
  tail call void @_serverAssert(ptr noundef nonnull @.str.306, ptr noundef nonnull @.str.18, i32 noundef 1153) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %clusterSendMessage.exit
  %cmp4.i = icmp eq i32 %dec.i, 0
  br i1 %cmp4.i, label %if.then.i, label %return

if.then.i:                                        ; preds = %cond.end.i
  %17 = load i64, ptr %call, align 8
  %18 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %sub.i = sub i64 %18, %17
  store i64 %sub.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  tail call void @zfree(ptr noundef nonnull %call) #33
  br label %return

return:                                           ; preds = %if.then.i, %cond.end.i, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterGetSlaveRank() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.120, ptr noundef nonnull @.str.18, i32 noundef 3961) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 11
  %2 = load ptr, ptr %slaveof, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %cond.end
  %call = tail call i64 @replicationGetSlaveOffset() #33
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 9
  %3 = load i32, ptr %numslaves, align 8
  %cmp411 = icmp sgt i32 %3, 0
  br i1 %cmp411, label %for.body.lr.ph, label %return

for.body.lr.ph:                                   ; preds = %if.end
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 10
  %4 = load ptr, ptr %slaves, align 8
  %5 = load ptr, ptr @myself, align 8
  %wide.trip.count = zext nneg i32 %3 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.inc ]
  %rank.013 = phi i32 [ 0, %for.body.lr.ph ], [ %rank.1, %for.inc ]
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv
  %6 = load ptr, ptr %arrayidx, align 8
  %cmp6.not = icmp eq ptr %6, %5
  br i1 %cmp6.not, label %for.inc, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %flags11 = getelementptr inbounds %struct._clusterNode, ptr %6, i64 0, i32 3
  %7 = load i32, ptr %flags11, align 8
  %and12 = and i32 %7, 512
  %tobool13.not = icmp eq i32 %and12, 0
  br i1 %tobool13.not, label %land.lhs.true14, label %for.inc

land.lhs.true14:                                  ; preds = %land.lhs.true
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %6, i64 0, i32 20
  %8 = load i64, ptr %repl_offset, align 8
  %cmp18 = icmp sgt i64 %8, %call
  %inc = zext i1 %cmp18 to i32
  %spec.select = add nsw i32 %rank.013, %inc
  br label %for.inc

for.inc:                                          ; preds = %land.lhs.true14, %for.body, %land.lhs.true
  %rank.1 = phi i32 [ %rank.013, %land.lhs.true ], [ %rank.013, %for.body ], [ %spec.select, %land.lhs.true14 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %return, label %for.body, !llvm.loop !55

return:                                           ; preds = %for.inc, %if.end, %cond.end
  %retval.0 = phi i32 [ 0, %cond.end ], [ 0, %if.end ], [ %rank.1, %for.inc ]
  ret i32 %retval.0
}

declare i64 @replicationGetSlaveOffset() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterLogCantFailover(i32 noundef %reason) local_unnamed_addr #2 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %add = add nsw i64 %0, 5000
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %cant_failover_reason = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 16
  %2 = load i32, ptr %cant_failover_reason, align 8
  %cmp = icmp eq i32 %2, %reason
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call = tail call i64 @time(ptr noundef null) #33
  %3 = load i64, ptr @clusterLogCantFailover.lastlog_time, align 8
  %sub = sub nsw i64 %call, %3
  %cmp1 = icmp slt i64 %sub, 10
  br i1 %cmp1, label %if.end29, label %land.lhs.true.if.end_crit_edge

land.lhs.true.if.end_crit_edge:                   ; preds = %land.lhs.true
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end

if.end:                                           ; preds = %land.lhs.true.if.end_crit_edge, %entry
  %4 = phi ptr [ %.pre, %land.lhs.true.if.end_crit_edge ], [ %1, %entry ]
  %cant_failover_reason2 = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 16
  store i32 %reason, ptr %cant_failover_reason2, align 8
  %5 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %5, i64 0, i32 11
  %6 = load ptr, ptr %slaveof, align 8
  %tobool.not = icmp eq ptr %6, null
  br i1 %tobool.not, label %if.end12, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %if.end
  %flags = getelementptr inbounds %struct._clusterNode, ptr %6, i64 0, i32 3
  %7 = load i32, ptr %flags, align 8
  %and = and i32 %7, 8
  %tobool5.not = icmp eq i32 %and, 0
  br i1 %tobool5.not, label %if.end12, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true3
  %call7 = tail call i64 @mstime() #33
  %8 = load ptr, ptr @myself, align 8
  %slaveof8 = getelementptr inbounds %struct._clusterNode, ptr %8, i64 0, i32 11
  %9 = load ptr, ptr %slaveof8, align 8
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %9, i64 0, i32 16
  %10 = load i64, ptr %fail_time, align 8
  %sub9 = sub nsw i64 %call7, %10
  %cmp10 = icmp slt i64 %sub9, %add
  br i1 %cmp10, label %if.end29, label %if.end12

if.end12:                                         ; preds = %land.lhs.true6, %land.lhs.true3, %if.end
  %switch.tableidx = add i32 %reason, -1
  %11 = icmp ult i32 %switch.tableidx, 4
  br i1 %11, label %switch.lookup, label %sw.epilog

switch.lookup:                                    ; preds = %if.end12
  %12 = zext nneg i32 %switch.tableidx to i64
  %switch.gep = getelementptr inbounds [4 x ptr], ptr @switch.table.clusterLogCantFailover, i64 0, i64 %12
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end12, %switch.lookup
  %msg.0 = phi ptr [ %switch.load, %switch.lookup ], [ @.str.125, %if.end12 ]
  %call16 = tail call i64 @time(ptr noundef null) #33
  store i64 %call16, ptr @clusterLogCantFailover.lastlog_time, align 8
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp17 = icmp sgt i32 %13, 2
  br i1 %cmp17, label %if.end29, label %do.end

do.end:                                           ; preds = %sw.epilog
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.126, ptr noundef nonnull %msg.0) #33
  %.pre6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %14 = icmp sgt i32 %.pre6, 2
  %15 = add i32 %reason, -5
  %or.cond = icmp ult i32 %15, -2
  %or.cond1 = select i1 %or.cond, i1 true, i1 %14
  br i1 %or.cond1, label %if.end29, label %if.end27

if.end27:                                         ; preds = %do.end
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %16, i64 0, i32 3
  %17 = load i32, ptr %size, align 4
  %div = sdiv i32 %17, 2
  %add20 = add nsw i32 %div, 1
  %failover_auth_count = getelementptr inbounds %struct.clusterState, ptr %16, i64 0, i32 12
  %18 = load i32, ptr %failover_auth_count, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.127, i32 noundef %add20, i32 noundef %18) #33
  br label %if.end29

if.end29:                                         ; preds = %sw.epilog, %if.end27, %do.end, %land.lhs.true6, %land.lhs.true
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterFailoverReplaceYourMaster() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 11
  %1 = load ptr, ptr %slaveof, align 8
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 3
  %2 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %2, 1
  %tobool = icmp ne i32 %and.i, 0
  %cmp = icmp eq ptr %1, null
  %or.cond = select i1 %tobool, i1 true, i1 %cmp
  br i1 %or.cond, label %return, label %if.then2.i

if.then2.i:                                       ; preds = %entry
  %numslaves.i.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 9
  %3 = load i32, ptr %numslaves.i.i, align 8
  %cmp19.i.i = icmp sgt i32 %3, 0
  br i1 %cmp19.i.i, label %for.body.lr.ph.i.i, label %clusterSetNodeAsMaster.exit

for.body.lr.ph.i.i:                               ; preds = %if.then2.i
  %slaves.i.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 10
  %4 = load ptr, ptr %slaves.i.i, align 8
  %wide.trip.count.i.i = zext nneg i32 %3 to i64
  br label %for.body.i.i

for.body.i.i:                                     ; preds = %for.inc.i.i, %for.body.lr.ph.i.i
  %indvars.iv.i.i = phi i64 [ 0, %for.body.lr.ph.i.i ], [ %indvars.iv.next.i.i, %for.inc.i.i ]
  %arrayidx.i.i = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv.i.i
  %5 = load ptr, ptr %arrayidx.i.i, align 8
  %cmp1.i.i = icmp eq ptr %5, %0
  br i1 %cmp1.i.i, label %if.then.i.i, label %for.inc.i.i

if.then.i.i:                                      ; preds = %for.body.i.i
  %6 = trunc i64 %indvars.iv.i.i to i32
  %add.i.i = add nuw nsw i32 %6, 1
  %cmp3.i.i = icmp slt i32 %add.i.i, %3
  br i1 %cmp3.i.i, label %if.then4.i.i, label %if.end.i.i

if.then4.i.i:                                     ; preds = %if.then.i.i
  %arrayidx.i.i.le = getelementptr inbounds ptr, ptr %4, i64 %indvars.iv.i.i
  %7 = xor i32 %6, -1
  %sub6.i.i = add nsw i32 %3, %7
  %idx.ext10.i.i = zext nneg i32 %add.i.i to i64
  %add.ptr11.i.i = getelementptr inbounds ptr, ptr %4, i64 %idx.ext10.i.i
  %conv.i.i = sext i32 %sub6.i.i to i64
  %mul.i.i = shl nsw i64 %conv.i.i, 3
  tail call void @llvm.memmove.p0.p0.i64(ptr nonnull align 8 %arrayidx.i.i.le, ptr nonnull align 8 %add.ptr11.i.i, i64 %mul.i.i, i1 false)
  %.pre.i.i = load i32, ptr %numslaves.i.i, align 8
  br label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then4.i.i, %if.then.i.i
  %8 = phi i32 [ %.pre.i.i, %if.then4.i.i ], [ %3, %if.then.i.i ]
  %dec.i.i = add nsw i32 %8, -1
  store i32 %dec.i.i, ptr %numslaves.i.i, align 8
  %cmp14.i.i = icmp eq i32 %dec.i.i, 0
  br i1 %cmp14.i.i, label %if.then16.i.i, label %clusterSetNodeAsMaster.exit

if.then16.i.i:                                    ; preds = %if.end.i.i
  %flags.i9.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 3
  %9 = load i32, ptr %flags.i9.i, align 8
  %and.i10.i = and i32 %9, -257
  store i32 %and.i10.i, ptr %flags.i9.i, align 8
  br label %clusterSetNodeAsMaster.exit

for.inc.i.i:                                      ; preds = %for.body.i.i
  %indvars.iv.next.i.i = add nuw nsw i64 %indvars.iv.i.i, 1
  %exitcond.not.i.i = icmp eq i64 %indvars.iv.next.i.i, %wide.trip.count.i.i
  br i1 %exitcond.not.i.i, label %clusterSetNodeAsMaster.exit, label %for.body.i.i, !llvm.loop !24

clusterSetNodeAsMaster.exit:                      ; preds = %for.inc.i.i, %if.then16.i.i, %if.end.i.i, %if.then2.i
  %10 = load ptr, ptr @myself, align 8
  %cmp.not.i = icmp eq ptr %10, %0
  %.pre.i = load i32, ptr %flags.i, align 8
  %or.i = or i32 %.pre.i, 256
  %spec.select.i = select i1 %cmp.not.i, i32 %.pre.i, i32 %or.i
  %and.i6 = and i32 %spec.select.i, -4
  %or10.i = or disjoint i32 %and.i6, 1
  store i32 %or10.i, ptr %flags.i, align 8
  store ptr null, ptr %slaveof, align 8
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i.i = getelementptr inbounds %struct.clusterState, ptr %11, i64 0, i32 22
  %12 = load i32, ptr %todo_before_sleep.i.i, align 8
  %or.i.i = or i32 %12, 6
  store i32 %or.i.i, ptr %todo_before_sleep.i.i, align 8
  tail call void @replicationUnsetMaster() #33
  %slots.i = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 5
  br label %for.body

for.body:                                         ; preds = %clusterSetNodeAsMaster.exit, %for.inc
  %indvars.iv = phi i64 [ 0, %clusterSetNodeAsMaster.exit ], [ %indvars.iv.next, %for.inc ]
  %13 = trunc i64 %indvars.iv to i32
  %div.i.i252627 = lshr i64 %indvars.iv, 3
  %conv.i.i7 = and i64 %div.i.i252627, 536870911
  %and.i.i8 = and i32 %13, 7
  %arrayidx.i.i9 = getelementptr inbounds i8, ptr %slots.i, i64 %conv.i.i7
  %14 = load i8, ptr %arrayidx.i.i9, align 1
  %conv1.i.i = zext i8 %14 to i32
  %15 = shl nuw nsw i32 1, %and.i.i8
  %16 = and i32 %15, %conv1.i.i
  %tobool3.not = icmp eq i32 %16, 0
  br i1 %tobool3.not, label %for.inc, label %if.then4

if.then4:                                         ; preds = %for.body
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %17, i64 0, i32 9, i64 %indvars.iv
  %18 = load ptr, ptr %arrayidx.i, align 8
  %tobool.not.i10 = icmp eq ptr %18, null
  br i1 %tobool.not.i10, label %if.end.i19, label %if.end.i11

if.end.i11:                                       ; preds = %if.then4
  tail call void @removeChannelsInSlot(i32 noundef %13)
  %slots.i.i = getelementptr inbounds %struct._clusterNode, ptr %18, i64 0, i32 5
  %arrayidx.i.i.i = getelementptr inbounds i8, ptr %slots.i.i, i64 %conv.i.i7
  %19 = load i8, ptr %arrayidx.i.i.i, align 1
  %conv1.i.i.i = zext i8 %19 to i32
  %20 = and i32 %15, %conv1.i.i.i
  %tobool.not.i.i = icmp eq i32 %20, 0
  br i1 %tobool.not.i.i, label %cond.false.i, label %clusterDelSlot.exit

cond.false.i:                                     ; preds = %if.end.i11
  tail call void @_serverAssert(ptr noundef nonnull @.str.138, ptr noundef nonnull @.str.18, i32 noundef 4866) #33
  tail call void @abort() #35
  unreachable

clusterDelSlot.exit:                              ; preds = %if.end.i11
  %21 = trunc i32 %15 to i8
  %22 = xor i8 %21, -1
  %conv3.i9.i.i = and i8 %19, %22
  store i8 %conv3.i9.i.i, ptr %arrayidx.i.i.i, align 1
  %numslots.i.i = getelementptr inbounds %struct._clusterNode, ptr %18, i64 0, i32 8
  %23 = load i32, ptr %numslots.i.i, align 4
  %dec.i.i12 = add nsw i32 %23, -1
  store i32 %dec.i.i12, ptr %numslots.i.i, align 4
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5.i = getelementptr inbounds %struct.clusterState, ptr %24, i64 0, i32 9, i64 %indvars.iv
  store ptr null, ptr %arrayidx5.i, align 8
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot.i = getelementptr inbounds %struct.clusterState, ptr %25, i64 0, i32 27
  %arrayidx.i.i13 = getelementptr inbounds i8, ptr %owner_not_claiming_slot.i, i64 %conv.i.i7
  %26 = load i8, ptr %arrayidx.i.i13, align 1
  %conv3.i.i14 = and i8 %26, %22
  store i8 %conv3.i.i14, ptr %arrayidx.i.i13, align 1
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx.i16.phi.trans.insert = getelementptr inbounds %struct.clusterState, ptr %.pre, i64 0, i32 9, i64 %indvars.iv
  %.pre34 = load ptr, ptr %arrayidx.i16.phi.trans.insert, align 8
  %tobool.not.i17 = icmp eq ptr %.pre34, null
  br i1 %tobool.not.i17, label %if.end.i19, label %for.inc

if.end.i19:                                       ; preds = %if.then4, %clusterDelSlot.exit
  %27 = load ptr, ptr @myself, align 8
  %call.i = tail call i32 @clusterNodeSetSlotBit(ptr noundef %27, i32 noundef %13), !range !18
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx3.i = getelementptr inbounds %struct.clusterState, ptr %28, i64 0, i32 9, i64 %indvars.iv
  store ptr %27, ptr %arrayidx3.i, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end.i19, %clusterDelSlot.exit, %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !56

for.end:                                          ; preds = %for.inc
  tail call void @clusterUpdateState()
  %call.i20 = tail call i32 @clusterSaveConfig(i32 noundef 1), !range !21
  %cmp.i = icmp eq i32 %call.i20, -1
  br i1 %cmp.i, label %do.body.i, label %clusterSaveConfigOrDie.exit

do.body.i:                                        ; preds = %for.end
  %29 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i = icmp sgt i32 %29, 3
  br i1 %cmp1.i, label %do.end.i, label %if.end.i21

if.end.i21:                                       ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.38) #33
  br label %do.end.i

do.end.i:                                         ; preds = %if.end.i21, %do.body.i
  tail call void @exit(i32 noundef 1) #35
  unreachable

clusterSaveConfigOrDie.exit:                      ; preds = %for.end
  tail call void @clusterBroadcastPong(i32 noundef 0)
  %30 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_slave.i = getelementptr inbounds %struct.clusterState, ptr %30, i64 0, i32 18
  %31 = load ptr, ptr %mf_slave.i, align 8
  %tobool.not.i22 = icmp eq ptr %31, null
  br i1 %tobool.not.i22, label %resetManualFailover.exit, label %if.then.i

if.then.i:                                        ; preds = %clusterSaveConfigOrDie.exit
  tail call void @unpauseActions(i32 noundef 2) #33
  %.pre.i23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %resetManualFailover.exit

resetManualFailover.exit:                         ; preds = %clusterSaveConfigOrDie.exit, %if.then.i
  %32 = phi ptr [ %.pre.i23, %if.then.i ], [ %30, %clusterSaveConfigOrDie.exit ]
  %mf_end.i = getelementptr inbounds %struct.clusterState, ptr %32, i64 0, i32 17
  %mf_can_start.i = getelementptr inbounds %struct.clusterState, ptr %32, i64 0, i32 20
  store i32 0, ptr %mf_can_start.i, align 8
  %mf_master_offset.i = getelementptr inbounds %struct.clusterState, ptr %32, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mf_end.i, i8 0, i64 16, i1 false)
  store i64 -1, ptr %mf_master_offset.i, align 8
  br label %return

return:                                           ; preds = %entry, %resetManualFailover.exit
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @clusterNodeCoversSlot(ptr nocapture noundef readonly %n, i32 noundef %slot) local_unnamed_addr #5 {
entry:
  %slots = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 5
  %div.i = sdiv i32 %slot, 8
  %conv.i = sext i32 %div.i to i64
  %and.i = and i32 %slot, 7
  %arrayidx.i = getelementptr inbounds i8, ptr %slots, i64 %conv.i
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv1.i = zext i8 %0 to i32
  %1 = lshr i32 %conv1.i, %and.i
  %conv3.i = and i32 %1, 1
  ret i32 %conv3.i
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateState() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 22
  %1 = load i32, ptr %todo_before_sleep, align 8
  %and = and i32 %1, -3
  store i32 %and, ptr %todo_before_sleep, align 8
  %2 = load i64, ptr @clusterUpdateState.first_call_time, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = tail call i64 @mstime() #33
  store i64 %call, ptr @clusterUpdateState.first_call_time, align 8
  %.pre.pre27.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %.pre.pre27 = phi ptr [ %.pre.pre27.pre, %if.then ], [ %0, %entry ]
  %3 = load ptr, ptr @myself, align 8
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %3, i64 0, i32 3
  %4 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %4, 1
  %tobool.not = icmp eq i32 %and.i, 0
  br i1 %tobool.not, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %state = getelementptr inbounds %struct.clusterState, ptr %.pre.pre27, i64 0, i32 2
  %5 = load i32, ptr %state, align 8
  %cmp2 = icmp eq i32 %5, 1
  br i1 %cmp2, label %land.lhs.true3, label %if.end7

land.lhs.true3:                                   ; preds = %land.lhs.true
  %call4 = tail call i64 @mstime() #33
  %6 = load i64, ptr @clusterUpdateState.first_call_time, align 8
  %sub = sub nsw i64 %call4, %6
  %cmp5 = icmp slt i64 %sub, 2000
  br i1 %cmp5, label %if.end72, label %land.lhs.true3.if.end7_crit_edge

land.lhs.true3.if.end7_crit_edge:                 ; preds = %land.lhs.true3
  %.pre.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end7

if.end7:                                          ; preds = %land.lhs.true3.if.end7_crit_edge, %land.lhs.true, %if.end
  %.pre = phi ptr [ %.pre.pre, %land.lhs.true3.if.end7_crit_edge ], [ %.pre.pre27, %land.lhs.true ], [ %.pre.pre27, %if.end ]
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 371), align 4
  %tobool8.not = icmp eq i32 %7, 0
  br i1 %tobool8.not, label %if.end19, label %for.body

for.cond:                                         ; preds = %lor.lhs.false
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %if.end19, label %for.body, !llvm.loop !57

for.body:                                         ; preds = %if.end7, %for.cond
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond ], [ 0, %if.end7 ]
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %.pre, i64 0, i32 9, i64 %indvars.iv
  %8 = load ptr, ptr %arrayidx, align 8
  %cmp11 = icmp eq ptr %8, null
  br i1 %cmp11, label %if.end19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %flags = getelementptr inbounds %struct._clusterNode, ptr %8, i64 0, i32 3
  %9 = load i32, ptr %flags, align 8
  %and15 = and i32 %9, 8
  %tobool16.not = icmp eq i32 %and15, 0
  br i1 %tobool16.not, label %for.cond, label %if.end19

if.end19:                                         ; preds = %for.body, %lor.lhs.false, %for.cond, %if.end7
  %new_state.0 = phi i32 [ 0, %if.end7 ], [ 1, %for.body ], [ 1, %lor.lhs.false ], [ 0, %for.cond ]
  %size = getelementptr inbounds %struct.clusterState, ptr %.pre, i64 0, i32 3
  store i32 0, ptr %size, align 4
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %10, i64 0, i32 4
  %11 = load ptr, ptr %nodes, align 8
  %call20 = tail call ptr @dictGetSafeIterator(ptr noundef %11) #33
  %call2121 = tail call ptr @dictNext(ptr noundef %call20) #33
  %cmp22.not22 = icmp eq ptr %call2121, null
  br i1 %cmp22.not22, label %while.end, label %while.body

while.body:                                       ; preds = %if.end19, %if.end37
  %call2124 = phi ptr [ %call21, %if.end37 ], [ %call2121, %if.end19 ]
  %reachable_masters.023 = phi i32 [ %reachable_masters.1, %if.end37 ], [ 0, %if.end19 ]
  %call23 = tail call ptr @dictGetVal(ptr noundef nonnull %call2124) #33
  %flags.i16 = getelementptr inbounds %struct._clusterNode, ptr %call23, i64 0, i32 3
  %12 = load i32, ptr %flags.i16, align 8
  %and.i17 = and i32 %12, 1
  %tobool25.not = icmp eq i32 %and.i17, 0
  br i1 %tobool25.not, label %if.end37, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %while.body
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %call23, i64 0, i32 8
  %13 = load i32, ptr %numslots, align 4
  %tobool27.not = icmp eq i32 %13, 0
  br i1 %tobool27.not, label %if.end37, label %if.then28

if.then28:                                        ; preds = %land.lhs.true26
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %size29 = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 3
  %15 = load i32, ptr %size29, align 4
  %inc30 = add nsw i32 %15, 1
  store i32 %inc30, ptr %size29, align 4
  %16 = load i32, ptr %flags.i16, align 8
  %and32 = and i32 %16, 12
  %cmp33 = icmp eq i32 %and32, 0
  %inc35 = zext i1 %cmp33 to i32
  %spec.select = add nsw i32 %reachable_masters.023, %inc35
  br label %if.end37

if.end37:                                         ; preds = %if.then28, %land.lhs.true26, %while.body
  %reachable_masters.1 = phi i32 [ %reachable_masters.023, %land.lhs.true26 ], [ %reachable_masters.023, %while.body ], [ %spec.select, %if.then28 ]
  %call21 = tail call ptr @dictNext(ptr noundef %call20) #33
  %cmp22.not = icmp eq ptr %call21, null
  br i1 %cmp22.not, label %while.end, label %while.body, !llvm.loop !58

while.end:                                        ; preds = %if.end37, %if.end19
  %reachable_masters.0.lcssa = phi i32 [ 0, %if.end19 ], [ %reachable_masters.1, %if.end37 ]
  tail call void @dictReleaseIterator(ptr noundef %call20) #33
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %size38 = getelementptr inbounds %struct.clusterState, ptr %17, i64 0, i32 3
  %18 = load i32, ptr %size38, align 4
  %div = sdiv i32 %18, 2
  %cmp39.not = icmp sgt i32 %reachable_masters.0.lcssa, %div
  br i1 %cmp39.not, label %if.end42, label %if.then40

if.then40:                                        ; preds = %while.end
  %call41 = tail call i64 @mstime() #33
  store i64 %call41, ptr @clusterUpdateState.among_minority_time, align 8
  %.pre26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %while.end
  %19 = phi ptr [ %.pre26, %if.then40 ], [ %17, %while.end ]
  %new_state.1 = phi i32 [ 1, %if.then40 ], [ %new_state.0, %while.end ]
  %state43 = getelementptr inbounds %struct.clusterState, ptr %19, i64 0, i32 2
  %20 = load i32, ptr %state43, align 8
  %cmp44.not = icmp eq i32 %new_state.1, %20
  br i1 %cmp44.not, label %if.end72, label %if.then45

if.then45:                                        ; preds = %if.end42
  %21 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %spec.store.select = tail call i64 @llvm.smin.i64(i64 %21, i64 5000)
  %spec.store.select1 = tail call i64 @llvm.smax.i64(i64 %spec.store.select, i64 500)
  %cmp52 = icmp eq i32 %new_state.1, 0
  br i1 %cmp52, label %land.lhs.true53, label %do.body

land.lhs.true53:                                  ; preds = %if.then45
  %22 = load ptr, ptr @myself, align 8
  %flags.i18 = getelementptr inbounds %struct._clusterNode, ptr %22, i64 0, i32 3
  %23 = load i32, ptr %flags.i18, align 8
  %and.i19 = and i32 %23, 1
  %tobool55.not = icmp eq i32 %and.i19, 0
  br i1 %tobool55.not, label %do.body, label %land.lhs.true56

land.lhs.true56:                                  ; preds = %land.lhs.true53
  %call57 = tail call i64 @mstime() #33
  %24 = load i64, ptr @clusterUpdateState.among_minority_time, align 8
  %sub58 = sub nsw i64 %call57, %24
  %cmp59 = icmp slt i64 %sub58, %spec.store.select1
  br i1 %cmp59, label %if.end72, label %do.body

do.body:                                          ; preds = %if.then45, %land.lhs.true53, %land.lhs.true56
  %cond = phi i32 [ 3, %if.then45 ], [ 2, %land.lhs.true53 ], [ 2, %land.lhs.true56 ]
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp64 = icmp slt i32 %cond, %25
  br i1 %cmp64, label %do.end, label %if.end66

if.end66:                                         ; preds = %do.body
  %cond70 = select i1 %cmp52, ptr @.str.140, ptr @.str.22
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef %cond, ptr noundef nonnull @.str.139, ptr noundef nonnull %cond70) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end66
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %state71 = getelementptr inbounds %struct.clusterState, ptr %26, i64 0, i32 2
  store i32 %new_state.1, ptr %state71, align 8
  br label %if.end72

if.end72:                                         ; preds = %land.lhs.true56, %land.lhs.true3, %do.end, %if.end42
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterHandleSlaveFailover() local_unnamed_addr #2 {
entry:
  %call = tail call i64 @mstime() #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_time = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 11
  %1 = load i64, ptr %failover_auth_time, align 8
  %sub = sub nsw i64 %call, %1
  %size = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 3
  %2 = load i32, ptr %size, align 4
  %div = sdiv i32 %2, 2
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 17
  %3 = load i64, ptr %mf_end, align 8
  %cmp.not = icmp eq i64 %3, 0
  br i1 %cmp.not, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %mf_can_start = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 20
  %4 = load i32, ptr %mf_can_start, align 8
  %tobool = icmp ne i32 %4, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 22
  %6 = load i32, ptr %todo_before_sleep, align 8
  %and = and i32 %6, -2
  store i32 %and, ptr %todo_before_sleep, align 8
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %mul = shl nsw i64 %7, 1
  %spec.store.select = tail call i64 @llvm.smax.i64(i64 %mul, i64 2000)
  %mul2 = shl nuw nsw i64 %spec.store.select, 1
  %8 = load ptr, ptr @myself, align 8
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %8, i64 0, i32 3
  %9 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %9, 1
  %tobool4.not = icmp eq i32 %and.i, 0
  br i1 %tobool4.not, label %lor.lhs.false, label %if.then18

lor.lhs.false:                                    ; preds = %land.end
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %8, i64 0, i32 11
  %10 = load ptr, ptr %slaveof, align 8
  %cmp5 = icmp eq ptr %10, null
  br i1 %cmp5, label %if.then18, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %flags = getelementptr inbounds %struct._clusterNode, ptr %10, i64 0, i32 3
  %11 = load i32, ptr %flags, align 8
  %and8 = and i32 %11, 8
  %tobool9 = icmp ne i32 %and8, 0
  %or.cond = select i1 %tobool9, i1 true, i1 %5
  br i1 %or.cond, label %lor.lhs.false11, label %if.then18

lor.lhs.false11:                                  ; preds = %lor.lhs.false6
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 372), align 8
  %tobool12 = icmp eq i32 %12, 0
  %or.cond1 = select i1 %tobool12, i1 true, i1 %5
  br i1 %or.cond1, label %lor.lhs.false15, label %if.then18

lor.lhs.false15:                                  ; preds = %lor.lhs.false11
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %10, i64 0, i32 8
  %13 = load i32, ptr %numslots, align 4
  %cmp17 = icmp eq i32 %13, 0
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %lor.lhs.false11, %lor.lhs.false6, %lor.lhs.false15, %lor.lhs.false, %land.end
  %cant_failover_reason = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 16
  store i32 0, ptr %cant_failover_reason, align 8
  br label %if.end153

if.end19:                                         ; preds = %lor.lhs.false15
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 289), align 4
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 349) seq_cst, align 8
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 370), align 8
  %tobool32.not = icmp eq i32 %15, 0
  br i1 %tobool32.not, label %if.end44, label %land.lhs.true33

land.lhs.true33:                                  ; preds = %if.end19
  %cmp20 = icmp eq i32 %14, 12
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 286), align 8
  %lastinteraction = getelementptr inbounds %struct.client, ptr %16, i64 0, i32 32
  %.sink20 = select i1 %cmp20, ptr %lastinteraction, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 300)
  %17 = load i64, ptr %.sink20, align 8
  %sub25 = sub nsw i64 %atomic-load, %17
  %data_age.0 = mul nsw i64 %sub25, 1000
  %18 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %cmp28 = icmp sgt i64 %data_age.0, %18
  %sub30 = select i1 %cmp28, i64 %18, i64 0
  %spec.select = sub nsw i64 %data_age.0, %sub30
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 267), align 4
  %conv = sext i32 %19 to i64
  %mul34 = mul nsw i64 %conv, 1000
  %conv35 = sext i32 %15 to i64
  %mul36 = mul nsw i64 %18, %conv35
  %add37 = add nsw i64 %mul34, %mul36
  %cmp38 = icmp sle i64 %spec.select, %add37
  %or.cond2 = select i1 %cmp38, i1 true, i1 %5
  br i1 %or.cond2, label %if.end44, label %if.then42

if.then42:                                        ; preds = %land.lhs.true33
  tail call void @clusterLogCantFailover(i32 noundef 1)
  br label %if.end153

if.end44:                                         ; preds = %land.lhs.true33, %if.end19
  %cmp45 = icmp sgt i64 %sub, %mul2
  br i1 %cmp45, label %if.then47, label %if.end75

if.then47:                                        ; preds = %if.end44
  %call48 = tail call i64 @mstime() #33
  %add49 = add nsw i64 %call48, 500
  %call50 = tail call i64 @random() #33
  %rem = srem i64 %call50, 500
  %add51 = add nsw i64 %add49, %rem
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_time52 = getelementptr inbounds %struct.clusterState, ptr %20, i64 0, i32 11
  store i64 %add51, ptr %failover_auth_time52, align 8
  %failover_auth_count = getelementptr inbounds %struct.clusterState, ptr %20, i64 0, i32 12
  store i32 0, ptr %failover_auth_count, align 8
  %failover_auth_sent = getelementptr inbounds %struct.clusterState, ptr %20, i64 0, i32 13
  store i32 0, ptr %failover_auth_sent, align 4
  %call53 = tail call i32 @clusterGetSlaveRank()
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_rank = getelementptr inbounds %struct.clusterState, ptr %21, i64 0, i32 14
  store i32 %call53, ptr %failover_auth_rank, align 8
  %mul55 = mul nsw i32 %call53, 1000
  %conv56 = sext i32 %mul55 to i64
  %failover_auth_time57 = getelementptr inbounds %struct.clusterState, ptr %21, i64 0, i32 11
  %22 = load i64, ptr %failover_auth_time57, align 8
  %add58 = add nsw i64 %22, %conv56
  store i64 %add58, ptr %failover_auth_time57, align 8
  %mf_end59 = getelementptr inbounds %struct.clusterState, ptr %21, i64 0, i32 17
  %23 = load i64, ptr %mf_end59, align 8
  %tobool60.not = icmp eq i64 %23, 0
  br i1 %tobool60.not, label %do.body, label %if.then61

if.then61:                                        ; preds = %if.then47
  %call62 = tail call i64 @mstime() #33
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_time63 = getelementptr inbounds %struct.clusterState, ptr %24, i64 0, i32 11
  store i64 %call62, ptr %failover_auth_time63, align 8
  %failover_auth_rank64 = getelementptr inbounds %struct.clusterState, ptr %24, i64 0, i32 14
  store i32 0, ptr %failover_auth_rank64, align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %24, i64 0, i32 22
  %25 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %25, 1
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  br label %do.body

do.body:                                          ; preds = %if.then47, %if.then61
  %26 = phi i64 [ %add58, %if.then47 ], [ %call62, %if.then61 ]
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp66 = icmp sgt i32 %27, 2
  br i1 %cmp66, label %do.end, label %if.end69

if.end69:                                         ; preds = %do.body
  %call71 = tail call i64 @mstime() #33
  %sub72 = sub nsw i64 %26, %call71
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_rank73 = getelementptr inbounds %struct.clusterState, ptr %28, i64 0, i32 14
  %29 = load i32, ptr %failover_auth_rank73, align 8
  %call74 = tail call i64 @replicationGetSlaveOffset() #33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.128, i64 noundef %sub72, i32 noundef %29, i64 noundef %call74) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end69
  tail call void @clusterBroadcastPong(i32 noundef 1)
  br label %if.end153

if.end75:                                         ; preds = %if.end44
  %30 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_sent76 = getelementptr inbounds %struct.clusterState, ptr %30, i64 0, i32 13
  %31 = load i32, ptr %failover_auth_sent76, align 4
  %cmp77 = icmp eq i32 %31, 0
  br i1 %cmp77, label %land.lhs.true79, label %if.end103

land.lhs.true79:                                  ; preds = %if.end75
  %mf_end80 = getelementptr inbounds %struct.clusterState, ptr %30, i64 0, i32 17
  %32 = load i64, ptr %mf_end80, align 8
  %cmp81 = icmp eq i64 %32, 0
  br i1 %cmp81, label %if.then83, label %if.end103

if.then83:                                        ; preds = %land.lhs.true79
  %call84 = tail call i32 @clusterGetSlaveRank()
  %33 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_rank85 = getelementptr inbounds %struct.clusterState, ptr %33, i64 0, i32 14
  %34 = load i32, ptr %failover_auth_rank85, align 8
  %cmp86 = icmp sgt i32 %call84, %34
  br i1 %cmp86, label %if.then88, label %if.end103

if.then88:                                        ; preds = %if.then83
  %sub90 = sub nsw i32 %call84, %34
  %mul91 = mul nsw i32 %sub90, 1000
  %conv92 = sext i32 %mul91 to i64
  %failover_auth_time93 = getelementptr inbounds %struct.clusterState, ptr %33, i64 0, i32 11
  %35 = load i64, ptr %failover_auth_time93, align 8
  %add94 = add nsw i64 %35, %conv92
  store i64 %add94, ptr %failover_auth_time93, align 8
  store i32 %call84, ptr %failover_auth_rank85, align 8
  %36 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp97 = icmp sgt i32 %36, 2
  br i1 %cmp97, label %if.end103, label %if.end100

if.end100:                                        ; preds = %if.then88
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.129, i32 noundef %call84, i64 noundef %conv92) #33
  br label %if.end103

if.end103:                                        ; preds = %if.then83, %if.then88, %if.end100, %land.lhs.true79, %if.end75
  %call104 = tail call i64 @mstime() #33
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_time105 = getelementptr inbounds %struct.clusterState, ptr %37, i64 0, i32 11
  %38 = load i64, ptr %failover_auth_time105, align 8
  %cmp106 = icmp slt i64 %call104, %38
  br i1 %cmp106, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end103
  tail call void @clusterLogCantFailover(i32 noundef 2)
  br label %if.end153

if.end109:                                        ; preds = %if.end103
  %cmp110 = icmp sgt i64 %sub, %spec.store.select
  br i1 %cmp110, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.end109
  tail call void @clusterLogCantFailover(i32 noundef 3)
  br label %if.end153

if.end113:                                        ; preds = %if.end109
  %failover_auth_sent114 = getelementptr inbounds %struct.clusterState, ptr %37, i64 0, i32 13
  %39 = load i32, ptr %failover_auth_sent114, align 4
  %cmp115 = icmp eq i32 %39, 0
  br i1 %cmp115, label %if.then117, label %if.end127

if.then117:                                       ; preds = %if.end113
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %37, i64 0, i32 1
  %40 = load i64, ptr %currentEpoch, align 8
  %inc = add i64 %40, 1
  store i64 %inc, ptr %currentEpoch, align 8
  %41 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch118 = getelementptr inbounds %struct.clusterState, ptr %41, i64 0, i32 1
  %42 = load i64, ptr %currentEpoch118, align 8
  %failover_auth_epoch = getelementptr inbounds %struct.clusterState, ptr %41, i64 0, i32 15
  store i64 %42, ptr %failover_auth_epoch, align 8
  %43 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp120 = icmp sgt i32 %43, 2
  br i1 %cmp120, label %do.end125, label %if.end123

if.end123:                                        ; preds = %if.then117
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.130, i64 noundef %42) #33
  br label %do.end125

do.end125:                                        ; preds = %if.then117, %if.end123
  tail call void @clusterRequestFailoverAuth()
  %44 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %failover_auth_sent126 = getelementptr inbounds %struct.clusterState, ptr %44, i64 0, i32 13
  store i32 1, ptr %failover_auth_sent126, align 4
  %todo_before_sleep.i18 = getelementptr inbounds %struct.clusterState, ptr %44, i64 0, i32 22
  %45 = load i32, ptr %todo_before_sleep.i18, align 8
  %or.i19 = or i32 %45, 14
  store i32 %or.i19, ptr %todo_before_sleep.i18, align 8
  br label %if.end153

if.end127:                                        ; preds = %if.end113
  %failover_auth_count128 = getelementptr inbounds %struct.clusterState, ptr %37, i64 0, i32 12
  %46 = load i32, ptr %failover_auth_count128, align 8
  %cmp129.not.not = icmp sgt i32 %46, %div
  br i1 %cmp129.not.not, label %do.body132, label %if.else152

do.body132:                                       ; preds = %if.end127
  %47 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp133 = icmp sgt i32 %47, 2
  br i1 %cmp133, label %do.end137, label %if.end136

if.end136:                                        ; preds = %do.body132
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.131) #33
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %do.end137

do.end137:                                        ; preds = %do.body132, %if.end136
  %48 = phi ptr [ %37, %do.body132 ], [ %.pre, %if.end136 ]
  %49 = load ptr, ptr @myself, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %49, i64 0, i32 4
  %50 = load i64, ptr %configEpoch, align 8
  %failover_auth_epoch138 = getelementptr inbounds %struct.clusterState, ptr %48, i64 0, i32 15
  %51 = load i64, ptr %failover_auth_epoch138, align 8
  %cmp139 = icmp ult i64 %50, %51
  br i1 %cmp139, label %if.then141, label %if.end151

if.then141:                                       ; preds = %do.end137
  store i64 %51, ptr %configEpoch, align 8
  %52 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp145 = icmp sgt i32 %52, 2
  br i1 %cmp145, label %if.end151, label %if.end148

if.end148:                                        ; preds = %if.then141
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.132, i64 noundef %51) #33
  br label %if.end151

if.end151:                                        ; preds = %if.end148, %if.then141, %do.end137
  tail call void @clusterFailoverReplaceYourMaster()
  br label %if.end153

if.else152:                                       ; preds = %if.end127
  tail call void @clusterLogCantFailover(i32 noundef 4)
  br label %if.end153

if.end153:                                        ; preds = %if.else152, %if.end151, %do.end125, %if.then112, %if.then108, %do.end, %if.then42, %if.then18
  ret void
}

; Function Attrs: nounwind
declare i64 @random() local_unnamed_addr #12

; Function Attrs: nounwind uwtable
define dso_local void @clusterHandleSlaveMigration(i32 noundef %max_slaves) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i64 0, i32 11
  %1 = load ptr, ptr %slaveof, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 2
  %3 = load i32, ptr %state, align 8
  %cmp = icmp ne i32 %3, 0
  %cmp1 = icmp eq ptr %1, null
  %or.cond = select i1 %cmp, i1 true, i1 %cmp1
  br i1 %or.cond, label %if.end94, label %for.cond.preheader

for.cond.preheader:                               ; preds = %entry
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 9
  %4 = load i32, ptr %numslaves, align 8
  %cmp447 = icmp sgt i32 %4, 0
  br i1 %cmp447, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 10
  %5 = load ptr, ptr %slaves, align 8
  %wide.trip.count = zext nneg i32 %4 to i64
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %indvars.iv = phi i64 [ 0, %for.body.lr.ph ], [ %indvars.iv.next, %for.body ]
  %okslaves.048 = phi i32 [ 0, %for.body.lr.ph ], [ %okslaves.1, %for.body ]
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %indvars.iv
  %6 = load ptr, ptr %arrayidx, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %6, i64 0, i32 3
  %7 = load i32, ptr %flags, align 8
  %8 = and i32 %7, 12
  %or.cond31 = icmp eq i32 %8, 0
  %inc = zext i1 %or.cond31 to i32
  %okslaves.1 = add nuw nsw i32 %okslaves.048, %inc
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !59

for.end:                                          ; preds = %for.body, %for.cond.preheader
  %okslaves.0.lcssa = phi i32 [ 0, %for.cond.preheader ], [ %okslaves.1, %for.body ]
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 368), align 8
  %cmp14.not = icmp sgt i32 %okslaves.0.lcssa, %9
  br i1 %cmp14.not, label %if.end16, label %if.end94

if.end16:                                         ; preds = %for.end
  %nodes = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 4
  %10 = load ptr, ptr %nodes, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %10) #33
  %call1754 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp18.not55 = icmp eq ptr %call1754, null
  br i1 %cmp18.not55, label %while.end, label %while.body

while.body:                                       ; preds = %if.end16, %if.end77
  %call1758 = phi ptr [ %call17, %if.end77 ], [ %call1754, %if.end16 ]
  %target.057 = phi ptr [ %target.2, %if.end77 ], [ null, %if.end16 ]
  %candidate.056 = phi ptr [ %candidate.3, %if.end77 ], [ %0, %if.end16 ]
  %call19 = tail call ptr @dictGetVal(ptr noundef nonnull %call1758) #33
  %flags21 = getelementptr inbounds %struct._clusterNode, ptr %call19, i64 0, i32 3
  %11 = load i32, ptr %flags21, align 8
  %12 = and i32 %11, 266
  %narrow.not = icmp eq i32 %12, 256
  %and.i = and i32 %11, 1
  %tobool35.not = icmp eq i32 %and.i, 0
  br i1 %tobool35.not, label %if.end38.thread, label %if.then36

if.then36:                                        ; preds = %while.body
  %numslaves.i = getelementptr inbounds %struct._clusterNode, ptr %call19, i64 0, i32 9
  %13 = load i32, ptr %numslaves.i, align 8
  %cmp5.i = icmp sgt i32 %13, 0
  br i1 %cmp5.i, label %for.body.lr.ph.i, label %if.end38.thread

for.body.lr.ph.i:                                 ; preds = %if.then36
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %call19, i64 0, i32 10
  %14 = load ptr, ptr %slaves.i, align 8
  %wide.trip.count.i = zext nneg i32 %13 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %okslaves.07.i = phi i32 [ 0, %for.body.lr.ph.i ], [ %spec.select.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds ptr, ptr %14, i64 %indvars.iv.i
  %15 = load ptr, ptr %arrayidx.i, align 8
  %flags.i36 = getelementptr inbounds %struct._clusterNode, ptr %15, i64 0, i32 3
  %16 = load i32, ptr %flags.i36, align 8
  %.fr = freeze i32 %16
  %and.i37 = lshr i32 %.fr, 3
  %17 = and i32 %and.i37, 1
  %18 = xor i32 %17, 1
  %spec.select.i = add i32 %18, %okslaves.07.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %if.end38, label %for.body.i, !llvm.loop !32

if.end38:                                         ; preds = %for.body.i
  %cmp39 = icmp sgt i32 %spec.select.i, 0
  br i1 %cmp39, label %if.else, label %if.end38.thread

if.end38.thread:                                  ; preds = %if.then36, %while.body, %if.end38
  %okslaves20.041 = phi i32 [ %spec.select.i, %if.end38 ], [ 0, %while.body ], [ 0, %if.then36 ]
  br i1 %narrow.not, label %if.then43, label %if.else

if.then43:                                        ; preds = %if.end38.thread
  %tobool44.not = icmp eq ptr %target.057, null
  br i1 %tobool44.not, label %land.lhs.true45, label %if.end48

land.lhs.true45:                                  ; preds = %if.then43
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %call19, i64 0, i32 8
  %19 = load i32, ptr %numslots, align 4
  %cmp46 = icmp sgt i32 %19, 0
  %spec.select33 = select i1 %cmp46, ptr %call19, ptr null
  br label %if.end48

if.end48:                                         ; preds = %land.lhs.true45, %if.then43
  %target.1 = phi ptr [ %target.057, %if.then43 ], [ %spec.select33, %land.lhs.true45 ]
  %orphaned_time = getelementptr inbounds %struct._clusterNode, ptr %call19, i64 0, i32 19
  %20 = load i64, ptr %orphaned_time, align 8
  %tobool49.not = icmp eq i64 %20, 0
  br i1 %tobool49.not, label %if.then50, label %if.end55

if.then50:                                        ; preds = %if.end48
  %call51 = tail call i64 @mstime() #33
  store i64 %call51, ptr %orphaned_time, align 8
  br label %if.end55

if.else:                                          ; preds = %if.end38, %if.end38.thread
  %okslaves20.04145 = phi i32 [ %okslaves20.041, %if.end38.thread ], [ %spec.select.i, %if.end38 ]
  %orphaned_time54 = getelementptr inbounds %struct._clusterNode, ptr %call19, i64 0, i32 19
  store i64 0, ptr %orphaned_time54, align 8
  br label %if.end55

if.end55:                                         ; preds = %if.end48, %if.then50, %if.else
  %okslaves20.04144 = phi i32 [ %okslaves20.041, %if.end48 ], [ %okslaves20.041, %if.then50 ], [ %okslaves20.04145, %if.else ]
  %target.2 = phi ptr [ %target.1, %if.end48 ], [ %target.1, %if.then50 ], [ %target.057, %if.else ]
  %cmp56 = icmp eq i32 %okslaves20.04144, %max_slaves
  br i1 %cmp56, label %for.cond58.preheader, label %if.end77

for.cond58.preheader:                             ; preds = %if.end55
  %numslaves59 = getelementptr inbounds %struct._clusterNode, ptr %call19, i64 0, i32 9
  %21 = load i32, ptr %numslaves59, align 8
  %cmp6050 = icmp sgt i32 %21, 0
  br i1 %cmp6050, label %for.body61.lr.ph, label %if.end77

for.body61.lr.ph:                                 ; preds = %for.cond58.preheader
  %slaves62 = getelementptr inbounds %struct._clusterNode, ptr %call19, i64 0, i32 10
  %22 = load ptr, ptr %slaves62, align 8
  %wide.trip.count65 = zext nneg i32 %21 to i64
  br label %for.body61

for.body61:                                       ; preds = %for.body61.lr.ph, %for.body61
  %indvars.iv62 = phi i64 [ 0, %for.body61.lr.ph ], [ %indvars.iv.next63, %for.body61 ]
  %candidate.151 = phi ptr [ %candidate.056, %for.body61.lr.ph ], [ %spec.select34, %for.body61 ]
  %arrayidx64 = getelementptr inbounds ptr, ptr %22, i64 %indvars.iv62
  %23 = load ptr, ptr %arrayidx64, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %23, i64 0, i32 1
  %name65 = getelementptr inbounds %struct._clusterNode, ptr %candidate.151, i64 0, i32 1
  %call67 = tail call i32 @memcmp(ptr noundef nonnull dereferenceable(40) %name, ptr noundef nonnull dereferenceable(40) %name65, i64 noundef 40) #34
  %cmp68 = icmp slt i32 %call67, 0
  %spec.select34 = select i1 %cmp68, ptr %23, ptr %candidate.151
  %indvars.iv.next63 = add nuw nsw i64 %indvars.iv62, 1
  %exitcond66.not = icmp eq i64 %indvars.iv.next63, %wide.trip.count65
  br i1 %exitcond66.not, label %if.end77, label %for.body61, !llvm.loop !60

if.end77:                                         ; preds = %for.body61, %for.cond58.preheader, %if.end55
  %candidate.3 = phi ptr [ %candidate.056, %if.end55 ], [ %candidate.056, %for.cond58.preheader ], [ %spec.select34, %for.body61 ]
  %call17 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp18.not = icmp eq ptr %call17, null
  br i1 %cmp18.not, label %while.end, label %while.body, !llvm.loop !61

while.end:                                        ; preds = %if.end77, %if.end16
  %candidate.0.lcssa = phi ptr [ %0, %if.end16 ], [ %candidate.3, %if.end77 ]
  %target.0.lcssa = phi ptr [ null, %if.end16 ], [ %target.2, %if.end77 ]
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  %tobool78.not = icmp ne ptr %target.0.lcssa, null
  %24 = load ptr, ptr @myself, align 8
  %cmp80 = icmp eq ptr %candidate.0.lcssa, %24
  %or.cond35 = select i1 %tobool78.not, i1 %cmp80, i1 false
  br i1 %or.cond35, label %land.lhs.true81, label %if.end94

land.lhs.true81:                                  ; preds = %while.end
  %call82 = tail call i64 @mstime() #33
  %orphaned_time83 = getelementptr inbounds %struct._clusterNode, ptr %target.0.lcssa, i64 0, i32 19
  %25 = load i64, ptr %orphaned_time83, align 8
  %sub = sub nsw i64 %call82, %25
  %cmp84 = icmp sgt i64 %sub, 5000
  br i1 %cmp84, label %land.lhs.true85, label %if.end94

land.lhs.true85:                                  ; preds = %land.lhs.true81
  %26 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  %and86 = and i32 %26, 2
  %tobool87.not = icmp eq i32 %and86, 0
  br i1 %tobool87.not, label %do.body, label %if.end94

do.body:                                          ; preds = %land.lhs.true85
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp89 = icmp sgt i32 %27, 2
  br i1 %cmp89, label %do.end, label %if.end91

if.end91:                                         ; preds = %do.body
  %name92 = getelementptr inbounds %struct._clusterNode, ptr %target.0.lcssa, i64 0, i32 1
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.133, ptr noundef nonnull %name92) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end91
  tail call void @clusterSetMaster(ptr noundef nonnull %target.0.lcssa)
  br label %if.end94

if.end94:                                         ; preds = %for.end, %entry, %do.end, %land.lhs.true85, %land.lhs.true81, %while.end
  ret void
}

declare void @unpauseActions(i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @manualFailoverCheckTimeout() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 17
  %1 = load i64, ptr %mf_end, align 8
  %tobool.not = icmp eq i64 %1, 0
  br i1 %tobool.not, label %if.end4, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call = tail call i64 @mstime() #33
  %cmp = icmp slt i64 %1, %call
  br i1 %cmp, label %do.body, label %if.end4

do.body:                                          ; preds = %land.lhs.true
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2 = icmp sgt i32 %2, 3
  br i1 %cmp2, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.134) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_slave.i = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 18
  %4 = load ptr, ptr %mf_slave.i, align 8
  %tobool.not.i = icmp eq ptr %4, null
  br i1 %tobool.not.i, label %resetManualFailover.exit, label %if.then.i

if.then.i:                                        ; preds = %do.end
  tail call void @unpauseActions(i32 noundef 2) #33
  %.pre.i = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %resetManualFailover.exit

resetManualFailover.exit:                         ; preds = %do.end, %if.then.i
  %5 = phi ptr [ %.pre.i, %if.then.i ], [ %3, %do.end ]
  %mf_end.i = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 17
  %mf_can_start.i = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 20
  store i32 0, ptr %mf_can_start.i, align 8
  %mf_master_offset.i = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mf_end.i, i8 0, i64 16, i1 false)
  store i64 -1, ptr %mf_master_offset.i, align 8
  br label %if.end4

if.end4:                                          ; preds = %resetManualFailover.exit, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterHandleManualFailover() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 17
  %1 = load i64, ptr %mf_end, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %mf_can_start = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 20
  %2 = load i32, ptr %mf_can_start, align 8
  %tobool.not = icmp eq i32 %2, 0
  br i1 %tobool.not, label %if.end2, label %return

if.end2:                                          ; preds = %if.end
  %mf_master_offset = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 19
  %3 = load i64, ptr %mf_master_offset, align 8
  %cmp3 = icmp eq i64 %3, -1
  br i1 %cmp3, label %return, label %if.end5

if.end5:                                          ; preds = %if.end2
  %call = tail call i64 @replicationGetSlaveOffset() #33
  %cmp7 = icmp eq i64 %3, %call
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br i1 %cmp7, label %if.then8, label %return.sink.split

if.then8:                                         ; preds = %if.end5
  %mf_can_start9 = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 20
  store i32 1, ptr %mf_can_start9, align 8
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp10 = icmp sgt i32 %5, 2
  br i1 %cmp10, label %return.sink.split, label %if.end12

if.end12:                                         ; preds = %if.then8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.135) #33
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %return.sink.split

return.sink.split:                                ; preds = %if.end5, %if.end12, %if.then8
  %.sink = phi ptr [ %4, %if.then8 ], [ %.pre, %if.end12 ], [ %4, %if.end5 ]
  %.sink3 = phi i32 [ 1, %if.then8 ], [ 1, %if.end12 ], [ 16, %if.end5 ]
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %.sink, i64 0, i32 22
  %6 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i2 = or i32 %6, %.sink3
  store i32 %or.i2, ptr %todo_before_sleep.i, align 8
  br label %return

return:                                           ; preds = %return.sink.split, %if.end2, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterCron() local_unnamed_addr #2 {
entry:
  %call = tail call i64 @mstime() #33
  %0 = load i64, ptr @clusterCron.iteration, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr @clusterCron.iteration, align 8
  %1 = load ptr, ptr @myself, align 8
  %tobool.not.i = icmp eq ptr %1, null
  br i1 %tobool.not.i, label %clusterUpdateMyselfHostname.exit, label %if.end.i

if.end.i:                                         ; preds = %entry
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 374), align 8
  tail call fastcc void @updateAnnouncedHostname(ptr noundef nonnull %1, ptr noundef %2)
  br label %clusterUpdateMyselfHostname.exit

clusterUpdateMyselfHostname.exit:                 ; preds = %entry, %if.end.i
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %spec.store.select = tail call i64 @llvm.smax.i64(i64 %3, i64 1000)
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %stats_pfail_nodes = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 25
  store i64 0, ptr %stats_pfail_nodes, align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 4
  %5 = load ptr, ptr %nodes, align 8
  %call1 = tail call ptr @dictGetSafeIterator(ptr noundef %5) #33
  %call2103 = tail call ptr @dictNext(ptr noundef %call1) #33
  %cmp3.not104 = icmp eq ptr %call2103, null
  br i1 %cmp3.not104, label %while.end, label %while.body

while.body:                                       ; preds = %clusterUpdateMyselfHostname.exit, %clusterNodeCronHandleReconnect.exit
  %call2105 = phi ptr [ %call2, %clusterNodeCronHandleReconnect.exit ], [ %call2103, %clusterUpdateMyselfHostname.exit ]
  %call4 = tail call ptr @dictGetVal(ptr noundef nonnull %call2105) #33
  %link.i = getelementptr inbounds %struct._clusterNode, ptr %call4, i64 0, i32 27
  %6 = load ptr, ptr %link.i, align 8
  %cmp.i.i = icmp eq ptr %6, null
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 383), align 8
  %cmp1.i.i = icmp eq i64 %7, 0
  %or.cond.i.i = select i1 %cmp.i.i, i1 true, i1 %cmp1.i.i
  br i1 %or.cond.i.i, label %freeClusterLinkOnBufferLimitReached.exit.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %while.body
  %send_msg_queue_mem.i.i = getelementptr inbounds %struct.clusterLink, ptr %6, i64 0, i32 4
  %8 = load i64, ptr %send_msg_queue_mem.i.i, align 8
  %cmp2.i.i = icmp ugt i64 %8, %7
  br i1 %cmp2.i.i, label %do.body.i.i, label %freeClusterLinkOnBufferLimitReached.exit.i

do.body.i.i:                                      ; preds = %if.end.i.i
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp4.i.i = icmp sgt i32 %9, 3
  br i1 %cmp4.i.i, label %do.end.i.i, label %if.end6.i.i

if.end6.i.i:                                      ; preds = %do.body.i.i
  %inbound.i.i = getelementptr inbounds %struct.clusterLink, ptr %6, i64 0, i32 9
  %10 = load i32, ptr %inbound.i.i, align 8
  %tobool.not.i.i = icmp eq i32 %10, 0
  %cond.i.i = select i1 %tobool.not.i.i, ptr @.str.162, ptr @.str.161
  %node.i.i = getelementptr inbounds %struct.clusterLink, ptr %6, i64 0, i32 8
  %11 = load ptr, ptr %node.i.i, align 8
  %tobool7.not.i.i = icmp eq ptr %11, null
  %name.i.i = getelementptr inbounds %struct._clusterNode, ptr %11, i64 0, i32 1
  %spec.select.i.i = select i1 %tobool7.not.i.i, ptr @.str.304, ptr %name.i.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.307, ptr noundef nonnull %cond.i.i, ptr noundef nonnull %spec.select.i.i, i64 noundef %8) #33
  br label %do.end.i.i

do.end.i.i:                                       ; preds = %if.end6.i.i, %do.body.i.i
  tail call void @freeClusterLink(ptr noundef nonnull %6)
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %stat_cluster_links_buffer_limit_exceeded.i.i = getelementptr inbounds %struct.clusterState, ptr %12, i64 0, i32 26
  %13 = load i64, ptr %stat_cluster_links_buffer_limit_exceeded.i.i, align 8
  %inc.i.i = add i64 %13, 1
  store i64 %inc.i.i, ptr %stat_cluster_links_buffer_limit_exceeded.i.i, align 8
  %.pre.i = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 383), align 8
  br label %freeClusterLinkOnBufferLimitReached.exit.i

freeClusterLinkOnBufferLimitReached.exit.i:       ; preds = %do.end.i.i, %if.end.i.i, %while.body
  %14 = phi i64 [ %7, %while.body ], [ %7, %if.end.i.i ], [ %.pre.i, %do.end.i.i ]
  %inbound_link.i = getelementptr inbounds %struct._clusterNode, ptr %call4, i64 0, i32 28
  %15 = load ptr, ptr %inbound_link.i, align 8
  %cmp.i2.i = icmp eq ptr %15, null
  %cmp1.i3.i = icmp eq i64 %14, 0
  %or.cond.i4.i = select i1 %cmp.i2.i, i1 true, i1 %cmp1.i3.i
  br i1 %or.cond.i4.i, label %clusterNodeCronFreeLinkOnBufferLimitReached.exit, label %if.end.i5.i

if.end.i5.i:                                      ; preds = %freeClusterLinkOnBufferLimitReached.exit.i
  %send_msg_queue_mem.i6.i = getelementptr inbounds %struct.clusterLink, ptr %15, i64 0, i32 4
  %16 = load i64, ptr %send_msg_queue_mem.i6.i, align 8
  %cmp2.i7.i = icmp ugt i64 %16, %14
  br i1 %cmp2.i7.i, label %do.body.i8.i, label %clusterNodeCronFreeLinkOnBufferLimitReached.exit

do.body.i8.i:                                     ; preds = %if.end.i5.i
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp4.i9.i = icmp sgt i32 %17, 3
  br i1 %cmp4.i9.i, label %do.end.i18.i, label %if.end6.i10.i

if.end6.i10.i:                                    ; preds = %do.body.i8.i
  %inbound.i11.i = getelementptr inbounds %struct.clusterLink, ptr %15, i64 0, i32 9
  %18 = load i32, ptr %inbound.i11.i, align 8
  %tobool.not.i12.i = icmp eq i32 %18, 0
  %cond.i13.i = select i1 %tobool.not.i12.i, ptr @.str.162, ptr @.str.161
  %node.i14.i = getelementptr inbounds %struct.clusterLink, ptr %15, i64 0, i32 8
  %19 = load ptr, ptr %node.i14.i, align 8
  %tobool7.not.i15.i = icmp eq ptr %19, null
  %name.i16.i = getelementptr inbounds %struct._clusterNode, ptr %19, i64 0, i32 1
  %spec.select.i17.i = select i1 %tobool7.not.i15.i, ptr @.str.304, ptr %name.i16.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.307, ptr noundef nonnull %cond.i13.i, ptr noundef nonnull %spec.select.i17.i, i64 noundef %16) #33
  br label %do.end.i18.i

do.end.i18.i:                                     ; preds = %if.end6.i10.i, %do.body.i8.i
  tail call void @freeClusterLink(ptr noundef nonnull %15)
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %stat_cluster_links_buffer_limit_exceeded.i19.i = getelementptr inbounds %struct.clusterState, ptr %20, i64 0, i32 26
  %21 = load i64, ptr %stat_cluster_links_buffer_limit_exceeded.i19.i, align 8
  %inc.i20.i = add i64 %21, 1
  store i64 %inc.i20.i, ptr %stat_cluster_links_buffer_limit_exceeded.i19.i, align 8
  br label %clusterNodeCronFreeLinkOnBufferLimitReached.exit

clusterNodeCronFreeLinkOnBufferLimitReached.exit: ; preds = %freeClusterLinkOnBufferLimitReached.exit.i, %if.end.i5.i, %do.end.i18.i
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %call4, i64 0, i32 3
  %22 = load i32, ptr %flags.i, align 8
  %and.i = and i32 %22, 80
  %tobool.not.i66 = icmp eq i32 %and.i, 0
  br i1 %tobool.not.i66, label %if.end.i67, label %clusterNodeCronHandleReconnect.exit

if.end.i67:                                       ; preds = %clusterNodeCronFreeLinkOnBufferLimitReached.exit
  %and2.i = and i32 %22, 4
  %tobool3.not.i = icmp eq i32 %and2.i, 0
  br i1 %tobool3.not.i, label %if.end5.i, label %if.then4.i

if.then4.i:                                       ; preds = %if.end.i67
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %stats_pfail_nodes.i = getelementptr inbounds %struct.clusterState, ptr %23, i64 0, i32 25
  %24 = load i64, ptr %stats_pfail_nodes.i, align 8
  %inc.i = add nsw i64 %24, 1
  store i64 %inc.i, ptr %stats_pfail_nodes.i, align 8
  %.pre.i68 = load i32, ptr %flags.i, align 8
  br label %if.end5.i

if.end5.i:                                        ; preds = %if.then4.i, %if.end.i67
  %25 = phi i32 [ %.pre.i68, %if.then4.i ], [ %22, %if.end.i67 ]
  %and7.i = and i32 %25, 32
  %tobool8.not.i = icmp eq i32 %and7.i, 0
  br i1 %tobool8.not.i, label %if.end10.i, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %if.end5.i
  %26 = load i64, ptr %call4, align 8
  %sub.i = sub nsw i64 %call, %26
  %cmp.i = icmp sgt i64 %sub.i, %spec.store.select
  br i1 %cmp.i, label %if.then9.i, label %if.end10.i

if.then9.i:                                       ; preds = %land.lhs.true.i
  tail call void @clusterDelNode(ptr noundef nonnull %call4)
  br label %clusterNodeCronHandleReconnect.exit

if.end10.i:                                       ; preds = %land.lhs.true.i, %if.end5.i
  %27 = load ptr, ptr %link.i, align 8
  %cmp11.i = icmp eq ptr %27, null
  br i1 %cmp11.i, label %createClusterLink.exit.i, label %clusterNodeCronHandleReconnect.exit

createClusterLink.exit.i:                         ; preds = %if.end10.i
  %call.i.i = tail call noalias dereferenceable_or_null(80) ptr @zmalloc(i64 noundef 80) #37
  %call1.i.i = tail call i64 @mstime() #33
  store i64 %call1.i.i, ptr %call.i.i, align 8
  %call2.i.i = tail call ptr @listCreate() #33
  %send_msg_queue.i.i = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 2
  store ptr %call2.i.i, ptr %send_msg_queue.i.i, align 8
  %free.i.i = getelementptr inbounds %struct.list, ptr %call2.i.i, i64 0, i32 3
  store ptr @clusterMsgSendBlockDecrRefCount, ptr %free.i.i, align 8
  %head_msg_send_offset.i.i = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 3
  store i64 0, ptr %head_msg_send_offset.i.i, align 8
  %send_msg_queue_mem.i.i70 = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 4
  store i64 48, ptr %send_msg_queue_mem.i.i70, align 8
  %rcvbuf_alloc.i.i = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 7
  store i64 1024, ptr %rcvbuf_alloc.i.i, align 8
  %call4.i.i = tail call noalias dereferenceable_or_null(1024) ptr @zmalloc(i64 noundef 1024) #37
  %rcvbuf.i.i = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 5
  store ptr %call4.i.i, ptr %rcvbuf.i.i, align 8
  %rcvbuf_len.i.i = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 6
  store i64 0, ptr %rcvbuf_len.i.i, align 8
  %28 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %add7.i.i = add i64 %28, 1072
  store i64 %add7.i.i, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 138), align 8
  %conn.i.i = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 1
  store ptr null, ptr %conn.i.i, align 8
  %node8.i.i = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 8
  store ptr %call4, ptr %node8.i.i, align 8
  %inbound.i.i71 = getelementptr inbounds %struct.clusterLink, ptr %call.i.i, i64 0, i32 9
  store i32 0, ptr %inbound.i.i71, align 8
  store ptr %call.i.i, ptr %link.i, align 8
  %call14.i = tail call ptr @connTypeOfCluster() #33
  %29 = getelementptr i8, ptr %call14.i, i64 72
  %call14.val.i = load ptr, ptr %29, align 8
  %call.i17.i = tail call ptr %call14.val.i() #33
  store ptr %call.i17.i, ptr %conn.i.i, align 8
  %private_data.i.i = getelementptr inbounds %struct.connection, ptr %call.i17.i, i64 0, i32 7
  store ptr %call.i.i, ptr %private_data.i.i, align 8
  %30 = load ptr, ptr %conn.i.i, align 8
  %ip.i = getelementptr inbounds %struct._clusterNode, ptr %call4, i64 0, i32 21
  %cport.i = getelementptr inbounds %struct._clusterNode, ptr %call4, i64 0, i32 26
  %31 = load i32, ptr %cport.i, align 8
  %32 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 49), align 8
  %33 = load ptr, ptr %30, align 8
  %connect.i.i = getelementptr inbounds %struct.ConnectionType, ptr %33, i64 0, i32 13
  %34 = load ptr, ptr %connect.i.i, align 8
  %call.i18.i = tail call i32 %34(ptr noundef nonnull %30, ptr noundef nonnull %ip.i, i32 noundef %31, ptr noundef %32, ptr noundef nonnull @clusterLinkConnectHandler) #33
  %cmp19.i = icmp eq i32 %call.i18.i, -1
  br i1 %cmp19.i, label %if.then20.i, label %clusterNodeCronHandleReconnect.exit

if.then20.i:                                      ; preds = %createClusterLink.exit.i
  %ping_sent.i = getelementptr inbounds %struct._clusterNode, ptr %call4, i64 0, i32 13
  %35 = load i64, ptr %ping_sent.i, align 8
  %cmp21.i = icmp eq i64 %35, 0
  br i1 %cmp21.i, label %if.then22.i, label %do.body.i

if.then22.i:                                      ; preds = %if.then20.i
  %call23.i = tail call i64 @mstime() #33
  store i64 %call23.i, ptr %ping_sent.i, align 8
  br label %do.body.i

do.body.i:                                        ; preds = %if.then22.i, %if.then20.i
  %36 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp26.i = icmp sgt i32 %36, 0
  br i1 %cmp26.i, label %do.end.i, label %if.end28.i

if.end28.i:                                       ; preds = %do.body.i
  %37 = load i32, ptr %cport.i, align 8
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.308, ptr noundef nonnull %ip.i, i32 noundef %37, ptr noundef nonnull getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 70)) #33
  br label %do.end.i

do.end.i:                                         ; preds = %if.end28.i, %do.body.i
  tail call void @freeClusterLink(ptr noundef nonnull %call.i.i)
  br label %clusterNodeCronHandleReconnect.exit

clusterNodeCronHandleReconnect.exit:              ; preds = %clusterNodeCronFreeLinkOnBufferLimitReached.exit, %if.then9.i, %if.end10.i, %createClusterLink.exit.i, %do.end.i
  %call2 = tail call ptr @dictNext(ptr noundef %call1) #33
  %cmp3.not = icmp eq ptr %call2, null
  br i1 %cmp3.not, label %while.end, label %while.body, !llvm.loop !62

while.end:                                        ; preds = %clusterNodeCronHandleReconnect.exit, %clusterUpdateMyselfHostname.exit
  tail call void @dictReleaseIterator(ptr noundef %call1) #33
  %38 = load i64, ptr @clusterCron.iteration, align 8
  %rem = urem i64 %38, 10
  %tobool8.not = icmp eq i64 %rem, 0
  br i1 %tobool8.not, label %for.body, label %if.end35

for.body:                                         ; preds = %while.end, %for.inc
  %min_pong.0108 = phi i64 [ %min_pong.1, %for.inc ], [ 0, %while.end ]
  %j.0107 = phi i32 [ %inc27, %for.inc ], [ 0, %while.end ]
  %min_pong_node.0106 = phi ptr [ %min_pong_node.1, %for.inc ], [ null, %while.end ]
  %39 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes11 = getelementptr inbounds %struct.clusterState, ptr %39, i64 0, i32 4
  %40 = load ptr, ptr %nodes11, align 8
  %call12 = tail call ptr @dictGetRandomKey(ptr noundef %40) #33
  %call13 = tail call ptr @dictGetVal(ptr noundef %call12) #33
  %link = getelementptr inbounds %struct._clusterNode, ptr %call13, i64 0, i32 27
  %41 = load ptr, ptr %link, align 8
  %cmp14 = icmp eq ptr %41, null
  br i1 %cmp14, label %for.inc, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %call13, i64 0, i32 13
  %42 = load i64, ptr %ping_sent, align 8
  %cmp15.not = icmp eq i64 %42, 0
  br i1 %cmp15.not, label %if.end17, label %for.inc

if.end17:                                         ; preds = %lor.lhs.false
  %flags = getelementptr inbounds %struct._clusterNode, ptr %call13, i64 0, i32 3
  %43 = load i32, ptr %flags, align 8
  %and = and i32 %43, 48
  %tobool18.not = icmp eq i32 %and, 0
  br i1 %tobool18.not, label %if.end20, label %for.inc

if.end20:                                         ; preds = %if.end17
  %cmp21 = icmp eq ptr %min_pong_node.0106, null
  %pong_received25.phi.trans.insert = getelementptr inbounds %struct._clusterNode, ptr %call13, i64 0, i32 14
  %.pre = load i64, ptr %pong_received25.phi.trans.insert, align 8
  br i1 %cmp21, label %for.inc, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %if.end20
  %cmp23 = icmp sgt i64 %min_pong.0108, %.pre
  %spec.select118 = select i1 %cmp23, ptr %call13, ptr %min_pong_node.0106
  %spec.select119 = tail call i64 @llvm.smin.i64(i64 %min_pong.0108, i64 %.pre)
  br label %for.inc

for.inc:                                          ; preds = %lor.lhs.false22, %if.end20, %if.end17, %for.body, %lor.lhs.false
  %min_pong_node.1 = phi ptr [ %min_pong_node.0106, %for.body ], [ %min_pong_node.0106, %lor.lhs.false ], [ %min_pong_node.0106, %if.end17 ], [ %call13, %if.end20 ], [ %spec.select118, %lor.lhs.false22 ]
  %min_pong.1 = phi i64 [ %min_pong.0108, %for.body ], [ %min_pong.0108, %lor.lhs.false ], [ %min_pong.0108, %if.end17 ], [ %.pre, %if.end20 ], [ %spec.select119, %lor.lhs.false22 ]
  %inc27 = add nuw nsw i32 %j.0107, 1
  %exitcond.not = icmp eq i32 %inc27, 5
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !63

for.end:                                          ; preds = %for.inc
  %tobool28.not = icmp eq ptr %min_pong_node.1, null
  br i1 %tobool28.not, label %if.end35, label %do.body

do.body:                                          ; preds = %for.end
  %44 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp30 = icmp sgt i32 %44, 0
  br i1 %cmp30, label %do.end, label %if.end32

if.end32:                                         ; preds = %do.body
  %name = getelementptr inbounds %struct._clusterNode, ptr %min_pong_node.1, i64 0, i32 1
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.136, ptr noundef nonnull %name) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end32
  %link33 = getelementptr inbounds %struct._clusterNode, ptr %min_pong_node.1, i64 0, i32 27
  %45 = load ptr, ptr %link33, align 8
  tail call void @clusterSendPing(ptr noundef %45, i32 noundef 0)
  br label %if.end35

if.end35:                                         ; preds = %for.end, %do.end, %while.end
  %46 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes36 = getelementptr inbounds %struct.clusterState, ptr %46, i64 0, i32 4
  %47 = load ptr, ptr %nodes36, align 8
  %call37 = tail call ptr @dictGetSafeIterator(ptr noundef %47) #33
  br label %while.cond38.outer.outer.outer

while.cond38.outer.outer.outer:                   ; preds = %do.end144, %if.end35
  %this_slaves.0.ph.ph.ph = phi i32 [ %this_slaves.1, %do.end144 ], [ 0, %if.end35 ]
  %max_slaves.0.ph.ph.ph = phi i32 [ %max_slaves.2, %do.end144 ], [ 0, %if.end35 ]
  %orphaned_masters.0.ph.ph.ph = phi i32 [ %orphaned_masters.2, %do.end144 ], [ 0, %if.end35 ]
  %tobool186.not = phi i1 [ false, %do.end144 ], [ true, %if.end35 ]
  br label %while.cond38.outer.outer

while.cond38.outer.outer:                         ; preds = %while.cond38.outer.outer.backedge, %while.cond38.outer.outer.outer
  %this_slaves.0.ph.ph = phi i32 [ %this_slaves.0.ph.ph.ph, %while.cond38.outer.outer.outer ], [ %this_slaves.1, %while.cond38.outer.outer.backedge ]
  %max_slaves.0.ph.ph = phi i32 [ %max_slaves.0.ph.ph.ph, %while.cond38.outer.outer.outer ], [ %max_slaves.2, %while.cond38.outer.outer.backedge ]
  %orphaned_masters.0.ph.ph = phi i32 [ %orphaned_masters.0.ph.ph.ph, %while.cond38.outer.outer.outer ], [ %orphaned_masters.2, %while.cond38.outer.outer.backedge ]
  br label %while.cond38.outer

while.cond38.outer:                               ; preds = %while.cond38.outer.backedge, %while.cond38.outer.outer
  %this_slaves.0.ph = phi i32 [ %this_slaves.0.ph.ph, %while.cond38.outer.outer ], [ %this_slaves.1, %while.cond38.outer.backedge ]
  %max_slaves.0.ph = phi i32 [ %max_slaves.0.ph.ph, %while.cond38.outer.outer ], [ %max_slaves.2, %while.cond38.outer.backedge ]
  %orphaned_masters.0.ph = phi i32 [ %orphaned_masters.0.ph.ph, %while.cond38.outer.outer ], [ %orphaned_masters.2, %while.cond38.outer.backedge ]
  br label %while.cond38

while.cond38:                                     ; preds = %while.cond38.outer, %while.body41
  %call39 = tail call ptr @dictNext(ptr noundef %call37) #33
  %cmp40.not = icmp eq ptr %call39, null
  br i1 %cmp40.not, label %while.end148, label %while.body41

while.body41:                                     ; preds = %while.cond38
  %call43 = tail call ptr @dictGetVal(ptr noundef nonnull %call39) #33
  %call44 = tail call i64 @mstime() #33
  %flags45 = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 3
  %48 = load i32, ptr %flags45, align 8
  %and46 = and i32 %48, 112
  %tobool47.not = icmp eq i32 %and46, 0
  br i1 %tobool47.not, label %if.end49, label %while.cond38, !llvm.loop !64

if.end49:                                         ; preds = %while.body41
  %49 = load ptr, ptr @myself, align 8
  %flags50 = getelementptr inbounds %struct._clusterNode, ptr %49, i64 0, i32 3
  %50 = load i32, ptr %flags50, align 8
  %and51 = and i32 %50, 2
  %tobool52.not = icmp ne i32 %and51, 0
  %51 = and i32 %48, 9
  %52 = icmp eq i32 %51, 1
  %or.cond98 = and i1 %52, %tobool52.not
  br i1 %or.cond98, label %if.then59, label %if.end77

if.then59:                                        ; preds = %if.end49
  %numslaves.i = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 9
  %53 = load i32, ptr %numslaves.i, align 8
  %cmp5.i = icmp sgt i32 %53, 0
  br i1 %cmp5.i, label %for.body.lr.ph.i, label %land.lhs.true62

for.body.lr.ph.i:                                 ; preds = %if.then59
  %slaves.i = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 10
  %54 = load ptr, ptr %slaves.i, align 8
  %wide.trip.count.i = zext nneg i32 %53 to i64
  br label %for.body.i

for.body.i:                                       ; preds = %for.body.i, %for.body.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %for.body.lr.ph.i ], [ %indvars.iv.next.i, %for.body.i ]
  %okslaves.07.i = phi i32 [ 0, %for.body.lr.ph.i ], [ %spec.select.i, %for.body.i ]
  %arrayidx.i = getelementptr inbounds ptr, ptr %54, i64 %indvars.iv.i
  %55 = load ptr, ptr %arrayidx.i, align 8
  %flags.i74 = getelementptr inbounds %struct._clusterNode, ptr %55, i64 0, i32 3
  %56 = load i32, ptr %flags.i74, align 8
  %and.i75 = lshr i32 %56, 3
  %57 = and i32 %and.i75, 1
  %58 = xor i32 %57, 1
  %spec.select.i = add i32 %58, %okslaves.07.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, %wide.trip.count.i
  br i1 %exitcond.not.i, label %clusterCountNonFailingSlaves.exit, label %for.body.i, !llvm.loop !32

clusterCountNonFailingSlaves.exit:                ; preds = %for.body.i
  %cmp61 = icmp eq i32 %spec.select.i, 0
  br i1 %cmp61, label %land.lhs.true62, label %if.end70

land.lhs.true62:                                  ; preds = %if.then59, %clusterCountNonFailingSlaves.exit
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 8
  %59 = load i32, ptr %numslots, align 4
  %cmp63 = icmp sgt i32 %59, 0
  br i1 %cmp63, label %land.lhs.true64, label %if.end70

land.lhs.true64:                                  ; preds = %land.lhs.true62
  %and66 = lshr i32 %48, 8
  %60 = and i32 %and66, 1
  %spec.select = add i32 %60, %orphaned_masters.0.ph
  br label %if.end70

if.end70:                                         ; preds = %land.lhs.true64, %land.lhs.true62, %clusterCountNonFailingSlaves.exit
  %okslaves.0.lcssa.i95 = phi i32 [ 0, %land.lhs.true62 ], [ %spec.select.i, %clusterCountNonFailingSlaves.exit ], [ 0, %land.lhs.true64 ]
  %orphaned_masters.1 = phi i32 [ %orphaned_masters.0.ph, %land.lhs.true62 ], [ %orphaned_masters.0.ph, %clusterCountNonFailingSlaves.exit ], [ %spec.select, %land.lhs.true64 ]
  %spec.select62 = tail call i32 @llvm.smax.i32(i32 %okslaves.0.lcssa.i95, i32 %max_slaves.0.ph)
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %49, i64 0, i32 11
  %61 = load ptr, ptr %slaveof, align 8
  %cmp74 = icmp eq ptr %61, %call43
  %spec.select65 = select i1 %cmp74, i32 %okslaves.0.lcssa.i95, i32 %this_slaves.0.ph
  br label %if.end77

if.end77:                                         ; preds = %if.end70, %if.end49
  %this_slaves.1 = phi i32 [ %this_slaves.0.ph, %if.end49 ], [ %spec.select65, %if.end70 ]
  %max_slaves.2 = phi i32 [ %max_slaves.0.ph, %if.end49 ], [ %spec.select62, %if.end70 ]
  %orphaned_masters.2 = phi i32 [ %orphaned_masters.0.ph, %if.end49 ], [ %orphaned_masters.1, %if.end70 ]
  %ping_sent78 = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 13
  %62 = load i64, ptr %ping_sent78, align 8
  %sub = sub nsw i64 %call44, %62
  %data_received = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 15
  %63 = load i64, ptr %data_received, align 8
  %sub79 = sub nsw i64 %call44, %63
  %link80 = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 27
  %64 = load ptr, ptr %link80, align 8
  %tobool81.not = icmp eq ptr %64, null
  br i1 %tobool81.not, label %if.end96, label %land.lhs.true82

land.lhs.true82:                                  ; preds = %if.end77
  %65 = load i64, ptr %64, align 8
  %sub84 = sub nsw i64 %call44, %65
  %66 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %cmp85 = icmp sle i64 %sub84, %66
  %tobool88.not = icmp eq i64 %62, 0
  %or.cond63 = select i1 %cmp85, i1 true, i1 %tobool88.not
  br i1 %or.cond63, label %if.end96, label %land.lhs.true89

land.lhs.true89:                                  ; preds = %land.lhs.true82
  %div = sdiv i64 %66, 2
  %cmp90 = icmp sgt i64 %sub, %div
  %cmp93 = icmp sgt i64 %sub79, %div
  %or.cond64 = select i1 %cmp90, i1 %cmp93, i1 false
  br i1 %or.cond64, label %if.then94, label %if.end96

if.then94:                                        ; preds = %land.lhs.true89
  tail call void @freeClusterLink(ptr noundef nonnull %64)
  br label %if.end96

if.end96:                                         ; preds = %if.then94, %land.lhs.true89, %land.lhs.true82, %if.end77
  %67 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 365), align 8
  %tobool97.not = icmp eq i64 %67, 0
  br i1 %tobool97.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %if.end96
  %68 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %div98 = sdiv i64 %68, 2
  br label %cond.end

cond.end:                                         ; preds = %if.end96, %cond.false
  %cond = phi i64 [ %div98, %cond.false ], [ %67, %if.end96 ]
  %69 = load ptr, ptr %link80, align 8
  %tobool100.not = icmp eq ptr %69, null
  br i1 %tobool100.not, label %if.end110, label %land.lhs.true101

land.lhs.true101:                                 ; preds = %cond.end
  %70 = load i64, ptr %ping_sent78, align 8
  %cmp103 = icmp eq i64 %70, 0
  br i1 %cmp103, label %land.lhs.true104, label %if.end110

land.lhs.true104:                                 ; preds = %land.lhs.true101
  %pong_received105 = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 14
  %71 = load i64, ptr %pong_received105, align 8
  %sub106 = sub nsw i64 %call44, %71
  %cmp107 = icmp sgt i64 %sub106, %cond
  br i1 %cmp107, label %while.cond38.outer.backedge.sink.split, label %if.end110

while.cond38.outer.backedge.sink.split:           ; preds = %land.lhs.true104, %land.lhs.true115
  tail call void @clusterSendPing(ptr noundef nonnull %69, i32 noundef 0)
  br label %while.cond38.outer.backedge

while.cond38.outer.backedge:                      ; preds = %while.cond38.outer.backedge.sink.split, %if.end122
  br label %while.cond38.outer, !llvm.loop !64

if.end110:                                        ; preds = %land.lhs.true104, %land.lhs.true101, %cond.end
  %72 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %72, i64 0, i32 17
  %73 = load i64, ptr %mf_end, align 8
  %tobool111.not = icmp eq i64 %73, 0
  br i1 %tobool111.not, label %if.end122, label %land.lhs.true112

land.lhs.true112:                                 ; preds = %if.end110
  %74 = load ptr, ptr @myself, align 8
  %flags.i76 = getelementptr inbounds %struct._clusterNode, ptr %74, i64 0, i32 3
  %75 = load i32, ptr %flags.i76, align 8
  %and.i77 = and i32 %75, 1
  %tobool114.not = icmp eq i32 %and.i77, 0
  br i1 %tobool114.not, label %if.end122, label %land.lhs.true115

land.lhs.true115:                                 ; preds = %land.lhs.true112
  %mf_slave = getelementptr inbounds %struct.clusterState, ptr %72, i64 0, i32 18
  %76 = load ptr, ptr %mf_slave, align 8
  %cmp116 = icmp ne ptr %76, %call43
  %brmerge = or i1 %tobool100.not, %cmp116
  br i1 %brmerge, label %if.end122, label %while.cond38.outer.backedge.sink.split

if.end122:                                        ; preds = %land.lhs.true115, %land.lhs.true112, %if.end110
  %77 = load i64, ptr %ping_sent78, align 8
  %cmp124 = icmp eq i64 %77, 0
  br i1 %cmp124, label %while.cond38.outer.backedge, label %if.end126

if.end126:                                        ; preds = %if.end122
  %cond131 = tail call i64 @llvm.smin.i64(i64 %sub, i64 %sub79)
  %78 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 364), align 8
  %cmp132 = icmp sgt i64 %cond131, %78
  br i1 %cmp132, label %if.then133, label %while.cond38.outer.outer.backedge

if.then133:                                       ; preds = %if.end126
  %flags45.le.le = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 3
  %79 = load i32, ptr %flags45.le.le, align 8
  %and135 = and i32 %79, 12
  %tobool136.not = icmp eq i32 %and135, 0
  br i1 %tobool136.not, label %do.body138, label %while.cond38.outer.outer.backedge

while.cond38.outer.outer.backedge:                ; preds = %if.then133, %if.end126
  br label %while.cond38.outer.outer, !llvm.loop !64

do.body138:                                       ; preds = %if.then133
  %flags45.le.le.le = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 3
  %80 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp139 = icmp sgt i32 %80, 0
  br i1 %cmp139, label %do.end144, label %if.end141

if.end141:                                        ; preds = %do.body138
  %name142 = getelementptr inbounds %struct._clusterNode, ptr %call43, i64 0, i32 1
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef nonnull @.str.137, ptr noundef nonnull %name142) #33
  %.pre113 = load i32, ptr %flags45.le.le.le, align 8
  br label %do.end144

do.end144:                                        ; preds = %do.body138, %if.end141
  %81 = phi i32 [ %79, %do.body138 ], [ %.pre113, %if.end141 ]
  %or = or i32 %81, 4
  store i32 %or, ptr %flags45.le.le.le, align 8
  br label %while.cond38.outer.outer.outer, !llvm.loop !64

while.end148:                                     ; preds = %while.cond38
  tail call void @dictReleaseIterator(ptr noundef %call37) #33
  %82 = load ptr, ptr @myself, align 8
  %flags149 = getelementptr inbounds %struct._clusterNode, ptr %82, i64 0, i32 3
  %83 = load i32, ptr %flags149, align 8
  %and150 = and i32 %83, 2
  %tobool151 = icmp ne i32 %and150, 0
  %84 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 283), align 8
  %cmp153 = icmp eq ptr %84, null
  %or.cond = select i1 %tobool151, i1 %cmp153, i1 false
  br i1 %or.cond, label %land.lhs.true154, label %if.end167

land.lhs.true154:                                 ; preds = %while.end148
  %slaveof155 = getelementptr inbounds %struct._clusterNode, ptr %82, i64 0, i32 11
  %85 = load ptr, ptr %slaveof155, align 8
  %tobool156.not = icmp eq ptr %85, null
  br i1 %tobool156.not, label %if.end167, label %land.lhs.true157

land.lhs.true157:                                 ; preds = %land.lhs.true154
  %flags159 = getelementptr inbounds %struct._clusterNode, ptr %85, i64 0, i32 3
  %86 = load i32, ptr %flags159, align 8
  %and160 = and i32 %86, 64
  %tobool161.not = icmp eq i32 %and160, 0
  br i1 %tobool161.not, label %if.then162, label %if.end167

if.then162:                                       ; preds = %land.lhs.true157
  %ip = getelementptr inbounds %struct._clusterNode, ptr %85, i64 0, i32 21
  %87 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 403), align 4
  %tobool.not.i78 = icmp eq i32 %87, 0
  %tls_port.i = getelementptr inbounds %struct._clusterNode, ptr %85, i64 0, i32 25
  %tcp_port.i = getelementptr inbounds %struct._clusterNode, ptr %85, i64 0, i32 24
  %cond.in.i = select i1 %tobool.not.i78, ptr %tcp_port.i, ptr %tls_port.i
  %cond.i = load i32, ptr %cond.in.i, align 4
  tail call void @replicationSetMaster(ptr noundef nonnull %ip, i32 noundef %cond.i) #33
  br label %if.end167

if.end167:                                        ; preds = %if.then162, %land.lhs.true157, %land.lhs.true154, %while.end148
  %88 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end.i = getelementptr inbounds %struct.clusterState, ptr %88, i64 0, i32 17
  %89 = load i64, ptr %mf_end.i, align 8
  %tobool.not.i79 = icmp eq i64 %89, 0
  br i1 %tobool.not.i79, label %manualFailoverCheckTimeout.exit, label %land.lhs.true.i80

land.lhs.true.i80:                                ; preds = %if.end167
  %call.i = tail call i64 @mstime() #33
  %cmp.i81 = icmp slt i64 %89, %call.i
  br i1 %cmp.i81, label %do.body.i82, label %manualFailoverCheckTimeout.exit

do.body.i82:                                      ; preds = %land.lhs.true.i80
  %90 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp2.i = icmp sgt i32 %90, 3
  br i1 %cmp2.i, label %do.end.i84, label %if.end.i83

if.end.i83:                                       ; preds = %do.body.i82
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.134) #33
  br label %do.end.i84

do.end.i84:                                       ; preds = %if.end.i83, %do.body.i82
  %91 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_slave.i.i = getelementptr inbounds %struct.clusterState, ptr %91, i64 0, i32 18
  %92 = load ptr, ptr %mf_slave.i.i, align 8
  %tobool.not.i.i85 = icmp eq ptr %92, null
  br i1 %tobool.not.i.i85, label %resetManualFailover.exit.i, label %if.then.i.i

if.then.i.i:                                      ; preds = %do.end.i84
  tail call void @unpauseActions(i32 noundef 2) #33
  %.pre.i.i = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %resetManualFailover.exit.i

resetManualFailover.exit.i:                       ; preds = %if.then.i.i, %do.end.i84
  %93 = phi ptr [ %.pre.i.i, %if.then.i.i ], [ %91, %do.end.i84 ]
  %mf_end.i.i = getelementptr inbounds %struct.clusterState, ptr %93, i64 0, i32 17
  %mf_can_start.i.i = getelementptr inbounds %struct.clusterState, ptr %93, i64 0, i32 20
  store i32 0, ptr %mf_can_start.i.i, align 8
  %mf_master_offset.i.i = getelementptr inbounds %struct.clusterState, ptr %93, i64 0, i32 19
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %mf_end.i.i, i8 0, i64 16, i1 false)
  store i64 -1, ptr %mf_master_offset.i.i, align 8
  br label %manualFailoverCheckTimeout.exit

manualFailoverCheckTimeout.exit:                  ; preds = %if.end167, %land.lhs.true.i80, %resetManualFailover.exit.i
  %94 = load ptr, ptr @myself, align 8
  %flags168 = getelementptr inbounds %struct._clusterNode, ptr %94, i64 0, i32 3
  %95 = load i32, ptr %flags168, align 8
  %and169 = and i32 %95, 2
  %tobool170.not = icmp eq i32 %and169, 0
  br i1 %tobool170.not, label %if.end185, label %if.then171

if.then171:                                       ; preds = %manualFailoverCheckTimeout.exit
  %96 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end.i86 = getelementptr inbounds %struct.clusterState, ptr %96, i64 0, i32 17
  %97 = load i64, ptr %mf_end.i86, align 8
  %cmp.i87 = icmp eq i64 %97, 0
  br i1 %cmp.i87, label %clusterHandleManualFailover.exit, label %if.end.i88

if.end.i88:                                       ; preds = %if.then171
  %mf_can_start.i = getelementptr inbounds %struct.clusterState, ptr %96, i64 0, i32 20
  %98 = load i32, ptr %mf_can_start.i, align 8
  %tobool.not.i89 = icmp eq i32 %98, 0
  br i1 %tobool.not.i89, label %if.end2.i, label %clusterHandleManualFailover.exit

if.end2.i:                                        ; preds = %if.end.i88
  %mf_master_offset.i = getelementptr inbounds %struct.clusterState, ptr %96, i64 0, i32 19
  %99 = load i64, ptr %mf_master_offset.i, align 8
  %cmp3.i = icmp eq i64 %99, -1
  br i1 %cmp3.i, label %clusterHandleManualFailover.exit, label %if.end5.i90

if.end5.i90:                                      ; preds = %if.end2.i
  %call.i91 = tail call i64 @replicationGetSlaveOffset() #33
  %cmp7.i = icmp eq i64 %99, %call.i91
  %100 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br i1 %cmp7.i, label %if.then8.i, label %return.sink.split.i

if.then8.i:                                       ; preds = %if.end5.i90
  %mf_can_start9.i = getelementptr inbounds %struct.clusterState, ptr %100, i64 0, i32 20
  store i32 1, ptr %mf_can_start9.i, align 8
  %101 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp10.i = icmp sgt i32 %101, 2
  br i1 %cmp10.i, label %return.sink.split.i, label %if.end12.i

if.end12.i:                                       ; preds = %if.then8.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.135) #33
  %.pre.i92 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %return.sink.split.i

return.sink.split.i:                              ; preds = %if.end12.i, %if.then8.i, %if.end5.i90
  %.sink.i = phi ptr [ %100, %if.then8.i ], [ %.pre.i92, %if.end12.i ], [ %100, %if.end5.i90 ]
  %.sink3.i = phi i32 [ 1, %if.then8.i ], [ 1, %if.end12.i ], [ 16, %if.end5.i90 ]
  %todo_before_sleep.i.i = getelementptr inbounds %struct.clusterState, ptr %.sink.i, i64 0, i32 22
  %102 = load i32, ptr %todo_before_sleep.i.i, align 8
  %or.i2.i = or i32 %102, %.sink3.i
  store i32 %or.i2.i, ptr %todo_before_sleep.i.i, align 8
  br label %clusterHandleManualFailover.exit

clusterHandleManualFailover.exit:                 ; preds = %if.then171, %if.end.i88, %if.end2.i, %return.sink.split.i
  %103 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  %and172 = and i32 %103, 2
  %tobool173.not = icmp eq i32 %and172, 0
  br i1 %tobool173.not, label %if.then174, label %if.end175

if.then174:                                       ; preds = %clusterHandleManualFailover.exit
  tail call void @clusterHandleSlaveFailover()
  br label %if.end175

if.end175:                                        ; preds = %if.then174, %clusterHandleManualFailover.exit
  %tobool176 = icmp ne i32 %orphaned_masters.0.ph, 0
  %cmp178 = icmp sgt i32 %max_slaves.0.ph, 1
  %or.cond1 = select i1 %tobool176, i1 %cmp178, i1 false
  br i1 %or.cond1, label %land.lhs.true179, label %if.end185

land.lhs.true179:                                 ; preds = %if.end175
  %cmp180 = icmp eq i32 %this_slaves.0.ph, %max_slaves.0.ph
  %104 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 369), align 4
  %tobool182 = icmp ne i32 %104, 0
  %or.cond2 = select i1 %cmp180, i1 %tobool182, i1 false
  br i1 %or.cond2, label %if.then183, label %if.end185

if.then183:                                       ; preds = %land.lhs.true179
  tail call void @clusterHandleSlaveMigration(i32 noundef %this_slaves.0.ph)
  br label %if.end185

if.end185:                                        ; preds = %if.end175, %land.lhs.true179, %if.then183, %manualFailoverCheckTimeout.exit
  br i1 %tobool186.not, label %lor.lhs.false187, label %if.then189

lor.lhs.false187:                                 ; preds = %if.end185
  %105 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %105, i64 0, i32 2
  %106 = load i32, ptr %state, align 8
  %cmp188 = icmp eq i32 %106, 1
  br i1 %cmp188, label %if.then189, label %if.end190

if.then189:                                       ; preds = %lor.lhs.false187, %if.end185
  tail call void @clusterUpdateState()
  br label %if.end190

if.end190:                                        ; preds = %if.then189, %lor.lhs.false187
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterBeforeSleep() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 22
  %1 = load i32, ptr %todo_before_sleep, align 8
  store i32 0, ptr %todo_before_sleep, align 8
  %and = and i32 %1, 16
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @myself, align 8
  %flags2 = getelementptr inbounds %struct._clusterNode, ptr %2, i64 0, i32 3
  %3 = load i32, ptr %flags2, align 8
  %and3 = and i32 %3, 2
  %tobool4.not = icmp eq i32 %and3, 0
  br i1 %tobool4.not, label %if.end14, label %if.then5

if.then5:                                         ; preds = %if.then
  %mf_end.i = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 17
  %4 = load i64, ptr %mf_end.i, align 8
  %cmp.i = icmp eq i64 %4, 0
  br i1 %cmp.i, label %clusterHandleManualFailover.exit, label %if.end.i

if.end.i:                                         ; preds = %if.then5
  %mf_can_start.i = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 20
  %5 = load i32, ptr %mf_can_start.i, align 8
  %tobool.not.i = icmp eq i32 %5, 0
  br i1 %tobool.not.i, label %if.end2.i, label %clusterHandleManualFailover.exit

if.end2.i:                                        ; preds = %if.end.i
  %mf_master_offset.i = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 19
  %6 = load i64, ptr %mf_master_offset.i, align 8
  %cmp3.i = icmp eq i64 %6, -1
  br i1 %cmp3.i, label %clusterHandleManualFailover.exit, label %if.end5.i

if.end5.i:                                        ; preds = %if.end2.i
  %call.i = tail call i64 @replicationGetSlaveOffset() #33
  %cmp7.i = icmp eq i64 %6, %call.i
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br i1 %cmp7.i, label %if.then8.i, label %return.sink.split.i

if.then8.i:                                       ; preds = %if.end5.i
  %mf_can_start9.i = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 20
  store i32 1, ptr %mf_can_start9.i, align 8
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp10.i = icmp sgt i32 %8, 2
  br i1 %cmp10.i, label %return.sink.split.i, label %if.end12.i

if.end12.i:                                       ; preds = %if.then8.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.135) #33
  %.pre.i = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %return.sink.split.i

return.sink.split.i:                              ; preds = %if.end12.i, %if.then8.i, %if.end5.i
  %.sink.i = phi ptr [ %7, %if.then8.i ], [ %.pre.i, %if.end12.i ], [ %7, %if.end5.i ]
  %.sink3.i = phi i32 [ 1, %if.then8.i ], [ 1, %if.end12.i ], [ 16, %if.end5.i ]
  %todo_before_sleep.i.i = getelementptr inbounds %struct.clusterState, ptr %.sink.i, i64 0, i32 22
  %9 = load i32, ptr %todo_before_sleep.i.i, align 8
  %or.i2.i = or i32 %9, %.sink3.i
  store i32 %or.i2.i, ptr %todo_before_sleep.i.i, align 8
  br label %clusterHandleManualFailover.exit

clusterHandleManualFailover.exit:                 ; preds = %if.then5, %if.end.i, %if.end2.i, %return.sink.split.i
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  %and6 = and i32 %10, 2
  %tobool7.not = icmp eq i32 %and6, 0
  br i1 %tobool7.not, label %if.end14.sink.split, label %if.end14

if.else:                                          ; preds = %entry
  %and10 = and i32 %1, 1
  %tobool11.not = icmp eq i32 %and10, 0
  br i1 %tobool11.not, label %if.end14, label %if.end14.sink.split

if.end14.sink.split:                              ; preds = %if.else, %clusterHandleManualFailover.exit
  tail call void @clusterHandleSlaveFailover()
  br label %if.end14

if.end14:                                         ; preds = %if.end14.sink.split, %if.else, %if.then, %clusterHandleManualFailover.exit
  %and15 = and i32 %1, 2
  %tobool16.not = icmp eq i32 %and15, 0
  br i1 %tobool16.not, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end14
  tail call void @clusterUpdateState()
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end14
  %and19 = and i32 %1, 4
  %tobool20.not = icmp eq i32 %and19, 0
  br i1 %tobool20.not, label %if.end23, label %if.then21

if.then21:                                        ; preds = %if.end18
  %and22 = and i32 %1, 8
  %call.i5 = tail call i32 @clusterSaveConfig(i32 noundef %and22), !range !21
  %cmp.i6 = icmp eq i32 %call.i5, -1
  br i1 %cmp.i6, label %do.body.i, label %if.end23

do.body.i:                                        ; preds = %if.then21
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i = icmp sgt i32 %11, 3
  br i1 %cmp1.i, label %do.end.i, label %if.end.i7

if.end.i7:                                        ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.38) #33
  br label %do.end.i

do.end.i:                                         ; preds = %if.end.i7, %do.body.i
  tail call void @exit(i32 noundef 1) #35
  unreachable

if.end23:                                         ; preds = %if.then21, %if.end18
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterMastersHaveSlaves() local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %if.end, %entry
  %slaves.0.ph = phi i32 [ %add, %if.end ], [ 0, %entry ]
  br label %while.cond

while.cond:                                       ; preds = %while.cond.outer, %while.body
  %call1 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call1, null
  br i1 %cmp.not, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %call2 = tail call ptr @dictGetVal(ptr noundef nonnull %call1) #33
  %flags = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and = and i32 %2, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %while.cond, !llvm.loop !14

if.end:                                           ; preds = %while.body
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %call2, i64 0, i32 9
  %3 = load i32, ptr %numslaves, align 8
  %add = add nsw i32 %3, %slaves.0.ph
  br label %while.cond.outer, !llvm.loop !14

while.end:                                        ; preds = %while.cond
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  %cmp3 = icmp ne i32 %slaves.0.ph, 0
  %conv = zext i1 %cmp3 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeSetSlotBit(ptr nocapture noundef %n, i32 noundef %slot) local_unnamed_addr #2 {
entry:
  %slots = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 5
  %div.i = sdiv i32 %slot, 8
  %conv.i = sext i32 %div.i to i64
  %and.i = and i32 %slot, 7
  %arrayidx.i = getelementptr inbounds i8, ptr %slots, i64 %conv.i
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv1.i = zext i8 %0 to i32
  %1 = lshr i32 %conv1.i, %and.i
  %conv3.i = and i32 %1, 1
  %tobool.not = icmp eq i32 %conv3.i, 0
  br i1 %tobool.not, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %shl.i = shl nuw nsw i32 1, %and.i
  %2 = trunc i32 %shl.i to i8
  %conv2.i = or i8 %0, %2
  store i8 %conv2.i, ptr %arrayidx.i, align 1
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 8
  %3 = load i32, ptr %numslots, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %numslots, align 4
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.then
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 4
  %5 = load ptr, ptr %nodes.i, align 8
  %call.i = tail call ptr @dictGetSafeIterator(ptr noundef %5) #33
  br label %while.cond.outer.i

while.cond.outer.i:                               ; preds = %if.end.i, %land.lhs.true
  %slaves.0.ph.i = phi i32 [ %add.i, %if.end.i ], [ 0, %land.lhs.true ]
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %while.cond.outer.i
  %call1.i = tail call ptr @dictNext(ptr noundef %call.i) #33
  %cmp.not.i = icmp eq ptr %call1.i, null
  br i1 %cmp.not.i, label %clusterMastersHaveSlaves.exit, label %while.body.i

while.body.i:                                     ; preds = %while.cond.i
  %call2.i = tail call ptr @dictGetVal(ptr noundef nonnull %call1.i) #33
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %call2.i, i64 0, i32 3
  %6 = load i32, ptr %flags.i, align 8
  %and.i11 = and i32 %6, 2
  %tobool.not.i = icmp eq i32 %and.i11, 0
  br i1 %tobool.not.i, label %if.end.i, label %while.cond.i, !llvm.loop !14

if.end.i:                                         ; preds = %while.body.i
  %numslaves.i = getelementptr inbounds %struct._clusterNode, ptr %call2.i, i64 0, i32 9
  %7 = load i32, ptr %numslaves.i, align 8
  %add.i = add nsw i32 %7, %slaves.0.ph.i
  br label %while.cond.outer.i, !llvm.loop !14

clusterMastersHaveSlaves.exit:                    ; preds = %while.cond.i
  tail call void @dictReleaseIterator(ptr noundef %call.i) #33
  %cmp3.i.not = icmp eq i32 %slaves.0.ph.i, 0
  br i1 %cmp3.i.not, label %if.end7, label %if.then6

if.then6:                                         ; preds = %clusterMastersHaveSlaves.exit
  %flags = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 3
  %8 = load i32, ptr %flags, align 8
  %or = or i32 %8, 256
  store i32 %or, ptr %flags, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then, %clusterMastersHaveSlaves.exit, %if.then6, %entry
  ret i32 %conv3.i
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable
define dso_local i32 @clusterNodeClearSlotBit(ptr nocapture noundef %n, i32 noundef %slot) local_unnamed_addr #26 {
entry:
  %slots = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 5
  %div.i = sdiv i32 %slot, 8
  %conv.i = sext i32 %div.i to i64
  %and.i = and i32 %slot, 7
  %arrayidx.i = getelementptr inbounds i8, ptr %slots, i64 %conv.i
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv1.i = zext i8 %0 to i32
  %1 = lshr i32 %conv1.i, %and.i
  %conv3.i = and i32 %1, 1
  %tobool.not = icmp eq i32 %conv3.i, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %shl.i = shl nuw nsw i32 1, %and.i
  %2 = trunc i32 %shl.i to i8
  %3 = xor i8 %2, -1
  %conv3.i9 = and i8 %0, %3
  store i8 %conv3.i9, ptr %arrayidx.i, align 1
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 8
  %4 = load i32, ptr %numslots, align 4
  %dec = add nsw i32 %4, -1
  store i32 %dec, ptr %numslots, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %conv3.i
}

; Function Attrs: nounwind uwtable
define dso_local void @removeChannelsInSlot(i32 noundef %slot) local_unnamed_addr #2 {
entry:
  %iter = alloca %struct.raxIterator, align 8
  %indexed = alloca [2 x i8], align 1
  %call = tail call i32 @countChannelsInSlot(i32 noundef %slot)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i32 %call to i64
  %mul = shl nuw nsw i64 %conv, 3
  %call1 = tail call noalias ptr @zmalloc(i64 noundef %mul) #37
  %shr = lshr i32 %slot, 8
  %conv2 = trunc i32 %shr to i8
  store i8 %conv2, ptr %indexed, align 1
  %conv4 = trunc i32 %slot to i8
  %arrayidx5 = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 1
  store i8 %conv4, ptr %arrayidx5, align 1
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %slots_to_channels = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 10
  %1 = load ptr, ptr %slots_to_channels, align 8
  call void @raxStart(ptr noundef nonnull %iter, ptr noundef %1) #33
  %call6 = call i32 @raxSeek(ptr noundef nonnull %iter, ptr noundef nonnull @.str.205, ptr noundef nonnull %indexed, i64 noundef 2) #33
  %key = getelementptr inbounds %struct.raxIterator, ptr %iter, i64 0, i32 2
  %call77 = call i32 @raxNext(ptr noundef nonnull %iter) #33
  %tobool.not8 = icmp eq i32 %call77, 0
  br i1 %tobool.not8, label %while.end, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %if.end
  %key_len = getelementptr inbounds %struct.raxIterator, ptr %iter, i64 0, i32 4
  br label %while.body

while.body:                                       ; preds = %while.body.lr.ph, %if.end22
  %indvars.iv = phi i64 [ 0, %while.body.lr.ph ], [ %indvars.iv.next, %if.end22 ]
  %2 = load ptr, ptr %key, align 8
  %3 = load i8, ptr %2, align 1
  %4 = load i8, ptr %indexed, align 1
  %cmp12.not = icmp eq i8 %3, %4
  br i1 %cmp12.not, label %lor.lhs.false, label %while.end

lor.lhs.false:                                    ; preds = %while.body
  %arrayidx15 = getelementptr inbounds i8, ptr %2, i64 1
  %5 = load i8, ptr %arrayidx15, align 1
  %6 = load i8, ptr %arrayidx5, align 1
  %cmp19.not = icmp eq i8 %5, %6
  br i1 %cmp19.not, label %if.end22, label %while.end

if.end22:                                         ; preds = %lor.lhs.false
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 2
  %7 = load i64, ptr %key_len, align 8
  %sub = add i64 %7, -2
  %call24 = call ptr @createStringObject(ptr noundef nonnull %add.ptr, i64 noundef %sub) #33
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  %arrayidx25 = getelementptr inbounds ptr, ptr %call1, i64 %indvars.iv
  store ptr %call24, ptr %arrayidx25, align 8
  %call7 = call i32 @raxNext(ptr noundef nonnull %iter) #33
  %tobool.not = icmp eq i32 %call7, 0
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !65

while.end:                                        ; preds = %if.end22, %lor.lhs.false, %while.body, %if.end
  call void @raxStop(ptr noundef nonnull %iter) #33
  call void @pubsubUnsubscribeShardChannels(ptr noundef %call1, i32 noundef %call) #33
  call void @zfree(ptr noundef %call1) #33
  br label %return

return:                                           ; preds = %entry, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @verifyClusterConfigWithData() local_unnamed_addr #2 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 380), align 8
  %and = and i32 %0, 4
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and1 = and i32 %2, 2
  %tobool2.not = icmp eq i32 %and1, 0
  br i1 %tobool2.not, label %for.cond.preheader, label %return

for.cond.preheader:                               ; preds = %if.end
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %cmp18 = icmp sgt i32 %3, 1
  br i1 %cmp18, label %for.body, label %for.body10.preheader

for.body10.preheader:                             ; preds = %for.cond, %for.cond.preheader
  br label %for.body10

for.cond:                                         ; preds = %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 173), align 8
  %5 = sext i32 %4 to i64
  %cmp = icmp slt i64 %indvars.iv.next, %5
  br i1 %cmp, label %for.body, label %for.body10.preheader, !llvm.loop !66

for.body:                                         ; preds = %for.cond.preheader, %for.cond
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond ], [ 1, %for.cond.preheader ]
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %6, i64 %indvars.iv
  %call = tail call i64 @dbSize(ptr noundef nonnull %arrayidx, i32 noundef 0) #33
  %tobool5.not = icmp eq i64 %call, 0
  br i1 %tobool5.not, label %for.cond, label %return

for.body10:                                       ; preds = %for.body10.preheader, %for.inc45
  %indvars.iv24 = phi i64 [ %indvars.iv.next25, %for.inc45 ], [ 0, %for.body10.preheader ]
  %update_config.022 = phi i32 [ %update_config.1, %for.inc45 ], [ 0, %for.body10.preheader ]
  %7 = trunc i64 %indvars.iv24 to i32
  %call11 = tail call i32 @countKeysInSlot(i32 noundef %7) #33
  %tobool12.not = icmp eq i32 %call11, 0
  br i1 %tobool12.not, label %for.inc45, label %if.end14

if.end14:                                         ; preds = %for.body10
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx16 = getelementptr inbounds %struct.clusterState, ptr %8, i64 0, i32 9, i64 %indvars.iv24
  %9 = load ptr, ptr %arrayidx16, align 8
  %10 = load ptr, ptr @myself, align 8
  %cmp17 = icmp eq ptr %9, %10
  br i1 %cmp17, label %for.inc45, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end14
  %arrayidx19 = getelementptr inbounds %struct.clusterState, ptr %8, i64 0, i32 8, i64 %indvars.iv24
  %11 = load ptr, ptr %arrayidx19, align 8
  %cmp20.not = icmp eq ptr %11, null
  br i1 %cmp20.not, label %if.end22, label %for.inc45

if.end22:                                         ; preds = %lor.lhs.false
  %inc23 = add nsw i32 %update_config.022, 1
  %cmp27 = icmp eq ptr %9, null
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp29 = icmp sgt i32 %12, 2
  br i1 %cmp27, label %do.body, label %do.body33

do.body:                                          ; preds = %if.end22
  br i1 %cmp29, label %if.end.i, label %do.end

do.end:                                           ; preds = %do.body
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.141, i32 noundef %7) #33
  %.pre28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx.i.phi.trans.insert = getelementptr inbounds %struct.clusterState, ptr %.pre28, i64 0, i32 9, i64 %indvars.iv24
  %.pre29 = load ptr, ptr %arrayidx.i.phi.trans.insert, align 8
  %tobool.not.i = icmp eq ptr %.pre29, null
  br i1 %tobool.not.i, label %if.end.i, label %for.inc45

if.end.i:                                         ; preds = %do.body, %do.end
  %13 = load ptr, ptr @myself, align 8
  %call.i = tail call i32 @clusterNodeSetSlotBit(ptr noundef %13, i32 noundef %7), !range !18
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx3.i = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 9, i64 %indvars.iv24
  store ptr %13, ptr %arrayidx3.i, align 8
  br label %for.inc45

do.body33:                                        ; preds = %if.end22
  br i1 %cmp29, label %do.end37, label %if.end36

if.end36:                                         ; preds = %do.body33
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.142, i32 noundef %7) #33
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx40.phi.trans.insert = getelementptr inbounds %struct.clusterState, ptr %.pre, i64 0, i32 9, i64 %indvars.iv24
  %.pre27 = load ptr, ptr %arrayidx40.phi.trans.insert, align 8
  br label %do.end37

do.end37:                                         ; preds = %do.body33, %if.end36
  %15 = phi ptr [ %9, %do.body33 ], [ %.pre27, %if.end36 ]
  %16 = phi ptr [ %8, %do.body33 ], [ %.pre, %if.end36 ]
  %arrayidx43 = getelementptr inbounds %struct.clusterState, ptr %16, i64 0, i32 8, i64 %indvars.iv24
  store ptr %15, ptr %arrayidx43, align 8
  br label %for.inc45

for.inc45:                                        ; preds = %if.end.i, %do.end, %do.end37, %if.end14, %lor.lhs.false, %for.body10
  %update_config.1 = phi i32 [ %update_config.022, %if.end14 ], [ %update_config.022, %lor.lhs.false ], [ %inc23, %do.end37 ], [ %update_config.022, %for.body10 ], [ %inc23, %do.end ], [ %inc23, %if.end.i ]
  %indvars.iv.next25 = add nuw nsw i64 %indvars.iv24, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next25, 16384
  br i1 %exitcond.not, label %for.end47, label %for.body10, !llvm.loop !67

for.end47:                                        ; preds = %for.inc45
  %tobool48.not = icmp eq i32 %update_config.1, 0
  br i1 %tobool48.not, label %return, label %if.then49

if.then49:                                        ; preds = %for.end47
  %call.i15 = tail call i32 @clusterSaveConfig(i32 noundef 1), !range !21
  %cmp.i = icmp eq i32 %call.i15, -1
  br i1 %cmp.i, label %do.body.i, label %return

do.body.i:                                        ; preds = %if.then49
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp1.i = icmp sgt i32 %17, 3
  br i1 %cmp1.i, label %do.end.i, label %if.end.i16

if.end.i16:                                       ; preds = %do.body.i
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef nonnull @.str.38) #33
  br label %do.end.i

do.end.i:                                         ; preds = %if.end.i16, %do.body.i
  tail call void @exit(i32 noundef 1) #35
  unreachable

return:                                           ; preds = %for.body, %if.then49, %for.end47, %if.end, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ 0, %if.end ], [ 0, %for.end47 ], [ 0, %if.then49 ], [ -1, %for.body ]
  ret i32 %retval.0
}

declare i64 @dbSize(ptr noundef, i32 noundef) local_unnamed_addr #1

declare ptr @sdscat(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @sdsIncrLen(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local ptr @representSlotInfo(ptr noundef %ci, ptr nocapture noundef readonly %slot_info_pairs, i32 noundef %slot_info_pairs_count) local_unnamed_addr #2 {
entry:
  %cmp10 = icmp sgt i32 %slot_info_pairs_count, 0
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %ci.addr.012 = phi ptr [ %ci.addr.1, %for.inc ], [ %ci, %entry ]
  %arrayidx = getelementptr inbounds i16, ptr %slot_info_pairs, i64 %indvars.iv
  %0 = load i16, ptr %arrayidx, align 2
  %conv = zext i16 %0 to i64
  %1 = or disjoint i64 %indvars.iv, 1
  %arrayidx2 = getelementptr inbounds i16, ptr %slot_info_pairs, i64 %1
  %2 = load i16, ptr %arrayidx2, align 2
  %cmp4 = icmp eq i16 %0, %2
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %call = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %ci.addr.012, ptr noundef nonnull @.str.146, i64 noundef %conv) #33
  br label %for.inc

if.else:                                          ; preds = %for.body
  %conv3 = zext i16 %2 to i64
  %call6 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %ci.addr.012, ptr noundef nonnull @.str.147, i64 noundef %conv, i64 noundef %conv3) #33
  br label %for.inc

for.inc:                                          ; preds = %if.then, %if.else
  %ci.addr.1 = phi ptr [ %call, %if.then ], [ %call6, %if.else ]
  %indvars.iv.next = add nuw i64 %indvars.iv, 2
  %3 = trunc i64 %indvars.iv.next to i32
  %cmp = icmp slt i32 %3, %slot_info_pairs_count
  br i1 %cmp, label %for.body, label %for.end, !llvm.loop !68

for.end:                                          ; preds = %for.inc, %entry
  %ci.addr.0.lcssa = phi ptr [ %ci, %entry ], [ %ci.addr.1, %for.inc ]
  ret ptr %ci.addr.0.lcssa
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterGenNodeDescription(ptr noundef readnone %c, ptr noundef %node, i32 noundef %tls_primary) local_unnamed_addr #2 {
entry:
  %tobool.not.i = icmp eq i32 %tls_primary, 0
  %tls_port.i = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 25
  %tcp_port.i = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 24
  %cond.in.i = select i1 %tobool.not.i, ptr %tcp_port.i, ptr %tls_port.i
  %cond.i = load i32, ptr %cond.in.i, align 4
  %call1 = tail call ptr @sdsempty() #33
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  %call2 = tail call ptr @sdscatlen(ptr noundef %call1, ptr noundef nonnull %name, i64 noundef 40) #33
  %ip = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 21
  %cport = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 26
  %0 = load i32, ptr %cport, align 8
  %call4 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call2, ptr noundef nonnull @.str.148, ptr noundef nonnull %ip, i32 noundef %cond.i, i32 noundef %0) #33
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 22
  %1 = load ptr, ptr %hostname, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %1, i64 -1
  %2 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %2 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %if.end [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %1, i64 -3
  %3 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %3 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %1, i64 -5
  %4 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %4 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %1, i64 -9
  %5 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %5 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %1, i64 -17
  %6 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %6, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %cmp.not = icmp eq i64 %retval.0.i, 0
  br i1 %cmp.not, label %if.end, label %if.then

if.then:                                          ; preds = %sdslen.exit
  %call7 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call4, ptr noundef nonnull @.str.149, ptr noundef nonnull %1) #33
  br label %if.end

if.end:                                           ; preds = %entry, %if.then, %sdslen.exit
  %ci.0 = phi ptr [ %call7, %if.then ], [ %call4, %sdslen.exit ], [ %call4, %entry ]
  %cmp8 = icmp eq ptr %c, null
  br i1 %cmp8, label %if.then9, label %if.end33

if.then9:                                         ; preds = %if.end
  %7 = load ptr, ptr %hostname, align 8
  %arrayidx.i80 = getelementptr inbounds i8, ptr %7, i64 -1
  %8 = load i8, ptr %arrayidx.i80, align 1
  %conv.i81 = zext i8 %8 to i32
  %and.i82 = and i32 %conv.i81, 7
  switch i32 %and.i82, label %if.then13 [
    i32 0, label %sw.bb.i95
    i32 1, label %sw.bb3.i92
    i32 2, label %sw.bb5.i89
    i32 3, label %sw.bb9.i86
    i32 4, label %sw.bb13.i83
  ]

sw.bb.i95:                                        ; preds = %if.then9
  %shr.i96 = lshr i32 %conv.i81, 3
  %conv2.i97 = zext nneg i32 %shr.i96 to i64
  br label %sdslen.exit98

sw.bb3.i92:                                       ; preds = %if.then9
  %add.ptr.i93 = getelementptr inbounds i8, ptr %7, i64 -3
  %9 = load i8, ptr %add.ptr.i93, align 1
  %conv4.i94 = zext i8 %9 to i64
  br label %sdslen.exit98

sw.bb5.i89:                                       ; preds = %if.then9
  %add.ptr6.i90 = getelementptr inbounds i8, ptr %7, i64 -5
  %10 = load i16, ptr %add.ptr6.i90, align 1
  %conv8.i91 = zext i16 %10 to i64
  br label %sdslen.exit98

sw.bb9.i86:                                       ; preds = %if.then9
  %add.ptr10.i87 = getelementptr inbounds i8, ptr %7, i64 -9
  %11 = load i32, ptr %add.ptr10.i87, align 1
  %conv12.i88 = zext i32 %11 to i64
  br label %sdslen.exit98

sw.bb13.i83:                                      ; preds = %if.then9
  %add.ptr14.i84 = getelementptr inbounds i8, ptr %7, i64 -17
  %12 = load i64, ptr %add.ptr14.i84, align 1
  br label %sdslen.exit98

sdslen.exit98:                                    ; preds = %sw.bb.i95, %sw.bb3.i92, %sw.bb5.i89, %sw.bb9.i86, %sw.bb13.i83
  %retval.0.i85 = phi i64 [ %12, %sw.bb13.i83 ], [ %conv12.i88, %sw.bb9.i86 ], [ %conv8.i91, %sw.bb5.i89 ], [ %conv4.i94, %sw.bb3.i92 ], [ %conv2.i97, %sw.bb.i95 ]
  %cmp12 = icmp eq i64 %retval.0.i85, 0
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.then9, %sdslen.exit98
  %call14 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %ci.0, ptr noundef nonnull @.str.14, i32 noundef 1) #33
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %sdslen.exit98
  %ci.1 = phi ptr [ %call14, %if.then13 ], [ %ci.0, %sdslen.exit98 ]
  %tobool = icmp ne i32 %tls_primary, 0
  br label %for.body

for.body:                                         ; preds = %if.end15, %for.inc
  %indvars.iv = phi i64 [ 3, %if.end15 ], [ %indvars.iv.next, %for.inc ]
  %ci.2107 = phi ptr [ %ci.1, %if.end15 ], [ %ci.3, %for.inc ]
  %cmp17 = icmp eq i64 %indvars.iv, 3
  %or.cond = and i1 %tobool, %cmp17
  %cmp20 = icmp eq i64 %indvars.iv, 2
  %or.cond1 = and i1 %tobool.not.i, %cmp20
  %or.cond105 = or i1 %or.cond, %or.cond1
  br i1 %or.cond105, label %for.inc, label %if.end22

if.end22:                                         ; preds = %for.body
  %isPresent = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %indvars.iv, i32 3
  %13 = load ptr, ptr %isPresent, align 8
  %call23 = tail call i32 %13(ptr noundef %node) #33
  %tobool24.not = icmp eq i32 %call23, 0
  br i1 %tobool24.not, label %for.inc, label %if.then25

if.then25:                                        ; preds = %if.end22
  %arrayidx = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %indvars.iv
  %14 = load ptr, ptr %arrayidx, align 16
  %call28 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %ci.2107, ptr noundef nonnull @.str.150, ptr noundef %14) #33
  %getter = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %indvars.iv, i32 2
  %15 = load ptr, ptr %getter, align 16
  %call31 = tail call ptr %15(ptr noundef %node, ptr noundef %call28) #33
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %if.then25, %for.body
  %ci.3 = phi ptr [ %ci.2107, %for.body ], [ %call31, %if.then25 ], [ %ci.2107, %if.end22 ]
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %cmp16.not = icmp eq i64 %indvars.iv, 0
  br i1 %cmp16.not, label %if.end33, label %for.body, !llvm.loop !69

if.end33:                                         ; preds = %for.inc, %if.end
  %ci.4 = phi ptr [ %ci.0, %if.end ], [ %ci.3, %for.inc ]
  %call34 = tail call ptr @sdscatlen(ptr noundef %ci.4, ptr noundef nonnull @.str.151, i64 noundef 1) #33
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %16 = load i32, ptr %flags, align 8
  %conv = trunc i32 %16 to i16
  %call35 = tail call ptr @representClusterNodeFlags(ptr noundef %call34, i16 noundef zeroext %conv)
  %call36 = tail call ptr @sdscatlen(ptr noundef %call35, ptr noundef nonnull @.str.151, i64 noundef 1) #33
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 11
  %17 = load ptr, ptr %slaveof, align 8
  %tobool37.not = icmp eq ptr %17, null
  br i1 %tobool37.not, label %if.else, label %if.then38

if.then38:                                        ; preds = %if.end33
  %name40 = getelementptr inbounds %struct._clusterNode, ptr %17, i64 0, i32 1
  %call42 = tail call ptr @sdscatlen(ptr noundef %call36, ptr noundef nonnull %name40, i64 noundef 40) #33
  br label %if.end44

if.else:                                          ; preds = %if.end33
  %call43 = tail call ptr @sdscatlen(ptr noundef %call36, ptr noundef nonnull @.str.152, i64 noundef 1) #33
  br label %if.end44

if.end44:                                         ; preds = %if.else, %if.then38
  %ci.5 = phi ptr [ %call42, %if.then38 ], [ %call43, %if.else ]
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 4
  %18 = load i64, ptr %configEpoch, align 8
  %19 = load i32, ptr %flags, align 8
  %and = and i32 %19, 2
  %tobool46.not = icmp eq i32 %and, 0
  br i1 %tobool46.not, label %if.end53, label %land.lhs.true47

land.lhs.true47:                                  ; preds = %if.end44
  %20 = load ptr, ptr %slaveof, align 8
  %tobool49.not = icmp eq ptr %20, null
  br i1 %tobool49.not, label %if.end53, label %if.then50

if.then50:                                        ; preds = %land.lhs.true47
  %configEpoch52 = getelementptr inbounds %struct._clusterNode, ptr %20, i64 0, i32 4
  %21 = load i64, ptr %configEpoch52, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.then50, %land.lhs.true47, %if.end44
  %nodeEpoch.0 = phi i64 [ %21, %if.then50 ], [ %18, %land.lhs.true47 ], [ %18, %if.end44 ]
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 13
  %22 = load i64, ptr %ping_sent, align 8
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 14
  %23 = load i64, ptr %pong_received, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 27
  %24 = load ptr, ptr %link, align 8
  %tobool54.not = icmp eq ptr %24, null
  %and56 = and i32 %19, 16
  %tobool57.not = icmp eq i32 %and56, 0
  %25 = and i1 %tobool57.not, %tobool54.not
  %cond = select i1 %25, ptr @.str.155, ptr @.str.154
  %call58 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %ci.5, ptr noundef nonnull @.str.153, i64 noundef %22, i64 noundef %23, i64 noundef %nodeEpoch.0, ptr noundef nonnull %cond) #33
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 6
  %26 = load ptr, ptr %slot_info_pairs, align 8
  %tobool59.not = icmp eq ptr %26, null
  br i1 %tobool59.not, label %if.else63, label %if.then60

if.then60:                                        ; preds = %if.end53
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 7
  %27 = load i32, ptr %slot_info_pairs_count, align 8
  %cmp10.i = icmp sgt i32 %27, 0
  br i1 %cmp10.i, label %for.body.i, label %if.end107

for.body.i:                                       ; preds = %if.then60, %for.inc.i
  %indvars.iv.i = phi i64 [ %indvars.iv.next.i, %for.inc.i ], [ 0, %if.then60 ]
  %ci.addr.012.i = phi ptr [ %ci.addr.1.i, %for.inc.i ], [ %call58, %if.then60 ]
  %arrayidx.i99 = getelementptr inbounds i16, ptr %26, i64 %indvars.iv.i
  %28 = load i16, ptr %arrayidx.i99, align 2
  %conv.i100 = zext i16 %28 to i64
  %29 = or disjoint i64 %indvars.iv.i, 1
  %arrayidx2.i = getelementptr inbounds i16, ptr %26, i64 %29
  %30 = load i16, ptr %arrayidx2.i, align 2
  %cmp4.i = icmp eq i16 %28, %30
  br i1 %cmp4.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %for.body.i
  %call.i = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %ci.addr.012.i, ptr noundef nonnull @.str.146, i64 noundef %conv.i100) #33
  br label %for.inc.i

if.else.i:                                        ; preds = %for.body.i
  %conv3.i = zext i16 %30 to i64
  %call6.i = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %ci.addr.012.i, ptr noundef nonnull @.str.147, i64 noundef %conv.i100, i64 noundef %conv3.i) #33
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.else.i, %if.then.i
  %ci.addr.1.i = phi ptr [ %call.i, %if.then.i ], [ %call6.i, %if.else.i ]
  %indvars.iv.next.i = add nuw i64 %indvars.iv.i, 2
  %31 = trunc i64 %indvars.iv.next.i to i32
  %cmp.i = icmp sgt i32 %27, %31
  br i1 %cmp.i, label %for.body.i, label %if.end107, !llvm.loop !68

if.else63:                                        ; preds = %if.end53
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 8
  %32 = load i32, ptr %numslots, align 4
  %cmp64 = icmp sgt i32 %32, 0
  br i1 %cmp64, label %for.cond67.preheader, label %if.end107

for.cond67.preheader:                             ; preds = %if.else63
  %slots.i = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 5
  br label %for.body70

for.body70:                                       ; preds = %for.cond67.preheader, %for.inc103
  %j.0111 = phi i32 [ 0, %for.cond67.preheader ], [ %inc104, %for.inc103 ]
  %start.0110 = phi i32 [ -1, %for.cond67.preheader ], [ %start.2, %for.inc103 ]
  %ci.6109 = phi ptr [ %call58, %for.cond67.preheader ], [ %ci.8, %for.inc103 ]
  %div.i.i = sdiv i32 %j.0111, 8
  %conv.i.i = sext i32 %div.i.i to i64
  %and.i.i = and i32 %j.0111, 7
  %arrayidx.i.i = getelementptr inbounds i8, ptr %slots.i, i64 %conv.i.i
  %33 = load i8, ptr %arrayidx.i.i, align 1
  %conv1.i.i = zext i8 %33 to i32
  %34 = lshr i32 %conv1.i.i, %and.i.i
  %conv3.i.i = and i32 %34, 1
  %cmp72 = icmp ne i32 %conv3.i.i, 0
  %cmp75 = icmp eq i32 %start.0110, -1
  %or.cond4 = and i1 %cmp75, %cmp72
  %spec.select = select i1 %or.cond4, i32 %j.0111, i32 %start.0110
  %cmp80.not = icmp eq i32 %spec.select, -1
  br i1 %cmp80.not, label %for.inc103, label %land.lhs.true82

land.lhs.true82:                                  ; preds = %for.body70
  %tobool83 = icmp eq i32 %conv3.i.i, 0
  %cmp85 = icmp eq i32 %j.0111, 16383
  %or.cond2 = or i1 %cmp85, %tobool83
  br i1 %or.cond2, label %if.then87, label %for.inc103

if.then87:                                        ; preds = %land.lhs.true82
  %or.cond3 = and i1 %cmp85, %cmp72
  %spec.select79 = select i1 %or.cond3, i32 16384, i32 %j.0111
  %sub = add nsw i32 %spec.select79, -1
  %cmp94 = icmp eq i32 %spec.select, %sub
  br i1 %cmp94, label %if.then96, label %if.else98

if.then96:                                        ; preds = %if.then87
  %call97 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %ci.6109, ptr noundef nonnull @.str.146, i32 noundef %spec.select) #33
  br label %for.inc103

if.else98:                                        ; preds = %if.then87
  %call100 = tail call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %ci.6109, ptr noundef nonnull @.str.147, i32 noundef %spec.select, i32 noundef %sub) #33
  br label %for.inc103

for.inc103:                                       ; preds = %if.then96, %if.else98, %for.body70, %land.lhs.true82
  %ci.8 = phi ptr [ %ci.6109, %land.lhs.true82 ], [ %ci.6109, %for.body70 ], [ %call97, %if.then96 ], [ %call100, %if.else98 ]
  %start.2 = phi i32 [ %spec.select, %land.lhs.true82 ], [ -1, %for.body70 ], [ -1, %if.then96 ], [ -1, %if.else98 ]
  %j.2 = phi i32 [ %j.0111, %land.lhs.true82 ], [ %j.0111, %for.body70 ], [ %spec.select79, %if.then96 ], [ %spec.select79, %if.else98 ]
  %inc104 = add nsw i32 %j.2, 1
  %cmp68 = icmp slt i32 %j.2, 16383
  br i1 %cmp68, label %for.body70, label %if.end107, !llvm.loop !70

if.end107:                                        ; preds = %for.inc.i, %for.inc103, %if.then60, %if.else63
  %ci.9 = phi ptr [ %call58, %if.else63 ], [ %call58, %if.then60 ], [ %ci.8, %for.inc103 ], [ %ci.addr.1.i, %for.inc.i ]
  %35 = load i32, ptr %flags, align 8
  %and109 = and i32 %35, 16
  %tobool110.not = icmp eq i32 %and109, 0
  br i1 %tobool110.not, label %if.end142, label %for.body115

for.body115:                                      ; preds = %if.end107, %for.inc139
  %indvars.iv116 = phi i64 [ %indvars.iv.next117, %for.inc139 ], [ 0, %if.end107 ]
  %ci.10112 = phi ptr [ %ci.11, %for.inc139 ], [ %ci.9, %if.end107 ]
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx117 = getelementptr inbounds %struct.clusterState, ptr %36, i64 0, i32 7, i64 %indvars.iv116
  %37 = load ptr, ptr %arrayidx117, align 8
  %tobool118.not = icmp eq ptr %37, null
  br i1 %tobool118.not, label %if.else126, label %for.inc139.sink.split

if.else126:                                       ; preds = %for.body115
  %arrayidx128 = getelementptr inbounds %struct.clusterState, ptr %36, i64 0, i32 8, i64 %indvars.iv116
  %38 = load ptr, ptr %arrayidx128, align 8
  %tobool129.not = icmp eq ptr %38, null
  br i1 %tobool129.not, label %for.inc139, label %for.inc139.sink.split

for.inc139.sink.split:                            ; preds = %if.else126, %for.body115
  %.sink = phi ptr [ %37, %for.body115 ], [ %38, %if.else126 ]
  %.str.156.sink = phi ptr [ @.str.156, %for.body115 ], [ @.str.157, %if.else126 ]
  %name123 = getelementptr inbounds %struct._clusterNode, ptr %.sink, i64 0, i32 1
  %39 = trunc i64 %indvars.iv116 to i32
  %call125 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %ci.10112, ptr noundef nonnull %.str.156.sink, i32 noundef %39, ptr noundef nonnull %name123) #33
  br label %for.inc139

for.inc139:                                       ; preds = %for.inc139.sink.split, %if.else126
  %ci.11 = phi ptr [ %ci.10112, %if.else126 ], [ %call125, %for.inc139.sink.split ]
  %indvars.iv.next117 = add nuw nsw i64 %indvars.iv116, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next117, 16384
  br i1 %exitcond.not, label %if.end142, label %for.body115, !llvm.loop !71

if.end142:                                        ; preds = %for.inc139, %if.end107
  %ci.12 = phi ptr [ %ci.9, %if.end107 ], [ %ci.11, %for.inc139 ]
  ret ptr %ci.12
}

declare ptr @sdscatlen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterGenNodesSlotsInfo(i32 noundef %filter) local_unnamed_addr #2 {
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %n.0 = phi ptr [ null, %entry ], [ %n.1, %for.inc ]
  %start.0 = phi i32 [ -1, %entry ], [ %start.1, %for.inc ]
  %cmp1 = icmp eq ptr %n.0, null
  %0 = trunc i64 %indvars.iv to i32
  %cmp2 = icmp eq i64 %indvars.iv, 16384
  br i1 %cmp1, label %if.then, label %if.end4

if.then:                                          ; preds = %for.body
  br i1 %cmp2, label %for.end, label %for.inc.sink.split

if.end4:                                          ; preds = %for.body
  br i1 %cmp2, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end4
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx8 = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 9, i64 %indvars.iv
  %2 = load ptr, ptr %arrayidx8, align 8
  %cmp9.not = icmp eq ptr %n.0, %2
  br i1 %cmp9.not, label %for.inc, label %if.then10

if.then10:                                        ; preds = %lor.lhs.false, %if.end4
  %flags = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 3
  %3 = load i32, ptr %flags, align 8
  %and = and i32 %3, %filter
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.then11, label %if.end35

if.then11:                                        ; preds = %if.then10
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 6
  %4 = load ptr, ptr %slot_info_pairs, align 8
  %tobool12.not = icmp eq ptr %4, null
  br i1 %tobool12.not, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.then11
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 8
  %5 = load i32, ptr %numslots, align 4
  %mul = shl nsw i32 %5, 1
  %conv = sext i32 %mul to i64
  %mul14 = shl nsw i64 %conv, 1
  %call = tail call noalias ptr @zmalloc(i64 noundef %mul14) #37
  store ptr %call, ptr %slot_info_pairs, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.then11
  %6 = phi ptr [ %call, %if.then13 ], [ %4, %if.then11 ]
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 7
  %7 = load i32, ptr %slot_info_pairs_count, align 8
  %add = add nsw i32 %7, 1
  %numslots17 = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 8
  %8 = load i32, ptr %numslots17, align 4
  %mul18 = shl nsw i32 %8, 1
  %cmp19 = icmp slt i32 %add, %mul18
  br i1 %cmp19, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end16
  tail call void @_serverAssert(ptr noundef nonnull @.str.158, ptr noundef nonnull @.str.18, i32 noundef 5288) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %if.end16
  %conv24 = trunc i32 %start.0 to i16
  store i32 %add, ptr %slot_info_pairs_count, align 8
  %idxprom27 = sext i32 %7 to i64
  %arrayidx28 = getelementptr inbounds i16, ptr %6, i64 %idxprom27
  store i16 %conv24, ptr %arrayidx28, align 2
  %9 = trunc i64 %indvars.iv to i16
  %conv29 = add nsw i16 %9, -1
  %10 = load ptr, ptr %slot_info_pairs, align 8
  %11 = load i32, ptr %slot_info_pairs_count, align 8
  %inc32 = add nsw i32 %11, 1
  store i32 %inc32, ptr %slot_info_pairs_count, align 8
  %idxprom33 = sext i32 %11 to i64
  %arrayidx34 = getelementptr inbounds i16, ptr %10, i64 %idxprom33
  store i16 %conv29, ptr %arrayidx34, align 2
  br label %if.end35

if.end35:                                         ; preds = %cond.end, %if.then10
  br i1 %cmp2, label %for.end, label %for.inc.sink.split

for.inc.sink.split:                               ; preds = %if.end35, %if.then
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx42 = getelementptr inbounds %struct.clusterState, ptr %12, i64 0, i32 9, i64 %indvars.iv
  %13 = load ptr, ptr %arrayidx42, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.inc.sink.split, %lor.lhs.false
  %n.1 = phi ptr [ %n.0, %lor.lhs.false ], [ %13, %for.inc.sink.split ]
  %start.1 = phi i32 [ %start.0, %lor.lhs.false ], [ %0, %for.inc.sink.split ]
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %for.body, !llvm.loop !72

for.end:                                          ; preds = %if.end35, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterFreeNodesSlotsInfo(ptr nocapture noundef %n) local_unnamed_addr #2 {
entry:
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 6
  %0 = load ptr, ptr %slot_info_pairs, align 8
  tail call void @zfree(ptr noundef %0) #33
  store ptr null, ptr %slot_info_pairs, align 8
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 7
  store i32 0, ptr %slot_info_pairs_count, align 8
  ret void
}

declare ptr @sdscatsds(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @addReplyClusterLinkDescription(ptr noundef %c, ptr nocapture noundef readonly %link) local_unnamed_addr #2 {
entry:
  %events = alloca [3 x i8], align 1
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 6) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.160) #33
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 9
  %0 = load i32, ptr %inbound, align 8
  %tobool.not = icmp eq i32 %0, 0
  %cond = select i1 %tobool.not, ptr @.str.162, ptr @.str.161
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull %cond) #33
  %node = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 8
  %1 = load ptr, ptr %node, align 8
  %tobool1.not = icmp eq ptr %1, null
  br i1 %tobool1.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.163, ptr noundef nonnull @.str.18, i32 noundef 5356) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %name = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 1
  %call = tail call ptr @sdsnewlen(ptr noundef nonnull %name, i64 noundef 40) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.164) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %call) #33
  tail call void @sdsfree(ptr noundef %call) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.165) #33
  %2 = load i64, ptr %link, align 8
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %2) #33
  %conn = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 1
  %3 = load ptr, ptr %conn, align 8
  %tobool6.not = icmp eq ptr %3, null
  br i1 %tobool6.not, label %if.end17, label %if.then

if.then:                                          ; preds = %cond.end
  %4 = getelementptr i8, ptr %3, i64 56
  %.val = load ptr, ptr %4, align 8
  %cmp.i.not = icmp eq ptr %.val, null
  br i1 %cmp.i.not, label %if.end, label %if.then10

if.then10:                                        ; preds = %if.then
  %incdec.ptr = getelementptr inbounds i8, ptr %events, i64 1
  store i8 114, ptr %events, align 1
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %p.0 = phi ptr [ %incdec.ptr, %if.then10 ], [ %events, %if.then ]
  %5 = getelementptr i8, ptr %3, i64 48
  %.val25 = load ptr, ptr %5, align 8
  %cmp.i26.not = icmp eq ptr %.val25, null
  br i1 %cmp.i26.not, label %if.end17, label %if.then14

if.then14:                                        ; preds = %if.end
  %incdec.ptr15 = getelementptr inbounds i8, ptr %p.0, i64 1
  store i8 119, ptr %p.0, align 1
  br label %if.end17

if.end17:                                         ; preds = %if.end, %if.then14, %cond.end
  %p.1 = phi ptr [ %incdec.ptr15, %if.then14 ], [ %p.0, %if.end ], [ %events, %cond.end ]
  store i8 0, ptr %p.1, align 1
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.166) #33
  call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull %events) #33
  call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.167) #33
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %link, i64 0, i32 4
  %6 = load i64, ptr %send_msg_queue_mem, align 8
  call void @addReplyLongLong(ptr noundef %c, i64 noundef %6) #33
  call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.168) #33
  %7 = load i64, ptr %send_msg_queue_mem, align 8
  call void @addReplyLongLong(ptr noundef %c, i64 noundef %7) #33
  ret void
}

declare void @addReplyMapLen(ptr noundef, i64 noundef) local_unnamed_addr #1

declare void @addReplyBulkCString(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @addReplyLongLong(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @addReplyClusterLinksDescription(ptr noundef %c) local_unnamed_addr #2 {
entry:
  %call = tail call ptr @addReplyDeferredLen(ptr noundef %c) #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call1 = tail call ptr @dictGetSafeIterator(ptr noundef %1) #33
  %call211 = tail call ptr @dictNext(ptr noundef %call1) #33
  %cmp.not12 = icmp eq ptr %call211, null
  br i1 %cmp.not12, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end9
  %call214 = phi ptr [ %call2, %if.end9 ], [ %call211, %entry ]
  %num_links.013 = phi i32 [ %num_links.2, %if.end9 ], [ 0, %entry ]
  %call3 = tail call ptr @dictGetVal(ptr noundef nonnull %call214) #33
  %link = getelementptr inbounds %struct._clusterNode, ptr %call3, i64 0, i32 27
  %2 = load ptr, ptr %link, align 8
  %tobool.not = icmp eq ptr %2, null
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %inc = add nsw i32 %num_links.013, 1
  tail call void @addReplyClusterLinkDescription(ptr noundef %c, ptr noundef nonnull %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %num_links.1 = phi i32 [ %inc, %if.then ], [ %num_links.013, %while.body ]
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %call3, i64 0, i32 28
  %3 = load ptr, ptr %inbound_link, align 8
  %tobool5.not = icmp eq ptr %3, null
  br i1 %tobool5.not, label %if.end9, label %if.then6

if.then6:                                         ; preds = %if.end
  %inc7 = add nsw i32 %num_links.1, 1
  tail call void @addReplyClusterLinkDescription(ptr noundef %c, ptr noundef nonnull %3)
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %if.end
  %num_links.2 = phi i32 [ %inc7, %if.then6 ], [ %num_links.1, %if.end ]
  %call2 = tail call ptr @dictNext(ptr noundef %call1) #33
  %cmp.not = icmp eq ptr %call2, null
  br i1 %cmp.not, label %while.end.loopexit, label %while.body, !llvm.loop !73

while.end.loopexit:                               ; preds = %if.end9
  %4 = sext i32 %num_links.2 to i64
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %entry
  %num_links.0.lcssa = phi i64 [ 0, %entry ], [ %4, %while.end.loopexit ]
  tail call void @dictReleaseIterator(ptr noundef %call1) #33
  tail call void @setDeferredArrayLen(ptr noundef %c, ptr noundef %call, i64 noundef %num_links.0.lcssa) #33
  ret void
}

declare ptr @addReplyDeferredLen(ptr noundef) local_unnamed_addr #1

declare void @setDeferredArrayLen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @getSlotOrReply(ptr noundef %c, ptr noundef %o) local_unnamed_addr #2 {
entry:
  %slot = alloca i64, align 8
  %call = call i32 @getLongLongFromObject(ptr noundef %o, ptr noundef nonnull %slot) #33
  %cmp = icmp ne i32 %call, 0
  %0 = load i64, ptr %slot, align 8
  %cmp1 = icmp slt i64 %0, 0
  %or.cond = select i1 %cmp, i1 true, i1 %cmp1
  %cmp3 = icmp sgt i64 %0, 16383
  %or.cond1 = select i1 %or.cond, i1 true, i1 %cmp3
  br i1 %or.cond1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @addReplyError(ptr noundef %c, ptr noundef nonnull @.str.180) #33
  br label %return

if.end:                                           ; preds = %entry
  %conv = trunc i64 %0 to i32
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -1, %if.then ], [ %conv, %if.end ]
  ret i32 %retval.0
}

declare i32 @getLongLongFromObject(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @addReplyError(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local i32 @checkSlotAssignmentsOrReply(ptr noundef %c, ptr nocapture noundef %slots, i32 noundef %del, i32 noundef %start_slot, i32 noundef %end_slot) local_unnamed_addr #2 {
entry:
  %cmp.not14 = icmp sgt i32 %start_slot, %end_slot
  br i1 %cmp.not14, label %return, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %entry
  %tobool.not = icmp eq i32 %del, 0
  %0 = sext i32 %start_slot to i64
  %1 = add i32 %end_slot, 1
  br i1 %tobool.not, label %for.body.us, label %for.body

for.body.us:                                      ; preds = %for.body.lr.ph, %for.inc.us
  %indvars.iv24 = phi i64 [ %indvars.iv.next25, %for.inc.us ], [ %0, %for.body.lr.ph ]
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx7.us = getelementptr inbounds %struct.clusterState, ptr %2, i64 0, i32 9, i64 %indvars.iv24
  %3 = load ptr, ptr %arrayidx7.us, align 8
  %tobool8.not.us = icmp eq ptr %3, null
  br i1 %tobool8.not.us, label %if.end10.us, label %return.sink.split

if.end10.us:                                      ; preds = %for.body.us
  %arrayidx12.us = getelementptr inbounds i8, ptr %slots, i64 %indvars.iv24
  %4 = load i8, ptr %arrayidx12.us, align 1
  %inc.us = add i8 %4, 1
  store i8 %inc.us, ptr %arrayidx12.us, align 1
  %cmp13.us = icmp eq i8 %4, 1
  br i1 %cmp13.us, label %return.sink.split, label %for.inc.us

for.inc.us:                                       ; preds = %if.end10.us
  %indvars.iv.next25 = add nsw i64 %indvars.iv24, 1
  %lftr.wideiv27 = trunc i64 %indvars.iv.next25 to i32
  %exitcond28.not = icmp eq i32 %1, %lftr.wideiv27
  br i1 %exitcond28.not, label %return, label %for.body.us, !llvm.loop !74

for.body:                                         ; preds = %for.body.lr.ph, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ %0, %for.body.lr.ph ]
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 9, i64 %indvars.iv
  %6 = load ptr, ptr %arrayidx, align 8
  %cmp2 = icmp eq ptr %6, null
  br i1 %cmp2, label %return.sink.split, label %if.end10

if.end10:                                         ; preds = %for.body
  %arrayidx12 = getelementptr inbounds i8, ptr %slots, i64 %indvars.iv
  %7 = load i8, ptr %arrayidx12, align 1
  %inc = add i8 %7, 1
  store i8 %inc, ptr %arrayidx12, align 1
  %cmp13 = icmp eq i8 %7, 1
  br i1 %cmp13, label %return.sink.split, label %for.inc

for.inc:                                          ; preds = %if.end10
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv.next to i32
  %exitcond.not = icmp eq i32 %1, %lftr.wideiv
  br i1 %exitcond.not, label %return, label %for.body, !llvm.loop !74

return.sink.split:                                ; preds = %if.end10, %for.body, %if.end10.us, %for.body.us
  %.us-phi16.in.sink = phi i64 [ %indvars.iv24, %for.body.us ], [ %indvars.iv24, %if.end10.us ], [ %indvars.iv, %for.body ], [ %indvars.iv, %if.end10 ]
  %.str.183.sink = phi ptr [ @.str.183, %if.end10.us ], [ @.str.182, %for.body.us ], [ @.str.183, %if.end10 ], [ @.str.181, %for.body ]
  %.us-phi16 = trunc i64 %.us-phi16.in.sink to i32
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %c, ptr noundef nonnull %.str.183.sink, i32 noundef %.us-phi16) #33
  br label %return

return:                                           ; preds = %for.inc, %for.inc.us, %return.sink.split, %entry
  %retval.0 = phi i32 [ 0, %entry ], [ -1, %return.sink.split ], [ 0, %for.inc.us ], [ 0, %for.inc ]
  ret i32 %retval.0
}

declare void @addReplyErrorFormat(ptr noundef, ptr noundef, ...) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateSlots(ptr noundef %c, ptr nocapture noundef readonly %slots, i32 noundef %del) local_unnamed_addr #2 {
entry:
  %tobool8.not = icmp eq i32 %del, 0
  br i1 %tobool8.not, label %for.body.us, label %for.body

for.body.us:                                      ; preds = %entry, %for.inc.us
  %indvars.iv21 = phi i64 [ %indvars.iv.next22, %for.inc.us ], [ 0, %entry ]
  %arrayidx.us = getelementptr inbounds i8, ptr %slots, i64 %indvars.iv21
  %0 = load i8, ptr %arrayidx.us, align 1
  %tobool.not.us = icmp eq i8 %0, 0
  br i1 %tobool.not.us, label %for.inc.us, label %if.then.us

if.then.us:                                       ; preds = %for.body.us
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx2.us = getelementptr inbounds %struct.clusterState, ptr %1, i64 0, i32 8, i64 %indvars.iv21
  %2 = load ptr, ptr %arrayidx2.us, align 8
  %tobool3.not.us = icmp eq ptr %2, null
  br i1 %tobool3.not.us, label %if.end.us, label %if.then4.us

if.then4.us:                                      ; preds = %if.then.us
  store ptr null, ptr %arrayidx2.us, align 8
  %.pre25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end.us

if.end.us:                                        ; preds = %if.then4.us, %if.then.us
  %3 = phi ptr [ %.pre25, %if.then4.us ], [ %1, %if.then.us ]
  %arrayidx.i8.us = getelementptr inbounds %struct.clusterState, ptr %3, i64 0, i32 9, i64 %indvars.iv21
  %4 = load ptr, ptr %arrayidx.i8.us, align 8
  %tobool.not.i9.us = icmp eq ptr %4, null
  br i1 %tobool.not.i9.us, label %if.end.i11.us, label %cond.false14

if.end.i11.us:                                    ; preds = %if.end.us
  %5 = load ptr, ptr @myself, align 8
  %6 = trunc i64 %indvars.iv21 to i32
  %call.i.us = tail call i32 @clusterNodeSetSlotBit(ptr noundef %5, i32 noundef %6), !range !18
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx3.i.us = getelementptr inbounds %struct.clusterState, ptr %7, i64 0, i32 9, i64 %indvars.iv21
  store ptr %5, ptr %arrayidx3.i.us, align 8
  br label %for.inc.us

for.inc.us:                                       ; preds = %if.end.i11.us, %for.body.us
  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
  %exitcond24.not = icmp eq i64 %indvars.iv.next22, 16384
  br i1 %exitcond24.not, label %for.end, label %for.body.us, !llvm.loop !75

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %entry ]
  %arrayidx = getelementptr inbounds i8, ptr %slots, i64 %indvars.iv
  %8 = load i8, ptr %arrayidx, align 1
  %tobool.not = icmp eq i8 %8, 0
  br i1 %tobool.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx2 = getelementptr inbounds %struct.clusterState, ptr %9, i64 0, i32 8, i64 %indvars.iv
  %10 = load ptr, ptr %arrayidx2, align 8
  %tobool3.not = icmp eq ptr %10, null
  br i1 %tobool3.not, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  store ptr null, ptr %arrayidx2, align 8
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %11 = phi ptr [ %.pre, %if.then4 ], [ %9, %if.then ]
  %arrayidx.i = getelementptr inbounds %struct.clusterState, ptr %11, i64 0, i32 9, i64 %indvars.iv
  %12 = load ptr, ptr %arrayidx.i, align 8
  %tobool.not.i = icmp eq ptr %12, null
  br i1 %tobool.not.i, label %cond.false14, label %if.end.i

if.end.i:                                         ; preds = %if.end
  %13 = trunc i64 %indvars.iv to i32
  tail call void @removeChannelsInSlot(i32 noundef %13)
  %slots.i.i = getelementptr inbounds %struct._clusterNode, ptr %12, i64 0, i32 5
  %div.i.i.i141516 = lshr i64 %indvars.iv, 3
  %conv.i.i.i = and i64 %div.i.i.i141516, 536870911
  %and.i.i.i = and i32 %13, 7
  %arrayidx.i.i.i = getelementptr inbounds i8, ptr %slots.i.i, i64 %conv.i.i.i
  %14 = load i8, ptr %arrayidx.i.i.i, align 1
  %conv1.i.i.i = zext i8 %14 to i32
  %15 = shl nuw nsw i32 1, %and.i.i.i
  %16 = and i32 %15, %conv1.i.i.i
  %tobool.not.i.i = icmp eq i32 %16, 0
  br i1 %tobool.not.i.i, label %cond.false.i, label %cond.end.i

cond.false.i:                                     ; preds = %if.end.i
  tail call void @_serverAssert(ptr noundef nonnull @.str.138, ptr noundef nonnull @.str.18, i32 noundef 4866) #33
  tail call void @abort() #35
  unreachable

cond.end.i:                                       ; preds = %if.end.i
  %17 = trunc i32 %15 to i8
  %18 = xor i8 %17, -1
  %conv3.i9.i.i = and i8 %14, %18
  store i8 %conv3.i9.i.i, ptr %arrayidx.i.i.i, align 1
  %numslots.i.i = getelementptr inbounds %struct._clusterNode, ptr %12, i64 0, i32 8
  %19 = load i32, ptr %numslots.i.i, align 4
  %dec.i.i = add nsw i32 %19, -1
  store i32 %dec.i.i, ptr %numslots.i.i, align 4
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5.i = getelementptr inbounds %struct.clusterState, ptr %20, i64 0, i32 9, i64 %indvars.iv
  store ptr null, ptr %arrayidx5.i, align 8
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot.i = getelementptr inbounds %struct.clusterState, ptr %21, i64 0, i32 27
  %arrayidx.i.i = getelementptr inbounds i8, ptr %owner_not_claiming_slot.i, i64 %conv.i.i.i
  %22 = load i8, ptr %arrayidx.i.i, align 1
  %conv3.i.i = and i8 %22, %18
  store i8 %conv3.i.i, ptr %arrayidx.i.i, align 1
  br label %for.inc

cond.false14:                                     ; preds = %if.end, %if.end.us
  tail call void @_serverAssertWithInfo(ptr noundef %c, ptr noundef null, ptr noundef nonnull @.str.184, ptr noundef nonnull @.str.18, i32 noundef 5473) #33
  tail call void @abort() #35
  unreachable

for.inc:                                          ; preds = %cond.end.i, %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !75

for.end:                                          ; preds = %for.inc, %for.inc.us
  ret void
}

declare void @_serverAssertWithInfo(ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @addNodeDetailsToShardReply(ptr noundef %c, ptr noundef %node) local_unnamed_addr #2 {
entry:
  %call = tail call ptr @addReplyDeferredLen(ptr noundef %c) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.185) #33
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %name, i64 noundef 40) #33
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 24
  %0 = load i32, ptr %tcp_port, align 8
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.186) #33
  %1 = load i32, ptr %tcp_port, align 8
  %conv = sext i32 %1 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv) #33
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %reply_count.0 = phi i32 [ 2, %if.then ], [ 1, %entry ]
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 25
  %2 = load i32, ptr %tls_port, align 4
  %tobool3.not = icmp eq i32 %2, 0
  br i1 %tobool3.not, label %if.end8, label %if.then4

if.then4:                                         ; preds = %if.end
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.3) #33
  %3 = load i32, ptr %tls_port, align 4
  %conv6 = sext i32 %3 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv6) #33
  %inc7 = add nuw nsw i32 %reply_count.0, 1
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %reply_count.1 = phi i32 [ %inc7, %if.then4 ], [ %reply_count.0, %if.end ]
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.187) #33
  %ip = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 21
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull %ip) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.188) #33
  %hostname.i.i = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 22
  %4 = load ptr, ptr %hostname.i.i, align 8
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 376), align 8
  switch i32 %5, label %sw.epilog.i [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb2.i
    i32 2, label %clusterNodePreferredEndpoint.exit
  ]

sw.bb.i:                                          ; preds = %if.end8
  br label %clusterNodePreferredEndpoint.exit

sw.bb2.i:                                         ; preds = %if.end8
  %cmp.not.i = icmp eq ptr %4, null
  br i1 %cmp.not.i, label %clusterNodePreferredEndpoint.exit, label %land.lhs.true.i

land.lhs.true.i:                                  ; preds = %sw.bb2.i
  %6 = load i8, ptr %4, align 1
  %cmp3.not.i = icmp eq i8 %6, 0
  %spec.select.i = select i1 %cmp3.not.i, ptr @.str.303, ptr %4
  br label %clusterNodePreferredEndpoint.exit

sw.epilog.i:                                      ; preds = %if.end8
  br label %clusterNodePreferredEndpoint.exit

clusterNodePreferredEndpoint.exit:                ; preds = %if.end8, %sw.bb.i, %sw.bb2.i, %land.lhs.true.i, %sw.epilog.i
  %retval.0.i = phi ptr [ @.str.179, %sw.epilog.i ], [ %ip, %sw.bb.i ], [ @.str.303, %sw.bb2.i ], [ %spec.select.i, %land.lhs.true.i ], [ @.str.304, %if.end8 ]
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef %retval.0.i) #33
  %inc12 = add nuw nsw i32 %reply_count.1, 2
  %7 = load ptr, ptr %hostname.i.i, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %7, i64 -1
  %8 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %8 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %if.end20 [
    i32 0, label %sw.bb.i46
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i46:                                        ; preds = %clusterNodePreferredEndpoint.exit
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %clusterNodePreferredEndpoint.exit
  %add.ptr.i = getelementptr inbounds i8, ptr %7, i64 -3
  %9 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %9 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %clusterNodePreferredEndpoint.exit
  %add.ptr6.i = getelementptr inbounds i8, ptr %7, i64 -5
  %10 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %10 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %clusterNodePreferredEndpoint.exit
  %add.ptr10.i = getelementptr inbounds i8, ptr %7, i64 -9
  %11 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %11 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %clusterNodePreferredEndpoint.exit
  %add.ptr14.i = getelementptr inbounds i8, ptr %7, i64 -17
  %12 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i46, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i45 = phi i64 [ %12, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i46 ]
  %cmp.not = icmp eq i64 %retval.0.i45, 0
  br i1 %cmp.not, label %if.end20, label %if.then15

if.then15:                                        ; preds = %sdslen.exit
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.189) #33
  %13 = load ptr, ptr %hostname.i.i, align 8
  %arrayidx.i47 = getelementptr inbounds i8, ptr %13, i64 -1
  %14 = load i8, ptr %arrayidx.i47, align 1
  %conv.i48 = zext i8 %14 to i32
  %and.i49 = and i32 %conv.i48, 7
  switch i32 %and.i49, label %sdslen.exit65 [
    i32 0, label %sw.bb.i62
    i32 1, label %sw.bb3.i59
    i32 2, label %sw.bb5.i56
    i32 3, label %sw.bb9.i53
    i32 4, label %sw.bb13.i50
  ]

sw.bb.i62:                                        ; preds = %if.then15
  %shr.i63 = lshr i32 %conv.i48, 3
  %conv2.i64 = zext nneg i32 %shr.i63 to i64
  br label %sdslen.exit65

sw.bb3.i59:                                       ; preds = %if.then15
  %add.ptr.i60 = getelementptr inbounds i8, ptr %13, i64 -3
  %15 = load i8, ptr %add.ptr.i60, align 1
  %conv4.i61 = zext i8 %15 to i64
  br label %sdslen.exit65

sw.bb5.i56:                                       ; preds = %if.then15
  %add.ptr6.i57 = getelementptr inbounds i8, ptr %13, i64 -5
  %16 = load i16, ptr %add.ptr6.i57, align 1
  %conv8.i58 = zext i16 %16 to i64
  br label %sdslen.exit65

sw.bb9.i53:                                       ; preds = %if.then15
  %add.ptr10.i54 = getelementptr inbounds i8, ptr %13, i64 -9
  %17 = load i32, ptr %add.ptr10.i54, align 1
  %conv12.i55 = zext i32 %17 to i64
  br label %sdslen.exit65

sw.bb13.i50:                                      ; preds = %if.then15
  %add.ptr14.i51 = getelementptr inbounds i8, ptr %13, i64 -17
  %18 = load i64, ptr %add.ptr14.i51, align 1
  br label %sdslen.exit65

sdslen.exit65:                                    ; preds = %if.then15, %sw.bb.i62, %sw.bb3.i59, %sw.bb5.i56, %sw.bb9.i53, %sw.bb13.i50
  %retval.0.i52 = phi i64 [ %18, %sw.bb13.i50 ], [ %conv12.i55, %sw.bb9.i53 ], [ %conv8.i58, %sw.bb5.i56 ], [ %conv4.i61, %sw.bb3.i59 ], [ %conv2.i64, %sw.bb.i62 ], [ 0, %if.then15 ]
  tail call void @addReplyBulkCBuffer(ptr noundef %c, ptr noundef nonnull %13, i64 noundef %retval.0.i52) #33
  %inc19 = add nuw nsw i32 %reply_count.1, 3
  br label %if.end20

if.end20:                                         ; preds = %clusterNodePreferredEndpoint.exit, %sdslen.exit65, %sdslen.exit
  %reply_count.2 = phi i32 [ %inc19, %sdslen.exit65 ], [ %inc12, %sdslen.exit ], [ %inc12, %clusterNodePreferredEndpoint.exit ]
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %19 = load i32, ptr %flags, align 8
  %and = and i32 %19, 16
  %tobool21.not = icmp eq i32 %and, 0
  br i1 %tobool21.not, label %if.else, label %if.then22

if.then22:                                        ; preds = %if.end20
  %and24 = and i32 %19, 2
  %tobool25.not = icmp eq i32 %and24, 0
  br i1 %tobool25.not, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then22
  %call26 = tail call i64 @replicationGetSlaveOffset() #33
  br label %if.end27

cond.false:                                       ; preds = %if.then22
  %20 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 262), align 8
  br label %if.end27

if.else:                                          ; preds = %if.end20
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 20
  %21 = load i64, ptr %repl_offset, align 8
  br label %if.end27

if.end27:                                         ; preds = %cond.true, %cond.false, %if.else
  %node_offset.0 = phi i64 [ %21, %if.else ], [ %call26, %cond.true ], [ %20, %cond.false ]
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.190) #33
  %22 = load i32, ptr %flags, align 8
  %and29 = and i32 %22, 2
  %tobool30.not = icmp eq i32 %and29, 0
  %cond31 = select i1 %tobool30.not, ptr @.str.19, ptr @.str.68
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull %cond31) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.191) #33
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %node_offset.0) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.192) #33
  %23 = load i32, ptr %flags, align 8
  %and35 = and i32 %23, 8
  %tobool36.not = icmp eq i32 %and35, 0
  br i1 %tobool36.not, label %if.else38, label %if.end47

if.else38:                                        ; preds = %if.end27
  %and40 = and i32 %23, 2
  %tobool41 = icmp ne i32 %and40, 0
  %cmp42 = icmp eq i64 %node_offset.0, 0
  %or.cond = select i1 %tobool41, i1 %cmp42, i1 false
  %.str.193..str.194 = select i1 %or.cond, ptr @.str.193, ptr @.str.194
  br label %if.end47

if.end47:                                         ; preds = %if.else38, %if.end27
  %health_msg.0 = phi ptr [ @.str.22, %if.end27 ], [ %.str.193..str.194, %if.else38 ]
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull %health_msg.0) #33
  %inc48 = add nuw nsw i32 %reply_count.2, 3
  %conv49 = zext nneg i32 %inc48 to i64
  tail call void @setDeferredMapLen(ptr noundef %c, ptr noundef %call, i64 noundef %conv49) #33
  ret void
}

declare void @addReplyBulkCBuffer(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @clusterNodePreferredEndpoint(ptr noundef readonly %n) local_unnamed_addr #0 {
entry:
  %hostname.i = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 22
  %0 = load ptr, ptr %hostname.i, align 8
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 376), align 8
  switch i32 %1, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb2
    i32 2, label %return
  ]

sw.bb:                                            ; preds = %entry
  %ip.i = getelementptr inbounds %struct._clusterNode, ptr %n, i64 0, i32 21
  br label %return

sw.bb2:                                           ; preds = %entry
  %cmp.not = icmp eq ptr %0, null
  br i1 %cmp.not, label %return, label %land.lhs.true

land.lhs.true:                                    ; preds = %sw.bb2
  %2 = load i8, ptr %0, align 1
  %cmp3.not = icmp eq i8 %2, 0
  %spec.select = select i1 %cmp3.not, ptr @.str.303, ptr %0
  br label %return

sw.epilog:                                        ; preds = %entry
  br label %return

return:                                           ; preds = %entry, %sw.bb2, %land.lhs.true, %sw.epilog, %sw.bb
  %retval.0 = phi ptr [ @.str.179, %sw.epilog ], [ %ip.i, %sw.bb ], [ @.str.303, %sw.bb2 ], [ %spec.select, %land.lhs.true ], [ @.str.304, %entry ]
  ret ptr %retval.0
}

declare void @setDeferredMapLen(ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @addShardReplyForClusterShards(ptr noundef %c, ptr noundef %nodes) local_unnamed_addr #2 {
entry:
  %li = alloca %struct.listIter, align 8
  %len = getelementptr inbounds %struct.list, ptr %nodes, i64 0, i32 5
  %0 = load i64, ptr %len, align 8
  %cmp.not = icmp eq i64 %0, 0
  br i1 %cmp.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %entry
  tail call void @_serverAssert(ptr noundef nonnull @.str.195, ptr noundef nonnull @.str.18, i32 noundef 5544) #33
  tail call void @abort() #35
  unreachable

cond.end:                                         ; preds = %entry
  %1 = load ptr, ptr %nodes, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %value, align 8
  tail call void @addReplyMapLen(ptr noundef %c, i64 noundef 2) #33
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.196) #33
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %cond.end
  %n.0 = phi ptr [ %2, %cond.end ], [ %3, %while.cond ]
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 11
  %3 = load ptr, ptr %slaveof, align 8
  %cmp2.not = icmp eq ptr %3, null
  br i1 %cmp2.not, label %while.end, label %while.cond, !llvm.loop !76

while.end:                                        ; preds = %while.cond
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 6
  %4 = load ptr, ptr %slot_info_pairs, align 8
  %cmp5.not = icmp eq ptr %4, null
  br i1 %cmp5.not, label %if.else, label %if.then

if.then:                                          ; preds = %while.end
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %n.0, i64 0, i32 7
  %5 = load i32, ptr %slot_info_pairs_count, align 8
  %6 = and i32 %5, 1
  %cmp7 = icmp eq i32 %6, 0
  br i1 %cmp7, label %cond.end17, label %cond.false16

cond.false16:                                     ; preds = %if.then
  tail call void @_serverAssert(ptr noundef nonnull @.str.197, ptr noundef nonnull @.str.18, i32 noundef 5553) #33
  tail call void @abort() #35
  unreachable

cond.end17:                                       ; preds = %if.then
  %conv19 = sext i32 %5 to i64
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef %conv19) #33
  %7 = load i32, ptr %slot_info_pairs_count, align 8
  %cmp2121 = icmp sgt i32 %7, 0
  br i1 %cmp2121, label %for.body, label %if.end

for.body:                                         ; preds = %cond.end17, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %cond.end17 ]
  %8 = load ptr, ptr %slot_info_pairs, align 8
  %arrayidx = getelementptr inbounds i16, ptr %8, i64 %indvars.iv
  %9 = load i16, ptr %arrayidx, align 2
  %conv24 = zext i16 %9 to i64
  tail call void @addReplyLongLong(ptr noundef %c, i64 noundef %conv24) #33
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %10 = load i32, ptr %slot_info_pairs_count, align 8
  %11 = sext i32 %10 to i64
  %cmp21 = icmp slt i64 %indvars.iv.next, %11
  br i1 %cmp21, label %for.body, label %if.end, !llvm.loop !77

if.else:                                          ; preds = %while.end
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef 0) #33
  br label %if.end

if.end:                                           ; preds = %for.body, %cond.end17, %if.else
  tail call void @addReplyBulkCString(ptr noundef %c, ptr noundef nonnull @.str.198) #33
  %12 = load i64, ptr %len, align 8
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef %12) #33
  call void @listRewind(ptr noundef nonnull %nodes, ptr noundef nonnull %li) #33
  %call = call ptr @listNext(ptr noundef nonnull %li) #33
  %cmp27.not23 = icmp eq ptr %call, null
  br i1 %cmp27.not23, label %for.end34, label %for.body29

for.body29:                                       ; preds = %if.end, %for.body29
  %ln.024 = phi ptr [ %call33, %for.body29 ], [ %call, %if.end ]
  %value31 = getelementptr inbounds %struct.listNode, ptr %ln.024, i64 0, i32 2
  %13 = load ptr, ptr %value31, align 8
  call void @addNodeDetailsToShardReply(ptr noundef %c, ptr noundef %13)
  %slot_info_pairs.i = getelementptr inbounds %struct._clusterNode, ptr %13, i64 0, i32 6
  %14 = load ptr, ptr %slot_info_pairs.i, align 8
  call void @zfree(ptr noundef %14) #33
  store ptr null, ptr %slot_info_pairs.i, align 8
  %slot_info_pairs_count.i = getelementptr inbounds %struct._clusterNode, ptr %13, i64 0, i32 7
  store i32 0, ptr %slot_info_pairs_count.i, align 8
  %call33 = call ptr @listNext(ptr noundef nonnull %li) #33
  %cmp27.not = icmp eq ptr %call33, null
  br i1 %cmp27.not, label %for.end34, label %for.body29, !llvm.loop !78

for.end34:                                        ; preds = %for.body29, %if.end
  ret void
}

declare void @addReplyArrayLen(ptr noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterCommandShards(ptr noundef %c) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 5
  %1 = load ptr, ptr %shards, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2
  %2 = load i64, ptr %ht_used, align 8
  %arrayidx3 = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2, i64 1
  %3 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %3, %2
  tail call void @addReplyArrayLen(ptr noundef %c, i64 noundef %add) #33
  tail call void @clusterGenNodesSlotsInfo(i32 noundef 0)
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %shards4 = getelementptr inbounds %struct.clusterState, ptr %4, i64 0, i32 5
  %5 = load ptr, ptr %shards4, align 8
  %call = tail call ptr @dictGetSafeIterator(ptr noundef %5) #33
  %call5 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not5 = icmp eq ptr %call5, null
  br i1 %cmp.not5, label %for.end, label %for.body

for.body:                                         ; preds = %entry, %for.body
  %de.06 = phi ptr [ %call7, %for.body ], [ %call5, %entry ]
  %call6 = tail call ptr @dictGetVal(ptr noundef nonnull %de.06) #33
  tail call void @addShardReplyForClusterShards(ptr noundef %c, ptr noundef %call6)
  %call7 = tail call ptr @dictNext(ptr noundef %call) #33
  %cmp.not = icmp eq ptr %call7, null
  br i1 %cmp.not, label %for.end, label %for.body, !llvm.loop !79

for.end:                                          ; preds = %for.body, %entry
  tail call void @dictReleaseIterator(ptr noundef %call) #33
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genClusterInfoString() local_unnamed_addr #2 {
entry:
  %call = tail call ptr @sdsempty() #33
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %slots_assigned.046 = phi i32 [ 0, %entry ], [ %slots_assigned.1, %for.inc ]
  %slots_fail.045 = phi i32 [ 0, %entry ], [ %slots_fail.1, %for.inc ]
  %slots_pfail.044 = phi i32 [ 0, %entry ], [ %slots_pfail.1, %for.inc ]
  %slots_ok.043 = phi i32 [ 0, %entry ], [ %slots_ok.1, %for.inc ]
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 9, i64 %indvars.iv
  %1 = load ptr, ptr %arrayidx, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %inc = add nsw i32 %slots_assigned.046, 1
  %flags = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and = and i32 %2, 8
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  %inc3 = add nsw i32 %slots_fail.045, 1
  br label %for.inc

if.else:                                          ; preds = %if.end
  %and5 = and i32 %2, 4
  %tobool6.not = icmp eq i32 %and5, 0
  br i1 %tobool6.not, label %if.else9, label %if.then7

if.then7:                                         ; preds = %if.else
  %inc8 = add nsw i32 %slots_pfail.044, 1
  br label %for.inc

if.else9:                                         ; preds = %if.else
  %inc10 = add nsw i32 %slots_ok.043, 1
  br label %for.inc

for.inc:                                          ; preds = %if.then2, %if.else9, %if.then7, %for.body
  %slots_ok.1 = phi i32 [ %slots_ok.043, %for.body ], [ %slots_ok.043, %if.then2 ], [ %slots_ok.043, %if.then7 ], [ %inc10, %if.else9 ]
  %slots_pfail.1 = phi i32 [ %slots_pfail.044, %for.body ], [ %slots_pfail.044, %if.then2 ], [ %inc8, %if.then7 ], [ %slots_pfail.044, %if.else9 ]
  %slots_fail.1 = phi i32 [ %slots_fail.045, %for.body ], [ %inc3, %if.then2 ], [ %slots_fail.045, %if.then7 ], [ %slots_fail.045, %if.else9 ]
  %slots_assigned.1 = phi i32 [ %slots_assigned.046, %for.body ], [ %inc, %if.then2 ], [ %inc, %if.then7 ], [ %inc, %if.else9 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 16384
  br i1 %exitcond.not, label %for.end, label %for.body, !llvm.loop !80

for.end:                                          ; preds = %for.inc
  %3 = load ptr, ptr @myself, align 8
  %flags14 = getelementptr inbounds %struct._clusterNode, ptr %3, i64 0, i32 3
  %4 = load i32, ptr %flags14, align 8
  %and15 = and i32 %4, 2
  %tobool16.not = icmp eq i32 %and15, 0
  br i1 %tobool16.not, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %3, i64 0, i32 11
  %5 = load ptr, ptr %slaveof, align 8
  %tobool17.not = icmp eq ptr %5, null
  br i1 %tobool17.not, label %cond.false, label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  br label %cond.end

cond.end:                                         ; preds = %land.lhs.true, %cond.false
  %.pn = phi ptr [ %3, %cond.false ], [ %5, %land.lhs.true ]
  %cond.in = getelementptr inbounds %struct._clusterNode, ptr %.pn, i64 0, i32 4
  %cond = load i64, ptr %cond.in, align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 2
  %6 = load i32, ptr %state, align 8
  %idxprom20 = sext i32 %6 to i64
  %arrayidx21 = getelementptr inbounds [2 x ptr], ptr @__const.genClusterInfoString.statestr, i64 0, i64 %idxprom20
  %7 = load ptr, ptr %arrayidx21, align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %8 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %8, i64 0, i32 2
  %9 = load i64, ptr %ht_used, align 8
  %arrayidx25 = getelementptr inbounds %struct.dict, ptr %8, i64 0, i32 2, i64 1
  %10 = load i64, ptr %arrayidx25, align 8
  %add = add i64 %10, %9
  %size = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 3
  %11 = load i32, ptr %size, align 4
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 1
  %12 = load i64, ptr %currentEpoch, align 8
  %call26 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call, ptr noundef nonnull @.str.199, ptr noundef %7, i32 noundef %slots_assigned.1, i32 noundef %slots_ok.1, i32 noundef %slots_pfail.1, i32 noundef %slots_fail.1, i64 noundef %add, i32 noundef %11, i64 noundef %12, i64 noundef %cond) #33
  %.pre63 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %for.body29

for.body29:                                       ; preds = %cond.end, %for.inc44
  %13 = phi ptr [ %.pre63, %cond.end ], [ %18, %for.inc44 ]
  %indvars.iv55 = phi i64 [ 0, %cond.end ], [ %indvars.iv.next56, %for.inc44 ]
  %tot_msg_sent.049 = phi i64 [ 0, %cond.end ], [ %tot_msg_sent.1, %for.inc44 ]
  %info.048 = phi ptr [ %call26, %cond.end ], [ %info.1, %for.inc44 ]
  %arrayidx31 = getelementptr inbounds %struct.clusterState, ptr %13, i64 0, i32 23, i64 %indvars.iv55
  %14 = load i64, ptr %arrayidx31, align 8
  %cmp32 = icmp eq i64 %14, 0
  br i1 %cmp32, label %for.inc44, label %if.end34

if.end34:                                         ; preds = %for.body29
  %add38 = add nsw i64 %14, %tot_msg_sent.049
  %15 = trunc i64 %indvars.iv55 to i32
  %16 = icmp ult i32 %15, 11
  br i1 %16, label %switch.lookup, label %clusterGetMessageTypeString.exit

switch.lookup:                                    ; preds = %if.end34
  %17 = and i64 %indvars.iv55, 4294967295
  %switch.gep = getelementptr inbounds [11 x ptr], ptr @switch.table.genClusterInfoString.15, i64 0, i64 %17
  %switch.load = load ptr, ptr %switch.gep, align 8
  br label %clusterGetMessageTypeString.exit

clusterGetMessageTypeString.exit:                 ; preds = %if.end34, %switch.lookup
  %retval.0.i = phi ptr [ %switch.load, %switch.lookup ], [ @.str.179, %if.end34 ]
  %call43 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.048, ptr noundef nonnull @.str.200, ptr noundef nonnull %retval.0.i, i64 noundef %14) #33
  %.pre = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %for.inc44

for.inc44:                                        ; preds = %for.body29, %clusterGetMessageTypeString.exit
  %18 = phi ptr [ %13, %for.body29 ], [ %.pre, %clusterGetMessageTypeString.exit ]
  %info.1 = phi ptr [ %info.048, %for.body29 ], [ %call43, %clusterGetMessageTypeString.exit ]
  %tot_msg_sent.1 = phi i64 [ %tot_msg_sent.049, %for.body29 ], [ %add38, %clusterGetMessageTypeString.exit ]
  %indvars.iv.next56 = add nuw nsw i64 %indvars.iv55, 1
  %exitcond58.not = icmp eq i64 %indvars.iv.next56, 11
  br i1 %exitcond58.not, label %for.end46, label %for.body29, !llvm.loop !81

for.end46:                                        ; preds = %for.inc44
  %call47 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.1, ptr noundef nonnull @.str.201, i64 noundef %tot_msg_sent.1) #33
  %.pre65 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %for.body51

for.body51:                                       ; preds = %for.end46, %for.inc66
  %19 = phi ptr [ %.pre65, %for.end46 ], [ %24, %for.inc66 ]
  %indvars.iv59 = phi i64 [ 0, %for.end46 ], [ %indvars.iv.next60, %for.inc66 ]
  %tot_msg_received.052 = phi i64 [ 0, %for.end46 ], [ %tot_msg_received.1, %for.inc66 ]
  %info.251 = phi ptr [ %call47, %for.end46 ], [ %info.3, %for.inc66 ]
  %arrayidx53 = getelementptr inbounds %struct.clusterState, ptr %19, i64 0, i32 24, i64 %indvars.iv59
  %20 = load i64, ptr %arrayidx53, align 8
  %cmp54 = icmp eq i64 %20, 0
  br i1 %cmp54, label %for.inc66, label %if.end56

if.end56:                                         ; preds = %for.body51
  %add60 = add nsw i64 %20, %tot_msg_received.052
  %21 = trunc i64 %indvars.iv59 to i32
  %22 = icmp ult i32 %21, 11
  br i1 %22, label %switch.lookup66, label %clusterGetMessageTypeString.exit42

switch.lookup66:                                  ; preds = %if.end56
  %23 = and i64 %indvars.iv59, 4294967295
  %switch.gep67 = getelementptr inbounds [11 x ptr], ptr @switch.table.genClusterInfoString.15, i64 0, i64 %23
  %switch.load68 = load ptr, ptr %switch.gep67, align 8
  br label %clusterGetMessageTypeString.exit42

clusterGetMessageTypeString.exit42:               ; preds = %if.end56, %switch.lookup66
  %retval.0.i31 = phi ptr [ %switch.load68, %switch.lookup66 ], [ @.str.179, %if.end56 ]
  %call65 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.251, ptr noundef nonnull @.str.202, ptr noundef nonnull %retval.0.i31, i64 noundef %20) #33
  %.pre64 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %for.inc66

for.inc66:                                        ; preds = %for.body51, %clusterGetMessageTypeString.exit42
  %24 = phi ptr [ %19, %for.body51 ], [ %.pre64, %clusterGetMessageTypeString.exit42 ]
  %info.3 = phi ptr [ %info.251, %for.body51 ], [ %call65, %clusterGetMessageTypeString.exit42 ]
  %tot_msg_received.1 = phi i64 [ %tot_msg_received.052, %for.body51 ], [ %add60, %clusterGetMessageTypeString.exit42 ]
  %indvars.iv.next60 = add nuw nsw i64 %indvars.iv59, 1
  %exitcond62.not = icmp eq i64 %indvars.iv.next60, 11
  br i1 %exitcond62.not, label %for.end68, label %for.body51, !llvm.loop !82

for.end68:                                        ; preds = %for.inc66
  %call69 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %info.3, ptr noundef nonnull @.str.203, i64 noundef %tot_msg_received.1) #33
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %stat_cluster_links_buffer_limit_exceeded = getelementptr inbounds %struct.clusterState, ptr %25, i64 0, i32 26
  %26 = load i64, ptr %stat_cluster_links_buffer_limit_exceeded, align 8
  %call70 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call69, ptr noundef nonnull @.str.204, i64 noundef %26) #33
  ret ptr %call70
}

; Function Attrs: nounwind uwtable
define dso_local i32 @countChannelsInSlot(i32 noundef %hashslot) local_unnamed_addr #2 {
entry:
  %iter = alloca %struct.raxIterator, align 8
  %indexed = alloca [2 x i8], align 1
  %shr = lshr i32 %hashslot, 8
  %conv = trunc i32 %shr to i8
  store i8 %conv, ptr %indexed, align 1
  %conv2 = trunc i32 %hashslot to i8
  %arrayidx3 = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 1
  store i8 %conv2, ptr %arrayidx3, align 1
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %slots_to_channels = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 10
  %1 = load ptr, ptr %slots_to_channels, align 8
  call void @raxStart(ptr noundef nonnull %iter, ptr noundef %1) #33
  %call = call i32 @raxSeek(ptr noundef nonnull %iter, ptr noundef nonnull @.str.205, ptr noundef nonnull %indexed, i64 noundef 2) #33
  %key = getelementptr inbounds %struct.raxIterator, ptr %iter, i64 0, i32 2
  %call43 = call i32 @raxNext(ptr noundef nonnull %iter) #33
  %tobool.not4 = icmp eq i32 %call43, 0
  br i1 %tobool.not4, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %if.end
  %j.05 = phi i32 [ %inc, %if.end ], [ 0, %entry ]
  %2 = load ptr, ptr %key, align 8
  %3 = load i8, ptr %2, align 1
  %4 = load i8, ptr %indexed, align 1
  %cmp.not = icmp eq i8 %3, %4
  br i1 %cmp.not, label %lor.lhs.false, label %while.end

lor.lhs.false:                                    ; preds = %while.body
  %arrayidx11 = getelementptr inbounds i8, ptr %2, i64 1
  %5 = load i8, ptr %arrayidx11, align 1
  %6 = load i8, ptr %arrayidx3, align 1
  %cmp15.not = icmp eq i8 %5, %6
  br i1 %cmp15.not, label %if.end, label %while.end

if.end:                                           ; preds = %lor.lhs.false
  %inc = add nuw nsw i32 %j.05, 1
  %call4 = call i32 @raxNext(ptr noundef nonnull %iter) #33
  %tobool.not = icmp eq i32 %call4, 0
  br i1 %tobool.not, label %while.end, label %while.body, !llvm.loop !83

while.end:                                        ; preds = %if.end, %lor.lhs.false, %while.body, %entry
  %j.0.lcssa = phi i32 [ 0, %entry ], [ %j.05, %while.body ], [ %j.05, %lor.lhs.false ], [ %inc, %if.end ]
  call void @raxStop(ptr noundef nonnull %iter) #33
  ret i32 %j.0.lcssa
}

declare void @raxStart(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @raxSeek(ptr noundef, ptr noundef, ptr noundef, i64 noundef) local_unnamed_addr #1

declare i32 @raxNext(ptr noundef) local_unnamed_addr #1

declare void @raxStop(ptr noundef) local_unnamed_addr #1

declare void @pubsubUnsubscribeShardChannels(ptr noundef, i32 noundef) local_unnamed_addr #1

declare void @enterExecutionUnit(i32 noundef, i64 noundef) local_unnamed_addr #1

declare i32 @dbDelete(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @propagateDeletion(ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

declare void @signalModifiedKey(ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @moduleNotifyKeyspaceEvent(i32 noundef, ptr noundef, ptr noundef, i32 noundef) local_unnamed_addr #1

declare void @exitExecutionUnit() local_unnamed_addr #1

declare void @postExecutionUnitOperations() local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @slotToChannelUpdate(ptr noundef %channel, i32 noundef %add) local_unnamed_addr #2 {
entry:
  %buf = alloca [64 x i8], align 16
  %buf.sroa.gep17 = getelementptr inbounds i8, ptr %buf, i64 2
  %buf.sroa.gep = getelementptr inbounds i8, ptr %buf, i64 1
  %arrayidx.i = getelementptr inbounds i8, ptr %channel, i64 -1
  %0 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %0 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit.thread [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sdslen.exit.thread:                               ; preds = %entry
  %call120 = tail call i32 @keyHashSlot(ptr noundef nonnull %channel, i32 noundef 0) #33
  br label %if.end

sw.bb.i:                                          ; preds = %entry
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %entry
  %add.ptr.i = getelementptr inbounds i8, ptr %channel, i64 -3
  %1 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %1 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %entry
  %add.ptr6.i = getelementptr inbounds i8, ptr %channel, i64 -5
  %2 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %2 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %entry
  %add.ptr10.i = getelementptr inbounds i8, ptr %channel, i64 -9
  %3 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %3 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %entry
  %add.ptr14.i = getelementptr inbounds i8, ptr %channel, i64 -17
  %4 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %4, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ]
  %conv = trunc i64 %retval.0.i to i32
  %call1 = tail call i32 @keyHashSlot(ptr noundef nonnull %channel, i32 noundef %conv) #33
  %add2 = add i64 %retval.0.i, 2
  %cmp = icmp ugt i64 %add2, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sdslen.exit
  %call5 = tail call noalias ptr @zmalloc(i64 noundef %add2) #37
  %call5.sroa.gep16 = getelementptr inbounds i8, ptr %call5, i64 2
  %call5.sroa.gep = getelementptr inbounds i8, ptr %call5, i64 1
  br label %if.end

if.end:                                           ; preds = %sdslen.exit.thread, %if.then, %sdslen.exit
  %add225 = phi i64 [ %add2, %if.then ], [ %add2, %sdslen.exit ], [ 2, %sdslen.exit.thread ]
  %call124 = phi i32 [ %call1, %if.then ], [ %call1, %sdslen.exit ], [ %call120, %sdslen.exit.thread ]
  %retval.0.i23 = phi i64 [ %retval.0.i, %if.then ], [ %retval.0.i, %sdslen.exit ], [ 0, %sdslen.exit.thread ]
  %indexed.0 = phi ptr [ %call5, %if.then ], [ %buf, %sdslen.exit ], [ %buf, %sdslen.exit.thread ]
  %indexed.0.sroa.phi = phi ptr [ %call5.sroa.gep, %if.then ], [ %buf.sroa.gep, %sdslen.exit ], [ %buf.sroa.gep, %sdslen.exit.thread ]
  %indexed.0.sroa.phi15 = phi ptr [ %call5.sroa.gep16, %if.then ], [ %buf.sroa.gep17, %sdslen.exit ], [ %buf.sroa.gep17, %sdslen.exit.thread ]
  %shr = lshr i32 %call124, 8
  %conv6 = trunc i32 %shr to i8
  store i8 %conv6, ptr %indexed.0, align 1
  %conv8 = trunc i32 %call124 to i8
  store i8 %conv8, ptr %indexed.0.sroa.phi, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %indexed.0.sroa.phi15, ptr nonnull align 1 %channel, i64 %retval.0.i23, i1 false)
  %tobool.not = icmp eq i32 %add, 0
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %slots_to_channels13 = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 10
  %6 = load ptr, ptr %slots_to_channels13, align 8
  br i1 %tobool.not, label %if.else, label %if.then10

if.then10:                                        ; preds = %if.end
  %call12 = call i32 @raxInsert(ptr noundef %6, ptr noundef nonnull %indexed.0, i64 noundef %add225, ptr noundef null, ptr noundef null) #33
  br label %if.end16

if.else:                                          ; preds = %if.end
  %call15 = call i32 @raxRemove(ptr noundef %6, ptr noundef nonnull %indexed.0, i64 noundef %add225, ptr noundef null) #33
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then10
  %cmp18.not = icmp eq ptr %indexed.0, %buf
  br i1 %cmp18.not, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end16
  call void @zfree(ptr noundef nonnull %indexed.0) #33
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end16
  ret void
}

declare i32 @keyHashSlot(ptr noundef, i32 noundef) local_unnamed_addr #1

declare i32 @raxInsert(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @raxRemove(ptr noundef, ptr noundef, i64 noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: nounwind uwtable
define dso_local void @slotToChannelAdd(ptr noundef %channel) local_unnamed_addr #2 {
entry:
  tail call void @slotToChannelUpdate(ptr noundef %channel, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @slotToChannelDel(ptr noundef %channel) local_unnamed_addr #2 {
entry:
  tail call void @slotToChannelUpdate(ptr noundef %channel, i32 noundef 0)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @clusterNodeIsMyself(ptr noundef readnone %n) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %1 = load ptr, ptr %0, align 8
  %cmp = icmp eq ptr %1, %n
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @getMyClusterNode() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %1 = load ptr, ptr %0, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @clusterManualFailoverTimeLimit() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 17
  %1 = load i64, ptr %mf_end, align 8
  %conv = trunc i64 %1 to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @getClusterSize() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2
  %2 = load i64, ptr %ht_used, align 8
  %arrayidx3 = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2, i64 1
  %3 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %3, %2
  %conv = trunc i64 %add to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @getMyShardSlotCount() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %1 = load ptr, ptr %0, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and = and i32 %2, 2
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %return.sink.split, label %if.else

if.else:                                          ; preds = %entry
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %1, i64 0, i32 11
  %3 = load ptr, ptr %slaveof, align 8
  %tobool3.not = icmp eq ptr %3, null
  br i1 %tobool3.not, label %return, label %return.sink.split

return.sink.split:                                ; preds = %if.else, %entry
  %.sink = phi ptr [ %1, %entry ], [ %3, %if.else ]
  %numslots7 = getelementptr inbounds %struct._clusterNode, ptr %.sink, i64 0, i32 8
  %4 = load i32, ptr %numslots7, align 4
  br label %return

return:                                           ; preds = %return.sink.split, %if.else
  %retval.0 = phi i32 [ 0, %if.else ], [ %4, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local noalias ptr @getClusterNodesList(ptr nocapture noundef writeonly %numnodes) local_unnamed_addr #2 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2
  %2 = load i64, ptr %ht_used, align 8
  %arrayidx3 = getelementptr inbounds %struct.dict, ptr %1, i64 0, i32 2, i64 1
  %3 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %3, %2
  %4 = mul i64 %add, 40
  %mul = add i64 %4, 40
  %call = tail call noalias ptr @zmalloc(i64 noundef %mul) #37
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes5 = getelementptr inbounds %struct.clusterState, ptr %5, i64 0, i32 4
  %6 = load ptr, ptr %nodes5, align 8
  %call6 = tail call ptr @dictGetIterator(ptr noundef %6) #33
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %if.end, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end ], [ 0, %entry ]
  br label %while.cond

while.cond:                                       ; preds = %while.cond.outer, %while.body
  %call7 = tail call ptr @dictNext(ptr noundef %call6) #33
  %cmp.not = icmp eq ptr %call7, null
  br i1 %cmp.not, label %while.end, label %while.body

while.body:                                       ; preds = %while.cond
  %call8 = tail call ptr @dictGetVal(ptr noundef nonnull %call7) #33
  %flags = getelementptr inbounds %struct._clusterNode, ptr %call8, i64 0, i32 3
  %7 = load i32, ptr %flags, align 8
  %and = and i32 %7, 96
  %tobool.not = icmp eq i32 %and, 0
  br i1 %tobool.not, label %if.end, label %while.cond, !llvm.loop !84

if.end:                                           ; preds = %while.body
  %call9 = tail call noalias dereferenceable_or_null(40) ptr @zmalloc(i64 noundef 40) #37
  %arrayidx10 = getelementptr inbounds ptr, ptr %call, i64 %indvars.iv
  store ptr %call9, ptr %arrayidx10, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %call8, i64 0, i32 1
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(40) %call9, ptr noundef nonnull align 8 dereferenceable(40) %name, i64 40, i1 false)
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  br label %while.cond.outer, !llvm.loop !84

while.end:                                        ; preds = %while.cond
  %conv = and i64 %indvars.iv, 4294967295
  store i64 %conv, ptr %numnodes, align 8
  %arrayidx14 = getelementptr inbounds ptr, ptr %call, i64 %conv
  store ptr null, ptr %arrayidx14, align 8
  tail call void @dictReleaseIterator(ptr noundef %call6) #33
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @handleDebugClusterCommand(ptr noundef %c) local_unnamed_addr #2 {
entry:
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %0 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 1
  %1 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %call = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.207) #34
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %entry
  %arrayidx2 = getelementptr inbounds ptr, ptr %0, i64 2
  %3 = load ptr, ptr %arrayidx2, align 8
  %ptr3 = getelementptr inbounds %struct.redisObject, ptr %3, i64 0, i32 2
  %4 = load ptr, ptr %ptr3, align 8
  %call4 = tail call i32 @strcasecmp(ptr noundef %4, ptr noundef nonnull @.str.208) #34
  %tobool5.not = icmp eq i32 %call4, 0
  br i1 %tobool5.not, label %lor.lhs.false6, label %return

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %5 = load i32, ptr %argc, align 8
  %cmp.not = icmp eq i32 %5, 5
  br i1 %cmp.not, label %if.end, label %return

if.end:                                           ; preds = %lor.lhs.false6
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool7.not = icmp eq i32 %6, 0
  br i1 %tobool7.not, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.209) #33
  br label %return

if.end9:                                          ; preds = %if.end
  %arrayidx11 = getelementptr inbounds ptr, ptr %0, i64 4
  %7 = load ptr, ptr %arrayidx11, align 8
  %ptr12 = getelementptr inbounds %struct.redisObject, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %ptr12, align 8
  %arrayidx.i = getelementptr inbounds i8, ptr %8, i64 -1
  %9 = load i8, ptr %arrayidx.i, align 1
  %conv.i = zext i8 %9 to i32
  %and.i = and i32 %conv.i, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.end9
  %shr.i = lshr i32 %conv.i, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.end9
  %add.ptr.i = getelementptr inbounds i8, ptr %8, i64 -3
  %10 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %10 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.end9
  %add.ptr6.i = getelementptr inbounds i8, ptr %8, i64 -5
  %11 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %11 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.end9
  %add.ptr10.i = getelementptr inbounds i8, ptr %8, i64 -9
  %12 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %12 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.end9
  %add.ptr14.i = getelementptr inbounds i8, ptr %8, i64 -17
  %13 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.end9, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i = phi i64 [ %13, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.end9 ]
  %conv = trunc i64 %retval.0.i to i32
  %call.i = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %8, i32 noundef %conv) #33
  %cmp.not.i = icmp eq i32 %call.i, 0
  br i1 %cmp.not.i, label %if.end.i, label %if.then19

if.end.i:                                         ; preds = %sdslen.exit
  %sext = shl i64 %retval.0.i, 32
  %conv.i19 = ashr exact i64 %sext, 32
  %call1.i = tail call ptr @sdsnewlen(ptr noundef nonnull %8, i64 noundef %conv.i19) #33
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %14, i64 0, i32 4
  %15 = load ptr, ptr %nodes.i, align 8
  %call2.i = tail call ptr @dictFind(ptr noundef %15, ptr noundef %call1.i) #33
  tail call void @sdsfree(ptr noundef %call1.i) #33
  %cmp3.i = icmp eq ptr %call2.i, null
  br i1 %cmp3.i, label %if.then19, label %clusterLookupNode.exit

clusterLookupNode.exit:                           ; preds = %if.end.i
  %call7.i = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i) #33
  %tobool18.not = icmp eq ptr %call7.i, null
  br i1 %tobool18.not, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.end.i, %sdslen.exit, %clusterLookupNode.exit
  %16 = load ptr, ptr %argv, align 8
  %arrayidx21 = getelementptr inbounds ptr, ptr %16, i64 4
  %17 = load ptr, ptr %arrayidx21, align 8
  %ptr22 = getelementptr inbounds %struct.redisObject, ptr %17, i64 0, i32 2
  %18 = load ptr, ptr %ptr22, align 8
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.210, ptr noundef %18) #33
  br label %return

if.end23:                                         ; preds = %clusterLookupNode.exit
  %19 = load ptr, ptr %argv, align 8
  %arrayidx25 = getelementptr inbounds ptr, ptr %19, i64 3
  %20 = load ptr, ptr %arrayidx25, align 8
  %ptr26 = getelementptr inbounds %struct.redisObject, ptr %20, i64 0, i32 2
  %21 = load ptr, ptr %ptr26, align 8
  %call27 = tail call i32 @strcasecmp(ptr noundef %21, ptr noundef nonnull @.str.161) #34
  %tobool28.not = icmp eq i32 %call27, 0
  br i1 %tobool28.not, label %if.then29, label %if.else

if.then29:                                        ; preds = %if.end23
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %call7.i, i64 0, i32 28
  %22 = load ptr, ptr %inbound_link, align 8
  tail call void @freeClusterLink(ptr noundef %22)
  br label %if.end51

if.else:                                          ; preds = %if.end23
  %call33 = tail call i32 @strcasecmp(ptr noundef %21, ptr noundef nonnull @.str.162) #34
  %tobool34.not = icmp eq i32 %call33, 0
  br i1 %tobool34.not, label %if.then35, label %if.else36

if.then35:                                        ; preds = %if.else
  %link = getelementptr inbounds %struct._clusterNode, ptr %call7.i, i64 0, i32 27
  %23 = load ptr, ptr %link, align 8
  tail call void @freeClusterLink(ptr noundef %23)
  br label %if.end51

if.else36:                                        ; preds = %if.else
  %call40 = tail call i32 @strcasecmp(ptr noundef %21, ptr noundef nonnull @.str.211) #34
  %tobool41.not = icmp eq i32 %call40, 0
  br i1 %tobool41.not, label %if.then42, label %if.else45

if.then42:                                        ; preds = %if.else36
  %link43 = getelementptr inbounds %struct._clusterNode, ptr %call7.i, i64 0, i32 27
  %24 = load ptr, ptr %link43, align 8
  tail call void @freeClusterLink(ptr noundef %24)
  %inbound_link44 = getelementptr inbounds %struct._clusterNode, ptr %call7.i, i64 0, i32 28
  %25 = load ptr, ptr %inbound_link44, align 8
  tail call void @freeClusterLink(ptr noundef %25)
  br label %if.end51

if.else45:                                        ; preds = %if.else36
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.212, ptr noundef %21) #33
  br label %if.end51

if.end51:                                         ; preds = %if.then35, %if.else45, %if.then42, %if.then29
  %26 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %26) #33
  br label %return

return:                                           ; preds = %entry, %lor.lhs.false, %lor.lhs.false6, %if.end51, %if.then19, %if.then8
  %retval.0 = phi i32 [ 1, %if.end51 ], [ 1, %if.then19 ], [ 1, %if.then8 ], [ 0, %lor.lhs.false6 ], [ 0, %lor.lhs.false ], [ 0, %entry ]
  ret i32 %retval.0
}

declare void @addReply(ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @clusterNodePending(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 96
  ret i32 %and
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local nonnull ptr @clusterNodeIp(ptr noundef readnone %node) local_unnamed_addr #27 {
entry:
  %ip = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 21
  ret ptr %ip
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @clusterNodeIsSlave(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 2
  ret i32 %and
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @clusterNodeGetSlaveof(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 11
  %0 = load ptr, ptr %slaveof, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local nonnull ptr @clusterNodeGetName(ptr noundef readnone %node) local_unnamed_addr #27 {
entry:
  %name = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 1
  ret ptr %name
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @clusterNodeTimedOut(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 4
  ret i32 %and
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @clusterNodeIsFailing(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 8
  ret i32 %and
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @clusterNodeIsNoFailover(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %flags = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 3
  %0 = load i32, ptr %flags, align 8
  %and = and i32 %0, 512
  ret i32 %and
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local nonnull ptr @clusterDebugCommandExtendedHelp() local_unnamed_addr #27 {
entry:
  ret ptr @clusterDebugCommandExtendedHelp.help
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local nonnull ptr @clusterNodeGetShardId(ptr noundef readnone %node) local_unnamed_addr #27 {
entry:
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 2
  ret ptr %shard_id
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterCommandSpecial(ptr noundef %c) local_unnamed_addr #2 {
entry:
  %slot.i312 = alloca i64, align 8
  %slot.i267 = alloca i64, align 8
  %slot.i255 = alloca i64, align 8
  %slot.i233 = alloca i64, align 8
  %slot.i = alloca i64, align 8
  %port = alloca i64, align 8
  %cport = alloca i64, align 8
  %epoch = alloca i64, align 8
  %argv = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 12
  %0 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 1
  %1 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %1, i64 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %call = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.171) #34
  %tobool.not = icmp eq i32 %call, 0
  br i1 %tobool.not, label %land.lhs.true, label %if.else44

land.lhs.true:                                    ; preds = %entry
  %argc = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %3 = load i32, ptr %argc, align 8
  %4 = and i32 %3, -2
  %switch = icmp eq i32 %4, 4
  br i1 %switch, label %if.then, label %if.else44

if.then:                                          ; preds = %land.lhs.true
  %arrayidx4 = getelementptr inbounds ptr, ptr %0, i64 3
  %5 = load ptr, ptr %arrayidx4, align 8
  %call5 = call i32 @getLongLongFromObject(ptr noundef %5, ptr noundef nonnull %port) #33
  %cmp6.not = icmp eq i32 %call5, 0
  br i1 %cmp6.not, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.then
  %6 = load ptr, ptr %argv, align 8
  %arrayidx9 = getelementptr inbounds ptr, ptr %6, i64 3
  %7 = load ptr, ptr %arrayidx9, align 8
  %ptr10 = getelementptr inbounds %struct.redisObject, ptr %7, i64 0, i32 2
  %8 = load ptr, ptr %ptr10, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.215, ptr noundef %8) #33
  br label %return

if.end:                                           ; preds = %if.then
  %9 = load i32, ptr %argc, align 8
  %cmp12 = icmp eq i32 %9, 5
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end
  %10 = load ptr, ptr %argv, align 8
  %arrayidx15 = getelementptr inbounds ptr, ptr %10, i64 4
  %11 = load ptr, ptr %arrayidx15, align 8
  %call16 = call i32 @getLongLongFromObject(ptr noundef %11, ptr noundef nonnull %cport) #33
  %cmp17.not = icmp eq i32 %call16, 0
  br i1 %cmp17.not, label %if.then13.if.end23_crit_edge, label %if.then18

if.then13.if.end23_crit_edge:                     ; preds = %if.then13
  %.pre489 = load i64, ptr %port, align 8
  %.pre490 = load i64, ptr %cport, align 8
  br label %if.end23

if.then18:                                        ; preds = %if.then13
  %12 = load ptr, ptr %argv, align 8
  %arrayidx20 = getelementptr inbounds ptr, ptr %12, i64 4
  %13 = load ptr, ptr %arrayidx20, align 8
  %ptr21 = getelementptr inbounds %struct.redisObject, ptr %13, i64 0, i32 2
  %14 = load ptr, ptr %ptr21, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.216, ptr noundef %14) #33
  br label %return

if.else:                                          ; preds = %if.end
  %15 = load i64, ptr %port, align 8
  %add = add nsw i64 %15, 10000
  store i64 %add, ptr %cport, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then13.if.end23_crit_edge, %if.else
  %16 = phi i64 [ %.pre490, %if.then13.if.end23_crit_edge ], [ %add, %if.else ]
  %17 = phi i64 [ %.pre489, %if.then13.if.end23_crit_edge ], [ %15, %if.else ]
  %18 = load ptr, ptr %argv, align 8
  %arrayidx25 = getelementptr inbounds ptr, ptr %18, i64 2
  %19 = load ptr, ptr %arrayidx25, align 8
  %ptr26 = getelementptr inbounds %struct.redisObject, ptr %19, i64 0, i32 2
  %20 = load ptr, ptr %ptr26, align 8
  %conv = trunc i64 %17 to i32
  %conv27 = trunc i64 %16 to i32
  %call28 = call i32 @clusterStartHandshake(ptr noundef %20, i32 noundef %conv, i32 noundef %conv27), !range !18
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %land.lhs.true31, label %if.else42

land.lhs.true31:                                  ; preds = %if.end23
  %call32 = tail call ptr @__errno_location() #36
  %21 = load i32, ptr %call32, align 4
  %cmp33 = icmp eq i32 %21, 22
  br i1 %cmp33, label %if.then35, label %if.else42

if.then35:                                        ; preds = %land.lhs.true31
  %22 = load ptr, ptr %argv, align 8
  %arrayidx37 = getelementptr inbounds ptr, ptr %22, i64 2
  %23 = load ptr, ptr %arrayidx37, align 8
  %ptr38 = getelementptr inbounds %struct.redisObject, ptr %23, i64 0, i32 2
  %24 = load ptr, ptr %ptr38, align 8
  %arrayidx40 = getelementptr inbounds ptr, ptr %22, i64 3
  %25 = load ptr, ptr %arrayidx40, align 8
  %ptr41 = getelementptr inbounds %struct.redisObject, ptr %25, i64 0, i32 2
  %26 = load ptr, ptr %ptr41, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.217, ptr noundef %24, ptr noundef %26) #33
  br label %return

if.else42:                                        ; preds = %land.lhs.true31, %if.end23
  %27 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef nonnull %c, ptr noundef %27) #33
  br label %return

if.else44:                                        ; preds = %land.lhs.true, %entry
  %call48 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.218) #34
  %tobool49.not = icmp eq i32 %call48, 0
  br i1 %tobool49.not, label %land.lhs.true50, label %if.else62

land.lhs.true50:                                  ; preds = %if.else44
  %argc51 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %28 = load i32, ptr %argc51, align 8
  %cmp52 = icmp eq i32 %28, 2
  br i1 %cmp52, label %if.then54, label %if.else62

if.then54:                                        ; preds = %land.lhs.true50
  %29 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %call56 = tail call i64 @dbSize(ptr noundef %29, i32 noundef 0) #33
  %cmp57.not = icmp eq i64 %call56, 0
  br i1 %cmp57.not, label %if.end60, label %if.then59

if.then59:                                        ; preds = %if.then54
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.219) #33
  br label %return

if.end60:                                         ; preds = %if.then54
  %30 = load ptr, ptr @myself, align 8
  %slots.i.i = getelementptr inbounds %struct._clusterNode, ptr %30, i64 0, i32 5
  br label %for.body.i

for.body.i:                                       ; preds = %for.inc.i, %if.end60
  %indvars.iv.i = phi i64 [ 0, %if.end60 ], [ %indvars.iv.next.i, %for.inc.i ]
  %31 = trunc i64 %indvars.iv.i to i32
  %div.i.i789.i = lshr i64 %indvars.iv.i, 3
  %conv.i.i.i = and i64 %div.i.i789.i, 536870911
  %and.i.i.i = and i32 %31, 7
  %arrayidx.i.i.i = getelementptr inbounds i8, ptr %slots.i.i, i64 %conv.i.i.i
  %32 = load i8, ptr %arrayidx.i.i.i, align 1
  %conv1.i.i.i = zext i8 %32 to i32
  %33 = shl nuw nsw i32 1, %and.i.i.i
  %34 = and i32 %33, %conv1.i.i.i
  %tobool.not.i = icmp eq i32 %34, 0
  br i1 %tobool.not.i, label %for.inc.i, label %if.then.i

if.then.i:                                        ; preds = %for.body.i
  %35 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx.i.i = getelementptr inbounds %struct.clusterState, ptr %35, i64 0, i32 9, i64 %indvars.iv.i
  %36 = load ptr, ptr %arrayidx.i.i, align 8
  %tobool.not.i.i = icmp eq ptr %36, null
  br i1 %tobool.not.i.i, label %for.inc.i, label %if.end.i.i

if.end.i.i:                                       ; preds = %if.then.i
  tail call void @removeChannelsInSlot(i32 noundef %31)
  %slots.i.i.i = getelementptr inbounds %struct._clusterNode, ptr %36, i64 0, i32 5
  %arrayidx.i.i.i.i = getelementptr inbounds i8, ptr %slots.i.i.i, i64 %conv.i.i.i
  %37 = load i8, ptr %arrayidx.i.i.i.i, align 1
  %conv1.i.i.i.i = zext i8 %37 to i32
  %38 = and i32 %33, %conv1.i.i.i.i
  %tobool.not.i.i.i = icmp eq i32 %38, 0
  br i1 %tobool.not.i.i.i, label %cond.false.i.i, label %cond.end.i.i

cond.false.i.i:                                   ; preds = %if.end.i.i
  tail call void @_serverAssert(ptr noundef nonnull @.str.138, ptr noundef nonnull @.str.18, i32 noundef 4866) #33
  tail call void @abort() #35
  unreachable

cond.end.i.i:                                     ; preds = %if.end.i.i
  %39 = trunc i32 %33 to i8
  %40 = xor i8 %39, -1
  %conv3.i9.i.i.i = and i8 %37, %40
  store i8 %conv3.i9.i.i.i, ptr %arrayidx.i.i.i.i, align 1
  %numslots.i.i.i = getelementptr inbounds %struct._clusterNode, ptr %36, i64 0, i32 8
  %41 = load i32, ptr %numslots.i.i.i, align 4
  %dec.i.i.i = add nsw i32 %41, -1
  store i32 %dec.i.i.i, ptr %numslots.i.i.i, align 4
  %42 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx5.i.i = getelementptr inbounds %struct.clusterState, ptr %42, i64 0, i32 9, i64 %indvars.iv.i
  store ptr null, ptr %arrayidx5.i.i, align 8
  %43 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %owner_not_claiming_slot.i.i = getelementptr inbounds %struct.clusterState, ptr %43, i64 0, i32 27
  %arrayidx.i.i5.i = getelementptr inbounds i8, ptr %owner_not_claiming_slot.i.i, i64 %conv.i.i.i
  %44 = load i8, ptr %arrayidx.i.i5.i, align 1
  %conv3.i.i6.i = and i8 %44, %40
  store i8 %conv3.i.i6.i, ptr %arrayidx.i.i5.i, align 1
  br label %for.inc.i

for.inc.i:                                        ; preds = %if.then.i, %cond.end.i.i, %for.body.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %exitcond.not.i = icmp eq i64 %indvars.iv.next.i, 16384
  br i1 %exitcond.not.i, label %clusterDelNodeSlots.exit, label %for.body.i, !llvm.loop !48

clusterDelNodeSlots.exit:                         ; preds = %for.inc.i
  %45 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i = getelementptr inbounds %struct.clusterState, ptr %45, i64 0, i32 22
  %46 = load i32, ptr %todo_before_sleep.i, align 8
  %or.i = or i32 %46, 6
  store i32 %or.i, ptr %todo_before_sleep.i, align 8
  %47 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef %c, ptr noundef %47) #33
  br label %return

if.else62:                                        ; preds = %land.lhs.true50, %if.else44
  %call66 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.220) #34
  %tobool67.not = icmp eq i32 %call66, 0
  br i1 %tobool67.not, label %land.lhs.true74, label %lor.lhs.false68

lor.lhs.false68:                                  ; preds = %if.else62
  %call72 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.221) #34
  %tobool73.not = icmp eq i32 %call72, 0
  br i1 %tobool73.not, label %land.lhs.true74, label %if.else112

land.lhs.true74:                                  ; preds = %lor.lhs.false68, %if.else62
  %argc75 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %48 = load i32, ptr %argc75, align 8
  %cmp76 = icmp sgt i32 %48, 2
  br i1 %cmp76, label %if.then78, label %if.else112

if.then78:                                        ; preds = %land.lhs.true74
  %call79 = tail call noalias dereferenceable_or_null(16384) ptr @zmalloc(i64 noundef 16384) #37
  %49 = load ptr, ptr %argv, align 8
  %arrayidx81 = getelementptr inbounds ptr, ptr %49, i64 1
  %50 = load ptr, ptr %arrayidx81, align 8
  %ptr82 = getelementptr inbounds %struct.redisObject, ptr %50, i64 0, i32 2
  %51 = load ptr, ptr %ptr82, align 8
  %call83 = tail call i32 @strcasecmp(ptr noundef %51, ptr noundef nonnull @.str.221) #34
  %call83.fr = freeze i32 %call83
  %tobool84.not = icmp eq i32 %call83.fr, 0
  %lnot.ext = zext i1 %tobool84.not to i32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(16384) %call79, i8 0, i64 16384, i1 false)
  %52 = load i32, ptr %argc75, align 8
  %cmp86451 = icmp sgt i32 %52, 2
  br i1 %cmp86451, label %for.body, label %for.end111

for.cond95.preheader:                             ; preds = %getSlotOrReply.exit
  %53 = icmp sgt i32 %65, 2
  br i1 %53, label %for.body99.lr.ph, label %for.end111

for.body99.lr.ph:                                 ; preds = %for.cond95.preheader
  br i1 %tobool84.not, label %for.body99.us, label %for.body99

for.body99.us:                                    ; preds = %for.body99.lr.ph, %for.inc.i249.us
  %indvars.iv480 = phi i64 [ %indvars.iv.next481, %for.inc.i249.us ], [ 2, %for.body99.lr.ph ]
  %54 = load ptr, ptr %argv, align 8
  %arrayidx102.us = getelementptr inbounds ptr, ptr %54, i64 %indvars.iv480
  %55 = load ptr, ptr %arrayidx102.us, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %slot.i233)
  %call.i234.us = call i32 @getLongLongFromObject(ptr noundef %55, ptr noundef nonnull %slot.i233) #33
  %cmp.i235.us = icmp ne i32 %call.i234.us, 0
  %56 = load i64, ptr %slot.i233, align 8
  %cmp1.i236.us = icmp slt i64 %56, 0
  %or.cond.i237.us = select i1 %cmp.i235.us, i1 true, i1 %cmp1.i236.us
  %cmp3.i238.us = icmp sgt i64 %56, 16383
  %or.cond1.i239.us = select i1 %or.cond.i237.us, i1 true, i1 %cmp3.i238.us
  br i1 %or.cond1.i239.us, label %if.then.i243.us, label %getSlotOrReply.exit244.us

if.then.i243.us:                                  ; preds = %for.body99.us
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.180) #33
  br label %getSlotOrReply.exit244.us

getSlotOrReply.exit244.us:                        ; preds = %for.body99.us, %if.then.i243.us
  %retval.0.i242.us = phi i64 [ -1, %if.then.i243.us ], [ %56, %for.body99.us ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i233)
  %57 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx.i.us = getelementptr inbounds %struct.clusterState, ptr %57, i64 0, i32 9, i64 %retval.0.i242.us
  %58 = load ptr, ptr %arrayidx.i.us, align 8
  %cmp2.i.us = icmp eq ptr %58, null
  br i1 %cmp2.i.us, label %if.then107, label %if.end10.i.us

if.end10.i.us:                                    ; preds = %getSlotOrReply.exit244.us
  %arrayidx12.i.us = getelementptr inbounds i8, ptr %call79, i64 %retval.0.i242.us
  %59 = load i8, ptr %arrayidx12.i.us, align 1
  %inc.i248.us = add i8 %59, 1
  store i8 %inc.i248.us, ptr %arrayidx12.i.us, align 1
  %cmp13.i.us = icmp eq i8 %59, 1
  br i1 %cmp13.i.us, label %if.then107, label %for.inc.i249.us

for.inc.i249.us:                                  ; preds = %if.end10.i.us
  %indvars.iv.next481 = add nuw nsw i64 %indvars.iv480, 1
  %60 = load i32, ptr %argc75, align 8
  %61 = sext i32 %60 to i64
  %cmp97.us = icmp slt i64 %indvars.iv.next481, %61
  br i1 %cmp97.us, label %for.body99.us, label %for.end111, !llvm.loop !85

for.body:                                         ; preds = %if.then78, %getSlotOrReply.exit
  %indvars.iv474 = phi i64 [ %indvars.iv.next475, %getSlotOrReply.exit ], [ 2, %if.then78 ]
  %62 = load ptr, ptr %argv, align 8
  %arrayidx89 = getelementptr inbounds ptr, ptr %62, i64 %indvars.iv474
  %63 = load ptr, ptr %arrayidx89, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %slot.i)
  %call.i = call i32 @getLongLongFromObject(ptr noundef %63, ptr noundef nonnull %slot.i) #33
  %cmp.i = icmp ne i32 %call.i, 0
  %64 = load i64, ptr %slot.i, align 8
  %cmp1.i = icmp slt i64 %64, 0
  %or.cond.i = select i1 %cmp.i, i1 true, i1 %cmp1.i
  %cmp3.i = icmp sgt i64 %64, 16383
  %or.cond1.i = select i1 %or.cond.i, i1 true, i1 %cmp3.i
  br i1 %or.cond1.i, label %getSlotOrReply.exit.thread, label %getSlotOrReply.exit

getSlotOrReply.exit.thread:                       ; preds = %for.body
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.180) #33
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i)
  call void @zfree(ptr noundef %call79) #33
  br label %return

getSlotOrReply.exit:                              ; preds = %for.body
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i)
  %indvars.iv.next475 = add nuw nsw i64 %indvars.iv474, 1
  %65 = load i32, ptr %argc75, align 8
  %66 = sext i32 %65 to i64
  %cmp86 = icmp slt i64 %indvars.iv.next475, %66
  br i1 %cmp86, label %for.body, label %for.cond95.preheader, !llvm.loop !86

for.body99:                                       ; preds = %for.body99.lr.ph, %for.inc.us.i
  %indvars.iv477 = phi i64 [ %indvars.iv.next478, %for.inc.us.i ], [ 2, %for.body99.lr.ph ]
  %67 = load ptr, ptr %argv, align 8
  %arrayidx102 = getelementptr inbounds ptr, ptr %67, i64 %indvars.iv477
  %68 = load ptr, ptr %arrayidx102, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %slot.i233)
  %call.i234 = call i32 @getLongLongFromObject(ptr noundef %68, ptr noundef nonnull %slot.i233) #33
  %cmp.i235 = icmp ne i32 %call.i234, 0
  %69 = load i64, ptr %slot.i233, align 8
  %cmp1.i236 = icmp slt i64 %69, 0
  %or.cond.i237 = select i1 %cmp.i235, i1 true, i1 %cmp1.i236
  %cmp3.i238 = icmp sgt i64 %69, 16383
  %or.cond1.i239 = select i1 %or.cond.i237, i1 true, i1 %cmp3.i238
  br i1 %or.cond1.i239, label %if.then.i243, label %getSlotOrReply.exit244

if.then.i243:                                     ; preds = %for.body99
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.180) #33
  br label %getSlotOrReply.exit244

getSlotOrReply.exit244:                           ; preds = %for.body99, %if.then.i243
  %retval.0.i242 = phi i64 [ -1, %if.then.i243 ], [ %69, %for.body99 ]
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i233)
  %70 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx7.us.i = getelementptr inbounds %struct.clusterState, ptr %70, i64 0, i32 9, i64 %retval.0.i242
  %71 = load ptr, ptr %arrayidx7.us.i, align 8
  %tobool8.not.us.i = icmp eq ptr %71, null
  br i1 %tobool8.not.us.i, label %if.end10.us.i, label %if.then107

if.end10.us.i:                                    ; preds = %getSlotOrReply.exit244
  %arrayidx12.us.i = getelementptr inbounds i8, ptr %call79, i64 %retval.0.i242
  %72 = load i8, ptr %arrayidx12.us.i, align 1
  %inc.us.i = add i8 %72, 1
  store i8 %inc.us.i, ptr %arrayidx12.us.i, align 1
  %cmp13.us.i = icmp eq i8 %72, 1
  br i1 %cmp13.us.i, label %if.then107, label %for.inc.us.i

for.inc.us.i:                                     ; preds = %if.end10.us.i
  %indvars.iv.next478 = add nuw nsw i64 %indvars.iv477, 1
  %73 = load i32, ptr %argc75, align 8
  %74 = sext i32 %73 to i64
  %cmp97 = icmp slt i64 %indvars.iv.next478, %74
  br i1 %cmp97, label %for.body99, label %for.end111, !llvm.loop !85

if.then107:                                       ; preds = %if.end10.us.i, %getSlotOrReply.exit244, %if.end10.i.us, %getSlotOrReply.exit244.us
  %.us-phi16.in.sink.i = phi i64 [ %retval.0.i242.us, %getSlotOrReply.exit244.us ], [ %retval.0.i242.us, %if.end10.i.us ], [ %retval.0.i242, %getSlotOrReply.exit244 ], [ %retval.0.i242, %if.end10.us.i ]
  %.str.183.sink.i = phi ptr [ @.str.183, %if.end10.i.us ], [ @.str.181, %getSlotOrReply.exit244.us ], [ @.str.183, %if.end10.us.i ], [ @.str.182, %getSlotOrReply.exit244 ]
  %.us-phi16.i = trunc i64 %.us-phi16.in.sink.i to i32
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull %.str.183.sink.i, i32 noundef %.us-phi16.i) #33
  call void @zfree(ptr noundef %call79) #33
  br label %return

for.end111:                                       ; preds = %for.inc.us.i, %for.inc.i249.us, %if.then78, %for.cond95.preheader
  call void @clusterUpdateSlots(ptr noundef nonnull %c, ptr noundef %call79, i32 noundef %lnot.ext)
  call void @zfree(ptr noundef %call79) #33
  %75 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i253 = getelementptr inbounds %struct.clusterState, ptr %75, i64 0, i32 22
  %76 = load i32, ptr %todo_before_sleep.i253, align 8
  %or.i254 = or i32 %76, 6
  store i32 %or.i254, ptr %todo_before_sleep.i253, align 8
  %77 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef nonnull %c, ptr noundef %77) #33
  br label %return

if.else112:                                       ; preds = %land.lhs.true74, %lor.lhs.false68
  %call116 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.222) #34
  %tobool117.not = icmp eq i32 %call116, 0
  br i1 %tobool117.not, label %land.lhs.true124, label %lor.lhs.false118

lor.lhs.false118:                                 ; preds = %if.else112
  %call122 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.223) #34
  %tobool123.not = icmp eq i32 %call122, 0
  br i1 %tobool123.not, label %land.lhs.true124, label %if.else179

land.lhs.true124:                                 ; preds = %lor.lhs.false118, %if.else112
  %argc125 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %78 = load i32, ptr %argc125, align 8
  %cmp126 = icmp sgt i32 %78, 3
  br i1 %cmp126, label %if.then128, label %if.else179

if.then128:                                       ; preds = %land.lhs.true124
  %rem = and i32 %78, 1
  %cmp130.not = icmp eq i32 %rem, 0
  br i1 %cmp130.not, label %if.end133, label %if.then132

if.then132:                                       ; preds = %if.then128
  tail call void @addReplyErrorArity(ptr noundef nonnull %c) #33
  br label %return

if.end133:                                        ; preds = %if.then128
  %call136 = tail call noalias dereferenceable_or_null(16384) ptr @zmalloc(i64 noundef 16384) #37
  %79 = load ptr, ptr %argv, align 8
  %arrayidx139 = getelementptr inbounds ptr, ptr %79, i64 1
  %80 = load ptr, ptr %arrayidx139, align 8
  %ptr140 = getelementptr inbounds %struct.redisObject, ptr %80, i64 0, i32 2
  %81 = load ptr, ptr %ptr140, align 8
  %call141 = tail call i32 @strcasecmp(ptr noundef %81, ptr noundef nonnull @.str.223) #34
  %tobool142.not = icmp eq i32 %call141, 0
  %lnot.ext144 = zext i1 %tobool142.not to i32
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 1 dereferenceable(16384) %call136, i8 0, i64 16384, i1 false)
  %82 = load i32, ptr %argc125, align 8
  %cmp147449 = icmp sgt i32 %82, 2
  br i1 %cmp147449, label %for.body149, label %for.end178

for.body149:                                      ; preds = %if.end133, %for.inc176
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc176 ], [ 2, %if.end133 ]
  %83 = load ptr, ptr %argv, align 8
  %arrayidx152 = getelementptr inbounds ptr, ptr %83, i64 %indvars.iv
  %84 = load ptr, ptr %arrayidx152, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %slot.i255)
  %call.i256 = call i32 @getLongLongFromObject(ptr noundef %84, ptr noundef nonnull %slot.i255) #33
  %cmp.i257 = icmp ne i32 %call.i256, 0
  %85 = load i64, ptr %slot.i255, align 8
  %cmp1.i258 = icmp slt i64 %85, 0
  %or.cond.i259 = select i1 %cmp.i257, i1 true, i1 %cmp1.i258
  %cmp3.i260 = icmp sgt i64 %85, 16383
  %or.cond1.i261 = select i1 %or.cond.i259, i1 true, i1 %cmp3.i260
  br i1 %or.cond1.i261, label %getSlotOrReply.exit266.thread, label %getSlotOrReply.exit266

getSlotOrReply.exit266.thread:                    ; preds = %for.body149
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.180) #33
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i255)
  call void @zfree(ptr noundef nonnull %call136) #33
  br label %return

getSlotOrReply.exit266:                           ; preds = %for.body149
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i255)
  %86 = load ptr, ptr %argv, align 8
  %87 = or disjoint i64 %indvars.iv, 1
  %arrayidx161 = getelementptr inbounds ptr, ptr %86, i64 %87
  %88 = load ptr, ptr %arrayidx161, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %slot.i267)
  %call.i268 = call i32 @getLongLongFromObject(ptr noundef %88, ptr noundef nonnull %slot.i267) #33
  %cmp.i269 = icmp ne i32 %call.i268, 0
  %89 = load i64, ptr %slot.i267, align 8
  %cmp1.i270 = icmp slt i64 %89, 0
  %or.cond.i271 = select i1 %cmp.i269, i1 true, i1 %cmp1.i270
  %cmp3.i272 = icmp sgt i64 %89, 16383
  %or.cond1.i273 = select i1 %or.cond.i271, i1 true, i1 %cmp3.i272
  br i1 %or.cond1.i273, label %getSlotOrReply.exit278.thread, label %getSlotOrReply.exit278

getSlotOrReply.exit278.thread:                    ; preds = %getSlotOrReply.exit266
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.180) #33
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i267)
  call void @zfree(ptr noundef nonnull %call136) #33
  br label %return

getSlotOrReply.exit278:                           ; preds = %getSlotOrReply.exit266
  %conv.i263 = trunc i64 %85 to i32
  %conv.i275 = trunc i64 %89 to i32
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i267)
  %cmp167 = icmp ugt i32 %conv.i263, %conv.i275
  br i1 %cmp167, label %if.then169, label %for.body.lr.ph.i

if.then169:                                       ; preds = %getSlotOrReply.exit278
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.224, i32 noundef %conv.i263, i32 noundef %conv.i275) #33
  call void @zfree(ptr noundef nonnull %call136) #33
  br label %return

for.body.lr.ph.i:                                 ; preds = %getSlotOrReply.exit278
  %90 = add nuw nsw i32 %conv.i275, 1
  %91 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br i1 %tobool142.not, label %for.body.i280, label %for.body.us.i297

for.body.us.i297:                                 ; preds = %for.body.lr.ph.i, %for.inc.us.i305
  %indvars.iv24.i298 = phi i64 [ %indvars.iv.next25.i306, %for.inc.us.i305 ], [ %85, %for.body.lr.ph.i ]
  %arrayidx7.us.i299 = getelementptr inbounds %struct.clusterState, ptr %91, i64 0, i32 9, i64 %indvars.iv24.i298
  %92 = load ptr, ptr %arrayidx7.us.i299, align 8
  %tobool8.not.us.i300 = icmp eq ptr %92, null
  br i1 %tobool8.not.us.i300, label %if.end10.us.i301, label %if.then174

if.end10.us.i301:                                 ; preds = %for.body.us.i297
  %arrayidx12.us.i302 = getelementptr inbounds i8, ptr %call136, i64 %indvars.iv24.i298
  %93 = load i8, ptr %arrayidx12.us.i302, align 1
  %inc.us.i303 = add i8 %93, 1
  store i8 %inc.us.i303, ptr %arrayidx12.us.i302, align 1
  %cmp13.us.i304 = icmp eq i8 %93, 1
  br i1 %cmp13.us.i304, label %if.then174, label %for.inc.us.i305

for.inc.us.i305:                                  ; preds = %if.end10.us.i301
  %indvars.iv.next25.i306 = add nuw nsw i64 %indvars.iv24.i298, 1
  %lftr.wideiv27.i307 = trunc i64 %indvars.iv.next25.i306 to i32
  %exitcond28.not.i308 = icmp eq i32 %90, %lftr.wideiv27.i307
  br i1 %exitcond28.not.i308, label %for.inc176, label %for.body.us.i297, !llvm.loop !74

for.body.i280:                                    ; preds = %for.body.lr.ph.i, %for.inc.i288
  %indvars.iv.i281 = phi i64 [ %indvars.iv.next.i289, %for.inc.i288 ], [ %85, %for.body.lr.ph.i ]
  %arrayidx.i282 = getelementptr inbounds %struct.clusterState, ptr %91, i64 0, i32 9, i64 %indvars.iv.i281
  %94 = load ptr, ptr %arrayidx.i282, align 8
  %cmp2.i283 = icmp eq ptr %94, null
  br i1 %cmp2.i283, label %if.then174, label %if.end10.i284

if.end10.i284:                                    ; preds = %for.body.i280
  %arrayidx12.i285 = getelementptr inbounds i8, ptr %call136, i64 %indvars.iv.i281
  %95 = load i8, ptr %arrayidx12.i285, align 1
  %inc.i286 = add i8 %95, 1
  store i8 %inc.i286, ptr %arrayidx12.i285, align 1
  %cmp13.i287 = icmp eq i8 %95, 1
  br i1 %cmp13.i287, label %if.then174, label %for.inc.i288

for.inc.i288:                                     ; preds = %if.end10.i284
  %indvars.iv.next.i289 = add nuw nsw i64 %indvars.iv.i281, 1
  %lftr.wideiv.i290 = trunc i64 %indvars.iv.next.i289 to i32
  %exitcond.not.i291 = icmp eq i32 %90, %lftr.wideiv.i290
  br i1 %exitcond.not.i291, label %for.inc176, label %for.body.i280, !llvm.loop !74

if.then174:                                       ; preds = %if.end10.us.i301, %for.body.us.i297, %if.end10.i284, %for.body.i280
  %.us-phi16.in.sink.i294 = phi i64 [ %indvars.iv.i281, %for.body.i280 ], [ %indvars.iv.i281, %if.end10.i284 ], [ %indvars.iv24.i298, %for.body.us.i297 ], [ %indvars.iv24.i298, %if.end10.us.i301 ]
  %.str.183.sink.i295 = phi ptr [ @.str.183, %if.end10.i284 ], [ @.str.181, %for.body.i280 ], [ @.str.183, %if.end10.us.i301 ], [ @.str.182, %for.body.us.i297 ]
  %.us-phi16.i296 = trunc i64 %.us-phi16.in.sink.i294 to i32
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %c, ptr noundef nonnull %.str.183.sink.i295, i32 noundef %.us-phi16.i296) #33
  call void @zfree(ptr noundef %call136) #33
  br label %return

for.inc176:                                       ; preds = %for.inc.us.i305, %for.inc.i288
  %indvars.iv.next = add nuw i64 %indvars.iv, 2
  %96 = load i32, ptr %argc125, align 8
  %97 = trunc i64 %indvars.iv.next to i32
  %cmp147 = icmp sgt i32 %96, %97
  br i1 %cmp147, label %for.body149, label %for.end178, !llvm.loop !87

for.end178:                                       ; preds = %for.inc176, %if.end133
  call void @clusterUpdateSlots(ptr noundef nonnull %c, ptr noundef nonnull %call136, i32 noundef %lnot.ext144)
  call void @zfree(ptr noundef nonnull %call136) #33
  %98 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i310 = getelementptr inbounds %struct.clusterState, ptr %98, i64 0, i32 22
  %99 = load i32, ptr %todo_before_sleep.i310, align 8
  %or.i311 = or i32 %99, 6
  store i32 %or.i311, ptr %todo_before_sleep.i310, align 8
  %100 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef nonnull %c, ptr noundef %100) #33
  br label %return

if.else179:                                       ; preds = %land.lhs.true124, %lor.lhs.false118
  %call183 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.225) #34
  %tobool184.not = icmp eq i32 %call183, 0
  br i1 %tobool184.not, label %land.lhs.true185, label %if.else408

land.lhs.true185:                                 ; preds = %if.else179
  %argc186 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %101 = load i32, ptr %argc186, align 8
  %cmp187 = icmp sgt i32 %101, 3
  br i1 %cmp187, label %if.then189, label %if.else408

if.then189:                                       ; preds = %land.lhs.true185
  %102 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %102, i64 0, i32 3
  %103 = load i32, ptr %flags, align 8
  %and = and i32 %103, 2
  %tobool191.not = icmp eq i32 %and, 0
  br i1 %tobool191.not, label %if.end193, label %if.then192

if.then192:                                       ; preds = %if.then189
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.226) #33
  br label %return

if.end193:                                        ; preds = %if.then189
  %arrayidx195 = getelementptr inbounds ptr, ptr %0, i64 2
  %104 = load ptr, ptr %arrayidx195, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %slot.i312)
  %call.i313 = call i32 @getLongLongFromObject(ptr noundef %104, ptr noundef nonnull %slot.i312) #33
  %cmp.i314 = icmp ne i32 %call.i313, 0
  %105 = load i64, ptr %slot.i312, align 8
  %cmp1.i315 = icmp slt i64 %105, 0
  %or.cond.i316 = select i1 %cmp.i314, i1 true, i1 %cmp1.i315
  %cmp3.i317 = icmp sgt i64 %105, 16383
  %or.cond1.i318 = select i1 %or.cond.i316, i1 true, i1 %cmp3.i317
  br i1 %or.cond1.i318, label %getSlotOrReply.exit323.thread, label %getSlotOrReply.exit323

getSlotOrReply.exit323.thread:                    ; preds = %if.end193
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.180) #33
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i312)
  br label %return

getSlotOrReply.exit323:                           ; preds = %if.end193
  %conv.i320 = trunc i64 %105 to i32
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %slot.i312)
  %106 = load ptr, ptr %argv, align 8
  %arrayidx202 = getelementptr inbounds ptr, ptr %106, i64 3
  %107 = load ptr, ptr %arrayidx202, align 8
  %ptr203 = getelementptr inbounds %struct.redisObject, ptr %107, i64 0, i32 2
  %108 = load ptr, ptr %ptr203, align 8
  %call204 = call i32 @strcasecmp(ptr noundef %108, ptr noundef nonnull @.str.227) #34
  %tobool205.not = icmp eq i32 %call204, 0
  br i1 %tobool205.not, label %land.lhs.true206, label %if.else241

land.lhs.true206:                                 ; preds = %getSlotOrReply.exit323
  %109 = load i32, ptr %argc186, align 8
  %cmp208 = icmp eq i32 %109, 5
  br i1 %cmp208, label %if.then210, label %if.else241

if.then210:                                       ; preds = %land.lhs.true206
  %110 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx213 = getelementptr inbounds %struct.clusterState, ptr %110, i64 0, i32 9, i64 %105
  %111 = load ptr, ptr %arrayidx213, align 8
  %112 = load ptr, ptr @myself, align 8
  %cmp214.not = icmp eq ptr %111, %112
  br i1 %cmp214.not, label %if.end217, label %if.then216

if.then216:                                       ; preds = %if.then210
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.228, i32 noundef %conv.i320) #33
  br label %return

if.end217:                                        ; preds = %if.then210
  %arrayidx219 = getelementptr inbounds ptr, ptr %106, i64 4
  %113 = load ptr, ptr %arrayidx219, align 8
  %ptr220 = getelementptr inbounds %struct.redisObject, ptr %113, i64 0, i32 2
  %114 = load ptr, ptr %ptr220, align 8
  %call224 = call fastcc i64 @sdslen(ptr noundef %114)
  %conv225 = trunc i64 %call224 to i32
  %call226 = call ptr @clusterLookupNode(ptr noundef %114, i32 noundef %conv225)
  %cmp227 = icmp eq ptr %call226, null
  br i1 %cmp227, label %if.then229, label %if.end233

if.then229:                                       ; preds = %if.end217
  %115 = load ptr, ptr %argv, align 8
  %arrayidx231 = getelementptr inbounds ptr, ptr %115, i64 4
  %116 = load ptr, ptr %arrayidx231, align 8
  %ptr232 = getelementptr inbounds %struct.redisObject, ptr %116, i64 0, i32 2
  %117 = load ptr, ptr %ptr232, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.229, ptr noundef %117) #33
  br label %return

if.end233:                                        ; preds = %if.end217
  %flags234 = getelementptr inbounds %struct._clusterNode, ptr %call226, i64 0, i32 3
  %118 = load i32, ptr %flags234, align 8
  %and235 = and i32 %118, 2
  %tobool236.not = icmp eq i32 %and235, 0
  br i1 %tobool236.not, label %if.end238, label %if.then237

if.then237:                                       ; preds = %if.end233
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.230) #33
  br label %return

if.end238:                                        ; preds = %if.end233
  %119 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx240 = getelementptr inbounds %struct.clusterState, ptr %119, i64 0, i32 7, i64 %105
  store ptr %call226, ptr %arrayidx240, align 8
  br label %if.end407

if.else241:                                       ; preds = %land.lhs.true206, %getSlotOrReply.exit323
  %call245 = call i32 @strcasecmp(ptr noundef %108, ptr noundef nonnull @.str.231) #34
  %tobool246.not = icmp eq i32 %call245, 0
  br i1 %tobool246.not, label %land.lhs.true247, label %if.else282

land.lhs.true247:                                 ; preds = %if.else241
  %120 = load i32, ptr %argc186, align 8
  %cmp249 = icmp eq i32 %120, 5
  br i1 %cmp249, label %if.then251, label %if.else282

if.then251:                                       ; preds = %land.lhs.true247
  %121 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx254 = getelementptr inbounds %struct.clusterState, ptr %121, i64 0, i32 9, i64 %105
  %122 = load ptr, ptr %arrayidx254, align 8
  %123 = load ptr, ptr @myself, align 8
  %cmp255 = icmp eq ptr %122, %123
  br i1 %cmp255, label %if.then257, label %if.end258

if.then257:                                       ; preds = %if.then251
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.232, i32 noundef %conv.i320) #33
  br label %return

if.end258:                                        ; preds = %if.then251
  %arrayidx260 = getelementptr inbounds ptr, ptr %106, i64 4
  %124 = load ptr, ptr %arrayidx260, align 8
  %ptr261 = getelementptr inbounds %struct.redisObject, ptr %124, i64 0, i32 2
  %125 = load ptr, ptr %ptr261, align 8
  %call265 = call fastcc i64 @sdslen(ptr noundef %125)
  %conv266 = trunc i64 %call265 to i32
  %call267 = call ptr @clusterLookupNode(ptr noundef %125, i32 noundef %conv266)
  %cmp268 = icmp eq ptr %call267, null
  br i1 %cmp268, label %if.then270, label %if.end274

if.then270:                                       ; preds = %if.end258
  %126 = load ptr, ptr %argv, align 8
  %arrayidx272 = getelementptr inbounds ptr, ptr %126, i64 4
  %127 = load ptr, ptr %arrayidx272, align 8
  %ptr273 = getelementptr inbounds %struct.redisObject, ptr %127, i64 0, i32 2
  %128 = load ptr, ptr %ptr273, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.229, ptr noundef %128) #33
  br label %return

if.end274:                                        ; preds = %if.end258
  %flags275 = getelementptr inbounds %struct._clusterNode, ptr %call267, i64 0, i32 3
  %129 = load i32, ptr %flags275, align 8
  %and276 = and i32 %129, 2
  %tobool277.not = icmp eq i32 %and276, 0
  br i1 %tobool277.not, label %if.end279, label %if.then278

if.then278:                                       ; preds = %if.end274
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.230) #33
  br label %return

if.end279:                                        ; preds = %if.end274
  %130 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx281 = getelementptr inbounds %struct.clusterState, ptr %130, i64 0, i32 8, i64 %105
  store ptr %call267, ptr %arrayidx281, align 8
  br label %if.end407

if.else282:                                       ; preds = %land.lhs.true247, %if.else241
  %call286 = call i32 @strcasecmp(ptr noundef %108, ptr noundef nonnull @.str.233) #34
  %tobool287.not = icmp eq i32 %call286, 0
  br i1 %tobool287.not, label %land.lhs.true288, label %if.else299

land.lhs.true288:                                 ; preds = %if.else282
  %131 = load i32, ptr %argc186, align 8
  %cmp290 = icmp eq i32 %131, 4
  br i1 %cmp290, label %if.then292, label %if.else299

if.then292:                                       ; preds = %land.lhs.true288
  %132 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx295 = getelementptr inbounds %struct.clusterState, ptr %132, i64 0, i32 8, i64 %105
  store ptr null, ptr %arrayidx295, align 8
  %133 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx298 = getelementptr inbounds %struct.clusterState, ptr %133, i64 0, i32 7, i64 %105
  store ptr null, ptr %arrayidx298, align 8
  br label %if.end407

if.else299:                                       ; preds = %land.lhs.true288, %if.else282
  %call303 = call i32 @strcasecmp(ptr noundef %108, ptr noundef nonnull @.str.164) #34
  %tobool304.not = icmp eq i32 %call303, 0
  br i1 %tobool304.not, label %land.lhs.true305, label %if.else403

land.lhs.true305:                                 ; preds = %if.else299
  %134 = load i32, ptr %argc186, align 8
  %cmp307 = icmp eq i32 %134, 5
  br i1 %cmp307, label %if.then309, label %if.else403

if.then309:                                       ; preds = %land.lhs.true305
  %arrayidx311 = getelementptr inbounds ptr, ptr %106, i64 4
  %135 = load ptr, ptr %arrayidx311, align 8
  %ptr312 = getelementptr inbounds %struct.redisObject, ptr %135, i64 0, i32 2
  %136 = load ptr, ptr %ptr312, align 8
  %call316 = call fastcc i64 @sdslen(ptr noundef %136)
  %conv317 = trunc i64 %call316 to i32
  %call318 = call ptr @clusterLookupNode(ptr noundef %136, i32 noundef %conv317)
  %tobool319.not = icmp eq ptr %call318, null
  br i1 %tobool319.not, label %if.then320, label %if.end324

if.then320:                                       ; preds = %if.then309
  %137 = load ptr, ptr %argv, align 8
  %arrayidx322 = getelementptr inbounds ptr, ptr %137, i64 4
  %138 = load ptr, ptr %arrayidx322, align 8
  %ptr323 = getelementptr inbounds %struct.redisObject, ptr %138, i64 0, i32 2
  %139 = load ptr, ptr %ptr323, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.210, ptr noundef %139) #33
  br label %return

if.end324:                                        ; preds = %if.then309
  %flags325 = getelementptr inbounds %struct._clusterNode, ptr %call318, i64 0, i32 3
  %140 = load i32, ptr %flags325, align 8
  %and326 = and i32 %140, 2
  %tobool327.not = icmp eq i32 %and326, 0
  br i1 %tobool327.not, label %if.end329, label %if.then328

if.then328:                                       ; preds = %if.end324
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.230) #33
  br label %return

if.end329:                                        ; preds = %if.end324
  %141 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx332 = getelementptr inbounds %struct.clusterState, ptr %141, i64 0, i32 9, i64 %105
  %142 = load ptr, ptr %arrayidx332, align 8
  %143 = load ptr, ptr @myself, align 8
  %cmp333 = icmp ne ptr %142, %143
  %cmp336.not = icmp eq ptr %call318, %143
  %or.cond227 = or i1 %cmp333, %cmp336.not
  br i1 %or.cond227, label %if.end344, label %if.then338

if.then338:                                       ; preds = %if.end329
  %call339 = call i32 @countKeysInSlot(i32 noundef %conv.i320) #33
  %cmp340.not = icmp eq i32 %call339, 0
  br i1 %cmp340.not, label %if.end344, label %if.then342

if.then342:                                       ; preds = %if.then338
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.234, i32 noundef %conv.i320) #33
  br label %return

if.end344:                                        ; preds = %if.then338, %if.end329
  %call345 = call i32 @countKeysInSlot(i32 noundef %conv.i320) #33
  %cmp346 = icmp eq i32 %call345, 0
  %.pre486 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br i1 %cmp346, label %land.lhs.true348, label %if.end357

land.lhs.true348:                                 ; preds = %if.end344
  %arrayidx351 = getelementptr inbounds %struct.clusterState, ptr %.pre486, i64 0, i32 7, i64 %105
  %144 = load ptr, ptr %arrayidx351, align 8
  %tobool352.not = icmp eq ptr %144, null
  br i1 %tobool352.not, label %if.end357, label %if.then353

if.then353:                                       ; preds = %land.lhs.true348
  store ptr null, ptr %arrayidx351, align 8
  %.pre485 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end357

if.end357:                                        ; preds = %if.then353, %land.lhs.true348, %if.end344
  %145 = phi ptr [ %.pre485, %if.then353 ], [ %.pre486, %land.lhs.true348 ], [ %.pre486, %if.end344 ]
  %arrayidx360 = getelementptr inbounds %struct.clusterState, ptr %145, i64 0, i32 9, i64 %105
  %146 = load ptr, ptr %arrayidx360, align 8
  %147 = load ptr, ptr @myself, align 8
  %cmp361 = icmp eq ptr %146, %147
  %call363 = call i32 @clusterDelSlot(i32 noundef %conv.i320), !range !21
  %148 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx.i324 = getelementptr inbounds %struct.clusterState, ptr %148, i64 0, i32 9, i64 %105
  %149 = load ptr, ptr %arrayidx.i324, align 8
  %tobool.not.i325 = icmp eq ptr %149, null
  br i1 %tobool.not.i325, label %if.end.i327, label %clusterAddSlot.exit

if.end.i327:                                      ; preds = %if.end357
  %call.i328 = call i32 @clusterNodeSetSlotBit(ptr noundef nonnull %call318, i32 noundef %conv.i320), !range !18
  %150 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx3.i = getelementptr inbounds %struct.clusterState, ptr %150, i64 0, i32 9, i64 %105
  store ptr %call318, ptr %arrayidx3.i, align 8
  br label %clusterAddSlot.exit

clusterAddSlot.exit:                              ; preds = %if.end357, %if.end.i327
  %.pre488 = load ptr, ptr @myself, align 8
  br i1 %cmp361, label %land.lhs.true366, label %if.end379

land.lhs.true366:                                 ; preds = %clusterAddSlot.exit
  %cmp367.not = icmp eq ptr %call318, %.pre488
  br i1 %cmp367.not, label %land.lhs.true382, label %land.lhs.true369

land.lhs.true369:                                 ; preds = %land.lhs.true366
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %.pre488, i64 0, i32 8
  %151 = load i32, ptr %numslots, align 4
  %cmp370 = icmp eq i32 %151, 0
  %152 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 369), align 4
  %tobool373 = icmp ne i32 %152, 0
  %or.cond = select i1 %cmp370, i1 %tobool373, i1 false
  br i1 %or.cond, label %do.body, label %if.end379

do.body:                                          ; preds = %land.lhs.true369
  %153 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp375 = icmp sgt i32 %153, 2
  br i1 %cmp375, label %do.end, label %if.end378

if.end378:                                        ; preds = %do.body
  %name = getelementptr inbounds %struct._clusterNode, ptr %call318, i64 0, i32 1
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %call318, i64 0, i32 23
  %154 = load ptr, ptr %human_nodename, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.78, ptr noundef nonnull %name, ptr noundef %154) #33
  br label %do.end

do.end:                                           ; preds = %do.body, %if.end378
  call void @clusterSetMaster(ptr noundef nonnull %call318)
  %155 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i329 = getelementptr inbounds %struct.clusterState, ptr %155, i64 0, i32 22
  %156 = load i32, ptr %todo_before_sleep.i329, align 8
  %or.i330 = or i32 %156, 14
  store i32 %or.i330, ptr %todo_before_sleep.i329, align 8
  %.pre487 = load ptr, ptr @myself, align 8
  br label %if.end379

if.end379:                                        ; preds = %do.end, %land.lhs.true369, %clusterAddSlot.exit
  %157 = phi ptr [ %.pre487, %do.end ], [ %.pre488, %land.lhs.true369 ], [ %.pre488, %clusterAddSlot.exit ]
  %cmp380 = icmp eq ptr %call318, %157
  br i1 %cmp380, label %land.lhs.true382, label %if.end407

land.lhs.true382:                                 ; preds = %land.lhs.true366, %if.end379
  %158 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx385 = getelementptr inbounds %struct.clusterState, ptr %158, i64 0, i32 8, i64 %105
  %159 = load ptr, ptr %arrayidx385, align 8
  %tobool386.not = icmp eq ptr %159, null
  br i1 %tobool386.not, label %if.end407, label %if.then387

if.then387:                                       ; preds = %land.lhs.true382
  %call388 = call i32 @clusterBumpConfigEpochWithoutConsensus(), !range !21
  %cmp389 = icmp ne i32 %call388, 0
  %160 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp393 = icmp sgt i32 %160, 2
  %or.cond1 = select i1 %cmp389, i1 true, i1 %cmp393
  br i1 %or.cond1, label %if.end398, label %if.end396

if.end396:                                        ; preds = %if.then387
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.235, i32 noundef %conv.i320) #33
  br label %if.end398

if.end398:                                        ; preds = %if.end396, %if.then387
  %161 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %arrayidx401 = getelementptr inbounds %struct.clusterState, ptr %161, i64 0, i32 8, i64 %105
  store ptr null, ptr %arrayidx401, align 8
  call void @clusterBroadcastPong(i32 noundef 0)
  br label %if.end407

if.else403:                                       ; preds = %land.lhs.true305, %if.else299
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.236) #33
  br label %return

if.end407:                                        ; preds = %if.end279, %if.end398, %land.lhs.true382, %if.end379, %if.then292, %if.end238
  %162 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i331 = getelementptr inbounds %struct.clusterState, ptr %162, i64 0, i32 22
  %163 = load i32, ptr %todo_before_sleep.i331, align 8
  %or.i332 = or i32 %163, 6
  store i32 %or.i332, ptr %todo_before_sleep.i331, align 8
  %164 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef nonnull %c, ptr noundef %164) #33
  br label %return

if.else408:                                       ; preds = %land.lhs.true185, %if.else179
  %call412 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.237) #34
  %tobool413.not = icmp eq i32 %call412, 0
  br i1 %tobool413.not, label %land.lhs.true414, label %if.else425

land.lhs.true414:                                 ; preds = %if.else408
  %argc415 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %165 = load i32, ptr %argc415, align 8
  %cmp416 = icmp eq i32 %165, 2
  br i1 %cmp416, label %if.then418, label %if.else425

if.then418:                                       ; preds = %land.lhs.true414
  %call420 = tail call i32 @clusterBumpConfigEpochWithoutConsensus(), !range !21
  %call421 = tail call ptr @sdsempty() #33
  %cmp422 = icmp eq i32 %call420, 0
  %cond = select i1 %cmp422, ptr @.str.239, ptr @.str.240
  %166 = load ptr, ptr @myself, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %166, i64 0, i32 4
  %167 = load i64, ptr %configEpoch, align 8
  %call424 = tail call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call421, ptr noundef nonnull @.str.238, ptr noundef nonnull %cond, i64 noundef %167) #33
  tail call void @addReplySds(ptr noundef nonnull %c, ptr noundef %call424) #33
  br label %return

if.else425:                                       ; preds = %land.lhs.true414, %if.else408
  %call429 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.241) #34
  %tobool430.not = icmp eq i32 %call429, 0
  br i1 %tobool430.not, label %land.lhs.true431, label %if.else445

land.lhs.true431:                                 ; preds = %if.else425
  %argc432 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %168 = load i32, ptr %argc432, align 8
  %cmp433 = icmp eq i32 %168, 2
  br i1 %cmp433, label %if.then435, label %if.else445

if.then435:                                       ; preds = %land.lhs.true431
  %call437 = tail call i32 @clusterSaveConfig(i32 noundef 1), !range !21
  %cmp438 = icmp eq i32 %call437, 0
  br i1 %cmp438, label %if.then440, label %if.else441

if.then440:                                       ; preds = %if.then435
  %169 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %169) #33
  br label %return

if.else441:                                       ; preds = %if.then435
  %call442 = tail call ptr @__errno_location() #36
  %170 = load i32, ptr %call442, align 4
  %call443 = tail call ptr @strerror(i32 noundef %170) #33
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.242, ptr noundef %call443) #33
  br label %return

if.else445:                                       ; preds = %land.lhs.true431, %if.else425
  %call449 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.243) #34
  %tobool450.not = icmp eq i32 %call449, 0
  br i1 %tobool450.not, label %land.lhs.true451, label %if.else494

land.lhs.true451:                                 ; preds = %if.else445
  %argc452 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %171 = load i32, ptr %argc452, align 8
  %cmp453 = icmp eq i32 %171, 3
  br i1 %cmp453, label %if.then455, label %if.else494

if.then455:                                       ; preds = %land.lhs.true451
  %arrayidx458 = getelementptr inbounds ptr, ptr %0, i64 2
  %172 = load ptr, ptr %arrayidx458, align 8
  %ptr459 = getelementptr inbounds %struct.redisObject, ptr %172, i64 0, i32 2
  %173 = load ptr, ptr %ptr459, align 8
  %arrayidx.i333 = getelementptr inbounds i8, ptr %173, i64 -1
  %174 = load i8, ptr %arrayidx.i333, align 1
  %conv.i334 = zext i8 %174 to i32
  %and.i = and i32 %conv.i334, 7
  switch i32 %and.i, label %sdslen.exit [
    i32 0, label %sw.bb.i
    i32 1, label %sw.bb3.i
    i32 2, label %sw.bb5.i
    i32 3, label %sw.bb9.i
    i32 4, label %sw.bb13.i
  ]

sw.bb.i:                                          ; preds = %if.then455
  %shr.i = lshr i32 %conv.i334, 3
  %conv2.i = zext nneg i32 %shr.i to i64
  br label %sdslen.exit

sw.bb3.i:                                         ; preds = %if.then455
  %add.ptr.i = getelementptr inbounds i8, ptr %173, i64 -3
  %175 = load i8, ptr %add.ptr.i, align 1
  %conv4.i = zext i8 %175 to i64
  br label %sdslen.exit

sw.bb5.i:                                         ; preds = %if.then455
  %add.ptr6.i = getelementptr inbounds i8, ptr %173, i64 -5
  %176 = load i16, ptr %add.ptr6.i, align 1
  %conv8.i = zext i16 %176 to i64
  br label %sdslen.exit

sw.bb9.i:                                         ; preds = %if.then455
  %add.ptr10.i = getelementptr inbounds i8, ptr %173, i64 -9
  %177 = load i32, ptr %add.ptr10.i, align 1
  %conv12.i = zext i32 %177 to i64
  br label %sdslen.exit

sw.bb13.i:                                        ; preds = %if.then455
  %add.ptr14.i = getelementptr inbounds i8, ptr %173, i64 -17
  %178 = load i64, ptr %add.ptr14.i, align 1
  br label %sdslen.exit

sdslen.exit:                                      ; preds = %if.then455, %sw.bb.i, %sw.bb3.i, %sw.bb5.i, %sw.bb9.i, %sw.bb13.i
  %retval.0.i335 = phi i64 [ %178, %sw.bb13.i ], [ %conv12.i, %sw.bb9.i ], [ %conv8.i, %sw.bb5.i ], [ %conv4.i, %sw.bb3.i ], [ %conv2.i, %sw.bb.i ], [ 0, %if.then455 ]
  %conv464 = trunc i64 %retval.0.i335 to i32
  %call.i336 = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %173, i32 noundef %conv464) #33
  %cmp.not.i = icmp eq i32 %call.i336, 0
  br i1 %cmp.not.i, label %if.end.i338, label %if.then467

if.end.i338:                                      ; preds = %sdslen.exit
  %sext433 = shl i64 %retval.0.i335, 32
  %conv.i339 = ashr exact i64 %sext433, 32
  %call1.i = tail call ptr @sdsnewlen(ptr noundef nonnull %173, i64 noundef %conv.i339) #33
  %179 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i = getelementptr inbounds %struct.clusterState, ptr %179, i64 0, i32 4
  %180 = load ptr, ptr %nodes.i, align 8
  %call2.i = tail call ptr @dictFind(ptr noundef %180, ptr noundef %call1.i) #33
  tail call void @sdsfree(ptr noundef %call1.i) #33
  %cmp3.i340 = icmp eq ptr %call2.i, null
  br i1 %cmp3.i340, label %if.then467, label %clusterLookupNode.exit

clusterLookupNode.exit:                           ; preds = %if.end.i338
  %call7.i = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i) #33
  %tobool466.not = icmp eq ptr %call7.i, null
  br i1 %tobool466.not, label %if.then467, label %if.else479

if.then467:                                       ; preds = %if.end.i338, %sdslen.exit, %clusterLookupNode.exit
  %181 = load ptr, ptr %argv, align 8
  %arrayidx469 = getelementptr inbounds ptr, ptr %181, i64 2
  %182 = load ptr, ptr %arrayidx469, align 8
  %ptr470 = getelementptr inbounds %struct.redisObject, ptr %182, i64 0, i32 2
  %183 = load ptr, ptr %ptr470, align 8
  %call471 = tail call i32 @clusterBlacklistExists(ptr noundef %183), !range !18
  %tobool472.not = icmp eq i32 %call471, 0
  br i1 %tobool472.not, label %if.else474, label %if.then473

if.then473:                                       ; preds = %if.then467
  %184 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %184) #33
  br label %return

if.else474:                                       ; preds = %if.then467
  %185 = load ptr, ptr %argv, align 8
  %arrayidx476 = getelementptr inbounds ptr, ptr %185, i64 2
  %186 = load ptr, ptr %arrayidx476, align 8
  %ptr477 = getelementptr inbounds %struct.redisObject, ptr %186, i64 0, i32 2
  %187 = load ptr, ptr %ptr477, align 8
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.210, ptr noundef %187) #33
  br label %return

if.else479:                                       ; preds = %clusterLookupNode.exit
  %188 = load ptr, ptr @myself, align 8
  %cmp480 = icmp eq ptr %call7.i, %188
  br i1 %cmp480, label %if.then482, label %if.else483

if.then482:                                       ; preds = %if.else479
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.244) #33
  br label %return

if.else483:                                       ; preds = %if.else479
  %flags484 = getelementptr inbounds %struct._clusterNode, ptr %188, i64 0, i32 3
  %189 = load i32, ptr %flags484, align 8
  %and485 = and i32 %189, 2
  %tobool486.not = icmp eq i32 %and485, 0
  br i1 %tobool486.not, label %if.end493, label %land.lhs.true487

land.lhs.true487:                                 ; preds = %if.else483
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %188, i64 0, i32 11
  %190 = load ptr, ptr %slaveof, align 8
  %cmp488 = icmp eq ptr %190, %call7.i
  br i1 %cmp488, label %if.then490, label %if.end493

if.then490:                                       ; preds = %land.lhs.true487
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.245) #33
  br label %return

if.end493:                                        ; preds = %land.lhs.true487, %if.else483
  tail call void @clusterBlacklistAddNode(ptr noundef nonnull %call7.i)
  tail call void @clusterDelNode(ptr noundef nonnull %call7.i)
  %191 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i341 = getelementptr inbounds %struct.clusterState, ptr %191, i64 0, i32 22
  %192 = load i32, ptr %todo_before_sleep.i341, align 8
  %or.i342 = or i32 %192, 6
  store i32 %or.i342, ptr %todo_before_sleep.i341, align 8
  %193 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %193) #33
  br label %return

if.else494:                                       ; preds = %land.lhs.true451, %if.else445
  %call498 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.246) #34
  %tobool499.not = icmp eq i32 %call498, 0
  br i1 %tobool499.not, label %land.lhs.true500, label %if.else543

land.lhs.true500:                                 ; preds = %if.else494
  %argc501 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %194 = load i32, ptr %argc501, align 8
  %cmp502 = icmp eq i32 %194, 3
  br i1 %cmp502, label %if.then504, label %if.else543

if.then504:                                       ; preds = %land.lhs.true500
  %arrayidx507 = getelementptr inbounds ptr, ptr %0, i64 2
  %195 = load ptr, ptr %arrayidx507, align 8
  %ptr508 = getelementptr inbounds %struct.redisObject, ptr %195, i64 0, i32 2
  %196 = load ptr, ptr %ptr508, align 8
  %arrayidx.i343 = getelementptr inbounds i8, ptr %196, i64 -1
  %197 = load i8, ptr %arrayidx.i343, align 1
  %conv.i344 = zext i8 %197 to i32
  %and.i345 = and i32 %conv.i344, 7
  switch i32 %and.i345, label %sdslen.exit361 [
    i32 0, label %sw.bb.i358
    i32 1, label %sw.bb3.i355
    i32 2, label %sw.bb5.i352
    i32 3, label %sw.bb9.i349
    i32 4, label %sw.bb13.i346
  ]

sw.bb.i358:                                       ; preds = %if.then504
  %shr.i359 = lshr i32 %conv.i344, 3
  %conv2.i360 = zext nneg i32 %shr.i359 to i64
  br label %sdslen.exit361

sw.bb3.i355:                                      ; preds = %if.then504
  %add.ptr.i356 = getelementptr inbounds i8, ptr %196, i64 -3
  %198 = load i8, ptr %add.ptr.i356, align 1
  %conv4.i357 = zext i8 %198 to i64
  br label %sdslen.exit361

sw.bb5.i352:                                      ; preds = %if.then504
  %add.ptr6.i353 = getelementptr inbounds i8, ptr %196, i64 -5
  %199 = load i16, ptr %add.ptr6.i353, align 1
  %conv8.i354 = zext i16 %199 to i64
  br label %sdslen.exit361

sw.bb9.i349:                                      ; preds = %if.then504
  %add.ptr10.i350 = getelementptr inbounds i8, ptr %196, i64 -9
  %200 = load i32, ptr %add.ptr10.i350, align 1
  %conv12.i351 = zext i32 %200 to i64
  br label %sdslen.exit361

sw.bb13.i346:                                     ; preds = %if.then504
  %add.ptr14.i347 = getelementptr inbounds i8, ptr %196, i64 -17
  %201 = load i64, ptr %add.ptr14.i347, align 1
  br label %sdslen.exit361

sdslen.exit361:                                   ; preds = %if.then504, %sw.bb.i358, %sw.bb3.i355, %sw.bb5.i352, %sw.bb9.i349, %sw.bb13.i346
  %retval.0.i348 = phi i64 [ %201, %sw.bb13.i346 ], [ %conv12.i351, %sw.bb9.i349 ], [ %conv8.i354, %sw.bb5.i352 ], [ %conv4.i357, %sw.bb3.i355 ], [ %conv2.i360, %sw.bb.i358 ], [ 0, %if.then504 ]
  %conv513 = trunc i64 %retval.0.i348 to i32
  %call.i362 = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %196, i32 noundef %conv513) #33
  %cmp.not.i363 = icmp eq i32 %call.i362, 0
  br i1 %cmp.not.i363, label %if.end.i365, label %if.then516

if.end.i365:                                      ; preds = %sdslen.exit361
  %sext432 = shl i64 %retval.0.i348, 32
  %conv.i366 = ashr exact i64 %sext432, 32
  %call1.i367 = tail call ptr @sdsnewlen(ptr noundef nonnull %196, i64 noundef %conv.i366) #33
  %202 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i368 = getelementptr inbounds %struct.clusterState, ptr %202, i64 0, i32 4
  %203 = load ptr, ptr %nodes.i368, align 8
  %call2.i369 = tail call ptr @dictFind(ptr noundef %203, ptr noundef %call1.i367) #33
  tail call void @sdsfree(ptr noundef %call1.i367) #33
  %cmp3.i370 = icmp eq ptr %call2.i369, null
  br i1 %cmp3.i370, label %if.then516, label %clusterLookupNode.exit373

clusterLookupNode.exit373:                        ; preds = %if.end.i365
  %call7.i372 = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i369) #33
  %tobool515.not = icmp eq ptr %call7.i372, null
  br i1 %tobool515.not, label %if.then516, label %if.end520

if.then516:                                       ; preds = %if.end.i365, %sdslen.exit361, %clusterLookupNode.exit373
  %204 = load ptr, ptr %argv, align 8
  %arrayidx518 = getelementptr inbounds ptr, ptr %204, i64 2
  %205 = load ptr, ptr %arrayidx518, align 8
  %ptr519 = getelementptr inbounds %struct.redisObject, ptr %205, i64 0, i32 2
  %206 = load ptr, ptr %ptr519, align 8
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.210, ptr noundef %206) #33
  br label %return

if.end520:                                        ; preds = %clusterLookupNode.exit373
  %207 = load ptr, ptr @myself, align 8
  %cmp521 = icmp eq ptr %call7.i372, %207
  br i1 %cmp521, label %if.then523, label %if.end524

if.then523:                                       ; preds = %if.end520
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.247) #33
  br label %return

if.end524:                                        ; preds = %if.end520
  %flags525 = getelementptr inbounds %struct._clusterNode, ptr %call7.i372, i64 0, i32 3
  %208 = load i32, ptr %flags525, align 8
  %and526 = and i32 %208, 2
  %tobool527.not = icmp eq i32 %and526, 0
  br i1 %tobool527.not, label %if.end529, label %if.then528

if.then528:                                       ; preds = %if.end524
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.248) #33
  br label %return

if.end529:                                        ; preds = %if.end524
  %flags.i = getelementptr inbounds %struct._clusterNode, ptr %207, i64 0, i32 3
  %209 = load i32, ptr %flags.i, align 8
  %and.i374 = and i32 %209, 1
  %tobool531.not = icmp eq i32 %and.i374, 0
  br i1 %tobool531.not, label %if.end542, label %land.lhs.true532

land.lhs.true532:                                 ; preds = %if.end529
  %numslots533 = getelementptr inbounds %struct._clusterNode, ptr %207, i64 0, i32 8
  %210 = load i32, ptr %numslots533, align 4
  %cmp534.not = icmp eq i32 %210, 0
  br i1 %cmp534.not, label %lor.lhs.false536, label %if.then541

lor.lhs.false536:                                 ; preds = %land.lhs.true532
  %211 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 10), align 8
  %call538 = tail call i64 @dbSize(ptr noundef %211, i32 noundef 0) #33
  %cmp539.not = icmp eq i64 %call538, 0
  br i1 %cmp539.not, label %if.end542, label %if.then541

if.then541:                                       ; preds = %lor.lhs.false536, %land.lhs.true532
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.249) #33
  br label %return

if.end542:                                        ; preds = %lor.lhs.false536, %if.end529
  tail call void @clusterSetMaster(ptr noundef nonnull %call7.i372)
  %212 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %todo_before_sleep.i375 = getelementptr inbounds %struct.clusterState, ptr %212, i64 0, i32 22
  %213 = load i32, ptr %todo_before_sleep.i375, align 8
  %or.i376 = or i32 %213, 6
  store i32 %or.i376, ptr %todo_before_sleep.i375, align 8
  %214 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %214) #33
  br label %return

if.else543:                                       ; preds = %land.lhs.true500, %if.else494
  %call547 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.250) #34
  %tobool548.not = icmp eq i32 %call547, 0
  br i1 %tobool548.not, label %land.lhs.true549, label %if.else573

land.lhs.true549:                                 ; preds = %if.else543
  %argc550 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %215 = load i32, ptr %argc550, align 8
  %cmp551 = icmp eq i32 %215, 3
  br i1 %cmp551, label %if.then553, label %if.else573

if.then553:                                       ; preds = %land.lhs.true549
  %arrayidx556 = getelementptr inbounds ptr, ptr %0, i64 2
  %216 = load ptr, ptr %arrayidx556, align 8
  %ptr557 = getelementptr inbounds %struct.redisObject, ptr %216, i64 0, i32 2
  %217 = load ptr, ptr %ptr557, align 8
  %arrayidx.i377 = getelementptr inbounds i8, ptr %217, i64 -1
  %218 = load i8, ptr %arrayidx.i377, align 1
  %conv.i378 = zext i8 %218 to i32
  %and.i379 = and i32 %conv.i378, 7
  switch i32 %and.i379, label %sdslen.exit395 [
    i32 0, label %sw.bb.i392
    i32 1, label %sw.bb3.i389
    i32 2, label %sw.bb5.i386
    i32 3, label %sw.bb9.i383
    i32 4, label %sw.bb13.i380
  ]

sw.bb.i392:                                       ; preds = %if.then553
  %shr.i393 = lshr i32 %conv.i378, 3
  %conv2.i394 = zext nneg i32 %shr.i393 to i64
  br label %sdslen.exit395

sw.bb3.i389:                                      ; preds = %if.then553
  %add.ptr.i390 = getelementptr inbounds i8, ptr %217, i64 -3
  %219 = load i8, ptr %add.ptr.i390, align 1
  %conv4.i391 = zext i8 %219 to i64
  br label %sdslen.exit395

sw.bb5.i386:                                      ; preds = %if.then553
  %add.ptr6.i387 = getelementptr inbounds i8, ptr %217, i64 -5
  %220 = load i16, ptr %add.ptr6.i387, align 1
  %conv8.i388 = zext i16 %220 to i64
  br label %sdslen.exit395

sw.bb9.i383:                                      ; preds = %if.then553
  %add.ptr10.i384 = getelementptr inbounds i8, ptr %217, i64 -9
  %221 = load i32, ptr %add.ptr10.i384, align 1
  %conv12.i385 = zext i32 %221 to i64
  br label %sdslen.exit395

sw.bb13.i380:                                     ; preds = %if.then553
  %add.ptr14.i381 = getelementptr inbounds i8, ptr %217, i64 -17
  %222 = load i64, ptr %add.ptr14.i381, align 1
  br label %sdslen.exit395

sdslen.exit395:                                   ; preds = %if.then553, %sw.bb.i392, %sw.bb3.i389, %sw.bb5.i386, %sw.bb9.i383, %sw.bb13.i380
  %retval.0.i382 = phi i64 [ %222, %sw.bb13.i380 ], [ %conv12.i385, %sw.bb9.i383 ], [ %conv8.i388, %sw.bb5.i386 ], [ %conv4.i391, %sw.bb3.i389 ], [ %conv2.i394, %sw.bb.i392 ], [ 0, %if.then553 ]
  %conv562 = trunc i64 %retval.0.i382 to i32
  %call.i396 = tail call i32 @verifyClusterNodeId(ptr noundef nonnull %217, i32 noundef %conv562) #33
  %cmp.not.i397 = icmp eq i32 %call.i396, 0
  br i1 %cmp.not.i397, label %if.end.i399, label %if.then565

if.end.i399:                                      ; preds = %sdslen.exit395
  %sext = shl i64 %retval.0.i382, 32
  %conv.i400 = ashr exact i64 %sext, 32
  %call1.i401 = tail call ptr @sdsnewlen(ptr noundef nonnull %217, i64 noundef %conv.i400) #33
  %223 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes.i402 = getelementptr inbounds %struct.clusterState, ptr %223, i64 0, i32 4
  %224 = load ptr, ptr %nodes.i402, align 8
  %call2.i403 = tail call ptr @dictFind(ptr noundef %224, ptr noundef %call1.i401) #33
  tail call void @sdsfree(ptr noundef %call1.i401) #33
  %cmp3.i404 = icmp eq ptr %call2.i403, null
  br i1 %cmp3.i404, label %if.then565, label %clusterLookupNode.exit407

clusterLookupNode.exit407:                        ; preds = %if.end.i399
  %call7.i406 = tail call ptr @dictGetVal(ptr noundef nonnull %call2.i403) #33
  %tobool564.not = icmp eq ptr %call7.i406, null
  br i1 %tobool564.not, label %if.then565, label %if.else569

if.then565:                                       ; preds = %if.end.i399, %sdslen.exit395, %clusterLookupNode.exit407
  %225 = load ptr, ptr %argv, align 8
  %arrayidx567 = getelementptr inbounds ptr, ptr %225, i64 2
  %226 = load ptr, ptr %arrayidx567, align 8
  %ptr568 = getelementptr inbounds %struct.redisObject, ptr %226, i64 0, i32 2
  %227 = load ptr, ptr %ptr568, align 8
  tail call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.210, ptr noundef %227) #33
  br label %return

if.else569:                                       ; preds = %clusterLookupNode.exit407
  %call570 = tail call i32 @clusterNodeFailureReportsCount(ptr noundef nonnull %call7.i406)
  %conv571 = sext i32 %call570 to i64
  tail call void @addReplyLongLong(ptr noundef nonnull %c, i64 noundef %conv571) #33
  br label %return

if.else573:                                       ; preds = %land.lhs.true549, %if.else543
  %call577 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.251) #34
  %tobool578.not = icmp eq i32 %call577, 0
  br i1 %tobool578.not, label %land.lhs.true579, label %if.else662

land.lhs.true579:                                 ; preds = %if.else573
  %argc580 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %228 = load i32, ptr %argc580, align 8
  %229 = and i32 %228, -2
  %switch229 = icmp eq i32 %229, 2
  br i1 %switch229, label %if.then587, label %if.else662

if.then587:                                       ; preds = %land.lhs.true579
  %cmp589.not = icmp eq i32 %228, 3
  br i1 %cmp589.not, label %if.then591, label %if.end608

if.then591:                                       ; preds = %if.then587
  %arrayidx593 = getelementptr inbounds ptr, ptr %0, i64 2
  %230 = load ptr, ptr %arrayidx593, align 8
  %ptr594 = getelementptr inbounds %struct.redisObject, ptr %230, i64 0, i32 2
  %231 = load ptr, ptr %ptr594, align 8
  %call595 = tail call i32 @strcasecmp(ptr noundef %231, ptr noundef nonnull @.str.252) #34
  %tobool596.not = icmp eq i32 %call595, 0
  br i1 %tobool596.not, label %if.end608, label %if.else598

if.else598:                                       ; preds = %if.then591
  %call602 = tail call i32 @strcasecmp(ptr noundef %231, ptr noundef nonnull @.str.253) #34
  %tobool603.not = icmp eq i32 %call602, 0
  br i1 %tobool603.not, label %if.end608, label %if.else605

if.else605:                                       ; preds = %if.else598
  %232 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 15), align 8
  tail call void @addReplyErrorObject(ptr noundef nonnull %c, ptr noundef %232) #33
  br label %return

if.end608:                                        ; preds = %if.else598, %if.then591, %if.then587
  %tobool634.not = phi i1 [ true, %if.then587 ], [ true, %if.then591 ], [ false, %if.else598 ]
  %233 = load ptr, ptr @myself, align 8
  %flags.i408 = getelementptr inbounds %struct._clusterNode, ptr %233, i64 0, i32 3
  %234 = load i32, ptr %flags.i408, align 8
  %and.i409 = and i32 %234, 1
  %tobool610.not = icmp eq i32 %and.i409, 0
  br i1 %tobool610.not, label %if.else612, label %if.then611

if.then611:                                       ; preds = %if.end608
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.254) #33
  br label %return

if.else612:                                       ; preds = %if.end608
  %slaveof613 = getelementptr inbounds %struct._clusterNode, ptr %233, i64 0, i32 11
  %235 = load ptr, ptr %slaveof613, align 8
  %cmp614 = icmp eq ptr %235, null
  br i1 %cmp614, label %if.then616, label %if.else617

if.then616:                                       ; preds = %if.else612
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.255) #33
  br label %return

if.else617:                                       ; preds = %if.else612
  br i1 %cmp589.not, label %if.end631, label %land.lhs.true619

land.lhs.true619:                                 ; preds = %if.else617
  %flags621 = getelementptr inbounds %struct._clusterNode, ptr %235, i64 0, i32 3
  %236 = load i32, ptr %flags621, align 8
  %and622 = and i32 %236, 8
  %tobool623.not = icmp eq i32 %and622, 0
  br i1 %tobool623.not, label %lor.lhs.false624, label %if.then628

lor.lhs.false624:                                 ; preds = %land.lhs.true619
  %link = getelementptr inbounds %struct._clusterNode, ptr %235, i64 0, i32 27
  %237 = load ptr, ptr %link, align 8
  %cmp626 = icmp eq ptr %237, null
  br i1 %cmp626, label %if.then628, label %if.end631

if.then628:                                       ; preds = %lor.lhs.false624, %land.lhs.true619
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.256) #33
  br label %return

if.end631:                                        ; preds = %lor.lhs.false624, %if.else617
  tail call void @resetManualFailover()
  %call632 = tail call i64 @mstime() #33
  %add633 = add nsw i64 %call632, 5000
  %238 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %238, i64 0, i32 17
  store i64 %add633, ptr %mf_end, align 8
  %239 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp647 = icmp sgt i32 %239, 2
  br i1 %tobool634.not, label %if.else643, label %do.body636

do.body636:                                       ; preds = %if.end631
  br i1 %cmp647, label %do.end641, label %if.end640

if.end640:                                        ; preds = %do.body636
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.257) #33
  br label %do.end641

do.end641:                                        ; preds = %do.body636, %if.end640
  %call642 = tail call i32 @clusterBumpConfigEpochWithoutConsensus(), !range !21
  tail call void @clusterFailoverReplaceYourMaster()
  br label %if.end661

if.else643:                                       ; preds = %if.end631
  br i1 %cmp589.not, label %do.body646, label %do.body653

do.body646:                                       ; preds = %if.else643
  br i1 %cmp647, label %do.end651, label %if.end650

if.end650:                                        ; preds = %do.body646
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.258) #33
  %.pre484 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %do.end651

do.end651:                                        ; preds = %do.body646, %if.end650
  %240 = phi ptr [ %238, %do.body646 ], [ %.pre484, %if.end650 ]
  %mf_can_start = getelementptr inbounds %struct.clusterState, ptr %240, i64 0, i32 20
  store i32 1, ptr %mf_can_start, align 8
  br label %if.end661

do.body653:                                       ; preds = %if.else643
  br i1 %cmp647, label %do.end658, label %if.end657

if.end657:                                        ; preds = %do.body653
  tail call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.259) #33
  br label %do.end658

do.end658:                                        ; preds = %do.body653, %if.end657
  %241 = load ptr, ptr @myself, align 8
  %slaveof659 = getelementptr inbounds %struct._clusterNode, ptr %241, i64 0, i32 11
  %242 = load ptr, ptr %slaveof659, align 8
  tail call void @clusterSendMFStart(ptr noundef %242)
  br label %if.end661

if.end661:                                        ; preds = %do.end651, %do.end658, %do.end641
  %243 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %243) #33
  br label %return

if.else662:                                       ; preds = %land.lhs.true579, %if.else573
  %call666 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.260) #34
  %tobool667.not = icmp eq i32 %call666, 0
  br i1 %tobool667.not, label %land.lhs.true668, label %if.else714

land.lhs.true668:                                 ; preds = %if.else662
  %argc669 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %244 = load i32, ptr %argc669, align 8
  %cmp670 = icmp eq i32 %244, 3
  br i1 %cmp670, label %if.then672, label %if.else714

if.then672:                                       ; preds = %land.lhs.true668
  %arrayidx674 = getelementptr inbounds ptr, ptr %0, i64 2
  %245 = load ptr, ptr %arrayidx674, align 8
  %call675 = call i32 @getLongLongFromObjectOrReply(ptr noundef nonnull %c, ptr noundef %245, ptr noundef nonnull %epoch, ptr noundef null) #33
  %cmp676.not = icmp eq i32 %call675, 0
  br i1 %cmp676.not, label %if.end679, label %return

if.end679:                                        ; preds = %if.then672
  %246 = load i64, ptr %epoch, align 8
  %cmp680 = icmp slt i64 %246, 0
  br i1 %cmp680, label %if.then682, label %if.else683

if.then682:                                       ; preds = %if.end679
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef nonnull %c, ptr noundef nonnull @.str.261, i64 noundef %246) #33
  br label %return

if.else683:                                       ; preds = %if.end679
  %247 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %247, i64 0, i32 4
  %248 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %248, i64 0, i32 2
  %249 = load i64, ptr %ht_used, align 8
  %arrayidx687 = getelementptr inbounds %struct.dict, ptr %248, i64 0, i32 2, i64 1
  %250 = load i64, ptr %arrayidx687, align 8
  %add688 = add i64 %250, %249
  %cmp689 = icmp ugt i64 %add688, 1
  br i1 %cmp689, label %if.then691, label %if.else692

if.then691:                                       ; preds = %if.else683
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.262) #33
  br label %return

if.else692:                                       ; preds = %if.else683
  %251 = load ptr, ptr @myself, align 8
  %configEpoch693 = getelementptr inbounds %struct._clusterNode, ptr %251, i64 0, i32 4
  %252 = load i64, ptr %configEpoch693, align 8
  %cmp694.not = icmp eq i64 %252, 0
  br i1 %cmp694.not, label %if.else697, label %if.then696

if.then696:                                       ; preds = %if.else692
  call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.263) #33
  br label %return

if.else697:                                       ; preds = %if.else692
  store i64 %246, ptr %configEpoch693, align 8
  %253 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 156), align 8
  %cmp700 = icmp sgt i32 %253, 2
  br i1 %cmp700, label %do.end705, label %if.end703

if.end703:                                        ; preds = %if.else697
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef nonnull @.str.264, i64 noundef %246) #33
  %.pre = load i64, ptr %epoch, align 8
  br label %do.end705

do.end705:                                        ; preds = %if.else697, %if.end703
  %254 = phi i64 [ %246, %if.else697 ], [ %.pre, %if.end703 ]
  %255 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %255, i64 0, i32 1
  %256 = load i64, ptr %currentEpoch, align 8
  %cmp706 = icmp ult i64 %256, %254
  br i1 %cmp706, label %if.then708, label %if.end710

if.then708:                                       ; preds = %do.end705
  store i64 %254, ptr %currentEpoch, align 8
  %.pre483 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  br label %if.end710

if.end710:                                        ; preds = %if.then708, %do.end705
  %257 = phi ptr [ %.pre483, %if.then708 ], [ %255, %do.end705 ]
  %todo_before_sleep.i410 = getelementptr inbounds %struct.clusterState, ptr %257, i64 0, i32 22
  %258 = load i32, ptr %todo_before_sleep.i410, align 8
  %or.i411 = or i32 %258, 6
  store i32 %or.i411, ptr %todo_before_sleep.i410, align 8
  %259 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef nonnull %c, ptr noundef %259) #33
  br label %return

if.else714:                                       ; preds = %land.lhs.true668, %if.else662
  %call718 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.265) #34
  %tobool719.not = icmp eq i32 %call718, 0
  br i1 %tobool719.not, label %land.lhs.true720, label %if.else758

land.lhs.true720:                                 ; preds = %if.else714
  %argc721 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %260 = load i32, ptr %argc721, align 8
  %261 = and i32 %260, -2
  %switch231 = icmp eq i32 %261, 2
  br i1 %switch231, label %if.then728, label %if.else758

if.then728:                                       ; preds = %land.lhs.true720
  %cmp730 = icmp eq i32 %260, 3
  br i1 %cmp730, label %if.then732, label %if.end749

if.then732:                                       ; preds = %if.then728
  %arrayidx734 = getelementptr inbounds ptr, ptr %0, i64 2
  %262 = load ptr, ptr %arrayidx734, align 8
  %ptr735 = getelementptr inbounds %struct.redisObject, ptr %262, i64 0, i32 2
  %263 = load ptr, ptr %ptr735, align 8
  %call736 = tail call i32 @strcasecmp(ptr noundef %263, ptr noundef nonnull @.str.266) #34
  %tobool737.not = icmp eq i32 %call736, 0
  br i1 %tobool737.not, label %if.end749, label %if.else739

if.else739:                                       ; preds = %if.then732
  %call743 = tail call i32 @strcasecmp(ptr noundef %263, ptr noundef nonnull @.str.267) #34
  %tobool744.not = icmp eq i32 %call743, 0
  br i1 %tobool744.not, label %if.end749, label %if.else746

if.else746:                                       ; preds = %if.else739
  %264 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i64 0, i32 15), align 8
  tail call void @addReplyErrorObject(ptr noundef nonnull %c, ptr noundef %264) #33
  br label %return

if.end749:                                        ; preds = %if.else739, %if.then732, %if.then728
  %hard.0 = phi i32 [ 0, %if.then728 ], [ 1, %if.then732 ], [ 0, %if.else739 ]
  %265 = load ptr, ptr @myself, align 8
  %flags.i412 = getelementptr inbounds %struct._clusterNode, ptr %265, i64 0, i32 3
  %266 = load i32, ptr %flags.i412, align 8
  %and.i413 = and i32 %266, 1
  %tobool751.not = icmp eq i32 %and.i413, 0
  br i1 %tobool751.not, label %if.end757, label %land.lhs.true752

land.lhs.true752:                                 ; preds = %if.end749
  %db = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 4
  %267 = load ptr, ptr %db, align 8
  %call753 = tail call i64 @dbSize(ptr noundef %267, i32 noundef 0) #33
  %cmp754.not = icmp eq i64 %call753, 0
  br i1 %cmp754.not, label %if.end757, label %if.then756

if.then756:                                       ; preds = %land.lhs.true752
  tail call void @addReplyError(ptr noundef nonnull %c, ptr noundef nonnull @.str.268) #33
  br label %return

if.end757:                                        ; preds = %land.lhs.true752, %if.end749
  tail call void @clusterReset(i32 noundef %hard.0)
  %268 = load ptr, ptr @shared, align 8
  tail call void @addReply(ptr noundef nonnull %c, ptr noundef %268) #33
  br label %return

if.else758:                                       ; preds = %land.lhs.true720, %if.else714
  %call762 = tail call i32 @strcasecmp(ptr noundef %2, ptr noundef nonnull @.str.269) #34
  %tobool763.not = icmp eq i32 %call762, 0
  br i1 %tobool763.not, label %land.lhs.true764, label %return

land.lhs.true764:                                 ; preds = %if.else758
  %argc765 = getelementptr inbounds %struct.client, ptr %c, i64 0, i32 11
  %269 = load i32, ptr %argc765, align 8
  %cmp766 = icmp eq i32 %269, 2
  br i1 %cmp766, label %if.then768, label %return

if.then768:                                       ; preds = %land.lhs.true764
  tail call void @addReplyClusterLinksDescription(ptr noundef nonnull %c)
  br label %return

return:                                           ; preds = %getSlotOrReply.exit323.thread, %if.else42, %if.then35, %for.end111, %if.end407, %if.else441, %if.then440, %if.end542, %if.end661, %if.end757, %if.then768, %if.then682, %if.then696, %if.end710, %if.then691, %if.else569, %if.end493, %if.then418, %for.end178, %clusterDelNodeSlots.exit, %if.else758, %land.lhs.true764, %if.then672, %if.then473, %if.else474, %if.then756, %if.else746, %if.then628, %if.then616, %if.then611, %if.else605, %if.then565, %if.then541, %if.then528, %if.then523, %if.then516, %if.then490, %if.then482, %if.else403, %if.then342, %if.then328, %if.then320, %if.then278, %if.then270, %if.then257, %if.then237, %if.then229, %if.then216, %if.then192, %if.then174, %if.then169, %getSlotOrReply.exit278.thread, %getSlotOrReply.exit266.thread, %if.then132, %if.then107, %getSlotOrReply.exit.thread, %if.then59, %if.then18, %if.then7
  %retval.0 = phi i32 [ 1, %if.else746 ], [ 1, %if.then756 ], [ 1, %if.else605 ], [ 1, %if.then611 ], [ 1, %if.then616 ], [ 1, %if.then628 ], [ 1, %if.then565 ], [ 1, %if.then523 ], [ 1, %if.then528 ], [ 1, %if.then541 ], [ 1, %if.then516 ], [ 1, %if.then482 ], [ 1, %if.then490 ], [ 1, %if.then192 ], [ 1, %if.else403 ], [ 1, %if.then328 ], [ 1, %if.then342 ], [ 1, %if.then320 ], [ 1, %if.then257 ], [ 1, %if.then270 ], [ 1, %if.then278 ], [ 1, %if.then216 ], [ 1, %if.then229 ], [ 1, %if.then237 ], [ 1, %if.then132 ], [ 1, %getSlotOrReply.exit266.thread ], [ 1, %getSlotOrReply.exit278.thread ], [ 1, %if.then169 ], [ 1, %if.then174 ], [ 1, %getSlotOrReply.exit.thread ], [ 1, %if.then107 ], [ 1, %if.then59 ], [ 1, %if.then7 ], [ 1, %if.then18 ], [ 1, %if.else474 ], [ 1, %if.then473 ], [ 1, %if.then672 ], [ 0, %land.lhs.true764 ], [ 0, %if.else758 ], [ 1, %clusterDelNodeSlots.exit ], [ 1, %for.end178 ], [ 1, %if.then418 ], [ 1, %if.end493 ], [ 1, %if.else569 ], [ 1, %if.then691 ], [ 1, %if.end710 ], [ 1, %if.then696 ], [ 1, %if.then682 ], [ 1, %if.then768 ], [ 1, %if.end757 ], [ 1, %if.end661 ], [ 1, %if.end542 ], [ 1, %if.then440 ], [ 1, %if.else441 ], [ 1, %if.end407 ], [ 1, %for.end111 ], [ 1, %if.then35 ], [ 1, %if.else42 ], [ 1, %getSlotOrReply.exit323.thread ]
  ret i32 %retval.0
}

declare void @addReplyErrorArity(ptr noundef) local_unnamed_addr #1

declare void @addReplySds(ptr noundef, ptr noundef) local_unnamed_addr #1

declare void @addReplyErrorObject(ptr noundef, ptr noundef) local_unnamed_addr #1

declare i32 @getLongLongFromObjectOrReply(ptr noundef, ptr noundef, ptr noundef, ptr noundef) local_unnamed_addr #1

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable
define dso_local nonnull ptr @clusterCommandExtendedHelp() local_unnamed_addr #27 {
entry:
  ret ptr @clusterCommandExtendedHelp.help
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i32 @clusterNodeNumSlaves(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 9
  %0 = load i32, ptr %numslaves, align 8
  ret i32 %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @clusterNodeGetSlave(ptr nocapture noundef readonly %node, i32 noundef %slave_idx) local_unnamed_addr #0 {
entry:
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 10
  %0 = load ptr, ptr %slaves, align 8
  %idxprom = sext i32 %slave_idx to i64
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 %idxprom
  %1 = load ptr, ptr %arrayidx, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @getMigratingSlotDest(i32 noundef %slot) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom = sext i32 %slot to i64
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 7, i64 %idxprom
  %1 = load ptr, ptr %arrayidx, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @getImportingSlotSource(i32 noundef %slot) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom = sext i32 %slot to i64
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 8, i64 %idxprom
  %1 = load ptr, ptr %arrayidx, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local i32 @isClusterHealthy() local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 2
  %1 = load i32, ptr %state, align 8
  %cmp = icmp eq i32 %1, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable
define dso_local ptr @getNodeBySlot(i32 noundef %slot) local_unnamed_addr #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 367), align 8
  %idxprom = sext i32 %slot to i64
  %arrayidx = getelementptr inbounds %struct.clusterState, ptr %0, i64 0, i32 9, i64 %idxprom
  %1 = load ptr, ptr %arrayidx, align 8
  ret ptr %1
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local ptr @clusterNodeHostname(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 22
  %0 = load ptr, ptr %hostname, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable
define dso_local i64 @clusterNodeReplOffset(ptr nocapture noundef readonly %node) local_unnamed_addr #5 {
entry:
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %node, i64 0, i32 20
  %0 = load i64, ptr %repl_offset, align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterAllowFailoverCmd(ptr noundef %c) local_unnamed_addr #2 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i64 0, i32 362), align 4
  %tobool.not = icmp eq i32 %0, 0
  br i1 %tobool.not, label %return, label %if.end

if.end:                                           ; preds = %entry
  tail call void @addReplyError(ptr noundef %c, ptr noundef nonnull @.str.305) #33
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterPromoteSelfToMaster() local_unnamed_addr #2 {
entry:
  tail call void @replicationUnsetMaster() #33
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @zcalloc(i64 noundef) local_unnamed_addr #14

; Function Attrs: nofree nounwind willreturn memory(argmem: read)
declare i32 @bcmp(ptr nocapture, ptr nocapture, i64) local_unnamed_addr #30

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #31

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.umin.i32(i32, i32) #31

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smin.i64(i64, i64) #31

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #31

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #31

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #32

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #32

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smin.i32(i32, i32) #31

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { mustprogress nofree nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { mustprogress nofree nounwind willreturn uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #7 = { mustprogress nofree nounwind willreturn memory(argmem: read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #9 = { mustprogress nofree nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nofree nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { mustprogress nofree nosync nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { mustprogress nofree nounwind willreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #16 = { nofree "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #17 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: write, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #18 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #19 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: write, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #20 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #21 = { mustprogress nofree nosync nounwind willreturn memory(readwrite, argmem: write, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #22 = { nofree nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #23 = { allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #24 = { nofree norecurse nosync nounwind memory(read, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #25 = { mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #26 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #27 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #28 = { mustprogress nofree nosync nounwind willreturn memory(argmem: write) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #29 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #30 = { nofree nounwind willreturn memory(argmem: read) }
attributes #31 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #32 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #33 = { nounwind }
attributes #34 = { nounwind willreturn memory(read) }
attributes #35 = { noreturn nounwind }
attributes #36 = { nounwind willreturn memory(none) }
attributes #37 = { nounwind allocsize(0) }
attributes #38 = { nounwind allocsize(1) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = !{i32 0, i32 2}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = !{i32 -1, i32 1}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
