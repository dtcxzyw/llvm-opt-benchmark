target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.redisServer = type { i32, i64, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i32, i64, i32, i32, i32, ptr, ptr, i32, i32, i64, ptr, ptr, ptr, ptr, [2 x i32], i32, i32, i32, i32, i32, [16 x ptr], i32, ptr, ptr, i32, [8 x %struct.connListener], i32, %struct.connListener, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i32, ptr, [3 x %struct.pause_event], [256 x i8], ptr, i64, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, ptr, i64, i64, i64, %struct.malloc_stats, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, [4 x i64], i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [7 x %struct.anon], i64, i64, i64, i64, i64, i64, [4 x %struct.durationStats], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i32, ptr, [3 x %struct.clientBufferLimitsConfig], i32, i32, ptr, i32, i32, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, ptr, i32, i64, i64, i64, i64, ptr, i32, ptr, i32, i32, i32, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, ptr, i32, i32, ptr, i32, i32, i32, [2 x i32], i32, %struct.redisOpArray, i32, ptr, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [41 x i8], [41 x i8], i64, i64, i64, i64, i32, i32, ptr, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, ptr, ptr, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, ptr, i32, ptr, i64, i32, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i64, i32, ptr, i32, i32, i64, i64, i32, i32, i32, i32, i32, i64, [3 x i32], i32, i32, i32, [9 x i32], ptr, ptr, i32, i64, ptr, ptr, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i32, i64, i64, i64, i64, i64, ptr, ptr, i32, ptr, i32, i32, i32, i64, i64, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i64, i32, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, i64, ptr, i32, %struct.aclInfo, i32, i64, i32, i32, i32, %struct.redisTLSContextConfig, ptr, ptr, ptr, ptr, ptr, i64, i32, ptr, i32, i32, i32, i64, i32, ptr }
%struct.connListener = type { [16 x i32], i32, ptr, i32, i32, ptr, ptr }
%struct.pause_event = type { i32, i64 }
%struct.malloc_stats = type { i64, i64, i64, i64, i64 }
%struct.anon = type { i64, i64, [16 x i64], i32 }
%struct.durationStats = type { i64, i64, i64 }
%struct.clientBufferLimitsConfig = type { i64, i64, i64 }
%struct.redisOpArray = type { ptr, i32, i32 }
%struct.aclInfo = type { i64, i64, i64, i64 }
%struct.redisTLSContextConfig = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32 }
%struct.dictType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.auxFieldHandler = type { ptr, ptr, ptr, ptr }
%struct.redisNodeFlags = type { i16, ptr }
%struct.sharedObjectsStruct = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [4 x ptr], [4 x ptr], [4 x ptr], [4 x ptr], ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr], [10000 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], ptr, ptr }
%struct._clusterNode = type { i64, [40 x i8], [40 x i8], i32, i64, [2048 x i8], ptr, i32, i32, i32, ptr, ptr, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i8], ptr, ptr, i32, i32, i32, ptr, ptr, ptr }
%struct.clusterState = type { ptr, i64, i32, i32, ptr, ptr, ptr, [16384 x ptr], [16384 x ptr], [16384 x ptr], ptr, i64, i32, i32, i32, i64, i32, i64, ptr, i64, i32, i64, i32, [11 x i64], [11 x i64], i64, i64, [2048 x i8] }
%struct.sdshdr8 = type { i8, i8, i8, [0 x i8] }
%struct.sdshdr16 = type <{ i16, i16, i8, [0 x i8] }>
%struct.sdshdr32 = type <{ i32, i32, i8, [0 x i8] }>
%struct.sdshdr64 = type <{ i64, i64, i8, [0 x i8] }>
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }
%struct.list = type { ptr, ptr, ptr, ptr, ptr, i64 }
%struct.ConnectionType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.clusterLink = type { i64, ptr, ptr, i64, i64, ptr, i64, i64, ptr, i32 }
%struct.clusterMsgSendBlock = type { i64, i32, %struct.clusterMsg }
%struct.clusterMsg = type { [4 x i8], i32, i16, i16, i16, i16, i64, i64, i64, [40 x i8], [2048 x i8], [40 x i8], [46 x i8], i16, [30 x i8], i16, i16, i16, i8, [3 x i8], %union.clusterMsgData }
%union.clusterMsgData = type { %struct.anon.3 }
%struct.anon.3 = type { %struct.clusterMsgDataUpdate }
%struct.clusterMsgDataUpdate = type { i64, [40 x i8], [2048 x i8] }
%struct.connection = type { ptr, i32, i32, i32, i16, i16, i16, ptr, ptr, ptr, ptr }
%struct.dict = type { ptr, [2 x ptr], [2 x i64], i64, i16, [2 x i8], [0 x ptr] }
%struct.listIter = type { ptr, i32 }
%struct.listNode = type { ptr, ptr, ptr }
%struct.clusterNodeFailReport = type { ptr, i64 }
%struct.anon.1 = type { %struct.clusterMsgDataFail }
%struct.clusterMsgDataFail = type { [40 x i8] }
%struct.sockaddr_storage = type { i16, [118 x i8], i64 }
%struct.sockaddr_in = type { i16, i16, %struct.in_addr, [8 x i8] }
%struct.in_addr = type { i32 }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.in6_addr = type { %union.anon }
%union.anon = type { [4 x i32] }
%struct.anon.0 = type { [1 x %struct.clusterMsgDataGossip] }
%struct.clusterMsgDataGossip = type { [40 x i8], i32, i32, [46 x i8], i16, i16, i16, i16, i16 }
%struct.redisDb = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i64, i64, ptr, i32, [2 x %struct.dbDictState] }
%struct.dbDictState = type { i32, i32, i64, i64, ptr }
%struct.clusterMsgPingExt = type { i32, i16, i16, [0 x %union.anon.5] }
%union.anon.5 = type { %struct.clusterMsgPingExtForgottenNode }
%struct.clusterMsgPingExtForgottenNode = type { [40 x i8], i64 }
%struct.clusterMsgPingExtHostname = type { [1 x i8] }
%struct.clusterMsgPingExtHumanNodename = type { [1 x i8] }
%struct.clusterMsgPingExtShardId = type { [40 x i8] }
%struct.anon.2 = type { %struct.clusterMsgDataPublish }
%struct.clusterMsgDataPublish = type { i32, i32, [8 x i8] }
%struct.anon.4 = type { %struct.clusterMsgModule }
%struct.clusterMsgModule = type { i64, i32, i8, [3 x i8] }
%struct.redisObject = type { i32, i32, ptr }
%struct.client = type { i64, i64, ptr, i32, ptr, ptr, ptr, ptr, ptr, i64, i64, i32, ptr, i32, i32, ptr, i64, ptr, ptr, ptr, ptr, i32, i32, i64, ptr, i64, ptr, i64, i64, i64, i32, ptr, i64, i64, i32, i32, i32, i32, i64, i64, ptr, i64, i64, i64, i64, i64, i64, i64, i64, [41 x i8], i32, ptr, i32, i32, %struct.multiState, %struct.blockingState, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, i32, ptr, ptr, ptr, i64, %struct.listNode, i64, i64, i32, i64, ptr }
%struct.multiState = type { ptr, i32, i32, i32, i64, i32 }
%struct.blockingState = type { i32, i64, i32, ptr, i32, i32, i64, ptr, ptr }
%struct.raxIterator = type { i32, ptr, ptr, ptr, i64, i64, [128 x i8], ptr, %struct.raxStack, ptr }
%struct.raxStack = type { ptr, i64, i64, [32 x ptr], i32 }

@myself = dso_local global ptr null, align 8
@server = external global %struct.redisServer, align 8
@clusterNodesDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@clusterNodesBlackListDictType = dso_local global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@clusterSdsToListType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr @dictListDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@.str = private unnamed_addr constant [9 x i8] c"shard-id\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"nodename\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c"tcp-port\00", align 1
@.str.3 = private unnamed_addr constant [9 x i8] c"tls-port\00", align 1
@auxFieldHandlers = dso_local global [4 x %struct.auxFieldHandler] [%struct.auxFieldHandler { ptr @.str, ptr @auxShardIdSetter, ptr @auxShardIdGetter, ptr @auxShardIdPresent }, %struct.auxFieldHandler { ptr @.str.1, ptr @auxHumanNodenameSetter, ptr @auxHumanNodenameGetter, ptr @auxHumanNodenamePresent }, %struct.auxFieldHandler { ptr @.str.2, ptr @auxTcpPortSetter, ptr @auxTcpPortGetter, ptr @auxTcpPortPresent }, %struct.auxFieldHandler { ptr @.str.3, ptr @auxTlsPortSetter, ptr @auxTlsPortGetter, ptr @auxTlsPortPresent }], align 16
@.str.4 = private unnamed_addr constant [6 x i8] c"%.40s\00", align 1
@.str.5 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.6 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.7 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.8 = private unnamed_addr constant [44 x i8] c"Loading the cluster node config from %s: %s\00", align 1
@.str.9 = private unnamed_addr constant [58 x i8] c"Unable to obtain the cluster node config file stat %s: %s\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"vars\00", align 1
@.str.11 = private unnamed_addr constant [13 x i8] c"currentEpoch\00", align 1
@.str.12 = private unnamed_addr constant [14 x i8] c"lastVoteEpoch\00", align 1
@.str.13 = private unnamed_addr constant [46 x i8] c"Skipping unknown cluster config variable '%s'\00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.15 = private unnamed_addr constant [2 x i8] c"=\00", align 1
@.str.16 = private unnamed_addr constant [7 x i8] c"myself\00", align 1
@.str.17 = private unnamed_addr constant [31 x i8] c"server.cluster->myself == NULL\00", align 1
@.str.18 = private unnamed_addr constant [17 x i8] c"cluster_legacy.c\00", align 1
@.str.19 = private unnamed_addr constant [7 x i8] c"master\00", align 1
@.str.20 = private unnamed_addr constant [6 x i8] c"slave\00", align 1
@.str.21 = private unnamed_addr constant [6 x i8] c"fail?\00", align 1
@.str.22 = private unnamed_addr constant [5 x i8] c"fail\00", align 1
@.str.23 = private unnamed_addr constant [10 x i8] c"handshake\00", align 1
@.str.24 = private unnamed_addr constant [7 x i8] c"noaddr\00", align 1
@.str.25 = private unnamed_addr constant [11 x i8] c"nofailover\00", align 1
@.str.26 = private unnamed_addr constant [8 x i8] c"noflags\00", align 1
@.str.27 = private unnamed_addr constant [42 x i8] c"Unknown flag in redis cluster config file\00", align 1
@.str.28 = private unnamed_addr constant [10 x i8] c"p != NULL\00", align 1
@.str.29 = private unnamed_addr constant [37 x i8] c"Node configuration loaded, I'm %.40s\00", align 1
@.str.30 = private unnamed_addr constant [57 x i8] c"Unrecoverable error: corrupted cluster config file \22%s\22.\00", align 1
@.str.31 = private unnamed_addr constant [43 x i8] c"vars currentEpoch %llu lastVoteEpoch %llu\0A\00", align 1
@.str.32 = private unnamed_addr constant [13 x i8] c"%s.tmp-%i-%I\00", align 1
@.str.33 = private unnamed_addr constant [44 x i8] c"Could not open temp cluster config file: %s\00", align 1
@.str.34 = private unnamed_addr constant [64 x i8] c"Failed after writing (%zd) bytes to tmp cluster config file: %s\00", align 1
@.str.35 = private unnamed_addr constant [43 x i8] c"Could not sync tmp cluster config file: %s\00", align 1
@.str.36 = private unnamed_addr constant [45 x i8] c"Could not rename tmp cluster config file: %s\00", align 1
@.str.37 = private unnamed_addr constant [43 x i8] c"Could not sync cluster config file dir: %s\00", align 1
@.str.38 = private unnamed_addr constant [41 x i8] c"Fatal: can't update cluster config file.\00", align 1
@.str.39 = private unnamed_addr constant [45 x i8] c"Can't open %s in order to acquire a lock: %s\00", align 1
@.str.40 = private unnamed_addr constant [173 x i8] c"Sorry, the cluster configuration file %s is already used by a different Redis Cluster node. Please make sure that different nodes use different cluster configuration files.\00", align 1
@.str.41 = private unnamed_addr constant [26 x i8] c"Impossible to lock %s: %s\00", align 1
@clusterUpdateMyselfIp.prev_ip = internal global ptr null, align 8
@.str.42 = private unnamed_addr constant [42 x i8] c"No cluster configuration found, I'm %.40s\00", align 1
@.str.43 = private unnamed_addr constant [153 x i8] c"Redis port number too high. Cluster communication port is 10,000 port numbers higher than your Redis port. Your Redis port number must be 55535 or less.\00", align 1
@.str.44 = private unnamed_addr constant [71 x i8] c"No bind address is configured, but it is required for the Cluster bus.\00", align 1
@.str.45 = private unnamed_addr constant [68 x i8] c"Missing connection type %s, but it is required for the Cluster bus.\00", align 1
@.str.46 = private unnamed_addr constant [49 x i8] c"Failed listening on port %u (cluster), aborting.\00", align 1
@.str.47 = private unnamed_addr constant [66 x i8] c"Unrecoverable error creating Redis Cluster socket accept handler.\00", align 1
@.str.48 = private unnamed_addr constant [44 x i8] c"configEpoch set to 0 via CLUSTER RESET HARD\00", align 1
@.str.49 = private unnamed_addr constant [31 x i8] c"Node hard reset, now I'm %.40s\00", align 1
@.str.50 = private unnamed_addr constant [15 x i8] c"!link->inbound\00", align 1
@.str.51 = private unnamed_addr constant [14 x i8] c"link->inbound\00", align 1
@.str.52 = private unnamed_addr constant [12 x i8] c"!link->node\00", align 1
@.str.53 = private unnamed_addr constant [56 x i8] c"Replacing inbound link fd %d from node %.40s with fd %d\00", align 1
@.str.54 = private unnamed_addr constant [20 x i8] c"!node->inbound_link\00", align 1
@.str.55 = private unnamed_addr constant [33 x i8] c"Error accepting cluster node: %s\00", align 1
@.str.56 = private unnamed_addr constant [60 x i8] c"Error creating an accepting connection for cluster node: %s\00", align 1
@.str.57 = private unnamed_addr constant [45 x i8] c"Accepting cluster node connection from %s:%d\00", align 1
@.str.58 = private unnamed_addr constant [44 x i8] c"Error accepting cluster node connection: %s\00", align 1
@.str.59 = private unnamed_addr constant [54 x i8] c"dictDelete(server.cluster->nodes,nodename) == DICT_OK\00", align 1
@.str.60 = private unnamed_addr constant [18 x i8] c"retval == DICT_OK\00", align 1
@.str.61 = private unnamed_addr constant [31 x i8] c"Renaming node %.40s into %.40s\00", align 1
@.str.62 = private unnamed_addr constant [49 x i8] c"dictAdd(server.cluster->shards, s, l) == DICT_OK\00", align 1
@.str.63 = private unnamed_addr constant [28 x i8] c"New configEpoch set to %llu\00", align 1
@.str.64 = private unnamed_addr constant [77 x i8] c"WARNING: configEpoch collision with node %.40s (%s). configEpoch set to %llu\00", align 1
@.str.65 = private unnamed_addr constant [53 x i8] c"Marking node %.40s (%s) as failing (quorum reached).\00", align 1
@.str.66 = private unnamed_addr constant [17 x i8] c"nodeFailed(node)\00", align 1
@.str.67 = private unnamed_addr constant [60 x i8] c"Clear FAIL state for node %.40s (%s):%s is reachable again.\00", align 1
@.str.68 = private unnamed_addr constant [8 x i8] c"replica\00", align 1
@.str.69 = private unnamed_addr constant [21 x i8] c"master without slots\00", align 1
@.str.70 = private unnamed_addr constant [106 x i8] c"Clear FAIL state for node %.40s (%s): is reachable again and nobody is serving its slots after some time.\00", align 1
@.str.71 = private unnamed_addr constant [25 x i8] c"GOSSIP %.40s %s:%d@%d %s\00", align 1
@.str.72 = private unnamed_addr constant [59 x i8] c"Node %.40s (%s) reported node %.40s (%s) as not reachable.\00", align 1
@.str.73 = private unnamed_addr constant [57 x i8] c"Node %.40s (%s) reported node %.40s (%s) is back online.\00", align 1
@.str.74 = private unnamed_addr constant [39 x i8] c"Error converting peer IP to string: %s\00", align 1
@.str.75 = private unnamed_addr constant [8 x i8] c"no link\00", align 1
@.str.76 = private unnamed_addr constant [47 x i8] c"Address updated for node %.40s (%s), now %s:%d\00", align 1
@.str.77 = private unnamed_addr constant [40 x i8] c"Discarding UPDATE message about myself.\00", align 1
@.str.78 = private unnamed_addr constant [79 x i8] c"Configuration change detected. Reconfiguring myself as a replica of %.40s (%s)\00", align 1
@.str.79 = private unnamed_addr constant [79 x i8] c"I'm a sub-replica! Reconfiguring myself as a replica of grandmaster %.40s (%s)\00", align 1
@.str.80 = private unnamed_addr constant [35 x i8] c"Received unknown extension type %d\00", align 1
@.str.81 = private unnamed_addr constant [44 x i8] c"--- Processing packet of type %s, %lu bytes\00", align 1
@.str.82 = private unnamed_addr constant [47 x i8] c"Dropping packet that matches debug drop filter\00", align 1
@.str.83 = private unnamed_addr constant [55 x i8] c"Received a %s packet without proper padding (%d bytes)\00", align 1
@.str.84 = private unnamed_addr constant [87 x i8] c"Received invalid %s packet with extension data that exceeds total packet length (%lld)\00", align 1
@.str.85 = private unnamed_addr constant [67 x i8] c"Received invalid %s packet of length %lld but expected length %lld\00", align 1
@.str.86 = private unnamed_addr constant [68 x i8] c"Received replication offset for paused master manual failover: %lld\00", align 1
@.str.87 = private unnamed_addr constant [39 x i8] c"IP address for this node updated to %s\00", align 1
@.str.88 = private unnamed_addr constant [47 x i8] c"nodeIp2String(node->ip,link,hdr->myip) == C_OK\00", align 1
@.str.89 = private unnamed_addr constant [26 x i8] c"%s packet received: %.40s\00", align 1
@.str.90 = private unnamed_addr constant [5 x i8] c"NULL\00", align 1
@.str.91 = private unnamed_addr constant [76 x i8] c"Handshake: we already know node %.40s (%s), updating the address if needed.\00", align 1
@.str.92 = private unnamed_addr constant [37 x i8] c"Handshake with node %.40s completed.\00", align 1
@.str.93 = private unnamed_addr constant [87 x i8] c"PONG contains mismatching sender ID. About node %.40s added %d ms ago, having flags %d\00", align 1
@.str.94 = private unnamed_addr constant [41 x i8] zeroinitializer, align 1
@.str.95 = private unnamed_addr constant [78 x i8] c"Node %.40s has old slots configuration, sending an UPDATE message about %.40s\00", align 1
@.str.96 = private unnamed_addr constant [55 x i8] c"FAIL message received from %.40s (%s) about %.40s (%s)\00", align 1
@.str.97 = private unnamed_addr constant [58 x i8] c"Ignoring FAIL message from unknown node %.40s about %.40s\00", align 1
@.str.98 = private unnamed_addr constant [49 x i8] c"Manual failover requested by replica %.40s (%s).\00", align 1
@.str.99 = private unnamed_addr constant [33 x i8] c"Received unknown packet type: %d\00", align 1
@.str.100 = private unnamed_addr constant [35 x i8] c"I/O error writing to node link: %s\00", align 1
@.str.101 = private unnamed_addr constant [12 x i8] c"short write\00", align 1
@.str.102 = private unnamed_addr constant [35 x i8] c"(msg_offset + nwritten) == msg_len\00", align 1
@.str.103 = private unnamed_addr constant [47 x i8] c"Connection with Node %.40s at %s:%d failed: %s\00", align 1
@.str.104 = private unnamed_addr constant [36 x i8] c"Connecting with Node %.40s at %s:%d\00", align 1
@.str.105 = private unnamed_addr constant [5 x i8] c"RCmb\00", align 1
@.str.106 = private unnamed_addr constant [61 x i8] c"Bad message length or signature received on the Cluster bus.\00", align 1
@.str.107 = private unnamed_addr constant [71 x i8] c"Bad message length or signature received on the Cluster bus from %s:%d\00", align 1
@.str.108 = private unnamed_addr constant [37 x i8] c"I/O error reading from node link: %s\00", align 1
@.str.109 = private unnamed_addr constant [18 x i8] c"connection closed\00", align 1
@clusterSendPing.cluster_pings_sent = internal global i64 0, align 8
@.str.110 = private unnamed_addr constant [24 x i8] c"gossipcount < USHRT_MAX\00", align 1
@.str.111 = private unnamed_addr constant [23 x i8] c"nodes_for_slot != NULL\00", align 1
@.str.112 = private unnamed_addr constant [69 x i8] c"Failover auth denied to %.40s (%s): reqEpoch (%llu) < curEpoch(%llu)\00", align 1
@.str.113 = private unnamed_addr constant [65 x i8] c"Failover auth denied to %.40s (%s): already voted for epoch %llu\00", align 1
@.str.114 = private unnamed_addr constant [56 x i8] c"Failover auth denied to %.40s (%s): it is a master node\00", align 1
@.str.115 = private unnamed_addr constant [60 x i8] c"Failover auth denied to %.40s (%s): I don't know its master\00", align 1
@.str.116 = private unnamed_addr constant [53 x i8] c"Failover auth denied to %.40s (%s): its master is up\00", align 1
@.str.117 = private unnamed_addr constant [88 x i8] c"Failover auth denied to %.40s %s: can't vote about this master before %lld milliseconds\00", align 1
@.str.118 = private unnamed_addr constant [75 x i8] c"Failover auth denied to %.40s (%s): slot %d epoch (%llu) > reqEpoch (%llu)\00", align 1
@.str.119 = private unnamed_addr constant [51 x i8] c"Failover auth granted to %.40s (%s) for epoch %llu\00", align 1
@.str.120 = private unnamed_addr constant [20 x i8] c"nodeIsSlave(myself)\00", align 1
@clusterLogCantFailover.lastlog_time = internal global i64 0, align 8
@.str.121 = private unnamed_addr constant [123 x i8] c"Disconnected from master for longer than allowed. Please check the 'cluster-replica-validity-factor' configuration option.\00", align 1
@.str.122 = private unnamed_addr constant [53 x i8] c"Waiting the delay before I can start a new failover.\00", align 1
@.str.123 = private unnamed_addr constant [26 x i8] c"Failover attempt expired.\00", align 1
@.str.124 = private unnamed_addr constant [51 x i8] c"Waiting for votes, but majority still not reached.\00", align 1
@.str.125 = private unnamed_addr constant [21 x i8] c"Unknown reason code.\00", align 1
@.str.126 = private unnamed_addr constant [33 x i8] c"Currently unable to failover: %s\00", align 1
@.str.127 = private unnamed_addr constant [55 x i8] c"Needed quorum: %d. Number of votes received so far: %d\00", align 1
@.str.128 = private unnamed_addr constant [73 x i8] c"Start of election delayed for %lld milliseconds (rank #%d, offset %lld).\00", align 1
@.str.129 = private unnamed_addr constant [63 x i8] c"Replica rank updated to #%d, added %lld milliseconds of delay.\00", align 1
@.str.130 = private unnamed_addr constant [45 x i8] c"Starting a failover election for epoch %llu.\00", align 1
@.str.131 = private unnamed_addr constant [43 x i8] c"Failover election won: I'm the new master.\00", align 1
@.str.132 = private unnamed_addr constant [50 x i8] c"configEpoch set to %llu after successful failover\00", align 1
@.str.133 = private unnamed_addr constant [35 x i8] c"Migrating to orphaned master %.40s\00", align 1
@.str.134 = private unnamed_addr constant [27 x i8] c"Manual failover timed out.\00", align 1
@.str.135 = private unnamed_addr constant [68 x i8] c"All master replication stream processed, manual failover can start.\00", align 1
@clusterCron.iteration = internal global i64 0, align 8
@.str.136 = private unnamed_addr constant [19 x i8] c"Pinging node %.40s\00", align 1
@.str.137 = private unnamed_addr constant [32 x i8] c"*** NODE %.40s possibly failing\00", align 1
@.str.138 = private unnamed_addr constant [37 x i8] c"clusterNodeClearSlotBit(n,slot) == 1\00", align 1
@clusterUpdateState.among_minority_time = internal global i64 0, align 8
@clusterUpdateState.first_call_time = internal global i64 0, align 8
@.str.139 = private unnamed_addr constant [26 x i8] c"Cluster state changed: %s\00", align 1
@.str.140 = private unnamed_addr constant [3 x i8] c"ok\00", align 1
@.str.141 = private unnamed_addr constant [66 x i8] c"I have keys for unassigned slot %d. Taking responsibility for it.\00", align 1
@.str.142 = private unnamed_addr constant [98 x i8] c"I have keys for slot %d, but the slot is assigned to another node. Setting it to importing state.\00", align 1
@.str.143 = private unnamed_addr constant [12 x i8] c"n != myself\00", align 1
@.str.144 = private unnamed_addr constant [22 x i8] c"myself->numslots == 0\00", align 1
@redisNodeFlagsTable = internal global [8 x %struct.redisNodeFlags] [%struct.redisNodeFlags { i16 16, ptr @.str.309 }, %struct.redisNodeFlags { i16 1, ptr @.str.310 }, %struct.redisNodeFlags { i16 2, ptr @.str.311 }, %struct.redisNodeFlags { i16 4, ptr @.str.312 }, %struct.redisNodeFlags { i16 8, ptr @.str.313 }, %struct.redisNodeFlags { i16 32, ptr @.str.314 }, %struct.redisNodeFlags { i16 64, ptr @.str.315 }, %struct.redisNodeFlags { i16 512, ptr @.str.316 }], align 16
@.str.145 = private unnamed_addr constant [9 x i8] c"noflags,\00", align 1
@.str.146 = private unnamed_addr constant [4 x i8] c" %i\00", align 1
@.str.147 = private unnamed_addr constant [7 x i8] c" %i-%i\00", align 1
@.str.148 = private unnamed_addr constant [10 x i8] c" %s:%i@%i\00", align 1
@.str.149 = private unnamed_addr constant [4 x i8] c",%s\00", align 1
@.str.150 = private unnamed_addr constant [5 x i8] c",%s=\00", align 1
@.str.151 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.152 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.153 = private unnamed_addr constant [13 x i8] c" %I %I %U %s\00", align 1
@.str.154 = private unnamed_addr constant [10 x i8] c"connected\00", align 1
@.str.155 = private unnamed_addr constant [13 x i8] c"disconnected\00", align 1
@.str.156 = private unnamed_addr constant [14 x i8] c" [%d->-%.40s]\00", align 1
@.str.157 = private unnamed_addr constant [14 x i8] c" [%d-<-%.40s]\00", align 1
@.str.158 = private unnamed_addr constant [51 x i8] c"(n->slot_info_pairs_count + 1) < (2 * n->numslots)\00", align 1
@.str.159 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.160 = private unnamed_addr constant [10 x i8] c"direction\00", align 1
@.str.161 = private unnamed_addr constant [5 x i8] c"from\00", align 1
@.str.162 = private unnamed_addr constant [3 x i8] c"to\00", align 1
@.str.163 = private unnamed_addr constant [11 x i8] c"link->node\00", align 1
@.str.164 = private unnamed_addr constant [5 x i8] c"node\00", align 1
@.str.165 = private unnamed_addr constant [12 x i8] c"create-time\00", align 1
@.str.166 = private unnamed_addr constant [7 x i8] c"events\00", align 1
@.str.167 = private unnamed_addr constant [22 x i8] c"send-buffer-allocated\00", align 1
@.str.168 = private unnamed_addr constant [17 x i8] c"send-buffer-used\00", align 1
@.str.169 = private unnamed_addr constant [5 x i8] c"ping\00", align 1
@.str.170 = private unnamed_addr constant [5 x i8] c"pong\00", align 1
@.str.171 = private unnamed_addr constant [5 x i8] c"meet\00", align 1
@.str.172 = private unnamed_addr constant [8 x i8] c"publish\00", align 1
@.str.173 = private unnamed_addr constant [13 x i8] c"publishshard\00", align 1
@.str.174 = private unnamed_addr constant [9 x i8] c"auth-req\00", align 1
@.str.175 = private unnamed_addr constant [9 x i8] c"auth-ack\00", align 1
@.str.176 = private unnamed_addr constant [7 x i8] c"update\00", align 1
@.str.177 = private unnamed_addr constant [8 x i8] c"mfstart\00", align 1
@.str.178 = private unnamed_addr constant [7 x i8] c"module\00", align 1
@.str.179 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.180 = private unnamed_addr constant [29 x i8] c"Invalid or out of range slot\00", align 1
@.str.181 = private unnamed_addr constant [30 x i8] c"Slot %d is already unassigned\00", align 1
@.str.182 = private unnamed_addr constant [24 x i8] c"Slot %d is already busy\00", align 1
@.str.183 = private unnamed_addr constant [33 x i8] c"Slot %d specified multiple times\00", align 1
@.str.184 = private unnamed_addr constant [15 x i8] c"retval == C_OK\00", align 1
@.str.185 = private unnamed_addr constant [3 x i8] c"id\00", align 1
@.str.186 = private unnamed_addr constant [5 x i8] c"port\00", align 1
@.str.187 = private unnamed_addr constant [3 x i8] c"ip\00", align 1
@.str.188 = private unnamed_addr constant [9 x i8] c"endpoint\00", align 1
@.str.189 = private unnamed_addr constant [9 x i8] c"hostname\00", align 1
@.str.190 = private unnamed_addr constant [5 x i8] c"role\00", align 1
@.str.191 = private unnamed_addr constant [19 x i8] c"replication-offset\00", align 1
@.str.192 = private unnamed_addr constant [7 x i8] c"health\00", align 1
@.str.193 = private unnamed_addr constant [8 x i8] c"loading\00", align 1
@.str.194 = private unnamed_addr constant [7 x i8] c"online\00", align 1
@.str.195 = private unnamed_addr constant [22 x i8] c"listLength(nodes) > 0\00", align 1
@.str.196 = private unnamed_addr constant [6 x i8] c"slots\00", align 1
@.str.197 = private unnamed_addr constant [36 x i8] c"(n->slot_info_pairs_count % 2) == 0\00", align 1
@.str.198 = private unnamed_addr constant [6 x i8] c"nodes\00", align 1
@__const.genClusterInfoString.statestr = private unnamed_addr constant [2 x ptr] [ptr @.str.140, ptr @.str.22], align 16
@.str.199 = private unnamed_addr constant [207 x i8] c"cluster_state:%s\0D\0Acluster_slots_assigned:%d\0D\0Acluster_slots_ok:%d\0D\0Acluster_slots_pfail:%d\0D\0Acluster_slots_fail:%d\0D\0Acluster_known_nodes:%lu\0D\0Acluster_size:%d\0D\0Acluster_current_epoch:%llu\0D\0Acluster_my_epoch:%llu\0D\0A\00", align 1
@.str.200 = private unnamed_addr constant [38 x i8] c"cluster_stats_messages_%s_sent:%lld\0D\0A\00", align 1
@.str.201 = private unnamed_addr constant [35 x i8] c"cluster_stats_messages_sent:%lld\0D\0A\00", align 1
@.str.202 = private unnamed_addr constant [42 x i8] c"cluster_stats_messages_%s_received:%lld\0D\0A\00", align 1
@.str.203 = private unnamed_addr constant [39 x i8] c"cluster_stats_messages_received:%lld\0D\0A\00", align 1
@.str.204 = private unnamed_addr constant [49 x i8] c"total_cluster_links_buffer_limit_exceeded:%llu\0D\0A\00", align 1
@.str.205 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str.206 = private unnamed_addr constant [4 x i8] c"del\00", align 1
@.str.207 = private unnamed_addr constant [12 x i8] c"CLUSTERLINK\00", align 1
@.str.208 = private unnamed_addr constant [5 x i8] c"KILL\00", align 1
@.str.209 = private unnamed_addr constant [60 x i8] c"Debug option only available for cluster mode enabled setup!\00", align 1
@.str.210 = private unnamed_addr constant [16 x i8] c"Unknown node %s\00", align 1
@.str.211 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.212 = private unnamed_addr constant [21 x i8] c"Unknown direction %s\00", align 1
@shared = external global %struct.sharedObjectsStruct, align 8
@clusterDebugCommandExtendedHelp.help = internal global [3 x ptr] [ptr @.str.213, ptr @.str.214, ptr null], align 16
@.str.213 = private unnamed_addr constant [41 x i8] c"CLUSTERLINK KILL <to|from|all> <node-id>\00", align 1
@.str.214 = private unnamed_addr constant [81 x i8] c"    Kills the link based on the direction to/from (both) with the provided node.\00", align 1
@.str.215 = private unnamed_addr constant [32 x i8] c"Invalid base port specified: %s\00", align 1
@.str.216 = private unnamed_addr constant [31 x i8] c"Invalid bus port specified: %s\00", align 1
@.str.217 = private unnamed_addr constant [38 x i8] c"Invalid node address specified: %s:%s\00", align 1
@.str.218 = private unnamed_addr constant [11 x i8] c"flushslots\00", align 1
@.str.219 = private unnamed_addr constant [48 x i8] c"DB must be empty to perform CLUSTER FLUSHSLOTS.\00", align 1
@.str.220 = private unnamed_addr constant [9 x i8] c"addslots\00", align 1
@.str.221 = private unnamed_addr constant [9 x i8] c"delslots\00", align 1
@.str.222 = private unnamed_addr constant [14 x i8] c"addslotsrange\00", align 1
@.str.223 = private unnamed_addr constant [14 x i8] c"delslotsrange\00", align 1
@.str.224 = private unnamed_addr constant [56 x i8] c"start slot number %d is greater than end slot number %d\00", align 1
@.str.225 = private unnamed_addr constant [8 x i8] c"setslot\00", align 1
@.str.226 = private unnamed_addr constant [38 x i8] c"Please use SETSLOT only with masters.\00", align 1
@.str.227 = private unnamed_addr constant [10 x i8] c"migrating\00", align 1
@.str.228 = private unnamed_addr constant [34 x i8] c"I'm not the owner of hash slot %u\00", align 1
@.str.229 = private unnamed_addr constant [27 x i8] c"I don't know about node %s\00", align 1
@.str.230 = private unnamed_addr constant [28 x i8] c"Target node is not a master\00", align 1
@.str.231 = private unnamed_addr constant [10 x i8] c"importing\00", align 1
@.str.232 = private unnamed_addr constant [38 x i8] c"I'm already the owner of hash slot %u\00", align 1
@.str.233 = private unnamed_addr constant [7 x i8] c"stable\00", align 1
@.str.234 = private unnamed_addr constant [89 x i8] c"Can't assign hashslot %d to a different node while I still hold keys for this hash slot.\00", align 1
@.str.235 = private unnamed_addr constant [44 x i8] c"configEpoch updated after importing slot %d\00", align 1
@.str.236 = private unnamed_addr constant [72 x i8] c"Invalid CLUSTER SETSLOT action or number of arguments. Try CLUSTER HELP\00", align 1
@.str.237 = private unnamed_addr constant [10 x i8] c"bumpepoch\00", align 1
@.str.238 = private unnamed_addr constant [11 x i8] c"+%s %llu\0D\0A\00", align 1
@.str.239 = private unnamed_addr constant [7 x i8] c"BUMPED\00", align 1
@.str.240 = private unnamed_addr constant [6 x i8] c"STILL\00", align 1
@.str.241 = private unnamed_addr constant [11 x i8] c"saveconfig\00", align 1
@.str.242 = private unnamed_addr constant [41 x i8] c"error saving the cluster node config: %s\00", align 1
@.str.243 = private unnamed_addr constant [7 x i8] c"forget\00", align 1
@.str.244 = private unnamed_addr constant [42 x i8] c"I tried hard but I can't forget myself...\00", align 1
@.str.245 = private unnamed_addr constant [24 x i8] c"Can't forget my master!\00", align 1
@.str.246 = private unnamed_addr constant [10 x i8] c"replicate\00", align 1
@.str.247 = private unnamed_addr constant [23 x i8] c"Can't replicate myself\00", align 1
@.str.248 = private unnamed_addr constant [46 x i8] c"I can only replicate a master, not a replica.\00", align 1
@.str.249 = private unnamed_addr constant [67 x i8] c"To set a master the node must be empty and without assigned slots.\00", align 1
@.str.250 = private unnamed_addr constant [22 x i8] c"count-failure-reports\00", align 1
@.str.251 = private unnamed_addr constant [9 x i8] c"failover\00", align 1
@.str.252 = private unnamed_addr constant [6 x i8] c"force\00", align 1
@.str.253 = private unnamed_addr constant [9 x i8] c"takeover\00", align 1
@.str.254 = private unnamed_addr constant [46 x i8] c"You should send CLUSTER FAILOVER to a replica\00", align 1
@.str.255 = private unnamed_addr constant [45 x i8] c"I'm a replica but my master is unknown to me\00", align 1
@.str.256 = private unnamed_addr constant [60 x i8] c"Master is down or failed, please use CLUSTER FAILOVER FORCE\00", align 1
@.str.257 = private unnamed_addr constant [39 x i8] c"Taking over the master (user request).\00", align 1
@.str.258 = private unnamed_addr constant [39 x i8] c"Forced failover user request accepted.\00", align 1
@.str.259 = private unnamed_addr constant [39 x i8] c"Manual failover user request accepted.\00", align 1
@.str.260 = private unnamed_addr constant [17 x i8] c"set-config-epoch\00", align 1
@.str.261 = private unnamed_addr constant [37 x i8] c"Invalid config epoch specified: %lld\00", align 1
@.str.262 = private unnamed_addr constant [84 x i8] c"The user can assign a config epoch only when the node does not know any other node.\00", align 1
@.str.263 = private unnamed_addr constant [38 x i8] c"Node config epoch is already non-zero\00", align 1
@.str.264 = private unnamed_addr constant [53 x i8] c"configEpoch set to %llu via CLUSTER SET-CONFIG-EPOCH\00", align 1
@.str.265 = private unnamed_addr constant [6 x i8] c"reset\00", align 1
@.str.266 = private unnamed_addr constant [5 x i8] c"hard\00", align 1
@.str.267 = private unnamed_addr constant [5 x i8] c"soft\00", align 1
@.str.268 = private unnamed_addr constant [64 x i8] c"CLUSTER RESET can't be called with master nodes containing keys\00", align 1
@.str.269 = private unnamed_addr constant [6 x i8] c"links\00", align 1
@clusterCommandExtendedHelp.help = internal global [34 x ptr] [ptr @.str.270, ptr @.str.271, ptr @.str.272, ptr @.str.273, ptr @.str.274, ptr @.str.275, ptr @.str.276, ptr @.str.277, ptr @.str.278, ptr @.str.279, ptr @.str.280, ptr @.str.281, ptr @.str.282, ptr @.str.283, ptr @.str.284, ptr @.str.285, ptr @.str.286, ptr @.str.287, ptr @.str.288, ptr @.str.289, ptr @.str.290, ptr @.str.291, ptr @.str.292, ptr @.str.293, ptr @.str.294, ptr @.str.295, ptr @.str.296, ptr @.str.297, ptr @.str.298, ptr @.str.299, ptr @.str.300, ptr @.str.301, ptr @.str.302, ptr null], align 16
@.str.270 = private unnamed_addr constant [29 x i8] c"ADDSLOTS <slot> [<slot> ...]\00", align 1
@.str.271 = private unnamed_addr constant [34 x i8] c"    Assign slots to current node.\00", align 1
@.str.272 = private unnamed_addr constant [68 x i8] c"ADDSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]\00", align 1
@.str.273 = private unnamed_addr constant [80 x i8] c"    Assign slots which are between <start-slot> and <end-slot> to current node.\00", align 1
@.str.274 = private unnamed_addr constant [10 x i8] c"BUMPEPOCH\00", align 1
@.str.275 = private unnamed_addr constant [38 x i8] c"    Advance the cluster config epoch.\00", align 1
@.str.276 = private unnamed_addr constant [32 x i8] c"COUNT-FAILURE-REPORTS <node-id>\00", align 1
@.str.277 = private unnamed_addr constant [52 x i8] c"    Return number of failure reports for <node-id>.\00", align 1
@.str.278 = private unnamed_addr constant [29 x i8] c"DELSLOTS <slot> [<slot> ...]\00", align 1
@.str.279 = private unnamed_addr constant [48 x i8] c"    Delete slots information from current node.\00", align 1
@.str.280 = private unnamed_addr constant [68 x i8] c"DELSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]\00", align 1
@.str.281 = private unnamed_addr constant [94 x i8] c"    Delete slots information which are between <start-slot> and <end-slot> from current node.\00", align 1
@.str.282 = private unnamed_addr constant [26 x i8] c"FAILOVER [FORCE|TAKEOVER]\00", align 1
@.str.283 = private unnamed_addr constant [52 x i8] c"    Promote current replica node to being a master.\00", align 1
@.str.284 = private unnamed_addr constant [17 x i8] c"FORGET <node-id>\00", align 1
@.str.285 = private unnamed_addr constant [36 x i8] c"    Remove a node from the cluster.\00", align 1
@.str.286 = private unnamed_addr constant [11 x i8] c"FLUSHSLOTS\00", align 1
@.str.287 = private unnamed_addr constant [47 x i8] c"    Delete current node own slots information.\00", align 1
@.str.288 = private unnamed_addr constant [30 x i8] c"MEET <ip> <port> [<bus-port>]\00", align 1
@.str.289 = private unnamed_addr constant [42 x i8] c"    Connect nodes into a working cluster.\00", align 1
@.str.290 = private unnamed_addr constant [20 x i8] c"REPLICATE <node-id>\00", align 1
@.str.291 = private unnamed_addr constant [52 x i8] c"    Configure current node as replica to <node-id>.\00", align 1
@.str.292 = private unnamed_addr constant [18 x i8] c"RESET [HARD|SOFT]\00", align 1
@.str.293 = private unnamed_addr constant [40 x i8] c"    Reset current node (default: soft).\00", align 1
@.str.294 = private unnamed_addr constant [25 x i8] c"SET-CONFIG-EPOCH <epoch>\00", align 1
@.str.295 = private unnamed_addr constant [38 x i8] c"    Set config epoch of current node.\00", align 1
@.str.296 = private unnamed_addr constant [79 x i8] c"SETSLOT <slot> (IMPORTING <node-id>|MIGRATING <node-id>|STABLE|NODE <node-id>)\00", align 1
@.str.297 = private unnamed_addr constant [20 x i8] c"    Set slot state.\00", align 1
@.str.298 = private unnamed_addr constant [11 x i8] c"SAVECONFIG\00", align 1
@.str.299 = private unnamed_addr constant [48 x i8] c"    Force saving cluster configuration on disk.\00", align 1
@.str.300 = private unnamed_addr constant [6 x i8] c"LINKS\00", align 1
@.str.301 = private unnamed_addr constant [80 x i8] c"    Return information about all network links between this node and its peers.\00", align 1
@.str.302 = private unnamed_addr constant [96 x i8] c"    Output format is an array where each array element is a map containing attributes of a link\00", align 1
@.str.303 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.304 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.305 = private unnamed_addr constant [76 x i8] c"FAILOVER not allowed in cluster mode. Use CLUSTER FAILOVER command instead.\00", align 1
@.str.306 = private unnamed_addr constant [24 x i8] c"msgblock->refcount >= 0\00", align 1
@.str.307 = private unnamed_addr constant [98 x i8] c"Freeing cluster link(%s node %.40s, used memory: %llu) due to exceeding send buffer memory limit.\00", align 1
@.str.308 = private unnamed_addr constant [48 x i8] c"Unable to connect to Cluster Node [%s]:%d -> %s\00", align 1
@.str.309 = private unnamed_addr constant [8 x i8] c"myself,\00", align 1
@.str.310 = private unnamed_addr constant [8 x i8] c"master,\00", align 1
@.str.311 = private unnamed_addr constant [7 x i8] c"slave,\00", align 1
@.str.312 = private unnamed_addr constant [7 x i8] c"fail?,\00", align 1
@.str.313 = private unnamed_addr constant [6 x i8] c"fail,\00", align 1
@.str.314 = private unnamed_addr constant [11 x i8] c"handshake,\00", align 1
@.str.315 = private unnamed_addr constant [8 x i8] c"noaddr,\00", align 1
@.str.316 = private unnamed_addr constant [12 x i8] c"nofailover,\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @getNodeDefaultClientPort(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %n.addr, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 25
  %2 = load i32, ptr %tls_port, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 24
  %4 = load i32, ptr %tcp_port, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ %4, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeClientPort(ptr noundef %n, i32 noundef %use_tls) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %use_tls.addr = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 %use_tls, ptr %use_tls.addr, align 4
  %0 = load i32, ptr %use_tls.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %n.addr, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 25
  %2 = load i32, ptr %tls_port, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 24
  %4 = load i32, ptr %tcp_port, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ %4, %cond.false ]
  ret i32 %cond
}

declare i64 @dictSdsHash(ptr noundef) #1

declare i32 @dictSdsKeyCompare(ptr noundef, ptr noundef, ptr noundef) #1

declare void @dictSdsDestructor(ptr noundef, ptr noundef) #1

declare i64 @dictSdsCaseHash(ptr noundef) #1

declare i32 @dictSdsKeyCaseCompare(ptr noundef, ptr noundef, ptr noundef) #1

declare void @dictListDestructor(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @auxShardIdSetter(ptr noundef %n, ptr noundef %value, i32 noundef %length) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %length.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %length, ptr %length.addr, align 4
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i32, ptr %length.addr, align 4
  %call = call i32 @verifyClusterNodeId(ptr noundef %0, i32 noundef %1)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 2
  %arraydecay = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  %3 = load ptr, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %3, i64 40, i1 false)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, ptr %i, align 4
  %5 = load ptr, ptr %n.addr, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 9
  %6 = load i32, ptr %numslaves, align 8
  %cmp1 = icmp slt i32 %4, %6
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %n.addr, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 10
  %8 = load ptr, ptr %slaves, align 8
  %9 = load i32, ptr %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %8, i64 %idxprom
  %10 = load ptr, ptr %arrayidx, align 8
  %shard_id2 = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 2
  %arraydecay3 = getelementptr inbounds [40 x i8], ptr %shard_id2, i64 0, i64 0
  %11 = load ptr, ptr %n.addr, align 8
  %shard_id4 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 2
  %arraydecay5 = getelementptr inbounds [40 x i8], ptr %shard_id4, i64 0, i64 0
  %call6 = call i32 @memcmp(ptr noundef %arraydecay3, ptr noundef %arraydecay5, i64 noundef 40) #12
  %cmp7 = icmp ne i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.body
  store i32 -1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %12 = load i32, ptr %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !5

for.end:                                          ; preds = %for.cond
  %13 = load ptr, ptr %value.addr, align 8
  %14 = load ptr, ptr %n.addr, align 8
  call void @clusterAddNodeToShard(ptr noundef %13, ptr noundef %14)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then8, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define dso_local ptr @auxShardIdGetter(ptr noundef %n, ptr noundef %s) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 2
  %arraydecay = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  %call = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %0, ptr noundef @.str.4, ptr noundef %arraydecay)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @auxShardIdPresent(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  %call = call i64 @strlen(ptr noundef %arraydecay) #12
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @auxHumanNodenameSetter(ptr noundef %n, ptr noundef %value, i32 noundef %length) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %length.addr = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %length, ptr %length.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %value.addr, align 8
  %2 = load ptr, ptr %n.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 23
  %3 = load ptr, ptr %human_nodename, align 8
  %4 = load i32, ptr %length.addr, align 4
  %conv = sext i32 %4 to i64
  %call = call i32 @strncmp(ptr noundef %1, ptr noundef %3, i64 noundef %conv) #12
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %5 = load ptr, ptr %n.addr, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %if.end, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %if.else
  %6 = load i32, ptr %length.addr, align 4
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %if.then5, label %if.end

if.then5:                                         ; preds = %land.lhs.true3
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %7 = load ptr, ptr %n.addr, align 8
  %tobool7 = icmp ne ptr %7, null
  br i1 %tobool7, label %if.then8, label %if.else13

if.then8:                                         ; preds = %if.end6
  %8 = load ptr, ptr %n.addr, align 8
  %human_nodename9 = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 23
  %9 = load ptr, ptr %human_nodename9, align 8
  %10 = load ptr, ptr %value.addr, align 8
  %11 = load i32, ptr %length.addr, align 4
  %conv10 = sext i32 %11 to i64
  %call11 = call ptr @sdscpylen(ptr noundef %9, ptr noundef %10, i64 noundef %conv10)
  %12 = load ptr, ptr %n.addr, align 8
  %human_nodename12 = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 23
  store ptr %call11, ptr %human_nodename12, align 8
  br label %if.end22

if.else13:                                        ; preds = %if.end6
  %13 = load ptr, ptr %n.addr, align 8
  %human_nodename14 = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 23
  %14 = load ptr, ptr %human_nodename14, align 8
  %call15 = call i64 @sdslen(ptr noundef %14)
  %cmp16 = icmp ne i64 %call15, 0
  br i1 %cmp16, label %if.then18, label %if.else20

if.then18:                                        ; preds = %if.else13
  %15 = load ptr, ptr %n.addr, align 8
  %human_nodename19 = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 23
  %16 = load ptr, ptr %human_nodename19, align 8
  call void @sdsclear(ptr noundef %16)
  br label %if.end21

if.else20:                                        ; preds = %if.else13
  store i32 -1, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.then18
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.else20, %if.then5, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define dso_local ptr @auxHumanNodenameGetter(ptr noundef %n, ptr noundef %s) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 23
  %2 = load ptr, ptr %human_nodename, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %0, ptr noundef @.str.5, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @auxHumanNodenamePresent(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 23
  %1 = load ptr, ptr %human_nodename, align 8
  %call = call i64 @sdslen(ptr noundef %1)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @auxTcpPortSetter(ptr noundef %n, ptr noundef %value, i32 noundef %length) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %length.addr = alloca i32, align 4
  %saved_stack = alloca ptr, align 8
  %__vla_expr0 = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %length, ptr %length.addr, align 4
  %0 = load i32, ptr %length.addr, align 4
  %cmp = icmp sgt i32 %0, 5
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp slt i32 %1, 1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %length.addr, align 4
  %add = add nsw i32 %2, 1
  %3 = zext i32 %add to i64
  %4 = call ptr @llvm.stacksave.p0()
  store ptr %4, ptr %saved_stack, align 8
  %vla = alloca i8, i64 %3, align 16
  store i64 %3, ptr %__vla_expr0, align 8
  %5 = load ptr, ptr %value.addr, align 8
  %6 = load i32, ptr %length.addr, align 4
  %conv = sext i32 %6 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %vla, ptr align 1 %5, i64 %conv, i1 false)
  %7 = load i32, ptr %length.addr, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds i8, ptr %vla, i64 %idxprom
  store i8 0, ptr %arrayidx, align 1
  %call = call i32 @atoi(ptr noundef %vla) #12
  %8 = load ptr, ptr %n.addr, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 24
  store i32 %call, ptr %tcp_port, align 8
  %9 = load ptr, ptr %n.addr, align 8
  %tcp_port2 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 24
  %10 = load i32, ptr %tcp_port2, align 8
  %cmp3 = icmp slt i32 %10, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end
  %11 = load ptr, ptr %n.addr, align 8
  %tcp_port5 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 24
  %12 = load i32, ptr %tcp_port5, align 8
  %cmp6 = icmp sge i32 %12, 65536
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %13 = phi i1 [ true, %if.end ], [ %cmp6, %lor.rhs ]
  %cond = select i1 %13, i32 -1, i32 0
  store i32 %cond, ptr %retval, align 4
  %14 = load ptr, ptr %saved_stack, align 8
  call void @llvm.stackrestore.p0(ptr %14)
  br label %return

return:                                           ; preds = %lor.end, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define dso_local ptr @auxTcpPortGetter(ptr noundef %n, ptr noundef %s) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 24
  %2 = load i32, ptr %tcp_port, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %0, ptr noundef @.str.6, i32 noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @auxTcpPortPresent(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 24
  %1 = load i32, ptr %tcp_port, align 8
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %tcp_port1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 24
  %3 = load i32, ptr %tcp_port1, align 8
  %cmp2 = icmp slt i32 %3, 65536
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define dso_local i32 @auxTlsPortSetter(ptr noundef %n, ptr noundef %value, i32 noundef %length) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %length.addr = alloca i32, align 4
  %saved_stack = alloca ptr, align 8
  %__vla_expr0 = alloca i64, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %length, ptr %length.addr, align 4
  %0 = load i32, ptr %length.addr, align 4
  %cmp = icmp sgt i32 %0, 5
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp slt i32 %1, 1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, ptr %length.addr, align 4
  %add = add nsw i32 %2, 1
  %3 = zext i32 %add to i64
  %4 = call ptr @llvm.stacksave.p0()
  store ptr %4, ptr %saved_stack, align 8
  %vla = alloca i8, i64 %3, align 16
  store i64 %3, ptr %__vla_expr0, align 8
  %5 = load ptr, ptr %value.addr, align 8
  %6 = load i32, ptr %length.addr, align 4
  %conv = sext i32 %6 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %vla, ptr align 1 %5, i64 %conv, i1 false)
  %7 = load i32, ptr %length.addr, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds i8, ptr %vla, i64 %idxprom
  store i8 0, ptr %arrayidx, align 1
  %call = call i32 @atoi(ptr noundef %vla) #12
  %8 = load ptr, ptr %n.addr, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 25
  store i32 %call, ptr %tls_port, align 4
  %9 = load ptr, ptr %n.addr, align 8
  %tls_port2 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 25
  %10 = load i32, ptr %tls_port2, align 4
  %cmp3 = icmp slt i32 %10, 0
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end
  %11 = load ptr, ptr %n.addr, align 8
  %tls_port5 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 25
  %12 = load i32, ptr %tls_port5, align 4
  %cmp6 = icmp sge i32 %12, 65536
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %13 = phi i1 [ true, %if.end ], [ %cmp6, %lor.rhs ]
  %cond = select i1 %13, i32 -1, i32 0
  store i32 %cond, ptr %retval, align 4
  %14 = load ptr, ptr %saved_stack, align 8
  call void @llvm.stackrestore.p0(ptr %14)
  br label %return

return:                                           ; preds = %lor.end, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define dso_local ptr @auxTlsPortGetter(ptr noundef %n, ptr noundef %s) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %n.addr, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 25
  %2 = load i32, ptr %tls_port, align 4
  %call = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %0, ptr noundef @.str.6, i32 noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @auxTlsPortPresent(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 25
  %1 = load i32, ptr %tls_port, align 4
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %tls_port1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 25
  %3 = load i32, ptr %tls_port1, align 4
  %cmp2 = icmp slt i32 %3, 65536
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

declare i32 @verifyClusterNodeId(ptr noundef, i32 noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #2

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #3

; Function Attrs: nounwind uwtable
define dso_local void @clusterAddNodeToShard(ptr noundef %shard_id, ptr noundef %node) #0 {
entry:
  %shard_id.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %de = alloca ptr, align 8
  %l = alloca ptr, align 8
  %l8 = alloca ptr, align 8
  store ptr %shard_id, ptr %shard_id.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %shard_id.addr, align 8
  %call = call ptr @sdsnewlen(ptr noundef %0, i64 noundef 40)
  store ptr %call, ptr %s, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 5
  %2 = load ptr, ptr %shards, align 8
  %3 = load ptr, ptr %s, align 8
  %call1 = call ptr @dictFind(ptr noundef %2, ptr noundef %3)
  store ptr %call1, ptr %de, align 8
  %4 = load ptr, ptr %de, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call2 = call ptr @listCreate()
  store ptr %call2, ptr %l, align 8
  %5 = load ptr, ptr %l, align 8
  %6 = load ptr, ptr %node.addr, align 8
  %call3 = call ptr @listAddNodeTail(ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards4 = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %shards4, align 8
  %9 = load ptr, ptr %s, align 8
  %10 = load ptr, ptr %l, align 8
  %call5 = call i32 @dictAdd(ptr noundef %8, ptr noundef %9, ptr noundef %10)
  %cmp6 = icmp eq i32 %call5, 0
  %lnot = xor i1 %cmp6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  call void @_serverAssert(ptr noundef @.str.62, ptr noundef @.str.18, i32 noundef 1623)
  call void @abort() #13
  unreachable

11:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %11, %cond.true
  br label %if.end15

if.else:                                          ; preds = %entry
  %12 = load ptr, ptr %de, align 8
  %call9 = call ptr @dictGetVal(ptr noundef %12)
  store ptr %call9, ptr %l8, align 8
  %13 = load ptr, ptr %l8, align 8
  %14 = load ptr, ptr %node.addr, align 8
  %call10 = call ptr @listSearchKey(ptr noundef %13, ptr noundef %14)
  %cmp11 = icmp eq ptr %call10, null
  br i1 %cmp11, label %if.then13, label %if.end

if.then13:                                        ; preds = %if.else
  %15 = load ptr, ptr %l8, align 8
  %16 = load ptr, ptr %node.addr, align 8
  %call14 = call ptr @listAddNodeTail(ptr noundef %15, ptr noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.else
  %17 = load ptr, ptr %s, align 8
  call void @sdsfree(ptr noundef %17)
  br label %if.end15

if.end15:                                         ; preds = %if.end, %cond.end
  ret void
}

declare ptr @sdscatprintf(ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #3

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strncmp(ptr noundef, ptr noundef, i64 noundef) #3

declare ptr @sdscpylen(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @sdslen(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %flags = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %flags, align 1
  %2 = load i8, ptr %flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %3 = load i8, ptr %flags, align 1
  %conv1 = zext i8 %3 to i32
  %shr = ashr i32 %conv1, 3
  %conv2 = sext i32 %shr to i64
  store i64 %conv2, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 -3
  %len = getelementptr inbounds %struct.sdshdr8, ptr %add.ptr, i32 0, i32 0
  %5 = load i8, ptr %len, align 1
  %conv4 = zext i8 %5 to i64
  store i64 %conv4, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  %6 = load ptr, ptr %s.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, ptr %6, i64 -5
  %len7 = getelementptr inbounds %struct.sdshdr16, ptr %add.ptr6, i32 0, i32 0
  %7 = load i16, ptr %len7, align 1
  %conv8 = zext i16 %7 to i64
  store i64 %conv8, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, ptr %8, i64 -9
  %len11 = getelementptr inbounds %struct.sdshdr32, ptr %add.ptr10, i32 0, i32 0
  %9 = load i32, ptr %len11, align 1
  %conv12 = zext i32 %9 to i64
  store i64 %conv12, ptr %retval, align 8
  br label %return

sw.bb13:                                          ; preds = %entry
  %10 = load ptr, ptr %s.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, ptr %10, i64 -17
  %len15 = getelementptr inbounds %struct.sdshdr64, ptr %add.ptr14, i32 0, i32 0
  %11 = load i64, ptr %len15, align 1
  store i64 %11, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

declare void @sdsclear(ptr noundef) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #4

; Function Attrs: nounwind willreturn memory(read)
declare i32 @atoi(ptr noundef) #3

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore.p0(ptr) #4

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterLoadConfig(ptr noundef %filename) #0 {
entry:
  %retval = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %fp = alloca ptr, align 8
  %sb = alloca %struct.stat, align 8
  %line = alloca ptr, align 8
  %maxline = alloca i32, align 4
  %j = alloca i32, align 4
  %argc = alloca i32, align 4
  %aux_argc = alloca i32, align 4
  %argv = alloca ptr, align 8
  %aux_argv = alloca ptr, align 8
  %n = alloca ptr, align 8
  %master = alloca ptr, align 8
  %p = alloca ptr, align 8
  %s = alloca ptr, align 8
  %aux_tcp_port = alloca i32, align 4
  %aux_tls_port = alloca i32, align 4
  %i = alloca i32, align 4
  %field_argc = alloca i32, align 4
  %field_argv = alloca ptr, align 8
  %j155 = alloca i32, align 4
  %field_found = alloca i32, align 4
  %j172 = alloca i32, align 4
  %port = alloca ptr, align 8
  %busp = alloca ptr, align 8
  %start = alloca i32, align 4
  %stop = alloca i32, align 4
  %slot = alloca i32, align 4
  %direction = alloca i8, align 1
  %cn = alloca ptr, align 8
  %pr = alloca ptr, align 8
  %node_len = alloca i64, align 8
  store ptr %filename, ptr %filename.addr, align 8
  %0 = load ptr, ptr %filename.addr, align 8
  %call = call noalias ptr @fopen64(ptr noundef %0, ptr noundef @.str.7)
  store ptr %call, ptr %fp, align 8
  %1 = load ptr, ptr %fp, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #14
  %2 = load i32, ptr %call1, align 4
  %cmp2 = icmp eq i32 %2, 2
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then
  store i32 -1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.else
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp4 = icmp slt i32 3, %3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %4 = load ptr, ptr %filename.addr, align 8
  %call6 = call ptr @__errno_location() #14
  %5 = load i32, ptr %call6, align 4
  %call7 = call ptr @strerror(i32 noundef %5) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.8, ptr noundef %4, ptr noundef %call7)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then5
  call void @exit(i32 noundef 1) #13
  unreachable

if.end8:                                          ; preds = %entry
  %6 = load ptr, ptr %fp, align 8
  %call9 = call i32 @fileno(ptr noundef %6) #15
  %call10 = call i32 @fstat64(i32 noundef %call9, ptr noundef %sb) #15
  %cmp11 = icmp eq i32 %call10, -1
  br i1 %cmp11, label %if.then12, label %if.end20

if.then12:                                        ; preds = %if.end8
  br label %do.body13

do.body13:                                        ; preds = %if.then12
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp14 = icmp slt i32 3, %7
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %do.body13
  br label %do.end19

if.end16:                                         ; preds = %do.body13
  %8 = load ptr, ptr %filename.addr, align 8
  %call17 = call ptr @__errno_location() #14
  %9 = load i32, ptr %call17, align 4
  %call18 = call ptr @strerror(i32 noundef %9) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.9, ptr noundef %8, ptr noundef %call18)
  br label %do.end19

do.end19:                                         ; preds = %if.end16, %if.then15
  call void @exit(i32 noundef 1) #13
  unreachable

if.end20:                                         ; preds = %if.end8
  %st_size = getelementptr inbounds %struct.stat, ptr %sb, i32 0, i32 8
  %10 = load i64, ptr %st_size, align 8
  %cmp21 = icmp eq i64 %10, 0
  br i1 %cmp21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end20
  %11 = load ptr, ptr %fp, align 8
  %call23 = call i32 @fclose(ptr noundef %11)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end20
  store i32 2098176, ptr %maxline, align 4
  %12 = load i32, ptr %maxline, align 4
  %conv = sext i32 %12 to i64
  %call25 = call noalias ptr @zmalloc(i64 noundef %conv) #16
  store ptr %call25, ptr %line, align 8
  br label %while.cond

while.cond:                                       ; preds = %for.end531, %for.end, %if.then36, %if.end24
  %13 = load ptr, ptr %line, align 8
  %14 = load i32, ptr %maxline, align 4
  %15 = load ptr, ptr %fp, align 8
  %call26 = call ptr @fgets(ptr noundef %13, i32 noundef %14, ptr noundef %15)
  %cmp27 = icmp ne ptr %call26, null
  br i1 %cmp27, label %while.body, label %while.end532

while.body:                                       ; preds = %while.cond
  %16 = load ptr, ptr %line, align 8
  %arrayidx = getelementptr inbounds i8, ptr %16, i64 0
  %17 = load i8, ptr %arrayidx, align 1
  %conv29 = sext i8 %17 to i32
  %cmp30 = icmp eq i32 %conv29, 10
  br i1 %cmp30, label %if.then36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %18 = load ptr, ptr %line, align 8
  %arrayidx32 = getelementptr inbounds i8, ptr %18, i64 0
  %19 = load i8, ptr %arrayidx32, align 1
  %conv33 = sext i8 %19 to i32
  %cmp34 = icmp eq i32 %conv33, 0
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %lor.lhs.false, %while.body
  br label %while.cond, !llvm.loop !7

if.end37:                                         ; preds = %lor.lhs.false
  %20 = load ptr, ptr %line, align 8
  %call38 = call ptr @sdssplitargs(ptr noundef %20, ptr noundef %argc)
  store ptr %call38, ptr %argv, align 8
  %21 = load ptr, ptr %argv, align 8
  %cmp39 = icmp eq ptr %21, null
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end37
  br label %fmterr

if.end42:                                         ; preds = %if.end37
  %22 = load ptr, ptr %argv, align 8
  %arrayidx43 = getelementptr inbounds ptr, ptr %22, i64 0
  %23 = load ptr, ptr %arrayidx43, align 8
  %call44 = call i32 @strcasecmp(ptr noundef %23, ptr noundef @.str.10) #12
  %cmp45 = icmp eq i32 %call44, 0
  br i1 %cmp45, label %if.then47, label %if.end83

if.then47:                                        ; preds = %if.end42
  %24 = load i32, ptr %argc, align 4
  %rem = srem i32 %24, 2
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.then47
  br label %fmterr

if.end49:                                         ; preds = %if.then47
  store i32 1, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end49
  %25 = load i32, ptr %j, align 4
  %26 = load i32, ptr %argc, align 4
  %cmp50 = icmp slt i32 %25, %26
  br i1 %cmp50, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %27 = load ptr, ptr %argv, align 8
  %28 = load i32, ptr %j, align 4
  %idxprom = sext i32 %28 to i64
  %arrayidx52 = getelementptr inbounds ptr, ptr %27, i64 %idxprom
  %29 = load ptr, ptr %arrayidx52, align 8
  %call53 = call i32 @strcasecmp(ptr noundef %29, ptr noundef @.str.11) #12
  %cmp54 = icmp eq i32 %call53, 0
  br i1 %cmp54, label %if.then56, label %if.else60

if.then56:                                        ; preds = %for.body
  %30 = load ptr, ptr %argv, align 8
  %31 = load i32, ptr %j, align 4
  %add = add nsw i32 %31, 1
  %idxprom57 = sext i32 %add to i64
  %arrayidx58 = getelementptr inbounds ptr, ptr %30, i64 %idxprom57
  %32 = load ptr, ptr %arrayidx58, align 8
  %call59 = call i64 @strtoull(ptr noundef %32, ptr noundef null, i32 noundef 10) #15
  %33 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %33, i32 0, i32 1
  store i64 %call59, ptr %currentEpoch, align 8
  br label %if.end81

if.else60:                                        ; preds = %for.body
  %34 = load ptr, ptr %argv, align 8
  %35 = load i32, ptr %j, align 4
  %idxprom61 = sext i32 %35 to i64
  %arrayidx62 = getelementptr inbounds ptr, ptr %34, i64 %idxprom61
  %36 = load ptr, ptr %arrayidx62, align 8
  %call63 = call i32 @strcasecmp(ptr noundef %36, ptr noundef @.str.12) #12
  %cmp64 = icmp eq i32 %call63, 0
  br i1 %cmp64, label %if.then66, label %if.else71

if.then66:                                        ; preds = %if.else60
  %37 = load ptr, ptr %argv, align 8
  %38 = load i32, ptr %j, align 4
  %add67 = add nsw i32 %38, 1
  %idxprom68 = sext i32 %add67 to i64
  %arrayidx69 = getelementptr inbounds ptr, ptr %37, i64 %idxprom68
  %39 = load ptr, ptr %arrayidx69, align 8
  %call70 = call i64 @strtoull(ptr noundef %39, ptr noundef null, i32 noundef 10) #15
  %40 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %40, i32 0, i32 21
  store i64 %call70, ptr %lastVoteEpoch, align 8
  br label %if.end80

if.else71:                                        ; preds = %if.else60
  br label %do.body72

do.body72:                                        ; preds = %if.else71
  %41 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp73 = icmp slt i32 2, %41
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %do.body72
  br label %do.end79

if.end76:                                         ; preds = %do.body72
  %42 = load ptr, ptr %argv, align 8
  %43 = load i32, ptr %j, align 4
  %idxprom77 = sext i32 %43 to i64
  %arrayidx78 = getelementptr inbounds ptr, ptr %42, i64 %idxprom77
  %44 = load ptr, ptr %arrayidx78, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.13, ptr noundef %44)
  br label %do.end79

do.end79:                                         ; preds = %if.end76, %if.then75
  br label %if.end80

if.end80:                                         ; preds = %do.end79, %if.then66
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %if.then56
  br label %for.inc

for.inc:                                          ; preds = %if.end81
  %45 = load i32, ptr %j, align 4
  %add82 = add nsw i32 %45, 2
  store i32 %add82, ptr %j, align 4
  br label %for.cond, !llvm.loop !8

for.end:                                          ; preds = %for.cond
  %46 = load ptr, ptr %argv, align 8
  %47 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %46, i32 noundef %47)
  br label %while.cond, !llvm.loop !7

if.end83:                                         ; preds = %if.end42
  %48 = load i32, ptr %argc, align 4
  %cmp84 = icmp slt i32 %48, 8
  br i1 %cmp84, label %if.then86, label %if.end87

if.then86:                                        ; preds = %if.end83
  %49 = load ptr, ptr %argv, align 8
  %50 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %49, i32 noundef %50)
  br label %fmterr

if.end87:                                         ; preds = %if.end83
  %51 = load ptr, ptr %argv, align 8
  %arrayidx88 = getelementptr inbounds ptr, ptr %51, i64 0
  %52 = load ptr, ptr %arrayidx88, align 8
  %53 = load ptr, ptr %argv, align 8
  %arrayidx89 = getelementptr inbounds ptr, ptr %53, i64 0
  %54 = load ptr, ptr %arrayidx89, align 8
  %call90 = call i64 @sdslen(ptr noundef %54)
  %conv91 = trunc i64 %call90 to i32
  %call92 = call i32 @verifyClusterNodeId(ptr noundef %52, i32 noundef %conv91)
  %cmp93 = icmp eq i32 %call92, -1
  br i1 %cmp93, label %if.then95, label %if.end96

if.then95:                                        ; preds = %if.end87
  %55 = load ptr, ptr %argv, align 8
  %56 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %55, i32 noundef %56)
  br label %fmterr

if.end96:                                         ; preds = %if.end87
  %57 = load ptr, ptr %argv, align 8
  %arrayidx97 = getelementptr inbounds ptr, ptr %57, i64 0
  %58 = load ptr, ptr %arrayidx97, align 8
  %59 = load ptr, ptr %argv, align 8
  %arrayidx98 = getelementptr inbounds ptr, ptr %59, i64 0
  %60 = load ptr, ptr %arrayidx98, align 8
  %call99 = call i64 @sdslen(ptr noundef %60)
  %conv100 = trunc i64 %call99 to i32
  %call101 = call ptr @clusterLookupNode(ptr noundef %58, i32 noundef %conv100)
  store ptr %call101, ptr %n, align 8
  %61 = load ptr, ptr %n, align 8
  %tobool102 = icmp ne ptr %61, null
  br i1 %tobool102, label %if.end106, label %if.then103

if.then103:                                       ; preds = %if.end96
  %62 = load ptr, ptr %argv, align 8
  %arrayidx104 = getelementptr inbounds ptr, ptr %62, i64 0
  %63 = load ptr, ptr %arrayidx104, align 8
  %call105 = call ptr @createClusterNode(ptr noundef %63, i32 noundef 0)
  store ptr %call105, ptr %n, align 8
  %64 = load ptr, ptr %n, align 8
  call void @clusterAddNode(ptr noundef %64)
  br label %if.end106

if.end106:                                        ; preds = %if.then103, %if.end96
  %65 = load ptr, ptr %argv, align 8
  %arrayidx107 = getelementptr inbounds ptr, ptr %65, i64 1
  %66 = load ptr, ptr %arrayidx107, align 8
  %67 = load ptr, ptr %argv, align 8
  %arrayidx108 = getelementptr inbounds ptr, ptr %67, i64 1
  %68 = load ptr, ptr %arrayidx108, align 8
  %call109 = call i64 @sdslen(ptr noundef %68)
  %call110 = call ptr @sdssplitlen(ptr noundef %66, i64 noundef %call109, ptr noundef @.str.14, i32 noundef 1, ptr noundef %aux_argc)
  store ptr %call110, ptr %aux_argv, align 8
  %69 = load ptr, ptr %aux_argv, align 8
  %cmp111 = icmp eq ptr %69, null
  br i1 %cmp111, label %if.then113, label %if.end114

if.then113:                                       ; preds = %if.end106
  %70 = load ptr, ptr %argv, align 8
  %71 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %70, i32 noundef %71)
  br label %fmterr

if.end114:                                        ; preds = %if.end106
  %72 = load i32, ptr %aux_argc, align 4
  %cmp115 = icmp sgt i32 %72, 1
  br i1 %cmp115, label %land.lhs.true, label %if.else125

land.lhs.true:                                    ; preds = %if.end114
  %73 = load ptr, ptr %aux_argv, align 8
  %arrayidx117 = getelementptr inbounds ptr, ptr %73, i64 1
  %74 = load ptr, ptr %arrayidx117, align 8
  %call118 = call i64 @sdslen(ptr noundef %74)
  %cmp119 = icmp ugt i64 %call118, 0
  br i1 %cmp119, label %if.then121, label %if.else125

if.then121:                                       ; preds = %land.lhs.true
  %75 = load ptr, ptr %n, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %75, i32 0, i32 22
  %76 = load ptr, ptr %hostname, align 8
  %77 = load ptr, ptr %aux_argv, align 8
  %arrayidx122 = getelementptr inbounds ptr, ptr %77, i64 1
  %78 = load ptr, ptr %arrayidx122, align 8
  %call123 = call ptr @sdscpy(ptr noundef %76, ptr noundef %78)
  %79 = load ptr, ptr %n, align 8
  %hostname124 = getelementptr inbounds %struct._clusterNode, ptr %79, i32 0, i32 22
  store ptr %call123, ptr %hostname124, align 8
  br label %if.end133

if.else125:                                       ; preds = %land.lhs.true, %if.end114
  %80 = load ptr, ptr %n, align 8
  %hostname126 = getelementptr inbounds %struct._clusterNode, ptr %80, i32 0, i32 22
  %81 = load ptr, ptr %hostname126, align 8
  %call127 = call i64 @sdslen(ptr noundef %81)
  %cmp128 = icmp ne i64 %call127, 0
  br i1 %cmp128, label %if.then130, label %if.end132

if.then130:                                       ; preds = %if.else125
  %82 = load ptr, ptr %n, align 8
  %hostname131 = getelementptr inbounds %struct._clusterNode, ptr %82, i32 0, i32 22
  %83 = load ptr, ptr %hostname131, align 8
  call void @sdsclear(ptr noundef %83)
  br label %if.end132

if.end132:                                        ; preds = %if.then130, %if.else125
  br label %if.end133

if.end133:                                        ; preds = %if.end132, %if.then121
  store i32 0, ptr %aux_tcp_port, align 4
  store i32 0, ptr %aux_tls_port, align 4
  store i32 2, ptr %i, align 4
  br label %for.cond134

for.cond134:                                      ; preds = %for.inc220, %if.end133
  %84 = load i32, ptr %i, align 4
  %85 = load i32, ptr %aux_argc, align 4
  %cmp135 = icmp slt i32 %84, %85
  br i1 %cmp135, label %for.body137, label %for.end222

for.body137:                                      ; preds = %for.cond134
  %86 = load ptr, ptr %aux_argv, align 8
  %87 = load i32, ptr %i, align 4
  %idxprom138 = sext i32 %87 to i64
  %arrayidx139 = getelementptr inbounds ptr, ptr %86, i64 %idxprom138
  %88 = load ptr, ptr %arrayidx139, align 8
  %89 = load ptr, ptr %aux_argv, align 8
  %90 = load i32, ptr %i, align 4
  %idxprom140 = sext i32 %90 to i64
  %arrayidx141 = getelementptr inbounds ptr, ptr %89, i64 %idxprom140
  %91 = load ptr, ptr %arrayidx141, align 8
  %call142 = call i64 @sdslen(ptr noundef %91)
  %call143 = call ptr @sdssplitlen(ptr noundef %88, i64 noundef %call142, ptr noundef @.str.15, i32 noundef 1, ptr noundef %field_argc)
  store ptr %call143, ptr %field_argv, align 8
  %92 = load ptr, ptr %field_argv, align 8
  %cmp144 = icmp eq ptr %92, null
  br i1 %cmp144, label %if.then149, label %lor.lhs.false146

lor.lhs.false146:                                 ; preds = %for.body137
  %93 = load i32, ptr %field_argc, align 4
  %cmp147 = icmp ne i32 %93, 2
  br i1 %cmp147, label %if.then149, label %if.end154

if.then149:                                       ; preds = %lor.lhs.false146, %for.body137
  %94 = load ptr, ptr %field_argv, align 8
  %cmp150 = icmp ne ptr %94, null
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %if.then149
  %95 = load ptr, ptr %field_argv, align 8
  %96 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef %95, i32 noundef %96)
  br label %if.end153

if.end153:                                        ; preds = %if.then152, %if.then149
  %97 = load ptr, ptr %aux_argv, align 8
  %98 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef %97, i32 noundef %98)
  %99 = load ptr, ptr %argv, align 8
  %100 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %99, i32 noundef %100)
  br label %fmterr

if.end154:                                        ; preds = %lor.lhs.false146
  store i32 0, ptr %j155, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc170, %if.end154
  %101 = load i32, ptr %j155, align 4
  %cmp157 = icmp ult i32 %101, 2
  br i1 %cmp157, label %for.body159, label %for.end171

for.body159:                                      ; preds = %for.cond156
  %102 = load ptr, ptr %field_argv, align 8
  %103 = load i32, ptr %j155, align 4
  %idxprom160 = zext i32 %103 to i64
  %arrayidx161 = getelementptr inbounds ptr, ptr %102, i64 %idxprom160
  %104 = load ptr, ptr %arrayidx161, align 8
  %105 = load ptr, ptr %field_argv, align 8
  %106 = load i32, ptr %j155, align 4
  %idxprom162 = zext i32 %106 to i64
  %arrayidx163 = getelementptr inbounds ptr, ptr %105, i64 %idxprom162
  %107 = load ptr, ptr %arrayidx163, align 8
  %call164 = call i64 @sdslen(ptr noundef %107)
  %conv165 = trunc i64 %call164 to i32
  %call166 = call i32 @isValidAuxString(ptr noundef %104, i32 noundef %conv165)
  %tobool167 = icmp ne i32 %call166, 0
  br i1 %tobool167, label %if.end169, label %if.then168

if.then168:                                       ; preds = %for.body159
  %108 = load ptr, ptr %field_argv, align 8
  %109 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef %108, i32 noundef %109)
  %110 = load ptr, ptr %aux_argv, align 8
  %111 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef %110, i32 noundef %111)
  %112 = load ptr, ptr %argv, align 8
  %113 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %112, i32 noundef %113)
  br label %fmterr

if.end169:                                        ; preds = %for.body159
  br label %for.inc170

for.inc170:                                       ; preds = %if.end169
  %114 = load i32, ptr %j155, align 4
  %inc = add i32 %114, 1
  store i32 %inc, ptr %j155, align 4
  br label %for.cond156, !llvm.loop !9

for.end171:                                       ; preds = %for.cond156
  store i32 0, ptr %field_found, align 4
  store i32 0, ptr %j172, align 4
  br label %for.cond173

for.cond173:                                      ; preds = %for.inc213, %for.end171
  %115 = load i32, ptr %j172, align 4
  %conv174 = zext i32 %115 to i64
  %cmp175 = icmp ult i64 %conv174, 4
  br i1 %cmp175, label %for.body177, label %for.end215

for.body177:                                      ; preds = %for.cond173
  %116 = load ptr, ptr %field_argv, align 8
  %arrayidx178 = getelementptr inbounds ptr, ptr %116, i64 0
  %117 = load ptr, ptr %arrayidx178, align 8
  %call179 = call i64 @sdslen(ptr noundef %117)
  %118 = load i32, ptr %j172, align 4
  %idxprom180 = zext i32 %118 to i64
  %arrayidx181 = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %idxprom180
  %field = getelementptr inbounds %struct.auxFieldHandler, ptr %arrayidx181, i32 0, i32 0
  %119 = load ptr, ptr %field, align 16
  %call182 = call i64 @strlen(ptr noundef %119) #12
  %cmp183 = icmp ne i64 %call179, %call182
  br i1 %cmp183, label %if.then195, label %lor.lhs.false185

lor.lhs.false185:                                 ; preds = %for.body177
  %120 = load ptr, ptr %field_argv, align 8
  %arrayidx186 = getelementptr inbounds ptr, ptr %120, i64 0
  %121 = load ptr, ptr %arrayidx186, align 8
  %122 = load i32, ptr %j172, align 4
  %idxprom187 = zext i32 %122 to i64
  %arrayidx188 = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %idxprom187
  %field189 = getelementptr inbounds %struct.auxFieldHandler, ptr %arrayidx188, i32 0, i32 0
  %123 = load ptr, ptr %field189, align 16
  %124 = load ptr, ptr %field_argv, align 8
  %arrayidx190 = getelementptr inbounds ptr, ptr %124, i64 0
  %125 = load ptr, ptr %arrayidx190, align 8
  %call191 = call i64 @sdslen(ptr noundef %125)
  %call192 = call i32 @memcmp(ptr noundef %121, ptr noundef %123, i64 noundef %call191) #12
  %cmp193 = icmp ne i32 %call192, 0
  br i1 %cmp193, label %if.then195, label %if.end196

if.then195:                                       ; preds = %lor.lhs.false185, %for.body177
  br label %for.inc213

if.end196:                                        ; preds = %lor.lhs.false185
  store i32 1, ptr %field_found, align 4
  %126 = load i32, ptr %j172, align 4
  %cmp197 = icmp eq i32 %126, 2
  %conv198 = zext i1 %cmp197 to i32
  %127 = load i32, ptr %aux_tcp_port, align 4
  %or = or i32 %127, %conv198
  store i32 %or, ptr %aux_tcp_port, align 4
  %128 = load i32, ptr %j172, align 4
  %cmp199 = icmp eq i32 %128, 3
  %conv200 = zext i1 %cmp199 to i32
  %129 = load i32, ptr %aux_tls_port, align 4
  %or201 = or i32 %129, %conv200
  store i32 %or201, ptr %aux_tls_port, align 4
  %130 = load i32, ptr %j172, align 4
  %idxprom202 = zext i32 %130 to i64
  %arrayidx203 = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %idxprom202
  %setter = getelementptr inbounds %struct.auxFieldHandler, ptr %arrayidx203, i32 0, i32 1
  %131 = load ptr, ptr %setter, align 8
  %132 = load ptr, ptr %n, align 8
  %133 = load ptr, ptr %field_argv, align 8
  %arrayidx204 = getelementptr inbounds ptr, ptr %133, i64 1
  %134 = load ptr, ptr %arrayidx204, align 8
  %135 = load ptr, ptr %field_argv, align 8
  %arrayidx205 = getelementptr inbounds ptr, ptr %135, i64 1
  %136 = load ptr, ptr %arrayidx205, align 8
  %call206 = call i64 @sdslen(ptr noundef %136)
  %conv207 = trunc i64 %call206 to i32
  %call208 = call i32 %131(ptr noundef %132, ptr noundef %134, i32 noundef %conv207)
  %cmp209 = icmp ne i32 %call208, 0
  br i1 %cmp209, label %if.then211, label %if.end212

if.then211:                                       ; preds = %if.end196
  %137 = load ptr, ptr %field_argv, align 8
  %138 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef %137, i32 noundef %138)
  %139 = load ptr, ptr %aux_argv, align 8
  %140 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef %139, i32 noundef %140)
  %141 = load ptr, ptr %argv, align 8
  %142 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %141, i32 noundef %142)
  br label %fmterr

if.end212:                                        ; preds = %if.end196
  br label %for.inc213

for.inc213:                                       ; preds = %if.end212, %if.then195
  %143 = load i32, ptr %j172, align 4
  %inc214 = add i32 %143, 1
  store i32 %inc214, ptr %j172, align 4
  br label %for.cond173, !llvm.loop !10

for.end215:                                       ; preds = %for.cond173
  %144 = load i32, ptr %field_found, align 4
  %cmp216 = icmp eq i32 %144, 0
  br i1 %cmp216, label %if.then218, label %if.end219

if.then218:                                       ; preds = %for.end215
  %145 = load ptr, ptr %field_argv, align 8
  %146 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef %145, i32 noundef %146)
  %147 = load ptr, ptr %aux_argv, align 8
  %148 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef %147, i32 noundef %148)
  %149 = load ptr, ptr %argv, align 8
  %150 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %149, i32 noundef %150)
  br label %fmterr

if.end219:                                        ; preds = %for.end215
  %151 = load ptr, ptr %field_argv, align 8
  %152 = load i32, ptr %field_argc, align 4
  call void @sdsfreesplitres(ptr noundef %151, i32 noundef %152)
  br label %for.inc220

for.inc220:                                       ; preds = %if.end219
  %153 = load i32, ptr %i, align 4
  %inc221 = add nsw i32 %153, 1
  store i32 %inc221, ptr %i, align 4
  br label %for.cond134, !llvm.loop !11

for.end222:                                       ; preds = %for.cond134
  %154 = load ptr, ptr %aux_argv, align 8
  %arrayidx223 = getelementptr inbounds ptr, ptr %154, i64 0
  %155 = load ptr, ptr %arrayidx223, align 8
  %call224 = call ptr @strrchr(ptr noundef %155, i32 noundef 58) #12
  store ptr %call224, ptr %p, align 8
  %cmp225 = icmp eq ptr %call224, null
  br i1 %cmp225, label %if.then227, label %if.end228

if.then227:                                       ; preds = %for.end222
  %156 = load ptr, ptr %aux_argv, align 8
  %157 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef %156, i32 noundef %157)
  %158 = load ptr, ptr %argv, align 8
  %159 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %158, i32 noundef %159)
  br label %fmterr

if.end228:                                        ; preds = %for.end222
  %160 = load ptr, ptr %p, align 8
  store i8 0, ptr %160, align 1
  %161 = load ptr, ptr %n, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %161, i32 0, i32 21
  %arraydecay = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %162 = load ptr, ptr %aux_argv, align 8
  %arrayidx229 = getelementptr inbounds ptr, ptr %162, i64 0
  %163 = load ptr, ptr %arrayidx229, align 8
  %164 = load ptr, ptr %aux_argv, align 8
  %arrayidx230 = getelementptr inbounds ptr, ptr %164, i64 0
  %165 = load ptr, ptr %arrayidx230, align 8
  %call231 = call i64 @strlen(ptr noundef %165) #12
  %add232 = add i64 %call231, 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %163, i64 %add232, i1 false)
  %166 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %166, i64 1
  store ptr %add.ptr, ptr %port, align 8
  %167 = load ptr, ptr %port, align 8
  %call233 = call ptr @strchr(ptr noundef %167, i32 noundef 64) #12
  store ptr %call233, ptr %busp, align 8
  %168 = load ptr, ptr %busp, align 8
  %tobool234 = icmp ne ptr %168, null
  br i1 %tobool234, label %if.then235, label %if.end236

if.then235:                                       ; preds = %if.end228
  %169 = load ptr, ptr %busp, align 8
  store i8 0, ptr %169, align 1
  %170 = load ptr, ptr %busp, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %170, i32 1
  store ptr %incdec.ptr, ptr %busp, align 8
  br label %if.end236

if.end236:                                        ; preds = %if.then235, %if.end228
  %171 = load i32, ptr %aux_tcp_port, align 4
  %tobool237 = icmp ne i32 %171, 0
  br i1 %tobool237, label %if.else247, label %land.lhs.true238

land.lhs.true238:                                 ; preds = %if.end236
  %172 = load i32, ptr %aux_tls_port, align 4
  %tobool239 = icmp ne i32 %172, 0
  br i1 %tobool239, label %if.else247, label %if.then240

if.then240:                                       ; preds = %land.lhs.true238
  %173 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool241 = icmp ne i32 %173, 0
  br i1 %tobool241, label %if.then242, label %if.else244

if.then242:                                       ; preds = %if.then240
  %174 = load ptr, ptr %port, align 8
  %call243 = call i32 @atoi(ptr noundef %174) #12
  %175 = load ptr, ptr %n, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %175, i32 0, i32 25
  store i32 %call243, ptr %tls_port, align 4
  br label %if.end246

if.else244:                                       ; preds = %if.then240
  %176 = load ptr, ptr %port, align 8
  %call245 = call i32 @atoi(ptr noundef %176) #12
  %177 = load ptr, ptr %n, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %177, i32 0, i32 24
  store i32 %call245, ptr %tcp_port, align 8
  br label %if.end246

if.end246:                                        ; preds = %if.else244, %if.then242
  br label %if.end259

if.else247:                                       ; preds = %land.lhs.true238, %if.end236
  %178 = load i32, ptr %aux_tcp_port, align 4
  %tobool248 = icmp ne i32 %178, 0
  br i1 %tobool248, label %if.else252, label %if.then249

if.then249:                                       ; preds = %if.else247
  %179 = load ptr, ptr %port, align 8
  %call250 = call i32 @atoi(ptr noundef %179) #12
  %180 = load ptr, ptr %n, align 8
  %tcp_port251 = getelementptr inbounds %struct._clusterNode, ptr %180, i32 0, i32 24
  store i32 %call250, ptr %tcp_port251, align 8
  br label %if.end258

if.else252:                                       ; preds = %if.else247
  %181 = load i32, ptr %aux_tls_port, align 4
  %tobool253 = icmp ne i32 %181, 0
  br i1 %tobool253, label %if.end257, label %if.then254

if.then254:                                       ; preds = %if.else252
  %182 = load ptr, ptr %port, align 8
  %call255 = call i32 @atoi(ptr noundef %182) #12
  %183 = load ptr, ptr %n, align 8
  %tls_port256 = getelementptr inbounds %struct._clusterNode, ptr %183, i32 0, i32 25
  store i32 %call255, ptr %tls_port256, align 4
  br label %if.end257

if.end257:                                        ; preds = %if.then254, %if.else252
  br label %if.end258

if.end258:                                        ; preds = %if.end257, %if.then249
  br label %if.end259

if.end259:                                        ; preds = %if.end258, %if.end246
  %184 = load ptr, ptr %busp, align 8
  %tobool260 = icmp ne ptr %184, null
  br i1 %tobool260, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end259
  %185 = load ptr, ptr %busp, align 8
  %call261 = call i32 @atoi(ptr noundef %185) #12
  br label %cond.end

cond.false:                                       ; preds = %if.end259
  %186 = load ptr, ptr %n, align 8
  %call262 = call i32 @getNodeDefaultClientPort(ptr noundef %186)
  %add263 = add nsw i32 %call262, 10000
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call261, %cond.true ], [ %add263, %cond.false ]
  %187 = load ptr, ptr %n, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %187, i32 0, i32 26
  store i32 %cond, ptr %cport, align 8
  %188 = load ptr, ptr %aux_argv, align 8
  %189 = load i32, ptr %aux_argc, align 4
  call void @sdsfreesplitres(ptr noundef %188, i32 noundef %189)
  %190 = load ptr, ptr %argv, align 8
  %arrayidx264 = getelementptr inbounds ptr, ptr %190, i64 2
  %191 = load ptr, ptr %arrayidx264, align 8
  store ptr %191, ptr %s, align 8
  store ptr %191, ptr %p, align 8
  br label %while.cond265

while.cond265:                                    ; preds = %if.end345, %cond.end
  %192 = load ptr, ptr %p, align 8
  %tobool266 = icmp ne ptr %192, null
  br i1 %tobool266, label %while.body267, label %while.end

while.body267:                                    ; preds = %while.cond265
  %193 = load ptr, ptr %s, align 8
  %call268 = call ptr @strchr(ptr noundef %193, i32 noundef 44) #12
  store ptr %call268, ptr %p, align 8
  %194 = load ptr, ptr %p, align 8
  %tobool269 = icmp ne ptr %194, null
  br i1 %tobool269, label %if.then270, label %if.end271

if.then270:                                       ; preds = %while.body267
  %195 = load ptr, ptr %p, align 8
  store i8 0, ptr %195, align 1
  br label %if.end271

if.end271:                                        ; preds = %if.then270, %while.body267
  %196 = load ptr, ptr %s, align 8
  %call272 = call i32 @strcasecmp(ptr noundef %196, ptr noundef @.str.16) #12
  %tobool273 = icmp ne i32 %call272, 0
  br i1 %tobool273, label %if.else285, label %if.then274

if.then274:                                       ; preds = %if.end271
  %197 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself = getelementptr inbounds %struct.clusterState, ptr %197, i32 0, i32 0
  %198 = load ptr, ptr %myself, align 8
  %cmp275 = icmp eq ptr %198, null
  %lnot = xor i1 %cmp275, true
  %lnot277 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot277 to i32
  %conv278 = sext i32 %lnot.ext to i64
  %tobool279 = icmp ne i64 %conv278, 0
  br i1 %tobool279, label %cond.true280, label %cond.false281

cond.true280:                                     ; preds = %if.then274
  br label %cond.end282

cond.false281:                                    ; preds = %if.then274
  call void @_serverAssert(ptr noundef @.str.17, ptr noundef @.str.18, i32 noundef 529)
  call void @abort() #13
  unreachable

199:                                              ; No predecessors!
  br label %cond.end282

cond.end282:                                      ; preds = %199, %cond.true280
  %200 = load ptr, ptr %n, align 8
  %201 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself283 = getelementptr inbounds %struct.clusterState, ptr %201, i32 0, i32 0
  store ptr %200, ptr %myself283, align 8
  store ptr %200, ptr @myself, align 8
  %202 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %202, i32 0, i32 3
  %203 = load i32, ptr %flags, align 8
  %or284 = or i32 %203, 16
  store i32 %or284, ptr %flags, align 8
  br label %if.end341

if.else285:                                       ; preds = %if.end271
  %204 = load ptr, ptr %s, align 8
  %call286 = call i32 @strcasecmp(ptr noundef %204, ptr noundef @.str.19) #12
  %tobool287 = icmp ne i32 %call286, 0
  br i1 %tobool287, label %if.else291, label %if.then288

if.then288:                                       ; preds = %if.else285
  %205 = load ptr, ptr %n, align 8
  %flags289 = getelementptr inbounds %struct._clusterNode, ptr %205, i32 0, i32 3
  %206 = load i32, ptr %flags289, align 8
  %or290 = or i32 %206, 1
  store i32 %or290, ptr %flags289, align 8
  br label %if.end340

if.else291:                                       ; preds = %if.else285
  %207 = load ptr, ptr %s, align 8
  %call292 = call i32 @strcasecmp(ptr noundef %207, ptr noundef @.str.20) #12
  %tobool293 = icmp ne i32 %call292, 0
  br i1 %tobool293, label %if.else297, label %if.then294

if.then294:                                       ; preds = %if.else291
  %208 = load ptr, ptr %n, align 8
  %flags295 = getelementptr inbounds %struct._clusterNode, ptr %208, i32 0, i32 3
  %209 = load i32, ptr %flags295, align 8
  %or296 = or i32 %209, 2
  store i32 %or296, ptr %flags295, align 8
  br label %if.end339

if.else297:                                       ; preds = %if.else291
  %210 = load ptr, ptr %s, align 8
  %call298 = call i32 @strcasecmp(ptr noundef %210, ptr noundef @.str.21) #12
  %tobool299 = icmp ne i32 %call298, 0
  br i1 %tobool299, label %if.else303, label %if.then300

if.then300:                                       ; preds = %if.else297
  %211 = load ptr, ptr %n, align 8
  %flags301 = getelementptr inbounds %struct._clusterNode, ptr %211, i32 0, i32 3
  %212 = load i32, ptr %flags301, align 8
  %or302 = or i32 %212, 4
  store i32 %or302, ptr %flags301, align 8
  br label %if.end338

if.else303:                                       ; preds = %if.else297
  %213 = load ptr, ptr %s, align 8
  %call304 = call i32 @strcasecmp(ptr noundef %213, ptr noundef @.str.22) #12
  %tobool305 = icmp ne i32 %call304, 0
  br i1 %tobool305, label %if.else310, label %if.then306

if.then306:                                       ; preds = %if.else303
  %214 = load ptr, ptr %n, align 8
  %flags307 = getelementptr inbounds %struct._clusterNode, ptr %214, i32 0, i32 3
  %215 = load i32, ptr %flags307, align 8
  %or308 = or i32 %215, 8
  store i32 %or308, ptr %flags307, align 8
  %call309 = call i64 @mstime()
  %216 = load ptr, ptr %n, align 8
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %216, i32 0, i32 16
  store i64 %call309, ptr %fail_time, align 8
  br label %if.end337

if.else310:                                       ; preds = %if.else303
  %217 = load ptr, ptr %s, align 8
  %call311 = call i32 @strcasecmp(ptr noundef %217, ptr noundef @.str.23) #12
  %tobool312 = icmp ne i32 %call311, 0
  br i1 %tobool312, label %if.else316, label %if.then313

if.then313:                                       ; preds = %if.else310
  %218 = load ptr, ptr %n, align 8
  %flags314 = getelementptr inbounds %struct._clusterNode, ptr %218, i32 0, i32 3
  %219 = load i32, ptr %flags314, align 8
  %or315 = or i32 %219, 32
  store i32 %or315, ptr %flags314, align 8
  br label %if.end336

if.else316:                                       ; preds = %if.else310
  %220 = load ptr, ptr %s, align 8
  %call317 = call i32 @strcasecmp(ptr noundef %220, ptr noundef @.str.24) #12
  %tobool318 = icmp ne i32 %call317, 0
  br i1 %tobool318, label %if.else322, label %if.then319

if.then319:                                       ; preds = %if.else316
  %221 = load ptr, ptr %n, align 8
  %flags320 = getelementptr inbounds %struct._clusterNode, ptr %221, i32 0, i32 3
  %222 = load i32, ptr %flags320, align 8
  %or321 = or i32 %222, 64
  store i32 %or321, ptr %flags320, align 8
  br label %if.end335

if.else322:                                       ; preds = %if.else316
  %223 = load ptr, ptr %s, align 8
  %call323 = call i32 @strcasecmp(ptr noundef %223, ptr noundef @.str.25) #12
  %tobool324 = icmp ne i32 %call323, 0
  br i1 %tobool324, label %if.else328, label %if.then325

if.then325:                                       ; preds = %if.else322
  %224 = load ptr, ptr %n, align 8
  %flags326 = getelementptr inbounds %struct._clusterNode, ptr %224, i32 0, i32 3
  %225 = load i32, ptr %flags326, align 8
  %or327 = or i32 %225, 512
  store i32 %or327, ptr %flags326, align 8
  br label %if.end334

if.else328:                                       ; preds = %if.else322
  %226 = load ptr, ptr %s, align 8
  %call329 = call i32 @strcasecmp(ptr noundef %226, ptr noundef @.str.26) #12
  %tobool330 = icmp ne i32 %call329, 0
  br i1 %tobool330, label %if.else332, label %if.then331

if.then331:                                       ; preds = %if.else328
  br label %if.end333

if.else332:                                       ; preds = %if.else328
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.18, i32 noundef 550, ptr noundef @.str.27)
  call void @abort() #13
  unreachable

if.end333:                                        ; preds = %if.then331
  br label %if.end334

if.end334:                                        ; preds = %if.end333, %if.then325
  br label %if.end335

if.end335:                                        ; preds = %if.end334, %if.then319
  br label %if.end336

if.end336:                                        ; preds = %if.end335, %if.then313
  br label %if.end337

if.end337:                                        ; preds = %if.end336, %if.then306
  br label %if.end338

if.end338:                                        ; preds = %if.end337, %if.then300
  br label %if.end339

if.end339:                                        ; preds = %if.end338, %if.then294
  br label %if.end340

if.end340:                                        ; preds = %if.end339, %if.then288
  br label %if.end341

if.end341:                                        ; preds = %if.end340, %cond.end282
  %227 = load ptr, ptr %p, align 8
  %tobool342 = icmp ne ptr %227, null
  br i1 %tobool342, label %if.then343, label %if.end345

if.then343:                                       ; preds = %if.end341
  %228 = load ptr, ptr %p, align 8
  %add.ptr344 = getelementptr inbounds i8, ptr %228, i64 1
  store ptr %add.ptr344, ptr %s, align 8
  br label %if.end345

if.end345:                                        ; preds = %if.then343, %if.end341
  br label %while.cond265, !llvm.loop !12

while.end:                                        ; preds = %while.cond265
  %229 = load ptr, ptr %argv, align 8
  %arrayidx346 = getelementptr inbounds ptr, ptr %229, i64 3
  %230 = load ptr, ptr %arrayidx346, align 8
  %arrayidx347 = getelementptr inbounds i8, ptr %230, i64 0
  %231 = load i8, ptr %arrayidx347, align 1
  %conv348 = sext i8 %231 to i32
  %cmp349 = icmp ne i32 %conv348, 45
  br i1 %cmp349, label %if.then351, label %if.else396

if.then351:                                       ; preds = %while.end
  %232 = load ptr, ptr %argv, align 8
  %arrayidx352 = getelementptr inbounds ptr, ptr %232, i64 3
  %233 = load ptr, ptr %arrayidx352, align 8
  %234 = load ptr, ptr %argv, align 8
  %arrayidx353 = getelementptr inbounds ptr, ptr %234, i64 3
  %235 = load ptr, ptr %arrayidx353, align 8
  %call354 = call i64 @sdslen(ptr noundef %235)
  %conv355 = trunc i64 %call354 to i32
  %call356 = call i32 @verifyClusterNodeId(ptr noundef %233, i32 noundef %conv355)
  %cmp357 = icmp eq i32 %call356, -1
  br i1 %cmp357, label %if.then359, label %if.end360

if.then359:                                       ; preds = %if.then351
  %236 = load ptr, ptr %argv, align 8
  %237 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %236, i32 noundef %237)
  br label %fmterr

if.end360:                                        ; preds = %if.then351
  %238 = load ptr, ptr %argv, align 8
  %arrayidx361 = getelementptr inbounds ptr, ptr %238, i64 3
  %239 = load ptr, ptr %arrayidx361, align 8
  %240 = load ptr, ptr %argv, align 8
  %arrayidx362 = getelementptr inbounds ptr, ptr %240, i64 3
  %241 = load ptr, ptr %arrayidx362, align 8
  %call363 = call i64 @sdslen(ptr noundef %241)
  %conv364 = trunc i64 %call363 to i32
  %call365 = call ptr @clusterLookupNode(ptr noundef %239, i32 noundef %conv364)
  store ptr %call365, ptr %master, align 8
  %242 = load ptr, ptr %master, align 8
  %tobool366 = icmp ne ptr %242, null
  br i1 %tobool366, label %if.end370, label %if.then367

if.then367:                                       ; preds = %if.end360
  %243 = load ptr, ptr %argv, align 8
  %arrayidx368 = getelementptr inbounds ptr, ptr %243, i64 3
  %244 = load ptr, ptr %arrayidx368, align 8
  %call369 = call ptr @createClusterNode(ptr noundef %244, i32 noundef 0)
  store ptr %call369, ptr %master, align 8
  %245 = load ptr, ptr %master, align 8
  call void @clusterAddNode(ptr noundef %245)
  br label %if.end370

if.end370:                                        ; preds = %if.then367, %if.end360
  %246 = load ptr, ptr getelementptr inbounds (%struct.auxFieldHandler, ptr @auxFieldHandlers, i32 0, i32 3), align 8
  %247 = load ptr, ptr %n, align 8
  %call371 = call i32 %246(ptr noundef %247)
  %cmp372 = icmp eq i32 %call371, 0
  br i1 %cmp372, label %if.then374, label %if.else380

if.then374:                                       ; preds = %if.end370
  %248 = load ptr, ptr %n, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %248, i32 0, i32 2
  %arraydecay375 = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  %249 = load ptr, ptr %master, align 8
  %shard_id376 = getelementptr inbounds %struct._clusterNode, ptr %249, i32 0, i32 2
  %arraydecay377 = getelementptr inbounds [40 x i8], ptr %shard_id376, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay375, ptr align 8 %arraydecay377, i64 40, i1 false)
  %250 = load ptr, ptr %master, align 8
  %shard_id378 = getelementptr inbounds %struct._clusterNode, ptr %250, i32 0, i32 2
  %arraydecay379 = getelementptr inbounds [40 x i8], ptr %shard_id378, i64 0, i64 0
  %251 = load ptr, ptr %n, align 8
  call void @clusterAddNodeToShard(ptr noundef %arraydecay379, ptr noundef %251)
  br label %if.end394

if.else380:                                       ; preds = %if.end370
  %252 = load ptr, ptr %master, align 8
  %call381 = call ptr @clusterGetNodesInMyShard(ptr noundef %252)
  %cmp382 = icmp ne ptr %call381, null
  br i1 %cmp382, label %land.lhs.true384, label %if.end393

land.lhs.true384:                                 ; preds = %if.else380
  %253 = load ptr, ptr %master, align 8
  %shard_id385 = getelementptr inbounds %struct._clusterNode, ptr %253, i32 0, i32 2
  %arraydecay386 = getelementptr inbounds [40 x i8], ptr %shard_id385, i64 0, i64 0
  %254 = load ptr, ptr %n, align 8
  %shard_id387 = getelementptr inbounds %struct._clusterNode, ptr %254, i32 0, i32 2
  %arraydecay388 = getelementptr inbounds [40 x i8], ptr %shard_id387, i64 0, i64 0
  %call389 = call i32 @memcmp(ptr noundef %arraydecay386, ptr noundef %arraydecay388, i64 noundef 40) #12
  %cmp390 = icmp ne i32 %call389, 0
  br i1 %cmp390, label %if.then392, label %if.end393

if.then392:                                       ; preds = %land.lhs.true384
  br label %fmterr

if.end393:                                        ; preds = %land.lhs.true384, %if.else380
  br label %if.end394

if.end394:                                        ; preds = %if.end393, %if.then374
  %255 = load ptr, ptr %master, align 8
  %256 = load ptr, ptr %n, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %256, i32 0, i32 11
  store ptr %255, ptr %slaveof, align 8
  %257 = load ptr, ptr %master, align 8
  %258 = load ptr, ptr %n, align 8
  %call395 = call i32 @clusterNodeAddSlave(ptr noundef %257, ptr noundef %258)
  br label %if.end404

if.else396:                                       ; preds = %while.end
  %259 = load ptr, ptr getelementptr inbounds (%struct.auxFieldHandler, ptr @auxFieldHandlers, i32 0, i32 3), align 8
  %260 = load ptr, ptr %n, align 8
  %call397 = call i32 %259(ptr noundef %260)
  %cmp398 = icmp eq i32 %call397, 0
  br i1 %cmp398, label %if.then400, label %if.end403

if.then400:                                       ; preds = %if.else396
  %261 = load ptr, ptr %n, align 8
  %shard_id401 = getelementptr inbounds %struct._clusterNode, ptr %261, i32 0, i32 2
  %arraydecay402 = getelementptr inbounds [40 x i8], ptr %shard_id401, i64 0, i64 0
  %262 = load ptr, ptr %n, align 8
  call void @clusterAddNodeToShard(ptr noundef %arraydecay402, ptr noundef %262)
  br label %if.end403

if.end403:                                        ; preds = %if.then400, %if.else396
  br label %if.end404

if.end404:                                        ; preds = %if.end403, %if.end394
  %263 = load ptr, ptr %argv, align 8
  %arrayidx405 = getelementptr inbounds ptr, ptr %263, i64 4
  %264 = load ptr, ptr %arrayidx405, align 8
  %call406 = call i32 @atoi(ptr noundef %264) #12
  %tobool407 = icmp ne i32 %call406, 0
  br i1 %tobool407, label %if.then408, label %if.end410

if.then408:                                       ; preds = %if.end404
  %call409 = call i64 @mstime()
  %265 = load ptr, ptr %n, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %265, i32 0, i32 13
  store i64 %call409, ptr %ping_sent, align 8
  br label %if.end410

if.end410:                                        ; preds = %if.then408, %if.end404
  %266 = load ptr, ptr %argv, align 8
  %arrayidx411 = getelementptr inbounds ptr, ptr %266, i64 5
  %267 = load ptr, ptr %arrayidx411, align 8
  %call412 = call i32 @atoi(ptr noundef %267) #12
  %tobool413 = icmp ne i32 %call412, 0
  br i1 %tobool413, label %if.then414, label %if.end416

if.then414:                                       ; preds = %if.end410
  %call415 = call i64 @mstime()
  %268 = load ptr, ptr %n, align 8
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %268, i32 0, i32 14
  store i64 %call415, ptr %pong_received, align 8
  br label %if.end416

if.end416:                                        ; preds = %if.then414, %if.end410
  %269 = load ptr, ptr %n, align 8
  %flags417 = getelementptr inbounds %struct._clusterNode, ptr %269, i32 0, i32 3
  %270 = load i32, ptr %flags417, align 8
  %and = and i32 %270, 2
  %tobool418 = icmp ne i32 %and, 0
  br i1 %tobool418, label %land.lhs.true419, label %cond.false423

land.lhs.true419:                                 ; preds = %if.end416
  %271 = load ptr, ptr %n, align 8
  %slaveof420 = getelementptr inbounds %struct._clusterNode, ptr %271, i32 0, i32 11
  %272 = load ptr, ptr %slaveof420, align 8
  %tobool421 = icmp ne ptr %272, null
  br i1 %tobool421, label %cond.true422, label %cond.false423

cond.true422:                                     ; preds = %land.lhs.true419
  br label %cond.end426

cond.false423:                                    ; preds = %land.lhs.true419, %if.end416
  %273 = load ptr, ptr %argv, align 8
  %arrayidx424 = getelementptr inbounds ptr, ptr %273, i64 6
  %274 = load ptr, ptr %arrayidx424, align 8
  %call425 = call i64 @strtoull(ptr noundef %274, ptr noundef null, i32 noundef 10) #15
  br label %cond.end426

cond.end426:                                      ; preds = %cond.false423, %cond.true422
  %cond427 = phi i64 [ 0, %cond.true422 ], [ %call425, %cond.false423 ]
  %275 = load ptr, ptr %n, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %275, i32 0, i32 4
  store i64 %cond427, ptr %configEpoch, align 8
  store i32 8, ptr %j, align 4
  br label %for.cond428

for.cond428:                                      ; preds = %for.inc529, %cond.end426
  %276 = load i32, ptr %j, align 4
  %277 = load i32, ptr %argc, align 4
  %cmp429 = icmp slt i32 %276, %277
  br i1 %cmp429, label %for.body431, label %for.end531

for.body431:                                      ; preds = %for.cond428
  %278 = load ptr, ptr %argv, align 8
  %279 = load i32, ptr %j, align 4
  %idxprom432 = sext i32 %279 to i64
  %arrayidx433 = getelementptr inbounds ptr, ptr %278, i64 %idxprom432
  %280 = load ptr, ptr %arrayidx433, align 8
  %arrayidx434 = getelementptr inbounds i8, ptr %280, i64 0
  %281 = load i8, ptr %arrayidx434, align 1
  %conv435 = sext i8 %281 to i32
  %cmp436 = icmp eq i32 %conv435, 91
  br i1 %cmp436, label %if.then438, label %if.else491

if.then438:                                       ; preds = %for.body431
  %282 = load ptr, ptr %argv, align 8
  %283 = load i32, ptr %j, align 4
  %idxprom439 = sext i32 %283 to i64
  %arrayidx440 = getelementptr inbounds ptr, ptr %282, i64 %idxprom439
  %284 = load ptr, ptr %arrayidx440, align 8
  %call441 = call ptr @strchr(ptr noundef %284, i32 noundef 45) #12
  store ptr %call441, ptr %p, align 8
  %285 = load ptr, ptr %p, align 8
  %cmp442 = icmp ne ptr %285, null
  %lnot444 = xor i1 %cmp442, true
  %lnot446 = xor i1 %lnot444, true
  %lnot.ext447 = zext i1 %lnot446 to i32
  %conv448 = sext i32 %lnot.ext447 to i64
  %tobool449 = icmp ne i64 %conv448, 0
  br i1 %tobool449, label %cond.true450, label %cond.false451

cond.true450:                                     ; preds = %if.then438
  br label %cond.end452

cond.false451:                                    ; preds = %if.then438
  call void @_serverAssert(ptr noundef @.str.28, ptr noundef @.str.18, i32 noundef 610)
  call void @abort() #13
  unreachable

286:                                              ; No predecessors!
  br label %cond.end452

cond.end452:                                      ; preds = %286, %cond.true450
  %287 = load ptr, ptr %p, align 8
  store i8 0, ptr %287, align 1
  %288 = load ptr, ptr %p, align 8
  %arrayidx453 = getelementptr inbounds i8, ptr %288, i64 1
  %289 = load i8, ptr %arrayidx453, align 1
  store i8 %289, ptr %direction, align 1
  %290 = load ptr, ptr %argv, align 8
  %291 = load i32, ptr %j, align 4
  %idxprom454 = sext i32 %291 to i64
  %arrayidx455 = getelementptr inbounds ptr, ptr %290, i64 %idxprom454
  %292 = load ptr, ptr %arrayidx455, align 8
  %add.ptr456 = getelementptr inbounds i8, ptr %292, i64 1
  %call457 = call i32 @atoi(ptr noundef %add.ptr456) #12
  store i32 %call457, ptr %slot, align 4
  %293 = load i32, ptr %slot, align 4
  %cmp458 = icmp slt i32 %293, 0
  br i1 %cmp458, label %if.then463, label %lor.lhs.false460

lor.lhs.false460:                                 ; preds = %cond.end452
  %294 = load i32, ptr %slot, align 4
  %cmp461 = icmp sge i32 %294, 16384
  br i1 %cmp461, label %if.then463, label %if.end464

if.then463:                                       ; preds = %lor.lhs.false460, %cond.end452
  %295 = load ptr, ptr %argv, align 8
  %296 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %295, i32 noundef %296)
  br label %fmterr

if.end464:                                        ; preds = %lor.lhs.false460
  %297 = load ptr, ptr %p, align 8
  %add.ptr465 = getelementptr inbounds i8, ptr %297, i64 3
  store ptr %add.ptr465, ptr %p, align 8
  %298 = load ptr, ptr %p, align 8
  %call466 = call ptr @strchr(ptr noundef %298, i32 noundef 93) #12
  store ptr %call466, ptr %pr, align 8
  %299 = load ptr, ptr %pr, align 8
  %300 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %299 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %300 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %node_len, align 8
  %301 = load ptr, ptr %pr, align 8
  %cmp467 = icmp eq ptr %301, null
  br i1 %cmp467, label %if.then474, label %lor.lhs.false469

lor.lhs.false469:                                 ; preds = %if.end464
  %302 = load ptr, ptr %p, align 8
  %303 = load i64, ptr %node_len, align 8
  %conv470 = trunc i64 %303 to i32
  %call471 = call i32 @verifyClusterNodeId(ptr noundef %302, i32 noundef %conv470)
  %cmp472 = icmp eq i32 %call471, -1
  br i1 %cmp472, label %if.then474, label %if.end475

if.then474:                                       ; preds = %lor.lhs.false469, %if.end464
  %304 = load ptr, ptr %argv, align 8
  %305 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %304, i32 noundef %305)
  br label %fmterr

if.end475:                                        ; preds = %lor.lhs.false469
  %306 = load ptr, ptr %p, align 8
  %call476 = call ptr @clusterLookupNode(ptr noundef %306, i32 noundef 40)
  store ptr %call476, ptr %cn, align 8
  %307 = load ptr, ptr %cn, align 8
  %tobool477 = icmp ne ptr %307, null
  br i1 %tobool477, label %if.end480, label %if.then478

if.then478:                                       ; preds = %if.end475
  %308 = load ptr, ptr %p, align 8
  %call479 = call ptr @createClusterNode(ptr noundef %308, i32 noundef 0)
  store ptr %call479, ptr %cn, align 8
  %309 = load ptr, ptr %cn, align 8
  call void @clusterAddNode(ptr noundef %309)
  br label %if.end480

if.end480:                                        ; preds = %if.then478, %if.end475
  %310 = load i8, ptr %direction, align 1
  %conv481 = sext i8 %310 to i32
  %cmp482 = icmp eq i32 %conv481, 62
  br i1 %cmp482, label %if.then484, label %if.else487

if.then484:                                       ; preds = %if.end480
  %311 = load ptr, ptr %cn, align 8
  %312 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to = getelementptr inbounds %struct.clusterState, ptr %312, i32 0, i32 7
  %313 = load i32, ptr %slot, align 4
  %idxprom485 = sext i32 %313 to i64
  %arrayidx486 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to, i64 0, i64 %idxprom485
  store ptr %311, ptr %arrayidx486, align 8
  br label %if.end490

if.else487:                                       ; preds = %if.end480
  %314 = load ptr, ptr %cn, align 8
  %315 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %315, i32 0, i32 8
  %316 = load i32, ptr %slot, align 4
  %idxprom488 = sext i32 %316 to i64
  %arrayidx489 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 %idxprom488
  store ptr %314, ptr %arrayidx489, align 8
  br label %if.end490

if.end490:                                        ; preds = %if.else487, %if.then484
  br label %for.inc529

if.else491:                                       ; preds = %for.body431
  %317 = load ptr, ptr %argv, align 8
  %318 = load i32, ptr %j, align 4
  %idxprom492 = sext i32 %318 to i64
  %arrayidx493 = getelementptr inbounds ptr, ptr %317, i64 %idxprom492
  %319 = load ptr, ptr %arrayidx493, align 8
  %call494 = call ptr @strchr(ptr noundef %319, i32 noundef 45) #12
  store ptr %call494, ptr %p, align 8
  %cmp495 = icmp ne ptr %call494, null
  br i1 %cmp495, label %if.then497, label %if.else503

if.then497:                                       ; preds = %if.else491
  %320 = load ptr, ptr %p, align 8
  store i8 0, ptr %320, align 1
  %321 = load ptr, ptr %argv, align 8
  %322 = load i32, ptr %j, align 4
  %idxprom498 = sext i32 %322 to i64
  %arrayidx499 = getelementptr inbounds ptr, ptr %321, i64 %idxprom498
  %323 = load ptr, ptr %arrayidx499, align 8
  %call500 = call i32 @atoi(ptr noundef %323) #12
  store i32 %call500, ptr %start, align 4
  %324 = load ptr, ptr %p, align 8
  %add.ptr501 = getelementptr inbounds i8, ptr %324, i64 1
  %call502 = call i32 @atoi(ptr noundef %add.ptr501) #12
  store i32 %call502, ptr %stop, align 4
  br label %if.end507

if.else503:                                       ; preds = %if.else491
  %325 = load ptr, ptr %argv, align 8
  %326 = load i32, ptr %j, align 4
  %idxprom504 = sext i32 %326 to i64
  %arrayidx505 = getelementptr inbounds ptr, ptr %325, i64 %idxprom504
  %327 = load ptr, ptr %arrayidx505, align 8
  %call506 = call i32 @atoi(ptr noundef %327) #12
  store i32 %call506, ptr %stop, align 4
  store i32 %call506, ptr %start, align 4
  br label %if.end507

if.end507:                                        ; preds = %if.else503, %if.then497
  br label %if.end508

if.end508:                                        ; preds = %if.end507
  %328 = load i32, ptr %start, align 4
  %cmp509 = icmp slt i32 %328, 0
  br i1 %cmp509, label %if.then520, label %lor.lhs.false511

lor.lhs.false511:                                 ; preds = %if.end508
  %329 = load i32, ptr %start, align 4
  %cmp512 = icmp sge i32 %329, 16384
  br i1 %cmp512, label %if.then520, label %lor.lhs.false514

lor.lhs.false514:                                 ; preds = %lor.lhs.false511
  %330 = load i32, ptr %stop, align 4
  %cmp515 = icmp slt i32 %330, 0
  br i1 %cmp515, label %if.then520, label %lor.lhs.false517

lor.lhs.false517:                                 ; preds = %lor.lhs.false514
  %331 = load i32, ptr %stop, align 4
  %cmp518 = icmp sge i32 %331, 16384
  br i1 %cmp518, label %if.then520, label %if.end521

if.then520:                                       ; preds = %lor.lhs.false517, %lor.lhs.false514, %lor.lhs.false511, %if.end508
  %332 = load ptr, ptr %argv, align 8
  %333 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %332, i32 noundef %333)
  br label %fmterr

if.end521:                                        ; preds = %lor.lhs.false517
  br label %while.cond522

while.cond522:                                    ; preds = %while.body525, %if.end521
  %334 = load i32, ptr %start, align 4
  %335 = load i32, ptr %stop, align 4
  %cmp523 = icmp sle i32 %334, %335
  br i1 %cmp523, label %while.body525, label %while.end528

while.body525:                                    ; preds = %while.cond522
  %336 = load ptr, ptr %n, align 8
  %337 = load i32, ptr %start, align 4
  %inc526 = add nsw i32 %337, 1
  store i32 %inc526, ptr %start, align 4
  %call527 = call i32 @clusterAddSlot(ptr noundef %336, i32 noundef %337)
  br label %while.cond522, !llvm.loop !13

while.end528:                                     ; preds = %while.cond522
  br label %for.inc529

for.inc529:                                       ; preds = %while.end528, %if.end490
  %338 = load i32, ptr %j, align 4
  %inc530 = add nsw i32 %338, 1
  store i32 %inc530, ptr %j, align 4
  br label %for.cond428, !llvm.loop !14

for.end531:                                       ; preds = %for.cond428
  %339 = load ptr, ptr %argv, align 8
  %340 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %339, i32 noundef %340)
  br label %while.cond, !llvm.loop !7

while.end532:                                     ; preds = %while.cond
  %341 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself533 = getelementptr inbounds %struct.clusterState, ptr %341, i32 0, i32 0
  %342 = load ptr, ptr %myself533, align 8
  %cmp534 = icmp eq ptr %342, null
  br i1 %cmp534, label %if.then536, label %if.end537

if.then536:                                       ; preds = %while.end532
  br label %fmterr

if.end537:                                        ; preds = %while.end532
  %343 = load ptr, ptr %line, align 8
  call void @zfree(ptr noundef %343)
  %344 = load ptr, ptr %fp, align 8
  %call538 = call i32 @fclose(ptr noundef %344)
  br label %do.body539

do.body539:                                       ; preds = %if.end537
  %345 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp540 = icmp slt i32 2, %345
  br i1 %cmp540, label %if.then542, label %if.end543

if.then542:                                       ; preds = %do.body539
  br label %do.end545

if.end543:                                        ; preds = %do.body539
  %346 = load ptr, ptr @myself, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %346, i32 0, i32 1
  %arraydecay544 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.29, ptr noundef %arraydecay544)
  br label %do.end545

do.end545:                                        ; preds = %if.end543, %if.then542
  %call546 = call i64 @clusterGetMaxEpoch()
  %347 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch547 = getelementptr inbounds %struct.clusterState, ptr %347, i32 0, i32 1
  %348 = load i64, ptr %currentEpoch547, align 8
  %cmp548 = icmp ugt i64 %call546, %348
  br i1 %cmp548, label %if.then550, label %if.end553

if.then550:                                       ; preds = %do.end545
  %call551 = call i64 @clusterGetMaxEpoch()
  %349 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch552 = getelementptr inbounds %struct.clusterState, ptr %349, i32 0, i32 1
  store i64 %call551, ptr %currentEpoch552, align 8
  br label %if.end553

if.end553:                                        ; preds = %if.then550, %do.end545
  store i32 0, ptr %retval, align 4
  br label %return

fmterr:                                           ; preds = %if.then536, %if.then520, %if.then474, %if.then463, %if.then392, %if.then359, %if.then227, %if.then218, %if.then211, %if.then168, %if.end153, %if.then113, %if.then95, %if.then86, %if.then48, %if.then41
  br label %do.body554

do.body554:                                       ; preds = %fmterr
  %350 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp555 = icmp slt i32 3, %350
  br i1 %cmp555, label %if.then557, label %if.end558

if.then557:                                       ; preds = %do.body554
  br label %do.end559

if.end558:                                        ; preds = %do.body554
  %351 = load ptr, ptr %line, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.30, ptr noundef %351)
  br label %do.end559

do.end559:                                        ; preds = %if.end558, %if.then557
  %352 = load ptr, ptr %line, align 8
  call void @zfree(ptr noundef %352)
  %353 = load ptr, ptr %fp, align 8
  %tobool560 = icmp ne ptr %353, null
  br i1 %tobool560, label %if.then561, label %if.end563

if.then561:                                       ; preds = %do.end559
  %354 = load ptr, ptr %fp, align 8
  %call562 = call i32 @fclose(ptr noundef %354)
  br label %if.end563

if.end563:                                        ; preds = %if.then561, %do.end559
  call void @exit(i32 noundef 1) #13
  unreachable

return:                                           ; preds = %if.end553, %if.then22, %if.then3
  %355 = load i32, ptr %retval, align 4
  ret i32 %355
}

declare noalias ptr @fopen64(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #5

declare void @_serverLog(i32 noundef, ptr noundef, ...) #1

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) #6

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) #7

; Function Attrs: nounwind
declare i32 @fstat64(i32 noundef, ptr noundef) #6

; Function Attrs: nounwind
declare i32 @fileno(ptr noundef) #6

declare i32 @fclose(ptr noundef) #1

; Function Attrs: allocsize(0)
declare noalias ptr @zmalloc(i64 noundef) #8

declare ptr @fgets(ptr noundef, i32 noundef, ptr noundef) #1

declare ptr @sdssplitargs(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcasecmp(ptr noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i64 @strtoull(ptr noundef, ptr noundef, i32 noundef) #6

declare void @sdsfreesplitres(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterLookupNode(ptr noundef %name, i32 noundef %length) #0 {
entry:
  %retval = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %length.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  %de = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %length, ptr %length.addr, align 4
  %0 = load ptr, ptr %name.addr, align 8
  %1 = load i32, ptr %length.addr, align 4
  %call = call i32 @verifyClusterNodeId(ptr noundef %0, i32 noundef %1)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %name.addr, align 8
  %3 = load i32, ptr %length.addr, align 4
  %conv = sext i32 %3 to i64
  %call1 = call ptr @sdsnewlen(ptr noundef %2, i64 noundef %conv)
  store ptr %call1, ptr %s, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %nodes, align 8
  %6 = load ptr, ptr %s, align 8
  %call2 = call ptr @dictFind(ptr noundef %5, ptr noundef %6)
  store ptr %call2, ptr %de, align 8
  %7 = load ptr, ptr %s, align 8
  call void @sdsfree(ptr noundef %7)
  %8 = load ptr, ptr %de, align 8
  %cmp3 = icmp eq ptr %8, null
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load ptr, ptr %de, align 8
  %call7 = call ptr @dictGetVal(ptr noundef %9)
  store ptr %call7, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define dso_local ptr @createClusterNode(ptr noundef %nodename, i32 noundef %flags) #0 {
entry:
  %nodename.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %node = alloca ptr, align 8
  store ptr %nodename, ptr %nodename.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %call = call noalias ptr @zmalloc(i64 noundef 2368) #16
  store ptr %call, ptr %node, align 8
  %0 = load ptr, ptr %nodename.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %node, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %2 = load ptr, ptr %nodename.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %2, i64 40, i1 false)
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %node, align 8
  %name1 = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 1
  %arraydecay2 = getelementptr inbounds [40 x i8], ptr %name1, i64 0, i64 0
  call void @getRandomHexChars(ptr noundef %arraydecay2, i64 noundef 40)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %node, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 2
  %arraydecay3 = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  call void @getRandomHexChars(ptr noundef %arraydecay3, i64 noundef 40)
  %call4 = call i64 @mstime()
  %5 = load ptr, ptr %node, align 8
  %ctime = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 0
  store i64 %call4, ptr %ctime, align 8
  %6 = load ptr, ptr %node, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 4
  store i64 0, ptr %configEpoch, align 8
  %7 = load i32, ptr %flags.addr, align 4
  %8 = load ptr, ptr %node, align 8
  %flags5 = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 3
  store i32 %7, ptr %flags5, align 8
  %9 = load ptr, ptr %node, align 8
  %slots = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 5
  %arraydecay6 = getelementptr inbounds [2048 x i8], ptr %slots, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay6, i8 0, i64 2048, i1 false)
  %10 = load ptr, ptr %node, align 8
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 6
  store ptr null, ptr %slot_info_pairs, align 8
  %11 = load ptr, ptr %node, align 8
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 7
  store i32 0, ptr %slot_info_pairs_count, align 8
  %12 = load ptr, ptr %node, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 8
  store i32 0, ptr %numslots, align 4
  %13 = load ptr, ptr %node, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 9
  store i32 0, ptr %numslaves, align 8
  %14 = load ptr, ptr %node, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 10
  store ptr null, ptr %slaves, align 8
  %15 = load ptr, ptr %node, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 11
  store ptr null, ptr %slaveof, align 8
  %16 = load ptr, ptr %node, align 8
  %last_in_ping_gossip = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 12
  store i64 0, ptr %last_in_ping_gossip, align 8
  %17 = load ptr, ptr %node, align 8
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 14
  store i64 0, ptr %pong_received, align 8
  %18 = load ptr, ptr %node, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 13
  store i64 0, ptr %ping_sent, align 8
  %19 = load ptr, ptr %node, align 8
  %data_received = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 15
  store i64 0, ptr %data_received, align 8
  %20 = load ptr, ptr %node, align 8
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %20, i32 0, i32 16
  store i64 0, ptr %fail_time, align 8
  %21 = load ptr, ptr %node, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 27
  store ptr null, ptr %link, align 8
  %22 = load ptr, ptr %node, align 8
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 28
  store ptr null, ptr %inbound_link, align 8
  %23 = load ptr, ptr %node, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 21
  %arraydecay7 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay7, i8 0, i64 46, i1 false)
  %call8 = call ptr @sdsempty()
  %24 = load ptr, ptr %node, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %24, i32 0, i32 22
  store ptr %call8, ptr %hostname, align 8
  %call9 = call ptr @sdsempty()
  %25 = load ptr, ptr %node, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %25, i32 0, i32 23
  store ptr %call9, ptr %human_nodename, align 8
  %26 = load ptr, ptr %node, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %26, i32 0, i32 24
  store i32 0, ptr %tcp_port, align 8
  %27 = load ptr, ptr %node, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 26
  store i32 0, ptr %cport, align 8
  %28 = load ptr, ptr %node, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %28, i32 0, i32 25
  store i32 0, ptr %tls_port, align 4
  %call10 = call ptr @listCreate()
  %29 = load ptr, ptr %node, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %29, i32 0, i32 29
  store ptr %call10, ptr %fail_reports, align 8
  %30 = load ptr, ptr %node, align 8
  %voted_time = getelementptr inbounds %struct._clusterNode, ptr %30, i32 0, i32 17
  store i64 0, ptr %voted_time, align 8
  %31 = load ptr, ptr %node, align 8
  %orphaned_time = getelementptr inbounds %struct._clusterNode, ptr %31, i32 0, i32 19
  store i64 0, ptr %orphaned_time, align 8
  %32 = load ptr, ptr %node, align 8
  %repl_offset_time = getelementptr inbounds %struct._clusterNode, ptr %32, i32 0, i32 18
  store i64 0, ptr %repl_offset_time, align 8
  %33 = load ptr, ptr %node, align 8
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %33, i32 0, i32 20
  store i64 0, ptr %repl_offset, align 8
  %34 = load ptr, ptr %node, align 8
  %fail_reports11 = getelementptr inbounds %struct._clusterNode, ptr %34, i32 0, i32 29
  %35 = load ptr, ptr %fail_reports11, align 8
  %free = getelementptr inbounds %struct.list, ptr %35, i32 0, i32 3
  store ptr @zfree, ptr %free, align 8
  %36 = load ptr, ptr %node, align 8
  ret ptr %36
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterAddNode(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %retval = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %call = call ptr @sdsnewlen(ptr noundef %arraydecay, i64 noundef 40)
  %3 = load ptr, ptr %node.addr, align 8
  %call1 = call i32 @dictAdd(ptr noundef %1, ptr noundef %call, ptr noundef %3)
  store i32 %call1, ptr %retval, align 4
  %4 = load i32, ptr %retval, align 4
  %cmp = icmp eq i32 %4, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.60, ptr noundef @.str.18, i32 noundef 1530)
  call void @abort() #13
  unreachable

5:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %5, %cond.true
  ret void
}

declare ptr @sdssplitlen(ptr noundef, i64 noundef, ptr noundef, i32 noundef, ptr noundef) #1

declare ptr @sdscpy(ptr noundef, ptr noundef) #1

declare i32 @isValidAuxString(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strrchr(ptr noundef, i32 noundef) #3

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strchr(ptr noundef, i32 noundef) #3

declare void @_serverAssert(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: noreturn nounwind
declare void @abort() #7

declare i64 @mstime() #1

declare void @_serverPanic(ptr noundef, i32 noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterGetNodesInMyShard(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %de = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  %call = call ptr @sdsnewlen(ptr noundef %arraydecay, i64 noundef 40)
  store ptr %call, ptr %s, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 5
  %2 = load ptr, ptr %shards, align 8
  %3 = load ptr, ptr %s, align 8
  %call1 = call ptr @dictFind(ptr noundef %2, ptr noundef %3)
  store ptr %call1, ptr %de, align 8
  %4 = load ptr, ptr %s, align 8
  call void @sdsfree(ptr noundef %4)
  %5 = load ptr, ptr %de, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %6)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ null, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeAddSlave(ptr noundef %master, ptr noundef %slave) #0 {
entry:
  %retval = alloca i32, align 4
  %master.addr = alloca ptr, align 8
  %slave.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  store ptr %master, ptr %master.addr, align 8
  store ptr %slave, ptr %slave.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %1 = load ptr, ptr %master.addr, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 9
  %2 = load i32, ptr %numslaves, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %master.addr, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 10
  %4 = load ptr, ptr %slaves, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %7 = load ptr, ptr %slave.addr, align 8
  %cmp1 = icmp eq ptr %6, %7
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, ptr %j, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !15

for.end:                                          ; preds = %for.cond
  %9 = load ptr, ptr %master.addr, align 8
  %slaves2 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 10
  %10 = load ptr, ptr %slaves2, align 8
  %11 = load ptr, ptr %master.addr, align 8
  %numslaves3 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 9
  %12 = load i32, ptr %numslaves3, align 8
  %add = add nsw i32 %12, 1
  %conv = sext i32 %add to i64
  %mul = mul i64 8, %conv
  %call = call ptr @zrealloc(ptr noundef %10, i64 noundef %mul) #17
  %13 = load ptr, ptr %master.addr, align 8
  %slaves4 = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 10
  store ptr %call, ptr %slaves4, align 8
  %14 = load ptr, ptr %slave.addr, align 8
  %15 = load ptr, ptr %master.addr, align 8
  %slaves5 = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 10
  %16 = load ptr, ptr %slaves5, align 8
  %17 = load ptr, ptr %master.addr, align 8
  %numslaves6 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 9
  %18 = load i32, ptr %numslaves6, align 8
  %idxprom7 = sext i32 %18 to i64
  %arrayidx8 = getelementptr inbounds ptr, ptr %16, i64 %idxprom7
  store ptr %14, ptr %arrayidx8, align 8
  %19 = load ptr, ptr %master.addr, align 8
  %numslaves9 = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 9
  %20 = load i32, ptr %numslaves9, align 8
  %inc10 = add nsw i32 %20, 1
  store i32 %inc10, ptr %numslaves9, align 8
  %21 = load ptr, ptr %master.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 3
  %22 = load i32, ptr %flags, align 8
  %or = or i32 %22, 256
  store i32 %or, ptr %flags, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %23 = load i32, ptr %retval, align 4
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterAddSlot(ptr noundef %n, i32 noundef %slot) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 9
  %1 = load i32, ptr %slot.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %4 = load i32, ptr %slot.addr, align 4
  %call = call i32 @clusterNodeSetSlotBit(ptr noundef %3, i32 noundef %4)
  %5 = load ptr, ptr %n.addr, align 8
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots1 = getelementptr inbounds %struct.clusterState, ptr %6, i32 0, i32 9
  %7 = load i32, ptr %slot.addr, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr inbounds [16384 x ptr], ptr %slots1, i64 0, i64 %idxprom2
  store ptr %5, ptr %arrayidx3, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare void @zfree(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @clusterGetMaxEpoch() #0 {
entry:
  %max = alloca i64, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %node = alloca ptr, align 8
  store i64 0, ptr %max, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %1)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %2)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %3)
  store ptr %call2, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 4
  %5 = load i64, ptr %configEpoch, align 8
  %6 = load i64, ptr %max, align 8
  %cmp3 = icmp ugt i64 %5, %6
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %7 = load ptr, ptr %node, align 8
  %configEpoch4 = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 4
  %8 = load i64, ptr %configEpoch4, align 8
  store i64 %8, ptr %max, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !16

while.end:                                        ; preds = %while.cond
  %9 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %9)
  %10 = load i64, ptr %max, align 8
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %currentEpoch, align 8
  %cmp5 = icmp ult i64 %10, %12
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %while.end
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch7 = getelementptr inbounds %struct.clusterState, ptr %13, i32 0, i32 1
  %14 = load i64, ptr %currentEpoch7, align 8
  store i64 %14, ptr %max, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %while.end
  %15 = load i64, ptr %max, align 8
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterSaveConfig(i32 noundef %do_fsync) #0 {
entry:
  %do_fsync.addr = alloca i32, align 4
  %ci = alloca ptr, align 8
  %tmpfilename = alloca ptr, align 8
  %content_size = alloca i64, align 8
  %offset = alloca i64, align 8
  %written_bytes = alloca i64, align 8
  %fd = alloca i32, align 4
  %retval1 = alloca i32, align 4
  store i32 %do_fsync, ptr %do_fsync.addr, align 4
  store i64 0, ptr %offset, align 8
  store i32 -1, ptr %fd, align 4
  store i32 -1, ptr %retval1, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 22
  %1 = load i32, ptr %todo_before_sleep, align 8
  %and = and i32 %1, -5
  store i32 %and, ptr %todo_before_sleep, align 8
  %call = call ptr @clusterGenNodesDescription(ptr noundef null, i32 noundef 32, i32 noundef 0)
  store ptr %call, ptr %ci, align 8
  %2 = load ptr, ptr %ci, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %3, i32 0, i32 1
  %4 = load i64, ptr %currentEpoch, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 21
  %6 = load i64, ptr %lastVoteEpoch, align 8
  %call2 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %2, ptr noundef @.str.31, i64 noundef %4, i64 noundef %6)
  store ptr %call2, ptr %ci, align 8
  %7 = load ptr, ptr %ci, align 8
  %call3 = call i64 @sdslen(ptr noundef %7)
  store i64 %call3, ptr %content_size, align 8
  %call4 = call ptr @sdsempty()
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 366), align 8
  %call5 = call i32 @getpid() #15
  %call6 = call i64 @mstime()
  %call7 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call4, ptr noundef @.str.32, ptr noundef %8, i32 noundef %call5, i64 noundef %call6)
  store ptr %call7, ptr %tmpfilename, align 8
  %9 = load ptr, ptr %tmpfilename, align 8
  %call8 = call i32 (ptr, i32, ...) @open64(ptr noundef %9, i32 noundef 65, i32 noundef 420)
  store i32 %call8, ptr %fd, align 4
  %cmp = icmp eq i32 %call8, -1
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp9 = icmp slt i32 3, %10
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %call11 = call ptr @__errno_location() #14
  %11 = load i32, ptr %call11, align 4
  %call12 = call ptr @strerror(i32 noundef %11) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.33, ptr noundef %call12)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then10
  br label %cleanup

if.end13:                                         ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end29, %if.then20, %if.end13
  %12 = load i64, ptr %offset, align 8
  %13 = load i64, ptr %content_size, align 8
  %cmp14 = icmp ult i64 %12, %13
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %14 = load i32, ptr %fd, align 4
  %15 = load ptr, ptr %ci, align 8
  %16 = load i64, ptr %offset, align 8
  %add.ptr = getelementptr inbounds i8, ptr %15, i64 %16
  %17 = load i64, ptr %content_size, align 8
  %18 = load i64, ptr %offset, align 8
  %sub = sub i64 %17, %18
  %call15 = call i64 @write(i32 noundef %14, ptr noundef %add.ptr, i64 noundef %sub)
  store i64 %call15, ptr %written_bytes, align 8
  %19 = load i64, ptr %written_bytes, align 8
  %cmp16 = icmp sle i64 %19, 0
  br i1 %cmp16, label %if.then17, label %if.end29

if.then17:                                        ; preds = %while.body
  %call18 = call ptr @__errno_location() #14
  %20 = load i32, ptr %call18, align 4
  %cmp19 = icmp eq i32 %20, 4
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.then17
  br label %while.cond, !llvm.loop !17

if.end21:                                         ; preds = %if.then17
  br label %do.body22

do.body22:                                        ; preds = %if.end21
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp23 = icmp slt i32 3, %21
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %do.body22
  br label %do.end28

if.end25:                                         ; preds = %do.body22
  %22 = load i64, ptr %offset, align 8
  %call26 = call ptr @__errno_location() #14
  %23 = load i32, ptr %call26, align 4
  %call27 = call ptr @strerror(i32 noundef %23) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.34, i64 noundef %22, ptr noundef %call27)
  br label %do.end28

do.end28:                                         ; preds = %if.end25, %if.then24
  br label %cleanup

if.end29:                                         ; preds = %while.body
  %24 = load i64, ptr %written_bytes, align 8
  %25 = load i64, ptr %offset, align 8
  %add = add i64 %25, %24
  store i64 %add, ptr %offset, align 8
  br label %while.cond, !llvm.loop !17

while.end:                                        ; preds = %while.cond
  %26 = load i32, ptr %do_fsync.addr, align 4
  %tobool = icmp ne i32 %26, 0
  br i1 %tobool, label %if.then30, label %if.end44

if.then30:                                        ; preds = %while.end
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %todo_before_sleep31 = getelementptr inbounds %struct.clusterState, ptr %27, i32 0, i32 22
  %28 = load i32, ptr %todo_before_sleep31, align 8
  %and32 = and i32 %28, -9
  store i32 %and32, ptr %todo_before_sleep31, align 8
  %29 = load i32, ptr %fd, align 4
  %call33 = call i32 @fdatasync(i32 noundef %29)
  %cmp34 = icmp eq i32 %call33, -1
  br i1 %cmp34, label %if.then35, label %if.end43

if.then35:                                        ; preds = %if.then30
  br label %do.body36

do.body36:                                        ; preds = %if.then35
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp37 = icmp slt i32 3, %30
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %do.body36
  br label %do.end42

if.end39:                                         ; preds = %do.body36
  %call40 = call ptr @__errno_location() #14
  %31 = load i32, ptr %call40, align 4
  %call41 = call ptr @strerror(i32 noundef %31) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.35, ptr noundef %call41)
  br label %do.end42

do.end42:                                         ; preds = %if.end39, %if.then38
  br label %cleanup

if.end43:                                         ; preds = %if.then30
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %while.end
  %32 = load ptr, ptr %tmpfilename, align 8
  %33 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 366), align 8
  %call45 = call i32 @rename(ptr noundef %32, ptr noundef %33) #15
  %cmp46 = icmp eq i32 %call45, -1
  br i1 %cmp46, label %if.then47, label %if.end55

if.then47:                                        ; preds = %if.end44
  br label %do.body48

do.body48:                                        ; preds = %if.then47
  %34 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp49 = icmp slt i32 3, %34
  br i1 %cmp49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %do.body48
  br label %do.end54

if.end51:                                         ; preds = %do.body48
  %call52 = call ptr @__errno_location() #14
  %35 = load i32, ptr %call52, align 4
  %call53 = call ptr @strerror(i32 noundef %35) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.36, ptr noundef %call53)
  br label %do.end54

do.end54:                                         ; preds = %if.end51, %if.then50
  br label %cleanup

if.end55:                                         ; preds = %if.end44
  %36 = load i32, ptr %do_fsync.addr, align 4
  %tobool56 = icmp ne i32 %36, 0
  br i1 %tobool56, label %if.then57, label %if.end69

if.then57:                                        ; preds = %if.end55
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 366), align 8
  %call58 = call i32 @fsyncFileDir(ptr noundef %37)
  %cmp59 = icmp eq i32 %call58, -1
  br i1 %cmp59, label %if.then60, label %if.end68

if.then60:                                        ; preds = %if.then57
  br label %do.body61

do.body61:                                        ; preds = %if.then60
  %38 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp62 = icmp slt i32 3, %38
  br i1 %cmp62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %do.body61
  br label %do.end67

if.end64:                                         ; preds = %do.body61
  %call65 = call ptr @__errno_location() #14
  %39 = load i32, ptr %call65, align 4
  %call66 = call ptr @strerror(i32 noundef %39) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.37, ptr noundef %call66)
  br label %do.end67

do.end67:                                         ; preds = %if.end64, %if.then63
  br label %cleanup

if.end68:                                         ; preds = %if.then57
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %if.end55
  store i32 0, ptr %retval1, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end69, %do.end67, %do.end54, %do.end42, %do.end28, %do.end
  %40 = load i32, ptr %fd, align 4
  %cmp70 = icmp ne i32 %40, -1
  br i1 %cmp70, label %if.then71, label %if.end73

if.then71:                                        ; preds = %cleanup
  %41 = load i32, ptr %fd, align 4
  %call72 = call i32 @close(i32 noundef %41)
  br label %if.end73

if.end73:                                         ; preds = %if.then71, %cleanup
  %42 = load i32, ptr %retval1, align 4
  %tobool74 = icmp ne i32 %42, 0
  br i1 %tobool74, label %if.then75, label %if.end77

if.then75:                                        ; preds = %if.end73
  %43 = load ptr, ptr %tmpfilename, align 8
  %call76 = call i32 @unlink(ptr noundef %43) #15
  br label %if.end77

if.end77:                                         ; preds = %if.then75, %if.end73
  %44 = load ptr, ptr %tmpfilename, align 8
  call void @sdsfree(ptr noundef %44)
  %45 = load ptr, ptr %ci, align 8
  call void @sdsfree(ptr noundef %45)
  %46 = load i32, ptr %retval1, align 4
  ret i32 %46
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterGenNodesDescription(ptr noundef %c, i32 noundef %filter, i32 noundef %tls_primary) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %filter.addr = alloca i32, align 4
  %tls_primary.addr = alloca i32, align 4
  %ci = alloca ptr, align 8
  %ni = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %node = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %filter, ptr %filter.addr, align 4
  store i32 %tls_primary, ptr %tls_primary.addr, align 4
  %call = call ptr @sdsempty()
  store ptr %call, ptr %ci, align 8
  %0 = load i32, ptr %filter.addr, align 4
  call void @clusterGenNodesSlotsInfo(i32 noundef %0)
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %nodes, align 8
  %call1 = call ptr @dictGetSafeIterator(ptr noundef %2)
  store ptr %call1, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then, %entry
  %3 = load ptr, ptr %di, align 8
  %call2 = call ptr @dictNext(ptr noundef %3)
  store ptr %call2, ptr %de, align 8
  %cmp = icmp ne ptr %call2, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %de, align 8
  %call3 = call ptr @dictGetVal(ptr noundef %4)
  store ptr %call3, ptr %node, align 8
  %5 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 3
  %6 = load i32, ptr %flags, align 8
  %7 = load i32, ptr %filter.addr, align 4
  %and = and i32 %6, %7
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !18

if.end:                                           ; preds = %while.body
  %8 = load ptr, ptr %c.addr, align 8
  %9 = load ptr, ptr %node, align 8
  %10 = load i32, ptr %tls_primary.addr, align 4
  %call4 = call ptr @clusterGenNodeDescription(ptr noundef %8, ptr noundef %9, i32 noundef %10)
  store ptr %call4, ptr %ni, align 8
  %11 = load ptr, ptr %ci, align 8
  %12 = load ptr, ptr %ni, align 8
  %call5 = call ptr @sdscatsds(ptr noundef %11, ptr noundef %12)
  store ptr %call5, ptr %ci, align 8
  %13 = load ptr, ptr %ni, align 8
  call void @sdsfree(ptr noundef %13)
  %14 = load ptr, ptr %ci, align 8
  %call6 = call ptr @sdscatlen(ptr noundef %14, ptr noundef @.str.159, i64 noundef 1)
  store ptr %call6, ptr %ci, align 8
  %15 = load ptr, ptr %node, align 8
  call void @clusterFreeNodesSlotsInfo(ptr noundef %15)
  br label %while.cond, !llvm.loop !18

while.end:                                        ; preds = %while.cond
  %16 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %16)
  %17 = load ptr, ptr %ci, align 8
  ret ptr %17
}

declare ptr @sdscatfmt(ptr noundef, ptr noundef, ...) #1

declare ptr @sdsempty() #1

; Function Attrs: nounwind
declare i32 @getpid() #6

declare i32 @open64(ptr noundef, i32 noundef, ...) #1

declare i64 @write(i32 noundef, ptr noundef, i64 noundef) #1

declare i32 @fdatasync(i32 noundef) #1

; Function Attrs: nounwind
declare i32 @rename(ptr noundef, ptr noundef) #6

declare i32 @fsyncFileDir(ptr noundef) #1

declare i32 @close(i32 noundef) #1

; Function Attrs: nounwind
declare i32 @unlink(ptr noundef) #6

declare void @sdsfree(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterSaveConfigOrDie(i32 noundef %do_fsync) #0 {
entry:
  %do_fsync.addr = alloca i32, align 4
  store i32 %do_fsync, ptr %do_fsync.addr, align 4
  %0 = load i32, ptr %do_fsync.addr, align 4
  %call = call i32 @clusterSaveConfig(i32 noundef %0)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 3, %1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.38)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  call void @exit(i32 noundef 1) #13
  unreachable

if.end3:                                          ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterLockConfig(ptr noundef %filename) #0 {
entry:
  %retval = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %fd = alloca i32, align 4
  store ptr %filename, ptr %filename.addr, align 8
  %0 = load ptr, ptr %filename.addr, align 8
  %call = call i32 (ptr, i32, ...) @open64(ptr noundef %0, i32 noundef 524353, i32 noundef 420)
  store i32 %call, ptr %fd, align 4
  %1 = load i32, ptr %fd, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 3, %2
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %filename.addr, align 8
  %call3 = call ptr @__errno_location() #14
  %4 = load i32, ptr %call3, align 4
  %call4 = call ptr @strerror(i32 noundef %4) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.39, ptr noundef %3, ptr noundef %call4)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  store i32 -1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %entry
  %5 = load i32, ptr %fd, align 4
  %call6 = call i32 @flock(i32 noundef %5, i32 noundef 6) #15
  %cmp7 = icmp eq i32 %call6, -1
  br i1 %cmp7, label %if.then8, label %if.end26

if.then8:                                         ; preds = %if.end5
  %call9 = call ptr @__errno_location() #14
  %6 = load i32, ptr %call9, align 4
  %cmp10 = icmp eq i32 %6, 11
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.then8
  br label %do.body12

do.body12:                                        ; preds = %if.then11
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp13 = icmp slt i32 3, %7
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %do.body12
  br label %do.end16

if.end15:                                         ; preds = %do.body12
  %8 = load ptr, ptr %filename.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.40, ptr noundef %8)
  br label %do.end16

do.end16:                                         ; preds = %if.end15, %if.then14
  br label %if.end24

if.else:                                          ; preds = %if.then8
  br label %do.body17

do.body17:                                        ; preds = %if.else
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp18 = icmp slt i32 3, %9
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %do.body17
  br label %do.end23

if.end20:                                         ; preds = %do.body17
  %10 = load ptr, ptr %filename.addr, align 8
  %call21 = call ptr @__errno_location() #14
  %11 = load i32, ptr %call21, align 4
  %call22 = call ptr @strerror(i32 noundef %11) #15
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.41, ptr noundef %10, ptr noundef %call22)
  br label %do.end23

do.end23:                                         ; preds = %if.end20, %if.then19
  br label %if.end24

if.end24:                                         ; preds = %do.end23, %do.end16
  %12 = load i32, ptr %fd, align 4
  %call25 = call i32 @close(i32 noundef %12)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end5
  %13 = load i32, ptr %fd, align 4
  store i32 %13, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 382), align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end26, %if.end24, %do.end
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind
declare i32 @flock(i32 noundef, i32 noundef) #6

; Function Attrs: nounwind uwtable
define dso_local void @deriveAnnouncedPorts(ptr noundef %announced_tcp_port, ptr noundef %announced_tls_port, ptr noundef %announced_cport) #0 {
entry:
  %announced_tcp_port.addr = alloca ptr, align 8
  %announced_tls_port.addr = alloca ptr, align 8
  %announced_cport.addr = alloca ptr, align 8
  store ptr %announced_tcp_port, ptr %announced_tcp_port.addr, align 8
  store ptr %announced_tls_port, ptr %announced_tls_port.addr, align 8
  store ptr %announced_cport, ptr %announced_cport.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 377), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 377), align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %1, %cond.true ], [ %2, %cond.false ]
  %3 = load ptr, ptr %announced_tcp_port.addr, align 8
  store i32 %cond, ptr %3, align 4
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 378), align 8
  %tobool1 = icmp ne i32 %4, 0
  br i1 %tobool1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.end
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 378), align 8
  br label %cond.end4

cond.false3:                                      ; preds = %cond.end
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  br label %cond.end4

cond.end4:                                        ; preds = %cond.false3, %cond.true2
  %cond5 = phi i32 [ %5, %cond.true2 ], [ %6, %cond.false3 ]
  %7 = load ptr, ptr %announced_tls_port.addr, align 8
  store i32 %cond5, ptr %7, align 4
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 379), align 4
  %tobool6 = icmp ne i32 %8, 0
  br i1 %tobool6, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end4
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 379), align 4
  %10 = load ptr, ptr %announced_cport.addr, align 8
  store i32 %9, ptr %10, align 4
  br label %if.end10

if.else:                                          ; preds = %cond.end4
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 363), align 8
  %tobool7 = icmp ne i32 %11, 0
  br i1 %tobool7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 363), align 8
  %13 = load ptr, ptr %announced_cport.addr, align 8
  store i32 %12, ptr %13, align 4
  br label %if.end

if.else9:                                         ; preds = %if.else
  %call = call i32 @defaultClientPort()
  %add = add nsw i32 %call, 10000
  %14 = load ptr, ptr %announced_cport.addr, align 8
  store i32 %add, ptr %14, align 4
  br label %if.end

if.end:                                           ; preds = %if.else9, %if.then8
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @defaultClientPort() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %1, %cond.true ], [ %2, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateMyselfFlags() #0 {
entry:
  %oldflags = alloca i32, align 4
  %nofailover = alloca i32, align 4
  %0 = load ptr, ptr @myself, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end6

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %flags, align 8
  store i32 %2, ptr %oldflags, align 4
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 372), align 8
  %tobool1 = icmp ne i32 %3, 0
  %cond = select i1 %tobool1, i32 512, i32 0
  store i32 %cond, ptr %nofailover, align 4
  %4 = load ptr, ptr @myself, align 8
  %flags2 = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %flags2, align 8
  %and = and i32 %5, -513
  store i32 %and, ptr %flags2, align 8
  %6 = load i32, ptr %nofailover, align 4
  %7 = load ptr, ptr @myself, align 8
  %flags3 = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 3
  %8 = load i32, ptr %flags3, align 8
  %or = or i32 %8, %6
  store i32 %or, ptr %flags3, align 8
  %9 = load ptr, ptr @myself, align 8
  %flags4 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %flags4, align 8
  %11 = load i32, ptr %oldflags, align 4
  %cmp = icmp ne i32 %10, %11
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterDoBeforeSleep(i32 noundef %flags) #0 {
entry:
  %flags.addr = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 22
  %2 = load i32, ptr %todo_before_sleep, align 8
  %or = or i32 %2, %0
  store i32 %or, ptr %todo_before_sleep, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateMyselfAnnouncedPorts() #0 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @myself, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 24
  %2 = load ptr, ptr @myself, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 25
  %3 = load ptr, ptr @myself, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 26
  call void @deriveAnnouncedPorts(ptr noundef %tcp_port, ptr noundef %tls_port, ptr noundef %cport)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateMyselfIp() #0 {
entry:
  %curr_ip = alloca ptr, align 8
  %changed = alloca i32, align 4
  %0 = load ptr, ptr @myself, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end29

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 373), align 8
  store ptr %1, ptr %curr_ip, align 8
  store i32 0, ptr %changed, align 4
  %2 = load ptr, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %3 = load ptr, ptr %curr_ip, align 8
  %cmp1 = icmp ne ptr %3, null
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %land.lhs.true
  store i32 1, ptr %changed, align 4
  br label %if.end16

if.else:                                          ; preds = %land.lhs.true, %if.end
  %4 = load ptr, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %cmp3 = icmp ne ptr %4, null
  br i1 %cmp3, label %land.lhs.true4, label %if.else7

land.lhs.true4:                                   ; preds = %if.else
  %5 = load ptr, ptr %curr_ip, align 8
  %cmp5 = icmp eq ptr %5, null
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %land.lhs.true4
  store i32 1, ptr %changed, align 4
  br label %if.end15

if.else7:                                         ; preds = %land.lhs.true4, %if.else
  %6 = load ptr, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %tobool8 = icmp ne ptr %6, null
  br i1 %tobool8, label %land.lhs.true9, label %if.end14

land.lhs.true9:                                   ; preds = %if.else7
  %7 = load ptr, ptr %curr_ip, align 8
  %tobool10 = icmp ne ptr %7, null
  br i1 %tobool10, label %land.lhs.true11, label %if.end14

land.lhs.true11:                                  ; preds = %land.lhs.true9
  %8 = load ptr, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %9 = load ptr, ptr %curr_ip, align 8
  %call = call i32 @strcmp(ptr noundef %8, ptr noundef %9) #12
  %tobool12 = icmp ne i32 %call, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %land.lhs.true11
  store i32 1, ptr %changed, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %land.lhs.true11, %land.lhs.true9, %if.else7
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then6
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.then2
  %10 = load i32, ptr %changed, align 4
  %tobool17 = icmp ne i32 %10, 0
  br i1 %tobool17, label %if.then18, label %if.end29

if.then18:                                        ; preds = %if.end16
  %11 = load ptr, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %tobool19 = icmp ne ptr %11, null
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.then18
  %12 = load ptr, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  call void @zfree(ptr noundef %12)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.then18
  %13 = load ptr, ptr %curr_ip, align 8
  store ptr %13, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %14 = load ptr, ptr %curr_ip, align 8
  %tobool22 = icmp ne ptr %14, null
  br i1 %tobool22, label %if.then23, label %if.else26

if.then23:                                        ; preds = %if.end21
  %15 = load ptr, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %call24 = call noalias ptr @zstrdup(ptr noundef %15)
  store ptr %call24, ptr @clusterUpdateMyselfIp.prev_ip, align 8
  %16 = load ptr, ptr @myself, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 21
  %arraydecay = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 373), align 8
  %call25 = call i64 @redis_strlcpy(ptr noundef %arraydecay, ptr noundef %17, i64 noundef 46)
  br label %if.end28

if.else26:                                        ; preds = %if.end21
  %18 = load ptr, ptr @myself, align 8
  %ip27 = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 21
  %arrayidx = getelementptr inbounds [46 x i8], ptr %ip27, i64 0, i64 0
  store i8 0, ptr %arrayidx, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.else26, %if.then23
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.end16, %if.then
  ret void
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #3

declare noalias ptr @zstrdup(ptr noundef) #1

declare i64 @redis_strlcpy(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateMyselfHostname() #0 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @myself, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 374), align 8
  call void @updateAnnouncedHostname(ptr noundef %1, ptr noundef %2)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @updateAnnouncedHostname(ptr noundef %node, ptr noundef %new) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %new.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %new, ptr %new.addr, align 8
  %0 = load ptr, ptr %new.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %new.addr, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 22
  %3 = load ptr, ptr %hostname, align 8
  %call = call i32 @strcmp(ptr noundef %1, ptr noundef %3) #12
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %4 = load ptr, ptr %new.addr, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.end, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %if.else
  %5 = load ptr, ptr %node.addr, align 8
  %hostname4 = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 22
  %6 = load ptr, ptr %hostname4, align 8
  %call5 = call i64 @sdslen(ptr noundef %6)
  %cmp = icmp eq i64 %call5, 0
  br i1 %cmp, label %if.then6, label %if.end

if.then6:                                         ; preds = %land.lhs.true3
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end
  %7 = load ptr, ptr %new.addr, align 8
  %tobool8 = icmp ne ptr %7, null
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.end7
  %8 = load ptr, ptr %node.addr, align 8
  %hostname10 = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 22
  %9 = load ptr, ptr %hostname10, align 8
  %10 = load ptr, ptr %new.addr, align 8
  %call11 = call ptr @sdscpy(ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %node.addr, align 8
  %hostname12 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 22
  store ptr %call11, ptr %hostname12, align 8
  br label %if.end20

if.else13:                                        ; preds = %if.end7
  %12 = load ptr, ptr %node.addr, align 8
  %hostname14 = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 22
  %13 = load ptr, ptr %hostname14, align 8
  %call15 = call i64 @sdslen(ptr noundef %13)
  %cmp16 = icmp ne i64 %call15, 0
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.else13
  %14 = load ptr, ptr %node.addr, align 8
  %hostname18 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 22
  %15 = load ptr, ptr %hostname18, align 8
  call void @sdsclear(ptr noundef %15)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.else13
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then9
  call void @clusterDoBeforeSleep(i32 noundef 4)
  br label %return

return:                                           ; preds = %if.end20, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateMyselfHumanNodename() #0 {
entry:
  %0 = load ptr, ptr @myself, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @myself, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 375), align 8
  call void @updateAnnouncedHumanNodename(ptr noundef %1, ptr noundef %2)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @updateAnnouncedHumanNodename(ptr noundef %node, ptr noundef %new) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %new.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %new, ptr %new.addr, align 8
  %0 = load ptr, ptr %new.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %new.addr, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 23
  %3 = load ptr, ptr %human_nodename, align 8
  %call = call i32 @strcmp(ptr noundef %1, ptr noundef %3) #12
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %4 = load ptr, ptr %new.addr, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.end, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %if.else
  %5 = load ptr, ptr %node.addr, align 8
  %human_nodename4 = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 23
  %6 = load ptr, ptr %human_nodename4, align 8
  %call5 = call i64 @sdslen(ptr noundef %6)
  %cmp = icmp eq i64 %call5, 0
  br i1 %cmp, label %if.then6, label %if.end

if.then6:                                         ; preds = %land.lhs.true3
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end
  %7 = load ptr, ptr %new.addr, align 8
  %tobool8 = icmp ne ptr %7, null
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.end7
  %8 = load ptr, ptr %node.addr, align 8
  %human_nodename10 = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 23
  %9 = load ptr, ptr %human_nodename10, align 8
  %10 = load ptr, ptr %new.addr, align 8
  %call11 = call ptr @sdscpy(ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %node.addr, align 8
  %human_nodename12 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 23
  store ptr %call11, ptr %human_nodename12, align 8
  br label %if.end20

if.else13:                                        ; preds = %if.end7
  %12 = load ptr, ptr %node.addr, align 8
  %human_nodename14 = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 23
  %13 = load ptr, ptr %human_nodename14, align 8
  %call15 = call i64 @sdslen(ptr noundef %13)
  %cmp16 = icmp ne i64 %call15, 0
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.else13
  %14 = load ptr, ptr %node.addr, align 8
  %human_nodename18 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 23
  %15 = load ptr, ptr %human_nodename18, align 8
  call void @sdsclear(ptr noundef %15)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.else13
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then9
  call void @clusterDoBeforeSleep(i32 noundef 4)
  br label %return

return:                                           ; preds = %if.end20, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterInit() #0 {
entry:
  %saveconf = alloca i32, align 4
  %i = alloca i32, align 4
  %port = alloca i32, align 4
  store i32 0, ptr %saveconf, align 4
  %call = call noalias ptr @zmalloc(i64 noundef 395600) #16
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 0
  store ptr null, ptr %myself, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 1
  store i64 0, ptr %currentEpoch, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 2
  store i32 1, ptr %state, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %3, i32 0, i32 3
  store i32 1, ptr %size, align 4
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 22
  store i32 0, ptr %todo_before_sleep, align 8
  %call1 = call ptr @dictCreate(ptr noundef @clusterNodesDictType)
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 4
  store ptr %call1, ptr %nodes, align 8
  %call2 = call ptr @dictCreate(ptr noundef @clusterSdsToListType)
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %6, i32 0, i32 5
  store ptr %call2, ptr %shards, align 8
  %call3 = call ptr @dictCreate(ptr noundef @clusterNodesBlackListDictType)
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 6
  store ptr %call3, ptr %nodes_black_list, align 8
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_time = getelementptr inbounds %struct.clusterState, ptr %8, i32 0, i32 11
  store i64 0, ptr %failover_auth_time, align 8
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_count = getelementptr inbounds %struct.clusterState, ptr %9, i32 0, i32 12
  store i32 0, ptr %failover_auth_count, align 8
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_rank = getelementptr inbounds %struct.clusterState, ptr %10, i32 0, i32 14
  store i32 0, ptr %failover_auth_rank, align 8
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_epoch = getelementptr inbounds %struct.clusterState, ptr %11, i32 0, i32 15
  store i64 0, ptr %failover_auth_epoch, align 8
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %cant_failover_reason = getelementptr inbounds %struct.clusterState, ptr %12, i32 0, i32 16
  store i32 0, ptr %cant_failover_reason, align 8
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %13, i32 0, i32 21
  store i64 0, ptr %lastVoteEpoch, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %14 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %14, 11
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_sent = getelementptr inbounds %struct.clusterState, ptr %15, i32 0, i32 23
  %16 = load i32, ptr %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_sent, i64 0, i64 %idxprom
  store i64 0, ptr %arrayidx, align 8
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_received = getelementptr inbounds %struct.clusterState, ptr %17, i32 0, i32 24
  %18 = load i32, ptr %i, align 4
  %idxprom4 = sext i32 %18 to i64
  %arrayidx5 = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_received, i64 0, i64 %idxprom4
  store i64 0, ptr %arrayidx5, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32, ptr %i, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %for.cond
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_pfail_nodes = getelementptr inbounds %struct.clusterState, ptr %20, i32 0, i32 25
  store i64 0, ptr %stats_pfail_nodes, align 8
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stat_cluster_links_buffer_limit_exceeded = getelementptr inbounds %struct.clusterState, ptr %21, i32 0, i32 26
  store i64 0, ptr %stat_cluster_links_buffer_limit_exceeded, align 8
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %22, i32 0, i32 9
  %arraydecay = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay, i8 0, i64 131072, i1 false)
  call void @clusterCloseAllSlots()
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %23, i32 0, i32 27
  %arraydecay6 = getelementptr inbounds [2048 x i8], ptr %owner_not_claiming_slot, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay6, i8 0, i64 2048, i1 false)
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 382), align 8
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 366), align 8
  %call7 = call i32 @clusterLockConfig(ptr noundef %24)
  %cmp8 = icmp eq i32 %call7, -1
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  call void @exit(i32 noundef 1) #13
  unreachable

if.end:                                           ; preds = %for.end
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 366), align 8
  %call9 = call i32 @clusterLoadConfig(ptr noundef %25)
  %cmp10 = icmp eq i32 %call9, -1
  br i1 %cmp10, label %if.then11, label %if.end19

if.then11:                                        ; preds = %if.end
  %call12 = call ptr @createClusterNode(ptr noundef null, i32 noundef 17)
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself13 = getelementptr inbounds %struct.clusterState, ptr %26, i32 0, i32 0
  store ptr %call12, ptr %myself13, align 8
  store ptr %call12, ptr @myself, align 8
  br label %do.body

do.body:                                          ; preds = %if.then11
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp14 = icmp slt i32 2, %27
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %do.body
  br label %do.end

if.end16:                                         ; preds = %do.body
  %28 = load ptr, ptr @myself, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %28, i32 0, i32 1
  %arraydecay17 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.42, ptr noundef %arraydecay17)
  br label %do.end

do.end:                                           ; preds = %if.end16, %if.then15
  %29 = load ptr, ptr @myself, align 8
  call void @clusterAddNode(ptr noundef %29)
  %30 = load ptr, ptr @myself, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %30, i32 0, i32 2
  %arraydecay18 = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  %31 = load ptr, ptr @myself, align 8
  call void @clusterAddNodeToShard(ptr noundef %arraydecay18, ptr noundef %31)
  store i32 1, ptr %saveconf, align 4
  br label %if.end19

if.end19:                                         ; preds = %do.end, %if.end
  %32 = load i32, ptr %saveconf, align 4
  %tobool = icmp ne i32 %32, 0
  br i1 %tobool, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end19
  call void @clusterSaveConfigOrDie(i32 noundef 1)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end19
  %call22 = call i32 @defaultClientPort()
  store i32 %call22, ptr %port, align 4
  %33 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 363), align 8
  %tobool23 = icmp ne i32 %33, 0
  br i1 %tobool23, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end21
  %34 = load i32, ptr %port, align 4
  %cmp24 = icmp sgt i32 %34, 55535
  br i1 %cmp24, label %if.then25, label %if.end31

if.then25:                                        ; preds = %land.lhs.true
  br label %do.body26

do.body26:                                        ; preds = %if.then25
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp27 = icmp slt i32 3, %35
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %do.body26
  br label %do.end30

if.end29:                                         ; preds = %do.body26
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.43)
  br label %do.end30

do.end30:                                         ; preds = %if.end29, %if.then28
  call void @exit(i32 noundef 1) #13
  unreachable

if.end31:                                         ; preds = %land.lhs.true, %if.end21
  %36 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 48), align 8
  %tobool32 = icmp ne i32 %36, 0
  br i1 %tobool32, label %if.end39, label %if.then33

if.then33:                                        ; preds = %if.end31
  br label %do.body34

do.body34:                                        ; preds = %if.then33
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp35 = icmp slt i32 3, %37
  br i1 %cmp35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %do.body34
  br label %do.end38

if.end37:                                         ; preds = %do.body34
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.44)
  br label %do.end38

do.end38:                                         ; preds = %if.end37, %if.then36
  call void @exit(i32 noundef 1) #13
  unreachable

if.end39:                                         ; preds = %if.end31
  %call40 = call ptr @raxNew()
  %38 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots_to_channels = getelementptr inbounds %struct.clusterState, ptr %38, i32 0, i32 10
  store ptr %call40, ptr %slots_to_channels, align 8
  %39 = load ptr, ptr @myself, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %39, i32 0, i32 24
  %40 = load ptr, ptr @myself, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %40, i32 0, i32 25
  %41 = load ptr, ptr @myself, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %41, i32 0, i32 26
  call void @deriveAnnouncedPorts(ptr noundef %tcp_port, ptr noundef %tls_port, ptr noundef %cport)
  %42 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %42, i32 0, i32 17
  store i64 0, ptr %mf_end, align 8
  %43 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_slave = getelementptr inbounds %struct.clusterState, ptr %43, i32 0, i32 18
  store ptr null, ptr %mf_slave, align 8
  call void @resetManualFailover()
  call void @clusterUpdateMyselfFlags()
  call void @clusterUpdateMyselfIp()
  call void @clusterUpdateMyselfHostname()
  call void @clusterUpdateMyselfHumanNodename()
  ret void
}

declare ptr @dictCreate(ptr noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #9

; Function Attrs: nounwind uwtable
define dso_local void @clusterCloseAllSlots() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 7
  %arraydecay = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay, i8 0, i64 131072, i1 false)
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 8
  %arraydecay1 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay1, i8 0, i64 131072, i1 false)
  ret void
}

declare ptr @raxNew() #1

; Function Attrs: nounwind uwtable
define dso_local void @resetManualFailover() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_slave = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 18
  %1 = load ptr, ptr %mf_slave, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @unpauseActions(i32 noundef 2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 17
  store i64 0, ptr %mf_end, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_can_start = getelementptr inbounds %struct.clusterState, ptr %3, i32 0, i32 20
  store i32 0, ptr %mf_can_start, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_slave1 = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 18
  store ptr null, ptr %mf_slave1, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_master_offset = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 19
  store i64 -1, ptr %mf_master_offset, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterInitLast() #0 {
entry:
  %port = alloca i32, align 4
  %listener = alloca ptr, align 8
  %call = call ptr @connTypeOfCluster()
  %get_type = getelementptr inbounds %struct.ConnectionType, ptr %call, i32 0, i32 0
  %0 = load ptr, ptr %get_type, align 8
  %call1 = call ptr %0(ptr noundef null)
  %call2 = call i32 @connectionIndexByType(ptr noundef %call1)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp3 = icmp slt i32 3, %1
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %call5 = call ptr @connTypeOfCluster()
  %get_type6 = getelementptr inbounds %struct.ConnectionType, ptr %call5, i32 0, i32 0
  %2 = load ptr, ptr %get_type6, align 8
  %call7 = call ptr %2(ptr noundef null)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.45, ptr noundef %call7)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then4
  call void @exit(i32 noundef 1) #13
  unreachable

if.end8:                                          ; preds = %entry
  %call9 = call i32 @defaultClientPort()
  store i32 %call9, ptr %port, align 4
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 54), ptr %listener, align 8
  %3 = load ptr, ptr %listener, align 8
  %count = getelementptr inbounds %struct.connListener, ptr %3, i32 0, i32 1
  store i32 0, ptr %count, align 8
  %4 = load ptr, ptr %listener, align 8
  %bindaddr = getelementptr inbounds %struct.connListener, ptr %4, i32 0, i32 2
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 47), ptr %bindaddr, align 8
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 48), align 8
  %6 = load ptr, ptr %listener, align 8
  %bindaddr_count = getelementptr inbounds %struct.connListener, ptr %6, i32 0, i32 3
  store i32 %5, ptr %bindaddr_count, align 8
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 363), align 8
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end8
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 363), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end8
  %9 = load i32, ptr %port, align 4
  %add = add nsw i32 %9, 10000
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %8, %cond.true ], [ %add, %cond.false ]
  %10 = load ptr, ptr %listener, align 8
  %port10 = getelementptr inbounds %struct.connListener, ptr %10, i32 0, i32 4
  store i32 %cond, ptr %port10, align 4
  %call11 = call ptr @connTypeOfCluster()
  %11 = load ptr, ptr %listener, align 8
  %ct = getelementptr inbounds %struct.connListener, ptr %11, i32 0, i32 5
  store ptr %call11, ptr %ct, align 8
  %12 = load ptr, ptr %listener, align 8
  %call12 = call i32 @connListen(ptr noundef %12)
  %cmp13 = icmp eq i32 %call12, -1
  br i1 %cmp13, label %if.then14, label %if.end21

if.then14:                                        ; preds = %cond.end
  br label %do.body15

do.body15:                                        ; preds = %if.then14
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp16 = icmp slt i32 3, %13
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %do.body15
  br label %do.end20

if.end18:                                         ; preds = %do.body15
  %14 = load ptr, ptr %listener, align 8
  %port19 = getelementptr inbounds %struct.connListener, ptr %14, i32 0, i32 4
  %15 = load i32, ptr %port19, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.46, i32 noundef %15)
  br label %do.end20

do.end20:                                         ; preds = %if.end18, %if.then17
  call void @exit(i32 noundef 1) #13
  unreachable

if.end21:                                         ; preds = %cond.end
  %call22 = call i32 @createSocketAcceptHandler(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 54), ptr noundef @clusterAcceptHandler)
  %cmp23 = icmp ne i32 %call22, 0
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end21
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.18, i32 noundef 1060, ptr noundef @.str.47)
  call void @abort() #13
  unreachable

if.end25:                                         ; preds = %if.end21
  ret void
}

declare i32 @connectionIndexByType(ptr noundef) #1

declare ptr @connTypeOfCluster() #1

; Function Attrs: nounwind uwtable
define internal i32 @connListen(ptr noundef %listener) #0 {
entry:
  %listener.addr = alloca ptr, align 8
  store ptr %listener, ptr %listener.addr, align 8
  %0 = load ptr, ptr %listener.addr, align 8
  %ct = getelementptr inbounds %struct.connListener, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %ct, align 8
  %listen = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 8
  %2 = load ptr, ptr %listen, align 8
  %3 = load ptr, ptr %listener.addr, align 8
  %call = call i32 %2(ptr noundef %3)
  ret i32 %call
}

declare i32 @createSocketAcceptHandler(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterAcceptHandler(ptr noundef %el, i32 noundef %fd, ptr noundef %privdata, i32 noundef %mask) #0 {
entry:
  %el.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %privdata.addr = alloca ptr, align 8
  %mask.addr = alloca i32, align 4
  %cport = alloca i32, align 4
  %cfd = alloca i32, align 4
  %max = alloca i32, align 4
  %cip = alloca [46 x i8], align 16
  %require_auth = alloca i32, align 4
  %conn = alloca ptr, align 8
  store ptr %el, ptr %el.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %privdata, ptr %privdata.addr, align 8
  store i32 %mask, ptr %mask.addr, align 4
  store i32 1000, ptr %max, align 4
  store i32 1, ptr %require_auth, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %while.end

if.end:                                           ; preds = %land.lhs.true, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end49, %if.end
  %2 = load i32, ptr %max, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, ptr %max, align 4
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i32, ptr %fd.addr, align 4
  %arraydecay = getelementptr inbounds [46 x i8], ptr %cip, i64 0, i64 0
  %call = call i32 @anetTcpAccept(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 70), i32 noundef %3, ptr noundef %arraydecay, i64 noundef 46, ptr noundef %cport)
  store i32 %call, ptr %cfd, align 4
  %4 = load i32, ptr %cfd, align 4
  %cmp2 = icmp eq i32 %4, -1
  br i1 %cmp2, label %if.then3, label %if.end11

if.then3:                                         ; preds = %while.body
  %call4 = call ptr @__errno_location() #14
  %5 = load i32, ptr %call4, align 4
  %cmp5 = icmp ne i32 %5, 11
  br i1 %cmp5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %if.then3
  br label %do.body

do.body:                                          ; preds = %if.then6
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp7 = icmp slt i32 1, %6
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %do.body
  br label %do.end

if.end9:                                          ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.55, ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 70))
  br label %do.end

do.end:                                           ; preds = %if.end9, %if.then8
  br label %if.end10

if.end10:                                         ; preds = %do.end, %if.then3
  br label %while.end

if.end11:                                         ; preds = %while.body
  %call12 = call ptr @connTypeOfCluster()
  %7 = load i32, ptr %cfd, align 4
  %call13 = call ptr @connCreateAccepted(ptr noundef %call12, i32 noundef %7, ptr noundef %require_auth)
  store ptr %call13, ptr %conn, align 8
  %8 = load ptr, ptr %conn, align 8
  %call14 = call i32 @connGetState(ptr noundef %8)
  %cmp15 = icmp ne i32 %call14, 2
  br i1 %cmp15, label %if.then16, label %if.end23

if.then16:                                        ; preds = %if.end11
  br label %do.body17

do.body17:                                        ; preds = %if.then16
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp18 = icmp slt i32 1, %9
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %do.body17
  br label %do.end22

if.end20:                                         ; preds = %do.body17
  %10 = load ptr, ptr %conn, align 8
  %call21 = call ptr @connGetLastError(ptr noundef %10)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.56, ptr noundef %call21)
  br label %do.end22

do.end22:                                         ; preds = %if.end20, %if.then19
  %11 = load ptr, ptr %conn, align 8
  call void @connClose(ptr noundef %11)
  br label %while.end

if.end23:                                         ; preds = %if.end11
  %12 = load ptr, ptr %conn, align 8
  %call24 = call i32 @connEnableTcpNoDelay(ptr noundef %12)
  %13 = load ptr, ptr %conn, align 8
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %div = sdiv i64 %14, 1000
  %mul = mul nsw i64 %div, 2
  %conv = trunc i64 %mul to i32
  %call25 = call i32 @connKeepAlive(ptr noundef %13, i32 noundef %conv)
  br label %do.body26

do.body26:                                        ; preds = %if.end23
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp27 = icmp slt i32 1, %15
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %do.body26
  br label %do.end32

if.end30:                                         ; preds = %do.body26
  %arraydecay31 = getelementptr inbounds [46 x i8], ptr %cip, i64 0, i64 0
  %16 = load i32, ptr %cport, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.57, ptr noundef %arraydecay31, i32 noundef %16)
  br label %do.end32

do.end32:                                         ; preds = %if.end30, %if.then29
  %17 = load ptr, ptr %conn, align 8
  %call33 = call i32 @connAccept(ptr noundef %17, ptr noundef @clusterConnAcceptHandler)
  %cmp34 = icmp eq i32 %call33, -1
  br i1 %cmp34, label %if.then36, label %if.end49

if.then36:                                        ; preds = %do.end32
  %18 = load ptr, ptr %conn, align 8
  %call37 = call i32 @connGetState(ptr noundef %18)
  %cmp38 = icmp eq i32 %call37, 5
  br i1 %cmp38, label %if.then40, label %if.end48

if.then40:                                        ; preds = %if.then36
  br label %do.body41

do.body41:                                        ; preds = %if.then40
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp42 = icmp slt i32 1, %19
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %do.body41
  br label %do.end47

if.end45:                                         ; preds = %do.body41
  %20 = load ptr, ptr %conn, align 8
  %call46 = call ptr @connGetLastError(ptr noundef %20)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.58, ptr noundef %call46)
  br label %do.end47

do.end47:                                         ; preds = %if.end45, %if.then44
  br label %if.end48

if.end48:                                         ; preds = %do.end47, %if.then36
  %21 = load ptr, ptr %conn, align 8
  call void @connClose(ptr noundef %21)
  br label %while.end

if.end49:                                         ; preds = %do.end32
  br label %while.cond, !llvm.loop !20

while.end:                                        ; preds = %if.end48, %do.end22, %if.end10, %while.cond, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterReset(i32 noundef %hard) #0 {
entry:
  %hard.addr = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %j = alloca i32, align 4
  %node = alloca ptr, align 8
  %oldname = alloca ptr, align 8
  store i32 %hard, ptr %hard.addr, align 4
  %0 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @myself, align 8
  call void @clusterSetNodeAsMaster(ptr noundef %2)
  call void @replicationUnsetMaster()
  %call = call i64 @emptyData(i32 noundef -1, i32 noundef 0, ptr noundef null)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @clusterCloseAllSlots()
  call void @resetManualFailover()
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %3, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %j, align 4
  %call1 = call i32 @clusterDelSlot(i32 noundef %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %j, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %shards, align 8
  call void @dictEmpty(ptr noundef %7, ptr noundef null)
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %nodes, align 8
  %call2 = call ptr @dictGetSafeIterator(ptr noundef %9)
  store ptr %call2, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end8, %if.then7, %for.end
  %10 = load ptr, ptr %di, align 8
  %call3 = call ptr @dictNext(ptr noundef %10)
  store ptr %call3, ptr %de, align 8
  %cmp4 = icmp ne ptr %call3, null
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load ptr, ptr %de, align 8
  %call5 = call ptr @dictGetVal(ptr noundef %11)
  store ptr %call5, ptr %node, align 8
  %12 = load ptr, ptr %node, align 8
  %13 = load ptr, ptr @myself, align 8
  %cmp6 = icmp eq ptr %12, %13
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !22

if.end8:                                          ; preds = %while.body
  %14 = load ptr, ptr %node, align 8
  call void @clusterDelNode(ptr noundef %14)
  br label %while.cond, !llvm.loop !22

while.end:                                        ; preds = %while.cond
  %15 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %15)
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %16, i32 0, i32 6
  %17 = load ptr, ptr %nodes_black_list, align 8
  call void @dictEmpty(ptr noundef %17, ptr noundef null)
  %18 = load i32, ptr %hard.addr, align 4
  %tobool9 = icmp ne i32 %18, 0
  br i1 %tobool9, label %if.then10, label %if.end27

if.then10:                                        ; preds = %while.end
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %19, i32 0, i32 1
  store i64 0, ptr %currentEpoch, align 8
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %20, i32 0, i32 21
  store i64 0, ptr %lastVoteEpoch, align 8
  %21 = load ptr, ptr @myself, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 4
  store i64 0, ptr %configEpoch, align 8
  br label %do.body

do.body:                                          ; preds = %if.then10
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp11 = icmp slt i32 2, %22
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %do.body
  br label %do.end

if.end13:                                         ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.48)
  br label %do.end

do.end:                                           ; preds = %if.end13, %if.then12
  %23 = load ptr, ptr @myself, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %call14 = call ptr @sdsnewlen(ptr noundef %arraydecay, i64 noundef 40)
  store ptr %call14, ptr %oldname, align 8
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes15 = getelementptr inbounds %struct.clusterState, ptr %24, i32 0, i32 4
  %25 = load ptr, ptr %nodes15, align 8
  %26 = load ptr, ptr %oldname, align 8
  %call16 = call i32 @dictDelete(ptr noundef %25, ptr noundef %26)
  %27 = load ptr, ptr %oldname, align 8
  call void @sdsfree(ptr noundef %27)
  %28 = load ptr, ptr @myself, align 8
  %name17 = getelementptr inbounds %struct._clusterNode, ptr %28, i32 0, i32 1
  %arraydecay18 = getelementptr inbounds [40 x i8], ptr %name17, i64 0, i64 0
  call void @getRandomHexChars(ptr noundef %arraydecay18, i64 noundef 40)
  %29 = load ptr, ptr @myself, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %29, i32 0, i32 2
  %arraydecay19 = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  call void @getRandomHexChars(ptr noundef %arraydecay19, i64 noundef 40)
  %30 = load ptr, ptr @myself, align 8
  call void @clusterAddNode(ptr noundef %30)
  br label %do.body20

do.body20:                                        ; preds = %do.end
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp21 = icmp slt i32 2, %31
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %do.body20
  br label %do.end26

if.end23:                                         ; preds = %do.body20
  %32 = load ptr, ptr @myself, align 8
  %name24 = getelementptr inbounds %struct._clusterNode, ptr %32, i32 0, i32 1
  %arraydecay25 = getelementptr inbounds [40 x i8], ptr %name24, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.49, ptr noundef %arraydecay25)
  br label %do.end26

do.end26:                                         ; preds = %if.end23, %if.then22
  br label %if.end27

if.end27:                                         ; preds = %do.end26, %while.end
  %33 = load ptr, ptr @myself, align 8
  %shard_id28 = getelementptr inbounds %struct._clusterNode, ptr %33, i32 0, i32 2
  %arraydecay29 = getelementptr inbounds [40 x i8], ptr %shard_id28, i64 0, i64 0
  %34 = load ptr, ptr @myself, align 8
  call void @clusterAddNodeToShard(ptr noundef %arraydecay29, ptr noundef %34)
  call void @clusterDoBeforeSleep(i32 noundef 14)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSetNodeAsMaster(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %call = call i32 @clusterNodeIsMaster(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %n.addr, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 11
  %2 = load ptr, ptr %slaveof, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr %n.addr, align 8
  %slaveof3 = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 11
  %4 = load ptr, ptr %slaveof3, align 8
  %5 = load ptr, ptr %n.addr, align 8
  %call4 = call i32 @clusterNodeRemoveSlave(ptr noundef %4, ptr noundef %5)
  %6 = load ptr, ptr %n.addr, align 8
  %7 = load ptr, ptr @myself, align 8
  %cmp = icmp ne ptr %6, %7
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then2
  %8 = load ptr, ptr %n.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %flags, align 8
  %or = or i32 %9, 256
  store i32 %or, ptr %flags, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then2
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %10 = load ptr, ptr %n.addr, align 8
  %flags8 = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 3
  %11 = load i32, ptr %flags8, align 8
  %and = and i32 %11, -3
  store i32 %and, ptr %flags8, align 8
  %12 = load ptr, ptr %n.addr, align 8
  %flags9 = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 3
  %13 = load i32, ptr %flags9, align 8
  %or10 = or i32 %13, 1
  store i32 %or10, ptr %flags9, align 8
  %14 = load ptr, ptr %n.addr, align 8
  %slaveof11 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 11
  store ptr null, ptr %slaveof11, align 8
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %return

return:                                           ; preds = %if.end7, %if.then
  ret void
}

declare void @replicationUnsetMaster() #1

declare i64 @emptyData(i32 noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterDelSlot(i32 noundef %slot) #0 {
entry:
  %retval = alloca i32, align 4
  %slot.addr = alloca i32, align 4
  %n = alloca ptr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 9
  %1 = load i32, ptr %slot.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  store ptr %2, ptr %n, align 8
  %3 = load ptr, ptr %n, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr %slot.addr, align 4
  call void @removeChannelsInSlot(i32 noundef %4)
  %5 = load ptr, ptr %n, align 8
  %6 = load i32, ptr %slot.addr, align 4
  %call = call i32 @clusterNodeClearSlotBit(ptr noundef %5, i32 noundef %6)
  %cmp = icmp eq i32 %call, 1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  call void @_serverAssert(ptr noundef @.str.138, ptr noundef @.str.18, i32 noundef 4866)
  call void @abort() #13
  unreachable

7:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %7, %cond.true
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots3 = getelementptr inbounds %struct.clusterState, ptr %8, i32 0, i32 9
  %9 = load i32, ptr %slot.addr, align 4
  %idxprom4 = sext i32 %9 to i64
  %arrayidx5 = getelementptr inbounds [16384 x ptr], ptr %slots3, i64 0, i64 %idxprom4
  store ptr null, ptr %arrayidx5, align 8
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %10, i32 0, i32 27
  %arraydecay = getelementptr inbounds [2048 x i8], ptr %owner_not_claiming_slot, i64 0, i64 0
  %11 = load i32, ptr %slot.addr, align 4
  call void @bitmapClearBit(ptr noundef %arraydecay, i32 noundef %11)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

declare void @dictEmpty(ptr noundef, ptr noundef) #1

declare ptr @dictGetSafeIterator(ptr noundef) #1

declare ptr @dictNext(ptr noundef) #1

declare ptr @dictGetVal(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterDelNode(ptr noundef %delnode) #0 {
entry:
  %delnode.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %node = alloca ptr, align 8
  store ptr %delnode, ptr %delnode.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %0, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 8
  %2 = load i32, ptr %j, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  %4 = load ptr, ptr %delnode.addr, align 8
  %cmp1 = icmp eq ptr %3, %4
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from2 = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 8
  %6 = load i32, ptr %j, align 4
  %idxprom3 = sext i32 %6 to i64
  %arrayidx4 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from2, i64 0, i64 %idxprom3
  store ptr null, ptr %arrayidx4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 7
  %8 = load i32, ptr %j, align 4
  %idxprom5 = sext i32 %8 to i64
  %arrayidx6 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to, i64 0, i64 %idxprom5
  %9 = load ptr, ptr %arrayidx6, align 8
  %10 = load ptr, ptr %delnode.addr, align 8
  %cmp7 = icmp eq ptr %9, %10
  br i1 %cmp7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to9 = getelementptr inbounds %struct.clusterState, ptr %11, i32 0, i32 7
  %12 = load i32, ptr %j, align 4
  %idxprom10 = sext i32 %12 to i64
  %arrayidx11 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to9, i64 0, i64 %idxprom10
  store ptr null, ptr %arrayidx11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then8, %if.end
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %13, i32 0, i32 9
  %14 = load i32, ptr %j, align 4
  %idxprom13 = sext i32 %14 to i64
  %arrayidx14 = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom13
  %15 = load ptr, ptr %arrayidx14, align 8
  %16 = load ptr, ptr %delnode.addr, align 8
  %cmp15 = icmp eq ptr %15, %16
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end12
  %17 = load i32, ptr %j, align 4
  %call = call i32 @clusterDelSlot(i32 noundef %17)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end12
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %18 = load i32, ptr %j, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %19, i32 0, i32 4
  %20 = load ptr, ptr %nodes, align 8
  %call18 = call ptr @dictGetSafeIterator(ptr noundef %20)
  store ptr %call18, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end24, %if.then23, %for.end
  %21 = load ptr, ptr %di, align 8
  %call19 = call ptr @dictNext(ptr noundef %21)
  store ptr %call19, ptr %de, align 8
  %cmp20 = icmp ne ptr %call19, null
  br i1 %cmp20, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %22 = load ptr, ptr %de, align 8
  %call21 = call ptr @dictGetVal(ptr noundef %22)
  store ptr %call21, ptr %node, align 8
  %23 = load ptr, ptr %node, align 8
  %24 = load ptr, ptr %delnode.addr, align 8
  %cmp22 = icmp eq ptr %23, %24
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %while.body
  br label %while.cond, !llvm.loop !24

if.end24:                                         ; preds = %while.body
  %25 = load ptr, ptr %node, align 8
  %26 = load ptr, ptr %delnode.addr, align 8
  %call25 = call i32 @clusterNodeDelFailureReport(ptr noundef %25, ptr noundef %26)
  br label %while.cond, !llvm.loop !24

while.end:                                        ; preds = %while.cond
  %27 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %27)
  %28 = load ptr, ptr %delnode.addr, align 8
  call void @clusterRemoveNodeFromShard(ptr noundef %28)
  %29 = load ptr, ptr %delnode.addr, align 8
  call void @freeClusterNode(ptr noundef %29)
  ret void
}

declare void @dictReleaseIterator(ptr noundef) #1

declare ptr @sdsnewlen(ptr noundef, i64 noundef) #1

declare i32 @dictDelete(ptr noundef, ptr noundef) #1

declare void @getRandomHexChars(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @createClusterLink(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %link = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 80) #16
  store ptr %call, ptr %link, align 8
  %call1 = call i64 @mstime()
  %0 = load ptr, ptr %link, align 8
  %ctime = getelementptr inbounds %struct.clusterLink, ptr %0, i32 0, i32 0
  store i64 %call1, ptr %ctime, align 8
  %call2 = call ptr @listCreate()
  %1 = load ptr, ptr %link, align 8
  %send_msg_queue = getelementptr inbounds %struct.clusterLink, ptr %1, i32 0, i32 2
  store ptr %call2, ptr %send_msg_queue, align 8
  %2 = load ptr, ptr %link, align 8
  %send_msg_queue3 = getelementptr inbounds %struct.clusterLink, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %send_msg_queue3, align 8
  %free = getelementptr inbounds %struct.list, ptr %3, i32 0, i32 3
  store ptr @clusterMsgSendBlockDecrRefCount, ptr %free, align 8
  %4 = load ptr, ptr %link, align 8
  %head_msg_send_offset = getelementptr inbounds %struct.clusterLink, ptr %4, i32 0, i32 3
  store i64 0, ptr %head_msg_send_offset, align 8
  %5 = load ptr, ptr %link, align 8
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %5, i32 0, i32 4
  store i64 48, ptr %send_msg_queue_mem, align 8
  %6 = load ptr, ptr %link, align 8
  %rcvbuf_alloc = getelementptr inbounds %struct.clusterLink, ptr %6, i32 0, i32 7
  store i64 1024, ptr %rcvbuf_alloc, align 8
  %call4 = call noalias ptr @zmalloc(i64 noundef 1024) #16
  %7 = load ptr, ptr %link, align 8
  %rcvbuf = getelementptr inbounds %struct.clusterLink, ptr %7, i32 0, i32 5
  store ptr %call4, ptr %rcvbuf, align 8
  %8 = load ptr, ptr %link, align 8
  %rcvbuf_len = getelementptr inbounds %struct.clusterLink, ptr %8, i32 0, i32 6
  store i64 0, ptr %rcvbuf_len, align 8
  %9 = load ptr, ptr %link, align 8
  %rcvbuf_alloc5 = getelementptr inbounds %struct.clusterLink, ptr %9, i32 0, i32 7
  %10 = load i64, ptr %rcvbuf_alloc5, align 8
  %11 = load ptr, ptr %link, align 8
  %send_msg_queue_mem6 = getelementptr inbounds %struct.clusterLink, ptr %11, i32 0, i32 4
  %12 = load i64, ptr %send_msg_queue_mem6, align 8
  %add = add i64 %10, %12
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %add7 = add i64 %13, %add
  store i64 %add7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %14 = load ptr, ptr %link, align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %14, i32 0, i32 1
  store ptr null, ptr %conn, align 8
  %15 = load ptr, ptr %node.addr, align 8
  %16 = load ptr, ptr %link, align 8
  %node8 = getelementptr inbounds %struct.clusterLink, ptr %16, i32 0, i32 8
  store ptr %15, ptr %node8, align 8
  %17 = load ptr, ptr %node.addr, align 8
  %cmp = icmp eq ptr %17, null
  %conv = zext i1 %cmp to i32
  %18 = load ptr, ptr %link, align 8
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %18, i32 0, i32 9
  store i32 %conv, ptr %inbound, align 8
  %19 = load ptr, ptr %link, align 8
  %inbound9 = getelementptr inbounds %struct.clusterLink, ptr %19, i32 0, i32 9
  %20 = load i32, ptr %inbound9, align 8
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %21 = load ptr, ptr %link, align 8
  %22 = load ptr, ptr %node.addr, align 8
  %link10 = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 27
  store ptr %21, ptr %link10, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %23 = load ptr, ptr %link, align 8
  ret ptr %23
}

declare ptr @listCreate() #1

; Function Attrs: nounwind uwtable
define internal void @clusterMsgSendBlockDecrRefCount(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %msgblock = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  store ptr %0, ptr %msgblock, align 8
  %1 = load ptr, ptr %msgblock, align 8
  %refcount = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %refcount, align 8
  %dec = add nsw i32 %2, -1
  store i32 %dec, ptr %refcount, align 8
  %3 = load ptr, ptr %msgblock, align 8
  %refcount1 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %refcount1, align 8
  %cmp = icmp sge i32 %4, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.306, ptr noundef @.str.18, i32 noundef 1153)
  call void @abort() #13
  unreachable

5:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %5, %cond.true
  %6 = load ptr, ptr %msgblock, align 8
  %refcount3 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %refcount3, align 8
  %cmp4 = icmp eq i32 %7, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %8 = load ptr, ptr %msgblock, align 8
  %totlen = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %8, i32 0, i32 0
  %9 = load i64, ptr %totlen, align 8
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %sub = sub i64 %10, %9
  store i64 %sub, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %11 = load ptr, ptr %msgblock, align 8
  call void @zfree(ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @freeClusterLink(ptr noundef %link) #0 {
entry:
  %link.addr = alloca ptr, align 8
  store ptr %link, ptr %link.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %conn, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %link.addr, align 8
  %conn1 = getelementptr inbounds %struct.clusterLink, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %conn1, align 8
  call void @connClose(ptr noundef %3)
  %4 = load ptr, ptr %link.addr, align 8
  %conn2 = getelementptr inbounds %struct.clusterLink, ptr %4, i32 0, i32 1
  store ptr null, ptr %conn2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %link.addr, align 8
  %send_msg_queue = getelementptr inbounds %struct.clusterLink, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %send_msg_queue, align 8
  %len = getelementptr inbounds %struct.list, ptr %6, i32 0, i32 5
  %7 = load i64, ptr %len, align 8
  %mul = mul i64 %7, 24
  %add = add i64 48, %mul
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %sub = sub i64 %8, %add
  store i64 %sub, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %9 = load ptr, ptr %link.addr, align 8
  %send_msg_queue3 = getelementptr inbounds %struct.clusterLink, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %send_msg_queue3, align 8
  call void @listRelease(ptr noundef %10)
  %11 = load ptr, ptr %link.addr, align 8
  %rcvbuf_alloc = getelementptr inbounds %struct.clusterLink, ptr %11, i32 0, i32 7
  %12 = load i64, ptr %rcvbuf_alloc, align 8
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %sub4 = sub i64 %13, %12
  store i64 %sub4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %14 = load ptr, ptr %link.addr, align 8
  %rcvbuf = getelementptr inbounds %struct.clusterLink, ptr %14, i32 0, i32 5
  %15 = load ptr, ptr %rcvbuf, align 8
  call void @zfree(ptr noundef %15)
  %16 = load ptr, ptr %link.addr, align 8
  %node = getelementptr inbounds %struct.clusterLink, ptr %16, i32 0, i32 8
  %17 = load ptr, ptr %node, align 8
  %tobool5 = icmp ne ptr %17, null
  br i1 %tobool5, label %if.then6, label %if.end35

if.then6:                                         ; preds = %if.end
  %18 = load ptr, ptr %link.addr, align 8
  %node7 = getelementptr inbounds %struct.clusterLink, ptr %18, i32 0, i32 8
  %19 = load ptr, ptr %node7, align 8
  %link8 = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 27
  %20 = load ptr, ptr %link8, align 8
  %21 = load ptr, ptr %link.addr, align 8
  %cmp = icmp eq ptr %20, %21
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then6
  %22 = load ptr, ptr %link.addr, align 8
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %22, i32 0, i32 9
  %23 = load i32, ptr %inbound, align 8
  %tobool10 = icmp ne i32 %23, 0
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot12 = xor i1 %lnot11, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool13 = icmp ne i64 %conv, 0
  br i1 %tobool13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then9
  br label %cond.end

cond.false:                                       ; preds = %if.then9
  call void @_serverAssert(ptr noundef @.str.50, ptr noundef @.str.18, i32 noundef 1194)
  call void @abort() #13
  unreachable

24:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %24, %cond.true
  %25 = load ptr, ptr %link.addr, align 8
  %node14 = getelementptr inbounds %struct.clusterLink, ptr %25, i32 0, i32 8
  %26 = load ptr, ptr %node14, align 8
  %link15 = getelementptr inbounds %struct._clusterNode, ptr %26, i32 0, i32 27
  store ptr null, ptr %link15, align 8
  br label %if.end34

if.else:                                          ; preds = %if.then6
  %27 = load ptr, ptr %link.addr, align 8
  %node16 = getelementptr inbounds %struct.clusterLink, ptr %27, i32 0, i32 8
  %28 = load ptr, ptr %node16, align 8
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %28, i32 0, i32 28
  %29 = load ptr, ptr %inbound_link, align 8
  %30 = load ptr, ptr %link.addr, align 8
  %cmp17 = icmp eq ptr %29, %30
  br i1 %cmp17, label %if.then19, label %if.end33

if.then19:                                        ; preds = %if.else
  %31 = load ptr, ptr %link.addr, align 8
  %inbound20 = getelementptr inbounds %struct.clusterLink, ptr %31, i32 0, i32 9
  %32 = load i32, ptr %inbound20, align 8
  %tobool21 = icmp ne i32 %32, 0
  %lnot22 = xor i1 %tobool21, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %conv26 = sext i32 %lnot.ext25 to i64
  %tobool27 = icmp ne i64 %conv26, 0
  br i1 %tobool27, label %cond.true28, label %cond.false29

cond.true28:                                      ; preds = %if.then19
  br label %cond.end30

cond.false29:                                     ; preds = %if.then19
  call void @_serverAssert(ptr noundef @.str.51, ptr noundef @.str.18, i32 noundef 1197)
  call void @abort() #13
  unreachable

33:                                               ; No predecessors!
  br label %cond.end30

cond.end30:                                       ; preds = %33, %cond.true28
  %34 = load ptr, ptr %link.addr, align 8
  %node31 = getelementptr inbounds %struct.clusterLink, ptr %34, i32 0, i32 8
  %35 = load ptr, ptr %node31, align 8
  %inbound_link32 = getelementptr inbounds %struct._clusterNode, ptr %35, i32 0, i32 28
  store ptr null, ptr %inbound_link32, align 8
  br label %if.end33

if.end33:                                         ; preds = %cond.end30, %if.else
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %cond.end
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end
  %36 = load ptr, ptr %link.addr, align 8
  call void @zfree(ptr noundef %36)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @connClose(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %close = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 12
  %2 = load ptr, ptr %close, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  call void %2(ptr noundef %3)
  ret void
}

declare void @listRelease(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @setClusterNodeToInboundClusterLink(ptr noundef %node, ptr noundef %link) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %link.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %link, ptr %link.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  %node1 = getelementptr inbounds %struct.clusterLink, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %node1, align 8
  %tobool = icmp ne ptr %1, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool4 = icmp ne i64 %conv, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.52, ptr noundef @.str.18, i32 noundef 1205)
  call void @abort() #13
  unreachable

2:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %2, %cond.true
  %3 = load ptr, ptr %link.addr, align 8
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %3, i32 0, i32 9
  %4 = load i32, ptr %inbound, align 8
  %tobool5 = icmp ne i32 %4, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %tobool11 = icmp ne i64 %conv10, 0
  br i1 %tobool11, label %cond.true12, label %cond.false13

cond.true12:                                      ; preds = %cond.end
  br label %cond.end14

cond.false13:                                     ; preds = %cond.end
  call void @_serverAssert(ptr noundef @.str.51, ptr noundef @.str.18, i32 noundef 1206)
  call void @abort() #13
  unreachable

5:                                                ; No predecessors!
  br label %cond.end14

cond.end14:                                       ; preds = %5, %cond.true12
  %6 = load ptr, ptr %node.addr, align 8
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 28
  %7 = load ptr, ptr %inbound_link, align 8
  %tobool15 = icmp ne ptr %7, null
  br i1 %tobool15, label %if.then, label %if.end22

if.then:                                          ; preds = %cond.end14
  br label %do.body

do.body:                                          ; preds = %if.then
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 0, %8
  br i1 %cmp, label %if.then17, label %if.end

if.then17:                                        ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %9 = load ptr, ptr %node.addr, align 8
  %inbound_link18 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 28
  %10 = load ptr, ptr %inbound_link18, align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %conn, align 8
  %fd = getelementptr inbounds %struct.connection, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %fd, align 8
  %13 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %14 = load ptr, ptr %link.addr, align 8
  %conn19 = getelementptr inbounds %struct.clusterLink, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %conn19, align 8
  %fd20 = getelementptr inbounds %struct.connection, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %fd20, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.53, i32 noundef %12, ptr noundef %arraydecay, i32 noundef %16)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then17
  %17 = load ptr, ptr %node.addr, align 8
  %inbound_link21 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 28
  %18 = load ptr, ptr %inbound_link21, align 8
  call void @freeClusterLink(ptr noundef %18)
  br label %if.end22

if.end22:                                         ; preds = %do.end, %cond.end14
  %19 = load ptr, ptr %node.addr, align 8
  %inbound_link23 = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 28
  %20 = load ptr, ptr %inbound_link23, align 8
  %tobool24 = icmp ne ptr %20, null
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %tobool32 = icmp ne i64 %conv31, 0
  br i1 %tobool32, label %cond.true33, label %cond.false34

cond.true33:                                      ; preds = %if.end22
  br label %cond.end35

cond.false34:                                     ; preds = %if.end22
  call void @_serverAssert(ptr noundef @.str.54, ptr noundef @.str.18, i32 noundef 1219)
  call void @abort() #13
  unreachable

21:                                               ; No predecessors!
  br label %cond.end35

cond.end35:                                       ; preds = %21, %cond.true33
  %22 = load ptr, ptr %link.addr, align 8
  %23 = load ptr, ptr %node.addr, align 8
  %inbound_link36 = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 28
  store ptr %22, ptr %inbound_link36, align 8
  %24 = load ptr, ptr %node.addr, align 8
  %25 = load ptr, ptr %link.addr, align 8
  %node37 = getelementptr inbounds %struct.clusterLink, ptr %25, i32 0, i32 8
  store ptr %24, ptr %node37, align 8
  ret void
}

declare i32 @anetTcpAccept(ptr noundef, i32 noundef, ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @connCreateAccepted(ptr noundef %ct, i32 noundef %fd, ptr noundef %priv) #0 {
entry:
  %ct.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %priv.addr = alloca ptr, align 8
  store ptr %ct, ptr %ct.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %priv, ptr %priv.addr, align 8
  %0 = load ptr, ptr %ct.addr, align 8
  %conn_create_accepted = getelementptr inbounds %struct.ConnectionType, ptr %0, i32 0, i32 10
  %1 = load ptr, ptr %conn_create_accepted, align 8
  %2 = load i32, ptr %fd.addr, align 4
  %3 = load ptr, ptr %priv.addr, align 8
  %call = call ptr %1(i32 noundef %2, ptr noundef %3)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal i32 @connGetState(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %state = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %state, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define internal ptr @connGetLastError(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %get_last_error = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 21
  %2 = load ptr, ptr %get_last_error, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %call = call ptr %2(ptr noundef %3)
  ret ptr %call
}

declare i32 @connEnableTcpNoDelay(ptr noundef) #1

declare i32 @connKeepAlive(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @connAccept(ptr noundef %conn, ptr noundef %accept_handler) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %accept_handler.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %accept_handler, ptr %accept_handler.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %accept = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 15
  %2 = load ptr, ptr %accept, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %4 = load ptr, ptr %accept_handler.addr, align 8
  %call = call i32 %2(ptr noundef %3, ptr noundef %4)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @clusterConnAcceptHandler(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %link = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %call = call i32 @connGetState(ptr noundef %0)
  %cmp = icmp ne i32 %call, 3
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 1, %1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %conn.addr, align 8
  %call3 = call ptr @connGetLastError(ptr noundef %2)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.58, ptr noundef %call3)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  %3 = load ptr, ptr %conn.addr, align 8
  call void @connClose(ptr noundef %3)
  br label %return

if.end4:                                          ; preds = %entry
  %call5 = call ptr @createClusterLink(ptr noundef null)
  store ptr %call5, ptr %link, align 8
  %4 = load ptr, ptr %conn.addr, align 8
  %5 = load ptr, ptr %link, align 8
  %conn6 = getelementptr inbounds %struct.clusterLink, ptr %5, i32 0, i32 1
  store ptr %4, ptr %conn6, align 8
  %6 = load ptr, ptr %conn.addr, align 8
  %7 = load ptr, ptr %link, align 8
  call void @connSetPrivateData(ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %conn.addr, align 8
  %call7 = call i32 @connSetReadHandler(ptr noundef %8, ptr noundef @clusterReadHandler)
  br label %return

return:                                           ; preds = %if.end4, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @getClusterConnectionsCount() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %2, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes1 = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %nodes1, align 8
  %ht_used2 = getelementptr inbounds %struct.dict, ptr %5, i32 0, i32 2
  %arrayidx3 = getelementptr inbounds [2 x i64], ptr %ht_used2, i64 0, i64 1
  %6 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %3, %6
  %sub = sub i64 %add, 1
  %mul = mul i64 %sub, 2
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 0, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeAddFailureReport(ptr noundef %failing, ptr noundef %sender) #0 {
entry:
  %retval = alloca i32, align 4
  %failing.addr = alloca ptr, align 8
  %sender.addr = alloca ptr, align 8
  %l = alloca ptr, align 8
  %ln = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %fr = alloca ptr, align 8
  store ptr %failing, ptr %failing.addr, align 8
  store ptr %sender, ptr %sender.addr, align 8
  %0 = load ptr, ptr %failing.addr, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 29
  %1 = load ptr, ptr %fail_reports, align 8
  store ptr %1, ptr %l, align 8
  %2 = load ptr, ptr %l, align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %fr, align 8
  %5 = load ptr, ptr %fr, align 8
  %node = getelementptr inbounds %struct.clusterNodeFailReport, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %node, align 8
  %7 = load ptr, ptr %sender.addr, align 8
  %cmp1 = icmp eq ptr %6, %7
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %call2 = call i64 @mstime()
  %8 = load ptr, ptr %fr, align 8
  %time = getelementptr inbounds %struct.clusterNodeFailReport, ptr %8, i32 0, i32 1
  store i64 %call2, ptr %time, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %while.body
  br label %while.cond, !llvm.loop !25

while.end:                                        ; preds = %while.cond
  %call3 = call noalias ptr @zmalloc(i64 noundef 16) #16
  store ptr %call3, ptr %fr, align 8
  %9 = load ptr, ptr %sender.addr, align 8
  %10 = load ptr, ptr %fr, align 8
  %node4 = getelementptr inbounds %struct.clusterNodeFailReport, ptr %10, i32 0, i32 0
  store ptr %9, ptr %node4, align 8
  %call5 = call i64 @mstime()
  %11 = load ptr, ptr %fr, align 8
  %time6 = getelementptr inbounds %struct.clusterNodeFailReport, ptr %11, i32 0, i32 1
  store i64 %call5, ptr %time6, align 8
  %12 = load ptr, ptr %l, align 8
  %13 = load ptr, ptr %fr, align 8
  %call7 = call ptr @listAddNodeTail(ptr noundef %12, ptr noundef %13)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

declare void @listRewind(ptr noundef, ptr noundef) #1

declare ptr @listNext(ptr noundef) #1

declare ptr @listAddNodeTail(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterNodeCleanupFailureReports(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %l = alloca ptr, align 8
  %ln = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %fr = alloca ptr, align 8
  %maxtime = alloca i64, align 8
  %now = alloca i64, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 29
  %1 = load ptr, ptr %fail_reports, align 8
  store ptr %1, ptr %l, align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %mul = mul nsw i64 %2, 2
  store i64 %mul, ptr %maxtime, align 8
  %call = call i64 @mstime()
  store i64 %call, ptr %now, align 8
  %3 = load ptr, ptr %l, align 8
  call void @listRewind(ptr noundef %3, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call1 = call ptr @listNext(ptr noundef %li)
  store ptr %call1, ptr %ln, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %value, align 8
  store ptr %5, ptr %fr, align 8
  %6 = load i64, ptr %now, align 8
  %7 = load ptr, ptr %fr, align 8
  %time = getelementptr inbounds %struct.clusterNodeFailReport, ptr %7, i32 0, i32 1
  %8 = load i64, ptr %time, align 8
  %sub = sub nsw i64 %6, %8
  %9 = load i64, ptr %maxtime, align 8
  %cmp2 = icmp sgt i64 %sub, %9
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %10 = load ptr, ptr %l, align 8
  %11 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %10, ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !26

while.end:                                        ; preds = %while.cond
  ret void
}

declare void @listDelNode(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeDelFailureReport(ptr noundef %node, ptr noundef %sender) #0 {
entry:
  %retval = alloca i32, align 4
  %node.addr = alloca ptr, align 8
  %sender.addr = alloca ptr, align 8
  %l = alloca ptr, align 8
  %ln = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %fr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %sender, ptr %sender.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 29
  %1 = load ptr, ptr %fail_reports, align 8
  store ptr %1, ptr %l, align 8
  %2 = load ptr, ptr %l, align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %fr, align 8
  %5 = load ptr, ptr %fr, align 8
  %node1 = getelementptr inbounds %struct.clusterNodeFailReport, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %node1, align 8
  %7 = load ptr, ptr %sender.addr, align 8
  %cmp2 = icmp eq ptr %6, %7
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  br label %while.cond, !llvm.loop !27

while.end:                                        ; preds = %if.then, %while.cond
  %8 = load ptr, ptr %ln, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %while.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %while.end
  %9 = load ptr, ptr %l, align 8
  %10 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %node.addr, align 8
  call void @clusterNodeCleanupFailureReports(ptr noundef %11)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeFailureReportsCount(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  call void @clusterNodeCleanupFailureReports(ptr noundef %0)
  %1 = load ptr, ptr %node.addr, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %fail_reports, align 8
  %len = getelementptr inbounds %struct.list, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %len, align 8
  %conv = trunc i64 %3 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeRemoveSlave(ptr noundef %master, ptr noundef %slave) #0 {
entry:
  %retval = alloca i32, align 4
  %master.addr = alloca ptr, align 8
  %slave.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %remaining_slaves = alloca i32, align 4
  store ptr %master, ptr %master.addr, align 8
  store ptr %slave, ptr %slave.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %1 = load ptr, ptr %master.addr, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 9
  %2 = load i32, ptr %numslaves, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %master.addr, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 10
  %4 = load ptr, ptr %slaves, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %7 = load ptr, ptr %slave.addr, align 8
  %cmp1 = icmp eq ptr %6, %7
  br i1 %cmp1, label %if.then, label %if.end18

if.then:                                          ; preds = %for.body
  %8 = load i32, ptr %j, align 4
  %add = add nsw i32 %8, 1
  %9 = load ptr, ptr %master.addr, align 8
  %numslaves2 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 9
  %10 = load i32, ptr %numslaves2, align 8
  %cmp3 = icmp slt i32 %add, %10
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %11 = load ptr, ptr %master.addr, align 8
  %numslaves5 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 9
  %12 = load i32, ptr %numslaves5, align 8
  %13 = load i32, ptr %j, align 4
  %sub = sub nsw i32 %12, %13
  %sub6 = sub nsw i32 %sub, 1
  store i32 %sub6, ptr %remaining_slaves, align 4
  %14 = load ptr, ptr %master.addr, align 8
  %slaves7 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 10
  %15 = load ptr, ptr %slaves7, align 8
  %16 = load i32, ptr %j, align 4
  %idx.ext = sext i32 %16 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %15, i64 %idx.ext
  %17 = load ptr, ptr %master.addr, align 8
  %slaves8 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 10
  %18 = load ptr, ptr %slaves8, align 8
  %19 = load i32, ptr %j, align 4
  %add9 = add nsw i32 %19, 1
  %idx.ext10 = sext i32 %add9 to i64
  %add.ptr11 = getelementptr inbounds ptr, ptr %18, i64 %idx.ext10
  %20 = load i32, ptr %remaining_slaves, align 4
  %conv = sext i32 %20 to i64
  %mul = mul i64 8, %conv
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %add.ptr, ptr align 8 %add.ptr11, i64 %mul, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %21 = load ptr, ptr %master.addr, align 8
  %numslaves12 = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 9
  %22 = load i32, ptr %numslaves12, align 8
  %dec = add nsw i32 %22, -1
  store i32 %dec, ptr %numslaves12, align 8
  %23 = load ptr, ptr %master.addr, align 8
  %numslaves13 = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 9
  %24 = load i32, ptr %numslaves13, align 8
  %cmp14 = icmp eq i32 %24, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end
  %25 = load ptr, ptr %master.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %25, i32 0, i32 3
  %26 = load i32, ptr %flags, align 8
  %and = and i32 %26, -257
  store i32 %and, ptr %flags, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end18
  %27 = load i32, ptr %j, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !28

for.end:                                          ; preds = %for.cond
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end17
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #2

; Function Attrs: allocsize(1)
declare ptr @zrealloc(ptr noundef, i64 noundef) #10

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterCountNonFailingSlaves(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %okslaves = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 0, ptr %okslaves, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %1 = load ptr, ptr %n.addr, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 9
  %2 = load i32, ptr %numslaves, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %n.addr, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 10
  %4 = load ptr, ptr %slaves, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %flags, align 8
  %and = and i32 %7, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load i32, ptr %okslaves, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %okslaves, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, ptr %j, align 4
  %inc1 = add nsw i32 %9, 1
  store i32 %inc1, ptr %j, align 4
  br label %for.cond, !llvm.loop !29

for.end:                                          ; preds = %for.cond
  %10 = load i32, ptr %okslaves, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define dso_local void @freeClusterNode(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %nodename = alloca ptr, align 8
  %j = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %1 = load ptr, ptr %n.addr, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 9
  %2 = load i32, ptr %numslaves, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %n.addr, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 10
  %4 = load ptr, ptr %slaves, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 11
  store ptr null, ptr %slaveof, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %j, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !30

for.end:                                          ; preds = %for.cond
  %8 = load ptr, ptr %n.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %flags, align 8
  %and = and i32 %9, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.end
  %10 = load ptr, ptr %n.addr, align 8
  %slaveof1 = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 11
  %11 = load ptr, ptr %slaveof1, align 8
  %tobool2 = icmp ne ptr %11, null
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %12 = load ptr, ptr %n.addr, align 8
  %slaveof3 = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 11
  %13 = load ptr, ptr %slaveof3, align 8
  %14 = load ptr, ptr %n.addr, align 8
  %call = call i32 @clusterNodeRemoveSlave(ptr noundef %13, ptr noundef %14)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.end
  %15 = load ptr, ptr %n.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %call4 = call ptr @sdsnewlen(ptr noundef %arraydecay, i64 noundef 40)
  store ptr %call4, ptr %nodename, align 8
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %16, i32 0, i32 4
  %17 = load ptr, ptr %nodes, align 8
  %18 = load ptr, ptr %nodename, align 8
  %call5 = call i32 @dictDelete(ptr noundef %17, ptr noundef %18)
  %cmp6 = icmp eq i32 %call5, 0
  %lnot = xor i1 %cmp6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  call void @_serverAssert(ptr noundef @.str.59, ptr noundef @.str.18, i32 noundef 1511)
  call void @abort() #13
  unreachable

19:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %19, %cond.true
  %20 = load ptr, ptr %nodename, align 8
  call void @sdsfree(ptr noundef %20)
  %21 = load ptr, ptr %n.addr, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 22
  %22 = load ptr, ptr %hostname, align 8
  call void @sdsfree(ptr noundef %22)
  %23 = load ptr, ptr %n.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 23
  %24 = load ptr, ptr %human_nodename, align 8
  call void @sdsfree(ptr noundef %24)
  %25 = load ptr, ptr %n.addr, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %25, i32 0, i32 27
  %26 = load ptr, ptr %link, align 8
  %tobool9 = icmp ne ptr %26, null
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %cond.end
  %27 = load ptr, ptr %n.addr, align 8
  %link11 = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 27
  %28 = load ptr, ptr %link11, align 8
  call void @freeClusterLink(ptr noundef %28)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %cond.end
  %29 = load ptr, ptr %n.addr, align 8
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %29, i32 0, i32 28
  %30 = load ptr, ptr %inbound_link, align 8
  %tobool13 = icmp ne ptr %30, null
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %31 = load ptr, ptr %n.addr, align 8
  %inbound_link15 = getelementptr inbounds %struct._clusterNode, ptr %31, i32 0, i32 28
  %32 = load ptr, ptr %inbound_link15, align 8
  call void @freeClusterLink(ptr noundef %32)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %33 = load ptr, ptr %n.addr, align 8
  %fail_reports = getelementptr inbounds %struct._clusterNode, ptr %33, i32 0, i32 29
  %34 = load ptr, ptr %fail_reports, align 8
  call void @listRelease(ptr noundef %34)
  %35 = load ptr, ptr %n.addr, align 8
  %slaves17 = getelementptr inbounds %struct._clusterNode, ptr %35, i32 0, i32 10
  %36 = load ptr, ptr %slaves17, align 8
  call void @zfree(ptr noundef %36)
  %37 = load ptr, ptr %n.addr, align 8
  call void @zfree(ptr noundef %37)
  ret void
}

declare i32 @dictAdd(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterRemoveNodeFromShard(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %de = alloca ptr, align 8
  %l = alloca ptr, align 8
  %ln = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  %call = call ptr @sdsnewlen(ptr noundef %arraydecay, i64 noundef 40)
  store ptr %call, ptr %s, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 5
  %2 = load ptr, ptr %shards, align 8
  %3 = load ptr, ptr %s, align 8
  %call1 = call ptr @dictFind(ptr noundef %2, ptr noundef %3)
  store ptr %call1, ptr %de, align 8
  %4 = load ptr, ptr %de, align 8
  %cmp = icmp ne ptr %4, null
  br i1 %cmp, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %5)
  store ptr %call2, ptr %l, align 8
  %6 = load ptr, ptr %l, align 8
  %7 = load ptr, ptr %node.addr, align 8
  %call3 = call ptr @listSearchKey(ptr noundef %6, ptr noundef %7)
  store ptr %call3, ptr %ln, align 8
  %8 = load ptr, ptr %ln, align 8
  %cmp4 = icmp ne ptr %8, null
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %9 = load ptr, ptr %l, align 8
  %10 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %9, ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  %11 = load ptr, ptr %l, align 8
  %len = getelementptr inbounds %struct.list, ptr %11, i32 0, i32 5
  %12 = load i64, ptr %len, align 8
  %cmp6 = icmp eq i64 %12, 0
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards8 = getelementptr inbounds %struct.clusterState, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %shards8, align 8
  %15 = load ptr, ptr %s, align 8
  %call9 = call i32 @dictDelete(ptr noundef %14, ptr noundef %15)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %entry
  %16 = load ptr, ptr %s, align 8
  call void @sdsfree(ptr noundef %16)
  ret void
}

declare ptr @dictFind(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterRenameNode(ptr noundef %node, ptr noundef %newname) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %newname.addr = alloca ptr, align 8
  %retval = alloca i32, align 4
  %s = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %newname, ptr %newname.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %call = call ptr @sdsnewlen(ptr noundef %arraydecay, i64 noundef 40)
  store ptr %call, ptr %s, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %node.addr, align 8
  %name1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 1
  %arraydecay2 = getelementptr inbounds [40 x i8], ptr %name1, i64 0, i64 0
  %3 = load ptr, ptr %newname.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.61, ptr noundef %arraydecay2, ptr noundef %3)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %nodes, align 8
  %6 = load ptr, ptr %s, align 8
  %call3 = call i32 @dictDelete(ptr noundef %5, ptr noundef %6)
  store i32 %call3, ptr %retval, align 4
  %7 = load ptr, ptr %s, align 8
  call void @sdsfree(ptr noundef %7)
  %8 = load i32, ptr %retval, align 4
  %cmp4 = icmp eq i32 %8, 0
  %lnot = xor i1 %cmp4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  br label %cond.end

cond.false:                                       ; preds = %do.end
  call void @_serverAssert(ptr noundef @.str.60, ptr noundef @.str.18, i32 noundef 1612)
  call void @abort() #13
  unreachable

9:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %9, %cond.true
  %10 = load ptr, ptr %node.addr, align 8
  %name6 = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 1
  %arraydecay7 = getelementptr inbounds [40 x i8], ptr %name6, i64 0, i64 0
  %11 = load ptr, ptr %newname.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay7, ptr align 1 %11, i64 40, i1 false)
  %12 = load ptr, ptr %node.addr, align 8
  call void @clusterAddNode(ptr noundef %12)
  ret void
}

declare ptr @listSearchKey(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterBumpConfigEpochWithoutConsensus() #0 {
entry:
  %retval = alloca i32, align 4
  %maxEpoch = alloca i64, align 8
  %call = call i64 @clusterGetMaxEpoch()
  store i64 %call, ptr %maxEpoch, align 8
  %0 = load ptr, ptr @myself, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 4
  %1 = load i64, ptr %configEpoch, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr @myself, align 8
  %configEpoch1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 4
  %3 = load i64, ptr %configEpoch1, align 8
  %4 = load i64, ptr %maxEpoch, align 8
  %cmp2 = icmp ne i64 %3, %4
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %currentEpoch, align 8
  %inc = add i64 %6, 1
  store i64 %inc, ptr %currentEpoch, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch3 = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 1
  %8 = load i64, ptr %currentEpoch3, align 8
  %9 = load ptr, ptr @myself, align 8
  %configEpoch4 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 4
  store i64 %8, ptr %configEpoch4, align 8
  call void @clusterDoBeforeSleep(i32 noundef 12)
  br label %do.body

do.body:                                          ; preds = %if.then
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp5 = icmp slt i32 2, %10
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %11 = load ptr, ptr @myself, align 8
  %configEpoch7 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 4
  %12 = load i64, ptr %configEpoch7, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.63, i64 noundef %12)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then6
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %do.end
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterHandleConfigEpochCollision(ptr noundef %sender) #0 {
entry:
  %sender.addr = alloca ptr, align 8
  store ptr %sender, ptr %sender.addr, align 8
  %0 = load ptr, ptr %sender.addr, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 4
  %1 = load i64, ptr %configEpoch, align 8
  %2 = load ptr, ptr @myself, align 8
  %configEpoch1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 4
  %3 = load i64, ptr %configEpoch1, align 8
  %cmp = icmp ne i64 %1, %3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load ptr, ptr %sender.addr, align 8
  %call = call i32 @clusterNodeIsMaster(ptr noundef %4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.lhs.false2, label %if.then

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %5 = load ptr, ptr @myself, align 8
  %call3 = call i32 @clusterNodeIsMaster(ptr noundef %5)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  br label %do.end

if.end:                                           ; preds = %lor.lhs.false2
  %6 = load ptr, ptr %sender.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %7 = load ptr, ptr @myself, align 8
  %name5 = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 1
  %arraydecay6 = getelementptr inbounds [40 x i8], ptr %name5, i64 0, i64 0
  %call7 = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %arraydecay6, i64 noundef 40) #12
  %cmp8 = icmp sle i32 %call7, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  br label %do.end

if.end10:                                         ; preds = %if.end
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %8, i32 0, i32 1
  %9 = load i64, ptr %currentEpoch, align 8
  %inc = add i64 %9, 1
  store i64 %inc, ptr %currentEpoch, align 8
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch11 = getelementptr inbounds %struct.clusterState, ptr %10, i32 0, i32 1
  %11 = load i64, ptr %currentEpoch11, align 8
  %12 = load ptr, ptr @myself, align 8
  %configEpoch12 = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 4
  store i64 %11, ptr %configEpoch12, align 8
  call void @clusterSaveConfigOrDie(i32 noundef 1)
  br label %do.body

do.body:                                          ; preds = %if.end10
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp13 = icmp slt i32 1, %13
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %do.body
  br label %do.end

if.end15:                                         ; preds = %do.body
  %14 = load ptr, ptr %sender.addr, align 8
  %name16 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 1
  %arraydecay17 = getelementptr inbounds [40 x i8], ptr %name16, i64 0, i64 0
  %15 = load ptr, ptr %sender.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 23
  %16 = load ptr, ptr %human_nodename, align 8
  %17 = load ptr, ptr @myself, align 8
  %configEpoch18 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 4
  %18 = load i64, ptr %configEpoch18, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.64, ptr noundef %arraydecay17, ptr noundef %16, i64 noundef %18)
  br label %do.end

do.end:                                           ; preds = %if.end15, %if.then14, %if.then9, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeIsMaster(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 1
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterBlacklistCleanup() #0 {
entry:
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %expire = alloca i64, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %nodes_black_list, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %1)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %2)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %de, align 8
  %call2 = call i64 @dictGetUnsignedIntegerVal(ptr noundef %3)
  store i64 %call2, ptr %expire, align 8
  %4 = load i64, ptr %expire, align 8
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %cmp3 = icmp slt i64 %4, %atomic-load
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list4 = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %nodes_black_list4, align 8
  %7 = load ptr, ptr %de, align 8
  %call5 = call ptr @dictGetKey(ptr noundef %7)
  %call6 = call i32 @dictDelete(ptr noundef %6, ptr noundef %call5)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !31

while.end:                                        ; preds = %while.cond
  %8 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %8)
  ret void
}

declare i64 @dictGetUnsignedIntegerVal(ptr noundef) #1

declare ptr @dictGetKey(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterBlacklistAddNode(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %de = alloca ptr, align 8
  %id = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %call = call ptr @sdsnewlen(ptr noundef %arraydecay, i64 noundef 40)
  store ptr %call, ptr %id, align 8
  call void @clusterBlacklistCleanup()
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %nodes_black_list, align 8
  %3 = load ptr, ptr %id, align 8
  %call1 = call i32 @dictAdd(ptr noundef %2, ptr noundef %3, ptr noundef null)
  %cmp = icmp eq i32 %call1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %id, align 8
  %call2 = call ptr @sdsdup(ptr noundef %4)
  store ptr %call2, ptr %id, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list3 = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %nodes_black_list3, align 8
  %7 = load ptr, ptr %id, align 8
  %call4 = call ptr @dictFind(ptr noundef %6, ptr noundef %7)
  store ptr %call4, ptr %de, align 8
  %8 = load ptr, ptr %de, align 8
  %call5 = call i64 @time(ptr noundef null) #15
  %add = add nsw i64 %call5, 60
  call void @dictSetUnsignedIntegerVal(ptr noundef %8, i64 noundef %add)
  %9 = load ptr, ptr %id, align 8
  call void @sdsfree(ptr noundef %9)
  ret void
}

declare ptr @sdsdup(ptr noundef) #1

declare void @dictSetUnsignedIntegerVal(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind
declare i64 @time(ptr noundef) #6

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterBlacklistExists(ptr noundef %nodeid) #0 {
entry:
  %nodeid.addr = alloca ptr, align 8
  %id = alloca ptr, align 8
  %retval1 = alloca i32, align 4
  store ptr %nodeid, ptr %nodeid.addr, align 8
  %0 = load ptr, ptr %nodeid.addr, align 8
  %call = call ptr @sdsnewlen(ptr noundef %0, i64 noundef 40)
  store ptr %call, ptr %id, align 8
  call void @clusterBlacklistCleanup()
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %nodes_black_list, align 8
  %3 = load ptr, ptr %id, align 8
  %call2 = call ptr @dictFind(ptr noundef %2, ptr noundef %3)
  %cmp = icmp ne ptr %call2, null
  %conv = zext i1 %cmp to i32
  store i32 %conv, ptr %retval1, align 4
  %4 = load ptr, ptr %id, align 8
  call void @sdsfree(ptr noundef %4)
  %5 = load i32, ptr %retval1, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define dso_local void @markNodeAsFailingIfNeeded(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %failures = alloca i32, align 4
  %needed_quorum = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %size, align 4
  %div = sdiv i32 %1, 2
  %add = add nsw i32 %div, 1
  store i32 %add, ptr %needed_quorum, align 4
  %2 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 3
  %3 = load i32, ptr %flags, align 8
  %and = and i32 %3, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %node.addr, align 8
  %flags1 = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %flags1, align 8
  %and2 = and i32 %5, 8
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %return

if.end5:                                          ; preds = %if.end
  %6 = load ptr, ptr %node.addr, align 8
  %call = call i32 @clusterNodeFailureReportsCount(ptr noundef %6)
  store i32 %call, ptr %failures, align 4
  %7 = load ptr, ptr @myself, align 8
  %call6 = call i32 @clusterNodeIsMaster(ptr noundef %7)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %8 = load i32, ptr %failures, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %failures, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end5
  %9 = load i32, ptr %failures, align 4
  %10 = load i32, ptr %needed_quorum, align 4
  %cmp = icmp slt i32 %9, %10
  br i1 %cmp, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end9
  br label %return

if.end11:                                         ; preds = %if.end9
  br label %do.body

do.body:                                          ; preds = %if.end11
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp12 = icmp slt i32 2, %11
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %do.body
  br label %do.end

if.end14:                                         ; preds = %do.body
  %12 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %13 = load ptr, ptr %node.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 23
  %14 = load ptr, ptr %human_nodename, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.65, ptr noundef %arraydecay, ptr noundef %14)
  br label %do.end

do.end:                                           ; preds = %if.end14, %if.then13
  %15 = load ptr, ptr %node.addr, align 8
  %flags15 = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %flags15, align 8
  %and16 = and i32 %16, -5
  store i32 %and16, ptr %flags15, align 8
  %17 = load ptr, ptr %node.addr, align 8
  %flags17 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 3
  %18 = load i32, ptr %flags17, align 8
  %or = or i32 %18, 8
  store i32 %or, ptr %flags17, align 8
  %call18 = call i64 @mstime()
  %19 = load ptr, ptr %node.addr, align 8
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 16
  store i64 %call18, ptr %fail_time, align 8
  %20 = load ptr, ptr %node.addr, align 8
  %name19 = getelementptr inbounds %struct._clusterNode, ptr %20, i32 0, i32 1
  %arraydecay20 = getelementptr inbounds [40 x i8], ptr %name19, i64 0, i64 0
  call void @clusterSendFail(ptr noundef %arraydecay20)
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %return

return:                                           ; preds = %do.end, %if.then10, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendFail(ptr noundef %nodename) #0 {
entry:
  %nodename.addr = alloca ptr, align 8
  %msglen = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  store ptr %nodename, ptr %nodename.addr, align 8
  store i32 2296, ptr %msglen, align 4
  %0 = load i32, ptr %msglen, align 4
  %call = call ptr @createClusterMsgSendBlock(i32 noundef 3, i32 noundef %0)
  store ptr %call, ptr %msgblock, align 8
  %1 = load ptr, ptr %msgblock, align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %1, i32 0, i32 2
  store ptr %msg, ptr %hdr, align 8
  %2 = load ptr, ptr %hdr, align 8
  %data = getelementptr inbounds %struct.clusterMsg, ptr %2, i32 0, i32 20
  %about = getelementptr inbounds %struct.anon.1, ptr %data, i32 0, i32 0
  %nodename1 = getelementptr inbounds %struct.clusterMsgDataFail, ptr %about, i32 0, i32 0
  %arraydecay = getelementptr inbounds [40 x i8], ptr %nodename1, i64 0, i64 0
  %3 = load ptr, ptr %nodename.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %3, i64 40, i1 false)
  %4 = load ptr, ptr %msgblock, align 8
  call void @clusterBroadcastMessage(ptr noundef %4)
  %5 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %5)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clearNodeFailureIfNeeded(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %now = alloca i64, align 8
  store ptr %node, ptr %node.addr, align 8
  %call = call i64 @mstime()
  store i64 %call, ptr %now, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 8
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.66, ptr noundef @.str.18, i32 noundef 1915)
  call void @abort() #13
  unreachable

2:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %2, %cond.true
  %3 = load ptr, ptr %node.addr, align 8
  %flags3 = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %flags3, align 8
  %and4 = and i32 %4, 2
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %5 = load ptr, ptr %node.addr, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 8
  %6 = load i32, ptr %numslots, align 4
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %if.then, label %if.end15

if.then:                                          ; preds = %lor.lhs.false, %cond.end
  br label %do.body

do.body:                                          ; preds = %if.then
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp7 = icmp slt i32 2, %7
  br i1 %cmp7, label %if.then9, label %if.end

if.then9:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %8 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %9 = load ptr, ptr %node.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 23
  %10 = load ptr, ptr %human_nodename, align 8
  %11 = load ptr, ptr %node.addr, align 8
  %flags10 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %flags10, align 8
  %and11 = and i32 %12, 2
  %tobool12 = icmp ne i32 %and11, 0
  %cond = select i1 %tobool12, ptr @.str.68, ptr @.str.69
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.67, ptr noundef %arraydecay, ptr noundef %10, ptr noundef %cond)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then9
  %13 = load ptr, ptr %node.addr, align 8
  %flags13 = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 3
  %14 = load i32, ptr %flags13, align 8
  %and14 = and i32 %14, -9
  store i32 %and14, ptr %flags13, align 8
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end15

if.end15:                                         ; preds = %do.end, %lor.lhs.false
  %15 = load ptr, ptr %node.addr, align 8
  %call16 = call i32 @clusterNodeIsMaster(ptr noundef %15)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %if.end15
  %16 = load ptr, ptr %node.addr, align 8
  %numslots18 = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 8
  %17 = load i32, ptr %numslots18, align 4
  %cmp19 = icmp sgt i32 %17, 0
  br i1 %cmp19, label %land.lhs.true21, label %if.end36

land.lhs.true21:                                  ; preds = %land.lhs.true
  %18 = load i64, ptr %now, align 8
  %19 = load ptr, ptr %node.addr, align 8
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 16
  %20 = load i64, ptr %fail_time, align 8
  %sub = sub nsw i64 %18, %20
  %21 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %mul = mul nsw i64 %21, 2
  %cmp22 = icmp sgt i64 %sub, %mul
  br i1 %cmp22, label %if.then24, label %if.end36

if.then24:                                        ; preds = %land.lhs.true21
  br label %do.body25

do.body25:                                        ; preds = %if.then24
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp26 = icmp slt i32 2, %22
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %do.body25
  br label %do.end33

if.end29:                                         ; preds = %do.body25
  %23 = load ptr, ptr %node.addr, align 8
  %name30 = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 1
  %arraydecay31 = getelementptr inbounds [40 x i8], ptr %name30, i64 0, i64 0
  %24 = load ptr, ptr %node.addr, align 8
  %human_nodename32 = getelementptr inbounds %struct._clusterNode, ptr %24, i32 0, i32 23
  %25 = load ptr, ptr %human_nodename32, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.70, ptr noundef %arraydecay31, ptr noundef %25)
  br label %do.end33

do.end33:                                         ; preds = %if.end29, %if.then28
  %26 = load ptr, ptr %node.addr, align 8
  %flags34 = getelementptr inbounds %struct._clusterNode, ptr %26, i32 0, i32 3
  %27 = load i32, ptr %flags34, align 8
  %and35 = and i32 %27, -9
  store i32 %and35, ptr %flags34, align 8
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end36

if.end36:                                         ; preds = %do.end33, %land.lhs.true21, %land.lhs.true, %if.end15
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterHandshakeInProgress(ptr noundef %ip, i32 noundef %port, i32 noundef %cport) #0 {
entry:
  %ip.addr = alloca ptr, align 8
  %port.addr = alloca i32, align 4
  %cport.addr = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %node = alloca ptr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i32 %port, ptr %port.addr, align 4
  store i32 %cport, ptr %cport.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %1)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end12, %if.then, %entry
  %2 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %2)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %3)
  store ptr %call2, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %flags, align 8
  %and = and i32 %5, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !32

if.end:                                           ; preds = %while.body
  %6 = load ptr, ptr %node, align 8
  %ip3 = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 21
  %arraydecay = getelementptr inbounds [46 x i8], ptr %ip3, i64 0, i64 0
  %7 = load ptr, ptr %ip.addr, align 8
  %call4 = call i32 @strcasecmp(ptr noundef %arraydecay, ptr noundef %7) #12
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %8 = load ptr, ptr %node, align 8
  %call6 = call i32 @getNodeDefaultClientPort(ptr noundef %8)
  %9 = load i32, ptr %port.addr, align 4
  %cmp7 = icmp eq i32 %call6, %9
  br i1 %cmp7, label %land.lhs.true8, label %if.end12

land.lhs.true8:                                   ; preds = %land.lhs.true
  %10 = load ptr, ptr %node, align 8
  %cport9 = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 26
  %11 = load i32, ptr %cport9, align 8
  %12 = load i32, ptr %cport.addr, align 4
  %cmp10 = icmp eq i32 %11, %12
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true8
  br label %while.end

if.end12:                                         ; preds = %land.lhs.true8, %land.lhs.true, %if.end
  br label %while.cond, !llvm.loop !32

while.end:                                        ; preds = %if.then11, %while.cond
  %13 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %13)
  %14 = load ptr, ptr %de, align 8
  %cmp13 = icmp ne ptr %14, null
  %conv = zext i1 %cmp13 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterStartHandshake(ptr noundef %ip, i32 noundef %port, i32 noundef %cport) #0 {
entry:
  %retval = alloca i32, align 4
  %ip.addr = alloca ptr, align 8
  %port.addr = alloca i32, align 4
  %cport.addr = alloca i32, align 4
  %n = alloca ptr, align 8
  %norm_ip = alloca [46 x i8], align 16
  %sa = alloca %struct.sockaddr_storage, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i32 %port, ptr %port.addr, align 4
  store i32 %cport, ptr %cport.addr, align 4
  %0 = load ptr, ptr %ip.addr, align 8
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, ptr %sa, i32 0, i32 2
  %call = call i32 @inet_pton(i32 noundef 2, ptr noundef %0, ptr noundef %sin_addr) #15
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %ss_family = getelementptr inbounds %struct.sockaddr_storage, ptr %sa, i32 0, i32 0
  store i16 2, ptr %ss_family, align 8
  br label %if.end7

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %ip.addr, align 8
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, ptr %sa, i32 0, i32 3
  %call1 = call i32 @inet_pton(i32 noundef 10, ptr noundef %1, ptr noundef %sin6_addr) #15
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  %ss_family4 = getelementptr inbounds %struct.sockaddr_storage, ptr %sa, i32 0, i32 0
  store i16 10, ptr %ss_family4, align 8
  br label %if.end

if.else5:                                         ; preds = %if.else
  %call6 = call ptr @__errno_location() #14
  store i32 22, ptr %call6, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then3
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %2 = load i32, ptr %port.addr, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %3 = load i32, ptr %port.addr, align 4
  %cmp8 = icmp sgt i32 %3, 65535
  br i1 %cmp8, label %if.then13, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %4 = load i32, ptr %cport.addr, align 4
  %cmp10 = icmp sle i32 %4, 0
  br i1 %cmp10, label %if.then13, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false9
  %5 = load i32, ptr %cport.addr, align 4
  %cmp12 = icmp sgt i32 %5, 65535
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %lor.lhs.false11, %lor.lhs.false9, %lor.lhs.false, %if.end7
  %call14 = call ptr @__errno_location() #14
  store i32 22, ptr %call14, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %lor.lhs.false11
  %arraydecay = getelementptr inbounds [46 x i8], ptr %norm_ip, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay, i8 0, i64 46, i1 false)
  %ss_family16 = getelementptr inbounds %struct.sockaddr_storage, ptr %sa, i32 0, i32 0
  %6 = load i16, ptr %ss_family16, align 8
  %conv = zext i16 %6 to i32
  %cmp17 = icmp eq i32 %conv, 2
  br i1 %cmp17, label %if.then19, label %if.else23

if.then19:                                        ; preds = %if.end15
  %sin_addr20 = getelementptr inbounds %struct.sockaddr_in, ptr %sa, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [46 x i8], ptr %norm_ip, i64 0, i64 0
  %call22 = call ptr @inet_ntop(i32 noundef 2, ptr noundef %sin_addr20, ptr noundef %arraydecay21, i32 noundef 46) #15
  br label %if.end27

if.else23:                                        ; preds = %if.end15
  %sin6_addr24 = getelementptr inbounds %struct.sockaddr_in6, ptr %sa, i32 0, i32 3
  %arraydecay25 = getelementptr inbounds [46 x i8], ptr %norm_ip, i64 0, i64 0
  %call26 = call ptr @inet_ntop(i32 noundef 10, ptr noundef %sin6_addr24, ptr noundef %arraydecay25, i32 noundef 46) #15
  br label %if.end27

if.end27:                                         ; preds = %if.else23, %if.then19
  %arraydecay28 = getelementptr inbounds [46 x i8], ptr %norm_ip, i64 0, i64 0
  %7 = load i32, ptr %port.addr, align 4
  %8 = load i32, ptr %cport.addr, align 4
  %call29 = call i32 @clusterHandshakeInProgress(ptr noundef %arraydecay28, i32 noundef %7, i32 noundef %8)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end27
  %call32 = call ptr @__errno_location() #14
  store i32 11, ptr %call32, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end27
  %call34 = call ptr @createClusterNode(ptr noundef null, i32 noundef 160)
  store ptr %call34, ptr %n, align 8
  %9 = load ptr, ptr %n, align 8
  %ip35 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 21
  %arraydecay36 = getelementptr inbounds [46 x i8], ptr %ip35, i64 0, i64 0
  %arraydecay37 = getelementptr inbounds [46 x i8], ptr %norm_ip, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay36, ptr align 16 %arraydecay37, i64 46, i1 false)
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool38 = icmp ne i32 %10, 0
  br i1 %tobool38, label %if.then39, label %if.else40

if.then39:                                        ; preds = %if.end33
  %11 = load i32, ptr %port.addr, align 4
  %12 = load ptr, ptr %n, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 25
  store i32 %11, ptr %tls_port, align 4
  br label %if.end41

if.else40:                                        ; preds = %if.end33
  %13 = load i32, ptr %port.addr, align 4
  %14 = load ptr, ptr %n, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 24
  store i32 %13, ptr %tcp_port, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.else40, %if.then39
  %15 = load i32, ptr %cport.addr, align 4
  %16 = load ptr, ptr %n, align 8
  %cport42 = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 26
  store i32 %15, ptr %cport42, align 8
  %17 = load ptr, ptr %n, align 8
  call void @clusterAddNode(ptr noundef %17)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end41, %if.then31, %if.then13, %if.else5
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind
declare i32 @inet_pton(i32 noundef, ptr noundef, ptr noundef) #6

; Function Attrs: nounwind
declare ptr @inet_ntop(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #6

; Function Attrs: nounwind uwtable
define dso_local void @clusterProcessGossipSection(ptr noundef %hdr, ptr noundef %link) #0 {
entry:
  %hdr.addr = alloca ptr, align 8
  %link.addr = alloca ptr, align 8
  %count = alloca i16, align 2
  %g = alloca ptr, align 8
  %sender = alloca ptr, align 8
  %flags = alloca i16, align 2
  %node9 = alloca ptr, align 8
  %ci = alloca ptr, align 8
  %msg_tls_port = alloca i32, align 4
  %msg_tcp_port = alloca i32, align 4
  %pongtime = alloca i64, align 8
  %node172 = alloca ptr, align 8
  store ptr %hdr, ptr %hdr.addr, align 8
  store ptr %link, ptr %link.addr, align 8
  %0 = load ptr, ptr %hdr.addr, align 8
  %count1 = getelementptr inbounds %struct.clusterMsg, ptr %0, i32 0, i32 5
  %1 = load i16, ptr %count1, align 2
  %call = call zeroext i16 @ntohs(i16 noundef zeroext %1) #14
  store i16 %call, ptr %count, align 2
  %2 = load ptr, ptr %hdr.addr, align 8
  %data = getelementptr inbounds %struct.clusterMsg, ptr %2, i32 0, i32 20
  %gossip = getelementptr inbounds %struct.anon.0, ptr %data, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %gossip, i64 0, i64 0
  store ptr %arraydecay, ptr %g, align 8
  %3 = load ptr, ptr %link.addr, align 8
  %node = getelementptr inbounds %struct.clusterLink, ptr %3, i32 0, i32 8
  %4 = load ptr, ptr %node, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load ptr, ptr %link.addr, align 8
  %node2 = getelementptr inbounds %struct.clusterLink, ptr %5, i32 0, i32 8
  %6 = load ptr, ptr %node2, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load ptr, ptr %hdr.addr, align 8
  %sender3 = getelementptr inbounds %struct.clusterMsg, ptr %7, i32 0, i32 9
  %arraydecay4 = getelementptr inbounds [40 x i8], ptr %sender3, i64 0, i64 0
  %call5 = call ptr @clusterLookupNode(ptr noundef %arraydecay4, i32 noundef 40)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %6, %cond.true ], [ %call5, %cond.false ]
  store ptr %cond, ptr %sender, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end188, %cond.end
  %8 = load i16, ptr %count, align 2
  %dec = add i16 %8, -1
  store i16 %dec, ptr %count, align 2
  %tobool6 = icmp ne i16 %8, 0
  br i1 %tobool6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load ptr, ptr %g, align 8
  %flags7 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %9, i32 0, i32 6
  %10 = load i16, ptr %flags7, align 2
  %call8 = call zeroext i16 @ntohs(i16 noundef zeroext %10) #14
  store i16 %call8, ptr %flags, align 2
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp eq i32 %11, 0
  br i1 %cmp, label %if.then, label %if.end19

if.then:                                          ; preds = %while.body
  %call10 = call ptr @sdsempty()
  %12 = load i16, ptr %flags, align 2
  %call11 = call ptr @representClusterNodeFlags(ptr noundef %call10, i16 noundef zeroext %12)
  store ptr %call11, ptr %ci, align 8
  br label %do.body

do.body:                                          ; preds = %if.then
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp12 = icmp slt i32 0, %13
  br i1 %cmp12, label %if.then13, label %if.end

if.then13:                                        ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %14 = load ptr, ptr %g, align 8
  %nodename = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %14, i32 0, i32 0
  %arraydecay14 = getelementptr inbounds [40 x i8], ptr %nodename, i64 0, i64 0
  %15 = load ptr, ptr %g, align 8
  %ip = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %15, i32 0, i32 3
  %arraydecay15 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %16 = load ptr, ptr %g, align 8
  %port = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %16, i32 0, i32 4
  %17 = load i16, ptr %port, align 2
  %call16 = call zeroext i16 @ntohs(i16 noundef zeroext %17) #14
  %conv = zext i16 %call16 to i32
  %18 = load ptr, ptr %g, align 8
  %cport = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %18, i32 0, i32 5
  %19 = load i16, ptr %cport, align 4
  %call17 = call zeroext i16 @ntohs(i16 noundef zeroext %19) #14
  %conv18 = zext i16 %call17 to i32
  %20 = load ptr, ptr %ci, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.71, ptr noundef %arraydecay14, ptr noundef %arraydecay15, i32 noundef %conv, i32 noundef %conv18, ptr noundef %20)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then13
  %21 = load ptr, ptr %ci, align 8
  call void @sdsfree(ptr noundef %21)
  br label %if.end19

if.end19:                                         ; preds = %do.end, %while.body
  %22 = load ptr, ptr %g, align 8
  call void @getClientPortFromGossip(ptr noundef %22, ptr noundef %msg_tls_port, ptr noundef %msg_tcp_port)
  %23 = load ptr, ptr %g, align 8
  %nodename20 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %23, i32 0, i32 0
  %arraydecay21 = getelementptr inbounds [40 x i8], ptr %nodename20, i64 0, i64 0
  %call22 = call ptr @clusterLookupNode(ptr noundef %arraydecay21, i32 noundef 40)
  store ptr %call22, ptr %node9, align 8
  %24 = load ptr, ptr %node9, align 8
  %tobool23 = icmp ne ptr %24, null
  br i1 %tobool23, label %if.then24, label %if.else160

if.then24:                                        ; preds = %if.end19
  %25 = load ptr, ptr %sender, align 8
  %tobool25 = icmp ne ptr %25, null
  br i1 %tobool25, label %land.lhs.true, label %if.end66

land.lhs.true:                                    ; preds = %if.then24
  %26 = load ptr, ptr %sender, align 8
  %call26 = call i32 @clusterNodeIsMaster(ptr noundef %26)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %land.lhs.true28, label %if.end66

land.lhs.true28:                                  ; preds = %land.lhs.true
  %27 = load ptr, ptr %node9, align 8
  %28 = load ptr, ptr @myself, align 8
  %cmp29 = icmp ne ptr %27, %28
  br i1 %cmp29, label %if.then31, label %if.end66

if.then31:                                        ; preds = %land.lhs.true28
  %29 = load i16, ptr %flags, align 2
  %conv32 = zext i16 %29 to i32
  %and = and i32 %conv32, 12
  %tobool33 = icmp ne i32 %and, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.then31
  %30 = load ptr, ptr %node9, align 8
  %31 = load ptr, ptr %sender, align 8
  %call35 = call i32 @clusterNodeAddFailureReport(ptr noundef %30, ptr noundef %31)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.then37, label %if.end48

if.then37:                                        ; preds = %if.then34
  br label %do.body38

do.body38:                                        ; preds = %if.then37
  %32 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp39 = icmp slt i32 1, %32
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %do.body38
  br label %do.end47

if.end42:                                         ; preds = %do.body38
  %33 = load ptr, ptr %sender, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %33, i32 0, i32 1
  %arraydecay43 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %34 = load ptr, ptr %sender, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %34, i32 0, i32 23
  %35 = load ptr, ptr %human_nodename, align 8
  %36 = load ptr, ptr %node9, align 8
  %name44 = getelementptr inbounds %struct._clusterNode, ptr %36, i32 0, i32 1
  %arraydecay45 = getelementptr inbounds [40 x i8], ptr %name44, i64 0, i64 0
  %37 = load ptr, ptr %node9, align 8
  %human_nodename46 = getelementptr inbounds %struct._clusterNode, ptr %37, i32 0, i32 23
  %38 = load ptr, ptr %human_nodename46, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.72, ptr noundef %arraydecay43, ptr noundef %35, ptr noundef %arraydecay45, ptr noundef %38)
  br label %do.end47

do.end47:                                         ; preds = %if.end42, %if.then41
  br label %if.end48

if.end48:                                         ; preds = %do.end47, %if.then34
  %39 = load ptr, ptr %node9, align 8
  call void @markNodeAsFailingIfNeeded(ptr noundef %39)
  br label %if.end65

if.else:                                          ; preds = %if.then31
  %40 = load ptr, ptr %node9, align 8
  %41 = load ptr, ptr %sender, align 8
  %call49 = call i32 @clusterNodeDelFailureReport(ptr noundef %40, ptr noundef %41)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then51, label %if.end64

if.then51:                                        ; preds = %if.else
  br label %do.body52

do.body52:                                        ; preds = %if.then51
  %42 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp53 = icmp slt i32 1, %42
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %do.body52
  br label %do.end63

if.end56:                                         ; preds = %do.body52
  %43 = load ptr, ptr %sender, align 8
  %name57 = getelementptr inbounds %struct._clusterNode, ptr %43, i32 0, i32 1
  %arraydecay58 = getelementptr inbounds [40 x i8], ptr %name57, i64 0, i64 0
  %44 = load ptr, ptr %sender, align 8
  %human_nodename59 = getelementptr inbounds %struct._clusterNode, ptr %44, i32 0, i32 23
  %45 = load ptr, ptr %human_nodename59, align 8
  %46 = load ptr, ptr %node9, align 8
  %name60 = getelementptr inbounds %struct._clusterNode, ptr %46, i32 0, i32 1
  %arraydecay61 = getelementptr inbounds [40 x i8], ptr %name60, i64 0, i64 0
  %47 = load ptr, ptr %node9, align 8
  %human_nodename62 = getelementptr inbounds %struct._clusterNode, ptr %47, i32 0, i32 23
  %48 = load ptr, ptr %human_nodename62, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.73, ptr noundef %arraydecay58, ptr noundef %45, ptr noundef %arraydecay61, ptr noundef %48)
  br label %do.end63

do.end63:                                         ; preds = %if.end56, %if.then55
  br label %if.end64

if.end64:                                         ; preds = %do.end63, %if.else
  br label %if.end65

if.end65:                                         ; preds = %if.end64, %if.end48
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %land.lhs.true28, %land.lhs.true, %if.then24
  %49 = load i16, ptr %flags, align 2
  %conv67 = zext i16 %49 to i32
  %and68 = and i32 %conv67, 12
  %tobool69 = icmp ne i32 %and68, 0
  br i1 %tobool69, label %if.end89, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %if.end66
  %50 = load ptr, ptr %node9, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %50, i32 0, i32 13
  %51 = load i64, ptr %ping_sent, align 8
  %cmp71 = icmp eq i64 %51, 0
  br i1 %cmp71, label %land.lhs.true73, label %if.end89

land.lhs.true73:                                  ; preds = %land.lhs.true70
  %52 = load ptr, ptr %node9, align 8
  %call74 = call i32 @clusterNodeFailureReportsCount(ptr noundef %52)
  %cmp75 = icmp eq i32 %call74, 0
  br i1 %cmp75, label %if.then77, label %if.end89

if.then77:                                        ; preds = %land.lhs.true73
  %53 = load ptr, ptr %g, align 8
  %pong_received = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %53, i32 0, i32 2
  %54 = load i32, ptr %pong_received, align 4
  %call78 = call i32 @ntohl(i32 noundef %54) #14
  %conv79 = zext i32 %call78 to i64
  store i64 %conv79, ptr %pongtime, align 8
  %55 = load i64, ptr %pongtime, align 8
  %mul = mul nsw i64 %55, 1000
  store i64 %mul, ptr %pongtime, align 8
  %56 = load i64, ptr %pongtime, align 8
  %57 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  %add = add nsw i64 %57, 500
  %cmp80 = icmp sle i64 %56, %add
  br i1 %cmp80, label %land.lhs.true82, label %if.end88

land.lhs.true82:                                  ; preds = %if.then77
  %58 = load i64, ptr %pongtime, align 8
  %59 = load ptr, ptr %node9, align 8
  %pong_received83 = getelementptr inbounds %struct._clusterNode, ptr %59, i32 0, i32 14
  %60 = load i64, ptr %pong_received83, align 8
  %cmp84 = icmp sgt i64 %58, %60
  br i1 %cmp84, label %if.then86, label %if.end88

if.then86:                                        ; preds = %land.lhs.true82
  %61 = load i64, ptr %pongtime, align 8
  %62 = load ptr, ptr %node9, align 8
  %pong_received87 = getelementptr inbounds %struct._clusterNode, ptr %62, i32 0, i32 14
  store i64 %61, ptr %pong_received87, align 8
  br label %if.end88

if.end88:                                         ; preds = %if.then86, %land.lhs.true82, %if.then77
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %land.lhs.true73, %land.lhs.true70, %if.end66
  %63 = load ptr, ptr %node9, align 8
  %flags90 = getelementptr inbounds %struct._clusterNode, ptr %63, i32 0, i32 3
  %64 = load i32, ptr %flags90, align 8
  %and91 = and i32 %64, 12
  %tobool92 = icmp ne i32 %and91, 0
  br i1 %tobool92, label %land.lhs.true93, label %if.end159

land.lhs.true93:                                  ; preds = %if.end89
  %65 = load i16, ptr %flags, align 2
  %conv94 = zext i16 %65 to i32
  %and95 = and i32 %conv94, 64
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.end159, label %land.lhs.true97

land.lhs.true97:                                  ; preds = %land.lhs.true93
  %66 = load i16, ptr %flags, align 2
  %conv98 = zext i16 %66 to i32
  %and99 = and i32 %conv98, 12
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %if.end159, label %land.lhs.true101

land.lhs.true101:                                 ; preds = %land.lhs.true97
  %67 = load ptr, ptr %node9, align 8
  %ip102 = getelementptr inbounds %struct._clusterNode, ptr %67, i32 0, i32 21
  %arraydecay103 = getelementptr inbounds [46 x i8], ptr %ip102, i64 0, i64 0
  %68 = load ptr, ptr %g, align 8
  %ip104 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %68, i32 0, i32 3
  %arraydecay105 = getelementptr inbounds [46 x i8], ptr %ip104, i64 0, i64 0
  %call106 = call i32 @strcasecmp(ptr noundef %arraydecay103, ptr noundef %arraydecay105) #12
  %tobool107 = icmp ne i32 %call106, 0
  br i1 %tobool107, label %if.then141, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true101
  %69 = load ptr, ptr %node9, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %69, i32 0, i32 25
  %70 = load i32, ptr %tls_port, align 4
  %71 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool108 = icmp ne i32 %71, 0
  br i1 %tobool108, label %cond.true109, label %cond.false113

cond.true109:                                     ; preds = %lor.lhs.false
  %72 = load ptr, ptr %g, align 8
  %port110 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %72, i32 0, i32 4
  %73 = load i16, ptr %port110, align 2
  %call111 = call zeroext i16 @ntohs(i16 noundef zeroext %73) #14
  %conv112 = zext i16 %call111 to i32
  br label %cond.end116

cond.false113:                                    ; preds = %lor.lhs.false
  %74 = load ptr, ptr %g, align 8
  %pport = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %74, i32 0, i32 7
  %75 = load i16, ptr %pport, align 4
  %call114 = call zeroext i16 @ntohs(i16 noundef zeroext %75) #14
  %conv115 = zext i16 %call114 to i32
  br label %cond.end116

cond.end116:                                      ; preds = %cond.false113, %cond.true109
  %cond117 = phi i32 [ %conv112, %cond.true109 ], [ %conv115, %cond.false113 ]
  %cmp118 = icmp ne i32 %70, %cond117
  br i1 %cmp118, label %if.then141, label %lor.lhs.false120

lor.lhs.false120:                                 ; preds = %cond.end116
  %76 = load ptr, ptr %node9, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %76, i32 0, i32 24
  %77 = load i32, ptr %tcp_port, align 8
  %78 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool121 = icmp ne i32 %78, 0
  br i1 %tobool121, label %cond.true122, label %cond.false126

cond.true122:                                     ; preds = %lor.lhs.false120
  %79 = load ptr, ptr %g, align 8
  %pport123 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %79, i32 0, i32 7
  %80 = load i16, ptr %pport123, align 4
  %call124 = call zeroext i16 @ntohs(i16 noundef zeroext %80) #14
  %conv125 = zext i16 %call124 to i32
  br label %cond.end130

cond.false126:                                    ; preds = %lor.lhs.false120
  %81 = load ptr, ptr %g, align 8
  %port127 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %81, i32 0, i32 4
  %82 = load i16, ptr %port127, align 2
  %call128 = call zeroext i16 @ntohs(i16 noundef zeroext %82) #14
  %conv129 = zext i16 %call128 to i32
  br label %cond.end130

cond.end130:                                      ; preds = %cond.false126, %cond.true122
  %cond131 = phi i32 [ %conv125, %cond.true122 ], [ %conv129, %cond.false126 ]
  %cmp132 = icmp ne i32 %77, %cond131
  br i1 %cmp132, label %if.then141, label %lor.lhs.false134

lor.lhs.false134:                                 ; preds = %cond.end130
  %83 = load ptr, ptr %node9, align 8
  %cport135 = getelementptr inbounds %struct._clusterNode, ptr %83, i32 0, i32 26
  %84 = load i32, ptr %cport135, align 8
  %85 = load ptr, ptr %g, align 8
  %cport136 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %85, i32 0, i32 5
  %86 = load i16, ptr %cport136, align 4
  %call137 = call zeroext i16 @ntohs(i16 noundef zeroext %86) #14
  %conv138 = zext i16 %call137 to i32
  %cmp139 = icmp ne i32 %84, %conv138
  br i1 %cmp139, label %if.then141, label %if.end159

if.then141:                                       ; preds = %lor.lhs.false134, %cond.end130, %cond.end116, %land.lhs.true101
  %87 = load ptr, ptr %node9, align 8
  %link142 = getelementptr inbounds %struct._clusterNode, ptr %87, i32 0, i32 27
  %88 = load ptr, ptr %link142, align 8
  %tobool143 = icmp ne ptr %88, null
  br i1 %tobool143, label %if.then144, label %if.end146

if.then144:                                       ; preds = %if.then141
  %89 = load ptr, ptr %node9, align 8
  %link145 = getelementptr inbounds %struct._clusterNode, ptr %89, i32 0, i32 27
  %90 = load ptr, ptr %link145, align 8
  call void @freeClusterLink(ptr noundef %90)
  br label %if.end146

if.end146:                                        ; preds = %if.then144, %if.then141
  %91 = load ptr, ptr %node9, align 8
  %ip147 = getelementptr inbounds %struct._clusterNode, ptr %91, i32 0, i32 21
  %arraydecay148 = getelementptr inbounds [46 x i8], ptr %ip147, i64 0, i64 0
  %92 = load ptr, ptr %g, align 8
  %ip149 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %92, i32 0, i32 3
  %arraydecay150 = getelementptr inbounds [46 x i8], ptr %ip149, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay148, ptr align 4 %arraydecay150, i64 46, i1 false)
  %93 = load i32, ptr %msg_tcp_port, align 4
  %94 = load ptr, ptr %node9, align 8
  %tcp_port151 = getelementptr inbounds %struct._clusterNode, ptr %94, i32 0, i32 24
  store i32 %93, ptr %tcp_port151, align 8
  %95 = load i32, ptr %msg_tls_port, align 4
  %96 = load ptr, ptr %node9, align 8
  %tls_port152 = getelementptr inbounds %struct._clusterNode, ptr %96, i32 0, i32 25
  store i32 %95, ptr %tls_port152, align 4
  %97 = load ptr, ptr %g, align 8
  %cport153 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %97, i32 0, i32 5
  %98 = load i16, ptr %cport153, align 4
  %call154 = call zeroext i16 @ntohs(i16 noundef zeroext %98) #14
  %conv155 = zext i16 %call154 to i32
  %99 = load ptr, ptr %node9, align 8
  %cport156 = getelementptr inbounds %struct._clusterNode, ptr %99, i32 0, i32 26
  store i32 %conv155, ptr %cport156, align 8
  %100 = load ptr, ptr %node9, align 8
  %flags157 = getelementptr inbounds %struct._clusterNode, ptr %100, i32 0, i32 3
  %101 = load i32, ptr %flags157, align 8
  %and158 = and i32 %101, -65
  store i32 %and158, ptr %flags157, align 8
  br label %if.end159

if.end159:                                        ; preds = %if.end146, %lor.lhs.false134, %land.lhs.true97, %land.lhs.true93, %if.end89
  br label %if.end188

if.else160:                                       ; preds = %if.end19
  %102 = load ptr, ptr %sender, align 8
  %tobool161 = icmp ne ptr %102, null
  br i1 %tobool161, label %land.lhs.true162, label %if.end187

land.lhs.true162:                                 ; preds = %if.else160
  %103 = load i16, ptr %flags, align 2
  %conv163 = zext i16 %103 to i32
  %and164 = and i32 %conv163, 64
  %tobool165 = icmp ne i32 %and164, 0
  br i1 %tobool165, label %if.end187, label %land.lhs.true166

land.lhs.true166:                                 ; preds = %land.lhs.true162
  %104 = load ptr, ptr %g, align 8
  %nodename167 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %104, i32 0, i32 0
  %arraydecay168 = getelementptr inbounds [40 x i8], ptr %nodename167, i64 0, i64 0
  %call169 = call i32 @clusterBlacklistExists(ptr noundef %arraydecay168)
  %tobool170 = icmp ne i32 %call169, 0
  br i1 %tobool170, label %if.end187, label %if.then171

if.then171:                                       ; preds = %land.lhs.true166
  %105 = load ptr, ptr %g, align 8
  %nodename173 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %105, i32 0, i32 0
  %arraydecay174 = getelementptr inbounds [40 x i8], ptr %nodename173, i64 0, i64 0
  %106 = load i16, ptr %flags, align 2
  %conv175 = zext i16 %106 to i32
  %call176 = call ptr @createClusterNode(ptr noundef %arraydecay174, i32 noundef %conv175)
  store ptr %call176, ptr %node172, align 8
  %107 = load ptr, ptr %node172, align 8
  %ip177 = getelementptr inbounds %struct._clusterNode, ptr %107, i32 0, i32 21
  %arraydecay178 = getelementptr inbounds [46 x i8], ptr %ip177, i64 0, i64 0
  %108 = load ptr, ptr %g, align 8
  %ip179 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %108, i32 0, i32 3
  %arraydecay180 = getelementptr inbounds [46 x i8], ptr %ip179, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay178, ptr align 4 %arraydecay180, i64 46, i1 false)
  %109 = load i32, ptr %msg_tcp_port, align 4
  %110 = load ptr, ptr %node172, align 8
  %tcp_port181 = getelementptr inbounds %struct._clusterNode, ptr %110, i32 0, i32 24
  store i32 %109, ptr %tcp_port181, align 8
  %111 = load i32, ptr %msg_tls_port, align 4
  %112 = load ptr, ptr %node172, align 8
  %tls_port182 = getelementptr inbounds %struct._clusterNode, ptr %112, i32 0, i32 25
  store i32 %111, ptr %tls_port182, align 4
  %113 = load ptr, ptr %g, align 8
  %cport183 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %113, i32 0, i32 5
  %114 = load i16, ptr %cport183, align 4
  %call184 = call zeroext i16 @ntohs(i16 noundef zeroext %114) #14
  %conv185 = zext i16 %call184 to i32
  %115 = load ptr, ptr %node172, align 8
  %cport186 = getelementptr inbounds %struct._clusterNode, ptr %115, i32 0, i32 26
  store i32 %conv185, ptr %cport186, align 8
  %116 = load ptr, ptr %node172, align 8
  call void @clusterAddNode(ptr noundef %116)
  br label %if.end187

if.end187:                                        ; preds = %if.then171, %land.lhs.true166, %land.lhs.true162, %if.else160
  br label %if.end188

if.end188:                                        ; preds = %if.end187, %if.end159
  %117 = load ptr, ptr %g, align 8
  %incdec.ptr = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %117, i32 1
  store ptr %incdec.ptr, ptr %g, align 8
  br label %while.cond, !llvm.loop !33

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind willreturn memory(none)
declare zeroext i16 @ntohs(i16 noundef zeroext) #5

; Function Attrs: nounwind uwtable
define dso_local ptr @representClusterNodeFlags(ptr noundef %ci, i16 noundef zeroext %flags) #0 {
entry:
  %ci.addr = alloca ptr, align 8
  %flags.addr = alloca i16, align 2
  %orig_len = alloca i64, align 8
  %i = alloca i32, align 4
  %size = alloca i32, align 4
  %nodeflag = alloca ptr, align 8
  store ptr %ci, ptr %ci.addr, align 8
  store i16 %flags, ptr %flags.addr, align 2
  %0 = load ptr, ptr %ci.addr, align 8
  %call = call i64 @sdslen(ptr noundef %0)
  store i64 %call, ptr %orig_len, align 8
  store i32 8, ptr %size, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %size, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.redisNodeFlags, ptr @redisNodeFlagsTable, i64 %idx.ext
  store ptr %add.ptr, ptr %nodeflag, align 8
  %4 = load i16, ptr %flags.addr, align 2
  %conv = zext i16 %4 to i32
  %5 = load ptr, ptr %nodeflag, align 8
  %flag = getelementptr inbounds %struct.redisNodeFlags, ptr %5, i32 0, i32 0
  %6 = load i16, ptr %flag, align 8
  %conv1 = zext i16 %6 to i32
  %and = and i32 %conv, %conv1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load ptr, ptr %ci.addr, align 8
  %8 = load ptr, ptr %nodeflag, align 8
  %name = getelementptr inbounds %struct.redisNodeFlags, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %name, align 8
  %call2 = call ptr @sdscat(ptr noundef %7, ptr noundef %9)
  store ptr %call2, ptr %ci.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, ptr %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !34

for.end:                                          ; preds = %for.cond
  %11 = load ptr, ptr %ci.addr, align 8
  %call3 = call i64 @sdslen(ptr noundef %11)
  %12 = load i64, ptr %orig_len, align 8
  %cmp4 = icmp eq i64 %call3, %12
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %for.end
  %13 = load ptr, ptr %ci.addr, align 8
  %call7 = call ptr @sdscat(ptr noundef %13, ptr noundef @.str.145)
  store ptr %call7, ptr %ci.addr, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %for.end
  %14 = load ptr, ptr %ci.addr, align 8
  call void @sdsIncrLen(ptr noundef %14, i64 noundef -1)
  %15 = load ptr, ptr %ci.addr, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define internal void @getClientPortFromGossip(ptr noundef %g, ptr noundef %tls_port, ptr noundef %tcp_port) #0 {
entry:
  %g.addr = alloca ptr, align 8
  %tls_port.addr = alloca ptr, align 8
  %tcp_port.addr = alloca ptr, align 8
  store ptr %g, ptr %g.addr, align 8
  store ptr %tls_port, ptr %tls_port.addr, align 8
  store ptr %tcp_port, ptr %tcp_port.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %g.addr, align 8
  %port = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %1, i32 0, i32 4
  %2 = load i16, ptr %port, align 2
  %call = call zeroext i16 @ntohs(i16 noundef zeroext %2) #14
  %conv = zext i16 %call to i32
  %3 = load ptr, ptr %tls_port.addr, align 8
  store i32 %conv, ptr %3, align 4
  %4 = load ptr, ptr %g.addr, align 8
  %pport = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %4, i32 0, i32 7
  %5 = load i16, ptr %pport, align 4
  %call1 = call zeroext i16 @ntohs(i16 noundef zeroext %5) #14
  %conv2 = zext i16 %call1 to i32
  %6 = load ptr, ptr %tcp_port.addr, align 8
  store i32 %conv2, ptr %6, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr %g.addr, align 8
  %pport3 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %7, i32 0, i32 7
  %8 = load i16, ptr %pport3, align 4
  %call4 = call zeroext i16 @ntohs(i16 noundef zeroext %8) #14
  %conv5 = zext i16 %call4 to i32
  %9 = load ptr, ptr %tls_port.addr, align 8
  store i32 %conv5, ptr %9, align 4
  %10 = load ptr, ptr %g.addr, align 8
  %port6 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %10, i32 0, i32 4
  %11 = load i16, ptr %port6, align 2
  %call7 = call zeroext i16 @ntohs(i16 noundef zeroext %11) #14
  %conv8 = zext i16 %call7 to i32
  %12 = load ptr, ptr %tcp_port.addr, align 8
  store i32 %conv8, ptr %12, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind willreturn memory(none)
declare i32 @ntohl(i32 noundef) #5

; Function Attrs: nounwind uwtable
define dso_local i32 @nodeIp2String(ptr noundef %buf, ptr noundef %link, ptr noundef %announced_ip) #0 {
entry:
  %retval = alloca i32, align 4
  %buf.addr = alloca ptr, align 8
  %link.addr = alloca ptr, align 8
  %announced_ip.addr = alloca ptr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store ptr %link, ptr %link.addr, align 8
  store ptr %announced_ip, ptr %announced_ip.addr, align 8
  %0 = load ptr, ptr %announced_ip.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load ptr, ptr %announced_ip.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %2, ptr align 1 %3, i64 46, i1 false)
  %4 = load ptr, ptr %buf.addr, align 8
  %arrayidx2 = getelementptr inbounds i8, ptr %4, i64 45
  store i8 0, ptr %arrayidx2, align 1
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %link.addr, align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %conn, align 8
  %7 = load ptr, ptr %buf.addr, align 8
  %call = call i32 @connAddrPeerName(ptr noundef %6, ptr noundef %7, i64 noundef 46, ptr noundef null)
  %cmp3 = icmp eq i32 %call, -1
  br i1 %cmp3, label %if.then5, label %if.end12

if.then5:                                         ; preds = %if.else
  br label %do.body

do.body:                                          ; preds = %if.then5
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp6 = icmp slt i32 2, %8
  br i1 %cmp6, label %if.then8, label %if.end

if.then8:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %9 = load ptr, ptr %link.addr, align 8
  %conn9 = getelementptr inbounds %struct.clusterLink, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %conn9, align 8
  %tobool = icmp ne ptr %10, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %11 = load ptr, ptr %link.addr, align 8
  %conn10 = getelementptr inbounds %struct.clusterLink, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %conn10, align 8
  %call11 = call ptr @connGetLastError(ptr noundef %12)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call11, %cond.true ], [ @.str.75, %cond.false ]
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.74, ptr noundef %cond)
  br label %do.end

do.end:                                           ; preds = %cond.end, %if.then8
  store i32 -1, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %do.end, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal i32 @connAddrPeerName(ptr noundef %conn, ptr noundef %ip, i64 noundef %ip_len, ptr noundef %port) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %ip.addr = alloca ptr, align 8
  %ip_len.addr = alloca i64, align 8
  %port.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i64 %ip_len, ptr %ip_len.addr, align 8
  store ptr %port, ptr %port.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %1 = load ptr, ptr %ip.addr, align 8
  %2 = load i64, ptr %ip_len.addr, align 8
  %3 = load ptr, ptr %port.addr, align 8
  %call = call i32 @connAddr(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @nodeUpdateAddressIfNeeded(ptr noundef %node, ptr noundef %link, ptr noundef %hdr) #0 {
entry:
  %retval = alloca i32, align 4
  %node.addr = alloca ptr, align 8
  %link.addr = alloca ptr, align 8
  %hdr.addr = alloca ptr, align 8
  %ip = alloca [46 x i8], align 16
  %cport = alloca i32, align 4
  %tcp_port = alloca i32, align 4
  %tls_port = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store ptr %link, ptr %link.addr, align 8
  store ptr %hdr, ptr %hdr.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %ip, i8 0, i64 46, i1 false)
  %0 = load ptr, ptr %hdr.addr, align 8
  %cport1 = getelementptr inbounds %struct.clusterMsg, ptr %0, i32 0, i32 16
  %1 = load i16, ptr %cport1, align 8
  %call = call zeroext i16 @ntohs(i16 noundef zeroext %1) #14
  %conv = zext i16 %call to i32
  store i32 %conv, ptr %cport, align 4
  %2 = load ptr, ptr %hdr.addr, align 8
  call void @getClientPortFromClusterMsg(ptr noundef %2, ptr noundef %tls_port, ptr noundef %tcp_port)
  %3 = load ptr, ptr %link.addr, align 8
  %4 = load ptr, ptr %node.addr, align 8
  %link2 = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 27
  %5 = load ptr, ptr %link2, align 8
  %cmp = icmp eq ptr %3, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %6 = load ptr, ptr %link.addr, align 8
  %7 = load ptr, ptr %hdr.addr, align 8
  %myip = getelementptr inbounds %struct.clusterMsg, ptr %7, i32 0, i32 12
  %arraydecay4 = getelementptr inbounds [46 x i8], ptr %myip, i64 0, i64 0
  %call5 = call i32 @nodeIp2String(ptr noundef %arraydecay, ptr noundef %6, ptr noundef %arraydecay4)
  %cmp6 = icmp eq i32 %call5, -1
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  %8 = load ptr, ptr %node.addr, align 8
  %tcp_port10 = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 24
  %9 = load i32, ptr %tcp_port10, align 8
  %10 = load i32, ptr %tcp_port, align 4
  %cmp11 = icmp eq i32 %9, %10
  br i1 %cmp11, label %land.lhs.true, label %if.end28

land.lhs.true:                                    ; preds = %if.end9
  %11 = load ptr, ptr %node.addr, align 8
  %cport13 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 26
  %12 = load i32, ptr %cport13, align 8
  %13 = load i32, ptr %cport, align 4
  %cmp14 = icmp eq i32 %12, %13
  br i1 %cmp14, label %land.lhs.true16, label %if.end28

land.lhs.true16:                                  ; preds = %land.lhs.true
  %14 = load ptr, ptr %node.addr, align 8
  %tls_port17 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 25
  %15 = load i32, ptr %tls_port17, align 4
  %16 = load i32, ptr %tls_port, align 4
  %cmp18 = icmp eq i32 %15, %16
  br i1 %cmp18, label %land.lhs.true20, label %if.end28

land.lhs.true20:                                  ; preds = %land.lhs.true16
  %arraydecay21 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %17 = load ptr, ptr %node.addr, align 8
  %ip22 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 21
  %arraydecay23 = getelementptr inbounds [46 x i8], ptr %ip22, i64 0, i64 0
  %call24 = call i32 @strcmp(ptr noundef %arraydecay21, ptr noundef %arraydecay23) #12
  %cmp25 = icmp eq i32 %call24, 0
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %land.lhs.true20
  store i32 0, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %land.lhs.true20, %land.lhs.true16, %land.lhs.true, %if.end9
  %18 = load ptr, ptr %node.addr, align 8
  %ip29 = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 21
  %arraydecay30 = getelementptr inbounds [46 x i8], ptr %ip29, i64 0, i64 0
  %arraydecay31 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay30, ptr align 16 %arraydecay31, i64 46, i1 false)
  %19 = load i32, ptr %tcp_port, align 4
  %20 = load ptr, ptr %node.addr, align 8
  %tcp_port32 = getelementptr inbounds %struct._clusterNode, ptr %20, i32 0, i32 24
  store i32 %19, ptr %tcp_port32, align 8
  %21 = load i32, ptr %tls_port, align 4
  %22 = load ptr, ptr %node.addr, align 8
  %tls_port33 = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 25
  store i32 %21, ptr %tls_port33, align 4
  %23 = load i32, ptr %cport, align 4
  %24 = load ptr, ptr %node.addr, align 8
  %cport34 = getelementptr inbounds %struct._clusterNode, ptr %24, i32 0, i32 26
  store i32 %23, ptr %cport34, align 8
  %25 = load ptr, ptr %node.addr, align 8
  %link35 = getelementptr inbounds %struct._clusterNode, ptr %25, i32 0, i32 27
  %26 = load ptr, ptr %link35, align 8
  %tobool = icmp ne ptr %26, null
  br i1 %tobool, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end28
  %27 = load ptr, ptr %node.addr, align 8
  %link37 = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 27
  %28 = load ptr, ptr %link37, align 8
  call void @freeClusterLink(ptr noundef %28)
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end28
  %29 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %29, i32 0, i32 3
  %30 = load i32, ptr %flags, align 8
  %and = and i32 %30, -65
  store i32 %and, ptr %flags, align 8
  br label %do.body

do.body:                                          ; preds = %if.end38
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp39 = icmp slt i32 2, %31
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %do.body
  br label %do.end

if.end42:                                         ; preds = %do.body
  %32 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %32, i32 0, i32 1
  %arraydecay43 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %33 = load ptr, ptr %node.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %33, i32 0, i32 23
  %34 = load ptr, ptr %human_nodename, align 8
  %35 = load ptr, ptr %node.addr, align 8
  %ip44 = getelementptr inbounds %struct._clusterNode, ptr %35, i32 0, i32 21
  %arraydecay45 = getelementptr inbounds [46 x i8], ptr %ip44, i64 0, i64 0
  %36 = load ptr, ptr %node.addr, align 8
  %call46 = call i32 @getNodeDefaultClientPort(ptr noundef %36)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.76, ptr noundef %arraydecay43, ptr noundef %34, ptr noundef %arraydecay45, i32 noundef %call46)
  br label %do.end

do.end:                                           ; preds = %if.end42, %if.then41
  %37 = load ptr, ptr @myself, align 8
  %flags47 = getelementptr inbounds %struct._clusterNode, ptr %37, i32 0, i32 3
  %38 = load i32, ptr %flags47, align 8
  %and48 = and i32 %38, 2
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %land.lhs.true50, label %if.end57

land.lhs.true50:                                  ; preds = %do.end
  %39 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %39, i32 0, i32 11
  %40 = load ptr, ptr %slaveof, align 8
  %41 = load ptr, ptr %node.addr, align 8
  %cmp51 = icmp eq ptr %40, %41
  br i1 %cmp51, label %if.then53, label %if.end57

if.then53:                                        ; preds = %land.lhs.true50
  %42 = load ptr, ptr %node.addr, align 8
  %ip54 = getelementptr inbounds %struct._clusterNode, ptr %42, i32 0, i32 21
  %arraydecay55 = getelementptr inbounds [46 x i8], ptr %ip54, i64 0, i64 0
  %43 = load ptr, ptr %node.addr, align 8
  %call56 = call i32 @getNodeDefaultReplicationPort(ptr noundef %43)
  call void @replicationSetMaster(ptr noundef %arraydecay55, i32 noundef %call56)
  br label %if.end57

if.end57:                                         ; preds = %if.then53, %land.lhs.true50, %do.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end57, %if.then27, %if.then8, %if.then
  %44 = load i32, ptr %retval, align 4
  ret i32 %44
}

; Function Attrs: nounwind uwtable
define internal void @getClientPortFromClusterMsg(ptr noundef %hdr, ptr noundef %tls_port, ptr noundef %tcp_port) #0 {
entry:
  %hdr.addr = alloca ptr, align 8
  %tls_port.addr = alloca ptr, align 8
  %tcp_port.addr = alloca ptr, align 8
  store ptr %hdr, ptr %hdr.addr, align 8
  store ptr %tls_port, ptr %tls_port.addr, align 8
  store ptr %tcp_port, ptr %tcp_port.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %hdr.addr, align 8
  %port = getelementptr inbounds %struct.clusterMsg, ptr %1, i32 0, i32 3
  %2 = load i16, ptr %port, align 2
  %call = call zeroext i16 @ntohs(i16 noundef zeroext %2) #14
  %conv = zext i16 %call to i32
  %3 = load ptr, ptr %tls_port.addr, align 8
  store i32 %conv, ptr %3, align 4
  %4 = load ptr, ptr %hdr.addr, align 8
  %pport = getelementptr inbounds %struct.clusterMsg, ptr %4, i32 0, i32 15
  %5 = load i16, ptr %pport, align 2
  %call1 = call zeroext i16 @ntohs(i16 noundef zeroext %5) #14
  %conv2 = zext i16 %call1 to i32
  %6 = load ptr, ptr %tcp_port.addr, align 8
  store i32 %conv2, ptr %6, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr %hdr.addr, align 8
  %pport3 = getelementptr inbounds %struct.clusterMsg, ptr %7, i32 0, i32 15
  %8 = load i16, ptr %pport3, align 2
  %call4 = call zeroext i16 @ntohs(i16 noundef zeroext %8) #14
  %conv5 = zext i16 %call4 to i32
  %9 = load ptr, ptr %tls_port.addr, align 8
  store i32 %conv5, ptr %9, align 4
  %10 = load ptr, ptr %hdr.addr, align 8
  %port6 = getelementptr inbounds %struct.clusterMsg, ptr %10, i32 0, i32 3
  %11 = load i16, ptr %port6, align 2
  %call7 = call zeroext i16 @ntohs(i16 noundef zeroext %11) #14
  %conv8 = zext i16 %call7 to i32
  %12 = load ptr, ptr %tcp_port.addr, align 8
  store i32 %conv8, ptr %12, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare void @replicationSetMaster(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @getNodeDefaultReplicationPort(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 403), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %n.addr, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 25
  %2 = load i32, ptr %tls_port, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 24
  %4 = load i32, ptr %tcp_port, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ %4, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateSlotsConfigWith(ptr noundef %sender, i64 noundef %senderConfigEpoch, ptr noundef %slots) #0 {
entry:
  %sender.addr = alloca ptr, align 8
  %senderConfigEpoch.addr = alloca i64, align 8
  %slots.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %curmaster = alloca ptr, align 8
  %newmaster = alloca ptr, align 8
  %dirty_slots = alloca [16384 x i16], align 16
  %dirty_slots_count = alloca i32, align 4
  %sender_slots = alloca i32, align 4
  %migrated_our_slots = alloca i32, align 4
  store ptr %sender, ptr %sender.addr, align 8
  store i64 %senderConfigEpoch, ptr %senderConfigEpoch.addr, align 8
  store ptr %slots, ptr %slots.addr, align 8
  store ptr null, ptr %curmaster, align 8
  store ptr null, ptr %newmaster, align 8
  store i32 0, ptr %dirty_slots_count, align 4
  store i32 0, ptr %sender_slots, align 4
  store i32 0, ptr %migrated_our_slots, align 4
  %0 = load ptr, ptr @myself, align 8
  %call = call i32 @clusterNodeIsMaster(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr @myself, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 11
  %3 = load ptr, ptr %slaveof, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ %3, %cond.false ]
  store ptr %cond, ptr %curmaster, align 8
  %4 = load ptr, ptr %sender.addr, align 8
  %5 = load ptr, ptr @myself, align 8
  %cmp = icmp eq ptr %4, %5
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.then
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 2, %6
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.77)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  br label %if.end130

if.end3:                                          ; preds = %cond.end
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %7 = load i32, ptr %j, align 4
  %cmp4 = icmp slt i32 %7, 16384
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %slots.addr, align 8
  %9 = load i32, ptr %j, align 4
  %call5 = call i32 @bitmapTestBit(ptr noundef %8, i32 noundef %9)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.else

if.then7:                                         ; preds = %for.body
  %10 = load i32, ptr %sender_slots, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %sender_slots, align 4
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots8 = getelementptr inbounds %struct.clusterState, ptr %11, i32 0, i32 9
  %12 = load i32, ptr %j, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %slots8, i64 0, i64 %idxprom
  %13 = load ptr, ptr %arrayidx, align 8
  %14 = load ptr, ptr %sender.addr, align 8
  %cmp9 = icmp eq ptr %13, %14
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then7
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %15, i32 0, i32 27
  %arraydecay = getelementptr inbounds [2048 x i8], ptr %owner_not_claiming_slot, i64 0, i64 0
  %16 = load i32, ptr %j, align 4
  call void @bitmapClearBit(ptr noundef %arraydecay, i32 noundef %16)
  br label %for.inc

if.end11:                                         ; preds = %if.then7
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %17, i32 0, i32 8
  %18 = load i32, ptr %j, align 4
  %idxprom12 = sext i32 %18 to i64
  %arrayidx13 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 %idxprom12
  %19 = load ptr, ptr %arrayidx13, align 8
  %tobool14 = icmp ne ptr %19, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  br label %for.inc

if.end16:                                         ; preds = %if.end11
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots17 = getelementptr inbounds %struct.clusterState, ptr %20, i32 0, i32 9
  %21 = load i32, ptr %j, align 4
  %idxprom18 = sext i32 %21 to i64
  %arrayidx19 = getelementptr inbounds [16384 x ptr], ptr %slots17, i64 0, i64 %idxprom18
  %22 = load ptr, ptr %arrayidx19, align 8
  %cmp20 = icmp eq ptr %22, null
  br i1 %cmp20, label %if.then30, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end16
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %owner_not_claiming_slot21 = getelementptr inbounds %struct.clusterState, ptr %23, i32 0, i32 27
  %arraydecay22 = getelementptr inbounds [2048 x i8], ptr %owner_not_claiming_slot21, i64 0, i64 0
  %24 = load i32, ptr %j, align 4
  %call23 = call i32 @bitmapTestBit(ptr noundef %arraydecay22, i32 noundef %24)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then30, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %lor.lhs.false
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots26 = getelementptr inbounds %struct.clusterState, ptr %25, i32 0, i32 9
  %26 = load i32, ptr %j, align 4
  %idxprom27 = sext i32 %26 to i64
  %arrayidx28 = getelementptr inbounds [16384 x ptr], ptr %slots26, i64 0, i64 %idxprom27
  %27 = load ptr, ptr %arrayidx28, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 4
  %28 = load i64, ptr %configEpoch, align 8
  %29 = load i64, ptr %senderConfigEpoch.addr, align 8
  %cmp29 = icmp ult i64 %28, %29
  br i1 %cmp29, label %if.then30, label %if.end54

if.then30:                                        ; preds = %lor.lhs.false25, %lor.lhs.false, %if.end16
  %30 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots31 = getelementptr inbounds %struct.clusterState, ptr %30, i32 0, i32 9
  %31 = load i32, ptr %j, align 4
  %idxprom32 = sext i32 %31 to i64
  %arrayidx33 = getelementptr inbounds [16384 x ptr], ptr %slots31, i64 0, i64 %idxprom32
  %32 = load ptr, ptr %arrayidx33, align 8
  %33 = load ptr, ptr @myself, align 8
  %cmp34 = icmp eq ptr %32, %33
  br i1 %cmp34, label %land.lhs.true, label %if.end43

land.lhs.true:                                    ; preds = %if.then30
  %34 = load i32, ptr %j, align 4
  %call35 = call i32 @countKeysInSlot(i32 noundef %34)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %land.lhs.true37, label %if.end43

land.lhs.true37:                                  ; preds = %land.lhs.true
  %35 = load ptr, ptr %sender.addr, align 8
  %36 = load ptr, ptr @myself, align 8
  %cmp38 = icmp ne ptr %35, %36
  br i1 %cmp38, label %if.then39, label %if.end43

if.then39:                                        ; preds = %land.lhs.true37
  %37 = load i32, ptr %j, align 4
  %conv = trunc i32 %37 to i16
  %38 = load i32, ptr %dirty_slots_count, align 4
  %idxprom40 = sext i32 %38 to i64
  %arrayidx41 = getelementptr inbounds [16384 x i16], ptr %dirty_slots, i64 0, i64 %idxprom40
  store i16 %conv, ptr %arrayidx41, align 2
  %39 = load i32, ptr %dirty_slots_count, align 4
  %inc42 = add nsw i32 %39, 1
  store i32 %inc42, ptr %dirty_slots_count, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then39, %land.lhs.true37, %land.lhs.true, %if.then30
  %40 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots44 = getelementptr inbounds %struct.clusterState, ptr %40, i32 0, i32 9
  %41 = load i32, ptr %j, align 4
  %idxprom45 = sext i32 %41 to i64
  %arrayidx46 = getelementptr inbounds [16384 x ptr], ptr %slots44, i64 0, i64 %idxprom45
  %42 = load ptr, ptr %arrayidx46, align 8
  %43 = load ptr, ptr %curmaster, align 8
  %cmp47 = icmp eq ptr %42, %43
  br i1 %cmp47, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.end43
  %44 = load ptr, ptr %sender.addr, align 8
  store ptr %44, ptr %newmaster, align 8
  %45 = load i32, ptr %migrated_our_slots, align 4
  %inc50 = add nsw i32 %45, 1
  store i32 %inc50, ptr %migrated_our_slots, align 4
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %if.end43
  %46 = load i32, ptr %j, align 4
  %call52 = call i32 @clusterDelSlot(i32 noundef %46)
  %47 = load ptr, ptr %sender.addr, align 8
  %48 = load i32, ptr %j, align 4
  %call53 = call i32 @clusterAddSlot(ptr noundef %47, i32 noundef %48)
  call void @clusterDoBeforeSleep(i32 noundef 14)
  br label %if.end54

if.end54:                                         ; preds = %if.end51, %lor.lhs.false25
  br label %if.end64

if.else:                                          ; preds = %for.body
  %49 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots55 = getelementptr inbounds %struct.clusterState, ptr %49, i32 0, i32 9
  %50 = load i32, ptr %j, align 4
  %idxprom56 = sext i32 %50 to i64
  %arrayidx57 = getelementptr inbounds [16384 x ptr], ptr %slots55, i64 0, i64 %idxprom56
  %51 = load ptr, ptr %arrayidx57, align 8
  %52 = load ptr, ptr %sender.addr, align 8
  %cmp58 = icmp eq ptr %51, %52
  br i1 %cmp58, label %if.then60, label %if.end63

if.then60:                                        ; preds = %if.else
  %53 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %owner_not_claiming_slot61 = getelementptr inbounds %struct.clusterState, ptr %53, i32 0, i32 27
  %arraydecay62 = getelementptr inbounds [2048 x i8], ptr %owner_not_claiming_slot61, i64 0, i64 0
  %54 = load i32, ptr %j, align 4
  call void @bitmapSetBit(ptr noundef %arraydecay62, i32 noundef %54)
  br label %if.end63

if.end63:                                         ; preds = %if.then60, %if.else
  br label %if.end64

if.end64:                                         ; preds = %if.end63, %if.end54
  br label %for.inc

for.inc:                                          ; preds = %if.end64, %if.then15, %if.then10
  %55 = load i32, ptr %j, align 4
  %inc65 = add nsw i32 %55, 1
  store i32 %inc65, ptr %j, align 4
  br label %for.cond, !llvm.loop !35

for.end:                                          ; preds = %for.cond
  %56 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  %and = and i32 %56, 4
  %tobool66 = icmp ne i32 %and, 0
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %for.end
  br label %if.end130

if.end68:                                         ; preds = %for.end
  %57 = load ptr, ptr %newmaster, align 8
  %tobool69 = icmp ne ptr %57, null
  br i1 %tobool69, label %land.lhs.true70, label %if.else86

land.lhs.true70:                                  ; preds = %if.end68
  %58 = load ptr, ptr %curmaster, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %58, i32 0, i32 8
  %59 = load i32, ptr %numslots, align 4
  %cmp71 = icmp eq i32 %59, 0
  br i1 %cmp71, label %land.lhs.true73, label %if.else86

land.lhs.true73:                                  ; preds = %land.lhs.true70
  %60 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 369), align 4
  %tobool74 = icmp ne i32 %60, 0
  br i1 %tobool74, label %if.then78, label %lor.lhs.false75

lor.lhs.false75:                                  ; preds = %land.lhs.true73
  %61 = load i32, ptr %sender_slots, align 4
  %62 = load i32, ptr %migrated_our_slots, align 4
  %cmp76 = icmp eq i32 %61, %62
  br i1 %cmp76, label %if.then78, label %if.else86

if.then78:                                        ; preds = %lor.lhs.false75, %land.lhs.true73
  br label %do.body79

do.body79:                                        ; preds = %if.then78
  %63 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp80 = icmp slt i32 2, %63
  br i1 %cmp80, label %if.then82, label %if.end83

if.then82:                                        ; preds = %do.body79
  br label %do.end85

if.end83:                                         ; preds = %do.body79
  %64 = load ptr, ptr %sender.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %64, i32 0, i32 1
  %arraydecay84 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %65 = load ptr, ptr %sender.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %65, i32 0, i32 23
  %66 = load ptr, ptr %human_nodename, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.78, ptr noundef %arraydecay84, ptr noundef %66)
  br label %do.end85

do.end85:                                         ; preds = %if.end83, %if.then82
  %67 = load ptr, ptr %sender.addr, align 8
  call void @clusterSetMaster(ptr noundef %67)
  call void @clusterDoBeforeSleep(i32 noundef 14)
  br label %if.end130

if.else86:                                        ; preds = %lor.lhs.false75, %land.lhs.true70, %if.end68
  %68 = load ptr, ptr @myself, align 8
  %slaveof87 = getelementptr inbounds %struct._clusterNode, ptr %68, i32 0, i32 11
  %69 = load ptr, ptr %slaveof87, align 8
  %tobool88 = icmp ne ptr %69, null
  br i1 %tobool88, label %land.lhs.true89, label %if.else114

land.lhs.true89:                                  ; preds = %if.else86
  %70 = load ptr, ptr @myself, align 8
  %slaveof90 = getelementptr inbounds %struct._clusterNode, ptr %70, i32 0, i32 11
  %71 = load ptr, ptr %slaveof90, align 8
  %slaveof91 = getelementptr inbounds %struct._clusterNode, ptr %71, i32 0, i32 11
  %72 = load ptr, ptr %slaveof91, align 8
  %tobool92 = icmp ne ptr %72, null
  br i1 %tobool92, label %land.lhs.true93, label %if.else114

land.lhs.true93:                                  ; preds = %land.lhs.true89
  %73 = load ptr, ptr @myself, align 8
  %slaveof94 = getelementptr inbounds %struct._clusterNode, ptr %73, i32 0, i32 11
  %74 = load ptr, ptr %slaveof94, align 8
  %slaveof95 = getelementptr inbounds %struct._clusterNode, ptr %74, i32 0, i32 11
  %75 = load ptr, ptr %slaveof95, align 8
  %76 = load ptr, ptr @myself, align 8
  %cmp96 = icmp ne ptr %75, %76
  br i1 %cmp96, label %if.then98, label %if.else114

if.then98:                                        ; preds = %land.lhs.true93
  br label %do.body99

do.body99:                                        ; preds = %if.then98
  %77 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp100 = icmp slt i32 2, %77
  br i1 %cmp100, label %if.then102, label %if.end103

if.then102:                                       ; preds = %do.body99
  br label %do.end111

if.end103:                                        ; preds = %do.body99
  %78 = load ptr, ptr @myself, align 8
  %slaveof104 = getelementptr inbounds %struct._clusterNode, ptr %78, i32 0, i32 11
  %79 = load ptr, ptr %slaveof104, align 8
  %slaveof105 = getelementptr inbounds %struct._clusterNode, ptr %79, i32 0, i32 11
  %80 = load ptr, ptr %slaveof105, align 8
  %name106 = getelementptr inbounds %struct._clusterNode, ptr %80, i32 0, i32 1
  %arraydecay107 = getelementptr inbounds [40 x i8], ptr %name106, i64 0, i64 0
  %81 = load ptr, ptr @myself, align 8
  %slaveof108 = getelementptr inbounds %struct._clusterNode, ptr %81, i32 0, i32 11
  %82 = load ptr, ptr %slaveof108, align 8
  %slaveof109 = getelementptr inbounds %struct._clusterNode, ptr %82, i32 0, i32 11
  %83 = load ptr, ptr %slaveof109, align 8
  %human_nodename110 = getelementptr inbounds %struct._clusterNode, ptr %83, i32 0, i32 23
  %84 = load ptr, ptr %human_nodename110, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.79, ptr noundef %arraydecay107, ptr noundef %84)
  br label %do.end111

do.end111:                                        ; preds = %if.end103, %if.then102
  %85 = load ptr, ptr @myself, align 8
  %slaveof112 = getelementptr inbounds %struct._clusterNode, ptr %85, i32 0, i32 11
  %86 = load ptr, ptr %slaveof112, align 8
  %slaveof113 = getelementptr inbounds %struct._clusterNode, ptr %86, i32 0, i32 11
  %87 = load ptr, ptr %slaveof113, align 8
  call void @clusterSetMaster(ptr noundef %87)
  call void @clusterDoBeforeSleep(i32 noundef 14)
  br label %if.end129

if.else114:                                       ; preds = %land.lhs.true93, %land.lhs.true89, %if.else86
  %88 = load i32, ptr %dirty_slots_count, align 4
  %tobool115 = icmp ne i32 %88, 0
  br i1 %tobool115, label %if.then116, label %if.end128

if.then116:                                       ; preds = %if.else114
  store i32 0, ptr %j, align 4
  br label %for.cond117

for.cond117:                                      ; preds = %for.inc125, %if.then116
  %89 = load i32, ptr %j, align 4
  %90 = load i32, ptr %dirty_slots_count, align 4
  %cmp118 = icmp slt i32 %89, %90
  br i1 %cmp118, label %for.body120, label %for.end127

for.body120:                                      ; preds = %for.cond117
  %91 = load i32, ptr %j, align 4
  %idxprom121 = sext i32 %91 to i64
  %arrayidx122 = getelementptr inbounds [16384 x i16], ptr %dirty_slots, i64 0, i64 %idxprom121
  %92 = load i16, ptr %arrayidx122, align 2
  %conv123 = zext i16 %92 to i32
  %call124 = call i32 @delKeysInSlot(i32 noundef %conv123)
  br label %for.inc125

for.inc125:                                       ; preds = %for.body120
  %93 = load i32, ptr %j, align 4
  %inc126 = add nsw i32 %93, 1
  store i32 %inc126, ptr %j, align 4
  br label %for.cond117, !llvm.loop !36

for.end127:                                       ; preds = %for.cond117
  br label %if.end128

if.end128:                                        ; preds = %for.end127, %if.else114
  br label %if.end129

if.end129:                                        ; preds = %if.end128, %do.end111
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %do.end85, %if.then67, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @bitmapTestBit(ptr noundef %bitmap, i32 noundef %pos) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %byte = alloca i64, align 8
  %bit = alloca i32, align 4
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  %0 = load i32, ptr %pos.addr, align 4
  %div = sdiv i32 %0, 8
  %conv = sext i32 %div to i64
  store i64 %conv, ptr %byte, align 8
  %1 = load i32, ptr %pos.addr, align 4
  %and = and i32 %1, 7
  store i32 %and, ptr %bit, align 4
  %2 = load ptr, ptr %bitmap.addr, align 8
  %3 = load i64, ptr %byte, align 8
  %arrayidx = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load i8, ptr %arrayidx, align 1
  %conv1 = zext i8 %4 to i32
  %5 = load i32, ptr %bit, align 4
  %shl = shl i32 1, %5
  %and2 = and i32 %conv1, %shl
  %cmp = icmp ne i32 %and2, 0
  %conv3 = zext i1 %cmp to i32
  ret i32 %conv3
}

; Function Attrs: nounwind uwtable
define dso_local void @bitmapClearBit(ptr noundef %bitmap, i32 noundef %pos) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %byte = alloca i64, align 8
  %bit = alloca i32, align 4
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  %0 = load i32, ptr %pos.addr, align 4
  %div = sdiv i32 %0, 8
  %conv = sext i32 %div to i64
  store i64 %conv, ptr %byte, align 8
  %1 = load i32, ptr %pos.addr, align 4
  %and = and i32 %1, 7
  store i32 %and, ptr %bit, align 4
  %2 = load i32, ptr %bit, align 4
  %shl = shl i32 1, %2
  %not = xor i32 %shl, -1
  %3 = load ptr, ptr %bitmap.addr, align 8
  %4 = load i64, ptr %byte, align 8
  %arrayidx = getelementptr inbounds i8, ptr %3, i64 %4
  %5 = load i8, ptr %arrayidx, align 1
  %conv1 = zext i8 %5 to i32
  %and2 = and i32 %conv1, %not
  %conv3 = trunc i32 %and2 to i8
  store i8 %conv3, ptr %arrayidx, align 1
  ret void
}

declare i32 @countKeysInSlot(i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @bitmapSetBit(ptr noundef %bitmap, i32 noundef %pos) #0 {
entry:
  %bitmap.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %byte = alloca i64, align 8
  %bit = alloca i32, align 4
  store ptr %bitmap, ptr %bitmap.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  %0 = load i32, ptr %pos.addr, align 4
  %div = sdiv i32 %0, 8
  %conv = sext i32 %div to i64
  store i64 %conv, ptr %byte, align 8
  %1 = load i32, ptr %pos.addr, align 4
  %and = and i32 %1, 7
  store i32 %and, ptr %bit, align 4
  %2 = load i32, ptr %bit, align 4
  %shl = shl i32 1, %2
  %3 = load ptr, ptr %bitmap.addr, align 8
  %4 = load i64, ptr %byte, align 8
  %arrayidx = getelementptr inbounds i8, ptr %3, i64 %4
  %5 = load i8, ptr %arrayidx, align 1
  %conv1 = zext i8 %5 to i32
  %or = or i32 %conv1, %shl
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, ptr %arrayidx, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSetMaster(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr @myself, align 8
  %cmp = icmp ne ptr %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.143, ptr noundef @.str.18, i32 noundef 5094)
  call void @abort() #13
  unreachable

2:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %2, %cond.true
  %3 = load ptr, ptr @myself, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %numslots, align 4
  %cmp2 = icmp eq i32 %4, 0
  %lnot4 = xor i1 %cmp2, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %tobool9 = icmp ne i64 %conv8, 0
  br i1 %tobool9, label %cond.true10, label %cond.false11

cond.true10:                                      ; preds = %cond.end
  br label %cond.end12

cond.false11:                                     ; preds = %cond.end
  call void @_serverAssert(ptr noundef @.str.144, ptr noundef @.str.18, i32 noundef 5095)
  call void @abort() #13
  unreachable

5:                                                ; No predecessors!
  br label %cond.end12

cond.end12:                                       ; preds = %5, %cond.true10
  %6 = load ptr, ptr @myself, align 8
  %call = call i32 @clusterNodeIsMaster(ptr noundef %6)
  %tobool13 = icmp ne i32 %call, 0
  br i1 %tobool13, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end12
  %7 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 3
  %8 = load i32, ptr %flags, align 8
  %and = and i32 %8, -258
  store i32 %and, ptr %flags, align 8
  %9 = load ptr, ptr @myself, align 8
  %flags14 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %flags14, align 8
  %or = or i32 %10, 2
  store i32 %or, ptr %flags14, align 8
  call void @clusterCloseAllSlots()
  br label %if.end19

if.else:                                          ; preds = %cond.end12
  %11 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 11
  %12 = load ptr, ptr %slaveof, align 8
  %tobool15 = icmp ne ptr %12, null
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  %13 = load ptr, ptr @myself, align 8
  %slaveof17 = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 11
  %14 = load ptr, ptr %slaveof17, align 8
  %15 = load ptr, ptr @myself, align 8
  %call18 = call i32 @clusterNodeRemoveSlave(ptr noundef %14, ptr noundef %15)
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  br label %if.end19

if.end19:                                         ; preds = %if.end, %if.then
  %16 = load ptr, ptr %n.addr, align 8
  %17 = load ptr, ptr @myself, align 8
  %slaveof20 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 11
  store ptr %16, ptr %slaveof20, align 8
  %18 = load ptr, ptr @myself, align 8
  %19 = load ptr, ptr %n.addr, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 2
  %arraydecay = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  call void @updateShardId(ptr noundef %18, ptr noundef %arraydecay)
  %20 = load ptr, ptr %n.addr, align 8
  %21 = load ptr, ptr @myself, align 8
  %call21 = call i32 @clusterNodeAddSlave(ptr noundef %20, ptr noundef %21)
  %22 = load ptr, ptr %n.addr, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 21
  %arraydecay22 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %23 = load ptr, ptr %n.addr, align 8
  %call23 = call i32 @getNodeDefaultReplicationPort(ptr noundef %23)
  call void @replicationSetMaster(ptr noundef %arraydecay22, i32 noundef %call23)
  call void @removeAllNotOwnedShardChannelSubscriptions()
  call void @resetManualFailover()
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @delKeysInSlot(i32 noundef %hashslot) #0 {
entry:
  %hashslot.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %iter = alloca ptr, align 8
  %de = alloca ptr, align 8
  %sdskey = alloca ptr, align 8
  %key = alloca ptr, align 8
  store i32 %hashslot, ptr %hashslot.addr, align 4
  store i32 0, ptr %j, align 4
  store ptr null, ptr %iter, align 8
  store ptr null, ptr %de, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %dict = getelementptr inbounds %struct.redisDb, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %dict, align 8
  %2 = load i32, ptr %hashslot.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %3)
  store ptr %call, ptr %iter, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %4 = load ptr, ptr %iter, align 8
  %call1 = call ptr @dictNext(ptr noundef %4)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0)
  %5 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetKey(ptr noundef %5)
  store ptr %call2, ptr %sdskey, align 8
  %6 = load ptr, ptr %sdskey, align 8
  %7 = load ptr, ptr %sdskey, align 8
  %call3 = call i64 @sdslen(ptr noundef %7)
  %call4 = call ptr @createStringObject(ptr noundef %6, i64 noundef %call3)
  store ptr %call4, ptr %key, align 8
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %arrayidx5 = getelementptr inbounds %struct.redisDb, ptr %8, i64 0
  %9 = load ptr, ptr %key, align 8
  %call6 = call i32 @dbDelete(ptr noundef %arrayidx5, ptr noundef %9)
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %arrayidx7 = getelementptr inbounds %struct.redisDb, ptr %10, i64 0
  %11 = load ptr, ptr %key, align 8
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 390), align 8
  call void @propagateDeletion(ptr noundef %arrayidx7, ptr noundef %11, i32 noundef %12)
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %arrayidx8 = getelementptr inbounds %struct.redisDb, ptr %13, i64 0
  %14 = load ptr, ptr %key, align 8
  call void @signalModifiedKey(ptr noundef null, ptr noundef %arrayidx8, ptr noundef %14)
  %15 = load ptr, ptr %key, align 8
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %arrayidx9 = getelementptr inbounds %struct.redisDb, ptr %16, i64 0
  %id = getelementptr inbounds %struct.redisDb, ptr %arrayidx9, i32 0, i32 6
  %17 = load i32, ptr %id, align 8
  call void @moduleNotifyKeyspaceEvent(i32 noundef 4, ptr noundef @.str.206, ptr noundef %15, i32 noundef %17)
  call void @exitExecutionUnit()
  call void @postExecutionUnitOperations()
  %18 = load ptr, ptr %key, align 8
  call void @decrRefCount(ptr noundef %18)
  %19 = load i32, ptr %j, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %j, align 4
  %20 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  %inc10 = add nsw i64 %20, 1
  store i64 %inc10, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  br label %while.cond, !llvm.loop !37

while.end:                                        ; preds = %while.cond
  %21 = load ptr, ptr %iter, align 8
  call void @dictReleaseIterator(ptr noundef %21)
  %22 = load i32, ptr %j, align 4
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getAlignedPingExtSize(i32 noundef %dataSize) #0 {
entry:
  %dataSize.addr = alloca i32, align 4
  store i32 %dataSize, ptr %dataSize.addr, align 4
  %0 = load i32, ptr %dataSize.addr, align 4
  %add = add i32 %0, 7
  %div = udiv i32 %add, 8
  %mul = mul i32 %div, 8
  %conv = zext i32 %mul to i64
  %add1 = add i64 8, %conv
  %conv2 = trunc i64 %add1 to i32
  ret i32 %conv2
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getHostnamePingExtSize() #0 {
entry:
  %retval = alloca i32, align 4
  %0 = load ptr, ptr @myself, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 22
  %1 = load ptr, ptr %hostname, align 8
  %call = call i64 @sdslen(ptr noundef %1)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr @myself, align 8
  %hostname1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 22
  %3 = load ptr, ptr %hostname1, align 8
  %call2 = call i64 @sdslen(ptr noundef %3)
  %add = add i64 %call2, 1
  %conv = trunc i64 %add to i32
  %call3 = call i32 @getAlignedPingExtSize(i32 noundef %conv)
  store i32 %call3, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getHumanNodenamePingExtSize() #0 {
entry:
  %retval = alloca i32, align 4
  %0 = load ptr, ptr @myself, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 23
  %1 = load ptr, ptr %human_nodename, align 8
  %call = call i64 @sdslen(ptr noundef %1)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr @myself, align 8
  %human_nodename1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 23
  %3 = load ptr, ptr %human_nodename1, align 8
  %call2 = call i64 @sdslen(ptr noundef %3)
  %add = add i64 %call2, 1
  %conv = trunc i64 %add to i32
  %call3 = call i32 @getAlignedPingExtSize(i32 noundef %conv)
  store i32 %call3, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getShardIdPingExtSize() #0 {
entry:
  %call = call i32 @getAlignedPingExtSize(i32 noundef 40)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getForgottenNodeExtSize() #0 {
entry:
  %call = call i32 @getAlignedPingExtSize(i32 noundef 48)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @preparePingExt(ptr noundef %ext, i16 noundef zeroext %type, i32 noundef %length) #0 {
entry:
  %ext.addr = alloca ptr, align 8
  %type.addr = alloca i16, align 2
  %length.addr = alloca i32, align 4
  store ptr %ext, ptr %ext.addr, align 8
  store i16 %type, ptr %type.addr, align 2
  store i32 %length, ptr %length.addr, align 4
  %0 = load i16, ptr %type.addr, align 2
  %call = call zeroext i16 @htons(i16 noundef zeroext %0) #14
  %1 = load ptr, ptr %ext.addr, align 8
  %type1 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %1, i32 0, i32 1
  store i16 %call, ptr %type1, align 4
  %2 = load i32, ptr %length.addr, align 4
  %call2 = call i32 @htonl(i32 noundef %2) #14
  %3 = load ptr, ptr %ext.addr, align 8
  %length3 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %3, i32 0, i32 0
  store i32 %call2, ptr %length3, align 8
  %4 = load ptr, ptr %ext.addr, align 8
  %ext4 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %4, i32 0, i32 3
  %arrayidx = getelementptr inbounds [0 x %union.anon.5], ptr %ext4, i64 0, i64 0
  ret ptr %arrayidx
}

; Function Attrs: nounwind willreturn memory(none)
declare zeroext i16 @htons(i16 noundef zeroext) #5

; Function Attrs: nounwind willreturn memory(none)
declare i32 @htonl(i32 noundef) #5

; Function Attrs: nounwind uwtable
define dso_local ptr @nextPingExt(ptr noundef %ext) #0 {
entry:
  %ext.addr = alloca ptr, align 8
  store ptr %ext, ptr %ext.addr, align 8
  %0 = load ptr, ptr %ext.addr, align 8
  %1 = load ptr, ptr %ext.addr, align 8
  %length = getelementptr inbounds %struct.clusterMsgPingExt, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %length, align 8
  %call = call i32 @ntohl(i32 noundef %2) #14
  %idx.ext = zext i32 %call to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define dso_local i32 @writePingExt(ptr noundef %hdr, i32 noundef %gossipcount) #0 {
entry:
  %hdr.addr = alloca ptr, align 8
  %gossipcount.addr = alloca i32, align 4
  %extensions = alloca i16, align 2
  %totlen = alloca i32, align 4
  %cursor = alloca ptr, align 8
  %ext = alloca ptr, align 8
  %ext21 = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %expire = alloca i64, align 8
  %ttl = alloca i64, align 8
  %ext52 = alloca ptr, align 8
  %ext67 = alloca ptr, align 8
  store ptr %hdr, ptr %hdr.addr, align 8
  store i32 %gossipcount, ptr %gossipcount.addr, align 4
  store i16 0, ptr %extensions, align 2
  store i32 0, ptr %totlen, align 4
  store ptr null, ptr %cursor, align 8
  %0 = load ptr, ptr %hdr.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %hdr.addr, align 8
  %2 = load i32, ptr %gossipcount.addr, align 4
  %call = call ptr @getInitialPingExt(ptr noundef %1, i32 noundef %2)
  store ptr %call, ptr %cursor, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr @myself, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 22
  %4 = load ptr, ptr %hostname, align 8
  %call1 = call i64 @sdslen(ptr noundef %4)
  %cmp2 = icmp ne i64 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end15

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %cursor, align 8
  %cmp4 = icmp ne ptr %5, null
  br i1 %cmp4, label %if.then5, label %if.end13

if.then5:                                         ; preds = %if.then3
  %6 = load ptr, ptr %cursor, align 8
  %call6 = call i32 @getHostnamePingExtSize()
  %call7 = call ptr @preparePingExt(ptr noundef %6, i16 noundef zeroext 0, i32 noundef %call6)
  store ptr %call7, ptr %ext, align 8
  %7 = load ptr, ptr %ext, align 8
  %hostname8 = getelementptr inbounds %struct.clusterMsgPingExtHostname, ptr %7, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x i8], ptr %hostname8, i64 0, i64 0
  %8 = load ptr, ptr @myself, align 8
  %hostname9 = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 22
  %9 = load ptr, ptr %hostname9, align 8
  %10 = load ptr, ptr @myself, align 8
  %hostname10 = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 22
  %11 = load ptr, ptr %hostname10, align 8
  %call11 = call i64 @sdslen(ptr noundef %11)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay, ptr align 1 %9, i64 %call11, i1 false)
  %12 = load ptr, ptr %cursor, align 8
  %call12 = call ptr @nextPingExt(ptr noundef %12)
  store ptr %call12, ptr %cursor, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then5, %if.then3
  %call14 = call i32 @getHostnamePingExtSize()
  %13 = load i32, ptr %totlen, align 4
  %add = add i32 %13, %call14
  store i32 %add, ptr %totlen, align 4
  %14 = load i16, ptr %extensions, align 2
  %inc = add i16 %14, 1
  store i16 %inc, ptr %extensions, align 2
  br label %if.end15

if.end15:                                         ; preds = %if.end13, %if.end
  %15 = load ptr, ptr @myself, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 23
  %16 = load ptr, ptr %human_nodename, align 8
  %call16 = call i64 @sdslen(ptr noundef %16)
  %cmp17 = icmp ne i64 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.end34

if.then18:                                        ; preds = %if.end15
  %17 = load ptr, ptr %cursor, align 8
  %cmp19 = icmp ne ptr %17, null
  br i1 %cmp19, label %if.then20, label %if.end30

if.then20:                                        ; preds = %if.then18
  %18 = load ptr, ptr %cursor, align 8
  %call22 = call i32 @getHumanNodenamePingExtSize()
  %call23 = call ptr @preparePingExt(ptr noundef %18, i16 noundef zeroext 1, i32 noundef %call22)
  store ptr %call23, ptr %ext21, align 8
  %19 = load ptr, ptr %ext21, align 8
  %human_nodename24 = getelementptr inbounds %struct.clusterMsgPingExtHumanNodename, ptr %19, i32 0, i32 0
  %arraydecay25 = getelementptr inbounds [1 x i8], ptr %human_nodename24, i64 0, i64 0
  %20 = load ptr, ptr @myself, align 8
  %human_nodename26 = getelementptr inbounds %struct._clusterNode, ptr %20, i32 0, i32 23
  %21 = load ptr, ptr %human_nodename26, align 8
  %22 = load ptr, ptr @myself, align 8
  %human_nodename27 = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 23
  %23 = load ptr, ptr %human_nodename27, align 8
  %call28 = call i64 @sdslen(ptr noundef %23)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay25, ptr align 1 %21, i64 %call28, i1 false)
  %24 = load ptr, ptr %cursor, align 8
  %call29 = call ptr @nextPingExt(ptr noundef %24)
  store ptr %call29, ptr %cursor, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then20, %if.then18
  %call31 = call i32 @getHumanNodenamePingExtSize()
  %25 = load i32, ptr %totlen, align 4
  %add32 = add i32 %25, %call31
  store i32 %add32, ptr %totlen, align 4
  %26 = load i16, ptr %extensions, align 2
  %inc33 = add i16 %26, 1
  store i16 %inc33, ptr %extensions, align 2
  br label %if.end34

if.end34:                                         ; preds = %if.end30, %if.end15
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %27, i32 0, i32 6
  %28 = load ptr, ptr %nodes_black_list, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %28, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %29 = load i64, ptr %arrayidx, align 8
  %30 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list35 = getelementptr inbounds %struct.clusterState, ptr %30, i32 0, i32 6
  %31 = load ptr, ptr %nodes_black_list35, align 8
  %ht_used36 = getelementptr inbounds %struct.dict, ptr %31, i32 0, i32 2
  %arrayidx37 = getelementptr inbounds [2 x i64], ptr %ht_used36, i64 0, i64 1
  %32 = load i64, ptr %arrayidx37, align 8
  %add38 = add i64 %29, %32
  %cmp39 = icmp ugt i64 %add38, 0
  br i1 %cmp39, label %if.then40, label %if.end64

if.then40:                                        ; preds = %if.end34
  %33 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list41 = getelementptr inbounds %struct.clusterState, ptr %33, i32 0, i32 6
  %34 = load ptr, ptr %nodes_black_list41, align 8
  %call42 = call ptr @dictGetIterator(ptr noundef %34)
  store ptr %call42, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end60, %if.then49, %if.then40
  %35 = load ptr, ptr %di, align 8
  %call43 = call ptr @dictNext(ptr noundef %35)
  store ptr %call43, ptr %de, align 8
  %cmp44 = icmp ne ptr %call43, null
  br i1 %cmp44, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %36 = load ptr, ptr %cursor, align 8
  %cmp45 = icmp ne ptr %36, null
  br i1 %cmp45, label %if.then46, label %if.end60

if.then46:                                        ; preds = %while.body
  %37 = load ptr, ptr %de, align 8
  %call47 = call i64 @dictGetUnsignedIntegerVal(ptr noundef %37)
  store i64 %call47, ptr %expire, align 8
  %38 = load i64, ptr %expire, align 8
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %cmp48 = icmp slt i64 %38, %atomic-load
  br i1 %cmp48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.then46
  br label %while.cond, !llvm.loop !38

if.end50:                                         ; preds = %if.then46
  %39 = load i64, ptr %expire, align 8
  %atomic-load51 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %sub = sub i64 %39, %atomic-load51
  store i64 %sub, ptr %ttl, align 8
  %40 = load ptr, ptr %cursor, align 8
  %call53 = call i32 @getForgottenNodeExtSize()
  %call54 = call ptr @preparePingExt(ptr noundef %40, i16 noundef zeroext 2, i32 noundef %call53)
  store ptr %call54, ptr %ext52, align 8
  %41 = load ptr, ptr %ext52, align 8
  %name = getelementptr inbounds %struct.clusterMsgPingExtForgottenNode, ptr %41, i32 0, i32 0
  %arraydecay55 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %42 = load ptr, ptr %de, align 8
  %call56 = call ptr @dictGetKey(ptr noundef %42)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay55, ptr align 1 %call56, i64 40, i1 false)
  %43 = load i64, ptr %ttl, align 8
  %call57 = call i64 @intrev64(i64 noundef %43)
  %44 = load ptr, ptr %ext52, align 8
  %ttl58 = getelementptr inbounds %struct.clusterMsgPingExtForgottenNode, ptr %44, i32 0, i32 1
  store i64 %call57, ptr %ttl58, align 8
  %45 = load ptr, ptr %cursor, align 8
  %call59 = call ptr @nextPingExt(ptr noundef %45)
  store ptr %call59, ptr %cursor, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.end50, %while.body
  %call61 = call i32 @getForgottenNodeExtSize()
  %46 = load i32, ptr %totlen, align 4
  %add62 = add i32 %46, %call61
  store i32 %add62, ptr %totlen, align 4
  %47 = load i16, ptr %extensions, align 2
  %inc63 = add i16 %47, 1
  store i16 %inc63, ptr %extensions, align 2
  br label %while.cond, !llvm.loop !38

while.end:                                        ; preds = %while.cond
  %48 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %48)
  br label %if.end64

if.end64:                                         ; preds = %while.end, %if.end34
  %49 = load ptr, ptr %cursor, align 8
  %cmp65 = icmp ne ptr %49, null
  br i1 %cmp65, label %if.then66, label %if.end74

if.then66:                                        ; preds = %if.end64
  %50 = load ptr, ptr %cursor, align 8
  %call68 = call i32 @getShardIdPingExtSize()
  %call69 = call ptr @preparePingExt(ptr noundef %50, i16 noundef zeroext 3, i32 noundef %call68)
  store ptr %call69, ptr %ext67, align 8
  %51 = load ptr, ptr %ext67, align 8
  %shard_id = getelementptr inbounds %struct.clusterMsgPingExtShardId, ptr %51, i32 0, i32 0
  %arraydecay70 = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  %52 = load ptr, ptr @myself, align 8
  %shard_id71 = getelementptr inbounds %struct._clusterNode, ptr %52, i32 0, i32 2
  %arraydecay72 = getelementptr inbounds [40 x i8], ptr %shard_id71, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay70, ptr align 8 %arraydecay72, i64 40, i1 false)
  %53 = load ptr, ptr %cursor, align 8
  %call73 = call ptr @nextPingExt(ptr noundef %53)
  store ptr %call73, ptr %cursor, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.then66, %if.end64
  %call75 = call i32 @getShardIdPingExtSize()
  %54 = load i32, ptr %totlen, align 4
  %add76 = add i32 %54, %call75
  store i32 %add76, ptr %totlen, align 4
  %55 = load i16, ptr %extensions, align 2
  %inc77 = add i16 %55, 1
  store i16 %inc77, ptr %extensions, align 2
  %56 = load ptr, ptr %hdr.addr, align 8
  %cmp78 = icmp ne ptr %56, null
  br i1 %cmp78, label %if.then79, label %if.end89

if.then79:                                        ; preds = %if.end74
  %57 = load i16, ptr %extensions, align 2
  %conv = zext i16 %57 to i32
  %cmp80 = icmp ne i32 %conv, 0
  br i1 %cmp80, label %if.then82, label %if.end86

if.then82:                                        ; preds = %if.then79
  %58 = load ptr, ptr %hdr.addr, align 8
  %mflags = getelementptr inbounds %struct.clusterMsg, ptr %58, i32 0, i32 19
  %arrayidx83 = getelementptr inbounds [3 x i8], ptr %mflags, i64 0, i64 0
  %59 = load i8, ptr %arrayidx83, align 1
  %conv84 = zext i8 %59 to i32
  %or = or i32 %conv84, 4
  %conv85 = trunc i32 %or to i8
  store i8 %conv85, ptr %arrayidx83, align 1
  br label %if.end86

if.end86:                                         ; preds = %if.then82, %if.then79
  %60 = load i16, ptr %extensions, align 2
  %call87 = call zeroext i16 @htons(i16 noundef zeroext %60) #14
  %61 = load ptr, ptr %hdr.addr, align 8
  %extensions88 = getelementptr inbounds %struct.clusterMsg, ptr %61, i32 0, i32 13
  store i16 %call87, ptr %extensions88, align 2
  br label %if.end89

if.end89:                                         ; preds = %if.end86, %if.end74
  %62 = load i32, ptr %totlen, align 4
  ret i32 %62
}

; Function Attrs: nounwind uwtable
define internal ptr @getInitialPingExt(ptr noundef %hdr, i32 noundef %count) #0 {
entry:
  %hdr.addr = alloca ptr, align 8
  %count.addr = alloca i32, align 4
  %initial = alloca ptr, align 8
  store ptr %hdr, ptr %hdr.addr, align 8
  store i32 %count, ptr %count.addr, align 4
  %0 = load ptr, ptr %hdr.addr, align 8
  %data = getelementptr inbounds %struct.clusterMsg, ptr %0, i32 0, i32 20
  %gossip = getelementptr inbounds %struct.anon.0, ptr %data, i32 0, i32 0
  %1 = load i32, ptr %count.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %gossip, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %initial, align 8
  %2 = load ptr, ptr %initial, align 8
  ret ptr %2
}

declare ptr @dictGetIterator(ptr noundef) #1

declare i64 @intrev64(i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterProcessPingExtensions(ptr noundef %hdr, ptr noundef %link) #0 {
entry:
  %hdr.addr = alloca ptr, align 8
  %link.addr = alloca ptr, align 8
  %sender = alloca ptr, align 8
  %ext_hostname = alloca ptr, align 8
  %ext_humannodename = alloca ptr, align 8
  %ext_shardid = alloca ptr, align 8
  %extensions = alloca i16, align 2
  %ext = alloca ptr, align 8
  %type = alloca i16, align 2
  %hostname_ext = alloca ptr, align 8
  %humannodename_ext = alloca ptr, align 8
  %forgotten_node_ext = alloca ptr, align 8
  %n = alloca ptr, align 8
  %id = alloca ptr, align 8
  %de = alloca ptr, align 8
  %expire = alloca i64, align 8
  %shardid_ext = alloca ptr, align 8
  store ptr %hdr, ptr %hdr.addr, align 8
  store ptr %link, ptr %link.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  %node = getelementptr inbounds %struct.clusterLink, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %node, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %link.addr, align 8
  %node1 = getelementptr inbounds %struct.clusterLink, ptr %2, i32 0, i32 8
  %3 = load ptr, ptr %node1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load ptr, ptr %hdr.addr, align 8
  %sender2 = getelementptr inbounds %struct.clusterMsg, ptr %4, i32 0, i32 9
  %arraydecay = getelementptr inbounds [40 x i8], ptr %sender2, i64 0, i64 0
  %call = call ptr @clusterLookupNode(ptr noundef %arraydecay, i32 noundef 40)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %3, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %sender, align 8
  store ptr null, ptr %ext_hostname, align 8
  store ptr null, ptr %ext_humannodename, align 8
  store ptr null, ptr %ext_shardid, align 8
  %5 = load ptr, ptr %hdr.addr, align 8
  %extensions3 = getelementptr inbounds %struct.clusterMsg, ptr %5, i32 0, i32 13
  %6 = load i16, ptr %extensions3, align 2
  %call4 = call zeroext i16 @ntohs(i16 noundef zeroext %6) #14
  store i16 %call4, ptr %extensions, align 2
  %7 = load ptr, ptr %hdr.addr, align 8
  %8 = load ptr, ptr %hdr.addr, align 8
  %count = getelementptr inbounds %struct.clusterMsg, ptr %8, i32 0, i32 5
  %9 = load i16, ptr %count, align 2
  %call5 = call zeroext i16 @ntohs(i16 noundef zeroext %9) #14
  %conv = zext i16 %call5 to i32
  %call6 = call ptr @getInitialPingExt(ptr noundef %7, i32 noundef %conv)
  store ptr %call6, ptr %ext, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end61, %cond.end
  %10 = load i16, ptr %extensions, align 2
  %dec = add i16 %10, -1
  store i16 %dec, ptr %extensions, align 2
  %tobool7 = icmp ne i16 %10, 0
  br i1 %tobool7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load ptr, ptr %ext, align 8
  %type8 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %11, i32 0, i32 1
  %12 = load i16, ptr %type8, align 4
  %call9 = call zeroext i16 @ntohs(i16 noundef zeroext %12) #14
  store i16 %call9, ptr %type, align 2
  %13 = load i16, ptr %type, align 2
  %conv10 = zext i16 %13 to i32
  %cmp = icmp eq i32 %conv10, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %14 = load ptr, ptr %ext, align 8
  %ext12 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %14, i32 0, i32 3
  %arrayidx = getelementptr inbounds [0 x %union.anon.5], ptr %ext12, i64 0, i64 0
  store ptr %arrayidx, ptr %hostname_ext, align 8
  %15 = load ptr, ptr %hostname_ext, align 8
  %hostname = getelementptr inbounds %struct.clusterMsgPingExtHostname, ptr %15, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [1 x i8], ptr %hostname, i64 0, i64 0
  store ptr %arraydecay13, ptr %ext_hostname, align 8
  br label %if.end61

if.else:                                          ; preds = %while.body
  %16 = load i16, ptr %type, align 2
  %conv14 = zext i16 %16 to i32
  %cmp15 = icmp eq i32 %conv14, 1
  br i1 %cmp15, label %if.then17, label %if.else21

if.then17:                                        ; preds = %if.else
  %17 = load ptr, ptr %ext, align 8
  %ext18 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %17, i32 0, i32 3
  %arrayidx19 = getelementptr inbounds [0 x %union.anon.5], ptr %ext18, i64 0, i64 0
  store ptr %arrayidx19, ptr %humannodename_ext, align 8
  %18 = load ptr, ptr %humannodename_ext, align 8
  %human_nodename = getelementptr inbounds %struct.clusterMsgPingExtHumanNodename, ptr %18, i32 0, i32 0
  %arraydecay20 = getelementptr inbounds [1 x i8], ptr %human_nodename, i64 0, i64 0
  store ptr %arraydecay20, ptr %ext_humannodename, align 8
  br label %if.end60

if.else21:                                        ; preds = %if.else
  %19 = load i16, ptr %type, align 2
  %conv22 = zext i16 %19 to i32
  %cmp23 = icmp eq i32 %conv22, 2
  br i1 %cmp23, label %if.then25, label %if.else44

if.then25:                                        ; preds = %if.else21
  %20 = load ptr, ptr %ext, align 8
  %ext26 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %20, i32 0, i32 3
  %arrayidx27 = getelementptr inbounds [0 x %union.anon.5], ptr %ext26, i64 0, i64 0
  store ptr %arrayidx27, ptr %forgotten_node_ext, align 8
  %21 = load ptr, ptr %forgotten_node_ext, align 8
  %name = getelementptr inbounds %struct.clusterMsgPingExtForgottenNode, ptr %21, i32 0, i32 0
  %arraydecay28 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %call29 = call ptr @clusterLookupNode(ptr noundef %arraydecay28, i32 noundef 40)
  store ptr %call29, ptr %n, align 8
  %22 = load ptr, ptr %n, align 8
  %tobool30 = icmp ne ptr %22, null
  br i1 %tobool30, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then25
  %23 = load ptr, ptr %n, align 8
  %24 = load ptr, ptr @myself, align 8
  %cmp31 = icmp ne ptr %23, %24
  br i1 %cmp31, label %land.lhs.true33, label %if.end

land.lhs.true33:                                  ; preds = %land.lhs.true
  %25 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %25, i32 0, i32 3
  %26 = load i32, ptr %flags, align 8
  %and = and i32 %26, 2
  %tobool34 = icmp ne i32 %and, 0
  br i1 %tobool34, label %land.lhs.true35, label %if.then38

land.lhs.true35:                                  ; preds = %land.lhs.true33
  %27 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 11
  %28 = load ptr, ptr %slaveof, align 8
  %29 = load ptr, ptr %n, align 8
  %cmp36 = icmp eq ptr %28, %29
  br i1 %cmp36, label %if.end, label %if.then38

if.then38:                                        ; preds = %land.lhs.true35, %land.lhs.true33
  %30 = load ptr, ptr %forgotten_node_ext, align 8
  %name39 = getelementptr inbounds %struct.clusterMsgPingExtForgottenNode, ptr %30, i32 0, i32 0
  %arraydecay40 = getelementptr inbounds [40 x i8], ptr %name39, i64 0, i64 0
  %call41 = call ptr @sdsnewlen(ptr noundef %arraydecay40, i64 noundef 40)
  store ptr %call41, ptr %id, align 8
  %31 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes_black_list = getelementptr inbounds %struct.clusterState, ptr %31, i32 0, i32 6
  %32 = load ptr, ptr %nodes_black_list, align 8
  %33 = load ptr, ptr %id, align 8
  %call42 = call ptr @dictAddOrFind(ptr noundef %32, ptr noundef %33)
  store ptr %call42, ptr %de, align 8
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %34 = load ptr, ptr %forgotten_node_ext, align 8
  %ttl = getelementptr inbounds %struct.clusterMsgPingExtForgottenNode, ptr %34, i32 0, i32 1
  %35 = load i64, ptr %ttl, align 8
  %call43 = call i64 @intrev64(i64 noundef %35)
  %add = add i64 %atomic-load, %call43
  store i64 %add, ptr %expire, align 8
  %36 = load ptr, ptr %de, align 8
  %37 = load i64, ptr %expire, align 8
  call void @dictSetUnsignedIntegerVal(ptr noundef %36, i64 noundef %37)
  %38 = load ptr, ptr %n, align 8
  call void @clusterDelNode(ptr noundef %38)
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end

if.end:                                           ; preds = %if.then38, %land.lhs.true35, %land.lhs.true, %if.then25
  br label %if.end59

if.else44:                                        ; preds = %if.else21
  %39 = load i16, ptr %type, align 2
  %conv45 = zext i16 %39 to i32
  %cmp46 = icmp eq i32 %conv45, 3
  br i1 %cmp46, label %if.then48, label %if.else52

if.then48:                                        ; preds = %if.else44
  %40 = load ptr, ptr %ext, align 8
  %ext49 = getelementptr inbounds %struct.clusterMsgPingExt, ptr %40, i32 0, i32 3
  %arrayidx50 = getelementptr inbounds [0 x %union.anon.5], ptr %ext49, i64 0, i64 0
  store ptr %arrayidx50, ptr %shardid_ext, align 8
  %41 = load ptr, ptr %shardid_ext, align 8
  %shard_id = getelementptr inbounds %struct.clusterMsgPingExtShardId, ptr %41, i32 0, i32 0
  %arraydecay51 = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  store ptr %arraydecay51, ptr %ext_shardid, align 8
  br label %if.end58

if.else52:                                        ; preds = %if.else44
  br label %do.body

do.body:                                          ; preds = %if.else52
  %42 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp53 = icmp slt i32 3, %42
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %do.body
  br label %do.end

if.end56:                                         ; preds = %do.body
  %43 = load i16, ptr %type, align 2
  %conv57 = zext i16 %43 to i32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.80, i32 noundef %conv57)
  br label %do.end

do.end:                                           ; preds = %if.end56, %if.then55
  br label %if.end58

if.end58:                                         ; preds = %do.end, %if.then48
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.end
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.then17
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.then
  %44 = load ptr, ptr %ext, align 8
  %call62 = call ptr @getNextPingExt(ptr noundef %44)
  store ptr %call62, ptr %ext, align 8
  br label %while.cond, !llvm.loop !39

while.end:                                        ; preds = %while.cond
  %45 = load ptr, ptr %sender, align 8
  %46 = load ptr, ptr %ext_hostname, align 8
  call void @updateAnnouncedHostname(ptr noundef %45, ptr noundef %46)
  %47 = load ptr, ptr %sender, align 8
  %48 = load ptr, ptr %ext_humannodename, align 8
  call void @updateAnnouncedHumanNodename(ptr noundef %47, ptr noundef %48)
  %49 = load ptr, ptr %sender, align 8
  %50 = load ptr, ptr %ext_shardid, align 8
  call void @updateShardId(ptr noundef %49, ptr noundef %50)
  ret void
}

declare ptr @dictAddOrFind(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @getNextPingExt(ptr noundef %ext) #0 {
entry:
  %ext.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %ext, ptr %ext.addr, align 8
  %0 = load ptr, ptr %ext.addr, align 8
  %1 = load ptr, ptr %ext.addr, align 8
  %call = call i32 @getPingExtLength(ptr noundef %1)
  %idx.ext = zext i32 %call to i64
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %idx.ext
  store ptr %add.ptr, ptr %next, align 8
  %2 = load ptr, ptr %next, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define internal void @updateShardId(ptr noundef %node, ptr noundef %shard_id) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %shard_id.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %shard_id, ptr %shard_id.addr, align 8
  %0 = load ptr, ptr %shard_id.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %node.addr, align 8
  %shard_id1 = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 2
  %arraydecay = getelementptr inbounds [40 x i8], ptr %shard_id1, i64 0, i64 0
  %2 = load ptr, ptr %shard_id.addr, align 8
  %call = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %2, i64 noundef 40) #12
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %node.addr, align 8
  call void @clusterRemoveNodeFromShard(ptr noundef %3)
  %4 = load ptr, ptr %node.addr, align 8
  %shard_id2 = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 2
  %arraydecay3 = getelementptr inbounds [40 x i8], ptr %shard_id2, i64 0, i64 0
  %5 = load ptr, ptr %shard_id.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay3, ptr align 1 %5, i64 40, i1 false)
  %6 = load ptr, ptr %shard_id.addr, align 8
  %7 = load ptr, ptr %node.addr, align 8
  call void @clusterAddNodeToShard(ptr noundef %6, ptr noundef %7)
  call void @clusterDoBeforeSleep(i32 noundef 4)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %8 = load ptr, ptr %shard_id.addr, align 8
  %tobool4 = icmp ne ptr %8, null
  br i1 %tobool4, label %land.lhs.true5, label %if.end18

land.lhs.true5:                                   ; preds = %if.end
  %9 = load ptr, ptr @myself, align 8
  %10 = load ptr, ptr %node.addr, align 8
  %cmp6 = icmp ne ptr %9, %10
  br i1 %cmp6, label %land.lhs.true7, label %if.end18

land.lhs.true7:                                   ; preds = %land.lhs.true5
  %11 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 11
  %12 = load ptr, ptr %slaveof, align 8
  %13 = load ptr, ptr %node.addr, align 8
  %cmp8 = icmp eq ptr %12, %13
  br i1 %cmp8, label %if.then9, label %if.end18

if.then9:                                         ; preds = %land.lhs.true7
  %14 = load ptr, ptr @myself, align 8
  %shard_id10 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 2
  %arraydecay11 = getelementptr inbounds [40 x i8], ptr %shard_id10, i64 0, i64 0
  %15 = load ptr, ptr %shard_id.addr, align 8
  %call12 = call i32 @memcmp(ptr noundef %arraydecay11, ptr noundef %15, i64 noundef 40) #12
  %cmp13 = icmp ne i32 %call12, 0
  br i1 %cmp13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.then9
  %16 = load ptr, ptr @myself, align 8
  call void @clusterRemoveNodeFromShard(ptr noundef %16)
  %17 = load ptr, ptr @myself, align 8
  %shard_id15 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 2
  %arraydecay16 = getelementptr inbounds [40 x i8], ptr %shard_id15, i64 0, i64 0
  %18 = load ptr, ptr %shard_id.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay16, ptr align 1 %18, i64 40, i1 false)
  %19 = load ptr, ptr %shard_id.addr, align 8
  %20 = load ptr, ptr @myself, align 8
  call void @clusterAddNodeToShard(ptr noundef %19, ptr noundef %20)
  call void @clusterDoBeforeSleep(i32 noundef 12)
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.then9
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %land.lhs.true7, %land.lhs.true5, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterProcessPacket(ptr noundef %link) #0 {
entry:
  %retval = alloca i32, align 4
  %link.addr = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  %totlen = alloca i32, align 4
  %type = alloca i16, align 2
  %now = alloca i64, align 8
  %flags = alloca i16, align 2
  %extensions = alloca i16, align 2
  %senderCurrentEpoch = alloca i64, align 8
  %senderConfigEpoch = alloca i64, align 8
  %explen = alloca i32, align 4
  %sender = alloca ptr, align 8
  %count = alloca i16, align 2
  %ext = alloca ptr, align 8
  %extlen = alloca i16, align 2
  %ip254 = alloca [46 x i8], align 16
  %node = alloca ptr, align 8
  %nofailover = alloca i32, align 4
  %master = alloca ptr, align 8
  %sender_master = alloca ptr, align 8
  %dirty_slots = alloca i32, align 4
  %j = alloca i32, align 4
  %failing = alloca ptr, align 8
  %channel = alloca ptr, align 8
  %message = alloca ptr, align 8
  %channel_len662 = alloca i32, align 4
  %message_len663 = alloca i32, align 4
  %n = alloca ptr, align 8
  %reportedConfigEpoch = alloca i64, align 8
  %module_id = alloca i64, align 8
  %len800 = alloca i32, align 4
  %type805 = alloca i8, align 1
  %payload = alloca ptr, align 8
  store ptr %link, ptr %link.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  %rcvbuf = getelementptr inbounds %struct.clusterLink, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %rcvbuf, align 8
  store ptr %1, ptr %hdr, align 8
  %2 = load ptr, ptr %hdr, align 8
  %totlen1 = getelementptr inbounds %struct.clusterMsg, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %totlen1, align 4
  %call = call i32 @ntohl(i32 noundef %3) #14
  store i32 %call, ptr %totlen, align 4
  %4 = load ptr, ptr %hdr, align 8
  %type2 = getelementptr inbounds %struct.clusterMsg, ptr %4, i32 0, i32 4
  %5 = load i16, ptr %type2, align 4
  %call3 = call zeroext i16 @ntohs(i16 noundef zeroext %5) #14
  store i16 %call3, ptr %type, align 2
  %call4 = call i64 @mstime()
  store i64 %call4, ptr %now, align 8
  %6 = load i16, ptr %type, align 2
  %conv = zext i16 %6 to i32
  %cmp = icmp slt i32 %conv, 11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_received = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 24
  %8 = load i16, ptr %type, align 2
  %idxprom = zext i16 %8 to i64
  %arrayidx = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_received, i64 0, i64 %idxprom
  %9 = load i64, ptr %arrayidx, align 8
  %inc = add nsw i64 %9, 1
  store i64 %inc, ptr %arrayidx, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp6 = icmp slt i32 0, %10
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %do.body
  br label %do.end

if.end9:                                          ; preds = %do.body
  %11 = load i16, ptr %type, align 2
  %conv10 = zext i16 %11 to i32
  %call11 = call ptr @clusterGetMessageTypeString(i32 noundef %conv10)
  %12 = load i32, ptr %totlen, align 4
  %conv12 = zext i32 %12 to i64
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.81, ptr noundef %call11, i64 noundef %conv12)
  br label %do.end

do.end:                                           ; preds = %if.end9, %if.then8
  %13 = load i32, ptr %totlen, align 4
  %cmp13 = icmp ult i32 %13, 16
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %do.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %do.end
  %14 = load i32, ptr %totlen, align 4
  %conv17 = zext i32 %14 to i64
  %15 = load ptr, ptr %link.addr, align 8
  %rcvbuf_len = getelementptr inbounds %struct.clusterLink, ptr %15, i32 0, i32 6
  %16 = load i64, ptr %rcvbuf_len, align 8
  %cmp18 = icmp ugt i64 %conv17, %16
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end16
  store i32 1, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end16
  %17 = load ptr, ptr %hdr, align 8
  %ver = getelementptr inbounds %struct.clusterMsg, ptr %17, i32 0, i32 2
  %18 = load i16, ptr %ver, align 8
  %call22 = call zeroext i16 @ntohs(i16 noundef zeroext %18) #14
  %conv23 = zext i16 %call22 to i32
  %cmp24 = icmp ne i32 %conv23, 1
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end21
  store i32 1, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end21
  %19 = load i16, ptr %type, align 2
  %conv28 = zext i16 %19 to i32
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 384), align 8
  %cmp29 = icmp eq i32 %conv28, %20
  br i1 %cmp29, label %if.then31, label %if.end38

if.then31:                                        ; preds = %if.end27
  br label %do.body32

do.body32:                                        ; preds = %if.then31
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp33 = icmp slt i32 3, %21
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %do.body32
  br label %do.end37

if.end36:                                         ; preds = %do.body32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.82)
  br label %do.end37

do.end37:                                         ; preds = %if.end36, %if.then35
  store i32 1, ptr %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end27
  %22 = load ptr, ptr %hdr, align 8
  %flags39 = getelementptr inbounds %struct.clusterMsg, ptr %22, i32 0, i32 17
  %23 = load i16, ptr %flags39, align 2
  %call40 = call zeroext i16 @ntohs(i16 noundef zeroext %23) #14
  store i16 %call40, ptr %flags, align 2
  %24 = load ptr, ptr %hdr, align 8
  %extensions41 = getelementptr inbounds %struct.clusterMsg, ptr %24, i32 0, i32 13
  %25 = load i16, ptr %extensions41, align 2
  %call42 = call zeroext i16 @ntohs(i16 noundef zeroext %25) #14
  store i16 %call42, ptr %extensions, align 2
  store i64 0, ptr %senderCurrentEpoch, align 8
  store i64 0, ptr %senderConfigEpoch, align 8
  %26 = load i16, ptr %type, align 2
  %conv43 = zext i16 %26 to i32
  %cmp44 = icmp eq i32 %conv43, 0
  br i1 %cmp44, label %if.then53, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end38
  %27 = load i16, ptr %type, align 2
  %conv46 = zext i16 %27 to i32
  %cmp47 = icmp eq i32 %conv46, 1
  br i1 %cmp47, label %if.then53, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false
  %28 = load i16, ptr %type, align 2
  %conv50 = zext i16 %28 to i32
  %cmp51 = icmp eq i32 %conv50, 2
  br i1 %cmp51, label %if.then53, label %if.else

if.then53:                                        ; preds = %lor.lhs.false49, %lor.lhs.false, %if.end38
  %29 = load ptr, ptr %hdr, align 8
  %count54 = getelementptr inbounds %struct.clusterMsg, ptr %29, i32 0, i32 5
  %30 = load i16, ptr %count54, align 2
  %call55 = call zeroext i16 @ntohs(i16 noundef zeroext %30) #14
  store i16 %call55, ptr %count, align 2
  store i32 2256, ptr %explen, align 4
  %31 = load i16, ptr %count, align 2
  %conv56 = zext i16 %31 to i64
  %mul = mul i64 104, %conv56
  %32 = load i32, ptr %explen, align 4
  %conv57 = zext i32 %32 to i64
  %add = add i64 %conv57, %mul
  %conv58 = trunc i64 %add to i32
  store i32 %conv58, ptr %explen, align 4
  %33 = load ptr, ptr %hdr, align 8
  %mflags = getelementptr inbounds %struct.clusterMsg, ptr %33, i32 0, i32 19
  %arrayidx59 = getelementptr inbounds [3 x i8], ptr %mflags, i64 0, i64 0
  %34 = load i8, ptr %arrayidx59, align 1
  %conv60 = zext i8 %34 to i32
  %and = and i32 %conv60, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then61, label %if.end98

if.then61:                                        ; preds = %if.then53
  %35 = load ptr, ptr %hdr, align 8
  %36 = load i16, ptr %count, align 2
  %conv62 = zext i16 %36 to i32
  %call63 = call ptr @getInitialPingExt(ptr noundef %35, i32 noundef %conv62)
  store ptr %call63, ptr %ext, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end94, %if.then61
  %37 = load i16, ptr %extensions, align 2
  %dec = add i16 %37, -1
  store i16 %dec, ptr %extensions, align 2
  %tobool64 = icmp ne i16 %37, 0
  br i1 %tobool64, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %38 = load ptr, ptr %ext, align 8
  %call65 = call i32 @getPingExtLength(ptr noundef %38)
  %conv66 = trunc i32 %call65 to i16
  store i16 %conv66, ptr %extlen, align 2
  %39 = load i16, ptr %extlen, align 2
  %conv67 = zext i16 %39 to i32
  %rem = srem i32 %conv67, 8
  %cmp68 = icmp ne i32 %rem, 0
  br i1 %cmp68, label %if.then70, label %if.end80

if.then70:                                        ; preds = %while.body
  br label %do.body71

do.body71:                                        ; preds = %if.then70
  %40 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp72 = icmp slt i32 3, %40
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %do.body71
  br label %do.end79

if.end75:                                         ; preds = %do.body71
  %41 = load i16, ptr %type, align 2
  %conv76 = zext i16 %41 to i32
  %call77 = call ptr @clusterGetMessageTypeString(i32 noundef %conv76)
  %42 = load i16, ptr %extlen, align 2
  %conv78 = zext i16 %42 to i32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.83, ptr noundef %call77, i32 noundef %conv78)
  br label %do.end79

do.end79:                                         ; preds = %if.end75, %if.then74
  store i32 1, ptr %retval, align 4
  br label %return

if.end80:                                         ; preds = %while.body
  %43 = load i32, ptr %totlen, align 4
  %44 = load i32, ptr %explen, align 4
  %sub = sub i32 %43, %44
  %45 = load i16, ptr %extlen, align 2
  %conv81 = zext i16 %45 to i32
  %cmp82 = icmp ult i32 %sub, %conv81
  br i1 %cmp82, label %if.then84, label %if.end94

if.then84:                                        ; preds = %if.end80
  br label %do.body85

do.body85:                                        ; preds = %if.then84
  %46 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp86 = icmp slt i32 3, %46
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %do.body85
  br label %do.end93

if.end89:                                         ; preds = %do.body85
  %47 = load i16, ptr %type, align 2
  %conv90 = zext i16 %47 to i32
  %call91 = call ptr @clusterGetMessageTypeString(i32 noundef %conv90)
  %48 = load i32, ptr %totlen, align 4
  %conv92 = zext i32 %48 to i64
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.84, ptr noundef %call91, i64 noundef %conv92)
  br label %do.end93

do.end93:                                         ; preds = %if.end89, %if.then88
  store i32 1, ptr %retval, align 4
  br label %return

if.end94:                                         ; preds = %if.end80
  %49 = load i16, ptr %extlen, align 2
  %conv95 = zext i16 %49 to i32
  %50 = load i32, ptr %explen, align 4
  %add96 = add i32 %50, %conv95
  store i32 %add96, ptr %explen, align 4
  %51 = load ptr, ptr %ext, align 8
  %call97 = call ptr @getNextPingExt(ptr noundef %51)
  store ptr %call97, ptr %ext, align 8
  br label %while.cond, !llvm.loop !40

while.end:                                        ; preds = %while.cond
  br label %if.end98

if.end98:                                         ; preds = %while.end, %if.then53
  br label %if.end166

if.else:                                          ; preds = %lor.lhs.false49
  %52 = load i16, ptr %type, align 2
  %conv99 = zext i16 %52 to i32
  %cmp100 = icmp eq i32 %conv99, 3
  br i1 %cmp100, label %if.then102, label %if.else106

if.then102:                                       ; preds = %if.else
  store i32 2256, ptr %explen, align 4
  %53 = load i32, ptr %explen, align 4
  %conv103 = zext i32 %53 to i64
  %add104 = add i64 %conv103, 40
  %conv105 = trunc i64 %add104 to i32
  store i32 %conv105, ptr %explen, align 4
  br label %if.end165

if.else106:                                       ; preds = %if.else
  %54 = load i16, ptr %type, align 2
  %conv107 = zext i16 %54 to i32
  %cmp108 = icmp eq i32 %conv107, 4
  br i1 %cmp108, label %if.then114, label %lor.lhs.false110

lor.lhs.false110:                                 ; preds = %if.else106
  %55 = load i16, ptr %type, align 2
  %conv111 = zext i16 %55 to i32
  %cmp112 = icmp eq i32 %conv111, 10
  br i1 %cmp112, label %if.then114, label %if.else126

if.then114:                                       ; preds = %lor.lhs.false110, %if.else106
  store i32 2256, ptr %explen, align 4
  %56 = load ptr, ptr %hdr, align 8
  %data = getelementptr inbounds %struct.clusterMsg, ptr %56, i32 0, i32 20
  %msg = getelementptr inbounds %struct.anon.2, ptr %data, i32 0, i32 0
  %channel_len = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg, i32 0, i32 0
  %57 = load i32, ptr %channel_len, align 8
  %call115 = call i32 @ntohl(i32 noundef %57) #14
  %conv116 = zext i32 %call115 to i64
  %add117 = add i64 8, %conv116
  %58 = load ptr, ptr %hdr, align 8
  %data118 = getelementptr inbounds %struct.clusterMsg, ptr %58, i32 0, i32 20
  %msg119 = getelementptr inbounds %struct.anon.2, ptr %data118, i32 0, i32 0
  %message_len = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg119, i32 0, i32 1
  %59 = load i32, ptr %message_len, align 4
  %call120 = call i32 @ntohl(i32 noundef %59) #14
  %conv121 = zext i32 %call120 to i64
  %add122 = add i64 %add117, %conv121
  %60 = load i32, ptr %explen, align 4
  %conv123 = zext i32 %60 to i64
  %add124 = add i64 %conv123, %add122
  %conv125 = trunc i64 %add124 to i32
  store i32 %conv125, ptr %explen, align 4
  br label %if.end164

if.else126:                                       ; preds = %lor.lhs.false110
  %61 = load i16, ptr %type, align 2
  %conv127 = zext i16 %61 to i32
  %cmp128 = icmp eq i32 %conv127, 5
  br i1 %cmp128, label %if.then138, label %lor.lhs.false130

lor.lhs.false130:                                 ; preds = %if.else126
  %62 = load i16, ptr %type, align 2
  %conv131 = zext i16 %62 to i32
  %cmp132 = icmp eq i32 %conv131, 6
  br i1 %cmp132, label %if.then138, label %lor.lhs.false134

lor.lhs.false134:                                 ; preds = %lor.lhs.false130
  %63 = load i16, ptr %type, align 2
  %conv135 = zext i16 %63 to i32
  %cmp136 = icmp eq i32 %conv135, 8
  br i1 %cmp136, label %if.then138, label %if.else139

if.then138:                                       ; preds = %lor.lhs.false134, %lor.lhs.false130, %if.else126
  store i32 2256, ptr %explen, align 4
  br label %if.end163

if.else139:                                       ; preds = %lor.lhs.false134
  %64 = load i16, ptr %type, align 2
  %conv140 = zext i16 %64 to i32
  %cmp141 = icmp eq i32 %conv140, 7
  br i1 %cmp141, label %if.then143, label %if.else147

if.then143:                                       ; preds = %if.else139
  store i32 2256, ptr %explen, align 4
  %65 = load i32, ptr %explen, align 4
  %conv144 = zext i32 %65 to i64
  %add145 = add i64 %conv144, 2096
  %conv146 = trunc i64 %add145 to i32
  store i32 %conv146, ptr %explen, align 4
  br label %if.end162

if.else147:                                       ; preds = %if.else139
  %66 = load i16, ptr %type, align 2
  %conv148 = zext i16 %66 to i32
  %cmp149 = icmp eq i32 %conv148, 9
  br i1 %cmp149, label %if.then151, label %if.else160

if.then151:                                       ; preds = %if.else147
  store i32 2256, ptr %explen, align 4
  %67 = load ptr, ptr %hdr, align 8
  %data152 = getelementptr inbounds %struct.clusterMsg, ptr %67, i32 0, i32 20
  %msg153 = getelementptr inbounds %struct.anon.4, ptr %data152, i32 0, i32 0
  %len = getelementptr inbounds %struct.clusterMsgModule, ptr %msg153, i32 0, i32 1
  %68 = load i32, ptr %len, align 8
  %call154 = call i32 @ntohl(i32 noundef %68) #14
  %conv155 = zext i32 %call154 to i64
  %add156 = add i64 13, %conv155
  %69 = load i32, ptr %explen, align 4
  %conv157 = zext i32 %69 to i64
  %add158 = add i64 %conv157, %add156
  %conv159 = trunc i64 %add158 to i32
  store i32 %conv159, ptr %explen, align 4
  br label %if.end161

if.else160:                                       ; preds = %if.else147
  %70 = load i32, ptr %totlen, align 4
  store i32 %70, ptr %explen, align 4
  br label %if.end161

if.end161:                                        ; preds = %if.else160, %if.then151
  br label %if.end162

if.end162:                                        ; preds = %if.end161, %if.then143
  br label %if.end163

if.end163:                                        ; preds = %if.end162, %if.then138
  br label %if.end164

if.end164:                                        ; preds = %if.end163, %if.then114
  br label %if.end165

if.end165:                                        ; preds = %if.end164, %if.then102
  br label %if.end166

if.end166:                                        ; preds = %if.end165, %if.end98
  %71 = load i32, ptr %totlen, align 4
  %72 = load i32, ptr %explen, align 4
  %cmp167 = icmp ne i32 %71, %72
  br i1 %cmp167, label %if.then169, label %if.end180

if.then169:                                       ; preds = %if.end166
  br label %do.body170

do.body170:                                       ; preds = %if.then169
  %73 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp171 = icmp slt i32 3, %73
  br i1 %cmp171, label %if.then173, label %if.end174

if.then173:                                       ; preds = %do.body170
  br label %do.end179

if.end174:                                        ; preds = %do.body170
  %74 = load i16, ptr %type, align 2
  %conv175 = zext i16 %74 to i32
  %call176 = call ptr @clusterGetMessageTypeString(i32 noundef %conv175)
  %75 = load i32, ptr %totlen, align 4
  %conv177 = zext i32 %75 to i64
  %76 = load i32, ptr %explen, align 4
  %conv178 = zext i32 %76 to i64
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.85, ptr noundef %call176, i64 noundef %conv177, i64 noundef %conv178)
  br label %do.end179

do.end179:                                        ; preds = %if.end174, %if.then173
  store i32 1, ptr %retval, align 4
  br label %return

if.end180:                                        ; preds = %if.end166
  %77 = load ptr, ptr %link.addr, align 8
  %78 = load ptr, ptr %hdr, align 8
  %call181 = call ptr @getNodeFromLinkAndMsg(ptr noundef %77, ptr noundef %78)
  store ptr %call181, ptr %sender, align 8
  %79 = load ptr, ptr %sender, align 8
  %tobool182 = icmp ne ptr %79, null
  br i1 %tobool182, label %if.then183, label %if.end184

if.then183:                                       ; preds = %if.end180
  %80 = load i64, ptr %now, align 8
  %81 = load ptr, ptr %sender, align 8
  %data_received = getelementptr inbounds %struct._clusterNode, ptr %81, i32 0, i32 15
  store i64 %80, ptr %data_received, align 8
  br label %if.end184

if.end184:                                        ; preds = %if.then183, %if.end180
  %82 = load ptr, ptr %sender, align 8
  %tobool185 = icmp ne ptr %82, null
  br i1 %tobool185, label %land.lhs.true, label %if.end233

land.lhs.true:                                    ; preds = %if.end184
  %83 = load ptr, ptr %sender, align 8
  %flags186 = getelementptr inbounds %struct._clusterNode, ptr %83, i32 0, i32 3
  %84 = load i32, ptr %flags186, align 8
  %and187 = and i32 %84, 32
  %tobool188 = icmp ne i32 %and187, 0
  br i1 %tobool188, label %if.end233, label %if.then189

if.then189:                                       ; preds = %land.lhs.true
  %85 = load ptr, ptr %hdr, align 8
  %currentEpoch = getelementptr inbounds %struct.clusterMsg, ptr %85, i32 0, i32 6
  %86 = load i64, ptr %currentEpoch, align 8
  %call190 = call i64 @intrev64(i64 noundef %86)
  store i64 %call190, ptr %senderCurrentEpoch, align 8
  %87 = load ptr, ptr %hdr, align 8
  %configEpoch = getelementptr inbounds %struct.clusterMsg, ptr %87, i32 0, i32 7
  %88 = load i64, ptr %configEpoch, align 8
  %call191 = call i64 @intrev64(i64 noundef %88)
  store i64 %call191, ptr %senderConfigEpoch, align 8
  %89 = load i64, ptr %senderCurrentEpoch, align 8
  %90 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch192 = getelementptr inbounds %struct.clusterState, ptr %90, i32 0, i32 1
  %91 = load i64, ptr %currentEpoch192, align 8
  %cmp193 = icmp ugt i64 %89, %91
  br i1 %cmp193, label %if.then195, label %if.end197

if.then195:                                       ; preds = %if.then189
  %92 = load i64, ptr %senderCurrentEpoch, align 8
  %93 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch196 = getelementptr inbounds %struct.clusterState, ptr %93, i32 0, i32 1
  store i64 %92, ptr %currentEpoch196, align 8
  br label %if.end197

if.end197:                                        ; preds = %if.then195, %if.then189
  %94 = load i64, ptr %senderConfigEpoch, align 8
  %95 = load ptr, ptr %sender, align 8
  %configEpoch198 = getelementptr inbounds %struct._clusterNode, ptr %95, i32 0, i32 4
  %96 = load i64, ptr %configEpoch198, align 8
  %cmp199 = icmp ugt i64 %94, %96
  br i1 %cmp199, label %if.then201, label %if.end203

if.then201:                                       ; preds = %if.end197
  %97 = load i64, ptr %senderConfigEpoch, align 8
  %98 = load ptr, ptr %sender, align 8
  %configEpoch202 = getelementptr inbounds %struct._clusterNode, ptr %98, i32 0, i32 4
  store i64 %97, ptr %configEpoch202, align 8
  call void @clusterDoBeforeSleep(i32 noundef 12)
  br label %if.end203

if.end203:                                        ; preds = %if.then201, %if.end197
  %99 = load ptr, ptr %hdr, align 8
  %offset = getelementptr inbounds %struct.clusterMsg, ptr %99, i32 0, i32 8
  %100 = load i64, ptr %offset, align 8
  %call204 = call i64 @intrev64(i64 noundef %100)
  %101 = load ptr, ptr %sender, align 8
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %101, i32 0, i32 20
  store i64 %call204, ptr %repl_offset, align 8
  %102 = load i64, ptr %now, align 8
  %103 = load ptr, ptr %sender, align 8
  %repl_offset_time = getelementptr inbounds %struct._clusterNode, ptr %103, i32 0, i32 18
  store i64 %102, ptr %repl_offset_time, align 8
  %104 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %104, i32 0, i32 17
  %105 = load i64, ptr %mf_end, align 8
  %tobool205 = icmp ne i64 %105, 0
  br i1 %tobool205, label %land.lhs.true206, label %if.end232

land.lhs.true206:                                 ; preds = %if.end203
  %106 = load ptr, ptr @myself, align 8
  %flags207 = getelementptr inbounds %struct._clusterNode, ptr %106, i32 0, i32 3
  %107 = load i32, ptr %flags207, align 8
  %and208 = and i32 %107, 2
  %tobool209 = icmp ne i32 %and208, 0
  br i1 %tobool209, label %land.lhs.true210, label %if.end232

land.lhs.true210:                                 ; preds = %land.lhs.true206
  %108 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %108, i32 0, i32 11
  %109 = load ptr, ptr %slaveof, align 8
  %110 = load ptr, ptr %sender, align 8
  %cmp211 = icmp eq ptr %109, %110
  br i1 %cmp211, label %land.lhs.true213, label %if.end232

land.lhs.true213:                                 ; preds = %land.lhs.true210
  %111 = load ptr, ptr %hdr, align 8
  %mflags214 = getelementptr inbounds %struct.clusterMsg, ptr %111, i32 0, i32 19
  %arrayidx215 = getelementptr inbounds [3 x i8], ptr %mflags214, i64 0, i64 0
  %112 = load i8, ptr %arrayidx215, align 1
  %conv216 = zext i8 %112 to i32
  %and217 = and i32 %conv216, 1
  %tobool218 = icmp ne i32 %and217, 0
  br i1 %tobool218, label %land.lhs.true219, label %if.end232

land.lhs.true219:                                 ; preds = %land.lhs.true213
  %113 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_master_offset = getelementptr inbounds %struct.clusterState, ptr %113, i32 0, i32 19
  %114 = load i64, ptr %mf_master_offset, align 8
  %cmp220 = icmp eq i64 %114, -1
  br i1 %cmp220, label %if.then222, label %if.end232

if.then222:                                       ; preds = %land.lhs.true219
  %115 = load ptr, ptr %sender, align 8
  %repl_offset223 = getelementptr inbounds %struct._clusterNode, ptr %115, i32 0, i32 20
  %116 = load i64, ptr %repl_offset223, align 8
  %117 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_master_offset224 = getelementptr inbounds %struct.clusterState, ptr %117, i32 0, i32 19
  store i64 %116, ptr %mf_master_offset224, align 8
  call void @clusterDoBeforeSleep(i32 noundef 16)
  br label %do.body225

do.body225:                                       ; preds = %if.then222
  %118 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp226 = icmp slt i32 2, %118
  br i1 %cmp226, label %if.then228, label %if.end229

if.then228:                                       ; preds = %do.body225
  br label %do.end231

if.end229:                                        ; preds = %do.body225
  %119 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_master_offset230 = getelementptr inbounds %struct.clusterState, ptr %119, i32 0, i32 19
  %120 = load i64, ptr %mf_master_offset230, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.86, i64 noundef %120)
  br label %do.end231

do.end231:                                        ; preds = %if.end229, %if.then228
  br label %if.end232

if.end232:                                        ; preds = %do.end231, %land.lhs.true219, %land.lhs.true213, %land.lhs.true210, %land.lhs.true206, %if.end203
  br label %if.end233

if.end233:                                        ; preds = %if.end232, %land.lhs.true, %if.end184
  %121 = load i16, ptr %type, align 2
  %conv234 = zext i16 %121 to i32
  %cmp235 = icmp eq i32 %conv234, 0
  br i1 %cmp235, label %if.then241, label %lor.lhs.false237

lor.lhs.false237:                                 ; preds = %if.end233
  %122 = load i16, ptr %type, align 2
  %conv238 = zext i16 %122 to i32
  %cmp239 = icmp eq i32 %conv238, 2
  br i1 %cmp239, label %if.then241, label %if.end305

if.then241:                                       ; preds = %lor.lhs.false237, %if.end233
  %123 = load i16, ptr %type, align 2
  %conv242 = zext i16 %123 to i32
  %cmp243 = icmp eq i32 %conv242, 2
  br i1 %cmp243, label %land.lhs.true250, label %lor.lhs.false245

lor.lhs.false245:                                 ; preds = %if.then241
  %124 = load ptr, ptr @myself, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %124, i32 0, i32 21
  %arrayidx246 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %125 = load i8, ptr %arrayidx246, align 8
  %conv247 = sext i8 %125 to i32
  %cmp248 = icmp eq i32 %conv247, 0
  br i1 %cmp248, label %land.lhs.true250, label %if.end277

land.lhs.true250:                                 ; preds = %lor.lhs.false245, %if.then241
  %126 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 373), align 8
  %cmp251 = icmp eq ptr %126, null
  br i1 %cmp251, label %if.then253, label %if.end277

if.then253:                                       ; preds = %land.lhs.true250
  %127 = load ptr, ptr %link.addr, align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %127, i32 0, i32 1
  %128 = load ptr, ptr %conn, align 8
  %arraydecay = getelementptr inbounds [46 x i8], ptr %ip254, i64 0, i64 0
  %call255 = call i32 @connAddrSockName(ptr noundef %128, ptr noundef %arraydecay, i64 noundef 46, ptr noundef null)
  %cmp256 = icmp ne i32 %call255, -1
  br i1 %cmp256, label %land.lhs.true258, label %if.end276

land.lhs.true258:                                 ; preds = %if.then253
  %arraydecay259 = getelementptr inbounds [46 x i8], ptr %ip254, i64 0, i64 0
  %129 = load ptr, ptr @myself, align 8
  %ip260 = getelementptr inbounds %struct._clusterNode, ptr %129, i32 0, i32 21
  %arraydecay261 = getelementptr inbounds [46 x i8], ptr %ip260, i64 0, i64 0
  %call262 = call i32 @strcmp(ptr noundef %arraydecay259, ptr noundef %arraydecay261) #12
  %tobool263 = icmp ne i32 %call262, 0
  br i1 %tobool263, label %if.then264, label %if.end276

if.then264:                                       ; preds = %land.lhs.true258
  %130 = load ptr, ptr @myself, align 8
  %ip265 = getelementptr inbounds %struct._clusterNode, ptr %130, i32 0, i32 21
  %arraydecay266 = getelementptr inbounds [46 x i8], ptr %ip265, i64 0, i64 0
  %arraydecay267 = getelementptr inbounds [46 x i8], ptr %ip254, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay266, ptr align 16 %arraydecay267, i64 46, i1 false)
  br label %do.body268

do.body268:                                       ; preds = %if.then264
  %131 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp269 = icmp slt i32 2, %131
  br i1 %cmp269, label %if.then271, label %if.end272

if.then271:                                       ; preds = %do.body268
  br label %do.end275

if.end272:                                        ; preds = %do.body268
  %132 = load ptr, ptr @myself, align 8
  %ip273 = getelementptr inbounds %struct._clusterNode, ptr %132, i32 0, i32 21
  %arraydecay274 = getelementptr inbounds [46 x i8], ptr %ip273, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.87, ptr noundef %arraydecay274)
  br label %do.end275

do.end275:                                        ; preds = %if.end272, %if.then271
  call void @clusterDoBeforeSleep(i32 noundef 4)
  br label %if.end276

if.end276:                                        ; preds = %do.end275, %land.lhs.true258, %if.then253
  br label %if.end277

if.end277:                                        ; preds = %if.end276, %land.lhs.true250, %lor.lhs.false245
  %133 = load ptr, ptr %sender, align 8
  %tobool278 = icmp ne ptr %133, null
  br i1 %tobool278, label %if.end297, label %land.lhs.true279

land.lhs.true279:                                 ; preds = %if.end277
  %134 = load i16, ptr %type, align 2
  %conv280 = zext i16 %134 to i32
  %cmp281 = icmp eq i32 %conv280, 2
  br i1 %cmp281, label %if.then283, label %if.end297

if.then283:                                       ; preds = %land.lhs.true279
  %call284 = call ptr @createClusterNode(ptr noundef null, i32 noundef 32)
  store ptr %call284, ptr %node, align 8
  %135 = load ptr, ptr %node, align 8
  %ip285 = getelementptr inbounds %struct._clusterNode, ptr %135, i32 0, i32 21
  %arraydecay286 = getelementptr inbounds [46 x i8], ptr %ip285, i64 0, i64 0
  %136 = load ptr, ptr %link.addr, align 8
  %137 = load ptr, ptr %hdr, align 8
  %myip = getelementptr inbounds %struct.clusterMsg, ptr %137, i32 0, i32 12
  %arraydecay287 = getelementptr inbounds [46 x i8], ptr %myip, i64 0, i64 0
  %call288 = call i32 @nodeIp2String(ptr noundef %arraydecay286, ptr noundef %136, ptr noundef %arraydecay287)
  %cmp289 = icmp eq i32 %call288, 0
  %lnot = xor i1 %cmp289, true
  %lnot291 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot291 to i32
  %conv292 = sext i32 %lnot.ext to i64
  %tobool293 = icmp ne i64 %conv292, 0
  br i1 %tobool293, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then283
  br label %cond.end

cond.false:                                       ; preds = %if.then283
  call void @_serverAssert(ptr noundef @.str.88, ptr noundef @.str.18, i32 noundef 2808)
  call void @abort() #13
  unreachable

138:                                              ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %138, %cond.true
  %139 = load ptr, ptr %hdr, align 8
  %140 = load ptr, ptr %node, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %140, i32 0, i32 25
  %141 = load ptr, ptr %node, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %141, i32 0, i32 24
  call void @getClientPortFromClusterMsg(ptr noundef %139, ptr noundef %tls_port, ptr noundef %tcp_port)
  %142 = load ptr, ptr %hdr, align 8
  %cport = getelementptr inbounds %struct.clusterMsg, ptr %142, i32 0, i32 16
  %143 = load i16, ptr %cport, align 8
  %call294 = call zeroext i16 @ntohs(i16 noundef zeroext %143) #14
  %conv295 = zext i16 %call294 to i32
  %144 = load ptr, ptr %node, align 8
  %cport296 = getelementptr inbounds %struct._clusterNode, ptr %144, i32 0, i32 26
  store i32 %conv295, ptr %cport296, align 8
  %145 = load ptr, ptr %node, align 8
  call void @clusterAddNode(ptr noundef %145)
  call void @clusterDoBeforeSleep(i32 noundef 4)
  br label %if.end297

if.end297:                                        ; preds = %cond.end, %land.lhs.true279, %if.end277
  %146 = load ptr, ptr %sender, align 8
  %tobool298 = icmp ne ptr %146, null
  br i1 %tobool298, label %if.end304, label %land.lhs.true299

land.lhs.true299:                                 ; preds = %if.end297
  %147 = load i16, ptr %type, align 2
  %conv300 = zext i16 %147 to i32
  %cmp301 = icmp eq i32 %conv300, 2
  br i1 %cmp301, label %if.then303, label %if.end304

if.then303:                                       ; preds = %land.lhs.true299
  %148 = load ptr, ptr %hdr, align 8
  %149 = load ptr, ptr %link.addr, align 8
  call void @clusterProcessGossipSection(ptr noundef %148, ptr noundef %149)
  br label %if.end304

if.end304:                                        ; preds = %if.then303, %land.lhs.true299, %if.end297
  %150 = load ptr, ptr %link.addr, align 8
  call void @clusterSendPing(ptr noundef %150, i32 noundef 1)
  br label %if.end305

if.end305:                                        ; preds = %if.end304, %lor.lhs.false237
  %151 = load i16, ptr %type, align 2
  %conv306 = zext i16 %151 to i32
  %cmp307 = icmp eq i32 %conv306, 0
  br i1 %cmp307, label %if.then317, label %lor.lhs.false309

lor.lhs.false309:                                 ; preds = %if.end305
  %152 = load i16, ptr %type, align 2
  %conv310 = zext i16 %152 to i32
  %cmp311 = icmp eq i32 %conv310, 1
  br i1 %cmp311, label %if.then317, label %lor.lhs.false313

lor.lhs.false313:                                 ; preds = %lor.lhs.false309
  %153 = load i16, ptr %type, align 2
  %conv314 = zext i16 %153 to i32
  %cmp315 = icmp eq i32 %conv314, 2
  br i1 %cmp315, label %if.then317, label %if.else601

if.then317:                                       ; preds = %lor.lhs.false313, %lor.lhs.false309, %if.end305
  br label %do.body318

do.body318:                                       ; preds = %if.then317
  %154 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp319 = icmp slt i32 0, %154
  br i1 %cmp319, label %if.then321, label %if.end322

if.then321:                                       ; preds = %do.body318
  br label %do.end332

if.end322:                                        ; preds = %do.body318
  %155 = load i16, ptr %type, align 2
  %conv323 = zext i16 %155 to i32
  %call324 = call ptr @clusterGetMessageTypeString(i32 noundef %conv323)
  %156 = load ptr, ptr %link.addr, align 8
  %node325 = getelementptr inbounds %struct.clusterLink, ptr %156, i32 0, i32 8
  %157 = load ptr, ptr %node325, align 8
  %tobool326 = icmp ne ptr %157, null
  br i1 %tobool326, label %cond.true327, label %cond.false330

cond.true327:                                     ; preds = %if.end322
  %158 = load ptr, ptr %link.addr, align 8
  %node328 = getelementptr inbounds %struct.clusterLink, ptr %158, i32 0, i32 8
  %159 = load ptr, ptr %node328, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %159, i32 0, i32 1
  %arraydecay329 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  br label %cond.end331

cond.false330:                                    ; preds = %if.end322
  br label %cond.end331

cond.end331:                                      ; preds = %cond.false330, %cond.true327
  %cond = phi ptr [ %arraydecay329, %cond.true327 ], [ @.str.90, %cond.false330 ]
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.89, ptr noundef %call324, ptr noundef %cond)
  br label %do.end332

do.end332:                                        ; preds = %cond.end331, %if.then321
  %160 = load ptr, ptr %link.addr, align 8
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %160, i32 0, i32 9
  %161 = load i32, ptr %inbound, align 8
  %tobool333 = icmp ne i32 %161, 0
  br i1 %tobool333, label %if.end413, label %if.then334

if.then334:                                       ; preds = %do.end332
  %162 = load ptr, ptr %link.addr, align 8
  %node335 = getelementptr inbounds %struct.clusterLink, ptr %162, i32 0, i32 8
  %163 = load ptr, ptr %node335, align 8
  %flags336 = getelementptr inbounds %struct._clusterNode, ptr %163, i32 0, i32 3
  %164 = load i32, ptr %flags336, align 8
  %and337 = and i32 %164, 32
  %tobool338 = icmp ne i32 %and337, 0
  br i1 %tobool338, label %if.then339, label %if.else375

if.then339:                                       ; preds = %if.then334
  %165 = load ptr, ptr %sender, align 8
  %tobool340 = icmp ne ptr %165, null
  br i1 %tobool340, label %if.then341, label %if.end355

if.then341:                                       ; preds = %if.then339
  br label %do.body342

do.body342:                                       ; preds = %if.then341
  %166 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp343 = icmp slt i32 1, %166
  br i1 %cmp343, label %if.then345, label %if.end346

if.then345:                                       ; preds = %do.body342
  br label %do.end349

if.end346:                                        ; preds = %do.body342
  %167 = load ptr, ptr %sender, align 8
  %name347 = getelementptr inbounds %struct._clusterNode, ptr %167, i32 0, i32 1
  %arraydecay348 = getelementptr inbounds [40 x i8], ptr %name347, i64 0, i64 0
  %168 = load ptr, ptr %sender, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %168, i32 0, i32 23
  %169 = load ptr, ptr %human_nodename, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.91, ptr noundef %arraydecay348, ptr noundef %169)
  br label %do.end349

do.end349:                                        ; preds = %if.end346, %if.then345
  %170 = load ptr, ptr %sender, align 8
  %171 = load ptr, ptr %link.addr, align 8
  %172 = load ptr, ptr %hdr, align 8
  %call350 = call i32 @nodeUpdateAddressIfNeeded(ptr noundef %170, ptr noundef %171, ptr noundef %172)
  %tobool351 = icmp ne i32 %call350, 0
  br i1 %tobool351, label %if.then352, label %if.end353

if.then352:                                       ; preds = %do.end349
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end353

if.end353:                                        ; preds = %if.then352, %do.end349
  %173 = load ptr, ptr %link.addr, align 8
  %node354 = getelementptr inbounds %struct.clusterLink, ptr %173, i32 0, i32 8
  %174 = load ptr, ptr %node354, align 8
  call void @clusterDelNode(ptr noundef %174)
  store i32 0, ptr %retval, align 4
  br label %return

if.end355:                                        ; preds = %if.then339
  %175 = load ptr, ptr %link.addr, align 8
  %node356 = getelementptr inbounds %struct.clusterLink, ptr %175, i32 0, i32 8
  %176 = load ptr, ptr %node356, align 8
  %177 = load ptr, ptr %hdr, align 8
  %sender357 = getelementptr inbounds %struct.clusterMsg, ptr %177, i32 0, i32 9
  %arraydecay358 = getelementptr inbounds [40 x i8], ptr %sender357, i64 0, i64 0
  call void @clusterRenameNode(ptr noundef %176, ptr noundef %arraydecay358)
  br label %do.body359

do.body359:                                       ; preds = %if.end355
  %178 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp360 = icmp slt i32 0, %178
  br i1 %cmp360, label %if.then362, label %if.end363

if.then362:                                       ; preds = %do.body359
  br label %do.end367

if.end363:                                        ; preds = %do.body359
  %179 = load ptr, ptr %link.addr, align 8
  %node364 = getelementptr inbounds %struct.clusterLink, ptr %179, i32 0, i32 8
  %180 = load ptr, ptr %node364, align 8
  %name365 = getelementptr inbounds %struct._clusterNode, ptr %180, i32 0, i32 1
  %arraydecay366 = getelementptr inbounds [40 x i8], ptr %name365, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.92, ptr noundef %arraydecay366)
  br label %do.end367

do.end367:                                        ; preds = %if.end363, %if.then362
  %181 = load ptr, ptr %link.addr, align 8
  %node368 = getelementptr inbounds %struct.clusterLink, ptr %181, i32 0, i32 8
  %182 = load ptr, ptr %node368, align 8
  %flags369 = getelementptr inbounds %struct._clusterNode, ptr %182, i32 0, i32 3
  %183 = load i32, ptr %flags369, align 8
  %and370 = and i32 %183, -33
  store i32 %and370, ptr %flags369, align 8
  %184 = load i16, ptr %flags, align 2
  %conv371 = zext i16 %184 to i32
  %and372 = and i32 %conv371, 3
  %185 = load ptr, ptr %link.addr, align 8
  %node373 = getelementptr inbounds %struct.clusterLink, ptr %185, i32 0, i32 8
  %186 = load ptr, ptr %node373, align 8
  %flags374 = getelementptr inbounds %struct._clusterNode, ptr %186, i32 0, i32 3
  %187 = load i32, ptr %flags374, align 8
  %or = or i32 %187, %and372
  store i32 %or, ptr %flags374, align 8
  call void @clusterDoBeforeSleep(i32 noundef 4)
  br label %if.end412

if.else375:                                       ; preds = %if.then334
  %188 = load ptr, ptr %link.addr, align 8
  %node376 = getelementptr inbounds %struct.clusterLink, ptr %188, i32 0, i32 8
  %189 = load ptr, ptr %node376, align 8
  %name377 = getelementptr inbounds %struct._clusterNode, ptr %189, i32 0, i32 1
  %arraydecay378 = getelementptr inbounds [40 x i8], ptr %name377, i64 0, i64 0
  %190 = load ptr, ptr %hdr, align 8
  %sender379 = getelementptr inbounds %struct.clusterMsg, ptr %190, i32 0, i32 9
  %arraydecay380 = getelementptr inbounds [40 x i8], ptr %sender379, i64 0, i64 0
  %call381 = call i32 @memcmp(ptr noundef %arraydecay378, ptr noundef %arraydecay380, i64 noundef 40) #12
  %cmp382 = icmp ne i32 %call381, 0
  br i1 %cmp382, label %if.then384, label %if.end411

if.then384:                                       ; preds = %if.else375
  br label %do.body385

do.body385:                                       ; preds = %if.then384
  %191 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp386 = icmp slt i32 0, %191
  br i1 %cmp386, label %if.then388, label %if.end389

if.then388:                                       ; preds = %do.body385
  br label %do.end398

if.end389:                                        ; preds = %do.body385
  %192 = load ptr, ptr %link.addr, align 8
  %node390 = getelementptr inbounds %struct.clusterLink, ptr %192, i32 0, i32 8
  %193 = load ptr, ptr %node390, align 8
  %name391 = getelementptr inbounds %struct._clusterNode, ptr %193, i32 0, i32 1
  %arraydecay392 = getelementptr inbounds [40 x i8], ptr %name391, i64 0, i64 0
  %194 = load i64, ptr %now, align 8
  %195 = load ptr, ptr %link.addr, align 8
  %node393 = getelementptr inbounds %struct.clusterLink, ptr %195, i32 0, i32 8
  %196 = load ptr, ptr %node393, align 8
  %ctime = getelementptr inbounds %struct._clusterNode, ptr %196, i32 0, i32 0
  %197 = load i64, ptr %ctime, align 8
  %sub394 = sub nsw i64 %194, %197
  %conv395 = trunc i64 %sub394 to i32
  %198 = load ptr, ptr %link.addr, align 8
  %node396 = getelementptr inbounds %struct.clusterLink, ptr %198, i32 0, i32 8
  %199 = load ptr, ptr %node396, align 8
  %flags397 = getelementptr inbounds %struct._clusterNode, ptr %199, i32 0, i32 3
  %200 = load i32, ptr %flags397, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.93, ptr noundef %arraydecay392, i32 noundef %conv395, i32 noundef %200)
  br label %do.end398

do.end398:                                        ; preds = %if.end389, %if.then388
  %201 = load ptr, ptr %link.addr, align 8
  %node399 = getelementptr inbounds %struct.clusterLink, ptr %201, i32 0, i32 8
  %202 = load ptr, ptr %node399, align 8
  %flags400 = getelementptr inbounds %struct._clusterNode, ptr %202, i32 0, i32 3
  %203 = load i32, ptr %flags400, align 8
  %or401 = or i32 %203, 64
  store i32 %or401, ptr %flags400, align 8
  %204 = load ptr, ptr %link.addr, align 8
  %node402 = getelementptr inbounds %struct.clusterLink, ptr %204, i32 0, i32 8
  %205 = load ptr, ptr %node402, align 8
  %ip403 = getelementptr inbounds %struct._clusterNode, ptr %205, i32 0, i32 21
  %arrayidx404 = getelementptr inbounds [46 x i8], ptr %ip403, i64 0, i64 0
  store i8 0, ptr %arrayidx404, align 8
  %206 = load ptr, ptr %link.addr, align 8
  %node405 = getelementptr inbounds %struct.clusterLink, ptr %206, i32 0, i32 8
  %207 = load ptr, ptr %node405, align 8
  %tcp_port406 = getelementptr inbounds %struct._clusterNode, ptr %207, i32 0, i32 24
  store i32 0, ptr %tcp_port406, align 8
  %208 = load ptr, ptr %link.addr, align 8
  %node407 = getelementptr inbounds %struct.clusterLink, ptr %208, i32 0, i32 8
  %209 = load ptr, ptr %node407, align 8
  %tls_port408 = getelementptr inbounds %struct._clusterNode, ptr %209, i32 0, i32 25
  store i32 0, ptr %tls_port408, align 4
  %210 = load ptr, ptr %link.addr, align 8
  %node409 = getelementptr inbounds %struct.clusterLink, ptr %210, i32 0, i32 8
  %211 = load ptr, ptr %node409, align 8
  %cport410 = getelementptr inbounds %struct._clusterNode, ptr %211, i32 0, i32 26
  store i32 0, ptr %cport410, align 8
  %212 = load ptr, ptr %link.addr, align 8
  call void @freeClusterLink(ptr noundef %212)
  call void @clusterDoBeforeSleep(i32 noundef 4)
  store i32 0, ptr %retval, align 4
  br label %return

if.end411:                                        ; preds = %if.else375
  br label %if.end412

if.end412:                                        ; preds = %if.end411, %do.end367
  br label %if.end413

if.end413:                                        ; preds = %if.end412, %do.end332
  %213 = load ptr, ptr %sender, align 8
  %tobool414 = icmp ne ptr %213, null
  br i1 %tobool414, label %if.then415, label %if.end422

if.then415:                                       ; preds = %if.end413
  %214 = load i16, ptr %flags, align 2
  %conv416 = zext i16 %214 to i32
  %and417 = and i32 %conv416, 512
  store i32 %and417, ptr %nofailover, align 4
  %215 = load ptr, ptr %sender, align 8
  %flags418 = getelementptr inbounds %struct._clusterNode, ptr %215, i32 0, i32 3
  %216 = load i32, ptr %flags418, align 8
  %and419 = and i32 %216, -513
  store i32 %and419, ptr %flags418, align 8
  %217 = load i32, ptr %nofailover, align 4
  %218 = load ptr, ptr %sender, align 8
  %flags420 = getelementptr inbounds %struct._clusterNode, ptr %218, i32 0, i32 3
  %219 = load i32, ptr %flags420, align 8
  %or421 = or i32 %219, %217
  store i32 %or421, ptr %flags420, align 8
  br label %if.end422

if.end422:                                        ; preds = %if.then415, %if.end413
  %220 = load ptr, ptr %sender, align 8
  %tobool423 = icmp ne ptr %220, null
  br i1 %tobool423, label %land.lhs.true424, label %if.end436

land.lhs.true424:                                 ; preds = %if.end422
  %221 = load i16, ptr %type, align 2
  %conv425 = zext i16 %221 to i32
  %cmp426 = icmp eq i32 %conv425, 0
  br i1 %cmp426, label %land.lhs.true428, label %if.end436

land.lhs.true428:                                 ; preds = %land.lhs.true424
  %222 = load ptr, ptr %sender, align 8
  %flags429 = getelementptr inbounds %struct._clusterNode, ptr %222, i32 0, i32 3
  %223 = load i32, ptr %flags429, align 8
  %and430 = and i32 %223, 32
  %tobool431 = icmp ne i32 %and430, 0
  br i1 %tobool431, label %if.end436, label %land.lhs.true432

land.lhs.true432:                                 ; preds = %land.lhs.true428
  %224 = load ptr, ptr %sender, align 8
  %225 = load ptr, ptr %link.addr, align 8
  %226 = load ptr, ptr %hdr, align 8
  %call433 = call i32 @nodeUpdateAddressIfNeeded(ptr noundef %224, ptr noundef %225, ptr noundef %226)
  %tobool434 = icmp ne i32 %call433, 0
  br i1 %tobool434, label %if.then435, label %if.end436

if.then435:                                       ; preds = %land.lhs.true432
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end436

if.end436:                                        ; preds = %if.then435, %land.lhs.true432, %land.lhs.true428, %land.lhs.true424, %if.end422
  %227 = load ptr, ptr %link.addr, align 8
  %inbound437 = getelementptr inbounds %struct.clusterLink, ptr %227, i32 0, i32 9
  %228 = load i32, ptr %inbound437, align 8
  %tobool438 = icmp ne i32 %228, 0
  br i1 %tobool438, label %if.end463, label %land.lhs.true439

land.lhs.true439:                                 ; preds = %if.end436
  %229 = load i16, ptr %type, align 2
  %conv440 = zext i16 %229 to i32
  %cmp441 = icmp eq i32 %conv440, 1
  br i1 %cmp441, label %if.then443, label %if.end463

if.then443:                                       ; preds = %land.lhs.true439
  %230 = load i64, ptr %now, align 8
  %231 = load ptr, ptr %link.addr, align 8
  %node444 = getelementptr inbounds %struct.clusterLink, ptr %231, i32 0, i32 8
  %232 = load ptr, ptr %node444, align 8
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %232, i32 0, i32 14
  store i64 %230, ptr %pong_received, align 8
  %233 = load ptr, ptr %link.addr, align 8
  %node445 = getelementptr inbounds %struct.clusterLink, ptr %233, i32 0, i32 8
  %234 = load ptr, ptr %node445, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %234, i32 0, i32 13
  store i64 0, ptr %ping_sent, align 8
  %235 = load ptr, ptr %link.addr, align 8
  %node446 = getelementptr inbounds %struct.clusterLink, ptr %235, i32 0, i32 8
  %236 = load ptr, ptr %node446, align 8
  %flags447 = getelementptr inbounds %struct._clusterNode, ptr %236, i32 0, i32 3
  %237 = load i32, ptr %flags447, align 8
  %and448 = and i32 %237, 4
  %tobool449 = icmp ne i32 %and448, 0
  br i1 %tobool449, label %if.then450, label %if.else454

if.then450:                                       ; preds = %if.then443
  %238 = load ptr, ptr %link.addr, align 8
  %node451 = getelementptr inbounds %struct.clusterLink, ptr %238, i32 0, i32 8
  %239 = load ptr, ptr %node451, align 8
  %flags452 = getelementptr inbounds %struct._clusterNode, ptr %239, i32 0, i32 3
  %240 = load i32, ptr %flags452, align 8
  %and453 = and i32 %240, -5
  store i32 %and453, ptr %flags452, align 8
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end462

if.else454:                                       ; preds = %if.then443
  %241 = load ptr, ptr %link.addr, align 8
  %node455 = getelementptr inbounds %struct.clusterLink, ptr %241, i32 0, i32 8
  %242 = load ptr, ptr %node455, align 8
  %flags456 = getelementptr inbounds %struct._clusterNode, ptr %242, i32 0, i32 3
  %243 = load i32, ptr %flags456, align 8
  %and457 = and i32 %243, 8
  %tobool458 = icmp ne i32 %and457, 0
  br i1 %tobool458, label %if.then459, label %if.end461

if.then459:                                       ; preds = %if.else454
  %244 = load ptr, ptr %link.addr, align 8
  %node460 = getelementptr inbounds %struct.clusterLink, ptr %244, i32 0, i32 8
  %245 = load ptr, ptr %node460, align 8
  call void @clearNodeFailureIfNeeded(ptr noundef %245)
  br label %if.end461

if.end461:                                        ; preds = %if.then459, %if.else454
  br label %if.end462

if.end462:                                        ; preds = %if.end461, %if.then450
  br label %if.end463

if.end463:                                        ; preds = %if.end462, %land.lhs.true439, %if.end436
  %246 = load ptr, ptr %sender, align 8
  %tobool464 = icmp ne ptr %246, null
  br i1 %tobool464, label %if.then465, label %if.end500

if.then465:                                       ; preds = %if.end463
  %247 = load ptr, ptr %hdr, align 8
  %slaveof466 = getelementptr inbounds %struct.clusterMsg, ptr %247, i32 0, i32 11
  %arraydecay467 = getelementptr inbounds [40 x i8], ptr %slaveof466, i64 0, i64 0
  %call468 = call i32 @memcmp(ptr noundef %arraydecay467, ptr noundef @.str.94, i64 noundef 40) #12
  %tobool469 = icmp ne i32 %call468, 0
  br i1 %tobool469, label %if.else471, label %if.then470

if.then470:                                       ; preds = %if.then465
  %248 = load ptr, ptr %sender, align 8
  call void @clusterSetNodeAsMaster(ptr noundef %248)
  br label %if.end499

if.else471:                                       ; preds = %if.then465
  %249 = load ptr, ptr %hdr, align 8
  %slaveof472 = getelementptr inbounds %struct.clusterMsg, ptr %249, i32 0, i32 11
  %arraydecay473 = getelementptr inbounds [40 x i8], ptr %slaveof472, i64 0, i64 0
  %call474 = call ptr @clusterLookupNode(ptr noundef %arraydecay473, i32 noundef 40)
  store ptr %call474, ptr %master, align 8
  %250 = load ptr, ptr %sender, align 8
  %call475 = call i32 @clusterNodeIsMaster(ptr noundef %250)
  %tobool476 = icmp ne i32 %call475, 0
  br i1 %tobool476, label %if.then477, label %if.end483

if.then477:                                       ; preds = %if.else471
  %251 = load ptr, ptr %sender, align 8
  %call478 = call i32 @clusterDelNodeSlots(ptr noundef %251)
  %252 = load ptr, ptr %sender, align 8
  %flags479 = getelementptr inbounds %struct._clusterNode, ptr %252, i32 0, i32 3
  %253 = load i32, ptr %flags479, align 8
  %and480 = and i32 %253, -258
  store i32 %and480, ptr %flags479, align 8
  %254 = load ptr, ptr %sender, align 8
  %flags481 = getelementptr inbounds %struct._clusterNode, ptr %254, i32 0, i32 3
  %255 = load i32, ptr %flags481, align 8
  %or482 = or i32 %255, 2
  store i32 %or482, ptr %flags481, align 8
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end483

if.end483:                                        ; preds = %if.then477, %if.else471
  %256 = load ptr, ptr %master, align 8
  %tobool484 = icmp ne ptr %256, null
  br i1 %tobool484, label %land.lhs.true485, label %if.end498

land.lhs.true485:                                 ; preds = %if.end483
  %257 = load ptr, ptr %sender, align 8
  %slaveof486 = getelementptr inbounds %struct._clusterNode, ptr %257, i32 0, i32 11
  %258 = load ptr, ptr %slaveof486, align 8
  %259 = load ptr, ptr %master, align 8
  %cmp487 = icmp ne ptr %258, %259
  br i1 %cmp487, label %if.then489, label %if.end498

if.then489:                                       ; preds = %land.lhs.true485
  %260 = load ptr, ptr %sender, align 8
  %slaveof490 = getelementptr inbounds %struct._clusterNode, ptr %260, i32 0, i32 11
  %261 = load ptr, ptr %slaveof490, align 8
  %tobool491 = icmp ne ptr %261, null
  br i1 %tobool491, label %if.then492, label %if.end495

if.then492:                                       ; preds = %if.then489
  %262 = load ptr, ptr %sender, align 8
  %slaveof493 = getelementptr inbounds %struct._clusterNode, ptr %262, i32 0, i32 11
  %263 = load ptr, ptr %slaveof493, align 8
  %264 = load ptr, ptr %sender, align 8
  %call494 = call i32 @clusterNodeRemoveSlave(ptr noundef %263, ptr noundef %264)
  br label %if.end495

if.end495:                                        ; preds = %if.then492, %if.then489
  %265 = load ptr, ptr %master, align 8
  %266 = load ptr, ptr %sender, align 8
  %call496 = call i32 @clusterNodeAddSlave(ptr noundef %265, ptr noundef %266)
  %267 = load ptr, ptr %master, align 8
  %268 = load ptr, ptr %sender, align 8
  %slaveof497 = getelementptr inbounds %struct._clusterNode, ptr %268, i32 0, i32 11
  store ptr %267, ptr %slaveof497, align 8
  call void @clusterDoBeforeSleep(i32 noundef 4)
  br label %if.end498

if.end498:                                        ; preds = %if.end495, %land.lhs.true485, %if.end483
  br label %if.end499

if.end499:                                        ; preds = %if.end498, %if.then470
  br label %if.end500

if.end500:                                        ; preds = %if.end499, %if.end463
  store ptr null, ptr %sender_master, align 8
  store i32 0, ptr %dirty_slots, align 4
  %269 = load ptr, ptr %sender, align 8
  %tobool501 = icmp ne ptr %269, null
  br i1 %tobool501, label %if.then502, label %if.end518

if.then502:                                       ; preds = %if.end500
  %270 = load ptr, ptr %sender, align 8
  %call503 = call i32 @clusterNodeIsMaster(ptr noundef %270)
  %tobool504 = icmp ne i32 %call503, 0
  br i1 %tobool504, label %cond.true505, label %cond.false506

cond.true505:                                     ; preds = %if.then502
  %271 = load ptr, ptr %sender, align 8
  br label %cond.end508

cond.false506:                                    ; preds = %if.then502
  %272 = load ptr, ptr %sender, align 8
  %slaveof507 = getelementptr inbounds %struct._clusterNode, ptr %272, i32 0, i32 11
  %273 = load ptr, ptr %slaveof507, align 8
  br label %cond.end508

cond.end508:                                      ; preds = %cond.false506, %cond.true505
  %cond509 = phi ptr [ %271, %cond.true505 ], [ %273, %cond.false506 ]
  store ptr %cond509, ptr %sender_master, align 8
  %274 = load ptr, ptr %sender_master, align 8
  %tobool510 = icmp ne ptr %274, null
  br i1 %tobool510, label %if.then511, label %if.end517

if.then511:                                       ; preds = %cond.end508
  %275 = load ptr, ptr %sender_master, align 8
  %slots = getelementptr inbounds %struct._clusterNode, ptr %275, i32 0, i32 5
  %arraydecay512 = getelementptr inbounds [2048 x i8], ptr %slots, i64 0, i64 0
  %276 = load ptr, ptr %hdr, align 8
  %myslots = getelementptr inbounds %struct.clusterMsg, ptr %276, i32 0, i32 10
  %arraydecay513 = getelementptr inbounds [2048 x i8], ptr %myslots, i64 0, i64 0
  %call514 = call i32 @memcmp(ptr noundef %arraydecay512, ptr noundef %arraydecay513, i64 noundef 2048) #12
  %cmp515 = icmp ne i32 %call514, 0
  %conv516 = zext i1 %cmp515 to i32
  store i32 %conv516, ptr %dirty_slots, align 4
  br label %if.end517

if.end517:                                        ; preds = %if.then511, %cond.end508
  br label %if.end518

if.end518:                                        ; preds = %if.end517, %if.end500
  %277 = load ptr, ptr %sender, align 8
  %tobool519 = icmp ne ptr %277, null
  br i1 %tobool519, label %land.lhs.true520, label %if.end528

land.lhs.true520:                                 ; preds = %if.end518
  %278 = load ptr, ptr %sender, align 8
  %call521 = call i32 @clusterNodeIsMaster(ptr noundef %278)
  %tobool522 = icmp ne i32 %call521, 0
  br i1 %tobool522, label %land.lhs.true523, label %if.end528

land.lhs.true523:                                 ; preds = %land.lhs.true520
  %279 = load i32, ptr %dirty_slots, align 4
  %tobool524 = icmp ne i32 %279, 0
  br i1 %tobool524, label %if.then525, label %if.end528

if.then525:                                       ; preds = %land.lhs.true523
  %280 = load ptr, ptr %sender, align 8
  %281 = load i64, ptr %senderConfigEpoch, align 8
  %282 = load ptr, ptr %hdr, align 8
  %myslots526 = getelementptr inbounds %struct.clusterMsg, ptr %282, i32 0, i32 10
  %arraydecay527 = getelementptr inbounds [2048 x i8], ptr %myslots526, i64 0, i64 0
  call void @clusterUpdateSlotsConfigWith(ptr noundef %280, i64 noundef %281, ptr noundef %arraydecay527)
  br label %if.end528

if.end528:                                        ; preds = %if.then525, %land.lhs.true523, %land.lhs.true520, %if.end518
  %283 = load ptr, ptr %sender, align 8
  %tobool529 = icmp ne ptr %283, null
  br i1 %tobool529, label %land.lhs.true530, label %if.end584

land.lhs.true530:                                 ; preds = %if.end528
  %284 = load i32, ptr %dirty_slots, align 4
  %tobool531 = icmp ne i32 %284, 0
  br i1 %tobool531, label %if.then532, label %if.end584

if.then532:                                       ; preds = %land.lhs.true530
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then532
  %285 = load i32, ptr %j, align 4
  %cmp533 = icmp slt i32 %285, 16384
  br i1 %cmp533, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %286 = load ptr, ptr %hdr, align 8
  %myslots535 = getelementptr inbounds %struct.clusterMsg, ptr %286, i32 0, i32 10
  %arraydecay536 = getelementptr inbounds [2048 x i8], ptr %myslots535, i64 0, i64 0
  %287 = load i32, ptr %j, align 4
  %call537 = call i32 @bitmapTestBit(ptr noundef %arraydecay536, i32 noundef %287)
  %tobool538 = icmp ne i32 %call537, 0
  br i1 %tobool538, label %if.then539, label %if.end582

if.then539:                                       ; preds = %for.body
  %288 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots540 = getelementptr inbounds %struct.clusterState, ptr %288, i32 0, i32 9
  %289 = load i32, ptr %j, align 4
  %idxprom541 = sext i32 %289 to i64
  %arrayidx542 = getelementptr inbounds [16384 x ptr], ptr %slots540, i64 0, i64 %idxprom541
  %290 = load ptr, ptr %arrayidx542, align 8
  %291 = load ptr, ptr %sender, align 8
  %cmp543 = icmp eq ptr %290, %291
  br i1 %cmp543, label %if.then555, label %lor.lhs.false545

lor.lhs.false545:                                 ; preds = %if.then539
  %292 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots546 = getelementptr inbounds %struct.clusterState, ptr %292, i32 0, i32 9
  %293 = load i32, ptr %j, align 4
  %idxprom547 = sext i32 %293 to i64
  %arrayidx548 = getelementptr inbounds [16384 x ptr], ptr %slots546, i64 0, i64 %idxprom547
  %294 = load ptr, ptr %arrayidx548, align 8
  %cmp549 = icmp eq ptr %294, null
  br i1 %cmp549, label %if.then555, label %lor.lhs.false551

lor.lhs.false551:                                 ; preds = %lor.lhs.false545
  %295 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %295, i32 0, i32 27
  %arraydecay552 = getelementptr inbounds [2048 x i8], ptr %owner_not_claiming_slot, i64 0, i64 0
  %296 = load i32, ptr %j, align 4
  %call553 = call i32 @bitmapTestBit(ptr noundef %arraydecay552, i32 noundef %296)
  %tobool554 = icmp ne i32 %call553, 0
  br i1 %tobool554, label %if.then555, label %if.end556

if.then555:                                       ; preds = %lor.lhs.false551, %lor.lhs.false545, %if.then539
  br label %for.inc

if.end556:                                        ; preds = %lor.lhs.false551
  %297 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots557 = getelementptr inbounds %struct.clusterState, ptr %297, i32 0, i32 9
  %298 = load i32, ptr %j, align 4
  %idxprom558 = sext i32 %298 to i64
  %arrayidx559 = getelementptr inbounds [16384 x ptr], ptr %slots557, i64 0, i64 %idxprom558
  %299 = load ptr, ptr %arrayidx559, align 8
  %configEpoch560 = getelementptr inbounds %struct._clusterNode, ptr %299, i32 0, i32 4
  %300 = load i64, ptr %configEpoch560, align 8
  %301 = load i64, ptr %senderConfigEpoch, align 8
  %cmp561 = icmp ugt i64 %300, %301
  br i1 %cmp561, label %if.then563, label %if.end581

if.then563:                                       ; preds = %if.end556
  br label %do.body564

do.body564:                                       ; preds = %if.then563
  %302 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp565 = icmp slt i32 1, %302
  br i1 %cmp565, label %if.then567, label %if.end568

if.then567:                                       ; preds = %do.body564
  br label %do.end576

if.end568:                                        ; preds = %do.body564
  %303 = load ptr, ptr %sender, align 8
  %name569 = getelementptr inbounds %struct._clusterNode, ptr %303, i32 0, i32 1
  %arraydecay570 = getelementptr inbounds [40 x i8], ptr %name569, i64 0, i64 0
  %304 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots571 = getelementptr inbounds %struct.clusterState, ptr %304, i32 0, i32 9
  %305 = load i32, ptr %j, align 4
  %idxprom572 = sext i32 %305 to i64
  %arrayidx573 = getelementptr inbounds [16384 x ptr], ptr %slots571, i64 0, i64 %idxprom572
  %306 = load ptr, ptr %arrayidx573, align 8
  %name574 = getelementptr inbounds %struct._clusterNode, ptr %306, i32 0, i32 1
  %arraydecay575 = getelementptr inbounds [40 x i8], ptr %name574, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.95, ptr noundef %arraydecay570, ptr noundef %arraydecay575)
  br label %do.end576

do.end576:                                        ; preds = %if.end568, %if.then567
  %307 = load ptr, ptr %sender, align 8
  %link577 = getelementptr inbounds %struct._clusterNode, ptr %307, i32 0, i32 27
  %308 = load ptr, ptr %link577, align 8
  %309 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots578 = getelementptr inbounds %struct.clusterState, ptr %309, i32 0, i32 9
  %310 = load i32, ptr %j, align 4
  %idxprom579 = sext i32 %310 to i64
  %arrayidx580 = getelementptr inbounds [16384 x ptr], ptr %slots578, i64 0, i64 %idxprom579
  %311 = load ptr, ptr %arrayidx580, align 8
  call void @clusterSendUpdate(ptr noundef %308, ptr noundef %311)
  br label %for.end

if.end581:                                        ; preds = %if.end556
  br label %if.end582

if.end582:                                        ; preds = %if.end581, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end582, %if.then555
  %312 = load i32, ptr %j, align 4
  %inc583 = add nsw i32 %312, 1
  store i32 %inc583, ptr %j, align 4
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %do.end576, %for.cond
  br label %if.end584

if.end584:                                        ; preds = %for.end, %land.lhs.true530, %if.end528
  %313 = load ptr, ptr %sender, align 8
  %tobool585 = icmp ne ptr %313, null
  br i1 %tobool585, label %land.lhs.true586, label %if.end597

land.lhs.true586:                                 ; preds = %if.end584
  %314 = load ptr, ptr @myself, align 8
  %call587 = call i32 @clusterNodeIsMaster(ptr noundef %314)
  %tobool588 = icmp ne i32 %call587, 0
  br i1 %tobool588, label %land.lhs.true589, label %if.end597

land.lhs.true589:                                 ; preds = %land.lhs.true586
  %315 = load ptr, ptr %sender, align 8
  %call590 = call i32 @clusterNodeIsMaster(ptr noundef %315)
  %tobool591 = icmp ne i32 %call590, 0
  br i1 %tobool591, label %land.lhs.true592, label %if.end597

land.lhs.true592:                                 ; preds = %land.lhs.true589
  %316 = load i64, ptr %senderConfigEpoch, align 8
  %317 = load ptr, ptr @myself, align 8
  %configEpoch593 = getelementptr inbounds %struct._clusterNode, ptr %317, i32 0, i32 4
  %318 = load i64, ptr %configEpoch593, align 8
  %cmp594 = icmp eq i64 %316, %318
  br i1 %cmp594, label %if.then596, label %if.end597

if.then596:                                       ; preds = %land.lhs.true592
  %319 = load ptr, ptr %sender, align 8
  call void @clusterHandleConfigEpochCollision(ptr noundef %319)
  br label %if.end597

if.end597:                                        ; preds = %if.then596, %land.lhs.true592, %land.lhs.true589, %land.lhs.true586, %if.end584
  %320 = load ptr, ptr %sender, align 8
  %tobool598 = icmp ne ptr %320, null
  br i1 %tobool598, label %if.then599, label %if.end600

if.then599:                                       ; preds = %if.end597
  %321 = load ptr, ptr %hdr, align 8
  %322 = load ptr, ptr %link.addr, align 8
  call void @clusterProcessGossipSection(ptr noundef %321, ptr noundef %322)
  %323 = load ptr, ptr %hdr, align 8
  %324 = load ptr, ptr %link.addr, align 8
  call void @clusterProcessPingExtensions(ptr noundef %323, ptr noundef %324)
  br label %if.end600

if.end600:                                        ; preds = %if.then599, %if.end597
  br label %if.end830

if.else601:                                       ; preds = %lor.lhs.false313
  %325 = load i16, ptr %type, align 2
  %conv602 = zext i16 %325 to i32
  %cmp603 = icmp eq i32 %conv602, 3
  br i1 %cmp603, label %if.then605, label %if.else650

if.then605:                                       ; preds = %if.else601
  %326 = load ptr, ptr %sender, align 8
  %tobool606 = icmp ne ptr %326, null
  br i1 %tobool606, label %if.then607, label %if.else636

if.then607:                                       ; preds = %if.then605
  %327 = load ptr, ptr %hdr, align 8
  %data608 = getelementptr inbounds %struct.clusterMsg, ptr %327, i32 0, i32 20
  %about = getelementptr inbounds %struct.anon.1, ptr %data608, i32 0, i32 0
  %nodename = getelementptr inbounds %struct.clusterMsgDataFail, ptr %about, i32 0, i32 0
  %arraydecay609 = getelementptr inbounds [40 x i8], ptr %nodename, i64 0, i64 0
  %call610 = call ptr @clusterLookupNode(ptr noundef %arraydecay609, i32 noundef 40)
  store ptr %call610, ptr %failing, align 8
  %328 = load ptr, ptr %failing, align 8
  %tobool611 = icmp ne ptr %328, null
  br i1 %tobool611, label %land.lhs.true612, label %if.end635

land.lhs.true612:                                 ; preds = %if.then607
  %329 = load ptr, ptr %failing, align 8
  %flags613 = getelementptr inbounds %struct._clusterNode, ptr %329, i32 0, i32 3
  %330 = load i32, ptr %flags613, align 8
  %and614 = and i32 %330, 24
  %tobool615 = icmp ne i32 %and614, 0
  br i1 %tobool615, label %if.end635, label %if.then616

if.then616:                                       ; preds = %land.lhs.true612
  br label %do.body617

do.body617:                                       ; preds = %if.then616
  %331 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp618 = icmp slt i32 2, %331
  br i1 %cmp618, label %if.then620, label %if.end621

if.then620:                                       ; preds = %do.body617
  br label %do.end630

if.end621:                                        ; preds = %do.body617
  %332 = load ptr, ptr %hdr, align 8
  %sender622 = getelementptr inbounds %struct.clusterMsg, ptr %332, i32 0, i32 9
  %arraydecay623 = getelementptr inbounds [40 x i8], ptr %sender622, i64 0, i64 0
  %333 = load ptr, ptr %sender, align 8
  %human_nodename624 = getelementptr inbounds %struct._clusterNode, ptr %333, i32 0, i32 23
  %334 = load ptr, ptr %human_nodename624, align 8
  %335 = load ptr, ptr %hdr, align 8
  %data625 = getelementptr inbounds %struct.clusterMsg, ptr %335, i32 0, i32 20
  %about626 = getelementptr inbounds %struct.anon.1, ptr %data625, i32 0, i32 0
  %nodename627 = getelementptr inbounds %struct.clusterMsgDataFail, ptr %about626, i32 0, i32 0
  %arraydecay628 = getelementptr inbounds [40 x i8], ptr %nodename627, i64 0, i64 0
  %336 = load ptr, ptr %failing, align 8
  %human_nodename629 = getelementptr inbounds %struct._clusterNode, ptr %336, i32 0, i32 23
  %337 = load ptr, ptr %human_nodename629, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.96, ptr noundef %arraydecay623, ptr noundef %334, ptr noundef %arraydecay628, ptr noundef %337)
  br label %do.end630

do.end630:                                        ; preds = %if.end621, %if.then620
  %338 = load ptr, ptr %failing, align 8
  %flags631 = getelementptr inbounds %struct._clusterNode, ptr %338, i32 0, i32 3
  %339 = load i32, ptr %flags631, align 8
  %or632 = or i32 %339, 8
  store i32 %or632, ptr %flags631, align 8
  %340 = load i64, ptr %now, align 8
  %341 = load ptr, ptr %failing, align 8
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %341, i32 0, i32 16
  store i64 %340, ptr %fail_time, align 8
  %342 = load ptr, ptr %failing, align 8
  %flags633 = getelementptr inbounds %struct._clusterNode, ptr %342, i32 0, i32 3
  %343 = load i32, ptr %flags633, align 8
  %and634 = and i32 %343, -5
  store i32 %and634, ptr %flags633, align 8
  call void @clusterDoBeforeSleep(i32 noundef 6)
  br label %if.end635

if.end635:                                        ; preds = %do.end630, %land.lhs.true612, %if.then607
  br label %if.end649

if.else636:                                       ; preds = %if.then605
  br label %do.body637

do.body637:                                       ; preds = %if.else636
  %344 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp638 = icmp slt i32 2, %344
  br i1 %cmp638, label %if.then640, label %if.end641

if.then640:                                       ; preds = %do.body637
  br label %do.end648

if.end641:                                        ; preds = %do.body637
  %345 = load ptr, ptr %hdr, align 8
  %sender642 = getelementptr inbounds %struct.clusterMsg, ptr %345, i32 0, i32 9
  %arraydecay643 = getelementptr inbounds [40 x i8], ptr %sender642, i64 0, i64 0
  %346 = load ptr, ptr %hdr, align 8
  %data644 = getelementptr inbounds %struct.clusterMsg, ptr %346, i32 0, i32 20
  %about645 = getelementptr inbounds %struct.anon.1, ptr %data644, i32 0, i32 0
  %nodename646 = getelementptr inbounds %struct.clusterMsgDataFail, ptr %about645, i32 0, i32 0
  %arraydecay647 = getelementptr inbounds [40 x i8], ptr %nodename646, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.97, ptr noundef %arraydecay643, ptr noundef %arraydecay647)
  br label %do.end648

do.end648:                                        ; preds = %if.end641, %if.then640
  br label %if.end649

if.end649:                                        ; preds = %do.end648, %if.end635
  br label %if.end829

if.else650:                                       ; preds = %if.else601
  %347 = load i16, ptr %type, align 2
  %conv651 = zext i16 %347 to i32
  %cmp652 = icmp eq i32 %conv651, 4
  br i1 %cmp652, label %if.then658, label %lor.lhs.false654

lor.lhs.false654:                                 ; preds = %if.else650
  %348 = load i16, ptr %type, align 2
  %conv655 = zext i16 %348 to i32
  %cmp656 = icmp eq i32 %conv655, 10
  br i1 %cmp656, label %if.then658, label %if.else704

if.then658:                                       ; preds = %lor.lhs.false654, %if.else650
  %349 = load ptr, ptr %sender, align 8
  %tobool659 = icmp ne ptr %349, null
  br i1 %tobool659, label %if.end661, label %if.then660

if.then660:                                       ; preds = %if.then658
  store i32 1, ptr %retval, align 4
  br label %return

if.end661:                                        ; preds = %if.then658
  %350 = load i16, ptr %type, align 2
  %conv664 = zext i16 %350 to i32
  %cmp665 = icmp eq i32 %conv664, 4
  br i1 %cmp665, label %land.lhs.true667, label %lor.lhs.false671

land.lhs.true667:                                 ; preds = %if.end661
  %call668 = call i32 @serverPubsubSubscriptionCount()
  %cmp669 = icmp sgt i32 %call668, 0
  br i1 %cmp669, label %if.then679, label %lor.lhs.false671

lor.lhs.false671:                                 ; preds = %land.lhs.true667, %if.end661
  %351 = load i16, ptr %type, align 2
  %conv672 = zext i16 %351 to i32
  %cmp673 = icmp eq i32 %conv672, 10
  br i1 %cmp673, label %land.lhs.true675, label %if.end703

land.lhs.true675:                                 ; preds = %lor.lhs.false671
  %call676 = call i32 @serverPubsubShardSubscriptionCount()
  %cmp677 = icmp sgt i32 %call676, 0
  br i1 %cmp677, label %if.then679, label %if.end703

if.then679:                                       ; preds = %land.lhs.true675, %land.lhs.true667
  %352 = load ptr, ptr %hdr, align 8
  %data680 = getelementptr inbounds %struct.clusterMsg, ptr %352, i32 0, i32 20
  %msg681 = getelementptr inbounds %struct.anon.2, ptr %data680, i32 0, i32 0
  %channel_len682 = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg681, i32 0, i32 0
  %353 = load i32, ptr %channel_len682, align 8
  %call683 = call i32 @ntohl(i32 noundef %353) #14
  store i32 %call683, ptr %channel_len662, align 4
  %354 = load ptr, ptr %hdr, align 8
  %data684 = getelementptr inbounds %struct.clusterMsg, ptr %354, i32 0, i32 20
  %msg685 = getelementptr inbounds %struct.anon.2, ptr %data684, i32 0, i32 0
  %message_len686 = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg685, i32 0, i32 1
  %355 = load i32, ptr %message_len686, align 4
  %call687 = call i32 @ntohl(i32 noundef %355) #14
  store i32 %call687, ptr %message_len663, align 4
  %356 = load ptr, ptr %hdr, align 8
  %data688 = getelementptr inbounds %struct.clusterMsg, ptr %356, i32 0, i32 20
  %msg689 = getelementptr inbounds %struct.anon.2, ptr %data688, i32 0, i32 0
  %bulk_data = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg689, i32 0, i32 2
  %arraydecay690 = getelementptr inbounds [8 x i8], ptr %bulk_data, i64 0, i64 0
  %357 = load i32, ptr %channel_len662, align 4
  %conv691 = zext i32 %357 to i64
  %call692 = call ptr @createStringObject(ptr noundef %arraydecay690, i64 noundef %conv691)
  store ptr %call692, ptr %channel, align 8
  %358 = load ptr, ptr %hdr, align 8
  %data693 = getelementptr inbounds %struct.clusterMsg, ptr %358, i32 0, i32 20
  %msg694 = getelementptr inbounds %struct.anon.2, ptr %data693, i32 0, i32 0
  %bulk_data695 = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg694, i32 0, i32 2
  %arraydecay696 = getelementptr inbounds [8 x i8], ptr %bulk_data695, i64 0, i64 0
  %359 = load i32, ptr %channel_len662, align 4
  %idx.ext = zext i32 %359 to i64
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay696, i64 %idx.ext
  %360 = load i32, ptr %message_len663, align 4
  %conv697 = zext i32 %360 to i64
  %call698 = call ptr @createStringObject(ptr noundef %add.ptr, i64 noundef %conv697)
  store ptr %call698, ptr %message, align 8
  %361 = load ptr, ptr %channel, align 8
  %362 = load ptr, ptr %message, align 8
  %363 = load i16, ptr %type, align 2
  %conv699 = zext i16 %363 to i32
  %cmp700 = icmp eq i32 %conv699, 10
  %conv701 = zext i1 %cmp700 to i32
  %call702 = call i32 @pubsubPublishMessage(ptr noundef %361, ptr noundef %362, i32 noundef %conv701)
  %364 = load ptr, ptr %channel, align 8
  call void @decrRefCount(ptr noundef %364)
  %365 = load ptr, ptr %message, align 8
  call void @decrRefCount(ptr noundef %365)
  br label %if.end703

if.end703:                                        ; preds = %if.then679, %land.lhs.true675, %lor.lhs.false671
  br label %if.end828

if.else704:                                       ; preds = %lor.lhs.false654
  %366 = load i16, ptr %type, align 2
  %conv705 = zext i16 %366 to i32
  %cmp706 = icmp eq i32 %conv705, 5
  br i1 %cmp706, label %if.then708, label %if.else712

if.then708:                                       ; preds = %if.else704
  %367 = load ptr, ptr %sender, align 8
  %tobool709 = icmp ne ptr %367, null
  br i1 %tobool709, label %if.end711, label %if.then710

if.then710:                                       ; preds = %if.then708
  store i32 1, ptr %retval, align 4
  br label %return

if.end711:                                        ; preds = %if.then708
  %368 = load ptr, ptr %sender, align 8
  %369 = load ptr, ptr %hdr, align 8
  call void @clusterSendFailoverAuthIfNeeded(ptr noundef %368, ptr noundef %369)
  br label %if.end827

if.else712:                                       ; preds = %if.else704
  %370 = load i16, ptr %type, align 2
  %conv713 = zext i16 %370 to i32
  %cmp714 = icmp eq i32 %conv713, 6
  br i1 %cmp714, label %if.then716, label %if.else731

if.then716:                                       ; preds = %if.else712
  %371 = load ptr, ptr %sender, align 8
  %tobool717 = icmp ne ptr %371, null
  br i1 %tobool717, label %if.end719, label %if.then718

if.then718:                                       ; preds = %if.then716
  store i32 1, ptr %retval, align 4
  br label %return

if.end719:                                        ; preds = %if.then716
  %372 = load ptr, ptr %sender, align 8
  %call720 = call i32 @clusterNodeIsMaster(ptr noundef %372)
  %tobool721 = icmp ne i32 %call720, 0
  br i1 %tobool721, label %land.lhs.true722, label %if.end730

land.lhs.true722:                                 ; preds = %if.end719
  %373 = load ptr, ptr %sender, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %373, i32 0, i32 8
  %374 = load i32, ptr %numslots, align 4
  %cmp723 = icmp sgt i32 %374, 0
  br i1 %cmp723, label %land.lhs.true725, label %if.end730

land.lhs.true725:                                 ; preds = %land.lhs.true722
  %375 = load i64, ptr %senderCurrentEpoch, align 8
  %376 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_epoch = getelementptr inbounds %struct.clusterState, ptr %376, i32 0, i32 15
  %377 = load i64, ptr %failover_auth_epoch, align 8
  %cmp726 = icmp uge i64 %375, %377
  br i1 %cmp726, label %if.then728, label %if.end730

if.then728:                                       ; preds = %land.lhs.true725
  %378 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_count = getelementptr inbounds %struct.clusterState, ptr %378, i32 0, i32 12
  %379 = load i32, ptr %failover_auth_count, align 8
  %inc729 = add nsw i32 %379, 1
  store i32 %inc729, ptr %failover_auth_count, align 8
  call void @clusterDoBeforeSleep(i32 noundef 1)
  br label %if.end730

if.end730:                                        ; preds = %if.then728, %land.lhs.true725, %land.lhs.true722, %if.end719
  br label %if.end826

if.else731:                                       ; preds = %if.else712
  %380 = load i16, ptr %type, align 2
  %conv732 = zext i16 %380 to i32
  %cmp733 = icmp eq i32 %conv732, 8
  br i1 %cmp733, label %if.then735, label %if.else755

if.then735:                                       ; preds = %if.else731
  %381 = load ptr, ptr %sender, align 8
  %tobool736 = icmp ne ptr %381, null
  br i1 %tobool736, label %lor.lhs.false737, label %if.then741

lor.lhs.false737:                                 ; preds = %if.then735
  %382 = load ptr, ptr %sender, align 8
  %slaveof738 = getelementptr inbounds %struct._clusterNode, ptr %382, i32 0, i32 11
  %383 = load ptr, ptr %slaveof738, align 8
  %384 = load ptr, ptr @myself, align 8
  %cmp739 = icmp ne ptr %383, %384
  br i1 %cmp739, label %if.then741, label %if.end742

if.then741:                                       ; preds = %lor.lhs.false737, %if.then735
  store i32 1, ptr %retval, align 4
  br label %return

if.end742:                                        ; preds = %lor.lhs.false737
  call void @resetManualFailover()
  %385 = load i64, ptr %now, align 8
  %add743 = add nsw i64 %385, 5000
  %386 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end744 = getelementptr inbounds %struct.clusterState, ptr %386, i32 0, i32 17
  store i64 %add743, ptr %mf_end744, align 8
  %387 = load ptr, ptr %sender, align 8
  %388 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_slave = getelementptr inbounds %struct.clusterState, ptr %388, i32 0, i32 18
  store ptr %387, ptr %mf_slave, align 8
  %389 = load i64, ptr %now, align 8
  %add745 = add nsw i64 %389, 10000
  call void @pauseActions(i32 noundef 2, i64 noundef %add745, i32 noundef 29)
  br label %do.body746

do.body746:                                       ; preds = %if.end742
  %390 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp747 = icmp slt i32 2, %390
  br i1 %cmp747, label %if.then749, label %if.end750

if.then749:                                       ; preds = %do.body746
  br label %do.end754

if.end750:                                        ; preds = %do.body746
  %391 = load ptr, ptr %sender, align 8
  %name751 = getelementptr inbounds %struct._clusterNode, ptr %391, i32 0, i32 1
  %arraydecay752 = getelementptr inbounds [40 x i8], ptr %name751, i64 0, i64 0
  %392 = load ptr, ptr %sender, align 8
  %human_nodename753 = getelementptr inbounds %struct._clusterNode, ptr %392, i32 0, i32 23
  %393 = load ptr, ptr %human_nodename753, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.98, ptr noundef %arraydecay752, ptr noundef %393)
  br label %do.end754

do.end754:                                        ; preds = %if.end750, %if.then749
  %394 = load ptr, ptr %link.addr, align 8
  call void @clusterSendPing(ptr noundef %394, i32 noundef 0)
  br label %if.end825

if.else755:                                       ; preds = %if.else731
  %395 = load i16, ptr %type, align 2
  %conv756 = zext i16 %395 to i32
  %cmp757 = icmp eq i32 %conv756, 7
  br i1 %cmp757, label %if.then759, label %if.else789

if.then759:                                       ; preds = %if.else755
  %396 = load ptr, ptr %hdr, align 8
  %data760 = getelementptr inbounds %struct.clusterMsg, ptr %396, i32 0, i32 20
  %nodecfg = getelementptr inbounds %struct.anon.3, ptr %data760, i32 0, i32 0
  %configEpoch761 = getelementptr inbounds %struct.clusterMsgDataUpdate, ptr %nodecfg, i32 0, i32 0
  %397 = load i64, ptr %configEpoch761, align 8
  %call762 = call i64 @intrev64(i64 noundef %397)
  store i64 %call762, ptr %reportedConfigEpoch, align 8
  %398 = load ptr, ptr %sender, align 8
  %tobool763 = icmp ne ptr %398, null
  br i1 %tobool763, label %if.end765, label %if.then764

if.then764:                                       ; preds = %if.then759
  store i32 1, ptr %retval, align 4
  br label %return

if.end765:                                        ; preds = %if.then759
  %399 = load ptr, ptr %hdr, align 8
  %data766 = getelementptr inbounds %struct.clusterMsg, ptr %399, i32 0, i32 20
  %nodecfg767 = getelementptr inbounds %struct.anon.3, ptr %data766, i32 0, i32 0
  %nodename768 = getelementptr inbounds %struct.clusterMsgDataUpdate, ptr %nodecfg767, i32 0, i32 1
  %arraydecay769 = getelementptr inbounds [40 x i8], ptr %nodename768, i64 0, i64 0
  %call770 = call ptr @clusterLookupNode(ptr noundef %arraydecay769, i32 noundef 40)
  store ptr %call770, ptr %n, align 8
  %400 = load ptr, ptr %n, align 8
  %tobool771 = icmp ne ptr %400, null
  br i1 %tobool771, label %if.end773, label %if.then772

if.then772:                                       ; preds = %if.end765
  store i32 1, ptr %retval, align 4
  br label %return

if.end773:                                        ; preds = %if.end765
  %401 = load ptr, ptr %n, align 8
  %configEpoch774 = getelementptr inbounds %struct._clusterNode, ptr %401, i32 0, i32 4
  %402 = load i64, ptr %configEpoch774, align 8
  %403 = load i64, ptr %reportedConfigEpoch, align 8
  %cmp775 = icmp uge i64 %402, %403
  br i1 %cmp775, label %if.then777, label %if.end778

if.then777:                                       ; preds = %if.end773
  store i32 1, ptr %retval, align 4
  br label %return

if.end778:                                        ; preds = %if.end773
  %404 = load ptr, ptr %n, align 8
  %flags779 = getelementptr inbounds %struct._clusterNode, ptr %404, i32 0, i32 3
  %405 = load i32, ptr %flags779, align 8
  %and780 = and i32 %405, 2
  %tobool781 = icmp ne i32 %and780, 0
  br i1 %tobool781, label %if.then782, label %if.end783

if.then782:                                       ; preds = %if.end778
  %406 = load ptr, ptr %n, align 8
  call void @clusterSetNodeAsMaster(ptr noundef %406)
  br label %if.end783

if.end783:                                        ; preds = %if.then782, %if.end778
  %407 = load i64, ptr %reportedConfigEpoch, align 8
  %408 = load ptr, ptr %n, align 8
  %configEpoch784 = getelementptr inbounds %struct._clusterNode, ptr %408, i32 0, i32 4
  store i64 %407, ptr %configEpoch784, align 8
  call void @clusterDoBeforeSleep(i32 noundef 12)
  %409 = load ptr, ptr %n, align 8
  %410 = load i64, ptr %reportedConfigEpoch, align 8
  %411 = load ptr, ptr %hdr, align 8
  %data785 = getelementptr inbounds %struct.clusterMsg, ptr %411, i32 0, i32 20
  %nodecfg786 = getelementptr inbounds %struct.anon.3, ptr %data785, i32 0, i32 0
  %slots787 = getelementptr inbounds %struct.clusterMsgDataUpdate, ptr %nodecfg786, i32 0, i32 2
  %arraydecay788 = getelementptr inbounds [2048 x i8], ptr %slots787, i64 0, i64 0
  call void @clusterUpdateSlotsConfigWith(ptr noundef %409, i64 noundef %410, ptr noundef %arraydecay788)
  br label %if.end824

if.else789:                                       ; preds = %if.else755
  %412 = load i16, ptr %type, align 2
  %conv790 = zext i16 %412 to i32
  %cmp791 = icmp eq i32 %conv790, 9
  br i1 %cmp791, label %if.then793, label %if.else815

if.then793:                                       ; preds = %if.else789
  %413 = load ptr, ptr %sender, align 8
  %tobool794 = icmp ne ptr %413, null
  br i1 %tobool794, label %if.end796, label %if.then795

if.then795:                                       ; preds = %if.then793
  store i32 1, ptr %retval, align 4
  br label %return

if.end796:                                        ; preds = %if.then793
  %414 = load ptr, ptr %hdr, align 8
  %data797 = getelementptr inbounds %struct.clusterMsg, ptr %414, i32 0, i32 20
  %msg798 = getelementptr inbounds %struct.anon.4, ptr %data797, i32 0, i32 0
  %module_id799 = getelementptr inbounds %struct.clusterMsgModule, ptr %msg798, i32 0, i32 0
  %415 = load i64, ptr %module_id799, align 8
  store i64 %415, ptr %module_id, align 8
  %416 = load ptr, ptr %hdr, align 8
  %data801 = getelementptr inbounds %struct.clusterMsg, ptr %416, i32 0, i32 20
  %msg802 = getelementptr inbounds %struct.anon.4, ptr %data801, i32 0, i32 0
  %len803 = getelementptr inbounds %struct.clusterMsgModule, ptr %msg802, i32 0, i32 1
  %417 = load i32, ptr %len803, align 8
  %call804 = call i32 @ntohl(i32 noundef %417) #14
  store i32 %call804, ptr %len800, align 4
  %418 = load ptr, ptr %hdr, align 8
  %data806 = getelementptr inbounds %struct.clusterMsg, ptr %418, i32 0, i32 20
  %msg807 = getelementptr inbounds %struct.anon.4, ptr %data806, i32 0, i32 0
  %type808 = getelementptr inbounds %struct.clusterMsgModule, ptr %msg807, i32 0, i32 2
  %419 = load i8, ptr %type808, align 4
  store i8 %419, ptr %type805, align 1
  %420 = load ptr, ptr %hdr, align 8
  %data809 = getelementptr inbounds %struct.clusterMsg, ptr %420, i32 0, i32 20
  %msg810 = getelementptr inbounds %struct.anon.4, ptr %data809, i32 0, i32 0
  %bulk_data811 = getelementptr inbounds %struct.clusterMsgModule, ptr %msg810, i32 0, i32 3
  %arraydecay812 = getelementptr inbounds [3 x i8], ptr %bulk_data811, i64 0, i64 0
  store ptr %arraydecay812, ptr %payload, align 8
  %421 = load ptr, ptr %sender, align 8
  %name813 = getelementptr inbounds %struct._clusterNode, ptr %421, i32 0, i32 1
  %arraydecay814 = getelementptr inbounds [40 x i8], ptr %name813, i64 0, i64 0
  %422 = load i64, ptr %module_id, align 8
  %423 = load i8, ptr %type805, align 1
  %424 = load ptr, ptr %payload, align 8
  %425 = load i32, ptr %len800, align 4
  call void @moduleCallClusterReceivers(ptr noundef %arraydecay814, i64 noundef %422, i8 noundef zeroext %423, ptr noundef %424, i32 noundef %425)
  br label %if.end823

if.else815:                                       ; preds = %if.else789
  br label %do.body816

do.body816:                                       ; preds = %if.else815
  %426 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp817 = icmp slt i32 3, %426
  br i1 %cmp817, label %if.then819, label %if.end820

if.then819:                                       ; preds = %do.body816
  br label %do.end822

if.end820:                                        ; preds = %do.body816
  %427 = load i16, ptr %type, align 2
  %conv821 = zext i16 %427 to i32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.99, i32 noundef %conv821)
  br label %do.end822

do.end822:                                        ; preds = %if.end820, %if.then819
  br label %if.end823

if.end823:                                        ; preds = %do.end822, %if.end796
  br label %if.end824

if.end824:                                        ; preds = %if.end823, %if.end783
  br label %if.end825

if.end825:                                        ; preds = %if.end824, %do.end754
  br label %if.end826

if.end826:                                        ; preds = %if.end825, %if.end730
  br label %if.end827

if.end827:                                        ; preds = %if.end826, %if.end711
  br label %if.end828

if.end828:                                        ; preds = %if.end827, %if.end703
  br label %if.end829

if.end829:                                        ; preds = %if.end828, %if.end649
  br label %if.end830

if.end830:                                        ; preds = %if.end829, %if.end600
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end830, %if.then795, %if.then777, %if.then772, %if.then764, %if.then741, %if.then718, %if.then710, %if.then660, %do.end398, %if.end353, %do.end179, %do.end93, %do.end79, %do.end37, %if.then26, %if.then20, %if.then15
  %428 = load i32, ptr %retval, align 4
  ret i32 %428
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterGetMessageTypeString(i32 noundef %type) #0 {
entry:
  %retval = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  switch i32 %0, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
    i32 3, label %sw.bb3
    i32 4, label %sw.bb4
    i32 10, label %sw.bb5
    i32 5, label %sw.bb6
    i32 6, label %sw.bb7
    i32 7, label %sw.bb8
    i32 8, label %sw.bb9
    i32 9, label %sw.bb10
  ]

sw.bb:                                            ; preds = %entry
  store ptr @.str.169, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  store ptr @.str.170, ptr %retval, align 8
  br label %return

sw.bb2:                                           ; preds = %entry
  store ptr @.str.171, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  store ptr @.str.22, ptr %retval, align 8
  br label %return

sw.bb4:                                           ; preds = %entry
  store ptr @.str.172, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  store ptr @.str.173, ptr %retval, align 8
  br label %return

sw.bb6:                                           ; preds = %entry
  store ptr @.str.174, ptr %retval, align 8
  br label %return

sw.bb7:                                           ; preds = %entry
  store ptr @.str.175, ptr %retval, align 8
  br label %return

sw.bb8:                                           ; preds = %entry
  store ptr @.str.176, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  store ptr @.str.177, ptr %retval, align 8
  br label %return

sw.bb10:                                          ; preds = %entry
  store ptr @.str.178, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store ptr @.str.179, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal i32 @getPingExtLength(ptr noundef %ext) #0 {
entry:
  %ext.addr = alloca ptr, align 8
  store ptr %ext, ptr %ext.addr, align 8
  %0 = load ptr, ptr %ext.addr, align 8
  %length = getelementptr inbounds %struct.clusterMsgPingExt, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %length, align 8
  %call = call i32 @ntohl(i32 noundef %1) #14
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal ptr @getNodeFromLinkAndMsg(ptr noundef %link, ptr noundef %hdr) #0 {
entry:
  %link.addr = alloca ptr, align 8
  %hdr.addr = alloca ptr, align 8
  %sender = alloca ptr, align 8
  store ptr %link, ptr %link.addr, align 8
  store ptr %hdr, ptr %hdr.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  %node = getelementptr inbounds %struct.clusterLink, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %node, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %link.addr, align 8
  %node1 = getelementptr inbounds %struct.clusterLink, ptr %2, i32 0, i32 8
  %3 = load ptr, ptr %node1, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, 32
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %5 = load ptr, ptr %link.addr, align 8
  %node3 = getelementptr inbounds %struct.clusterLink, ptr %5, i32 0, i32 8
  %6 = load ptr, ptr %node3, align 8
  store ptr %6, ptr %sender, align 8
  br label %if.end10

if.else:                                          ; preds = %land.lhs.true, %entry
  %7 = load ptr, ptr %hdr.addr, align 8
  %sender4 = getelementptr inbounds %struct.clusterMsg, ptr %7, i32 0, i32 9
  %arraydecay = getelementptr inbounds [40 x i8], ptr %sender4, i64 0, i64 0
  %call = call ptr @clusterLookupNode(ptr noundef %arraydecay, i32 noundef 40)
  store ptr %call, ptr %sender, align 8
  %8 = load ptr, ptr %sender, align 8
  %tobool5 = icmp ne ptr %8, null
  br i1 %tobool5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %if.else
  %9 = load ptr, ptr %link.addr, align 8
  %node7 = getelementptr inbounds %struct.clusterLink, ptr %9, i32 0, i32 8
  %10 = load ptr, ptr %node7, align 8
  %tobool8 = icmp ne ptr %10, null
  br i1 %tobool8, label %if.end, label %if.then9

if.then9:                                         ; preds = %land.lhs.true6
  %11 = load ptr, ptr %sender, align 8
  %12 = load ptr, ptr %link.addr, align 8
  call void @setClusterNodeToInboundClusterLink(ptr noundef %11, ptr noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.then9, %land.lhs.true6, %if.else
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  %13 = load ptr, ptr %sender, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define internal i32 @connAddrSockName(ptr noundef %conn, ptr noundef %ip, i64 noundef %ip_len, ptr noundef %port) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %ip.addr = alloca ptr, align 8
  %ip_len.addr = alloca i64, align 8
  %port.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i64 %ip_len, ptr %ip_len.addr, align 8
  store ptr %port, ptr %port.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %1 = load ptr, ptr %ip.addr, align 8
  %2 = load i64, ptr %ip_len.addr, align 8
  %3 = load ptr, ptr %port.addr, align 8
  %call = call i32 @connAddr(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef 0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendPing(ptr noundef %link, i32 noundef %type) #0 {
entry:
  %link.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %gossipcount = alloca i32, align 4
  %wanted = alloca i32, align 4
  %estlen = alloca i32, align 4
  %freshnodes = alloca i32, align 4
  %pfail_wanted = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  %maxiterations = alloca i32, align 4
  %de = alloca ptr, align 8
  %this = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de73 = alloca ptr, align 8
  %node85 = alloca ptr, align 8
  %totlen = alloca i32, align 4
  store ptr %link, ptr %link.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load i64, ptr @clusterSendPing.cluster_pings_sent, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr @clusterSendPing.cluster_pings_sent, align 8
  store i32 0, ptr %gossipcount, align 4
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %2, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes1 = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %nodes1, align 8
  %ht_used2 = getelementptr inbounds %struct.dict, ptr %5, i32 0, i32 2
  %arrayidx3 = getelementptr inbounds [2 x i64], ptr %ht_used2, i64 0, i64 1
  %6 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %3, %6
  %sub = sub i64 %add, 2
  %conv = trunc i64 %sub to i32
  store i32 %conv, ptr %freshnodes, align 4
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes4 = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %nodes4, align 8
  %ht_used5 = getelementptr inbounds %struct.dict, ptr %8, i32 0, i32 2
  %arrayidx6 = getelementptr inbounds [2 x i64], ptr %ht_used5, i64 0, i64 0
  %9 = load i64, ptr %arrayidx6, align 8
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes7 = getelementptr inbounds %struct.clusterState, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %nodes7, align 8
  %ht_used8 = getelementptr inbounds %struct.dict, ptr %11, i32 0, i32 2
  %arrayidx9 = getelementptr inbounds [2 x i64], ptr %ht_used8, i64 0, i64 1
  %12 = load i64, ptr %arrayidx9, align 8
  %add10 = add i64 %9, %12
  %div = udiv i64 %add10, 10
  %conv11 = uitofp i64 %div to double
  %13 = call double @llvm.floor.f64(double %conv11)
  %conv12 = fptosi double %13 to i32
  store i32 %conv12, ptr %wanted, align 4
  %14 = load i32, ptr %wanted, align 4
  %cmp = icmp slt i32 %14, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 3, ptr %wanted, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load i32, ptr %wanted, align 4
  %16 = load i32, ptr %freshnodes, align 4
  %cmp14 = icmp sgt i32 %15, %16
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end
  %17 = load i32, ptr %freshnodes, align 4
  store i32 %17, ptr %wanted, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_pfail_nodes = getelementptr inbounds %struct.clusterState, ptr %18, i32 0, i32 25
  %19 = load i64, ptr %stats_pfail_nodes, align 8
  %conv18 = trunc i64 %19 to i32
  store i32 %conv18, ptr %pfail_wanted, align 4
  store i32 2256, ptr %estlen, align 4
  %20 = load i32, ptr %wanted, align 4
  %21 = load i32, ptr %pfail_wanted, align 4
  %add19 = add nsw i32 %20, %21
  %conv20 = sext i32 %add19 to i64
  %mul = mul i64 104, %conv20
  %22 = load i32, ptr %estlen, align 4
  %conv21 = sext i32 %22 to i64
  %add22 = add i64 %conv21, %mul
  %conv23 = trunc i64 %add22 to i32
  store i32 %conv23, ptr %estlen, align 4
  %call = call i32 @writePingExt(ptr noundef null, i32 noundef 0)
  %23 = load i32, ptr %estlen, align 4
  %add24 = add i32 %23, %call
  store i32 %add24, ptr %estlen, align 4
  %24 = load i32, ptr %estlen, align 4
  %cmp25 = icmp slt i32 %24, 4352
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end17
  store i32 4352, ptr %estlen, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.end17
  %25 = load i32, ptr %type.addr, align 4
  %26 = load i32, ptr %estlen, align 4
  %call29 = call ptr @createClusterMsgSendBlock(i32 noundef %25, i32 noundef %26)
  store ptr %call29, ptr %msgblock, align 8
  %27 = load ptr, ptr %msgblock, align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %27, i32 0, i32 2
  store ptr %msg, ptr %hdr, align 8
  %28 = load ptr, ptr %link.addr, align 8
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %28, i32 0, i32 9
  %29 = load i32, ptr %inbound, align 8
  %tobool = icmp ne i32 %29, 0
  br i1 %tobool, label %if.end34, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end28
  %30 = load i32, ptr %type.addr, align 4
  %cmp30 = icmp eq i32 %30, 0
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %land.lhs.true
  %call33 = call i64 @mstime()
  %31 = load ptr, ptr %link.addr, align 8
  %node = getelementptr inbounds %struct.clusterLink, ptr %31, i32 0, i32 8
  %32 = load ptr, ptr %node, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %32, i32 0, i32 13
  store i64 %call33, ptr %ping_sent, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %land.lhs.true, %if.end28
  %33 = load i32, ptr %wanted, align 4
  %mul35 = mul nsw i32 %33, 3
  store i32 %mul35, ptr %maxiterations, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end67, %if.then66, %if.then61, %if.then50, %if.then47, %if.end34
  %34 = load i32, ptr %freshnodes, align 4
  %cmp36 = icmp sgt i32 %34, 0
  br i1 %cmp36, label %land.lhs.true38, label %land.end

land.lhs.true38:                                  ; preds = %while.cond
  %35 = load i32, ptr %gossipcount, align 4
  %36 = load i32, ptr %wanted, align 4
  %cmp39 = icmp slt i32 %35, %36
  br i1 %cmp39, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true38
  %37 = load i32, ptr %maxiterations, align 4
  %dec = add nsw i32 %37, -1
  store i32 %dec, ptr %maxiterations, align 4
  %tobool41 = icmp ne i32 %37, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true38, %while.cond
  %38 = phi i1 [ false, %land.lhs.true38 ], [ false, %while.cond ], [ %tobool41, %land.rhs ]
  br i1 %38, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %39 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes42 = getelementptr inbounds %struct.clusterState, ptr %39, i32 0, i32 4
  %40 = load ptr, ptr %nodes42, align 8
  %call43 = call ptr @dictGetRandomKey(ptr noundef %40)
  store ptr %call43, ptr %de, align 8
  %41 = load ptr, ptr %de, align 8
  %call44 = call ptr @dictGetVal(ptr noundef %41)
  store ptr %call44, ptr %this, align 8
  %42 = load ptr, ptr %this, align 8
  %43 = load ptr, ptr @myself, align 8
  %cmp45 = icmp eq ptr %42, %43
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %while.body
  br label %while.cond, !llvm.loop !42

if.end48:                                         ; preds = %while.body
  %44 = load ptr, ptr %this, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %44, i32 0, i32 3
  %45 = load i32, ptr %flags, align 8
  %and = and i32 %45, 4
  %tobool49 = icmp ne i32 %and, 0
  br i1 %tobool49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end48
  br label %while.cond, !llvm.loop !42

if.end51:                                         ; preds = %if.end48
  %46 = load ptr, ptr %this, align 8
  %flags52 = getelementptr inbounds %struct._clusterNode, ptr %46, i32 0, i32 3
  %47 = load i32, ptr %flags52, align 8
  %and53 = and i32 %47, 96
  %tobool54 = icmp ne i32 %and53, 0
  br i1 %tobool54, label %if.then61, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end51
  %48 = load ptr, ptr %this, align 8
  %link55 = getelementptr inbounds %struct._clusterNode, ptr %48, i32 0, i32 27
  %49 = load ptr, ptr %link55, align 8
  %cmp56 = icmp eq ptr %49, null
  br i1 %cmp56, label %land.lhs.true58, label %if.end63

land.lhs.true58:                                  ; preds = %lor.lhs.false
  %50 = load ptr, ptr %this, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %50, i32 0, i32 8
  %51 = load i32, ptr %numslots, align 4
  %cmp59 = icmp eq i32 %51, 0
  br i1 %cmp59, label %if.then61, label %if.end63

if.then61:                                        ; preds = %land.lhs.true58, %if.end51
  %52 = load i32, ptr %freshnodes, align 4
  %dec62 = add nsw i32 %52, -1
  store i32 %dec62, ptr %freshnodes, align 4
  br label %while.cond, !llvm.loop !42

if.end63:                                         ; preds = %land.lhs.true58, %lor.lhs.false
  %53 = load ptr, ptr %this, align 8
  %last_in_ping_gossip = getelementptr inbounds %struct._clusterNode, ptr %53, i32 0, i32 12
  %54 = load i64, ptr %last_in_ping_gossip, align 8
  %55 = load i64, ptr @clusterSendPing.cluster_pings_sent, align 8
  %cmp64 = icmp eq i64 %54, %55
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.end63
  br label %while.cond, !llvm.loop !42

if.end67:                                         ; preds = %if.end63
  %56 = load ptr, ptr %hdr, align 8
  %57 = load i32, ptr %gossipcount, align 4
  %58 = load ptr, ptr %this, align 8
  call void @clusterSetGossipEntry(ptr noundef %56, i32 noundef %57, ptr noundef %58)
  %59 = load i64, ptr @clusterSendPing.cluster_pings_sent, align 8
  %60 = load ptr, ptr %this, align 8
  %last_in_ping_gossip68 = getelementptr inbounds %struct._clusterNode, ptr %60, i32 0, i32 12
  store i64 %59, ptr %last_in_ping_gossip68, align 8
  %61 = load i32, ptr %freshnodes, align 4
  %dec69 = add nsw i32 %61, -1
  store i32 %dec69, ptr %freshnodes, align 4
  %62 = load i32, ptr %gossipcount, align 4
  %inc70 = add nsw i32 %62, 1
  store i32 %inc70, ptr %gossipcount, align 4
  br label %while.cond, !llvm.loop !42

while.end:                                        ; preds = %land.end
  %63 = load i32, ptr %pfail_wanted, align 4
  %tobool71 = icmp ne i32 %63, 0
  br i1 %tobool71, label %if.then72, label %if.end105

if.then72:                                        ; preds = %while.end
  %64 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes74 = getelementptr inbounds %struct.clusterState, ptr %64, i32 0, i32 4
  %65 = load ptr, ptr %nodes74, align 8
  %call75 = call ptr @dictGetSafeIterator(ptr noundef %65)
  store ptr %call75, ptr %di, align 8
  br label %while.cond76

while.cond76:                                     ; preds = %if.end101, %if.then100, %if.then95, %if.then90, %if.then72
  %66 = load ptr, ptr %di, align 8
  %call77 = call ptr @dictNext(ptr noundef %66)
  store ptr %call77, ptr %de73, align 8
  %cmp78 = icmp ne ptr %call77, null
  br i1 %cmp78, label %land.rhs80, label %land.end83

land.rhs80:                                       ; preds = %while.cond76
  %67 = load i32, ptr %pfail_wanted, align 4
  %cmp81 = icmp sgt i32 %67, 0
  br label %land.end83

land.end83:                                       ; preds = %land.rhs80, %while.cond76
  %68 = phi i1 [ false, %while.cond76 ], [ %cmp81, %land.rhs80 ]
  br i1 %68, label %while.body84, label %while.end104

while.body84:                                     ; preds = %land.end83
  %69 = load ptr, ptr %de73, align 8
  %call86 = call ptr @dictGetVal(ptr noundef %69)
  store ptr %call86, ptr %node85, align 8
  %70 = load ptr, ptr %node85, align 8
  %flags87 = getelementptr inbounds %struct._clusterNode, ptr %70, i32 0, i32 3
  %71 = load i32, ptr %flags87, align 8
  %and88 = and i32 %71, 32
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %while.body84
  br label %while.cond76, !llvm.loop !43

if.end91:                                         ; preds = %while.body84
  %72 = load ptr, ptr %node85, align 8
  %flags92 = getelementptr inbounds %struct._clusterNode, ptr %72, i32 0, i32 3
  %73 = load i32, ptr %flags92, align 8
  %and93 = and i32 %73, 64
  %tobool94 = icmp ne i32 %and93, 0
  br i1 %tobool94, label %if.then95, label %if.end96

if.then95:                                        ; preds = %if.end91
  br label %while.cond76, !llvm.loop !43

if.end96:                                         ; preds = %if.end91
  %74 = load ptr, ptr %node85, align 8
  %flags97 = getelementptr inbounds %struct._clusterNode, ptr %74, i32 0, i32 3
  %75 = load i32, ptr %flags97, align 8
  %and98 = and i32 %75, 4
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %if.end101, label %if.then100

if.then100:                                       ; preds = %if.end96
  br label %while.cond76, !llvm.loop !43

if.end101:                                        ; preds = %if.end96
  %76 = load ptr, ptr %hdr, align 8
  %77 = load i32, ptr %gossipcount, align 4
  %78 = load ptr, ptr %node85, align 8
  call void @clusterSetGossipEntry(ptr noundef %76, i32 noundef %77, ptr noundef %78)
  %79 = load i32, ptr %gossipcount, align 4
  %inc102 = add nsw i32 %79, 1
  store i32 %inc102, ptr %gossipcount, align 4
  %80 = load i32, ptr %pfail_wanted, align 4
  %dec103 = add nsw i32 %80, -1
  store i32 %dec103, ptr %pfail_wanted, align 4
  br label %while.cond76, !llvm.loop !43

while.end104:                                     ; preds = %land.end83
  %81 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %81)
  br label %if.end105

if.end105:                                        ; preds = %while.end104, %while.end
  store i32 0, ptr %totlen, align 4
  %82 = load ptr, ptr %hdr, align 8
  %83 = load i32, ptr %gossipcount, align 4
  %call106 = call i32 @writePingExt(ptr noundef %82, i32 noundef %83)
  %84 = load i32, ptr %totlen, align 4
  %add107 = add i32 %84, %call106
  store i32 %add107, ptr %totlen, align 4
  %85 = load i32, ptr %totlen, align 4
  %conv108 = zext i32 %85 to i64
  %add109 = add i64 %conv108, 2256
  %conv110 = trunc i64 %add109 to i32
  store i32 %conv110, ptr %totlen, align 4
  %86 = load i32, ptr %gossipcount, align 4
  %conv111 = sext i32 %86 to i64
  %mul112 = mul i64 104, %conv111
  %87 = load i32, ptr %totlen, align 4
  %conv113 = zext i32 %87 to i64
  %add114 = add i64 %conv113, %mul112
  %conv115 = trunc i64 %add114 to i32
  store i32 %conv115, ptr %totlen, align 4
  %88 = load i32, ptr %gossipcount, align 4
  %cmp116 = icmp slt i32 %88, 65535
  %lnot = xor i1 %cmp116, true
  %lnot118 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot118 to i32
  %conv119 = sext i32 %lnot.ext to i64
  %tobool120 = icmp ne i64 %conv119, 0
  br i1 %tobool120, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end105
  br label %cond.end

cond.false:                                       ; preds = %if.end105
  call void @_serverAssert(ptr noundef @.str.110, ptr noundef @.str.18, i32 noundef 3600)
  call void @abort() #13
  unreachable

89:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %89, %cond.true
  %90 = load i32, ptr %gossipcount, align 4
  %conv121 = trunc i32 %90 to i16
  %call122 = call zeroext i16 @htons(i16 noundef zeroext %conv121) #14
  %91 = load ptr, ptr %hdr, align 8
  %count = getelementptr inbounds %struct.clusterMsg, ptr %91, i32 0, i32 5
  store i16 %call122, ptr %count, align 2
  %92 = load i32, ptr %totlen, align 4
  %call123 = call i32 @htonl(i32 noundef %92) #14
  %93 = load ptr, ptr %hdr, align 8
  %totlen124 = getelementptr inbounds %struct.clusterMsg, ptr %93, i32 0, i32 1
  store i32 %call123, ptr %totlen124, align 4
  %94 = load ptr, ptr %link.addr, align 8
  %95 = load ptr, ptr %msgblock, align 8
  call void @clusterSendMessage(ptr noundef %94, ptr noundef %95)
  %96 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %96)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterDelNodeSlots(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %deleted = alloca i32, align 4
  %j = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store i32 0, ptr %deleted, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %0, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %node.addr, align 8
  %2 = load i32, ptr %j, align 4
  %call = call i32 @clusterNodeCoversSlot(ptr noundef %1, i32 noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %3 = load i32, ptr %j, align 4
  %call1 = call i32 @clusterDelSlot(i32 noundef %3)
  %4 = load i32, ptr %deleted, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %deleted, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i32, ptr %j, align 4
  %inc2 = add nsw i32 %5, 1
  store i32 %inc2, ptr %j, align 4
  br label %for.cond, !llvm.loop !44

for.end:                                          ; preds = %for.cond
  %6 = load i32, ptr %deleted, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendUpdate(ptr noundef %link, ptr noundef %node) #0 {
entry:
  %link.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %msglen = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %link, ptr %link.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 4352, ptr %msglen, align 4
  %1 = load i32, ptr %msglen, align 4
  %call = call ptr @createClusterMsgSendBlock(i32 noundef 7, i32 noundef %1)
  store ptr %call, ptr %msgblock, align 8
  %2 = load ptr, ptr %msgblock, align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %2, i32 0, i32 2
  store ptr %msg, ptr %hdr, align 8
  %3 = load ptr, ptr %hdr, align 8
  %data = getelementptr inbounds %struct.clusterMsg, ptr %3, i32 0, i32 20
  %nodecfg = getelementptr inbounds %struct.anon.3, ptr %data, i32 0, i32 0
  %nodename = getelementptr inbounds %struct.clusterMsgDataUpdate, ptr %nodecfg, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %nodename, i64 0, i64 0
  %4 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 1
  %arraydecay1 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 8 %arraydecay1, i64 40, i1 false)
  %5 = load ptr, ptr %node.addr, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 4
  %6 = load i64, ptr %configEpoch, align 8
  %call2 = call i64 @intrev64(i64 noundef %6)
  %7 = load ptr, ptr %hdr, align 8
  %data3 = getelementptr inbounds %struct.clusterMsg, ptr %7, i32 0, i32 20
  %nodecfg4 = getelementptr inbounds %struct.anon.3, ptr %data3, i32 0, i32 0
  %configEpoch5 = getelementptr inbounds %struct.clusterMsgDataUpdate, ptr %nodecfg4, i32 0, i32 0
  store i64 %call2, ptr %configEpoch5, align 8
  %8 = load ptr, ptr %hdr, align 8
  %data6 = getelementptr inbounds %struct.clusterMsg, ptr %8, i32 0, i32 20
  %nodecfg7 = getelementptr inbounds %struct.anon.3, ptr %data6, i32 0, i32 0
  %slots = getelementptr inbounds %struct.clusterMsgDataUpdate, ptr %nodecfg7, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [2048 x i8], ptr %slots, i64 0, i64 0
  %9 = load ptr, ptr %node.addr, align 8
  %slots9 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 5
  %arraydecay10 = getelementptr inbounds [2048 x i8], ptr %slots9, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay8, ptr align 8 %arraydecay10, i64 2048, i1 false)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32, ptr %i, align 4
  %conv = zext i32 %10 to i64
  %cmp11 = icmp ult i64 %conv, 2048
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %hdr, align 8
  %data13 = getelementptr inbounds %struct.clusterMsg, ptr %11, i32 0, i32 20
  %nodecfg14 = getelementptr inbounds %struct.anon.3, ptr %data13, i32 0, i32 0
  %slots15 = getelementptr inbounds %struct.clusterMsgDataUpdate, ptr %nodecfg14, i32 0, i32 2
  %12 = load i32, ptr %i, align 4
  %idxprom = zext i32 %12 to i64
  %arrayidx = getelementptr inbounds [2048 x i8], ptr %slots15, i64 0, i64 %idxprom
  %13 = load i8, ptr %arrayidx, align 1
  %conv16 = zext i8 %13 to i32
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %14, i32 0, i32 27
  %15 = load i32, ptr %i, align 4
  %idxprom17 = zext i32 %15 to i64
  %arrayidx18 = getelementptr inbounds [2048 x i8], ptr %owner_not_claiming_slot, i64 0, i64 %idxprom17
  %16 = load i8, ptr %arrayidx18, align 1
  %conv19 = zext i8 %16 to i32
  %not = xor i32 %conv19, -1
  %and = and i32 %conv16, %not
  %conv20 = trunc i32 %and to i8
  %17 = load ptr, ptr %hdr, align 8
  %data21 = getelementptr inbounds %struct.clusterMsg, ptr %17, i32 0, i32 20
  %nodecfg22 = getelementptr inbounds %struct.anon.3, ptr %data21, i32 0, i32 0
  %slots23 = getelementptr inbounds %struct.clusterMsgDataUpdate, ptr %nodecfg22, i32 0, i32 2
  %18 = load i32, ptr %i, align 4
  %idxprom24 = zext i32 %18 to i64
  %arrayidx25 = getelementptr inbounds [2048 x i8], ptr %slots23, i64 0, i64 %idxprom24
  store i8 %conv20, ptr %arrayidx25, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32, ptr %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !45

for.end:                                          ; preds = %for.cond
  %20 = load ptr, ptr %link.addr, align 8
  %21 = load ptr, ptr %msgblock, align 8
  call void @clusterSendMessage(ptr noundef %20, ptr noundef %21)
  %22 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %22)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

declare i32 @serverPubsubSubscriptionCount() #1

declare i32 @serverPubsubShardSubscriptionCount() #1

declare ptr @createStringObject(ptr noundef, i64 noundef) #1

declare i32 @pubsubPublishMessage(ptr noundef, ptr noundef, i32 noundef) #1

declare void @decrRefCount(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendFailoverAuthIfNeeded(ptr noundef %node, ptr noundef %request) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %request.addr = alloca ptr, align 8
  %master = alloca ptr, align 8
  %requestCurrentEpoch = alloca i64, align 8
  %requestConfigEpoch = alloca i64, align 8
  %claimed_slots = alloca ptr, align 8
  %force_ack = alloca i32, align 4
  %j = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store ptr %request, ptr %request.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 11
  %1 = load ptr, ptr %slaveof, align 8
  store ptr %1, ptr %master, align 8
  %2 = load ptr, ptr %request.addr, align 8
  %currentEpoch = getelementptr inbounds %struct.clusterMsg, ptr %2, i32 0, i32 6
  %3 = load i64, ptr %currentEpoch, align 8
  %call = call i64 @intrev64(i64 noundef %3)
  store i64 %call, ptr %requestCurrentEpoch, align 8
  %4 = load ptr, ptr %request.addr, align 8
  %configEpoch = getelementptr inbounds %struct.clusterMsg, ptr %4, i32 0, i32 7
  %5 = load i64, ptr %configEpoch, align 8
  %call1 = call i64 @intrev64(i64 noundef %5)
  store i64 %call1, ptr %requestConfigEpoch, align 8
  %6 = load ptr, ptr %request.addr, align 8
  %myslots = getelementptr inbounds %struct.clusterMsg, ptr %6, i32 0, i32 10
  %arraydecay = getelementptr inbounds [2048 x i8], ptr %myslots, i64 0, i64 0
  store ptr %arraydecay, ptr %claimed_slots, align 8
  %7 = load ptr, ptr %request.addr, align 8
  %mflags = getelementptr inbounds %struct.clusterMsg, ptr %7, i32 0, i32 19
  %arrayidx = getelementptr inbounds [3 x i8], ptr %mflags, i64 0, i64 0
  %8 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 2
  store i32 %and, ptr %force_ack, align 4
  %9 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %flags, align 8
  %and2 = and i32 %10, 2
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %11 = load ptr, ptr @myself, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 8
  %12 = load i32, ptr %numslots, align 4
  %cmp = icmp eq i32 %12, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %do.end154

if.end:                                           ; preds = %lor.lhs.false
  %13 = load i64, ptr %requestCurrentEpoch, align 8
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch4 = getelementptr inbounds %struct.clusterState, ptr %14, i32 0, i32 1
  %15 = load i64, ptr %currentEpoch4, align 8
  %cmp5 = icmp ult i64 %13, %15
  br i1 %cmp5, label %if.then7, label %if.end14

if.then7:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then7
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp8 = icmp slt i32 3, %16
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %do.body
  br label %do.end

if.end11:                                         ; preds = %do.body
  %17 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 1
  %arraydecay12 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %18 = load ptr, ptr %node.addr, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 23
  %19 = load ptr, ptr %human_nodename, align 8
  %20 = load i64, ptr %requestCurrentEpoch, align 8
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch13 = getelementptr inbounds %struct.clusterState, ptr %21, i32 0, i32 1
  %22 = load i64, ptr %currentEpoch13, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.112, ptr noundef %arraydecay12, ptr noundef %19, i64 noundef %20, i64 noundef %22)
  br label %do.end

do.end:                                           ; preds = %if.end11, %if.then10
  br label %do.end154

if.end14:                                         ; preds = %if.end
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %lastVoteEpoch = getelementptr inbounds %struct.clusterState, ptr %23, i32 0, i32 21
  %24 = load i64, ptr %lastVoteEpoch, align 8
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch15 = getelementptr inbounds %struct.clusterState, ptr %25, i32 0, i32 1
  %26 = load i64, ptr %currentEpoch15, align 8
  %cmp16 = icmp eq i64 %24, %26
  br i1 %cmp16, label %if.then18, label %if.end29

if.then18:                                        ; preds = %if.end14
  br label %do.body19

do.body19:                                        ; preds = %if.then18
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp20 = icmp slt i32 3, %27
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %do.body19
  br label %do.end28

if.end23:                                         ; preds = %do.body19
  %28 = load ptr, ptr %node.addr, align 8
  %name24 = getelementptr inbounds %struct._clusterNode, ptr %28, i32 0, i32 1
  %arraydecay25 = getelementptr inbounds [40 x i8], ptr %name24, i64 0, i64 0
  %29 = load ptr, ptr %node.addr, align 8
  %human_nodename26 = getelementptr inbounds %struct._clusterNode, ptr %29, i32 0, i32 23
  %30 = load ptr, ptr %human_nodename26, align 8
  %31 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch27 = getelementptr inbounds %struct.clusterState, ptr %31, i32 0, i32 1
  %32 = load i64, ptr %currentEpoch27, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.113, ptr noundef %arraydecay25, ptr noundef %30, i64 noundef %32)
  br label %do.end28

do.end28:                                         ; preds = %if.end23, %if.then22
  br label %do.end154

if.end29:                                         ; preds = %if.end14
  %33 = load ptr, ptr %node.addr, align 8
  %call30 = call i32 @clusterNodeIsMaster(ptr noundef %33)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then40, label %lor.lhs.false32

lor.lhs.false32:                                  ; preds = %if.end29
  %34 = load ptr, ptr %master, align 8
  %cmp33 = icmp eq ptr %34, null
  br i1 %cmp33, label %if.then40, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %lor.lhs.false32
  %35 = load ptr, ptr %master, align 8
  %flags36 = getelementptr inbounds %struct._clusterNode, ptr %35, i32 0, i32 3
  %36 = load i32, ptr %flags36, align 8
  %and37 = and i32 %36, 8
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.end82, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false35
  %37 = load i32, ptr %force_ack, align 4
  %tobool39 = icmp ne i32 %37, 0
  br i1 %tobool39, label %if.end82, label %if.then40

if.then40:                                        ; preds = %land.lhs.true, %lor.lhs.false32, %if.end29
  %38 = load ptr, ptr %node.addr, align 8
  %call41 = call i32 @clusterNodeIsMaster(ptr noundef %38)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.else

if.then43:                                        ; preds = %if.then40
  br label %do.body44

do.body44:                                        ; preds = %if.then43
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp45 = icmp slt i32 3, %39
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %do.body44
  br label %do.end52

if.end48:                                         ; preds = %do.body44
  %40 = load ptr, ptr %node.addr, align 8
  %name49 = getelementptr inbounds %struct._clusterNode, ptr %40, i32 0, i32 1
  %arraydecay50 = getelementptr inbounds [40 x i8], ptr %name49, i64 0, i64 0
  %41 = load ptr, ptr %node.addr, align 8
  %human_nodename51 = getelementptr inbounds %struct._clusterNode, ptr %41, i32 0, i32 23
  %42 = load ptr, ptr %human_nodename51, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.114, ptr noundef %arraydecay50, ptr noundef %42)
  br label %do.end52

do.end52:                                         ; preds = %if.end48, %if.then47
  br label %if.end81

if.else:                                          ; preds = %if.then40
  %43 = load ptr, ptr %master, align 8
  %cmp53 = icmp eq ptr %43, null
  br i1 %cmp53, label %if.then55, label %if.else65

if.then55:                                        ; preds = %if.else
  br label %do.body56

do.body56:                                        ; preds = %if.then55
  %44 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp57 = icmp slt i32 3, %44
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %do.body56
  br label %do.end64

if.end60:                                         ; preds = %do.body56
  %45 = load ptr, ptr %node.addr, align 8
  %name61 = getelementptr inbounds %struct._clusterNode, ptr %45, i32 0, i32 1
  %arraydecay62 = getelementptr inbounds [40 x i8], ptr %name61, i64 0, i64 0
  %46 = load ptr, ptr %node.addr, align 8
  %human_nodename63 = getelementptr inbounds %struct._clusterNode, ptr %46, i32 0, i32 23
  %47 = load ptr, ptr %human_nodename63, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.115, ptr noundef %arraydecay62, ptr noundef %47)
  br label %do.end64

do.end64:                                         ; preds = %if.end60, %if.then59
  br label %if.end80

if.else65:                                        ; preds = %if.else
  %48 = load ptr, ptr %master, align 8
  %flags66 = getelementptr inbounds %struct._clusterNode, ptr %48, i32 0, i32 3
  %49 = load i32, ptr %flags66, align 8
  %and67 = and i32 %49, 8
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %if.end79, label %if.then69

if.then69:                                        ; preds = %if.else65
  br label %do.body70

do.body70:                                        ; preds = %if.then69
  %50 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp71 = icmp slt i32 3, %50
  br i1 %cmp71, label %if.then73, label %if.end74

if.then73:                                        ; preds = %do.body70
  br label %do.end78

if.end74:                                         ; preds = %do.body70
  %51 = load ptr, ptr %node.addr, align 8
  %name75 = getelementptr inbounds %struct._clusterNode, ptr %51, i32 0, i32 1
  %arraydecay76 = getelementptr inbounds [40 x i8], ptr %name75, i64 0, i64 0
  %52 = load ptr, ptr %node.addr, align 8
  %human_nodename77 = getelementptr inbounds %struct._clusterNode, ptr %52, i32 0, i32 23
  %53 = load ptr, ptr %human_nodename77, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.116, ptr noundef %arraydecay76, ptr noundef %53)
  br label %do.end78

do.end78:                                         ; preds = %if.end74, %if.then73
  br label %if.end79

if.end79:                                         ; preds = %do.end78, %if.else65
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %do.end64
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %do.end52
  br label %do.end154

if.end82:                                         ; preds = %land.lhs.true, %lor.lhs.false35
  %call83 = call i64 @mstime()
  %54 = load ptr, ptr %node.addr, align 8
  %slaveof84 = getelementptr inbounds %struct._clusterNode, ptr %54, i32 0, i32 11
  %55 = load ptr, ptr %slaveof84, align 8
  %voted_time = getelementptr inbounds %struct._clusterNode, ptr %55, i32 0, i32 17
  %56 = load i64, ptr %voted_time, align 8
  %sub = sub nsw i64 %call83, %56
  %57 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %mul = mul nsw i64 %57, 2
  %cmp85 = icmp slt i64 %sub, %mul
  br i1 %cmp85, label %if.then87, label %if.end103

if.then87:                                        ; preds = %if.end82
  br label %do.body88

do.body88:                                        ; preds = %if.then87
  %58 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp89 = icmp slt i32 3, %58
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %do.body88
  br label %do.end102

if.end92:                                         ; preds = %do.body88
  %59 = load ptr, ptr %node.addr, align 8
  %name93 = getelementptr inbounds %struct._clusterNode, ptr %59, i32 0, i32 1
  %arraydecay94 = getelementptr inbounds [40 x i8], ptr %name93, i64 0, i64 0
  %60 = load ptr, ptr %node.addr, align 8
  %human_nodename95 = getelementptr inbounds %struct._clusterNode, ptr %60, i32 0, i32 23
  %61 = load ptr, ptr %human_nodename95, align 8
  %62 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %mul96 = mul nsw i64 %62, 2
  %call97 = call i64 @mstime()
  %63 = load ptr, ptr %node.addr, align 8
  %slaveof98 = getelementptr inbounds %struct._clusterNode, ptr %63, i32 0, i32 11
  %64 = load ptr, ptr %slaveof98, align 8
  %voted_time99 = getelementptr inbounds %struct._clusterNode, ptr %64, i32 0, i32 17
  %65 = load i64, ptr %voted_time99, align 8
  %sub100 = sub nsw i64 %call97, %65
  %sub101 = sub nsw i64 %mul96, %sub100
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.117, ptr noundef %arraydecay94, ptr noundef %61, i64 noundef %sub101)
  br label %do.end102

do.end102:                                        ; preds = %if.end92, %if.then91
  br label %do.end154

if.end103:                                        ; preds = %if.end82
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end103
  %66 = load i32, ptr %j, align 4
  %cmp104 = icmp slt i32 %66, 16384
  br i1 %cmp104, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %67 = load ptr, ptr %claimed_slots, align 8
  %68 = load i32, ptr %j, align 4
  %call106 = call i32 @bitmapTestBit(ptr noundef %67, i32 noundef %68)
  %cmp107 = icmp eq i32 %call106, 0
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %for.body
  br label %for.inc

if.end110:                                        ; preds = %for.body
  %69 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %69, i32 0, i32 9
  %70 = load i32, ptr %j, align 4
  %idxprom = sext i32 %70 to i64
  %arrayidx111 = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom
  %71 = load ptr, ptr %arrayidx111, align 8
  %cmp112 = icmp eq ptr %71, null
  br i1 %cmp112, label %if.then125, label %lor.lhs.false114

lor.lhs.false114:                                 ; preds = %if.end110
  %72 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %owner_not_claiming_slot = getelementptr inbounds %struct.clusterState, ptr %72, i32 0, i32 27
  %arraydecay115 = getelementptr inbounds [2048 x i8], ptr %owner_not_claiming_slot, i64 0, i64 0
  %73 = load i32, ptr %j, align 4
  %call116 = call i32 @bitmapTestBit(ptr noundef %arraydecay115, i32 noundef %73)
  %tobool117 = icmp ne i32 %call116, 0
  br i1 %tobool117, label %if.then125, label %lor.lhs.false118

lor.lhs.false118:                                 ; preds = %lor.lhs.false114
  %74 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots119 = getelementptr inbounds %struct.clusterState, ptr %74, i32 0, i32 9
  %75 = load i32, ptr %j, align 4
  %idxprom120 = sext i32 %75 to i64
  %arrayidx121 = getelementptr inbounds [16384 x ptr], ptr %slots119, i64 0, i64 %idxprom120
  %76 = load ptr, ptr %arrayidx121, align 8
  %configEpoch122 = getelementptr inbounds %struct._clusterNode, ptr %76, i32 0, i32 4
  %77 = load i64, ptr %configEpoch122, align 8
  %78 = load i64, ptr %requestConfigEpoch, align 8
  %cmp123 = icmp ule i64 %77, %78
  br i1 %cmp123, label %if.then125, label %if.end126

if.then125:                                       ; preds = %lor.lhs.false118, %lor.lhs.false114, %if.end110
  br label %for.inc

if.end126:                                        ; preds = %lor.lhs.false118
  br label %do.body127

do.body127:                                       ; preds = %if.end126
  %79 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp128 = icmp slt i32 3, %79
  br i1 %cmp128, label %if.then130, label %if.end131

if.then130:                                       ; preds = %do.body127
  br label %do.end139

if.end131:                                        ; preds = %do.body127
  %80 = load ptr, ptr %node.addr, align 8
  %name132 = getelementptr inbounds %struct._clusterNode, ptr %80, i32 0, i32 1
  %arraydecay133 = getelementptr inbounds [40 x i8], ptr %name132, i64 0, i64 0
  %81 = load ptr, ptr %node.addr, align 8
  %human_nodename134 = getelementptr inbounds %struct._clusterNode, ptr %81, i32 0, i32 23
  %82 = load ptr, ptr %human_nodename134, align 8
  %83 = load i32, ptr %j, align 4
  %84 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots135 = getelementptr inbounds %struct.clusterState, ptr %84, i32 0, i32 9
  %85 = load i32, ptr %j, align 4
  %idxprom136 = sext i32 %85 to i64
  %arrayidx137 = getelementptr inbounds [16384 x ptr], ptr %slots135, i64 0, i64 %idxprom136
  %86 = load ptr, ptr %arrayidx137, align 8
  %configEpoch138 = getelementptr inbounds %struct._clusterNode, ptr %86, i32 0, i32 4
  %87 = load i64, ptr %configEpoch138, align 8
  %88 = load i64, ptr %requestConfigEpoch, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.118, ptr noundef %arraydecay133, ptr noundef %82, i32 noundef %83, i64 noundef %87, i64 noundef %88)
  br label %do.end139

do.end139:                                        ; preds = %if.end131, %if.then130
  br label %do.end154

for.inc:                                          ; preds = %if.then125, %if.then109
  %89 = load i32, ptr %j, align 4
  %inc = add nsw i32 %89, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !46

for.end:                                          ; preds = %for.cond
  %90 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch140 = getelementptr inbounds %struct.clusterState, ptr %90, i32 0, i32 1
  %91 = load i64, ptr %currentEpoch140, align 8
  %92 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %lastVoteEpoch141 = getelementptr inbounds %struct.clusterState, ptr %92, i32 0, i32 21
  store i64 %91, ptr %lastVoteEpoch141, align 8
  %call142 = call i64 @mstime()
  %93 = load ptr, ptr %node.addr, align 8
  %slaveof143 = getelementptr inbounds %struct._clusterNode, ptr %93, i32 0, i32 11
  %94 = load ptr, ptr %slaveof143, align 8
  %voted_time144 = getelementptr inbounds %struct._clusterNode, ptr %94, i32 0, i32 17
  store i64 %call142, ptr %voted_time144, align 8
  call void @clusterDoBeforeSleep(i32 noundef 12)
  %95 = load ptr, ptr %node.addr, align 8
  call void @clusterSendFailoverAuth(ptr noundef %95)
  br label %do.body145

do.body145:                                       ; preds = %for.end
  %96 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp146 = icmp slt i32 2, %96
  br i1 %cmp146, label %if.then148, label %if.end149

if.then148:                                       ; preds = %do.body145
  br label %do.end154

if.end149:                                        ; preds = %do.body145
  %97 = load ptr, ptr %node.addr, align 8
  %name150 = getelementptr inbounds %struct._clusterNode, ptr %97, i32 0, i32 1
  %arraydecay151 = getelementptr inbounds [40 x i8], ptr %name150, i64 0, i64 0
  %98 = load ptr, ptr %node.addr, align 8
  %human_nodename152 = getelementptr inbounds %struct._clusterNode, ptr %98, i32 0, i32 23
  %99 = load ptr, ptr %human_nodename152, align 8
  %100 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch153 = getelementptr inbounds %struct.clusterState, ptr %100, i32 0, i32 1
  %101 = load i64, ptr %currentEpoch153, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.119, ptr noundef %arraydecay151, ptr noundef %99, i64 noundef %101)
  br label %do.end154

do.end154:                                        ; preds = %if.end149, %if.then148, %do.end139, %do.end102, %if.end81, %do.end28, %do.end, %if.then
  ret void
}

declare void @pauseActions(i32 noundef, i64 noundef, i32 noundef) #1

declare void @moduleCallClusterReceivers(ptr noundef, i64 noundef, i8 noundef zeroext, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @handleLinkIOError(ptr noundef %link) #0 {
entry:
  %link.addr = alloca ptr, align 8
  store ptr %link, ptr %link.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  call void @freeClusterLink(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterWriteHandler(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %link = alloca ptr, align 8
  %nwritten = alloca i64, align 8
  %totwritten = alloca i64, align 8
  %head = alloca ptr, align 8
  %msgblock = alloca ptr, align 8
  %msg = alloca ptr, align 8
  %msg_offset = alloca i64, align 8
  %msg_len = alloca i64, align 8
  %blocklen = alloca i32, align 4
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %call = call ptr @connGetPrivateData(ptr noundef %0)
  store ptr %call, ptr %link, align 8
  store i64 0, ptr %totwritten, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end30, %entry
  %1 = load i64, ptr %totwritten, align 8
  %cmp = icmp ult i64 %1, 65536
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %2 = load ptr, ptr %link, align 8
  %send_msg_queue = getelementptr inbounds %struct.clusterLink, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %send_msg_queue, align 8
  %len = getelementptr inbounds %struct.list, ptr %3, i32 0, i32 5
  %4 = load i64, ptr %len, align 8
  %cmp1 = icmp ugt i64 %4, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %5 = phi i1 [ false, %while.cond ], [ %cmp1, %land.rhs ]
  br i1 %5, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %6 = load ptr, ptr %link, align 8
  %send_msg_queue2 = getelementptr inbounds %struct.clusterLink, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %send_msg_queue2, align 8
  %head3 = getelementptr inbounds %struct.list, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %head3, align 8
  store ptr %8, ptr %head, align 8
  %9 = load ptr, ptr %head, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %value, align 8
  store ptr %10, ptr %msgblock, align 8
  %11 = load ptr, ptr %msgblock, align 8
  %msg4 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %11, i32 0, i32 2
  store ptr %msg4, ptr %msg, align 8
  %12 = load ptr, ptr %link, align 8
  %head_msg_send_offset = getelementptr inbounds %struct.clusterLink, ptr %12, i32 0, i32 3
  %13 = load i64, ptr %head_msg_send_offset, align 8
  store i64 %13, ptr %msg_offset, align 8
  %14 = load ptr, ptr %msg, align 8
  %totlen = getelementptr inbounds %struct.clusterMsg, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %totlen, align 4
  %call5 = call i32 @ntohl(i32 noundef %15) #14
  %conv = zext i32 %call5 to i64
  store i64 %conv, ptr %msg_len, align 8
  %16 = load ptr, ptr %conn.addr, align 8
  %17 = load ptr, ptr %msg, align 8
  %18 = load i64, ptr %msg_offset, align 8
  %add.ptr = getelementptr inbounds i8, ptr %17, i64 %18
  %19 = load i64, ptr %msg_len, align 8
  %20 = load i64, ptr %msg_offset, align 8
  %sub = sub i64 %19, %20
  %call6 = call i32 @connWrite(ptr noundef %16, ptr noundef %add.ptr, i64 noundef %sub)
  %conv7 = sext i32 %call6 to i64
  store i64 %conv7, ptr %nwritten, align 8
  %21 = load i64, ptr %nwritten, align 8
  %cmp8 = icmp sle i64 %21, 0
  br i1 %cmp8, label %if.then, label %if.end16

if.then:                                          ; preds = %while.body
  br label %do.body

do.body:                                          ; preds = %if.then
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp10 = icmp slt i32 0, %22
  br i1 %cmp10, label %if.then12, label %if.end

if.then12:                                        ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %23 = load i64, ptr %nwritten, align 8
  %cmp13 = icmp eq i64 %23, -1
  br i1 %cmp13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %24 = load ptr, ptr %conn.addr, align 8
  %call15 = call ptr @connGetLastError(ptr noundef %24)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call15, %cond.true ], [ @.str.101, %cond.false ]
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.100, ptr noundef %cond)
  br label %do.end

do.end:                                           ; preds = %cond.end, %if.then12
  %25 = load ptr, ptr %link, align 8
  call void @handleLinkIOError(ptr noundef %25)
  br label %if.end47

if.end16:                                         ; preds = %while.body
  %26 = load i64, ptr %msg_offset, align 8
  %27 = load i64, ptr %nwritten, align 8
  %add = add i64 %26, %27
  %28 = load i64, ptr %msg_len, align 8
  %cmp17 = icmp ult i64 %add, %28
  br i1 %cmp17, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end16
  %29 = load i64, ptr %nwritten, align 8
  %30 = load ptr, ptr %link, align 8
  %head_msg_send_offset20 = getelementptr inbounds %struct.clusterLink, ptr %30, i32 0, i32 3
  %31 = load i64, ptr %head_msg_send_offset20, align 8
  %add21 = add i64 %31, %29
  store i64 %add21, ptr %head_msg_send_offset20, align 8
  br label %if.end47

if.end22:                                         ; preds = %if.end16
  %32 = load i64, ptr %msg_offset, align 8
  %33 = load i64, ptr %nwritten, align 8
  %add23 = add i64 %32, %33
  %34 = load i64, ptr %msg_len, align 8
  %cmp24 = icmp eq i64 %add23, %34
  %lnot = xor i1 %cmp24, true
  %lnot26 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot26 to i32
  %conv27 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv27, 0
  br i1 %tobool, label %cond.true28, label %cond.false29

cond.true28:                                      ; preds = %if.end22
  br label %cond.end30

cond.false29:                                     ; preds = %if.end22
  call void @_serverAssert(ptr noundef @.str.102, ptr noundef @.str.18, i32 noundef 3195)
  call void @abort() #13
  unreachable

35:                                               ; No predecessors!
  br label %cond.end30

cond.end30:                                       ; preds = %35, %cond.true28
  %36 = load ptr, ptr %link, align 8
  %head_msg_send_offset31 = getelementptr inbounds %struct.clusterLink, ptr %36, i32 0, i32 3
  store i64 0, ptr %head_msg_send_offset31, align 8
  %37 = load ptr, ptr %msgblock, align 8
  %totlen32 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %37, i32 0, i32 0
  %38 = load i64, ptr %totlen32, align 8
  %conv33 = trunc i64 %38 to i32
  store i32 %conv33, ptr %blocklen, align 4
  %39 = load ptr, ptr %link, align 8
  %send_msg_queue34 = getelementptr inbounds %struct.clusterLink, ptr %39, i32 0, i32 2
  %40 = load ptr, ptr %send_msg_queue34, align 8
  %41 = load ptr, ptr %head, align 8
  call void @listDelNode(ptr noundef %40, ptr noundef %41)
  %42 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %sub35 = sub i64 %42, 24
  store i64 %sub35, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %43 = load i32, ptr %blocklen, align 4
  %conv36 = zext i32 %43 to i64
  %add37 = add i64 24, %conv36
  %44 = load ptr, ptr %link, align 8
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %44, i32 0, i32 4
  %45 = load i64, ptr %send_msg_queue_mem, align 8
  %sub38 = sub i64 %45, %add37
  store i64 %sub38, ptr %send_msg_queue_mem, align 8
  %46 = load i64, ptr %nwritten, align 8
  %47 = load i64, ptr %totwritten, align 8
  %add39 = add i64 %47, %46
  store i64 %add39, ptr %totwritten, align 8
  br label %while.cond, !llvm.loop !47

while.end:                                        ; preds = %land.end
  %48 = load ptr, ptr %link, align 8
  %send_msg_queue40 = getelementptr inbounds %struct.clusterLink, ptr %48, i32 0, i32 2
  %49 = load ptr, ptr %send_msg_queue40, align 8
  %len41 = getelementptr inbounds %struct.list, ptr %49, i32 0, i32 5
  %50 = load i64, ptr %len41, align 8
  %cmp42 = icmp eq i64 %50, 0
  br i1 %cmp42, label %if.then44, label %if.end47

if.then44:                                        ; preds = %while.end
  %51 = load ptr, ptr %link, align 8
  %conn45 = getelementptr inbounds %struct.clusterLink, ptr %51, i32 0, i32 1
  %52 = load ptr, ptr %conn45, align 8
  %call46 = call i32 @connSetWriteHandler(ptr noundef %52, ptr noundef null)
  br label %if.end47

if.end47:                                         ; preds = %if.then44, %while.end, %if.then19, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @connGetPrivateData(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %private_data = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 7
  %1 = load ptr, ptr %private_data, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal i32 @connWrite(ptr noundef %conn, ptr noundef %data, i64 noundef %data_len) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %data_len.addr = alloca i64, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store i64 %data_len, ptr %data_len.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %write = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 16
  %2 = load ptr, ptr %write, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %4 = load ptr, ptr %data.addr, align 8
  %5 = load i64, ptr %data_len.addr, align 8
  %call = call i32 %2(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @connSetWriteHandler(ptr noundef %conn, ptr noundef %func) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %func, ptr %func.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %set_write_handler = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 19
  %2 = load ptr, ptr %set_write_handler, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %4 = load ptr, ptr %func.addr, align 8
  %call = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef 0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterLinkConnectHandler(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %link = alloca ptr, align 8
  %node = alloca ptr, align 8
  %old_ping_sent = alloca i64, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %call = call ptr @connGetPrivateData(ptr noundef %0)
  store ptr %call, ptr %link, align 8
  %1 = load ptr, ptr %link, align 8
  %node1 = getelementptr inbounds %struct.clusterLink, ptr %1, i32 0, i32 8
  %2 = load ptr, ptr %node1, align 8
  store ptr %2, ptr %node, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %call2 = call i32 @connGetState(ptr noundef %3)
  %cmp = icmp ne i32 %call2, 3
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp3 = icmp slt i32 1, %4
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %5 = load ptr, ptr %node, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %6 = load ptr, ptr %node, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 21
  %arraydecay5 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %7 = load ptr, ptr %node, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 26
  %8 = load i32, ptr %cport, align 8
  %9 = load ptr, ptr %conn.addr, align 8
  %call6 = call ptr @connGetLastError(ptr noundef %9)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.103, ptr noundef %arraydecay, ptr noundef %arraydecay5, i32 noundef %8, ptr noundef %call6)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then4
  %10 = load ptr, ptr %link, align 8
  call void @freeClusterLink(ptr noundef %10)
  br label %do.end24

if.end7:                                          ; preds = %entry
  %11 = load ptr, ptr %conn.addr, align 8
  %call8 = call i32 @connSetReadHandler(ptr noundef %11, ptr noundef @clusterReadHandler)
  %12 = load ptr, ptr %node, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 13
  %13 = load i64, ptr %ping_sent, align 8
  store i64 %13, ptr %old_ping_sent, align 8
  %14 = load ptr, ptr %link, align 8
  %15 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %flags, align 8
  %and = and i32 %16, 128
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 2, i32 0
  call void @clusterSendPing(ptr noundef %14, i32 noundef %cond)
  %17 = load i64, ptr %old_ping_sent, align 8
  %tobool9 = icmp ne i64 %17, 0
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end7
  %18 = load i64, ptr %old_ping_sent, align 8
  %19 = load ptr, ptr %node, align 8
  %ping_sent11 = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 13
  store i64 %18, ptr %ping_sent11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end7
  %20 = load ptr, ptr %node, align 8
  %flags13 = getelementptr inbounds %struct._clusterNode, ptr %20, i32 0, i32 3
  %21 = load i32, ptr %flags13, align 8
  %and14 = and i32 %21, -129
  store i32 %and14, ptr %flags13, align 8
  br label %do.body15

do.body15:                                        ; preds = %if.end12
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp16 = icmp slt i32 0, %22
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %do.body15
  br label %do.end24

if.end18:                                         ; preds = %do.body15
  %23 = load ptr, ptr %node, align 8
  %name19 = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 1
  %arraydecay20 = getelementptr inbounds [40 x i8], ptr %name19, i64 0, i64 0
  %24 = load ptr, ptr %node, align 8
  %ip21 = getelementptr inbounds %struct._clusterNode, ptr %24, i32 0, i32 21
  %arraydecay22 = getelementptr inbounds [46 x i8], ptr %ip21, i64 0, i64 0
  %25 = load ptr, ptr %node, align 8
  %cport23 = getelementptr inbounds %struct._clusterNode, ptr %25, i32 0, i32 26
  %26 = load i32, ptr %cport23, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.104, ptr noundef %arraydecay20, ptr noundef %arraydecay22, i32 noundef %26)
  br label %do.end24

do.end24:                                         ; preds = %if.end18, %if.then17, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @connSetReadHandler(ptr noundef %conn, ptr noundef %func) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %func, ptr %func.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %set_read_handler = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 20
  %2 = load ptr, ptr %set_read_handler, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %4 = load ptr, ptr %func.addr, align 8
  %call = call i32 %2(ptr noundef %3, ptr noundef %4)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterReadHandler(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %buf = alloca [1 x %struct.clusterMsg], align 16
  %nread = alloca i64, align 8
  %hdr = alloca ptr, align 8
  %link = alloca ptr, align 8
  %readlen = alloca i32, align 4
  %rcvbuflen = alloca i32, align 4
  %ip = alloca [46 x i8], align 16
  %port = alloca i32, align 4
  %unused = alloca i64, align 8
  %required = alloca i64, align 8
  %prev_rcvbuf_alloc = alloca i64, align 8
  %prev_rcvbuf_alloc112 = alloca i64, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %call = call ptr @connGetPrivateData(ptr noundef %0)
  store ptr %call, ptr %link, align 8
  br label %while.body

while.body:                                       ; preds = %if.end125, %entry
  %1 = load ptr, ptr %link, align 8
  %rcvbuf_len = getelementptr inbounds %struct.clusterLink, ptr %1, i32 0, i32 6
  %2 = load i64, ptr %rcvbuf_len, align 8
  %conv = trunc i64 %2 to i32
  store i32 %conv, ptr %rcvbuflen, align 4
  %3 = load i32, ptr %rcvbuflen, align 4
  %cmp = icmp ult i32 %3, 8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %4 = load i32, ptr %rcvbuflen, align 4
  %sub = sub i32 8, %4
  store i32 %sub, ptr %readlen, align 4
  br label %if.end40

if.else:                                          ; preds = %while.body
  %5 = load ptr, ptr %link, align 8
  %rcvbuf = getelementptr inbounds %struct.clusterLink, ptr %5, i32 0, i32 5
  %6 = load ptr, ptr %rcvbuf, align 8
  store ptr %6, ptr %hdr, align 8
  %7 = load i32, ptr %rcvbuflen, align 4
  %cmp2 = icmp eq i32 %7, 8
  br i1 %cmp2, label %if.then4, label %if.end31

if.then4:                                         ; preds = %if.else
  %8 = load ptr, ptr %hdr, align 8
  %sig = getelementptr inbounds %struct.clusterMsg, ptr %8, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x i8], ptr %sig, i64 0, i64 0
  %call5 = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef @.str.105, i64 noundef 4) #12
  %cmp6 = icmp ne i32 %call5, 0
  br i1 %cmp6, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then4
  %9 = load ptr, ptr %hdr, align 8
  %totlen = getelementptr inbounds %struct.clusterMsg, ptr %9, i32 0, i32 1
  %10 = load i32, ptr %totlen, align 4
  %call8 = call i32 @ntohl(i32 noundef %10) #14
  %conv9 = zext i32 %call8 to i64
  %cmp10 = icmp ult i64 %conv9, 2256
  br i1 %cmp10, label %if.then12, label %if.end30

if.then12:                                        ; preds = %lor.lhs.false, %if.then4
  %11 = load ptr, ptr %conn.addr, align 8
  %arraydecay13 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %call14 = call i32 @connAddrPeerName(ptr noundef %11, ptr noundef %arraydecay13, i64 noundef 46, ptr noundef %port)
  %cmp15 = icmp eq i32 %call14, -1
  br i1 %cmp15, label %if.then17, label %if.else21

if.then17:                                        ; preds = %if.then12
  br label %do.body

do.body:                                          ; preds = %if.then17
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp18 = icmp slt i32 3, %12
  br i1 %cmp18, label %if.then20, label %if.end

if.then20:                                        ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.106)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then20
  br label %if.end29

if.else21:                                        ; preds = %if.then12
  br label %do.body22

do.body22:                                        ; preds = %if.else21
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp23 = icmp slt i32 3, %13
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %do.body22
  br label %do.end28

if.end26:                                         ; preds = %do.body22
  %arraydecay27 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %14 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.107, ptr noundef %arraydecay27, i32 noundef %14)
  br label %do.end28

do.end28:                                         ; preds = %if.end26, %if.then25
  br label %if.end29

if.end29:                                         ; preds = %do.end28, %do.end
  %15 = load ptr, ptr %link, align 8
  call void @handleLinkIOError(ptr noundef %15)
  br label %return

if.end30:                                         ; preds = %lor.lhs.false
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.else
  %16 = load ptr, ptr %hdr, align 8
  %totlen32 = getelementptr inbounds %struct.clusterMsg, ptr %16, i32 0, i32 1
  %17 = load i32, ptr %totlen32, align 4
  %call33 = call i32 @ntohl(i32 noundef %17) #14
  %18 = load i32, ptr %rcvbuflen, align 4
  %sub34 = sub i32 %call33, %18
  store i32 %sub34, ptr %readlen, align 4
  %19 = load i32, ptr %readlen, align 4
  %conv35 = zext i32 %19 to i64
  %cmp36 = icmp ugt i64 %conv35, 4352
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end31
  store i32 4352, ptr %readlen, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.end31
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then
  %20 = load ptr, ptr %conn.addr, align 8
  %arraydecay41 = getelementptr inbounds [1 x %struct.clusterMsg], ptr %buf, i64 0, i64 0
  %21 = load i32, ptr %readlen, align 4
  %conv42 = zext i32 %21 to i64
  %call43 = call i32 @connRead(ptr noundef %20, ptr noundef %arraydecay41, i64 noundef %conv42)
  %conv44 = sext i32 %call43 to i64
  store i64 %conv44, ptr %nread, align 8
  %22 = load i64, ptr %nread, align 8
  %cmp45 = icmp eq i64 %22, -1
  br i1 %cmp45, label %land.lhs.true, label %if.end51

land.lhs.true:                                    ; preds = %if.end40
  %23 = load ptr, ptr %conn.addr, align 8
  %call47 = call i32 @connGetState(ptr noundef %23)
  %cmp48 = icmp eq i32 %call47, 3
  br i1 %cmp48, label %if.then50, label %if.end51

if.then50:                                        ; preds = %land.lhs.true
  br label %return

if.end51:                                         ; preds = %land.lhs.true, %if.end40
  %24 = load i64, ptr %nread, align 8
  %cmp52 = icmp sle i64 %24, 0
  br i1 %cmp52, label %if.then54, label %if.else64

if.then54:                                        ; preds = %if.end51
  br label %do.body55

do.body55:                                        ; preds = %if.then54
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp56 = icmp slt i32 0, %25
  br i1 %cmp56, label %if.then58, label %if.end59

if.then58:                                        ; preds = %do.body55
  br label %do.end63

if.end59:                                         ; preds = %do.body55
  %26 = load i64, ptr %nread, align 8
  %cmp60 = icmp eq i64 %26, 0
  br i1 %cmp60, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end59
  br label %cond.end

cond.false:                                       ; preds = %if.end59
  %27 = load ptr, ptr %conn.addr, align 8
  %call62 = call ptr @connGetLastError(ptr noundef %27)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ @.str.109, %cond.true ], [ %call62, %cond.false ]
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.108, ptr noundef %cond)
  br label %do.end63

do.end63:                                         ; preds = %cond.end, %if.then58
  %28 = load ptr, ptr %link, align 8
  call void @handleLinkIOError(ptr noundef %28)
  br label %return

if.else64:                                        ; preds = %if.end51
  %29 = load ptr, ptr %link, align 8
  %rcvbuf_alloc = getelementptr inbounds %struct.clusterLink, ptr %29, i32 0, i32 7
  %30 = load i64, ptr %rcvbuf_alloc, align 8
  %31 = load ptr, ptr %link, align 8
  %rcvbuf_len65 = getelementptr inbounds %struct.clusterLink, ptr %31, i32 0, i32 6
  %32 = load i64, ptr %rcvbuf_len65, align 8
  %sub66 = sub i64 %30, %32
  store i64 %sub66, ptr %unused, align 8
  %33 = load i64, ptr %nread, align 8
  %34 = load i64, ptr %unused, align 8
  %cmp67 = icmp ugt i64 %33, %34
  br i1 %cmp67, label %if.then69, label %if.end87

if.then69:                                        ; preds = %if.else64
  %35 = load ptr, ptr %link, align 8
  %rcvbuf_len70 = getelementptr inbounds %struct.clusterLink, ptr %35, i32 0, i32 6
  %36 = load i64, ptr %rcvbuf_len70, align 8
  %37 = load i64, ptr %nread, align 8
  %add = add i64 %36, %37
  store i64 %add, ptr %required, align 8
  %38 = load ptr, ptr %link, align 8
  %rcvbuf_alloc71 = getelementptr inbounds %struct.clusterLink, ptr %38, i32 0, i32 7
  %39 = load i64, ptr %rcvbuf_alloc71, align 8
  store i64 %39, ptr %prev_rcvbuf_alloc, align 8
  %40 = load i64, ptr %required, align 8
  %cmp72 = icmp ult i64 %40, 1048576
  br i1 %cmp72, label %cond.true74, label %cond.false75

cond.true74:                                      ; preds = %if.then69
  %41 = load i64, ptr %required, align 8
  %mul = mul i64 %41, 2
  br label %cond.end77

cond.false75:                                     ; preds = %if.then69
  %42 = load i64, ptr %required, align 8
  %add76 = add i64 %42, 1048576
  br label %cond.end77

cond.end77:                                       ; preds = %cond.false75, %cond.true74
  %cond78 = phi i64 [ %mul, %cond.true74 ], [ %add76, %cond.false75 ]
  %43 = load ptr, ptr %link, align 8
  %rcvbuf_alloc79 = getelementptr inbounds %struct.clusterLink, ptr %43, i32 0, i32 7
  store i64 %cond78, ptr %rcvbuf_alloc79, align 8
  %44 = load ptr, ptr %link, align 8
  %rcvbuf80 = getelementptr inbounds %struct.clusterLink, ptr %44, i32 0, i32 5
  %45 = load ptr, ptr %rcvbuf80, align 8
  %46 = load ptr, ptr %link, align 8
  %rcvbuf_alloc81 = getelementptr inbounds %struct.clusterLink, ptr %46, i32 0, i32 7
  %47 = load i64, ptr %rcvbuf_alloc81, align 8
  %call82 = call ptr @zrealloc(ptr noundef %45, i64 noundef %47) #17
  %48 = load ptr, ptr %link, align 8
  %rcvbuf83 = getelementptr inbounds %struct.clusterLink, ptr %48, i32 0, i32 5
  store ptr %call82, ptr %rcvbuf83, align 8
  %49 = load ptr, ptr %link, align 8
  %rcvbuf_alloc84 = getelementptr inbounds %struct.clusterLink, ptr %49, i32 0, i32 7
  %50 = load i64, ptr %rcvbuf_alloc84, align 8
  %51 = load i64, ptr %prev_rcvbuf_alloc, align 8
  %sub85 = sub i64 %50, %51
  %52 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %add86 = add i64 %52, %sub85
  store i64 %add86, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  br label %if.end87

if.end87:                                         ; preds = %cond.end77, %if.else64
  %53 = load ptr, ptr %link, align 8
  %rcvbuf88 = getelementptr inbounds %struct.clusterLink, ptr %53, i32 0, i32 5
  %54 = load ptr, ptr %rcvbuf88, align 8
  %55 = load ptr, ptr %link, align 8
  %rcvbuf_len89 = getelementptr inbounds %struct.clusterLink, ptr %55, i32 0, i32 6
  %56 = load i64, ptr %rcvbuf_len89, align 8
  %add.ptr = getelementptr inbounds i8, ptr %54, i64 %56
  %arraydecay90 = getelementptr inbounds [1 x %struct.clusterMsg], ptr %buf, i64 0, i64 0
  %57 = load i64, ptr %nread, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr align 16 %arraydecay90, i64 %57, i1 false)
  %58 = load i64, ptr %nread, align 8
  %59 = load ptr, ptr %link, align 8
  %rcvbuf_len91 = getelementptr inbounds %struct.clusterLink, ptr %59, i32 0, i32 6
  %60 = load i64, ptr %rcvbuf_len91, align 8
  %add92 = add i64 %60, %58
  store i64 %add92, ptr %rcvbuf_len91, align 8
  %61 = load ptr, ptr %link, align 8
  %rcvbuf93 = getelementptr inbounds %struct.clusterLink, ptr %61, i32 0, i32 5
  %62 = load ptr, ptr %rcvbuf93, align 8
  store ptr %62, ptr %hdr, align 8
  %63 = load i64, ptr %nread, align 8
  %64 = load i32, ptr %rcvbuflen, align 4
  %conv94 = zext i32 %64 to i64
  %add95 = add nsw i64 %conv94, %63
  %conv96 = trunc i64 %add95 to i32
  store i32 %conv96, ptr %rcvbuflen, align 4
  br label %if.end97

if.end97:                                         ; preds = %if.end87
  %65 = load i32, ptr %rcvbuflen, align 4
  %cmp98 = icmp uge i32 %65, 8
  br i1 %cmp98, label %land.lhs.true100, label %if.end125

land.lhs.true100:                                 ; preds = %if.end97
  %66 = load i32, ptr %rcvbuflen, align 4
  %67 = load ptr, ptr %hdr, align 8
  %totlen101 = getelementptr inbounds %struct.clusterMsg, ptr %67, i32 0, i32 1
  %68 = load i32, ptr %totlen101, align 4
  %call102 = call i32 @ntohl(i32 noundef %68) #14
  %cmp103 = icmp eq i32 %66, %call102
  br i1 %cmp103, label %if.then105, label %if.end125

if.then105:                                       ; preds = %land.lhs.true100
  %69 = load ptr, ptr %link, align 8
  %call106 = call i32 @clusterProcessPacket(ptr noundef %69)
  %tobool = icmp ne i32 %call106, 0
  br i1 %tobool, label %if.then107, label %if.else123

if.then107:                                       ; preds = %if.then105
  %70 = load ptr, ptr %link, align 8
  %rcvbuf_alloc108 = getelementptr inbounds %struct.clusterLink, ptr %70, i32 0, i32 7
  %71 = load i64, ptr %rcvbuf_alloc108, align 8
  %cmp109 = icmp ugt i64 %71, 1024
  br i1 %cmp109, label %if.then111, label %if.end121

if.then111:                                       ; preds = %if.then107
  %72 = load ptr, ptr %link, align 8
  %rcvbuf_alloc113 = getelementptr inbounds %struct.clusterLink, ptr %72, i32 0, i32 7
  %73 = load i64, ptr %rcvbuf_alloc113, align 8
  store i64 %73, ptr %prev_rcvbuf_alloc112, align 8
  %74 = load ptr, ptr %link, align 8
  %rcvbuf114 = getelementptr inbounds %struct.clusterLink, ptr %74, i32 0, i32 5
  %75 = load ptr, ptr %rcvbuf114, align 8
  call void @zfree(ptr noundef %75)
  %76 = load ptr, ptr %link, align 8
  %rcvbuf_alloc115 = getelementptr inbounds %struct.clusterLink, ptr %76, i32 0, i32 7
  store i64 1024, ptr %rcvbuf_alloc115, align 8
  %call116 = call noalias ptr @zmalloc(i64 noundef 1024) #16
  %77 = load ptr, ptr %link, align 8
  %rcvbuf117 = getelementptr inbounds %struct.clusterLink, ptr %77, i32 0, i32 5
  store ptr %call116, ptr %rcvbuf117, align 8
  %78 = load ptr, ptr %link, align 8
  %rcvbuf_alloc118 = getelementptr inbounds %struct.clusterLink, ptr %78, i32 0, i32 7
  %79 = load i64, ptr %rcvbuf_alloc118, align 8
  %80 = load i64, ptr %prev_rcvbuf_alloc112, align 8
  %sub119 = sub i64 %79, %80
  %81 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %add120 = add i64 %81, %sub119
  store i64 %add120, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  br label %if.end121

if.end121:                                        ; preds = %if.then111, %if.then107
  %82 = load ptr, ptr %link, align 8
  %rcvbuf_len122 = getelementptr inbounds %struct.clusterLink, ptr %82, i32 0, i32 6
  store i64 0, ptr %rcvbuf_len122, align 8
  br label %if.end124

if.else123:                                       ; preds = %if.then105
  br label %return

if.end124:                                        ; preds = %if.end121
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %land.lhs.true100, %if.end97
  br label %while.body

return:                                           ; preds = %if.else123, %do.end63, %if.then50, %if.end29
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @connRead(ptr noundef %conn, ptr noundef %buf, i64 noundef %buf_len) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %buf_len.addr = alloca i64, align 8
  %ret = alloca i32, align 4
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %buf_len, ptr %buf_len.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %read = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 18
  %2 = load ptr, ptr %read, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %4 = load ptr, ptr %buf.addr, align 8
  %5 = load i64, ptr %buf_len.addr, align 8
  %call = call i32 %2(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  store i32 %call, ptr %ret, align 4
  %6 = load i32, ptr %ret, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendMessage(ptr noundef %link, ptr noundef %msgblock) #0 {
entry:
  %link.addr = alloca ptr, align 8
  %msgblock.addr = alloca ptr, align 8
  %type = alloca i16, align 2
  store ptr %link, ptr %link.addr, align 8
  store ptr %msgblock, ptr %msgblock.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end16

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %link.addr, align 8
  %send_msg_queue = getelementptr inbounds %struct.clusterLink, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %send_msg_queue, align 8
  %len = getelementptr inbounds %struct.list, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %3, 0
  br i1 %cmp, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %msgblock.addr, align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %4, i32 0, i32 2
  %totlen = getelementptr inbounds %struct.clusterMsg, ptr %msg, i32 0, i32 1
  %5 = load i32, ptr %totlen, align 4
  %cmp1 = icmp ne i32 %5, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %land.lhs.true
  %6 = load ptr, ptr %link.addr, align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %conn, align 8
  %call = call i32 @connSetWriteHandlerWithBarrier(ptr noundef %7, ptr noundef @clusterWriteHandler, i32 noundef 1)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %land.lhs.true, %if.end
  %8 = load ptr, ptr %link.addr, align 8
  %send_msg_queue4 = getelementptr inbounds %struct.clusterLink, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %send_msg_queue4, align 8
  %10 = load ptr, ptr %msgblock.addr, align 8
  %call5 = call ptr @listAddNodeTail(ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %msgblock.addr, align 8
  %refcount = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %refcount, align 8
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %refcount, align 8
  %13 = load ptr, ptr %msgblock.addr, align 8
  %totlen6 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %13, i32 0, i32 0
  %14 = load i64, ptr %totlen6, align 8
  %add = add i64 24, %14
  %15 = load ptr, ptr %link.addr, align 8
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %15, i32 0, i32 4
  %16 = load i64, ptr %send_msg_queue_mem, align 8
  %add7 = add i64 %16, %add
  store i64 %add7, ptr %send_msg_queue_mem, align 8
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %add8 = add i64 %17, 24
  store i64 %add8, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %18 = load ptr, ptr %msgblock.addr, align 8
  %msg9 = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %18, i32 0, i32 2
  %type10 = getelementptr inbounds %struct.clusterMsg, ptr %msg9, i32 0, i32 4
  %19 = load i16, ptr %type10, align 4
  %call11 = call zeroext i16 @ntohs(i16 noundef zeroext %19) #14
  store i16 %call11, ptr %type, align 2
  %20 = load i16, ptr %type, align 2
  %conv = zext i16 %20 to i32
  %cmp12 = icmp slt i32 %conv, 11
  br i1 %cmp12, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end3
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_sent = getelementptr inbounds %struct.clusterState, ptr %21, i32 0, i32 23
  %22 = load i16, ptr %type, align 2
  %idxprom = zext i16 %22 to i64
  %arrayidx = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_sent, i64 0, i64 %idxprom
  %23 = load i64, ptr %arrayidx, align 8
  %inc15 = add nsw i64 %23, 1
  store i64 %inc15, ptr %arrayidx, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end3, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @connSetWriteHandlerWithBarrier(ptr noundef %conn, ptr noundef %func, i32 noundef %barrier) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  %barrier.addr = alloca i32, align 4
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %func, ptr %func.addr, align 8
  store i32 %barrier, ptr %barrier.addr, align 4
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %set_write_handler = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 19
  %2 = load ptr, ptr %set_write_handler, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %4 = load ptr, ptr %func.addr, align 8
  %5 = load i32, ptr %barrier.addr, align 4
  %call = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef %5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterBroadcastMessage(ptr noundef %msgblock) #0 {
entry:
  %msgblock.addr = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %node = alloca ptr, align 8
  store ptr %msgblock, ptr %msgblock.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %1)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then, %entry
  %2 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %2)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %3)
  store ptr %call2, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %flags, align 8
  %and = and i32 %5, 48
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !48

if.end:                                           ; preds = %while.body
  %6 = load ptr, ptr %node, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 27
  %7 = load ptr, ptr %link, align 8
  %8 = load ptr, ptr %msgblock.addr, align 8
  call void @clusterSendMessage(ptr noundef %7, ptr noundef %8)
  br label %while.cond, !llvm.loop !48

while.end:                                        ; preds = %while.cond
  %9 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %9)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSetGossipEntry(ptr noundef %hdr, i32 noundef %i, ptr noundef %n) #0 {
entry:
  %hdr.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %gossip = alloca ptr, align 8
  store ptr %hdr, ptr %hdr.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %hdr.addr, align 8
  %data = getelementptr inbounds %struct.clusterMsg, ptr %0, i32 0, i32 20
  %gossip1 = getelementptr inbounds %struct.anon.0, ptr %data, i32 0, i32 0
  %1 = load i32, ptr %i.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [1 x %struct.clusterMsgDataGossip], ptr %gossip1, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %gossip, align 8
  %2 = load ptr, ptr %gossip, align 8
  %nodename = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [40 x i8], ptr %nodename, i64 0, i64 0
  %3 = load ptr, ptr %n.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 1
  %arraydecay2 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arraydecay, ptr align 8 %arraydecay2, i64 40, i1 false)
  %4 = load ptr, ptr %n.addr, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 13
  %5 = load i64, ptr %ping_sent, align 8
  %div = sdiv i64 %5, 1000
  %conv = trunc i64 %div to i32
  %call = call i32 @htonl(i32 noundef %conv) #14
  %6 = load ptr, ptr %gossip, align 8
  %ping_sent3 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %6, i32 0, i32 1
  store i32 %call, ptr %ping_sent3, align 4
  %7 = load ptr, ptr %n.addr, align 8
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 14
  %8 = load i64, ptr %pong_received, align 8
  %div4 = sdiv i64 %8, 1000
  %conv5 = trunc i64 %div4 to i32
  %call6 = call i32 @htonl(i32 noundef %conv5) #14
  %9 = load ptr, ptr %gossip, align 8
  %pong_received7 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %9, i32 0, i32 2
  store i32 %call6, ptr %pong_received7, align 4
  %10 = load ptr, ptr %gossip, align 8
  %ip = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %10, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %11 = load ptr, ptr %n.addr, align 8
  %ip9 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 21
  %arraydecay10 = getelementptr inbounds [46 x i8], ptr %ip9, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arraydecay8, ptr align 8 %arraydecay10, i64 46, i1 false)
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %13 = load ptr, ptr %n.addr, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 25
  %14 = load i32, ptr %tls_port, align 4
  %conv11 = trunc i32 %14 to i16
  %call12 = call zeroext i16 @htons(i16 noundef zeroext %conv11) #14
  %15 = load ptr, ptr %gossip, align 8
  %port = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %15, i32 0, i32 4
  store i16 %call12, ptr %port, align 2
  %16 = load ptr, ptr %n.addr, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 24
  %17 = load i32, ptr %tcp_port, align 8
  %conv13 = trunc i32 %17 to i16
  %call14 = call zeroext i16 @htons(i16 noundef zeroext %conv13) #14
  %18 = load ptr, ptr %gossip, align 8
  %pport = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %18, i32 0, i32 7
  store i16 %call14, ptr %pport, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %19 = load ptr, ptr %n.addr, align 8
  %tcp_port15 = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 24
  %20 = load i32, ptr %tcp_port15, align 8
  %conv16 = trunc i32 %20 to i16
  %call17 = call zeroext i16 @htons(i16 noundef zeroext %conv16) #14
  %21 = load ptr, ptr %gossip, align 8
  %port18 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %21, i32 0, i32 4
  store i16 %call17, ptr %port18, align 2
  %22 = load ptr, ptr %n.addr, align 8
  %tls_port19 = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 25
  %23 = load i32, ptr %tls_port19, align 4
  %conv20 = trunc i32 %23 to i16
  %call21 = call zeroext i16 @htons(i16 noundef zeroext %conv20) #14
  %24 = load ptr, ptr %gossip, align 8
  %pport22 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %24, i32 0, i32 7
  store i16 %call21, ptr %pport22, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %25 = load ptr, ptr %n.addr, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %25, i32 0, i32 26
  %26 = load i32, ptr %cport, align 8
  %conv23 = trunc i32 %26 to i16
  %call24 = call zeroext i16 @htons(i16 noundef zeroext %conv23) #14
  %27 = load ptr, ptr %gossip, align 8
  %cport25 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %27, i32 0, i32 5
  store i16 %call24, ptr %cport25, align 4
  %28 = load ptr, ptr %n.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %28, i32 0, i32 3
  %29 = load i32, ptr %flags, align 8
  %conv26 = trunc i32 %29 to i16
  %call27 = call zeroext i16 @htons(i16 noundef zeroext %conv26) #14
  %30 = load ptr, ptr %gossip, align 8
  %flags28 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %30, i32 0, i32 6
  store i16 %call27, ptr %flags28, align 2
  %31 = load ptr, ptr %gossip, align 8
  %notused1 = getelementptr inbounds %struct.clusterMsgDataGossip, ptr %31, i32 0, i32 8
  store i16 0, ptr %notused1, align 2
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.floor.f64(double) #11

; Function Attrs: nounwind uwtable
define internal ptr @createClusterMsgSendBlock(i32 noundef %type, i32 noundef %msglen) #0 {
entry:
  %type.addr = alloca i32, align 4
  %msglen.addr = alloca i32, align 4
  %blocklen = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %msglen, ptr %msglen.addr, align 4
  %0 = load i32, ptr %msglen.addr, align 4
  %conv = zext i32 %0 to i64
  %add = add i64 %conv, 4368
  %sub = sub i64 %add, 4352
  %conv1 = trunc i64 %sub to i32
  store i32 %conv1, ptr %blocklen, align 4
  %1 = load i32, ptr %blocklen, align 4
  %conv2 = zext i32 %1 to i64
  %call = call noalias ptr @zcalloc(i64 noundef %conv2) #16
  store ptr %call, ptr %msgblock, align 8
  %2 = load ptr, ptr %msgblock, align 8
  %refcount = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %2, i32 0, i32 1
  store i32 1, ptr %refcount, align 8
  %3 = load i32, ptr %blocklen, align 4
  %conv3 = zext i32 %3 to i64
  %4 = load ptr, ptr %msgblock, align 8
  %totlen = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %4, i32 0, i32 0
  store i64 %conv3, ptr %totlen, align 8
  %5 = load i32, ptr %blocklen, align 4
  %conv4 = zext i32 %5 to i64
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %add5 = add i64 %6, %conv4
  store i64 %add5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  %7 = load ptr, ptr %msgblock, align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %7, i32 0, i32 2
  %8 = load i32, ptr %type.addr, align 4
  %9 = load i32, ptr %msglen.addr, align 4
  %conv6 = zext i32 %9 to i64
  call void @clusterBuildMessageHdr(ptr noundef %msg, i32 noundef %8, i64 noundef %conv6)
  %10 = load ptr, ptr %msgblock, align 8
  ret ptr %10
}

declare ptr @dictGetRandomKey(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterBroadcastPong(i32 noundef %target) #0 {
entry:
  %target.addr = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %node = alloca ptr, align 8
  %local_slave = alloca i32, align 4
  store i32 %target, ptr %target.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %1)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end21, %if.then19, %if.then5, %if.then, %entry
  %2 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %2)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %3)
  store ptr %call2, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 27
  %5 = load ptr, ptr %link, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !49

if.end:                                           ; preds = %while.body
  %6 = load ptr, ptr %node, align 8
  %7 = load ptr, ptr @myself, align 8
  %cmp3 = icmp eq ptr %6, %7
  br i1 %cmp3, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %8 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %flags, align 8
  %and = and i32 %9, 32
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  br label %while.cond, !llvm.loop !49

if.end6:                                          ; preds = %lor.lhs.false
  %10 = load i32, ptr %target.addr, align 4
  %cmp7 = icmp eq i32 %10, 1
  br i1 %cmp7, label %if.then8, label %if.end21

if.then8:                                         ; preds = %if.end6
  %11 = load ptr, ptr %node, align 8
  %flags9 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %flags9, align 8
  %and10 = and i32 %12, 2
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.then8
  %13 = load ptr, ptr %node, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 11
  %14 = load ptr, ptr %slaveof, align 8
  %tobool12 = icmp ne ptr %14, null
  br i1 %tobool12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %15 = load ptr, ptr %node, align 8
  %slaveof13 = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 11
  %16 = load ptr, ptr %slaveof13, align 8
  %17 = load ptr, ptr @myself, align 8
  %cmp14 = icmp eq ptr %16, %17
  br i1 %cmp14, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %18 = load ptr, ptr %node, align 8
  %slaveof15 = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 11
  %19 = load ptr, ptr %slaveof15, align 8
  %20 = load ptr, ptr @myself, align 8
  %slaveof16 = getelementptr inbounds %struct._clusterNode, ptr %20, i32 0, i32 11
  %21 = load ptr, ptr %slaveof16, align 8
  %cmp17 = icmp eq ptr %19, %21
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %22 = phi i1 [ true, %land.rhs ], [ %cmp17, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %land.lhs.true, %if.then8
  %23 = phi i1 [ false, %land.lhs.true ], [ false, %if.then8 ], [ %22, %lor.end ]
  %land.ext = zext i1 %23 to i32
  store i32 %land.ext, ptr %local_slave, align 4
  %24 = load i32, ptr %local_slave, align 4
  %tobool18 = icmp ne i32 %24, 0
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %land.end
  br label %while.cond, !llvm.loop !49

if.end20:                                         ; preds = %land.end
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.end6
  %25 = load ptr, ptr %node, align 8
  %link22 = getelementptr inbounds %struct._clusterNode, ptr %25, i32 0, i32 27
  %26 = load ptr, ptr %link22, align 8
  call void @clusterSendPing(ptr noundef %26, i32 noundef 1)
  br label %while.cond, !llvm.loop !49

while.end:                                        ; preds = %while.cond
  %27 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %27)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterCreatePublishMsgBlock(ptr noundef %channel, ptr noundef %message, i16 noundef zeroext %type) #0 {
entry:
  %channel.addr = alloca ptr, align 8
  %message.addr = alloca ptr, align 8
  %type.addr = alloca i16, align 2
  %channel_len = alloca i32, align 4
  %message_len = alloca i32, align 4
  %msglen = alloca i64, align 8
  %msgblock = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  store ptr %channel, ptr %channel.addr, align 8
  store ptr %message, ptr %message.addr, align 8
  store i16 %type, ptr %type.addr, align 2
  %0 = load ptr, ptr %channel.addr, align 8
  %call = call ptr @getDecodedObject(ptr noundef %0)
  store ptr %call, ptr %channel.addr, align 8
  %1 = load ptr, ptr %message.addr, align 8
  %call1 = call ptr @getDecodedObject(ptr noundef %1)
  store ptr %call1, ptr %message.addr, align 8
  %2 = load ptr, ptr %channel.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call2 = call i64 @sdslen(ptr noundef %3)
  %conv = trunc i64 %call2 to i32
  store i32 %conv, ptr %channel_len, align 4
  %4 = load ptr, ptr %message.addr, align 8
  %ptr3 = getelementptr inbounds %struct.redisObject, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %ptr3, align 8
  %call4 = call i64 @sdslen(ptr noundef %5)
  %conv5 = trunc i64 %call4 to i32
  store i32 %conv5, ptr %message_len, align 4
  store i64 2256, ptr %msglen, align 8
  %6 = load i32, ptr %channel_len, align 4
  %conv6 = zext i32 %6 to i64
  %add = add i64 8, %conv6
  %7 = load i32, ptr %message_len, align 4
  %conv7 = zext i32 %7 to i64
  %add8 = add i64 %add, %conv7
  %8 = load i64, ptr %msglen, align 8
  %add9 = add i64 %8, %add8
  store i64 %add9, ptr %msglen, align 8
  %9 = load i16, ptr %type.addr, align 2
  %conv10 = zext i16 %9 to i32
  %10 = load i64, ptr %msglen, align 8
  %conv11 = trunc i64 %10 to i32
  %call12 = call ptr @createClusterMsgSendBlock(i32 noundef %conv10, i32 noundef %conv11)
  store ptr %call12, ptr %msgblock, align 8
  %11 = load ptr, ptr %msgblock, align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %11, i32 0, i32 2
  store ptr %msg, ptr %hdr, align 8
  %12 = load i32, ptr %channel_len, align 4
  %call13 = call i32 @htonl(i32 noundef %12) #14
  %13 = load ptr, ptr %hdr, align 8
  %data = getelementptr inbounds %struct.clusterMsg, ptr %13, i32 0, i32 20
  %msg14 = getelementptr inbounds %struct.anon.2, ptr %data, i32 0, i32 0
  %channel_len15 = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg14, i32 0, i32 0
  store i32 %call13, ptr %channel_len15, align 8
  %14 = load i32, ptr %message_len, align 4
  %call16 = call i32 @htonl(i32 noundef %14) #14
  %15 = load ptr, ptr %hdr, align 8
  %data17 = getelementptr inbounds %struct.clusterMsg, ptr %15, i32 0, i32 20
  %msg18 = getelementptr inbounds %struct.anon.2, ptr %data17, i32 0, i32 0
  %message_len19 = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg18, i32 0, i32 1
  store i32 %call16, ptr %message_len19, align 4
  %16 = load ptr, ptr %hdr, align 8
  %data20 = getelementptr inbounds %struct.clusterMsg, ptr %16, i32 0, i32 20
  %msg21 = getelementptr inbounds %struct.anon.2, ptr %data20, i32 0, i32 0
  %bulk_data = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg21, i32 0, i32 2
  %arraydecay = getelementptr inbounds [8 x i8], ptr %bulk_data, i64 0, i64 0
  %17 = load ptr, ptr %channel.addr, align 8
  %ptr22 = getelementptr inbounds %struct.redisObject, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %ptr22, align 8
  %19 = load ptr, ptr %channel.addr, align 8
  %ptr23 = getelementptr inbounds %struct.redisObject, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %ptr23, align 8
  %call24 = call i64 @sdslen(ptr noundef %20)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %18, i64 %call24, i1 false)
  %21 = load ptr, ptr %hdr, align 8
  %data25 = getelementptr inbounds %struct.clusterMsg, ptr %21, i32 0, i32 20
  %msg26 = getelementptr inbounds %struct.anon.2, ptr %data25, i32 0, i32 0
  %bulk_data27 = getelementptr inbounds %struct.clusterMsgDataPublish, ptr %msg26, i32 0, i32 2
  %arraydecay28 = getelementptr inbounds [8 x i8], ptr %bulk_data27, i64 0, i64 0
  %22 = load ptr, ptr %channel.addr, align 8
  %ptr29 = getelementptr inbounds %struct.redisObject, ptr %22, i32 0, i32 2
  %23 = load ptr, ptr %ptr29, align 8
  %call30 = call i64 @sdslen(ptr noundef %23)
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay28, i64 %call30
  %24 = load ptr, ptr %message.addr, align 8
  %ptr31 = getelementptr inbounds %struct.redisObject, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %ptr31, align 8
  %26 = load ptr, ptr %message.addr, align 8
  %ptr32 = getelementptr inbounds %struct.redisObject, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %ptr32, align 8
  %call33 = call i64 @sdslen(ptr noundef %27)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr align 1 %25, i64 %call33, i1 false)
  %28 = load ptr, ptr %channel.addr, align 8
  call void @decrRefCount(ptr noundef %28)
  %29 = load ptr, ptr %message.addr, align 8
  call void @decrRefCount(ptr noundef %29)
  %30 = load ptr, ptr %msgblock, align 8
  ret ptr %30
}

declare ptr @getDecodedObject(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendModule(ptr noundef %link, i64 noundef %module_id, i8 noundef zeroext %type, ptr noundef %payload, i32 noundef %len) #0 {
entry:
  %link.addr = alloca ptr, align 8
  %module_id.addr = alloca i64, align 8
  %type.addr = alloca i8, align 1
  %payload.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %msglen = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  store ptr %link, ptr %link.addr, align 8
  store i64 %module_id, ptr %module_id.addr, align 8
  store i8 %type, ptr %type.addr, align 1
  store ptr %payload, ptr %payload.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i32 2256, ptr %msglen, align 4
  %0 = load i32, ptr %len.addr, align 4
  %conv = zext i32 %0 to i64
  %add = add i64 13, %conv
  %1 = load i32, ptr %msglen, align 4
  %conv1 = zext i32 %1 to i64
  %add2 = add i64 %conv1, %add
  %conv3 = trunc i64 %add2 to i32
  store i32 %conv3, ptr %msglen, align 4
  %2 = load i32, ptr %msglen, align 4
  %call = call ptr @createClusterMsgSendBlock(i32 noundef 9, i32 noundef %2)
  store ptr %call, ptr %msgblock, align 8
  %3 = load ptr, ptr %msgblock, align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %3, i32 0, i32 2
  store ptr %msg, ptr %hdr, align 8
  %4 = load i64, ptr %module_id.addr, align 8
  %5 = load ptr, ptr %hdr, align 8
  %data = getelementptr inbounds %struct.clusterMsg, ptr %5, i32 0, i32 20
  %msg4 = getelementptr inbounds %struct.anon.4, ptr %data, i32 0, i32 0
  %module_id5 = getelementptr inbounds %struct.clusterMsgModule, ptr %msg4, i32 0, i32 0
  store i64 %4, ptr %module_id5, align 8
  %6 = load i8, ptr %type.addr, align 1
  %7 = load ptr, ptr %hdr, align 8
  %data6 = getelementptr inbounds %struct.clusterMsg, ptr %7, i32 0, i32 20
  %msg7 = getelementptr inbounds %struct.anon.4, ptr %data6, i32 0, i32 0
  %type8 = getelementptr inbounds %struct.clusterMsgModule, ptr %msg7, i32 0, i32 2
  store i8 %6, ptr %type8, align 4
  %8 = load i32, ptr %len.addr, align 4
  %call9 = call i32 @htonl(i32 noundef %8) #14
  %9 = load ptr, ptr %hdr, align 8
  %data10 = getelementptr inbounds %struct.clusterMsg, ptr %9, i32 0, i32 20
  %msg11 = getelementptr inbounds %struct.anon.4, ptr %data10, i32 0, i32 0
  %len12 = getelementptr inbounds %struct.clusterMsgModule, ptr %msg11, i32 0, i32 1
  store i32 %call9, ptr %len12, align 8
  %10 = load ptr, ptr %hdr, align 8
  %data13 = getelementptr inbounds %struct.clusterMsg, ptr %10, i32 0, i32 20
  %msg14 = getelementptr inbounds %struct.anon.4, ptr %data13, i32 0, i32 0
  %bulk_data = getelementptr inbounds %struct.clusterMsgModule, ptr %msg14, i32 0, i32 3
  %arraydecay = getelementptr inbounds [3 x i8], ptr %bulk_data, i64 0, i64 0
  %11 = load ptr, ptr %payload.addr, align 8
  %12 = load i32, ptr %len.addr, align 4
  %conv15 = zext i32 %12 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay, ptr align 1 %11, i64 %conv15, i1 false)
  %13 = load ptr, ptr %link.addr, align 8
  %tobool = icmp ne ptr %13, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %14 = load ptr, ptr %link.addr, align 8
  %15 = load ptr, ptr %msgblock, align 8
  call void @clusterSendMessage(ptr noundef %14, ptr noundef %15)
  br label %if.end

if.else:                                          ; preds = %entry
  %16 = load ptr, ptr %msgblock, align 8
  call void @clusterBroadcastMessage(ptr noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %17 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %17)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterSendModuleMessageToTarget(ptr noundef %target, i64 noundef %module_id, i8 noundef zeroext %type, ptr noundef %payload, i32 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %target.addr = alloca ptr, align 8
  %module_id.addr = alloca i64, align 8
  %type.addr = alloca i8, align 1
  %payload.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %node = alloca ptr, align 8
  store ptr %target, ptr %target.addr, align 8
  store i64 %module_id, ptr %module_id.addr, align 8
  store i8 %type, ptr %type.addr, align 1
  store ptr %payload, ptr %payload.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store ptr null, ptr %node, align 8
  %0 = load ptr, ptr %target.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %target.addr, align 8
  %2 = load ptr, ptr %target.addr, align 8
  %call = call i64 @strlen(ptr noundef %2) #12
  %conv = trunc i64 %call to i32
  %call1 = call ptr @clusterLookupNode(ptr noundef %1, i32 noundef %conv)
  store ptr %call1, ptr %node, align 8
  %3 = load ptr, ptr %node, align 8
  %cmp2 = icmp eq ptr %3, null
  br i1 %cmp2, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %4 = load ptr, ptr %node, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 27
  %5 = load ptr, ptr %link, align 8
  %cmp4 = icmp eq ptr %5, null
  br i1 %cmp4, label %if.then6, label %if.end

if.then6:                                         ; preds = %lor.lhs.false, %if.then
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %6 = load ptr, ptr %target.addr, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end7
  %7 = load ptr, ptr %node, align 8
  %link8 = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 27
  %8 = load ptr, ptr %link8, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %8, %cond.true ], [ null, %cond.false ]
  %9 = load i64, ptr %module_id.addr, align 8
  %10 = load i8, ptr %type.addr, align 1
  %11 = load ptr, ptr %payload.addr, align 8
  %12 = load i32, ptr %len.addr, align 4
  call void @clusterSendModule(ptr noundef %cond, i64 noundef %9, i8 noundef zeroext %10, ptr noundef %11, i32 noundef %12)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then6
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterPropagatePublish(ptr noundef %channel, ptr noundef %message, i32 noundef %sharded) #0 {
entry:
  %channel.addr = alloca ptr, align 8
  %message.addr = alloca ptr, align 8
  %sharded.addr = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %nodes_for_slot = alloca ptr, align 8
  %node = alloca ptr, align 8
  store ptr %channel, ptr %channel.addr, align 8
  store ptr %message, ptr %message.addr, align 8
  store i32 %sharded, ptr %sharded.addr, align 4
  %0 = load i32, ptr %sharded.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %channel.addr, align 8
  %2 = load ptr, ptr %message.addr, align 8
  %call = call ptr @clusterCreatePublishMsgBlock(ptr noundef %1, ptr noundef %2, i16 noundef zeroext 4)
  store ptr %call, ptr %msgblock, align 8
  %3 = load ptr, ptr %msgblock, align 8
  call void @clusterBroadcastMessage(ptr noundef %3)
  %4 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %4)
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %myself, align 8
  %call1 = call ptr @clusterGetNodesInMyShard(ptr noundef %6)
  store ptr %call1, ptr %nodes_for_slot, align 8
  %7 = load ptr, ptr %nodes_for_slot, align 8
  %cmp = icmp ne ptr %7, null
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  call void @_serverAssert(ptr noundef @.str.111, ptr noundef @.str.18, i32 noundef 3783)
  call void @abort() #13
  unreachable

8:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %8, %cond.true
  %9 = load ptr, ptr %nodes_for_slot, align 8
  call void @listRewind(ptr noundef %9, ptr noundef %li)
  %10 = load ptr, ptr %channel.addr, align 8
  %11 = load ptr, ptr %message.addr, align 8
  %call4 = call ptr @clusterCreatePublishMsgBlock(ptr noundef %10, ptr noundef %11, i16 noundef zeroext 10)
  store ptr %call4, ptr %msgblock, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %if.then8, %cond.end
  %call5 = call ptr @listNext(ptr noundef %li)
  store ptr %call5, ptr %ln, align 8
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %value, align 8
  store ptr %13, ptr %node, align 8
  %14 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 3
  %15 = load i32, ptr %flags, align 8
  %and = and i32 %15, 48
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !50

if.end9:                                          ; preds = %while.body
  %16 = load ptr, ptr %node, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 27
  %17 = load ptr, ptr %link, align 8
  %18 = load ptr, ptr %msgblock, align 8
  call void @clusterSendMessage(ptr noundef %17, ptr noundef %18)
  br label %while.cond, !llvm.loop !50

while.end:                                        ; preds = %while.cond
  %19 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %19)
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterRequestFailoverAuth() #0 {
entry:
  %msglen = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  %hdr = alloca ptr, align 8
  store i32 2256, ptr %msglen, align 4
  %0 = load i32, ptr %msglen, align 4
  %call = call ptr @createClusterMsgSendBlock(i32 noundef 5, i32 noundef %0)
  store ptr %call, ptr %msgblock, align 8
  %1 = load ptr, ptr %msgblock, align 8
  %msg = getelementptr inbounds %struct.clusterMsgSendBlock, ptr %1, i32 0, i32 2
  store ptr %msg, ptr %hdr, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 17
  %3 = load i64, ptr %mf_end, align 8
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %hdr, align 8
  %mflags = getelementptr inbounds %struct.clusterMsg, ptr %4, i32 0, i32 19
  %arrayidx = getelementptr inbounds [3 x i8], ptr %mflags, i64 0, i64 0
  %5 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %5 to i32
  %or = or i32 %conv, 2
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, ptr %arrayidx, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %msgblock, align 8
  call void @clusterBroadcastMessage(ptr noundef %6)
  %7 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %7)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendFailoverAuth(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %msglen = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 27
  %1 = load ptr, ptr %link, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 2256, ptr %msglen, align 4
  %2 = load i32, ptr %msglen, align 4
  %call = call ptr @createClusterMsgSendBlock(i32 noundef 6, i32 noundef %2)
  store ptr %call, ptr %msgblock, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %link1 = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 27
  %4 = load ptr, ptr %link1, align 8
  %5 = load ptr, ptr %msgblock, align 8
  call void @clusterSendMessage(ptr noundef %4, ptr noundef %5)
  %6 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %6)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterSendMFStart(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %msglen = alloca i32, align 4
  %msgblock = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 27
  %1 = load ptr, ptr %link, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 2256, ptr %msglen, align 4
  %2 = load i32, ptr %msglen, align 4
  %call = call ptr @createClusterMsgSendBlock(i32 noundef 8, i32 noundef %2)
  store ptr %call, ptr %msgblock, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %link1 = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 27
  %4 = load ptr, ptr %link1, align 8
  %5 = load ptr, ptr %msgblock, align 8
  call void @clusterSendMessage(ptr noundef %4, ptr noundef %5)
  %6 = load ptr, ptr %msgblock, align 8
  call void @clusterMsgSendBlockDecrRefCount(ptr noundef %6)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterGetSlaveRank() #0 {
entry:
  %retval = alloca i32, align 4
  %myoffset = alloca i64, align 8
  %j = alloca i32, align 4
  %rank = alloca i32, align 4
  %master = alloca ptr, align 8
  store i32 0, ptr %rank, align 4
  %0 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.120, ptr noundef @.str.18, i32 noundef 3961)
  call void @abort() #13
  unreachable

2:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %2, %cond.true
  %3 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 11
  %4 = load ptr, ptr %slaveof, align 8
  store ptr %4, ptr %master, align 8
  %5 = load ptr, ptr %master, align 8
  %cmp = icmp eq ptr %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end
  %call = call i64 @replicationGetSlaveOffset()
  store i64 %call, ptr %myoffset, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, ptr %j, align 4
  %7 = load ptr, ptr %master, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 9
  %8 = load i32, ptr %numslaves, align 8
  %cmp4 = icmp slt i32 %6, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %master, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 10
  %10 = load ptr, ptr %slaves, align 8
  %11 = load i32, ptr %j, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %10, i64 %idxprom
  %12 = load ptr, ptr %arrayidx, align 8
  %13 = load ptr, ptr @myself, align 8
  %cmp6 = icmp ne ptr %12, %13
  br i1 %cmp6, label %land.lhs.true, label %if.end21

land.lhs.true:                                    ; preds = %for.body
  %14 = load ptr, ptr %master, align 8
  %slaves8 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 10
  %15 = load ptr, ptr %slaves8, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom9 = sext i32 %16 to i64
  %arrayidx10 = getelementptr inbounds ptr, ptr %15, i64 %idxprom9
  %17 = load ptr, ptr %arrayidx10, align 8
  %flags11 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 3
  %18 = load i32, ptr %flags11, align 8
  %and12 = and i32 %18, 512
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.end21, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %land.lhs.true
  %19 = load ptr, ptr %master, align 8
  %slaves15 = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 10
  %20 = load ptr, ptr %slaves15, align 8
  %21 = load i32, ptr %j, align 4
  %idxprom16 = sext i32 %21 to i64
  %arrayidx17 = getelementptr inbounds ptr, ptr %20, i64 %idxprom16
  %22 = load ptr, ptr %arrayidx17, align 8
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 20
  %23 = load i64, ptr %repl_offset, align 8
  %24 = load i64, ptr %myoffset, align 8
  %cmp18 = icmp sgt i64 %23, %24
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true14
  %25 = load i32, ptr %rank, align 4
  %inc = add nsw i32 %25, 1
  store i32 %inc, ptr %rank, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %land.lhs.true14, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end21
  %26 = load i32, ptr %j, align 4
  %inc22 = add nsw i32 %26, 1
  store i32 %inc22, ptr %j, align 4
  br label %for.cond, !llvm.loop !51

for.end:                                          ; preds = %for.cond
  %27 = load i32, ptr %rank, align 4
  store i32 %27, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

declare i64 @replicationGetSlaveOffset() #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterLogCantFailover(i32 noundef %reason) #0 {
entry:
  %reason.addr = alloca i32, align 4
  %msg = alloca ptr, align 8
  %nolog_fail_time = alloca i64, align 8
  %cur_vote = alloca i32, align 4
  %cur_quorum = alloca i32, align 4
  store i32 %reason, ptr %reason.addr, align 4
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %add = add nsw i64 %0, 5000
  store i64 %add, ptr %nolog_fail_time, align 8
  %1 = load i32, ptr %reason.addr, align 4
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %cant_failover_reason = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 16
  %3 = load i32, ptr %cant_failover_reason, align 8
  %cmp = icmp eq i32 %1, %3
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call = call i64 @time(ptr noundef null) #15
  %4 = load i64, ptr @clusterLogCantFailover.lastlog_time, align 8
  %sub = sub nsw i64 %call, %4
  %cmp1 = icmp slt i64 %sub, 10
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %if.end29

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = load i32, ptr %reason.addr, align 4
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %cant_failover_reason2 = getelementptr inbounds %struct.clusterState, ptr %6, i32 0, i32 16
  store i32 %5, ptr %cant_failover_reason2, align 8
  %7 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 11
  %8 = load ptr, ptr %slaveof, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %land.lhs.true3, label %if.end12

land.lhs.true3:                                   ; preds = %if.end
  %9 = load ptr, ptr @myself, align 8
  %slaveof4 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 11
  %10 = load ptr, ptr %slaveof4, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 3
  %11 = load i32, ptr %flags, align 8
  %and = and i32 %11, 8
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %land.lhs.true6, label %if.end12

land.lhs.true6:                                   ; preds = %land.lhs.true3
  %call7 = call i64 @mstime()
  %12 = load ptr, ptr @myself, align 8
  %slaveof8 = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 11
  %13 = load ptr, ptr %slaveof8, align 8
  %fail_time = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 16
  %14 = load i64, ptr %fail_time, align 8
  %sub9 = sub nsw i64 %call7, %14
  %15 = load i64, ptr %nolog_fail_time, align 8
  %cmp10 = icmp slt i64 %sub9, %15
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true6
  br label %if.end29

if.end12:                                         ; preds = %land.lhs.true6, %land.lhs.true3, %if.end
  %16 = load i32, ptr %reason.addr, align 4
  switch i32 %16, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb13
    i32 3, label %sw.bb14
    i32 4, label %sw.bb15
  ]

sw.bb:                                            ; preds = %if.end12
  store ptr @.str.121, ptr %msg, align 8
  br label %sw.epilog

sw.bb13:                                          ; preds = %if.end12
  store ptr @.str.122, ptr %msg, align 8
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end12
  store ptr @.str.123, ptr %msg, align 8
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.end12
  store ptr @.str.124, ptr %msg, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end12
  store ptr @.str.125, ptr %msg, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb
  %call16 = call i64 @time(ptr noundef null) #15
  store i64 %call16, ptr @clusterLogCantFailover.lastlog_time, align 8
  br label %do.body

do.body:                                          ; preds = %sw.epilog
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp17 = icmp slt i32 2, %17
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %do.body
  br label %do.end

if.end19:                                         ; preds = %do.body
  %18 = load ptr, ptr %msg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.126, ptr noundef %18)
  br label %do.end

do.end:                                           ; preds = %if.end19, %if.then18
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_count = getelementptr inbounds %struct.clusterState, ptr %19, i32 0, i32 12
  %20 = load i32, ptr %failover_auth_count, align 8
  store i32 %20, ptr %cur_vote, align 4
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %21, i32 0, i32 3
  %22 = load i32, ptr %size, align 4
  %div = sdiv i32 %22, 2
  %add20 = add nsw i32 %div, 1
  store i32 %add20, ptr %cur_quorum, align 4
  %23 = load i32, ptr %reason.addr, align 4
  %cmp21 = icmp eq i32 %23, 4
  br i1 %cmp21, label %if.then23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %24 = load i32, ptr %reason.addr, align 4
  %cmp22 = icmp eq i32 %24, 3
  br i1 %cmp22, label %if.then23, label %if.end29

if.then23:                                        ; preds = %lor.lhs.false, %do.end
  br label %do.body24

do.body24:                                        ; preds = %if.then23
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp25 = icmp slt i32 2, %25
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %do.body24
  br label %do.end28

if.end27:                                         ; preds = %do.body24
  %26 = load i32, ptr %cur_quorum, align 4
  %27 = load i32, ptr %cur_vote, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.127, i32 noundef %26, i32 noundef %27)
  br label %do.end28

do.end28:                                         ; preds = %if.end27, %if.then26
  br label %if.end29

if.end29:                                         ; preds = %do.end28, %lor.lhs.false, %if.then11, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterFailoverReplaceYourMaster() #0 {
entry:
  %j = alloca i32, align 4
  %oldmaster = alloca ptr, align 8
  %0 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 11
  %1 = load ptr, ptr %slaveof, align 8
  store ptr %1, ptr %oldmaster, align 8
  %2 = load ptr, ptr @myself, align 8
  %call = call i32 @clusterNodeIsMaster(ptr noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %oldmaster, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr @myself, align 8
  call void @clusterSetNodeAsMaster(ptr noundef %4)
  call void @replicationUnsetMaster()
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, ptr %j, align 4
  %cmp1 = icmp slt i32 %5, 16384
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %oldmaster, align 8
  %7 = load i32, ptr %j, align 4
  %call2 = call i32 @clusterNodeCoversSlot(ptr noundef %6, i32 noundef %7)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %for.body
  %8 = load i32, ptr %j, align 4
  %call5 = call i32 @clusterDelSlot(i32 noundef %8)
  %9 = load ptr, ptr @myself, align 8
  %10 = load i32, ptr %j, align 4
  %call6 = call i32 @clusterAddSlot(ptr noundef %9, i32 noundef %10)
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %11 = load i32, ptr %j, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !52

for.end:                                          ; preds = %for.cond
  call void @clusterUpdateState()
  call void @clusterSaveConfigOrDie(i32 noundef 1)
  call void @clusterBroadcastPong(i32 noundef 0)
  call void @resetManualFailover()
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeCoversSlot(ptr noundef %n, i32 noundef %slot) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %slots = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [2048 x i8], ptr %slots, i64 0, i64 0
  %1 = load i32, ptr %slot.addr, align 4
  %call = call i32 @bitmapTestBit(ptr noundef %arraydecay, i32 noundef %1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateState() #0 {
entry:
  %j = alloca i32, align 4
  %new_state = alloca i32, align 4
  %reachable_masters = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %node = alloca ptr, align 8
  %needed_quorum = alloca i32, align 4
  %rejoin_delay = alloca i64, align 8
  store i32 0, ptr %reachable_masters, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 22
  %1 = load i32, ptr %todo_before_sleep, align 8
  %and = and i32 %1, -3
  store i32 %and, ptr %todo_before_sleep, align 8
  %2 = load i64, ptr @clusterUpdateState.first_call_time, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @mstime()
  store i64 %call, ptr @clusterUpdateState.first_call_time, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr @myself, align 8
  %call1 = call i32 @clusterNodeIsMaster(ptr noundef %3)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 2
  %5 = load i32, ptr %state, align 8
  %cmp2 = icmp eq i32 %5, 1
  br i1 %cmp2, label %land.lhs.true3, label %if.end7

land.lhs.true3:                                   ; preds = %land.lhs.true
  %call4 = call i64 @mstime()
  %6 = load i64, ptr @clusterUpdateState.first_call_time, align 8
  %sub = sub nsw i64 %call4, %6
  %cmp5 = icmp slt i64 %sub, 2000
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true3
  br label %if.end72

if.end7:                                          ; preds = %land.lhs.true3, %land.lhs.true, %if.end
  store i32 0, ptr %new_state, align 4
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 371), align 4
  %tobool8 = icmp ne i32 %7, 0
  br i1 %tobool8, label %if.then9, label %if.end19

if.then9:                                         ; preds = %if.end7
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then9
  %8 = load i32, ptr %j, align 4
  %cmp10 = icmp slt i32 %8, 16384
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %9, i32 0, i32 9
  %10 = load i32, ptr %j, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom
  %11 = load ptr, ptr %arrayidx, align 8
  %cmp11 = icmp eq ptr %11, null
  br i1 %cmp11, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots12 = getelementptr inbounds %struct.clusterState, ptr %12, i32 0, i32 9
  %13 = load i32, ptr %j, align 4
  %idxprom13 = sext i32 %13 to i64
  %arrayidx14 = getelementptr inbounds [16384 x ptr], ptr %slots12, i64 0, i64 %idxprom13
  %14 = load ptr, ptr %arrayidx14, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 3
  %15 = load i32, ptr %flags, align 8
  %and15 = and i32 %15, 8
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %lor.lhs.false, %for.body
  store i32 1, ptr %new_state, align 4
  br label %for.end

if.end18:                                         ; preds = %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end18
  %16 = load i32, ptr %j, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !53

for.end:                                          ; preds = %if.then17, %for.cond
  br label %if.end19

if.end19:                                         ; preds = %for.end, %if.end7
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %17, i32 0, i32 3
  store i32 0, ptr %size, align 4
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %18, i32 0, i32 4
  %19 = load ptr, ptr %nodes, align 8
  %call20 = call ptr @dictGetSafeIterator(ptr noundef %19)
  store ptr %call20, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end37, %if.end19
  %20 = load ptr, ptr %di, align 8
  %call21 = call ptr @dictNext(ptr noundef %20)
  store ptr %call21, ptr %de, align 8
  %cmp22 = icmp ne ptr %call21, null
  br i1 %cmp22, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %de, align 8
  %call23 = call ptr @dictGetVal(ptr noundef %21)
  store ptr %call23, ptr %node, align 8
  %22 = load ptr, ptr %node, align 8
  %call24 = call i32 @clusterNodeIsMaster(ptr noundef %22)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %land.lhs.true26, label %if.end37

land.lhs.true26:                                  ; preds = %while.body
  %23 = load ptr, ptr %node, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 8
  %24 = load i32, ptr %numslots, align 4
  %tobool27 = icmp ne i32 %24, 0
  br i1 %tobool27, label %if.then28, label %if.end37

if.then28:                                        ; preds = %land.lhs.true26
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %size29 = getelementptr inbounds %struct.clusterState, ptr %25, i32 0, i32 3
  %26 = load i32, ptr %size29, align 4
  %inc30 = add nsw i32 %26, 1
  store i32 %inc30, ptr %size29, align 4
  %27 = load ptr, ptr %node, align 8
  %flags31 = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 3
  %28 = load i32, ptr %flags31, align 8
  %and32 = and i32 %28, 12
  %cmp33 = icmp eq i32 %and32, 0
  br i1 %cmp33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.then28
  %29 = load i32, ptr %reachable_masters, align 4
  %inc35 = add nsw i32 %29, 1
  store i32 %inc35, ptr %reachable_masters, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.then28
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %land.lhs.true26, %while.body
  br label %while.cond, !llvm.loop !54

while.end:                                        ; preds = %while.cond
  %30 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %30)
  %31 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %size38 = getelementptr inbounds %struct.clusterState, ptr %31, i32 0, i32 3
  %32 = load i32, ptr %size38, align 4
  %div = sdiv i32 %32, 2
  %add = add nsw i32 %div, 1
  store i32 %add, ptr %needed_quorum, align 4
  %33 = load i32, ptr %reachable_masters, align 4
  %34 = load i32, ptr %needed_quorum, align 4
  %cmp39 = icmp slt i32 %33, %34
  br i1 %cmp39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %while.end
  store i32 1, ptr %new_state, align 4
  %call41 = call i64 @mstime()
  store i64 %call41, ptr @clusterUpdateState.among_minority_time, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %while.end
  %35 = load i32, ptr %new_state, align 4
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state43 = getelementptr inbounds %struct.clusterState, ptr %36, i32 0, i32 2
  %37 = load i32, ptr %state43, align 8
  %cmp44 = icmp ne i32 %35, %37
  br i1 %cmp44, label %if.then45, label %if.end72

if.then45:                                        ; preds = %if.end42
  %38 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  store i64 %38, ptr %rejoin_delay, align 8
  %39 = load i64, ptr %rejoin_delay, align 8
  %cmp46 = icmp sgt i64 %39, 5000
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.then45
  store i64 5000, ptr %rejoin_delay, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %if.then45
  %40 = load i64, ptr %rejoin_delay, align 8
  %cmp49 = icmp slt i64 %40, 500
  br i1 %cmp49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end48
  store i64 500, ptr %rejoin_delay, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %if.end48
  %41 = load i32, ptr %new_state, align 4
  %cmp52 = icmp eq i32 %41, 0
  br i1 %cmp52, label %land.lhs.true53, label %if.end61

land.lhs.true53:                                  ; preds = %if.end51
  %42 = load ptr, ptr @myself, align 8
  %call54 = call i32 @clusterNodeIsMaster(ptr noundef %42)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %land.lhs.true56, label %if.end61

land.lhs.true56:                                  ; preds = %land.lhs.true53
  %call57 = call i64 @mstime()
  %43 = load i64, ptr @clusterUpdateState.among_minority_time, align 8
  %sub58 = sub nsw i64 %call57, %43
  %44 = load i64, ptr %rejoin_delay, align 8
  %cmp59 = icmp slt i64 %sub58, %44
  br i1 %cmp59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %land.lhs.true56
  br label %if.end72

if.end61:                                         ; preds = %land.lhs.true56, %land.lhs.true53, %if.end51
  br label %do.body

do.body:                                          ; preds = %if.end61
  %45 = load i32, ptr %new_state, align 4
  %cmp62 = icmp eq i32 %45, 0
  %cond = select i1 %cmp62, i32 2, i32 3
  %and63 = and i32 %cond, 255
  %46 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp64 = icmp slt i32 %and63, %46
  br i1 %cmp64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %do.body
  br label %do.end

if.end66:                                         ; preds = %do.body
  %47 = load i32, ptr %new_state, align 4
  %cmp67 = icmp eq i32 %47, 0
  %cond68 = select i1 %cmp67, i32 2, i32 3
  %48 = load i32, ptr %new_state, align 4
  %cmp69 = icmp eq i32 %48, 0
  %cond70 = select i1 %cmp69, ptr @.str.140, ptr @.str.22
  call void (i32, ptr, ...) @_serverLog(i32 noundef %cond68, ptr noundef @.str.139, ptr noundef %cond70)
  br label %do.end

do.end:                                           ; preds = %if.end66, %if.then65
  %49 = load i32, ptr %new_state, align 4
  %50 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state71 = getelementptr inbounds %struct.clusterState, ptr %50, i32 0, i32 2
  store i32 %49, ptr %state71, align 8
  br label %if.end72

if.end72:                                         ; preds = %do.end, %if.then60, %if.end42, %if.then6
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterHandleSlaveFailover() #0 {
entry:
  %data_age = alloca i64, align 8
  %auth_age = alloca i64, align 8
  %needed_quorum = alloca i32, align 4
  %manual_failover = alloca i32, align 4
  %auth_timeout = alloca i64, align 8
  %auth_retry_time = alloca i64, align 8
  %newrank = alloca i32, align 4
  %added_delay = alloca i64, align 8
  %call = call i64 @mstime()
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_time = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 11
  %1 = load i64, ptr %failover_auth_time, align 8
  %sub = sub nsw i64 %call, %1
  store i64 %sub, ptr %auth_age, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 3
  %3 = load i32, ptr %size, align 4
  %div = sdiv i32 %3, 2
  %add = add nsw i32 %div, 1
  store i32 %add, ptr %needed_quorum, align 4
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 17
  %5 = load i64, ptr %mf_end, align 8
  %cmp = icmp ne i64 %5, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_can_start = getelementptr inbounds %struct.clusterState, ptr %6, i32 0, i32 20
  %7 = load i32, ptr %mf_can_start, align 8
  %tobool = icmp ne i32 %7, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  store i32 %land.ext, ptr %manual_failover, align 4
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %9, i32 0, i32 22
  %10 = load i32, ptr %todo_before_sleep, align 8
  %and = and i32 %10, -2
  store i32 %and, ptr %todo_before_sleep, align 8
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %mul = mul nsw i64 %11, 2
  store i64 %mul, ptr %auth_timeout, align 8
  %12 = load i64, ptr %auth_timeout, align 8
  %cmp1 = icmp slt i64 %12, 2000
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  store i64 2000, ptr %auth_timeout, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %13 = load i64, ptr %auth_timeout, align 8
  %mul2 = mul nsw i64 %13, 2
  store i64 %mul2, ptr %auth_retry_time, align 8
  %14 = load ptr, ptr @myself, align 8
  %call3 = call i32 @clusterNodeIsMaster(ptr noundef %14)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %15 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 11
  %16 = load ptr, ptr %slaveof, align 8
  %cmp5 = icmp eq ptr %16, null
  br i1 %cmp5, label %if.then18, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %17 = load ptr, ptr @myself, align 8
  %slaveof7 = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 11
  %18 = load ptr, ptr %slaveof7, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 3
  %19 = load i32, ptr %flags, align 8
  %and8 = and i32 %19, 8
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %lor.lhs.false11, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false6
  %20 = load i32, ptr %manual_failover, align 4
  %tobool10 = icmp ne i32 %20, 0
  br i1 %tobool10, label %lor.lhs.false11, label %if.then18

lor.lhs.false11:                                  ; preds = %land.lhs.true, %lor.lhs.false6
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 372), align 8
  %tobool12 = icmp ne i32 %21, 0
  br i1 %tobool12, label %land.lhs.true13, label %lor.lhs.false15

land.lhs.true13:                                  ; preds = %lor.lhs.false11
  %22 = load i32, ptr %manual_failover, align 4
  %tobool14 = icmp ne i32 %22, 0
  br i1 %tobool14, label %lor.lhs.false15, label %if.then18

lor.lhs.false15:                                  ; preds = %land.lhs.true13, %lor.lhs.false11
  %23 = load ptr, ptr @myself, align 8
  %slaveof16 = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 11
  %24 = load ptr, ptr %slaveof16, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %24, i32 0, i32 8
  %25 = load i32, ptr %numslots, align 4
  %cmp17 = icmp eq i32 %25, 0
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %lor.lhs.false15, %land.lhs.true13, %land.lhs.true, %lor.lhs.false, %if.end
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %cant_failover_reason = getelementptr inbounds %struct.clusterState, ptr %26, i32 0, i32 16
  store i32 0, ptr %cant_failover_reason, align 8
  br label %if.end153

if.end19:                                         ; preds = %lor.lhs.false15
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp20 = icmp eq i32 %27, 12
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end19
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 286), align 8
  %lastinteraction = getelementptr inbounds %struct.client, ptr %28, i32 0, i32 32
  %29 = load i64, ptr %lastinteraction, align 8
  %sub22 = sub nsw i64 %atomic-load, %29
  %mul23 = mul nsw i64 %sub22, 1000
  store i64 %mul23, ptr %data_age, align 8
  br label %if.end27

if.else:                                          ; preds = %if.end19
  %atomic-load24 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %30 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 300), align 8
  %sub25 = sub nsw i64 %atomic-load24, %30
  %mul26 = mul nsw i64 %sub25, 1000
  store i64 %mul26, ptr %data_age, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.else, %if.then21
  %31 = load i64, ptr %data_age, align 8
  %32 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %cmp28 = icmp sgt i64 %31, %32
  br i1 %cmp28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end27
  %33 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %34 = load i64, ptr %data_age, align 8
  %sub30 = sub nsw i64 %34, %33
  store i64 %sub30, ptr %data_age, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end27
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 370), align 8
  %tobool32 = icmp ne i32 %35, 0
  br i1 %tobool32, label %land.lhs.true33, label %if.end44

land.lhs.true33:                                  ; preds = %if.end31
  %36 = load i64, ptr %data_age, align 8
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 267), align 4
  %conv = sext i32 %37 to i64
  %mul34 = mul nsw i64 %conv, 1000
  %38 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 370), align 8
  %conv35 = sext i32 %39 to i64
  %mul36 = mul nsw i64 %38, %conv35
  %add37 = add nsw i64 %mul34, %mul36
  %cmp38 = icmp sgt i64 %36, %add37
  br i1 %cmp38, label %if.then40, label %if.end44

if.then40:                                        ; preds = %land.lhs.true33
  %40 = load i32, ptr %manual_failover, align 4
  %tobool41 = icmp ne i32 %40, 0
  br i1 %tobool41, label %if.end43, label %if.then42

if.then42:                                        ; preds = %if.then40
  call void @clusterLogCantFailover(i32 noundef 1)
  br label %if.end153

if.end43:                                         ; preds = %if.then40
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %land.lhs.true33, %if.end31
  %41 = load i64, ptr %auth_age, align 8
  %42 = load i64, ptr %auth_retry_time, align 8
  %cmp45 = icmp sgt i64 %41, %42
  br i1 %cmp45, label %if.then47, label %if.end75

if.then47:                                        ; preds = %if.end44
  %call48 = call i64 @mstime()
  %add49 = add nsw i64 %call48, 500
  %call50 = call i64 @random() #15
  %rem = srem i64 %call50, 500
  %add51 = add nsw i64 %add49, %rem
  %43 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_time52 = getelementptr inbounds %struct.clusterState, ptr %43, i32 0, i32 11
  store i64 %add51, ptr %failover_auth_time52, align 8
  %44 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_count = getelementptr inbounds %struct.clusterState, ptr %44, i32 0, i32 12
  store i32 0, ptr %failover_auth_count, align 8
  %45 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_sent = getelementptr inbounds %struct.clusterState, ptr %45, i32 0, i32 13
  store i32 0, ptr %failover_auth_sent, align 4
  %call53 = call i32 @clusterGetSlaveRank()
  %46 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_rank = getelementptr inbounds %struct.clusterState, ptr %46, i32 0, i32 14
  store i32 %call53, ptr %failover_auth_rank, align 8
  %47 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_rank54 = getelementptr inbounds %struct.clusterState, ptr %47, i32 0, i32 14
  %48 = load i32, ptr %failover_auth_rank54, align 8
  %mul55 = mul nsw i32 %48, 1000
  %conv56 = sext i32 %mul55 to i64
  %49 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_time57 = getelementptr inbounds %struct.clusterState, ptr %49, i32 0, i32 11
  %50 = load i64, ptr %failover_auth_time57, align 8
  %add58 = add nsw i64 %50, %conv56
  store i64 %add58, ptr %failover_auth_time57, align 8
  %51 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end59 = getelementptr inbounds %struct.clusterState, ptr %51, i32 0, i32 17
  %52 = load i64, ptr %mf_end59, align 8
  %tobool60 = icmp ne i64 %52, 0
  br i1 %tobool60, label %if.then61, label %if.end65

if.then61:                                        ; preds = %if.then47
  %call62 = call i64 @mstime()
  %53 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_time63 = getelementptr inbounds %struct.clusterState, ptr %53, i32 0, i32 11
  store i64 %call62, ptr %failover_auth_time63, align 8
  %54 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_rank64 = getelementptr inbounds %struct.clusterState, ptr %54, i32 0, i32 14
  store i32 0, ptr %failover_auth_rank64, align 8
  call void @clusterDoBeforeSleep(i32 noundef 1)
  br label %if.end65

if.end65:                                         ; preds = %if.then61, %if.then47
  br label %do.body

do.body:                                          ; preds = %if.end65
  %55 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp66 = icmp slt i32 2, %55
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %do.body
  br label %do.end

if.end69:                                         ; preds = %do.body
  %56 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_time70 = getelementptr inbounds %struct.clusterState, ptr %56, i32 0, i32 11
  %57 = load i64, ptr %failover_auth_time70, align 8
  %call71 = call i64 @mstime()
  %sub72 = sub nsw i64 %57, %call71
  %58 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_rank73 = getelementptr inbounds %struct.clusterState, ptr %58, i32 0, i32 14
  %59 = load i32, ptr %failover_auth_rank73, align 8
  %call74 = call i64 @replicationGetSlaveOffset()
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.128, i64 noundef %sub72, i32 noundef %59, i64 noundef %call74)
  br label %do.end

do.end:                                           ; preds = %if.end69, %if.then68
  call void @clusterBroadcastPong(i32 noundef 1)
  br label %if.end153

if.end75:                                         ; preds = %if.end44
  %60 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_sent76 = getelementptr inbounds %struct.clusterState, ptr %60, i32 0, i32 13
  %61 = load i32, ptr %failover_auth_sent76, align 4
  %cmp77 = icmp eq i32 %61, 0
  br i1 %cmp77, label %land.lhs.true79, label %if.end103

land.lhs.true79:                                  ; preds = %if.end75
  %62 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end80 = getelementptr inbounds %struct.clusterState, ptr %62, i32 0, i32 17
  %63 = load i64, ptr %mf_end80, align 8
  %cmp81 = icmp eq i64 %63, 0
  br i1 %cmp81, label %if.then83, label %if.end103

if.then83:                                        ; preds = %land.lhs.true79
  %call84 = call i32 @clusterGetSlaveRank()
  store i32 %call84, ptr %newrank, align 4
  %64 = load i32, ptr %newrank, align 4
  %65 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_rank85 = getelementptr inbounds %struct.clusterState, ptr %65, i32 0, i32 14
  %66 = load i32, ptr %failover_auth_rank85, align 8
  %cmp86 = icmp sgt i32 %64, %66
  br i1 %cmp86, label %if.then88, label %if.end102

if.then88:                                        ; preds = %if.then83
  %67 = load i32, ptr %newrank, align 4
  %68 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_rank89 = getelementptr inbounds %struct.clusterState, ptr %68, i32 0, i32 14
  %69 = load i32, ptr %failover_auth_rank89, align 8
  %sub90 = sub nsw i32 %67, %69
  %mul91 = mul nsw i32 %sub90, 1000
  %conv92 = sext i32 %mul91 to i64
  store i64 %conv92, ptr %added_delay, align 8
  %70 = load i64, ptr %added_delay, align 8
  %71 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_time93 = getelementptr inbounds %struct.clusterState, ptr %71, i32 0, i32 11
  %72 = load i64, ptr %failover_auth_time93, align 8
  %add94 = add nsw i64 %72, %70
  store i64 %add94, ptr %failover_auth_time93, align 8
  %73 = load i32, ptr %newrank, align 4
  %74 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_rank95 = getelementptr inbounds %struct.clusterState, ptr %74, i32 0, i32 14
  store i32 %73, ptr %failover_auth_rank95, align 8
  br label %do.body96

do.body96:                                        ; preds = %if.then88
  %75 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp97 = icmp slt i32 2, %75
  br i1 %cmp97, label %if.then99, label %if.end100

if.then99:                                        ; preds = %do.body96
  br label %do.end101

if.end100:                                        ; preds = %do.body96
  %76 = load i32, ptr %newrank, align 4
  %77 = load i64, ptr %added_delay, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.129, i32 noundef %76, i64 noundef %77)
  br label %do.end101

do.end101:                                        ; preds = %if.end100, %if.then99
  br label %if.end102

if.end102:                                        ; preds = %do.end101, %if.then83
  br label %if.end103

if.end103:                                        ; preds = %if.end102, %land.lhs.true79, %if.end75
  %call104 = call i64 @mstime()
  %78 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_time105 = getelementptr inbounds %struct.clusterState, ptr %78, i32 0, i32 11
  %79 = load i64, ptr %failover_auth_time105, align 8
  %cmp106 = icmp slt i64 %call104, %79
  br i1 %cmp106, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end103
  call void @clusterLogCantFailover(i32 noundef 2)
  br label %if.end153

if.end109:                                        ; preds = %if.end103
  %80 = load i64, ptr %auth_age, align 8
  %81 = load i64, ptr %auth_timeout, align 8
  %cmp110 = icmp sgt i64 %80, %81
  br i1 %cmp110, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.end109
  call void @clusterLogCantFailover(i32 noundef 3)
  br label %if.end153

if.end113:                                        ; preds = %if.end109
  %82 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_sent114 = getelementptr inbounds %struct.clusterState, ptr %82, i32 0, i32 13
  %83 = load i32, ptr %failover_auth_sent114, align 4
  %cmp115 = icmp eq i32 %83, 0
  br i1 %cmp115, label %if.then117, label %if.end127

if.then117:                                       ; preds = %if.end113
  %84 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %84, i32 0, i32 1
  %85 = load i64, ptr %currentEpoch, align 8
  %inc = add i64 %85, 1
  store i64 %inc, ptr %currentEpoch, align 8
  %86 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch118 = getelementptr inbounds %struct.clusterState, ptr %86, i32 0, i32 1
  %87 = load i64, ptr %currentEpoch118, align 8
  %88 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_epoch = getelementptr inbounds %struct.clusterState, ptr %88, i32 0, i32 15
  store i64 %87, ptr %failover_auth_epoch, align 8
  br label %do.body119

do.body119:                                       ; preds = %if.then117
  %89 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp120 = icmp slt i32 2, %89
  br i1 %cmp120, label %if.then122, label %if.end123

if.then122:                                       ; preds = %do.body119
  br label %do.end125

if.end123:                                        ; preds = %do.body119
  %90 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch124 = getelementptr inbounds %struct.clusterState, ptr %90, i32 0, i32 1
  %91 = load i64, ptr %currentEpoch124, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.130, i64 noundef %91)
  br label %do.end125

do.end125:                                        ; preds = %if.end123, %if.then122
  call void @clusterRequestFailoverAuth()
  %92 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_sent126 = getelementptr inbounds %struct.clusterState, ptr %92, i32 0, i32 13
  store i32 1, ptr %failover_auth_sent126, align 4
  call void @clusterDoBeforeSleep(i32 noundef 14)
  br label %if.end153

if.end127:                                        ; preds = %if.end113
  %93 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_count128 = getelementptr inbounds %struct.clusterState, ptr %93, i32 0, i32 12
  %94 = load i32, ptr %failover_auth_count128, align 8
  %95 = load i32, ptr %needed_quorum, align 4
  %cmp129 = icmp sge i32 %94, %95
  br i1 %cmp129, label %if.then131, label %if.else152

if.then131:                                       ; preds = %if.end127
  br label %do.body132

do.body132:                                       ; preds = %if.then131
  %96 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp133 = icmp slt i32 2, %96
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %do.body132
  br label %do.end137

if.end136:                                        ; preds = %do.body132
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.131)
  br label %do.end137

do.end137:                                        ; preds = %if.end136, %if.then135
  %97 = load ptr, ptr @myself, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %97, i32 0, i32 4
  %98 = load i64, ptr %configEpoch, align 8
  %99 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_epoch138 = getelementptr inbounds %struct.clusterState, ptr %99, i32 0, i32 15
  %100 = load i64, ptr %failover_auth_epoch138, align 8
  %cmp139 = icmp ult i64 %98, %100
  br i1 %cmp139, label %if.then141, label %if.end151

if.then141:                                       ; preds = %do.end137
  %101 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %failover_auth_epoch142 = getelementptr inbounds %struct.clusterState, ptr %101, i32 0, i32 15
  %102 = load i64, ptr %failover_auth_epoch142, align 8
  %103 = load ptr, ptr @myself, align 8
  %configEpoch143 = getelementptr inbounds %struct._clusterNode, ptr %103, i32 0, i32 4
  store i64 %102, ptr %configEpoch143, align 8
  br label %do.body144

do.body144:                                       ; preds = %if.then141
  %104 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp145 = icmp slt i32 2, %104
  br i1 %cmp145, label %if.then147, label %if.end148

if.then147:                                       ; preds = %do.body144
  br label %do.end150

if.end148:                                        ; preds = %do.body144
  %105 = load ptr, ptr @myself, align 8
  %configEpoch149 = getelementptr inbounds %struct._clusterNode, ptr %105, i32 0, i32 4
  %106 = load i64, ptr %configEpoch149, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.132, i64 noundef %106)
  br label %do.end150

do.end150:                                        ; preds = %if.end148, %if.then147
  br label %if.end151

if.end151:                                        ; preds = %do.end150, %do.end137
  call void @clusterFailoverReplaceYourMaster()
  br label %if.end153

if.else152:                                       ; preds = %if.end127
  call void @clusterLogCantFailover(i32 noundef 4)
  br label %if.end153

if.end153:                                        ; preds = %if.else152, %if.end151, %do.end125, %if.then112, %if.then108, %do.end, %if.then42, %if.then18
  ret void
}

; Function Attrs: nounwind
declare i64 @random() #6

; Function Attrs: nounwind uwtable
define dso_local void @clusterHandleSlaveMigration(i32 noundef %max_slaves) #0 {
entry:
  %max_slaves.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %okslaves = alloca i32, align 4
  %mymaster = alloca ptr, align 8
  %target = alloca ptr, align 8
  %candidate = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %node = alloca ptr, align 8
  %okslaves20 = alloca i32, align 4
  %is_orphaned = alloca i32, align 4
  store i32 %max_slaves, ptr %max_slaves.addr, align 4
  store i32 0, ptr %okslaves, align 4
  %0 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 11
  %1 = load ptr, ptr %slaveof, align 8
  store ptr %1, ptr %mymaster, align 8
  store ptr null, ptr %target, align 8
  store ptr null, ptr %candidate, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %state, align 8
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end94

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %mymaster, align 8
  %cmp1 = icmp eq ptr %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %if.end94

if.end3:                                          ; preds = %if.end
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %5 = load i32, ptr %j, align 4
  %6 = load ptr, ptr %mymaster, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 9
  %7 = load i32, ptr %numslaves, align 8
  %cmp4 = icmp slt i32 %5, %7
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %mymaster, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 10
  %9 = load ptr, ptr %slaves, align 8
  %10 = load i32, ptr %j, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %9, i64 %idxprom
  %11 = load ptr, ptr %arrayidx, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %flags, align 8
  %and = and i32 %12, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %13 = load ptr, ptr %mymaster, align 8
  %slaves5 = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 10
  %14 = load ptr, ptr %slaves5, align 8
  %15 = load i32, ptr %j, align 4
  %idxprom6 = sext i32 %15 to i64
  %arrayidx7 = getelementptr inbounds ptr, ptr %14, i64 %idxprom6
  %16 = load ptr, ptr %arrayidx7, align 8
  %flags8 = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %flags8, align 8
  %and9 = and i32 %17, 4
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %land.lhs.true
  %18 = load i32, ptr %okslaves, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %okslaves, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %19 = load i32, ptr %j, align 4
  %inc13 = add nsw i32 %19, 1
  store i32 %inc13, ptr %j, align 4
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  %20 = load i32, ptr %okslaves, align 4
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 368), align 8
  %cmp14 = icmp sle i32 %20, %21
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.end
  br label %if.end94

if.end16:                                         ; preds = %for.end
  %22 = load ptr, ptr @myself, align 8
  store ptr %22, ptr %candidate, align 8
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %23, i32 0, i32 4
  %24 = load ptr, ptr %nodes, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %24)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end77, %if.end16
  %25 = load ptr, ptr %di, align 8
  %call17 = call ptr @dictNext(ptr noundef %25)
  store ptr %call17, ptr %de, align 8
  %cmp18 = icmp ne ptr %call17, null
  br i1 %cmp18, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %26 = load ptr, ptr %de, align 8
  %call19 = call ptr @dictGetVal(ptr noundef %26)
  store ptr %call19, ptr %node, align 8
  store i32 0, ptr %okslaves20, align 4
  store i32 1, ptr %is_orphaned, align 4
  %27 = load ptr, ptr %node, align 8
  %flags21 = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 3
  %28 = load i32, ptr %flags21, align 8
  %and22 = and i32 %28, 2
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %29 = load ptr, ptr %node, align 8
  %flags24 = getelementptr inbounds %struct._clusterNode, ptr %29, i32 0, i32 3
  %30 = load i32, ptr %flags24, align 8
  %and25 = and i32 %30, 8
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %lor.lhs.false, %while.body
  store i32 0, ptr %is_orphaned, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %lor.lhs.false
  %31 = load ptr, ptr %node, align 8
  %flags29 = getelementptr inbounds %struct._clusterNode, ptr %31, i32 0, i32 3
  %32 = load i32, ptr %flags29, align 8
  %and30 = and i32 %32, 256
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.end28
  store i32 0, ptr %is_orphaned, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.end28
  %33 = load ptr, ptr %node, align 8
  %call34 = call i32 @clusterNodeIsMaster(ptr noundef %33)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end33
  %34 = load ptr, ptr %node, align 8
  %call37 = call i32 @clusterCountNonFailingSlaves(ptr noundef %34)
  store i32 %call37, ptr %okslaves20, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end33
  %35 = load i32, ptr %okslaves20, align 4
  %cmp39 = icmp sgt i32 %35, 0
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end38
  store i32 0, ptr %is_orphaned, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %if.end38
  %36 = load i32, ptr %is_orphaned, align 4
  %tobool42 = icmp ne i32 %36, 0
  br i1 %tobool42, label %if.then43, label %if.else

if.then43:                                        ; preds = %if.end41
  %37 = load ptr, ptr %target, align 8
  %tobool44 = icmp ne ptr %37, null
  br i1 %tobool44, label %if.end48, label %land.lhs.true45

land.lhs.true45:                                  ; preds = %if.then43
  %38 = load ptr, ptr %node, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %38, i32 0, i32 8
  %39 = load i32, ptr %numslots, align 4
  %cmp46 = icmp sgt i32 %39, 0
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %land.lhs.true45
  %40 = load ptr, ptr %node, align 8
  store ptr %40, ptr %target, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %land.lhs.true45, %if.then43
  %41 = load ptr, ptr %node, align 8
  %orphaned_time = getelementptr inbounds %struct._clusterNode, ptr %41, i32 0, i32 19
  %42 = load i64, ptr %orphaned_time, align 8
  %tobool49 = icmp ne i64 %42, 0
  br i1 %tobool49, label %if.end53, label %if.then50

if.then50:                                        ; preds = %if.end48
  %call51 = call i64 @mstime()
  %43 = load ptr, ptr %node, align 8
  %orphaned_time52 = getelementptr inbounds %struct._clusterNode, ptr %43, i32 0, i32 19
  store i64 %call51, ptr %orphaned_time52, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.then50, %if.end48
  br label %if.end55

if.else:                                          ; preds = %if.end41
  %44 = load ptr, ptr %node, align 8
  %orphaned_time54 = getelementptr inbounds %struct._clusterNode, ptr %44, i32 0, i32 19
  store i64 0, ptr %orphaned_time54, align 8
  br label %if.end55

if.end55:                                         ; preds = %if.else, %if.end53
  %45 = load i32, ptr %okslaves20, align 4
  %46 = load i32, ptr %max_slaves.addr, align 4
  %cmp56 = icmp eq i32 %45, %46
  br i1 %cmp56, label %if.then57, label %if.end77

if.then57:                                        ; preds = %if.end55
  store i32 0, ptr %j, align 4
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc74, %if.then57
  %47 = load i32, ptr %j, align 4
  %48 = load ptr, ptr %node, align 8
  %numslaves59 = getelementptr inbounds %struct._clusterNode, ptr %48, i32 0, i32 9
  %49 = load i32, ptr %numslaves59, align 8
  %cmp60 = icmp slt i32 %47, %49
  br i1 %cmp60, label %for.body61, label %for.end76

for.body61:                                       ; preds = %for.cond58
  %50 = load ptr, ptr %node, align 8
  %slaves62 = getelementptr inbounds %struct._clusterNode, ptr %50, i32 0, i32 10
  %51 = load ptr, ptr %slaves62, align 8
  %52 = load i32, ptr %j, align 4
  %idxprom63 = sext i32 %52 to i64
  %arrayidx64 = getelementptr inbounds ptr, ptr %51, i64 %idxprom63
  %53 = load ptr, ptr %arrayidx64, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %53, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %54 = load ptr, ptr %candidate, align 8
  %name65 = getelementptr inbounds %struct._clusterNode, ptr %54, i32 0, i32 1
  %arraydecay66 = getelementptr inbounds [40 x i8], ptr %name65, i64 0, i64 0
  %call67 = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %arraydecay66, i64 noundef 40) #12
  %cmp68 = icmp slt i32 %call67, 0
  br i1 %cmp68, label %if.then69, label %if.end73

if.then69:                                        ; preds = %for.body61
  %55 = load ptr, ptr %node, align 8
  %slaves70 = getelementptr inbounds %struct._clusterNode, ptr %55, i32 0, i32 10
  %56 = load ptr, ptr %slaves70, align 8
  %57 = load i32, ptr %j, align 4
  %idxprom71 = sext i32 %57 to i64
  %arrayidx72 = getelementptr inbounds ptr, ptr %56, i64 %idxprom71
  %58 = load ptr, ptr %arrayidx72, align 8
  store ptr %58, ptr %candidate, align 8
  br label %if.end73

if.end73:                                         ; preds = %if.then69, %for.body61
  br label %for.inc74

for.inc74:                                        ; preds = %if.end73
  %59 = load i32, ptr %j, align 4
  %inc75 = add nsw i32 %59, 1
  store i32 %inc75, ptr %j, align 4
  br label %for.cond58, !llvm.loop !56

for.end76:                                        ; preds = %for.cond58
  br label %if.end77

if.end77:                                         ; preds = %for.end76, %if.end55
  br label %while.cond, !llvm.loop !57

while.end:                                        ; preds = %while.cond
  %60 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %60)
  %61 = load ptr, ptr %target, align 8
  %tobool78 = icmp ne ptr %61, null
  br i1 %tobool78, label %land.lhs.true79, label %if.end94

land.lhs.true79:                                  ; preds = %while.end
  %62 = load ptr, ptr %candidate, align 8
  %63 = load ptr, ptr @myself, align 8
  %cmp80 = icmp eq ptr %62, %63
  br i1 %cmp80, label %land.lhs.true81, label %if.end94

land.lhs.true81:                                  ; preds = %land.lhs.true79
  %call82 = call i64 @mstime()
  %64 = load ptr, ptr %target, align 8
  %orphaned_time83 = getelementptr inbounds %struct._clusterNode, ptr %64, i32 0, i32 19
  %65 = load i64, ptr %orphaned_time83, align 8
  %sub = sub nsw i64 %call82, %65
  %cmp84 = icmp sgt i64 %sub, 5000
  br i1 %cmp84, label %land.lhs.true85, label %if.end94

land.lhs.true85:                                  ; preds = %land.lhs.true81
  %66 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  %and86 = and i32 %66, 2
  %tobool87 = icmp ne i32 %and86, 0
  br i1 %tobool87, label %if.end94, label %if.then88

if.then88:                                        ; preds = %land.lhs.true85
  br label %do.body

do.body:                                          ; preds = %if.then88
  %67 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp89 = icmp slt i32 2, %67
  br i1 %cmp89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %do.body
  br label %do.end

if.end91:                                         ; preds = %do.body
  %68 = load ptr, ptr %target, align 8
  %name92 = getelementptr inbounds %struct._clusterNode, ptr %68, i32 0, i32 1
  %arraydecay93 = getelementptr inbounds [40 x i8], ptr %name92, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.133, ptr noundef %arraydecay93)
  br label %do.end

do.end:                                           ; preds = %if.end91, %if.then90
  %69 = load ptr, ptr %target, align 8
  call void @clusterSetMaster(ptr noundef %69)
  br label %if.end94

if.end94:                                         ; preds = %do.end, %land.lhs.true85, %land.lhs.true81, %land.lhs.true79, %while.end, %if.then15, %if.then2, %if.then
  ret void
}

declare void @unpauseActions(i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @manualFailoverCheckTimeout() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 17
  %1 = load i64, ptr %mf_end, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end1 = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 17
  %3 = load i64, ptr %mf_end1, align 8
  %call = call i64 @mstime()
  %cmp = icmp slt i64 %3, %call
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %land.lhs.true
  br label %do.body

do.body:                                          ; preds = %if.then
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp2 = icmp slt i32 3, %4
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.134)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then3
  call void @resetManualFailover()
  br label %if.end4

if.end4:                                          ; preds = %do.end, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterHandleManualFailover() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 17
  %1 = load i64, ptr %mf_end, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_can_start = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 20
  %3 = load i32, ptr %mf_can_start, align 8
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %return

if.end2:                                          ; preds = %if.end
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_master_offset = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 19
  %5 = load i64, ptr %mf_master_offset, align 8
  %cmp3 = icmp eq i64 %5, -1
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end2
  br label %return

if.end5:                                          ; preds = %if.end2
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_master_offset6 = getelementptr inbounds %struct.clusterState, ptr %6, i32 0, i32 19
  %7 = load i64, ptr %mf_master_offset6, align 8
  %call = call i64 @replicationGetSlaveOffset()
  %cmp7 = icmp eq i64 %7, %call
  br i1 %cmp7, label %if.then8, label %if.end13

if.then8:                                         ; preds = %if.end5
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_can_start9 = getelementptr inbounds %struct.clusterState, ptr %8, i32 0, i32 20
  store i32 1, ptr %mf_can_start9, align 8
  br label %do.body

do.body:                                          ; preds = %if.then8
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp10 = icmp slt i32 2, %9
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.body
  br label %do.end

if.end12:                                         ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.135)
  br label %do.end

do.end:                                           ; preds = %if.end12, %if.then11
  call void @clusterDoBeforeSleep(i32 noundef 1)
  br label %return

if.end13:                                         ; preds = %if.end5
  call void @clusterDoBeforeSleep(i32 noundef 16)
  br label %return

return:                                           ; preds = %if.end13, %do.end, %if.then4, %if.then1, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterCron() #0 {
entry:
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %update_state = alloca i32, align 4
  %orphaned_masters = alloca i32, align 4
  %max_slaves = alloca i32, align 4
  %this_slaves = alloca i32, align 4
  %min_pong = alloca i64, align 8
  %now = alloca i64, align 8
  %min_pong_node = alloca ptr, align 8
  %handshake_timeout = alloca i64, align 8
  %node = alloca ptr, align 8
  %j = alloca i32, align 4
  %this = alloca ptr, align 8
  %node42 = alloca ptr, align 8
  %okslaves = alloca i32, align 4
  %ping_delay = alloca i64, align 8
  %data_delay = alloca i64, align 8
  %ping_interval = alloca i64, align 8
  %node_delay = alloca i64, align 8
  store i32 0, ptr %update_state, align 4
  store i64 0, ptr %min_pong, align 8
  %call = call i64 @mstime()
  store i64 %call, ptr %now, align 8
  store ptr null, ptr %min_pong_node, align 8
  %0 = load i64, ptr @clusterCron.iteration, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr @clusterCron.iteration, align 8
  call void @clusterUpdateMyselfHostname()
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  store i64 %1, ptr %handshake_timeout, align 8
  %2 = load i64, ptr %handshake_timeout, align 8
  %cmp = icmp slt i64 %2, 1000
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 1000, ptr %handshake_timeout, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_pfail_nodes = getelementptr inbounds %struct.clusterState, ptr %3, i32 0, i32 25
  store i64 0, ptr %stats_pfail_nodes, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %nodes, align 8
  %call1 = call ptr @dictGetSafeIterator(ptr noundef %5)
  store ptr %call1, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end7, %if.then6, %if.end
  %6 = load ptr, ptr %di, align 8
  %call2 = call ptr @dictNext(ptr noundef %6)
  store ptr %call2, ptr %de, align 8
  %cmp3 = icmp ne ptr %call2, null
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load ptr, ptr %de, align 8
  %call4 = call ptr @dictGetVal(ptr noundef %7)
  store ptr %call4, ptr %node, align 8
  %8 = load ptr, ptr %node, align 8
  call void @clusterNodeCronFreeLinkOnBufferLimitReached(ptr noundef %8)
  %9 = load ptr, ptr %node, align 8
  %10 = load i64, ptr %handshake_timeout, align 8
  %11 = load i64, ptr %now, align 8
  %call5 = call i32 @clusterNodeCronHandleReconnect(ptr noundef %9, i64 noundef %10, i64 noundef %11)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !58

if.end7:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !58

while.end:                                        ; preds = %while.cond
  %12 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %12)
  %13 = load i64, ptr @clusterCron.iteration, align 8
  %rem = urem i64 %13, 10
  %tobool8 = icmp ne i64 %rem, 0
  br i1 %tobool8, label %if.end35, label %if.then9

if.then9:                                         ; preds = %while.end
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then9
  %14 = load i32, ptr %j, align 4
  %cmp10 = icmp slt i32 %14, 5
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes11 = getelementptr inbounds %struct.clusterState, ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %nodes11, align 8
  %call12 = call ptr @dictGetRandomKey(ptr noundef %16)
  store ptr %call12, ptr %de, align 8
  %17 = load ptr, ptr %de, align 8
  %call13 = call ptr @dictGetVal(ptr noundef %17)
  store ptr %call13, ptr %this, align 8
  %18 = load ptr, ptr %this, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 27
  %19 = load ptr, ptr %link, align 8
  %cmp14 = icmp eq ptr %19, null
  br i1 %cmp14, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %20 = load ptr, ptr %this, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %20, i32 0, i32 13
  %21 = load i64, ptr %ping_sent, align 8
  %cmp15 = icmp ne i64 %21, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end17:                                         ; preds = %lor.lhs.false
  %22 = load ptr, ptr %this, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 3
  %23 = load i32, ptr %flags, align 8
  %and = and i32 %23, 48
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end17
  br label %for.inc

if.end20:                                         ; preds = %if.end17
  %24 = load ptr, ptr %min_pong_node, align 8
  %cmp21 = icmp eq ptr %24, null
  br i1 %cmp21, label %if.then24, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %if.end20
  %25 = load i64, ptr %min_pong, align 8
  %26 = load ptr, ptr %this, align 8
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %26, i32 0, i32 14
  %27 = load i64, ptr %pong_received, align 8
  %cmp23 = icmp sgt i64 %25, %27
  br i1 %cmp23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %lor.lhs.false22, %if.end20
  %28 = load ptr, ptr %this, align 8
  store ptr %28, ptr %min_pong_node, align 8
  %29 = load ptr, ptr %this, align 8
  %pong_received25 = getelementptr inbounds %struct._clusterNode, ptr %29, i32 0, i32 14
  %30 = load i64, ptr %pong_received25, align 8
  store i64 %30, ptr %min_pong, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %lor.lhs.false22
  br label %for.inc

for.inc:                                          ; preds = %if.end26, %if.then19, %if.then16
  %31 = load i32, ptr %j, align 4
  %inc27 = add nsw i32 %31, 1
  store i32 %inc27, ptr %j, align 4
  br label %for.cond, !llvm.loop !59

for.end:                                          ; preds = %for.cond
  %32 = load ptr, ptr %min_pong_node, align 8
  %tobool28 = icmp ne ptr %32, null
  br i1 %tobool28, label %if.then29, label %if.end34

if.then29:                                        ; preds = %for.end
  br label %do.body

do.body:                                          ; preds = %if.then29
  %33 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp30 = icmp slt i32 0, %33
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %do.body
  br label %do.end

if.end32:                                         ; preds = %do.body
  %34 = load ptr, ptr %min_pong_node, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %34, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.136, ptr noundef %arraydecay)
  br label %do.end

do.end:                                           ; preds = %if.end32, %if.then31
  %35 = load ptr, ptr %min_pong_node, align 8
  %link33 = getelementptr inbounds %struct._clusterNode, ptr %35, i32 0, i32 27
  %36 = load ptr, ptr %link33, align 8
  call void @clusterSendPing(ptr noundef %36, i32 noundef 0)
  br label %if.end34

if.end34:                                         ; preds = %do.end, %for.end
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %while.end
  store i32 0, ptr %orphaned_masters, align 4
  store i32 0, ptr %max_slaves, align 4
  store i32 0, ptr %this_slaves, align 4
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes36 = getelementptr inbounds %struct.clusterState, ptr %37, i32 0, i32 4
  %38 = load ptr, ptr %nodes36, align 8
  %call37 = call ptr @dictGetSafeIterator(ptr noundef %38)
  store ptr %call37, ptr %di, align 8
  br label %while.cond38

while.cond38:                                     ; preds = %if.end147, %if.then125, %if.then120, %if.then108, %if.then48, %if.end35
  %39 = load ptr, ptr %di, align 8
  %call39 = call ptr @dictNext(ptr noundef %39)
  store ptr %call39, ptr %de, align 8
  %cmp40 = icmp ne ptr %call39, null
  br i1 %cmp40, label %while.body41, label %while.end148

while.body41:                                     ; preds = %while.cond38
  %40 = load ptr, ptr %de, align 8
  %call43 = call ptr @dictGetVal(ptr noundef %40)
  store ptr %call43, ptr %node42, align 8
  %call44 = call i64 @mstime()
  store i64 %call44, ptr %now, align 8
  %41 = load ptr, ptr %node42, align 8
  %flags45 = getelementptr inbounds %struct._clusterNode, ptr %41, i32 0, i32 3
  %42 = load i32, ptr %flags45, align 8
  %and46 = and i32 %42, 112
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %while.body41
  br label %while.cond38, !llvm.loop !60

if.end49:                                         ; preds = %while.body41
  %43 = load ptr, ptr @myself, align 8
  %flags50 = getelementptr inbounds %struct._clusterNode, ptr %43, i32 0, i32 3
  %44 = load i32, ptr %flags50, align 8
  %and51 = and i32 %44, 2
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %land.lhs.true, label %if.end77

land.lhs.true:                                    ; preds = %if.end49
  %45 = load ptr, ptr %node42, align 8
  %call53 = call i32 @clusterNodeIsMaster(ptr noundef %45)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %land.lhs.true55, label %if.end77

land.lhs.true55:                                  ; preds = %land.lhs.true
  %46 = load ptr, ptr %node42, align 8
  %flags56 = getelementptr inbounds %struct._clusterNode, ptr %46, i32 0, i32 3
  %47 = load i32, ptr %flags56, align 8
  %and57 = and i32 %47, 8
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.end77, label %if.then59

if.then59:                                        ; preds = %land.lhs.true55
  %48 = load ptr, ptr %node42, align 8
  %call60 = call i32 @clusterCountNonFailingSlaves(ptr noundef %48)
  store i32 %call60, ptr %okslaves, align 4
  %49 = load i32, ptr %okslaves, align 4
  %cmp61 = icmp eq i32 %49, 0
  br i1 %cmp61, label %land.lhs.true62, label %if.end70

land.lhs.true62:                                  ; preds = %if.then59
  %50 = load ptr, ptr %node42, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %50, i32 0, i32 8
  %51 = load i32, ptr %numslots, align 4
  %cmp63 = icmp sgt i32 %51, 0
  br i1 %cmp63, label %land.lhs.true64, label %if.end70

land.lhs.true64:                                  ; preds = %land.lhs.true62
  %52 = load ptr, ptr %node42, align 8
  %flags65 = getelementptr inbounds %struct._clusterNode, ptr %52, i32 0, i32 3
  %53 = load i32, ptr %flags65, align 8
  %and66 = and i32 %53, 256
  %tobool67 = icmp ne i32 %and66, 0
  br i1 %tobool67, label %if.then68, label %if.end70

if.then68:                                        ; preds = %land.lhs.true64
  %54 = load i32, ptr %orphaned_masters, align 4
  %inc69 = add nsw i32 %54, 1
  store i32 %inc69, ptr %orphaned_masters, align 4
  br label %if.end70

if.end70:                                         ; preds = %if.then68, %land.lhs.true64, %land.lhs.true62, %if.then59
  %55 = load i32, ptr %okslaves, align 4
  %56 = load i32, ptr %max_slaves, align 4
  %cmp71 = icmp sgt i32 %55, %56
  br i1 %cmp71, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.end70
  %57 = load i32, ptr %okslaves, align 4
  store i32 %57, ptr %max_slaves, align 4
  br label %if.end73

if.end73:                                         ; preds = %if.then72, %if.end70
  %58 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %58, i32 0, i32 11
  %59 = load ptr, ptr %slaveof, align 8
  %60 = load ptr, ptr %node42, align 8
  %cmp74 = icmp eq ptr %59, %60
  br i1 %cmp74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %if.end73
  %61 = load i32, ptr %okslaves, align 4
  store i32 %61, ptr %this_slaves, align 4
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %if.end73
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %land.lhs.true55, %land.lhs.true, %if.end49
  %62 = load i64, ptr %now, align 8
  %63 = load ptr, ptr %node42, align 8
  %ping_sent78 = getelementptr inbounds %struct._clusterNode, ptr %63, i32 0, i32 13
  %64 = load i64, ptr %ping_sent78, align 8
  %sub = sub nsw i64 %62, %64
  store i64 %sub, ptr %ping_delay, align 8
  %65 = load i64, ptr %now, align 8
  %66 = load ptr, ptr %node42, align 8
  %data_received = getelementptr inbounds %struct._clusterNode, ptr %66, i32 0, i32 15
  %67 = load i64, ptr %data_received, align 8
  %sub79 = sub nsw i64 %65, %67
  store i64 %sub79, ptr %data_delay, align 8
  %68 = load ptr, ptr %node42, align 8
  %link80 = getelementptr inbounds %struct._clusterNode, ptr %68, i32 0, i32 27
  %69 = load ptr, ptr %link80, align 8
  %tobool81 = icmp ne ptr %69, null
  br i1 %tobool81, label %land.lhs.true82, label %if.end96

land.lhs.true82:                                  ; preds = %if.end77
  %70 = load i64, ptr %now, align 8
  %71 = load ptr, ptr %node42, align 8
  %link83 = getelementptr inbounds %struct._clusterNode, ptr %71, i32 0, i32 27
  %72 = load ptr, ptr %link83, align 8
  %ctime = getelementptr inbounds %struct.clusterLink, ptr %72, i32 0, i32 0
  %73 = load i64, ptr %ctime, align 8
  %sub84 = sub nsw i64 %70, %73
  %74 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %cmp85 = icmp sgt i64 %sub84, %74
  br i1 %cmp85, label %land.lhs.true86, label %if.end96

land.lhs.true86:                                  ; preds = %land.lhs.true82
  %75 = load ptr, ptr %node42, align 8
  %ping_sent87 = getelementptr inbounds %struct._clusterNode, ptr %75, i32 0, i32 13
  %76 = load i64, ptr %ping_sent87, align 8
  %tobool88 = icmp ne i64 %76, 0
  br i1 %tobool88, label %land.lhs.true89, label %if.end96

land.lhs.true89:                                  ; preds = %land.lhs.true86
  %77 = load i64, ptr %ping_delay, align 8
  %78 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %div = sdiv i64 %78, 2
  %cmp90 = icmp sgt i64 %77, %div
  br i1 %cmp90, label %land.lhs.true91, label %if.end96

land.lhs.true91:                                  ; preds = %land.lhs.true89
  %79 = load i64, ptr %data_delay, align 8
  %80 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %div92 = sdiv i64 %80, 2
  %cmp93 = icmp sgt i64 %79, %div92
  br i1 %cmp93, label %if.then94, label %if.end96

if.then94:                                        ; preds = %land.lhs.true91
  %81 = load ptr, ptr %node42, align 8
  %link95 = getelementptr inbounds %struct._clusterNode, ptr %81, i32 0, i32 27
  %82 = load ptr, ptr %link95, align 8
  call void @freeClusterLink(ptr noundef %82)
  br label %if.end96

if.end96:                                         ; preds = %if.then94, %land.lhs.true91, %land.lhs.true89, %land.lhs.true86, %land.lhs.true82, %if.end77
  %83 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 365), align 8
  %tobool97 = icmp ne i64 %83, 0
  br i1 %tobool97, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end96
  %84 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 365), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end96
  %85 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %div98 = sdiv i64 %85, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %84, %cond.true ], [ %div98, %cond.false ]
  store i64 %cond, ptr %ping_interval, align 8
  %86 = load ptr, ptr %node42, align 8
  %link99 = getelementptr inbounds %struct._clusterNode, ptr %86, i32 0, i32 27
  %87 = load ptr, ptr %link99, align 8
  %tobool100 = icmp ne ptr %87, null
  br i1 %tobool100, label %land.lhs.true101, label %if.end110

land.lhs.true101:                                 ; preds = %cond.end
  %88 = load ptr, ptr %node42, align 8
  %ping_sent102 = getelementptr inbounds %struct._clusterNode, ptr %88, i32 0, i32 13
  %89 = load i64, ptr %ping_sent102, align 8
  %cmp103 = icmp eq i64 %89, 0
  br i1 %cmp103, label %land.lhs.true104, label %if.end110

land.lhs.true104:                                 ; preds = %land.lhs.true101
  %90 = load i64, ptr %now, align 8
  %91 = load ptr, ptr %node42, align 8
  %pong_received105 = getelementptr inbounds %struct._clusterNode, ptr %91, i32 0, i32 14
  %92 = load i64, ptr %pong_received105, align 8
  %sub106 = sub nsw i64 %90, %92
  %93 = load i64, ptr %ping_interval, align 8
  %cmp107 = icmp sgt i64 %sub106, %93
  br i1 %cmp107, label %if.then108, label %if.end110

if.then108:                                       ; preds = %land.lhs.true104
  %94 = load ptr, ptr %node42, align 8
  %link109 = getelementptr inbounds %struct._clusterNode, ptr %94, i32 0, i32 27
  %95 = load ptr, ptr %link109, align 8
  call void @clusterSendPing(ptr noundef %95, i32 noundef 0)
  br label %while.cond38, !llvm.loop !60

if.end110:                                        ; preds = %land.lhs.true104, %land.lhs.true101, %cond.end
  %96 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %96, i32 0, i32 17
  %97 = load i64, ptr %mf_end, align 8
  %tobool111 = icmp ne i64 %97, 0
  br i1 %tobool111, label %land.lhs.true112, label %if.end122

land.lhs.true112:                                 ; preds = %if.end110
  %98 = load ptr, ptr @myself, align 8
  %call113 = call i32 @clusterNodeIsMaster(ptr noundef %98)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %land.lhs.true115, label %if.end122

land.lhs.true115:                                 ; preds = %land.lhs.true112
  %99 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_slave = getelementptr inbounds %struct.clusterState, ptr %99, i32 0, i32 18
  %100 = load ptr, ptr %mf_slave, align 8
  %101 = load ptr, ptr %node42, align 8
  %cmp116 = icmp eq ptr %100, %101
  br i1 %cmp116, label %land.lhs.true117, label %if.end122

land.lhs.true117:                                 ; preds = %land.lhs.true115
  %102 = load ptr, ptr %node42, align 8
  %link118 = getelementptr inbounds %struct._clusterNode, ptr %102, i32 0, i32 27
  %103 = load ptr, ptr %link118, align 8
  %tobool119 = icmp ne ptr %103, null
  br i1 %tobool119, label %if.then120, label %if.end122

if.then120:                                       ; preds = %land.lhs.true117
  %104 = load ptr, ptr %node42, align 8
  %link121 = getelementptr inbounds %struct._clusterNode, ptr %104, i32 0, i32 27
  %105 = load ptr, ptr %link121, align 8
  call void @clusterSendPing(ptr noundef %105, i32 noundef 0)
  br label %while.cond38, !llvm.loop !60

if.end122:                                        ; preds = %land.lhs.true117, %land.lhs.true115, %land.lhs.true112, %if.end110
  %106 = load ptr, ptr %node42, align 8
  %ping_sent123 = getelementptr inbounds %struct._clusterNode, ptr %106, i32 0, i32 13
  %107 = load i64, ptr %ping_sent123, align 8
  %cmp124 = icmp eq i64 %107, 0
  br i1 %cmp124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end122
  br label %while.cond38, !llvm.loop !60

if.end126:                                        ; preds = %if.end122
  %108 = load i64, ptr %ping_delay, align 8
  %109 = load i64, ptr %data_delay, align 8
  %cmp127 = icmp slt i64 %108, %109
  br i1 %cmp127, label %cond.true128, label %cond.false129

cond.true128:                                     ; preds = %if.end126
  %110 = load i64, ptr %ping_delay, align 8
  br label %cond.end130

cond.false129:                                    ; preds = %if.end126
  %111 = load i64, ptr %data_delay, align 8
  br label %cond.end130

cond.end130:                                      ; preds = %cond.false129, %cond.true128
  %cond131 = phi i64 [ %110, %cond.true128 ], [ %111, %cond.false129 ]
  store i64 %cond131, ptr %node_delay, align 8
  %112 = load i64, ptr %node_delay, align 8
  %113 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 364), align 8
  %cmp132 = icmp sgt i64 %112, %113
  br i1 %cmp132, label %if.then133, label %if.end147

if.then133:                                       ; preds = %cond.end130
  %114 = load ptr, ptr %node42, align 8
  %flags134 = getelementptr inbounds %struct._clusterNode, ptr %114, i32 0, i32 3
  %115 = load i32, ptr %flags134, align 8
  %and135 = and i32 %115, 12
  %tobool136 = icmp ne i32 %and135, 0
  br i1 %tobool136, label %if.end146, label %if.then137

if.then137:                                       ; preds = %if.then133
  br label %do.body138

do.body138:                                       ; preds = %if.then137
  %116 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp139 = icmp slt i32 0, %116
  br i1 %cmp139, label %if.then140, label %if.end141

if.then140:                                       ; preds = %do.body138
  br label %do.end144

if.end141:                                        ; preds = %do.body138
  %117 = load ptr, ptr %node42, align 8
  %name142 = getelementptr inbounds %struct._clusterNode, ptr %117, i32 0, i32 1
  %arraydecay143 = getelementptr inbounds [40 x i8], ptr %name142, i64 0, i64 0
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.137, ptr noundef %arraydecay143)
  br label %do.end144

do.end144:                                        ; preds = %if.end141, %if.then140
  %118 = load ptr, ptr %node42, align 8
  %flags145 = getelementptr inbounds %struct._clusterNode, ptr %118, i32 0, i32 3
  %119 = load i32, ptr %flags145, align 8
  %or = or i32 %119, 4
  store i32 %or, ptr %flags145, align 8
  store i32 1, ptr %update_state, align 4
  br label %if.end146

if.end146:                                        ; preds = %do.end144, %if.then133
  br label %if.end147

if.end147:                                        ; preds = %if.end146, %cond.end130
  br label %while.cond38, !llvm.loop !60

while.end148:                                     ; preds = %while.cond38
  %120 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %120)
  %121 = load ptr, ptr @myself, align 8
  %flags149 = getelementptr inbounds %struct._clusterNode, ptr %121, i32 0, i32 3
  %122 = load i32, ptr %flags149, align 8
  %and150 = and i32 %122, 2
  %tobool151 = icmp ne i32 %and150, 0
  br i1 %tobool151, label %land.lhs.true152, label %if.end167

land.lhs.true152:                                 ; preds = %while.end148
  %123 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %cmp153 = icmp eq ptr %123, null
  br i1 %cmp153, label %land.lhs.true154, label %if.end167

land.lhs.true154:                                 ; preds = %land.lhs.true152
  %124 = load ptr, ptr @myself, align 8
  %slaveof155 = getelementptr inbounds %struct._clusterNode, ptr %124, i32 0, i32 11
  %125 = load ptr, ptr %slaveof155, align 8
  %tobool156 = icmp ne ptr %125, null
  br i1 %tobool156, label %land.lhs.true157, label %if.end167

land.lhs.true157:                                 ; preds = %land.lhs.true154
  %126 = load ptr, ptr @myself, align 8
  %slaveof158 = getelementptr inbounds %struct._clusterNode, ptr %126, i32 0, i32 11
  %127 = load ptr, ptr %slaveof158, align 8
  %flags159 = getelementptr inbounds %struct._clusterNode, ptr %127, i32 0, i32 3
  %128 = load i32, ptr %flags159, align 8
  %and160 = and i32 %128, 64
  %tobool161 = icmp ne i32 %and160, 0
  br i1 %tobool161, label %if.end167, label %if.then162

if.then162:                                       ; preds = %land.lhs.true157
  %129 = load ptr, ptr @myself, align 8
  %slaveof163 = getelementptr inbounds %struct._clusterNode, ptr %129, i32 0, i32 11
  %130 = load ptr, ptr %slaveof163, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %130, i32 0, i32 21
  %arraydecay164 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %131 = load ptr, ptr @myself, align 8
  %slaveof165 = getelementptr inbounds %struct._clusterNode, ptr %131, i32 0, i32 11
  %132 = load ptr, ptr %slaveof165, align 8
  %call166 = call i32 @getNodeDefaultReplicationPort(ptr noundef %132)
  call void @replicationSetMaster(ptr noundef %arraydecay164, i32 noundef %call166)
  br label %if.end167

if.end167:                                        ; preds = %if.then162, %land.lhs.true157, %land.lhs.true154, %land.lhs.true152, %while.end148
  call void @manualFailoverCheckTimeout()
  %133 = load ptr, ptr @myself, align 8
  %flags168 = getelementptr inbounds %struct._clusterNode, ptr %133, i32 0, i32 3
  %134 = load i32, ptr %flags168, align 8
  %and169 = and i32 %134, 2
  %tobool170 = icmp ne i32 %and169, 0
  br i1 %tobool170, label %if.then171, label %if.end185

if.then171:                                       ; preds = %if.end167
  call void @clusterHandleManualFailover()
  %135 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  %and172 = and i32 %135, 2
  %tobool173 = icmp ne i32 %and172, 0
  br i1 %tobool173, label %if.end175, label %if.then174

if.then174:                                       ; preds = %if.then171
  call void @clusterHandleSlaveFailover()
  br label %if.end175

if.end175:                                        ; preds = %if.then174, %if.then171
  %136 = load i32, ptr %orphaned_masters, align 4
  %tobool176 = icmp ne i32 %136, 0
  br i1 %tobool176, label %land.lhs.true177, label %if.end184

land.lhs.true177:                                 ; preds = %if.end175
  %137 = load i32, ptr %max_slaves, align 4
  %cmp178 = icmp sge i32 %137, 2
  br i1 %cmp178, label %land.lhs.true179, label %if.end184

land.lhs.true179:                                 ; preds = %land.lhs.true177
  %138 = load i32, ptr %this_slaves, align 4
  %139 = load i32, ptr %max_slaves, align 4
  %cmp180 = icmp eq i32 %138, %139
  br i1 %cmp180, label %land.lhs.true181, label %if.end184

land.lhs.true181:                                 ; preds = %land.lhs.true179
  %140 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 369), align 4
  %tobool182 = icmp ne i32 %140, 0
  br i1 %tobool182, label %if.then183, label %if.end184

if.then183:                                       ; preds = %land.lhs.true181
  %141 = load i32, ptr %max_slaves, align 4
  call void @clusterHandleSlaveMigration(i32 noundef %141)
  br label %if.end184

if.end184:                                        ; preds = %if.then183, %land.lhs.true181, %land.lhs.true179, %land.lhs.true177, %if.end175
  br label %if.end185

if.end185:                                        ; preds = %if.end184, %if.end167
  %142 = load i32, ptr %update_state, align 4
  %tobool186 = icmp ne i32 %142, 0
  br i1 %tobool186, label %if.then189, label %lor.lhs.false187

lor.lhs.false187:                                 ; preds = %if.end185
  %143 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %143, i32 0, i32 2
  %144 = load i32, ptr %state, align 8
  %cmp188 = icmp eq i32 %144, 1
  br i1 %cmp188, label %if.then189, label %if.end190

if.then189:                                       ; preds = %lor.lhs.false187, %if.end185
  call void @clusterUpdateState()
  br label %if.end190

if.end190:                                        ; preds = %if.then189, %lor.lhs.false187
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clusterNodeCronFreeLinkOnBufferLimitReached(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 27
  %1 = load ptr, ptr %link, align 8
  call void @freeClusterLinkOnBufferLimitReached(ptr noundef %1)
  %2 = load ptr, ptr %node.addr, align 8
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 28
  %3 = load ptr, ptr %inbound_link, align 8
  call void @freeClusterLinkOnBufferLimitReached(ptr noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterNodeCronHandleReconnect(ptr noundef %node, i64 noundef %handshake_timeout, i64 noundef %now) #0 {
entry:
  %retval = alloca i32, align 4
  %node.addr = alloca ptr, align 8
  %handshake_timeout.addr = alloca i64, align 8
  %now.addr = alloca i64, align 8
  %link13 = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store i64 %handshake_timeout, ptr %handshake_timeout.addr, align 8
  store i64 %now, ptr %now.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 80
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %node.addr, align 8
  %flags1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 3
  %3 = load i32, ptr %flags1, align 8
  %and2 = and i32 %3, 4
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_pfail_nodes = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 25
  %5 = load i64, ptr %stats_pfail_nodes, align 8
  %inc = add nsw i64 %5, 1
  store i64 %inc, ptr %stats_pfail_nodes, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %6 = load ptr, ptr %node.addr, align 8
  %flags6 = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %flags6, align 8
  %and7 = and i32 %7, 32
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end5
  %8 = load i64, ptr %now.addr, align 8
  %9 = load ptr, ptr %node.addr, align 8
  %ctime = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 0
  %10 = load i64, ptr %ctime, align 8
  %sub = sub nsw i64 %8, %10
  %11 = load i64, ptr %handshake_timeout.addr, align 8
  %cmp = icmp sgt i64 %sub, %11
  br i1 %cmp, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true
  %12 = load ptr, ptr %node.addr, align 8
  call void @clusterDelNode(ptr noundef %12)
  store i32 1, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %land.lhs.true, %if.end5
  %13 = load ptr, ptr %node.addr, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %13, i32 0, i32 27
  %14 = load ptr, ptr %link, align 8
  %cmp11 = icmp eq ptr %14, null
  br i1 %cmp11, label %if.then12, label %if.end33

if.then12:                                        ; preds = %if.end10
  %15 = load ptr, ptr %node.addr, align 8
  %call = call ptr @createClusterLink(ptr noundef %15)
  store ptr %call, ptr %link13, align 8
  %call14 = call ptr @connTypeOfCluster()
  %call15 = call ptr @connCreate(ptr noundef %call14)
  %16 = load ptr, ptr %link13, align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %16, i32 0, i32 1
  store ptr %call15, ptr %conn, align 8
  %17 = load ptr, ptr %link13, align 8
  %conn16 = getelementptr inbounds %struct.clusterLink, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %conn16, align 8
  %19 = load ptr, ptr %link13, align 8
  call void @connSetPrivateData(ptr noundef %18, ptr noundef %19)
  %20 = load ptr, ptr %link13, align 8
  %conn17 = getelementptr inbounds %struct.clusterLink, ptr %20, i32 0, i32 1
  %21 = load ptr, ptr %conn17, align 8
  %22 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 21
  %arraydecay = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %23 = load ptr, ptr %node.addr, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 26
  %24 = load i32, ptr %cport, align 8
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 49), align 8
  %call18 = call i32 @connConnect(ptr noundef %21, ptr noundef %arraydecay, i32 noundef %24, ptr noundef %25, ptr noundef @clusterLinkConnectHandler)
  %cmp19 = icmp eq i32 %call18, -1
  br i1 %cmp19, label %if.then20, label %if.end32

if.then20:                                        ; preds = %if.then12
  %26 = load ptr, ptr %node.addr, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %26, i32 0, i32 13
  %27 = load i64, ptr %ping_sent, align 8
  %cmp21 = icmp eq i64 %27, 0
  br i1 %cmp21, label %if.then22, label %if.end25

if.then22:                                        ; preds = %if.then20
  %call23 = call i64 @mstime()
  %28 = load ptr, ptr %node.addr, align 8
  %ping_sent24 = getelementptr inbounds %struct._clusterNode, ptr %28, i32 0, i32 13
  store i64 %call23, ptr %ping_sent24, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %if.then20
  br label %do.body

do.body:                                          ; preds = %if.end25
  %29 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp26 = icmp slt i32 0, %29
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %do.body
  br label %do.end

if.end28:                                         ; preds = %do.body
  %30 = load ptr, ptr %node.addr, align 8
  %ip29 = getelementptr inbounds %struct._clusterNode, ptr %30, i32 0, i32 21
  %arraydecay30 = getelementptr inbounds [46 x i8], ptr %ip29, i64 0, i64 0
  %31 = load ptr, ptr %node.addr, align 8
  %cport31 = getelementptr inbounds %struct._clusterNode, ptr %31, i32 0, i32 26
  %32 = load i32, ptr %cport31, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.308, ptr noundef %arraydecay30, i32 noundef %32, ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 70))
  br label %do.end

do.end:                                           ; preds = %if.end28, %if.then27
  %33 = load ptr, ptr %link13, align 8
  call void @freeClusterLink(ptr noundef %33)
  store i32 0, ptr %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.then12
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end10
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end33, %do.end, %if.then9, %if.then
  %34 = load i32, ptr %retval, align 4
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterBeforeSleep() #0 {
entry:
  %flags = alloca i32, align 4
  %fsync = alloca i32, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %todo_before_sleep = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 22
  %1 = load i32, ptr %todo_before_sleep, align 8
  store i32 %1, ptr %flags, align 4
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %todo_before_sleep1 = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 22
  store i32 0, ptr %todo_before_sleep1, align 8
  %3 = load i32, ptr %flags, align 4
  %and = and i32 %3, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr @myself, align 8
  %flags2 = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %flags2, align 8
  %and3 = and i32 %5, 2
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.then
  call void @clusterHandleManualFailover()
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  %and6 = and i32 %6, 2
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.end, label %if.then8

if.then8:                                         ; preds = %if.then5
  call void @clusterHandleSlaveFailover()
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then5
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then
  br label %if.end14

if.else:                                          ; preds = %entry
  %7 = load i32, ptr %flags, align 4
  %and10 = and i32 %7, 1
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.else
  call void @clusterHandleSlaveFailover()
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.else
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.end9
  %8 = load i32, ptr %flags, align 4
  %and15 = and i32 %8, 2
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  call void @clusterUpdateState()
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end14
  %9 = load i32, ptr %flags, align 4
  %and19 = and i32 %9, 4
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end18
  %10 = load i32, ptr %flags, align 4
  %and22 = and i32 %10, 8
  store i32 %and22, ptr %fsync, align 4
  %11 = load i32, ptr %fsync, align 4
  call void @clusterSaveConfigOrDie(i32 noundef %11)
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end18
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterMastersHaveSlaves() #0 {
entry:
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %slaves = alloca i32, align 4
  %node = alloca ptr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %1)
  store ptr %call, ptr %di, align 8
  store i32 0, ptr %slaves, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then, %entry
  %2 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %2)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %3)
  store ptr %call2, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %flags, align 8
  %and = and i32 %5, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !61

if.end:                                           ; preds = %while.body
  %6 = load ptr, ptr %node, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 9
  %7 = load i32, ptr %numslaves, align 8
  %8 = load i32, ptr %slaves, align 4
  %add = add nsw i32 %8, %7
  store i32 %add, ptr %slaves, align 4
  br label %while.cond, !llvm.loop !61

while.end:                                        ; preds = %while.cond
  %9 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %9)
  %10 = load i32, ptr %slaves, align 4
  %cmp3 = icmp ne i32 %10, 0
  %conv = zext i1 %cmp3 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeSetSlotBit(ptr noundef %n, i32 noundef %slot) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %old = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %slots = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [2048 x i8], ptr %slots, i64 0, i64 0
  %1 = load i32, ptr %slot.addr, align 4
  %call = call i32 @bitmapTestBit(ptr noundef %arraydecay, i32 noundef %1)
  store i32 %call, ptr %old, align 4
  %2 = load i32, ptr %old, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %slots1 = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 5
  %arraydecay2 = getelementptr inbounds [2048 x i8], ptr %slots1, i64 0, i64 0
  %4 = load i32, ptr %slot.addr, align 4
  call void @bitmapSetBit(ptr noundef %arraydecay2, i32 noundef %4)
  %5 = load ptr, ptr %n.addr, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 8
  %6 = load i32, ptr %numslots, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %numslots, align 4
  %7 = load ptr, ptr %n.addr, align 8
  %numslots3 = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 8
  %8 = load i32, ptr %numslots3, align 4
  %cmp = icmp eq i32 %8, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %call4 = call i32 @clusterMastersHaveSlaves()
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %land.lhs.true
  %9 = load ptr, ptr %n.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %flags, align 8
  %or = or i32 %10, 256
  store i32 %or, ptr %flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then6, %land.lhs.true, %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %11 = load i32, ptr %old, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeClearSlotBit(ptr noundef %n, i32 noundef %slot) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %old = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr %n.addr, align 8
  %slots = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [2048 x i8], ptr %slots, i64 0, i64 0
  %1 = load i32, ptr %slot.addr, align 4
  %call = call i32 @bitmapTestBit(ptr noundef %arraydecay, i32 noundef %1)
  store i32 %call, ptr %old, align 4
  %2 = load i32, ptr %old, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %n.addr, align 8
  %slots1 = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 5
  %arraydecay2 = getelementptr inbounds [2048 x i8], ptr %slots1, i64 0, i64 0
  %4 = load i32, ptr %slot.addr, align 4
  call void @bitmapClearBit(ptr noundef %arraydecay2, i32 noundef %4)
  %5 = load ptr, ptr %n.addr, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 8
  %6 = load i32, ptr %numslots, align 4
  %dec = add nsw i32 %6, -1
  store i32 %dec, ptr %numslots, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32, ptr %old, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define dso_local void @removeChannelsInSlot(i32 noundef %slot) #0 {
entry:
  %slot.addr = alloca i32, align 4
  %channelcount = alloca i32, align 4
  %channels = alloca ptr, align 8
  %iter = alloca %struct.raxIterator, align 8
  %j = alloca i32, align 4
  %indexed = alloca [2 x i8], align 1
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load i32, ptr %slot.addr, align 4
  %call = call i32 @countChannelsInSlot(i32 noundef %0)
  store i32 %call, ptr %channelcount, align 4
  %1 = load i32, ptr %channelcount, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %channelcount, align 4
  %conv = zext i32 %2 to i64
  %mul = mul i64 8, %conv
  %call1 = call noalias ptr @zmalloc(i64 noundef %mul) #16
  store ptr %call1, ptr %channels, align 8
  store i32 0, ptr %j, align 4
  %3 = load i32, ptr %slot.addr, align 4
  %shr = lshr i32 %3, 8
  %and = and i32 %shr, 255
  %conv2 = trunc i32 %and to i8
  %arrayidx = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 0
  store i8 %conv2, ptr %arrayidx, align 1
  %4 = load i32, ptr %slot.addr, align 4
  %and3 = and i32 %4, 255
  %conv4 = trunc i32 %and3 to i8
  %arrayidx5 = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 1
  store i8 %conv4, ptr %arrayidx5, align 1
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots_to_channels = getelementptr inbounds %struct.clusterState, ptr %5, i32 0, i32 10
  %6 = load ptr, ptr %slots_to_channels, align 8
  call void @raxStart(ptr noundef %iter, ptr noundef %6)
  %arraydecay = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 0
  %call6 = call i32 @raxSeek(ptr noundef %iter, ptr noundef @.str.205, ptr noundef %arraydecay, i64 noundef 2)
  br label %while.cond

while.cond:                                       ; preds = %if.end22, %if.end
  %call7 = call i32 @raxNext(ptr noundef %iter)
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %key = getelementptr inbounds %struct.raxIterator, ptr %iter, i32 0, i32 2
  %7 = load ptr, ptr %key, align 8
  %arrayidx8 = getelementptr inbounds i8, ptr %7, i64 0
  %8 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %8 to i32
  %arrayidx10 = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 0
  %9 = load i8, ptr %arrayidx10, align 1
  %conv11 = zext i8 %9 to i32
  %cmp12 = icmp ne i32 %conv9, %conv11
  br i1 %cmp12, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %key14 = getelementptr inbounds %struct.raxIterator, ptr %iter, i32 0, i32 2
  %10 = load ptr, ptr %key14, align 8
  %arrayidx15 = getelementptr inbounds i8, ptr %10, i64 1
  %11 = load i8, ptr %arrayidx15, align 1
  %conv16 = zext i8 %11 to i32
  %arrayidx17 = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 1
  %12 = load i8, ptr %arrayidx17, align 1
  %conv18 = zext i8 %12 to i32
  %cmp19 = icmp ne i32 %conv16, %conv18
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %lor.lhs.false, %while.body
  br label %while.end

if.end22:                                         ; preds = %lor.lhs.false
  %key23 = getelementptr inbounds %struct.raxIterator, ptr %iter, i32 0, i32 2
  %13 = load ptr, ptr %key23, align 8
  %add.ptr = getelementptr inbounds i8, ptr %13, i64 2
  %key_len = getelementptr inbounds %struct.raxIterator, ptr %iter, i32 0, i32 4
  %14 = load i64, ptr %key_len, align 8
  %sub = sub i64 %14, 2
  %call24 = call ptr @createStringObject(ptr noundef %add.ptr, i64 noundef %sub)
  %15 = load ptr, ptr %channels, align 8
  %16 = load i32, ptr %j, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %j, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx25 = getelementptr inbounds ptr, ptr %15, i64 %idxprom
  store ptr %call24, ptr %arrayidx25, align 8
  br label %while.cond, !llvm.loop !62

while.end:                                        ; preds = %if.then21, %while.cond
  call void @raxStop(ptr noundef %iter)
  %17 = load ptr, ptr %channels, align 8
  %18 = load i32, ptr %channelcount, align 4
  call void @pubsubUnsubscribeShardChannels(ptr noundef %17, i32 noundef %18)
  %19 = load ptr, ptr %channels, align 8
  call void @zfree(ptr noundef %19)
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @verifyClusterConfigWithData() #0 {
entry:
  %retval = alloca i32, align 4
  %j = alloca i32, align 4
  %update_config = alloca i32, align 4
  store i32 0, ptr %update_config, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  %and = and i32 %0, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and1 = and i32 %2, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  store i32 1, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %3 = load i32, ptr %j, align 4
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 173), align 8
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %6 = load i32, ptr %j, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %5, i64 %idxprom
  %call = call i64 @dbSize(ptr noundef %arrayidx, i32 noundef 0)
  %tobool5 = icmp ne i64 %call, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  store i32 -1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %7 = load i32, ptr %j, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !63

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %j, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc45, %for.end
  %8 = load i32, ptr %j, align 4
  %cmp9 = icmp slt i32 %8, 16384
  br i1 %cmp9, label %for.body10, label %for.end47

for.body10:                                       ; preds = %for.cond8
  %9 = load i32, ptr %j, align 4
  %call11 = call i32 @countKeysInSlot(i32 noundef %9)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %for.body10
  br label %for.inc45

if.end14:                                         ; preds = %for.body10
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %10, i32 0, i32 9
  %11 = load i32, ptr %j, align 4
  %idxprom15 = sext i32 %11 to i64
  %arrayidx16 = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom15
  %12 = load ptr, ptr %arrayidx16, align 8
  %13 = load ptr, ptr @myself, align 8
  %cmp17 = icmp eq ptr %12, %13
  br i1 %cmp17, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end14
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %14, i32 0, i32 8
  %15 = load i32, ptr %j, align 4
  %idxprom18 = sext i32 %15 to i64
  %arrayidx19 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 %idxprom18
  %16 = load ptr, ptr %arrayidx19, align 8
  %cmp20 = icmp ne ptr %16, null
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %lor.lhs.false, %if.end14
  br label %for.inc45

if.end22:                                         ; preds = %lor.lhs.false
  %17 = load i32, ptr %update_config, align 4
  %inc23 = add nsw i32 %17, 1
  store i32 %inc23, ptr %update_config, align 4
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots24 = getelementptr inbounds %struct.clusterState, ptr %18, i32 0, i32 9
  %19 = load i32, ptr %j, align 4
  %idxprom25 = sext i32 %19 to i64
  %arrayidx26 = getelementptr inbounds [16384 x ptr], ptr %slots24, i64 0, i64 %idxprom25
  %20 = load ptr, ptr %arrayidx26, align 8
  %cmp27 = icmp eq ptr %20, null
  br i1 %cmp27, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.end22
  br label %do.body

do.body:                                          ; preds = %if.then28
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp29 = icmp slt i32 2, %21
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %do.body
  br label %do.end

if.end31:                                         ; preds = %do.body
  %22 = load i32, ptr %j, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.141, i32 noundef %22)
  br label %do.end

do.end:                                           ; preds = %if.end31, %if.then30
  %23 = load ptr, ptr @myself, align 8
  %24 = load i32, ptr %j, align 4
  %call32 = call i32 @clusterAddSlot(ptr noundef %23, i32 noundef %24)
  br label %if.end44

if.else:                                          ; preds = %if.end22
  br label %do.body33

do.body33:                                        ; preds = %if.else
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp34 = icmp slt i32 2, %25
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %do.body33
  br label %do.end37

if.end36:                                         ; preds = %do.body33
  %26 = load i32, ptr %j, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.142, i32 noundef %26)
  br label %do.end37

do.end37:                                         ; preds = %if.end36, %if.then35
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots38 = getelementptr inbounds %struct.clusterState, ptr %27, i32 0, i32 9
  %28 = load i32, ptr %j, align 4
  %idxprom39 = sext i32 %28 to i64
  %arrayidx40 = getelementptr inbounds [16384 x ptr], ptr %slots38, i64 0, i64 %idxprom39
  %29 = load ptr, ptr %arrayidx40, align 8
  %30 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from41 = getelementptr inbounds %struct.clusterState, ptr %30, i32 0, i32 8
  %31 = load i32, ptr %j, align 4
  %idxprom42 = sext i32 %31 to i64
  %arrayidx43 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from41, i64 0, i64 %idxprom42
  store ptr %29, ptr %arrayidx43, align 8
  br label %if.end44

if.end44:                                         ; preds = %do.end37, %do.end
  br label %for.inc45

for.inc45:                                        ; preds = %if.end44, %if.then21, %if.then13
  %32 = load i32, ptr %j, align 4
  %inc46 = add nsw i32 %32, 1
  store i32 %inc46, ptr %j, align 4
  br label %for.cond8, !llvm.loop !64

for.end47:                                        ; preds = %for.cond8
  %33 = load i32, ptr %update_config, align 4
  %tobool48 = icmp ne i32 %33, 0
  br i1 %tobool48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %for.end47
  call void @clusterSaveConfigOrDie(i32 noundef 1)
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %for.end47
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end50, %if.then6, %if.then3, %if.then
  %34 = load i32, ptr %retval, align 4
  ret i32 %34
}

declare i64 @dbSize(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @removeAllNotOwnedShardChannelSubscriptions() #0 {
entry:
  %currmaster = alloca ptr, align 8
  %j = alloca i32, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 360), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %0, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %1 = load i64, ptr %arrayidx, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 360), align 8
  %ht_used1 = getelementptr inbounds %struct.dict, ptr %2, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [2 x i64], ptr %ht_used1, i64 0, i64 1
  %3 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %1, %3
  %tobool = icmp ne i64 %add, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr @myself, align 8
  %call = call i32 @clusterNodeIsMaster(ptr noundef %4)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load ptr, ptr @myself, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 11
  %7 = load ptr, ptr %slaveof, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %5, %cond.true ], [ %7, %cond.false ]
  store ptr %cond, ptr %currmaster, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %8 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %8, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %9, i32 0, i32 9
  %10 = load i32, ptr %j, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx4 = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom
  %11 = load ptr, ptr %arrayidx4, align 8
  %12 = load ptr, ptr %currmaster, align 8
  %cmp5 = icmp ne ptr %11, %12
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  %13 = load i32, ptr %j, align 4
  call void @removeChannelsInSlot(i32 noundef %13)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %14 = load i32, ptr %j, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !65

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

declare ptr @sdscat(ptr noundef, ptr noundef) #1

declare void @sdsIncrLen(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @representSlotInfo(ptr noundef %ci, ptr noundef %slot_info_pairs, i32 noundef %slot_info_pairs_count) #0 {
entry:
  %ci.addr = alloca ptr, align 8
  %slot_info_pairs.addr = alloca ptr, align 8
  %slot_info_pairs_count.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %start = alloca i64, align 8
  %end = alloca i64, align 8
  store ptr %ci, ptr %ci.addr, align 8
  store ptr %slot_info_pairs, ptr %slot_info_pairs.addr, align 8
  store i32 %slot_info_pairs_count, ptr %slot_info_pairs_count.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %slot_info_pairs_count.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %slot_info_pairs.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds i16, ptr %2, i64 %idxprom
  %4 = load i16, ptr %arrayidx, align 2
  %conv = zext i16 %4 to i64
  store i64 %conv, ptr %start, align 8
  %5 = load ptr, ptr %slot_info_pairs.addr, align 8
  %6 = load i32, ptr %i, align 4
  %add = add nsw i32 %6, 1
  %idxprom1 = sext i32 %add to i64
  %arrayidx2 = getelementptr inbounds i16, ptr %5, i64 %idxprom1
  %7 = load i16, ptr %arrayidx2, align 2
  %conv3 = zext i16 %7 to i64
  store i64 %conv3, ptr %end, align 8
  %8 = load i64, ptr %start, align 8
  %9 = load i64, ptr %end, align 8
  %cmp4 = icmp eq i64 %8, %9
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %ci.addr, align 8
  %11 = load i64, ptr %start, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %10, ptr noundef @.str.146, i64 noundef %11)
  store ptr %call, ptr %ci.addr, align 8
  br label %if.end

if.else:                                          ; preds = %for.body
  %12 = load ptr, ptr %ci.addr, align 8
  %13 = load i64, ptr %start, align 8
  %14 = load i64, ptr %end, align 8
  %call6 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %12, ptr noundef @.str.147, i64 noundef %13, i64 noundef %14)
  store ptr %call6, ptr %ci.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i32, ptr %i, align 4
  %add7 = add nsw i32 %15, 2
  store i32 %add7, ptr %i, align 4
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %for.cond
  %16 = load ptr, ptr %ci.addr, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterGenNodeDescription(ptr noundef %c, ptr noundef %node, i32 noundef %tls_primary) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %tls_primary.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %start = alloca i32, align 4
  %ci = alloca ptr, align 8
  %port = alloca i32, align 4
  %i = alloca i32, align 4
  %nodeEpoch = alloca i64, align 8
  %bit = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  store i32 %tls_primary, ptr %tls_primary.addr, align 4
  %0 = load ptr, ptr %node.addr, align 8
  %1 = load i32, ptr %tls_primary.addr, align 4
  %call = call i32 @clusterNodeClientPort(ptr noundef %0, i32 noundef %1)
  store i32 %call, ptr %port, align 4
  %call1 = call ptr @sdsempty()
  %2 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %call2 = call ptr @sdscatlen(ptr noundef %call1, ptr noundef %arraydecay, i64 noundef 40)
  store ptr %call2, ptr %ci, align 8
  %3 = load ptr, ptr %ci, align 8
  %4 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 21
  %arraydecay3 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %5 = load i32, ptr %port, align 4
  %6 = load ptr, ptr %node.addr, align 8
  %cport = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 26
  %7 = load i32, ptr %cport, align 8
  %call4 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %3, ptr noundef @.str.148, ptr noundef %arraydecay3, i32 noundef %5, i32 noundef %7)
  store ptr %call4, ptr %ci, align 8
  %8 = load ptr, ptr %node.addr, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 22
  %9 = load ptr, ptr %hostname, align 8
  %call5 = call i64 @sdslen(ptr noundef %9)
  %cmp = icmp ne i64 %call5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %ci, align 8
  %11 = load ptr, ptr %node.addr, align 8
  %hostname6 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 22
  %12 = load ptr, ptr %hostname6, align 8
  %call7 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %10, ptr noundef @.str.149, ptr noundef %12)
  store ptr %call7, ptr %ci, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %13 = load ptr, ptr %c.addr, align 8
  %cmp8 = icmp eq ptr %13, null
  br i1 %cmp8, label %if.then9, label %if.end33

if.then9:                                         ; preds = %if.end
  %14 = load ptr, ptr %node.addr, align 8
  %hostname10 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 22
  %15 = load ptr, ptr %hostname10, align 8
  %call11 = call i64 @sdslen(ptr noundef %15)
  %cmp12 = icmp eq i64 %call11, 0
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.then9
  %16 = load ptr, ptr %ci, align 8
  %call14 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %16, ptr noundef @.str.14, i32 noundef 1)
  store ptr %call14, ptr %ci, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.then9
  store i32 3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end15
  %17 = load i32, ptr %i, align 4
  %cmp16 = icmp sge i32 %17, 0
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load i32, ptr %tls_primary.addr, align 4
  %tobool = icmp ne i32 %18, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %for.body
  %19 = load i32, ptr %i, align 4
  %cmp17 = icmp eq i32 %19, 3
  br i1 %cmp17, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %for.body
  %20 = load i32, ptr %tls_primary.addr, align 4
  %tobool18 = icmp ne i32 %20, 0
  br i1 %tobool18, label %if.end22, label %land.lhs.true19

land.lhs.true19:                                  ; preds = %lor.lhs.false
  %21 = load i32, ptr %i, align 4
  %cmp20 = icmp eq i32 %21, 2
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %land.lhs.true19, %land.lhs.true
  br label %for.inc

if.end22:                                         ; preds = %land.lhs.true19, %lor.lhs.false
  %22 = load i32, ptr %i, align 4
  %idxprom = sext i32 %22 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %idxprom
  %isPresent = getelementptr inbounds %struct.auxFieldHandler, ptr %arrayidx, i32 0, i32 3
  %23 = load ptr, ptr %isPresent, align 8
  %24 = load ptr, ptr %node.addr, align 8
  %call23 = call i32 %23(ptr noundef %24)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then25, label %if.end32

if.then25:                                        ; preds = %if.end22
  %25 = load ptr, ptr %ci, align 8
  %26 = load i32, ptr %i, align 4
  %idxprom26 = sext i32 %26 to i64
  %arrayidx27 = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %idxprom26
  %field = getelementptr inbounds %struct.auxFieldHandler, ptr %arrayidx27, i32 0, i32 0
  %27 = load ptr, ptr %field, align 16
  %call28 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %25, ptr noundef @.str.150, ptr noundef %27)
  store ptr %call28, ptr %ci, align 8
  %28 = load i32, ptr %i, align 4
  %idxprom29 = sext i32 %28 to i64
  %arrayidx30 = getelementptr inbounds [4 x %struct.auxFieldHandler], ptr @auxFieldHandlers, i64 0, i64 %idxprom29
  %getter = getelementptr inbounds %struct.auxFieldHandler, ptr %arrayidx30, i32 0, i32 2
  %29 = load ptr, ptr %getter, align 16
  %30 = load ptr, ptr %node.addr, align 8
  %31 = load ptr, ptr %ci, align 8
  %call31 = call ptr %29(ptr noundef %30, ptr noundef %31)
  store ptr %call31, ptr %ci, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then25, %if.end22
  br label %for.inc

for.inc:                                          ; preds = %if.end32, %if.then21
  %32 = load i32, ptr %i, align 4
  %dec = add nsw i32 %32, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond, !llvm.loop !67

for.end:                                          ; preds = %for.cond
  br label %if.end33

if.end33:                                         ; preds = %for.end, %if.end
  %33 = load ptr, ptr %ci, align 8
  %call34 = call ptr @sdscatlen(ptr noundef %33, ptr noundef @.str.151, i64 noundef 1)
  store ptr %call34, ptr %ci, align 8
  %34 = load ptr, ptr %ci, align 8
  %35 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %35, i32 0, i32 3
  %36 = load i32, ptr %flags, align 8
  %conv = trunc i32 %36 to i16
  %call35 = call ptr @representClusterNodeFlags(ptr noundef %34, i16 noundef zeroext %conv)
  store ptr %call35, ptr %ci, align 8
  %37 = load ptr, ptr %ci, align 8
  %call36 = call ptr @sdscatlen(ptr noundef %37, ptr noundef @.str.151, i64 noundef 1)
  store ptr %call36, ptr %ci, align 8
  %38 = load ptr, ptr %node.addr, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %38, i32 0, i32 11
  %39 = load ptr, ptr %slaveof, align 8
  %tobool37 = icmp ne ptr %39, null
  br i1 %tobool37, label %if.then38, label %if.else

if.then38:                                        ; preds = %if.end33
  %40 = load ptr, ptr %ci, align 8
  %41 = load ptr, ptr %node.addr, align 8
  %slaveof39 = getelementptr inbounds %struct._clusterNode, ptr %41, i32 0, i32 11
  %42 = load ptr, ptr %slaveof39, align 8
  %name40 = getelementptr inbounds %struct._clusterNode, ptr %42, i32 0, i32 1
  %arraydecay41 = getelementptr inbounds [40 x i8], ptr %name40, i64 0, i64 0
  %call42 = call ptr @sdscatlen(ptr noundef %40, ptr noundef %arraydecay41, i64 noundef 40)
  store ptr %call42, ptr %ci, align 8
  br label %if.end44

if.else:                                          ; preds = %if.end33
  %43 = load ptr, ptr %ci, align 8
  %call43 = call ptr @sdscatlen(ptr noundef %43, ptr noundef @.str.152, i64 noundef 1)
  store ptr %call43, ptr %ci, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.else, %if.then38
  %44 = load ptr, ptr %node.addr, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %44, i32 0, i32 4
  %45 = load i64, ptr %configEpoch, align 8
  store i64 %45, ptr %nodeEpoch, align 8
  %46 = load ptr, ptr %node.addr, align 8
  %flags45 = getelementptr inbounds %struct._clusterNode, ptr %46, i32 0, i32 3
  %47 = load i32, ptr %flags45, align 8
  %and = and i32 %47, 2
  %tobool46 = icmp ne i32 %and, 0
  br i1 %tobool46, label %land.lhs.true47, label %if.end53

land.lhs.true47:                                  ; preds = %if.end44
  %48 = load ptr, ptr %node.addr, align 8
  %slaveof48 = getelementptr inbounds %struct._clusterNode, ptr %48, i32 0, i32 11
  %49 = load ptr, ptr %slaveof48, align 8
  %tobool49 = icmp ne ptr %49, null
  br i1 %tobool49, label %if.then50, label %if.end53

if.then50:                                        ; preds = %land.lhs.true47
  %50 = load ptr, ptr %node.addr, align 8
  %slaveof51 = getelementptr inbounds %struct._clusterNode, ptr %50, i32 0, i32 11
  %51 = load ptr, ptr %slaveof51, align 8
  %configEpoch52 = getelementptr inbounds %struct._clusterNode, ptr %51, i32 0, i32 4
  %52 = load i64, ptr %configEpoch52, align 8
  store i64 %52, ptr %nodeEpoch, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.then50, %land.lhs.true47, %if.end44
  %53 = load ptr, ptr %ci, align 8
  %54 = load ptr, ptr %node.addr, align 8
  %ping_sent = getelementptr inbounds %struct._clusterNode, ptr %54, i32 0, i32 13
  %55 = load i64, ptr %ping_sent, align 8
  %56 = load ptr, ptr %node.addr, align 8
  %pong_received = getelementptr inbounds %struct._clusterNode, ptr %56, i32 0, i32 14
  %57 = load i64, ptr %pong_received, align 8
  %58 = load i64, ptr %nodeEpoch, align 8
  %59 = load ptr, ptr %node.addr, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %59, i32 0, i32 27
  %60 = load ptr, ptr %link, align 8
  %tobool54 = icmp ne ptr %60, null
  br i1 %tobool54, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end53
  %61 = load ptr, ptr %node.addr, align 8
  %flags55 = getelementptr inbounds %struct._clusterNode, ptr %61, i32 0, i32 3
  %62 = load i32, ptr %flags55, align 8
  %and56 = and i32 %62, 16
  %tobool57 = icmp ne i32 %and56, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end53
  %63 = phi i1 [ true, %if.end53 ], [ %tobool57, %lor.rhs ]
  %cond = select i1 %63, ptr @.str.154, ptr @.str.155
  %call58 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %53, ptr noundef @.str.153, i64 noundef %55, i64 noundef %57, i64 noundef %58, ptr noundef %cond)
  store ptr %call58, ptr %ci, align 8
  %64 = load ptr, ptr %node.addr, align 8
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %64, i32 0, i32 6
  %65 = load ptr, ptr %slot_info_pairs, align 8
  %tobool59 = icmp ne ptr %65, null
  br i1 %tobool59, label %if.then60, label %if.else63

if.then60:                                        ; preds = %lor.end
  %66 = load ptr, ptr %ci, align 8
  %67 = load ptr, ptr %node.addr, align 8
  %slot_info_pairs61 = getelementptr inbounds %struct._clusterNode, ptr %67, i32 0, i32 6
  %68 = load ptr, ptr %slot_info_pairs61, align 8
  %69 = load ptr, ptr %node.addr, align 8
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %69, i32 0, i32 7
  %70 = load i32, ptr %slot_info_pairs_count, align 8
  %call62 = call ptr @representSlotInfo(ptr noundef %66, ptr noundef %68, i32 noundef %70)
  store ptr %call62, ptr %ci, align 8
  br label %if.end107

if.else63:                                        ; preds = %lor.end
  %71 = load ptr, ptr %node.addr, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %71, i32 0, i32 8
  %72 = load i32, ptr %numslots, align 4
  %cmp64 = icmp sgt i32 %72, 0
  br i1 %cmp64, label %if.then66, label %if.end106

if.then66:                                        ; preds = %if.else63
  store i32 -1, ptr %start, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond67

for.cond67:                                       ; preds = %for.inc103, %if.then66
  %73 = load i32, ptr %j, align 4
  %cmp68 = icmp slt i32 %73, 16384
  br i1 %cmp68, label %for.body70, label %for.end105

for.body70:                                       ; preds = %for.cond67
  %74 = load ptr, ptr %node.addr, align 8
  %75 = load i32, ptr %j, align 4
  %call71 = call i32 @clusterNodeCoversSlot(ptr noundef %74, i32 noundef %75)
  store i32 %call71, ptr %bit, align 4
  %cmp72 = icmp ne i32 %call71, 0
  br i1 %cmp72, label %if.then74, label %if.end79

if.then74:                                        ; preds = %for.body70
  %76 = load i32, ptr %start, align 4
  %cmp75 = icmp eq i32 %76, -1
  br i1 %cmp75, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.then74
  %77 = load i32, ptr %j, align 4
  store i32 %77, ptr %start, align 4
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.then74
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %for.body70
  %78 = load i32, ptr %start, align 4
  %cmp80 = icmp ne i32 %78, -1
  br i1 %cmp80, label %land.lhs.true82, label %if.end102

land.lhs.true82:                                  ; preds = %if.end79
  %79 = load i32, ptr %bit, align 4
  %tobool83 = icmp ne i32 %79, 0
  br i1 %tobool83, label %lor.lhs.false84, label %if.then87

lor.lhs.false84:                                  ; preds = %land.lhs.true82
  %80 = load i32, ptr %j, align 4
  %cmp85 = icmp eq i32 %80, 16383
  br i1 %cmp85, label %if.then87, label %if.end102

if.then87:                                        ; preds = %lor.lhs.false84, %land.lhs.true82
  %81 = load i32, ptr %bit, align 4
  %tobool88 = icmp ne i32 %81, 0
  br i1 %tobool88, label %land.lhs.true89, label %if.end93

land.lhs.true89:                                  ; preds = %if.then87
  %82 = load i32, ptr %j, align 4
  %cmp90 = icmp eq i32 %82, 16383
  br i1 %cmp90, label %if.then92, label %if.end93

if.then92:                                        ; preds = %land.lhs.true89
  %83 = load i32, ptr %j, align 4
  %inc = add nsw i32 %83, 1
  store i32 %inc, ptr %j, align 4
  br label %if.end93

if.end93:                                         ; preds = %if.then92, %land.lhs.true89, %if.then87
  %84 = load i32, ptr %start, align 4
  %85 = load i32, ptr %j, align 4
  %sub = sub nsw i32 %85, 1
  %cmp94 = icmp eq i32 %84, %sub
  br i1 %cmp94, label %if.then96, label %if.else98

if.then96:                                        ; preds = %if.end93
  %86 = load ptr, ptr %ci, align 8
  %87 = load i32, ptr %start, align 4
  %call97 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %86, ptr noundef @.str.146, i32 noundef %87)
  store ptr %call97, ptr %ci, align 8
  br label %if.end101

if.else98:                                        ; preds = %if.end93
  %88 = load ptr, ptr %ci, align 8
  %89 = load i32, ptr %start, align 4
  %90 = load i32, ptr %j, align 4
  %sub99 = sub nsw i32 %90, 1
  %call100 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %88, ptr noundef @.str.147, i32 noundef %89, i32 noundef %sub99)
  store ptr %call100, ptr %ci, align 8
  br label %if.end101

if.end101:                                        ; preds = %if.else98, %if.then96
  store i32 -1, ptr %start, align 4
  br label %if.end102

if.end102:                                        ; preds = %if.end101, %lor.lhs.false84, %if.end79
  br label %for.inc103

for.inc103:                                       ; preds = %if.end102
  %91 = load i32, ptr %j, align 4
  %inc104 = add nsw i32 %91, 1
  store i32 %inc104, ptr %j, align 4
  br label %for.cond67, !llvm.loop !68

for.end105:                                       ; preds = %for.cond67
  br label %if.end106

if.end106:                                        ; preds = %for.end105, %if.else63
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %if.then60
  %92 = load ptr, ptr %node.addr, align 8
  %flags108 = getelementptr inbounds %struct._clusterNode, ptr %92, i32 0, i32 3
  %93 = load i32, ptr %flags108, align 8
  %and109 = and i32 %93, 16
  %tobool110 = icmp ne i32 %and109, 0
  br i1 %tobool110, label %if.then111, label %if.end142

if.then111:                                       ; preds = %if.end107
  store i32 0, ptr %j, align 4
  br label %for.cond112

for.cond112:                                      ; preds = %for.inc139, %if.then111
  %94 = load i32, ptr %j, align 4
  %cmp113 = icmp slt i32 %94, 16384
  br i1 %cmp113, label %for.body115, label %for.end141

for.body115:                                      ; preds = %for.cond112
  %95 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to = getelementptr inbounds %struct.clusterState, ptr %95, i32 0, i32 7
  %96 = load i32, ptr %j, align 4
  %idxprom116 = sext i32 %96 to i64
  %arrayidx117 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to, i64 0, i64 %idxprom116
  %97 = load ptr, ptr %arrayidx117, align 8
  %tobool118 = icmp ne ptr %97, null
  br i1 %tobool118, label %if.then119, label %if.else126

if.then119:                                       ; preds = %for.body115
  %98 = load ptr, ptr %ci, align 8
  %99 = load i32, ptr %j, align 4
  %100 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to120 = getelementptr inbounds %struct.clusterState, ptr %100, i32 0, i32 7
  %101 = load i32, ptr %j, align 4
  %idxprom121 = sext i32 %101 to i64
  %arrayidx122 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to120, i64 0, i64 %idxprom121
  %102 = load ptr, ptr %arrayidx122, align 8
  %name123 = getelementptr inbounds %struct._clusterNode, ptr %102, i32 0, i32 1
  %arraydecay124 = getelementptr inbounds [40 x i8], ptr %name123, i64 0, i64 0
  %call125 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %98, ptr noundef @.str.156, i32 noundef %99, ptr noundef %arraydecay124)
  store ptr %call125, ptr %ci, align 8
  br label %if.end138

if.else126:                                       ; preds = %for.body115
  %103 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %103, i32 0, i32 8
  %104 = load i32, ptr %j, align 4
  %idxprom127 = sext i32 %104 to i64
  %arrayidx128 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 %idxprom127
  %105 = load ptr, ptr %arrayidx128, align 8
  %tobool129 = icmp ne ptr %105, null
  br i1 %tobool129, label %if.then130, label %if.end137

if.then130:                                       ; preds = %if.else126
  %106 = load ptr, ptr %ci, align 8
  %107 = load i32, ptr %j, align 4
  %108 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from131 = getelementptr inbounds %struct.clusterState, ptr %108, i32 0, i32 8
  %109 = load i32, ptr %j, align 4
  %idxprom132 = sext i32 %109 to i64
  %arrayidx133 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from131, i64 0, i64 %idxprom132
  %110 = load ptr, ptr %arrayidx133, align 8
  %name134 = getelementptr inbounds %struct._clusterNode, ptr %110, i32 0, i32 1
  %arraydecay135 = getelementptr inbounds [40 x i8], ptr %name134, i64 0, i64 0
  %call136 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %106, ptr noundef @.str.157, i32 noundef %107, ptr noundef %arraydecay135)
  store ptr %call136, ptr %ci, align 8
  br label %if.end137

if.end137:                                        ; preds = %if.then130, %if.else126
  br label %if.end138

if.end138:                                        ; preds = %if.end137, %if.then119
  br label %for.inc139

for.inc139:                                       ; preds = %if.end138
  %111 = load i32, ptr %j, align 4
  %inc140 = add nsw i32 %111, 1
  store i32 %inc140, ptr %j, align 4
  br label %for.cond112, !llvm.loop !69

for.end141:                                       ; preds = %for.cond112
  br label %if.end142

if.end142:                                        ; preds = %for.end141, %if.end107
  %112 = load ptr, ptr %ci, align 8
  ret ptr %112
}

declare ptr @sdscatlen(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterGenNodesSlotsInfo(i32 noundef %filter) #0 {
entry:
  %filter.addr = alloca i32, align 4
  %n = alloca ptr, align 8
  %start = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %filter, ptr %filter.addr, align 4
  store ptr null, ptr %n, align 8
  store i32 -1, ptr %start, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp sle i32 %0, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %n, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end4

if.then:                                          ; preds = %for.body
  %2 = load i32, ptr %i, align 4
  %cmp2 = icmp eq i32 %2, 16384
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  br label %for.end

if.end:                                           ; preds = %if.then
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %3, i32 0, i32 9
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom
  %5 = load ptr, ptr %arrayidx, align 8
  store ptr %5, ptr %n, align 8
  %6 = load i32, ptr %i, align 4
  store i32 %6, ptr %start, align 4
  br label %for.inc

if.end4:                                          ; preds = %for.body
  %7 = load i32, ptr %i, align 4
  %cmp5 = icmp eq i32 %7, 16384
  br i1 %cmp5, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end4
  %8 = load ptr, ptr %n, align 8
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots6 = getelementptr inbounds %struct.clusterState, ptr %9, i32 0, i32 9
  %10 = load i32, ptr %i, align 4
  %idxprom7 = sext i32 %10 to i64
  %arrayidx8 = getelementptr inbounds [16384 x ptr], ptr %slots6, i64 0, i64 %idxprom7
  %11 = load ptr, ptr %arrayidx8, align 8
  %cmp9 = icmp ne ptr %8, %11
  br i1 %cmp9, label %if.then10, label %if.end43

if.then10:                                        ; preds = %lor.lhs.false, %if.end4
  %12 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 3
  %13 = load i32, ptr %flags, align 8
  %14 = load i32, ptr %filter.addr, align 4
  %and = and i32 %13, %14
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end35, label %if.then11

if.then11:                                        ; preds = %if.then10
  %15 = load ptr, ptr %n, align 8
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 6
  %16 = load ptr, ptr %slot_info_pairs, align 8
  %tobool12 = icmp ne ptr %16, null
  br i1 %tobool12, label %if.end16, label %if.then13

if.then13:                                        ; preds = %if.then11
  %17 = load ptr, ptr %n, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %17, i32 0, i32 8
  %18 = load i32, ptr %numslots, align 4
  %mul = mul nsw i32 2, %18
  %conv = sext i32 %mul to i64
  %mul14 = mul i64 %conv, 2
  %call = call noalias ptr @zmalloc(i64 noundef %mul14) #16
  %19 = load ptr, ptr %n, align 8
  %slot_info_pairs15 = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 6
  store ptr %call, ptr %slot_info_pairs15, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.then11
  %20 = load ptr, ptr %n, align 8
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %20, i32 0, i32 7
  %21 = load i32, ptr %slot_info_pairs_count, align 8
  %add = add nsw i32 %21, 1
  %22 = load ptr, ptr %n, align 8
  %numslots17 = getelementptr inbounds %struct._clusterNode, ptr %22, i32 0, i32 8
  %23 = load i32, ptr %numslots17, align 4
  %mul18 = mul nsw i32 2, %23
  %cmp19 = icmp slt i32 %add, %mul18
  %lnot = xor i1 %cmp19, true
  %lnot21 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot21 to i32
  %conv22 = sext i32 %lnot.ext to i64
  %tobool23 = icmp ne i64 %conv22, 0
  br i1 %tobool23, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end16
  br label %cond.end

cond.false:                                       ; preds = %if.end16
  call void @_serverAssert(ptr noundef @.str.158, ptr noundef @.str.18, i32 noundef 5288)
  call void @abort() #13
  unreachable

24:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %24, %cond.true
  %25 = load i32, ptr %start, align 4
  %conv24 = trunc i32 %25 to i16
  %26 = load ptr, ptr %n, align 8
  %slot_info_pairs25 = getelementptr inbounds %struct._clusterNode, ptr %26, i32 0, i32 6
  %27 = load ptr, ptr %slot_info_pairs25, align 8
  %28 = load ptr, ptr %n, align 8
  %slot_info_pairs_count26 = getelementptr inbounds %struct._clusterNode, ptr %28, i32 0, i32 7
  %29 = load i32, ptr %slot_info_pairs_count26, align 8
  %inc = add nsw i32 %29, 1
  store i32 %inc, ptr %slot_info_pairs_count26, align 8
  %idxprom27 = sext i32 %29 to i64
  %arrayidx28 = getelementptr inbounds i16, ptr %27, i64 %idxprom27
  store i16 %conv24, ptr %arrayidx28, align 2
  %30 = load i32, ptr %i, align 4
  %sub = sub nsw i32 %30, 1
  %conv29 = trunc i32 %sub to i16
  %31 = load ptr, ptr %n, align 8
  %slot_info_pairs30 = getelementptr inbounds %struct._clusterNode, ptr %31, i32 0, i32 6
  %32 = load ptr, ptr %slot_info_pairs30, align 8
  %33 = load ptr, ptr %n, align 8
  %slot_info_pairs_count31 = getelementptr inbounds %struct._clusterNode, ptr %33, i32 0, i32 7
  %34 = load i32, ptr %slot_info_pairs_count31, align 8
  %inc32 = add nsw i32 %34, 1
  store i32 %inc32, ptr %slot_info_pairs_count31, align 8
  %idxprom33 = sext i32 %34 to i64
  %arrayidx34 = getelementptr inbounds i16, ptr %32, i64 %idxprom33
  store i16 %conv29, ptr %arrayidx34, align 2
  br label %if.end35

if.end35:                                         ; preds = %cond.end, %if.then10
  %35 = load i32, ptr %i, align 4
  %cmp36 = icmp eq i32 %35, 16384
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end35
  br label %for.end

if.end39:                                         ; preds = %if.end35
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots40 = getelementptr inbounds %struct.clusterState, ptr %36, i32 0, i32 9
  %37 = load i32, ptr %i, align 4
  %idxprom41 = sext i32 %37 to i64
  %arrayidx42 = getelementptr inbounds [16384 x ptr], ptr %slots40, i64 0, i64 %idxprom41
  %38 = load ptr, ptr %arrayidx42, align 8
  store ptr %38, ptr %n, align 8
  %39 = load i32, ptr %i, align 4
  store i32 %39, ptr %start, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.end39, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end43, %if.end
  %40 = load i32, ptr %i, align 4
  %inc44 = add nsw i32 %40, 1
  store i32 %inc44, ptr %i, align 4
  br label %for.cond, !llvm.loop !70

for.end:                                          ; preds = %if.then38, %if.then3, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterFreeNodesSlotsInfo(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %slot_info_pairs, align 8
  call void @zfree(ptr noundef %1)
  %2 = load ptr, ptr %n.addr, align 8
  %slot_info_pairs1 = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 6
  store ptr null, ptr %slot_info_pairs1, align 8
  %3 = load ptr, ptr %n.addr, align 8
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 7
  store i32 0, ptr %slot_info_pairs_count, align 8
  ret void
}

declare ptr @sdscatsds(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @addReplyClusterLinkDescription(ptr noundef %c, ptr noundef %link) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %link.addr = alloca ptr, align 8
  %node_name = alloca ptr, align 8
  %events = alloca [3 x i8], align 1
  %p = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %link, ptr %link.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %0, i64 noundef 6)
  %1 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %1, ptr noundef @.str.160)
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load ptr, ptr %link.addr, align 8
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %3, i32 0, i32 9
  %4 = load i32, ptr %inbound, align 8
  %tobool = icmp ne i32 %4, 0
  %cond = select i1 %tobool, ptr @.str.161, ptr @.str.162
  call void @addReplyBulkCString(ptr noundef %2, ptr noundef %cond)
  %5 = load ptr, ptr %link.addr, align 8
  %node = getelementptr inbounds %struct.clusterLink, ptr %5, i32 0, i32 8
  %6 = load ptr, ptr %node, align 8
  %tobool1 = icmp ne ptr %6, null
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.163, ptr noundef @.str.18, i32 noundef 5356)
  call void @abort() #13
  unreachable

7:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %7, %cond.true
  %8 = load ptr, ptr %link.addr, align 8
  %node4 = getelementptr inbounds %struct.clusterLink, ptr %8, i32 0, i32 8
  %9 = load ptr, ptr %node4, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %call = call ptr @sdsnewlen(ptr noundef %arraydecay, i64 noundef 40)
  store ptr %call, ptr %node_name, align 8
  %10 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %10, ptr noundef @.str.164)
  %11 = load ptr, ptr %c.addr, align 8
  %12 = load ptr, ptr %node_name, align 8
  call void @addReplyBulkCString(ptr noundef %11, ptr noundef %12)
  %13 = load ptr, ptr %node_name, align 8
  call void @sdsfree(ptr noundef %13)
  %14 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %14, ptr noundef @.str.165)
  %15 = load ptr, ptr %c.addr, align 8
  %16 = load ptr, ptr %link.addr, align 8
  %ctime = getelementptr inbounds %struct.clusterLink, ptr %16, i32 0, i32 0
  %17 = load i64, ptr %ctime, align 8
  call void @addReplyLongLong(ptr noundef %15, i64 noundef %17)
  %arraydecay5 = getelementptr inbounds [3 x i8], ptr %events, i64 0, i64 0
  store ptr %arraydecay5, ptr %p, align 8
  %18 = load ptr, ptr %link.addr, align 8
  %conn = getelementptr inbounds %struct.clusterLink, ptr %18, i32 0, i32 1
  %19 = load ptr, ptr %conn, align 8
  %tobool6 = icmp ne ptr %19, null
  br i1 %tobool6, label %if.then, label %if.end17

if.then:                                          ; preds = %cond.end
  %20 = load ptr, ptr %link.addr, align 8
  %conn7 = getelementptr inbounds %struct.clusterLink, ptr %20, i32 0, i32 1
  %21 = load ptr, ptr %conn7, align 8
  %call8 = call i32 @connHasReadHandler(ptr noundef %21)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  %22 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %22, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  store i8 114, ptr %22, align 1
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %23 = load ptr, ptr %link.addr, align 8
  %conn11 = getelementptr inbounds %struct.clusterLink, ptr %23, i32 0, i32 1
  %24 = load ptr, ptr %conn11, align 8
  %call12 = call i32 @connHasWriteHandler(ptr noundef %24)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end
  %25 = load ptr, ptr %p, align 8
  %incdec.ptr15 = getelementptr inbounds i8, ptr %25, i32 1
  store ptr %incdec.ptr15, ptr %p, align 8
  store i8 119, ptr %25, align 1
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %cond.end
  %26 = load ptr, ptr %p, align 8
  store i8 0, ptr %26, align 1
  %27 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %27, ptr noundef @.str.166)
  %28 = load ptr, ptr %c.addr, align 8
  %arraydecay18 = getelementptr inbounds [3 x i8], ptr %events, i64 0, i64 0
  call void @addReplyBulkCString(ptr noundef %28, ptr noundef %arraydecay18)
  %29 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %29, ptr noundef @.str.167)
  %30 = load ptr, ptr %c.addr, align 8
  %31 = load ptr, ptr %link.addr, align 8
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %31, i32 0, i32 4
  %32 = load i64, ptr %send_msg_queue_mem, align 8
  call void @addReplyLongLong(ptr noundef %30, i64 noundef %32)
  %33 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %33, ptr noundef @.str.168)
  %34 = load ptr, ptr %c.addr, align 8
  %35 = load ptr, ptr %link.addr, align 8
  %send_msg_queue_mem19 = getelementptr inbounds %struct.clusterLink, ptr %35, i32 0, i32 4
  %36 = load i64, ptr %send_msg_queue_mem19, align 8
  call void @addReplyLongLong(ptr noundef %34, i64 noundef %36)
  ret void
}

declare void @addReplyMapLen(ptr noundef, i64 noundef) #1

declare void @addReplyBulkCString(ptr noundef, ptr noundef) #1

declare void @addReplyLongLong(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @connHasReadHandler(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %read_handler = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 10
  %1 = load ptr, ptr %read_handler, align 8
  %cmp = icmp ne ptr %1, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @connHasWriteHandler(ptr noundef %conn) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %write_handler = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 9
  %1 = load ptr, ptr %write_handler, align 8
  %cmp = icmp ne ptr %1, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyClusterLinksDescription(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %arraylen_ptr = alloca ptr, align 8
  %num_links = alloca i32, align 4
  %node = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr null, ptr %arraylen_ptr, align 8
  store i32 0, ptr %num_links, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %call = call ptr @addReplyDeferredLen(ptr noundef %0)
  store ptr %call, ptr %arraylen_ptr, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %nodes, align 8
  %call1 = call ptr @dictGetSafeIterator(ptr noundef %2)
  store ptr %call1, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %entry
  %3 = load ptr, ptr %di, align 8
  %call2 = call ptr @dictNext(ptr noundef %3)
  store ptr %call2, ptr %de, align 8
  %cmp = icmp ne ptr %call2, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %de, align 8
  %call3 = call ptr @dictGetVal(ptr noundef %4)
  store ptr %call3, ptr %node, align 8
  %5 = load ptr, ptr %node, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 27
  %6 = load ptr, ptr %link, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %7 = load i32, ptr %num_links, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %num_links, align 4
  %8 = load ptr, ptr %c.addr, align 8
  %9 = load ptr, ptr %node, align 8
  %link4 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 27
  %10 = load ptr, ptr %link4, align 8
  call void @addReplyClusterLinkDescription(ptr noundef %8, ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %11 = load ptr, ptr %node, align 8
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 28
  %12 = load ptr, ptr %inbound_link, align 8
  %tobool5 = icmp ne ptr %12, null
  br i1 %tobool5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %13 = load i32, ptr %num_links, align 4
  %inc7 = add nsw i32 %13, 1
  store i32 %inc7, ptr %num_links, align 4
  %14 = load ptr, ptr %c.addr, align 8
  %15 = load ptr, ptr %node, align 8
  %inbound_link8 = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 28
  %16 = load ptr, ptr %inbound_link8, align 8
  call void @addReplyClusterLinkDescription(ptr noundef %14, ptr noundef %16)
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %if.end
  br label %while.cond, !llvm.loop !71

while.end:                                        ; preds = %while.cond
  %17 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %17)
  %18 = load ptr, ptr %c.addr, align 8
  %19 = load ptr, ptr %arraylen_ptr, align 8
  %20 = load i32, ptr %num_links, align 4
  %conv = sext i32 %20 to i64
  call void @setDeferredArrayLen(ptr noundef %18, ptr noundef %19, i64 noundef %conv)
  ret void
}

declare ptr @addReplyDeferredLen(ptr noundef) #1

declare void @setDeferredArrayLen(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @getSlotOrReply(ptr noundef %c, ptr noundef %o) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %o.addr = alloca ptr, align 8
  %slot = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %o, ptr %o.addr, align 8
  %0 = load ptr, ptr %o.addr, align 8
  %call = call i32 @getLongLongFromObject(ptr noundef %0, ptr noundef %slot)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %slot, align 8
  %cmp1 = icmp slt i64 %1, 0
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i64, ptr %slot, align 8
  %cmp3 = icmp sge i64 %2, 16384
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %3 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %3, ptr noundef @.str.180)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %4 = load i64, ptr %slot, align 8
  %conv = trunc i64 %4 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

declare i32 @getLongLongFromObject(ptr noundef, ptr noundef) #1

declare void @addReplyError(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @checkSlotAssignmentsOrReply(ptr noundef %c, ptr noundef %slots, i32 noundef %del, i32 noundef %start_slot, i32 noundef %end_slot) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %slots.addr = alloca ptr, align 8
  %del.addr = alloca i32, align 4
  %start_slot.addr = alloca i32, align 4
  %end_slot.addr = alloca i32, align 4
  %slot = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %slots, ptr %slots.addr, align 8
  store i32 %del, ptr %del.addr, align 4
  store i32 %start_slot, ptr %start_slot.addr, align 4
  store i32 %end_slot, ptr %end_slot.addr, align 4
  %0 = load i32, ptr %start_slot.addr, align 4
  store i32 %0, ptr %slot, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %slot, align 4
  %2 = load i32, ptr %end_slot.addr, align 4
  %cmp = icmp sle i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, ptr %del.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots1 = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 9
  %5 = load i32, ptr %slot, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %slots1, i64 0, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %cmp2 = icmp eq ptr %6, null
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %7 = load ptr, ptr %c.addr, align 8
  %8 = load i32, ptr %slot, align 4
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %7, ptr noundef @.str.181, i32 noundef %8)
  store i32 -1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %for.body
  %9 = load i32, ptr %del.addr, align 4
  %tobool3 = icmp ne i32 %9, 0
  br i1 %tobool3, label %if.end, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %if.else
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots5 = getelementptr inbounds %struct.clusterState, ptr %10, i32 0, i32 9
  %11 = load i32, ptr %slot, align 4
  %idxprom6 = sext i32 %11 to i64
  %arrayidx7 = getelementptr inbounds [16384 x ptr], ptr %slots5, i64 0, i64 %idxprom6
  %12 = load ptr, ptr %arrayidx7, align 8
  %tobool8 = icmp ne ptr %12, null
  br i1 %tobool8, label %if.then9, label %if.end

if.then9:                                         ; preds = %land.lhs.true4
  %13 = load ptr, ptr %c.addr, align 8
  %14 = load i32, ptr %slot, align 4
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %13, ptr noundef @.str.182, i32 noundef %14)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %if.else
  br label %if.end10

if.end10:                                         ; preds = %if.end
  %15 = load ptr, ptr %slots.addr, align 8
  %16 = load i32, ptr %slot, align 4
  %idxprom11 = sext i32 %16 to i64
  %arrayidx12 = getelementptr inbounds i8, ptr %15, i64 %idxprom11
  %17 = load i8, ptr %arrayidx12, align 1
  %inc = add i8 %17, 1
  store i8 %inc, ptr %arrayidx12, align 1
  %conv = zext i8 %17 to i32
  %cmp13 = icmp eq i32 %conv, 1
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end10
  %18 = load ptr, ptr %c.addr, align 8
  %19 = load i32, ptr %slot, align 4
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %18, ptr noundef @.str.183, i32 noundef %19)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end10
  br label %for.inc

for.inc:                                          ; preds = %if.end16
  %20 = load i32, ptr %slot, align 4
  %inc17 = add nsw i32 %20, 1
  store i32 %inc17, ptr %slot, align 4
  br label %for.cond, !llvm.loop !72

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then15, %if.then9, %if.then
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

declare void @addReplyErrorFormat(ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterUpdateSlots(ptr noundef %c, ptr noundef %slots, i32 noundef %del) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %slots.addr = alloca ptr, align 8
  %del.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %retval = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %slots, ptr %slots.addr, align 8
  store i32 %del, ptr %del.addr, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %0, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %slots.addr, align 8
  %2 = load i32, ptr %j, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds i8, ptr %1, i64 %idxprom
  %3 = load i8, ptr %arrayidx, align 1
  %tobool = icmp ne i8 %3, 0
  br i1 %tobool, label %if.then, label %if.end16

if.then:                                          ; preds = %for.body
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 8
  %5 = load i32, ptr %j, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 %idxprom1
  %6 = load ptr, ptr %arrayidx2, align 8
  %tobool3 = icmp ne ptr %6, null
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from5 = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 8
  %8 = load i32, ptr %j, align 4
  %idxprom6 = sext i32 %8 to i64
  %arrayidx7 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from5, i64 0, i64 %idxprom6
  store ptr null, ptr %arrayidx7, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %9 = load i32, ptr %del.addr, align 4
  %tobool8 = icmp ne i32 %9, 0
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %10 = load i32, ptr %j, align 4
  %call = call i32 @clusterDelSlot(i32 noundef %10)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %11 = load ptr, ptr @myself, align 8
  %12 = load i32, ptr %j, align 4
  %call9 = call i32 @clusterAddSlot(ptr noundef %11, i32 noundef %12)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call, %cond.true ], [ %call9, %cond.false ]
  store i32 %cond, ptr %retval, align 4
  %13 = load i32, ptr %retval, align 4
  %cmp10 = icmp eq i32 %13, 0
  %lnot = xor i1 %cmp10, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool12 = icmp ne i64 %conv, 0
  br i1 %tobool12, label %cond.true13, label %cond.false14

cond.true13:                                      ; preds = %cond.end
  br label %cond.end15

cond.false14:                                     ; preds = %cond.end
  %14 = load ptr, ptr %c.addr, align 8
  call void @_serverAssertWithInfo(ptr noundef %14, ptr noundef null, ptr noundef @.str.184, ptr noundef @.str.18, i32 noundef 5473)
  call void @abort() #13
  unreachable

15:                                               ; No predecessors!
  br label %cond.end15

cond.end15:                                       ; preds = %15, %cond.true13
  br label %if.end16

if.end16:                                         ; preds = %cond.end15, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end16
  %16 = load i32, ptr %j, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !73

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @_serverAssertWithInfo(ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @addNodeDetailsToShardReply(ptr noundef %c, ptr noundef %node) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %reply_count = alloca i32, align 4
  %node_replylen = alloca ptr, align 8
  %node_offset = alloca i64, align 8
  %health_msg = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  store i32 0, ptr %reply_count, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %call = call ptr @addReplyDeferredLen(ptr noundef %0)
  store ptr %call, ptr %node_replylen, align 8
  %1 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %1, ptr noundef @.str.185)
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  call void @addReplyBulkCBuffer(ptr noundef %2, ptr noundef %arraydecay, i64 noundef 40)
  %4 = load i32, ptr %reply_count, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %reply_count, align 4
  %5 = load ptr, ptr %node.addr, align 8
  %tcp_port = getelementptr inbounds %struct._clusterNode, ptr %5, i32 0, i32 24
  %6 = load i32, ptr %tcp_port, align 8
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %7, ptr noundef @.str.186)
  %8 = load ptr, ptr %c.addr, align 8
  %9 = load ptr, ptr %node.addr, align 8
  %tcp_port1 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 24
  %10 = load i32, ptr %tcp_port1, align 8
  %conv = sext i32 %10 to i64
  call void @addReplyLongLong(ptr noundef %8, i64 noundef %conv)
  %11 = load i32, ptr %reply_count, align 4
  %inc2 = add nsw i32 %11, 1
  store i32 %inc2, ptr %reply_count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load ptr, ptr %node.addr, align 8
  %tls_port = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 25
  %13 = load i32, ptr %tls_port, align 4
  %tobool3 = icmp ne i32 %13, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %14 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %14, ptr noundef @.str.3)
  %15 = load ptr, ptr %c.addr, align 8
  %16 = load ptr, ptr %node.addr, align 8
  %tls_port5 = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 25
  %17 = load i32, ptr %tls_port5, align 4
  %conv6 = sext i32 %17 to i64
  call void @addReplyLongLong(ptr noundef %15, i64 noundef %conv6)
  %18 = load i32, ptr %reply_count, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, ptr %reply_count, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %if.end
  %19 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %19, ptr noundef @.str.187)
  %20 = load ptr, ptr %c.addr, align 8
  %21 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 21
  %arraydecay9 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  call void @addReplyBulkCString(ptr noundef %20, ptr noundef %arraydecay9)
  %22 = load i32, ptr %reply_count, align 4
  %inc10 = add nsw i32 %22, 1
  store i32 %inc10, ptr %reply_count, align 4
  %23 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %23, ptr noundef @.str.188)
  %24 = load ptr, ptr %c.addr, align 8
  %25 = load ptr, ptr %node.addr, align 8
  %call11 = call ptr @clusterNodePreferredEndpoint(ptr noundef %25)
  call void @addReplyBulkCString(ptr noundef %24, ptr noundef %call11)
  %26 = load i32, ptr %reply_count, align 4
  %inc12 = add nsw i32 %26, 1
  store i32 %inc12, ptr %reply_count, align 4
  %27 = load ptr, ptr %node.addr, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 22
  %28 = load ptr, ptr %hostname, align 8
  %call13 = call i64 @sdslen(ptr noundef %28)
  %cmp = icmp ne i64 %call13, 0
  br i1 %cmp, label %if.then15, label %if.end20

if.then15:                                        ; preds = %if.end8
  %29 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %29, ptr noundef @.str.189)
  %30 = load ptr, ptr %c.addr, align 8
  %31 = load ptr, ptr %node.addr, align 8
  %hostname16 = getelementptr inbounds %struct._clusterNode, ptr %31, i32 0, i32 22
  %32 = load ptr, ptr %hostname16, align 8
  %33 = load ptr, ptr %node.addr, align 8
  %hostname17 = getelementptr inbounds %struct._clusterNode, ptr %33, i32 0, i32 22
  %34 = load ptr, ptr %hostname17, align 8
  %call18 = call i64 @sdslen(ptr noundef %34)
  call void @addReplyBulkCBuffer(ptr noundef %30, ptr noundef %32, i64 noundef %call18)
  %35 = load i32, ptr %reply_count, align 4
  %inc19 = add nsw i32 %35, 1
  store i32 %inc19, ptr %reply_count, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then15, %if.end8
  %36 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %36, i32 0, i32 3
  %37 = load i32, ptr %flags, align 8
  %and = and i32 %37, 16
  %tobool21 = icmp ne i32 %and, 0
  br i1 %tobool21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end20
  %38 = load ptr, ptr %node.addr, align 8
  %flags23 = getelementptr inbounds %struct._clusterNode, ptr %38, i32 0, i32 3
  %39 = load i32, ptr %flags23, align 8
  %and24 = and i32 %39, 2
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then22
  %call26 = call i64 @replicationGetSlaveOffset()
  br label %cond.end

cond.false:                                       ; preds = %if.then22
  %40 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call26, %cond.true ], [ %40, %cond.false ]
  store i64 %cond, ptr %node_offset, align 8
  br label %if.end27

if.else:                                          ; preds = %if.end20
  %41 = load ptr, ptr %node.addr, align 8
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %41, i32 0, i32 20
  %42 = load i64, ptr %repl_offset, align 8
  store i64 %42, ptr %node_offset, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.else, %cond.end
  %43 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %43, ptr noundef @.str.190)
  %44 = load ptr, ptr %c.addr, align 8
  %45 = load ptr, ptr %node.addr, align 8
  %flags28 = getelementptr inbounds %struct._clusterNode, ptr %45, i32 0, i32 3
  %46 = load i32, ptr %flags28, align 8
  %and29 = and i32 %46, 2
  %tobool30 = icmp ne i32 %and29, 0
  %cond31 = select i1 %tobool30, ptr @.str.68, ptr @.str.19
  call void @addReplyBulkCString(ptr noundef %44, ptr noundef %cond31)
  %47 = load i32, ptr %reply_count, align 4
  %inc32 = add nsw i32 %47, 1
  store i32 %inc32, ptr %reply_count, align 4
  %48 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %48, ptr noundef @.str.191)
  %49 = load ptr, ptr %c.addr, align 8
  %50 = load i64, ptr %node_offset, align 8
  call void @addReplyLongLong(ptr noundef %49, i64 noundef %50)
  %51 = load i32, ptr %reply_count, align 4
  %inc33 = add nsw i32 %51, 1
  store i32 %inc33, ptr %reply_count, align 4
  %52 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %52, ptr noundef @.str.192)
  store ptr null, ptr %health_msg, align 8
  %53 = load ptr, ptr %node.addr, align 8
  %flags34 = getelementptr inbounds %struct._clusterNode, ptr %53, i32 0, i32 3
  %54 = load i32, ptr %flags34, align 8
  %and35 = and i32 %54, 8
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then37, label %if.else38

if.then37:                                        ; preds = %if.end27
  store ptr @.str.22, ptr %health_msg, align 8
  br label %if.end47

if.else38:                                        ; preds = %if.end27
  %55 = load ptr, ptr %node.addr, align 8
  %flags39 = getelementptr inbounds %struct._clusterNode, ptr %55, i32 0, i32 3
  %56 = load i32, ptr %flags39, align 8
  %and40 = and i32 %56, 2
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %land.lhs.true, label %if.else45

land.lhs.true:                                    ; preds = %if.else38
  %57 = load i64, ptr %node_offset, align 8
  %cmp42 = icmp eq i64 %57, 0
  br i1 %cmp42, label %if.then44, label %if.else45

if.then44:                                        ; preds = %land.lhs.true
  store ptr @.str.193, ptr %health_msg, align 8
  br label %if.end46

if.else45:                                        ; preds = %land.lhs.true, %if.else38
  store ptr @.str.194, ptr %health_msg, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.else45, %if.then44
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then37
  %58 = load ptr, ptr %c.addr, align 8
  %59 = load ptr, ptr %health_msg, align 8
  call void @addReplyBulkCString(ptr noundef %58, ptr noundef %59)
  %60 = load i32, ptr %reply_count, align 4
  %inc48 = add nsw i32 %60, 1
  store i32 %inc48, ptr %reply_count, align 4
  %61 = load ptr, ptr %c.addr, align 8
  %62 = load ptr, ptr %node_replylen, align 8
  %63 = load i32, ptr %reply_count, align 4
  %conv49 = sext i32 %63 to i64
  call void @setDeferredMapLen(ptr noundef %61, ptr noundef %62, i64 noundef %conv49)
  ret void
}

declare void @addReplyBulkCBuffer(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterNodePreferredEndpoint(ptr noundef %n) #0 {
entry:
  %retval = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %hostname = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %call = call ptr @clusterNodeHostname(ptr noundef %0)
  store ptr %call, ptr %hostname, align 8
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 376), align 8
  switch i32 %1, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb2
    i32 2, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %n.addr, align 8
  %call1 = call ptr @clusterNodeIp(ptr noundef %2)
  store ptr %call1, ptr %retval, align 8
  br label %return

sw.bb2:                                           ; preds = %entry
  %3 = load ptr, ptr %hostname, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %sw.bb2
  %4 = load ptr, ptr %hostname, align 8
  %arrayidx = getelementptr inbounds i8, ptr %4, i64 0
  %5 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %5 to i32
  %cmp3 = icmp ne i32 %conv, 0
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %6 = load ptr, ptr %hostname, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %sw.bb2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %6, %cond.true ], [ @.str.303, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  store ptr @.str.304, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store ptr @.str.179, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb5, %cond.end, %sw.bb
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

declare void @setDeferredMapLen(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @addShardReplyForClusterShards(ptr noundef %c, ptr noundef %nodes) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %nodes.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %i = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n30 = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %nodes, ptr %nodes.addr, align 8
  %0 = load ptr, ptr %nodes.addr, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp ugt i64 %1, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.195, ptr noundef @.str.18, i32 noundef 5544)
  call void @abort() #13
  unreachable

2:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %2, %cond.true
  %3 = load ptr, ptr %nodes.addr, align 8
  %head = getelementptr inbounds %struct.list, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %head, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %value, align 8
  store ptr %5, ptr %n, align 8
  %6 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %6, i64 noundef 2)
  %7 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %7, ptr noundef @.str.196)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %cond.end
  %8 = load ptr, ptr %n, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %8, i32 0, i32 11
  %9 = load ptr, ptr %slaveof, align 8
  %cmp2 = icmp ne ptr %9, null
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load ptr, ptr %n, align 8
  %slaveof4 = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 11
  %11 = load ptr, ptr %slaveof4, align 8
  store ptr %11, ptr %n, align 8
  br label %while.cond, !llvm.loop !74

while.end:                                        ; preds = %while.cond
  %12 = load ptr, ptr %n, align 8
  %slot_info_pairs = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 6
  %13 = load ptr, ptr %slot_info_pairs, align 8
  %cmp5 = icmp ne ptr %13, null
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %while.end
  %14 = load ptr, ptr %n, align 8
  %slot_info_pairs_count = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 7
  %15 = load i32, ptr %slot_info_pairs_count, align 8
  %rem = srem i32 %15, 2
  %cmp7 = icmp eq i32 %rem, 0
  %lnot9 = xor i1 %cmp7, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %tobool14 = icmp ne i64 %conv13, 0
  br i1 %tobool14, label %cond.true15, label %cond.false16

cond.true15:                                      ; preds = %if.then
  br label %cond.end17

cond.false16:                                     ; preds = %if.then
  call void @_serverAssert(ptr noundef @.str.197, ptr noundef @.str.18, i32 noundef 5553)
  call void @abort() #13
  unreachable

16:                                               ; No predecessors!
  br label %cond.end17

cond.end17:                                       ; preds = %16, %cond.true15
  %17 = load ptr, ptr %c.addr, align 8
  %18 = load ptr, ptr %n, align 8
  %slot_info_pairs_count18 = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 7
  %19 = load i32, ptr %slot_info_pairs_count18, align 8
  %conv19 = sext i32 %19 to i64
  call void @addReplyArrayLen(ptr noundef %17, i64 noundef %conv19)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end17
  %20 = load i32, ptr %i, align 4
  %21 = load ptr, ptr %n, align 8
  %slot_info_pairs_count20 = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 7
  %22 = load i32, ptr %slot_info_pairs_count20, align 8
  %cmp21 = icmp slt i32 %20, %22
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load ptr, ptr %c.addr, align 8
  %24 = load ptr, ptr %n, align 8
  %slot_info_pairs23 = getelementptr inbounds %struct._clusterNode, ptr %24, i32 0, i32 6
  %25 = load ptr, ptr %slot_info_pairs23, align 8
  %26 = load i32, ptr %i, align 4
  %idxprom = sext i32 %26 to i64
  %arrayidx = getelementptr inbounds i16, ptr %25, i64 %idxprom
  %27 = load i16, ptr %arrayidx, align 2
  %conv24 = zext i16 %27 to i64
  call void @addReplyLongLong(ptr noundef %23, i64 noundef %conv24)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %28 = load i32, ptr %i, align 4
  %inc = add nsw i32 %28, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !75

for.end:                                          ; preds = %for.cond
  br label %if.end

if.else:                                          ; preds = %while.end
  %29 = load ptr, ptr %c.addr, align 8
  call void @addReplyArrayLen(ptr noundef %29, i64 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %for.end
  %30 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %30, ptr noundef @.str.198)
  %31 = load ptr, ptr %c.addr, align 8
  %32 = load ptr, ptr %nodes.addr, align 8
  %len25 = getelementptr inbounds %struct.list, ptr %32, i32 0, i32 5
  %33 = load i64, ptr %len25, align 8
  call void @addReplyArrayLen(ptr noundef %31, i64 noundef %33)
  %34 = load ptr, ptr %nodes.addr, align 8
  call void @listRewind(ptr noundef %34, ptr noundef %li)
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  br label %for.cond26

for.cond26:                                       ; preds = %for.inc32, %if.end
  %35 = load ptr, ptr %ln, align 8
  %cmp27 = icmp ne ptr %35, null
  br i1 %cmp27, label %for.body29, label %for.end34

for.body29:                                       ; preds = %for.cond26
  %36 = load ptr, ptr %ln, align 8
  %value31 = getelementptr inbounds %struct.listNode, ptr %36, i32 0, i32 2
  %37 = load ptr, ptr %value31, align 8
  store ptr %37, ptr %n30, align 8
  %38 = load ptr, ptr %c.addr, align 8
  %39 = load ptr, ptr %n30, align 8
  call void @addNodeDetailsToShardReply(ptr noundef %38, ptr noundef %39)
  %40 = load ptr, ptr %n30, align 8
  call void @clusterFreeNodesSlotsInfo(ptr noundef %40)
  br label %for.inc32

for.inc32:                                        ; preds = %for.body29
  %call33 = call ptr @listNext(ptr noundef %li)
  store ptr %call33, ptr %ln, align 8
  br label %for.cond26, !llvm.loop !76

for.end34:                                        ; preds = %for.cond26
  ret void
}

declare void @addReplyArrayLen(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @clusterCommandShards(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 5
  %2 = load ptr, ptr %shards, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %2, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards1 = getelementptr inbounds %struct.clusterState, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %shards1, align 8
  %ht_used2 = getelementptr inbounds %struct.dict, ptr %5, i32 0, i32 2
  %arrayidx3 = getelementptr inbounds [2 x i64], ptr %ht_used2, i64 0, i64 1
  %6 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %3, %6
  call void @addReplyArrayLen(ptr noundef %0, i64 noundef %add)
  call void @clusterGenNodesSlotsInfo(i32 noundef 0)
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %shards4 = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %shards4, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %8)
  store ptr %call, ptr %di, align 8
  %9 = load ptr, ptr %di, align 8
  %call5 = call ptr @dictNext(ptr noundef %9)
  store ptr %call5, ptr %de, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load ptr, ptr %de, align 8
  %cmp = icmp ne ptr %10, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %c.addr, align 8
  %12 = load ptr, ptr %de, align 8
  %call6 = call ptr @dictGetVal(ptr noundef %12)
  call void @addShardReplyForClusterShards(ptr noundef %11, ptr noundef %call6)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load ptr, ptr %di, align 8
  %call7 = call ptr @dictNext(ptr noundef %13)
  store ptr %call7, ptr %de, align 8
  br label %for.cond, !llvm.loop !77

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %14)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genClusterInfoString() #0 {
entry:
  %info = alloca ptr, align 8
  %statestr = alloca [2 x ptr], align 16
  %slots_assigned = alloca i32, align 4
  %slots_ok = alloca i32, align 4
  %slots_pfail = alloca i32, align 4
  %slots_fail = alloca i32, align 4
  %myepoch = alloca i64, align 8
  %j = alloca i32, align 4
  %n = alloca ptr, align 8
  %tot_msg_sent = alloca i64, align 8
  %tot_msg_received = alloca i64, align 8
  %i = alloca i32, align 4
  %i48 = alloca i32, align 4
  %call = call ptr @sdsempty()
  store ptr %call, ptr %info, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %statestr, ptr align 16 @__const.genClusterInfoString.statestr, i64 16, i1 false)
  store i32 0, ptr %slots_assigned, align 4
  store i32 0, ptr %slots_ok, align 4
  store i32 0, ptr %slots_pfail, align 4
  store i32 0, ptr %slots_fail, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %0, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 9
  %2 = load i32, ptr %j, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  store ptr %3, ptr %n, align 8
  %4 = load ptr, ptr %n, align 8
  %cmp1 = icmp eq ptr %4, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %5 = load i32, ptr %slots_assigned, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %slots_assigned, align 4
  %6 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %flags, align 8
  %and = and i32 %7, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %8 = load i32, ptr %slots_fail, align 4
  %inc3 = add nsw i32 %8, 1
  store i32 %inc3, ptr %slots_fail, align 4
  br label %if.end12

if.else:                                          ; preds = %if.end
  %9 = load ptr, ptr %n, align 8
  %flags4 = getelementptr inbounds %struct._clusterNode, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %flags4, align 8
  %and5 = and i32 %10, 4
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.else
  %11 = load i32, ptr %slots_pfail, align 4
  %inc8 = add nsw i32 %11, 1
  store i32 %inc8, ptr %slots_pfail, align 4
  br label %if.end11

if.else9:                                         ; preds = %if.else
  %12 = load i32, ptr %slots_ok, align 4
  %inc10 = add nsw i32 %12, 1
  store i32 %inc10, ptr %slots_ok, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.else9, %if.then7
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.then2
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.then
  %13 = load i32, ptr %j, align 4
  %inc13 = add nsw i32 %13, 1
  store i32 %inc13, ptr %j, align 4
  br label %for.cond, !llvm.loop !78

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr @myself, align 8
  %flags14 = getelementptr inbounds %struct._clusterNode, ptr %14, i32 0, i32 3
  %15 = load i32, ptr %flags14, align 8
  %and15 = and i32 %15, 2
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.end
  %16 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %16, i32 0, i32 11
  %17 = load ptr, ptr %slaveof, align 8
  %tobool17 = icmp ne ptr %17, null
  br i1 %tobool17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %18 = load ptr, ptr @myself, align 8
  %slaveof18 = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 11
  %19 = load ptr, ptr %slaveof18, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %19, i32 0, i32 4
  %20 = load i64, ptr %configEpoch, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.end
  %21 = load ptr, ptr @myself, align 8
  %configEpoch19 = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 4
  %22 = load i64, ptr %configEpoch19, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %20, %cond.true ], [ %22, %cond.false ]
  store i64 %cond, ptr %myepoch, align 8
  %23 = load ptr, ptr %info, align 8
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %24, i32 0, i32 2
  %25 = load i32, ptr %state, align 8
  %idxprom20 = sext i32 %25 to i64
  %arrayidx21 = getelementptr inbounds [2 x ptr], ptr %statestr, i64 0, i64 %idxprom20
  %26 = load ptr, ptr %arrayidx21, align 8
  %27 = load i32, ptr %slots_assigned, align 4
  %28 = load i32, ptr %slots_ok, align 4
  %29 = load i32, ptr %slots_pfail, align 4
  %30 = load i32, ptr %slots_fail, align 4
  %31 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %31, i32 0, i32 4
  %32 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %32, i32 0, i32 2
  %arrayidx22 = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %33 = load i64, ptr %arrayidx22, align 8
  %34 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes23 = getelementptr inbounds %struct.clusterState, ptr %34, i32 0, i32 4
  %35 = load ptr, ptr %nodes23, align 8
  %ht_used24 = getelementptr inbounds %struct.dict, ptr %35, i32 0, i32 2
  %arrayidx25 = getelementptr inbounds [2 x i64], ptr %ht_used24, i64 0, i64 1
  %36 = load i64, ptr %arrayidx25, align 8
  %add = add i64 %33, %36
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %size = getelementptr inbounds %struct.clusterState, ptr %37, i32 0, i32 3
  %38 = load i32, ptr %size, align 4
  %39 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %39, i32 0, i32 1
  %40 = load i64, ptr %currentEpoch, align 8
  %41 = load i64, ptr %myepoch, align 8
  %call26 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %23, ptr noundef @.str.199, ptr noundef %26, i32 noundef %27, i32 noundef %28, i32 noundef %29, i32 noundef %30, i64 noundef %add, i32 noundef %38, i64 noundef %40, i64 noundef %41)
  store ptr %call26, ptr %info, align 8
  store i64 0, ptr %tot_msg_sent, align 8
  store i64 0, ptr %tot_msg_received, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc44, %cond.end
  %42 = load i32, ptr %i, align 4
  %cmp28 = icmp slt i32 %42, 11
  br i1 %cmp28, label %for.body29, label %for.end46

for.body29:                                       ; preds = %for.cond27
  %43 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_sent = getelementptr inbounds %struct.clusterState, ptr %43, i32 0, i32 23
  %44 = load i32, ptr %i, align 4
  %idxprom30 = sext i32 %44 to i64
  %arrayidx31 = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_sent, i64 0, i64 %idxprom30
  %45 = load i64, ptr %arrayidx31, align 8
  %cmp32 = icmp eq i64 %45, 0
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %for.body29
  br label %for.inc44

if.end34:                                         ; preds = %for.body29
  %46 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_sent35 = getelementptr inbounds %struct.clusterState, ptr %46, i32 0, i32 23
  %47 = load i32, ptr %i, align 4
  %idxprom36 = sext i32 %47 to i64
  %arrayidx37 = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_sent35, i64 0, i64 %idxprom36
  %48 = load i64, ptr %arrayidx37, align 8
  %49 = load i64, ptr %tot_msg_sent, align 8
  %add38 = add nsw i64 %49, %48
  store i64 %add38, ptr %tot_msg_sent, align 8
  %50 = load ptr, ptr %info, align 8
  %51 = load i32, ptr %i, align 4
  %call39 = call ptr @clusterGetMessageTypeString(i32 noundef %51)
  %52 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_sent40 = getelementptr inbounds %struct.clusterState, ptr %52, i32 0, i32 23
  %53 = load i32, ptr %i, align 4
  %idxprom41 = sext i32 %53 to i64
  %arrayidx42 = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_sent40, i64 0, i64 %idxprom41
  %54 = load i64, ptr %arrayidx42, align 8
  %call43 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %50, ptr noundef @.str.200, ptr noundef %call39, i64 noundef %54)
  store ptr %call43, ptr %info, align 8
  br label %for.inc44

for.inc44:                                        ; preds = %if.end34, %if.then33
  %55 = load i32, ptr %i, align 4
  %inc45 = add nsw i32 %55, 1
  store i32 %inc45, ptr %i, align 4
  br label %for.cond27, !llvm.loop !79

for.end46:                                        ; preds = %for.cond27
  %56 = load ptr, ptr %info, align 8
  %57 = load i64, ptr %tot_msg_sent, align 8
  %call47 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %56, ptr noundef @.str.201, i64 noundef %57)
  store ptr %call47, ptr %info, align 8
  store i32 0, ptr %i48, align 4
  br label %for.cond49

for.cond49:                                       ; preds = %for.inc66, %for.end46
  %58 = load i32, ptr %i48, align 4
  %cmp50 = icmp slt i32 %58, 11
  br i1 %cmp50, label %for.body51, label %for.end68

for.body51:                                       ; preds = %for.cond49
  %59 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_received = getelementptr inbounds %struct.clusterState, ptr %59, i32 0, i32 24
  %60 = load i32, ptr %i48, align 4
  %idxprom52 = sext i32 %60 to i64
  %arrayidx53 = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_received, i64 0, i64 %idxprom52
  %61 = load i64, ptr %arrayidx53, align 8
  %cmp54 = icmp eq i64 %61, 0
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %for.body51
  br label %for.inc66

if.end56:                                         ; preds = %for.body51
  %62 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_received57 = getelementptr inbounds %struct.clusterState, ptr %62, i32 0, i32 24
  %63 = load i32, ptr %i48, align 4
  %idxprom58 = sext i32 %63 to i64
  %arrayidx59 = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_received57, i64 0, i64 %idxprom58
  %64 = load i64, ptr %arrayidx59, align 8
  %65 = load i64, ptr %tot_msg_received, align 8
  %add60 = add nsw i64 %65, %64
  store i64 %add60, ptr %tot_msg_received, align 8
  %66 = load ptr, ptr %info, align 8
  %67 = load i32, ptr %i48, align 4
  %call61 = call ptr @clusterGetMessageTypeString(i32 noundef %67)
  %68 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stats_bus_messages_received62 = getelementptr inbounds %struct.clusterState, ptr %68, i32 0, i32 24
  %69 = load i32, ptr %i48, align 4
  %idxprom63 = sext i32 %69 to i64
  %arrayidx64 = getelementptr inbounds [11 x i64], ptr %stats_bus_messages_received62, i64 0, i64 %idxprom63
  %70 = load i64, ptr %arrayidx64, align 8
  %call65 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %66, ptr noundef @.str.202, ptr noundef %call61, i64 noundef %70)
  store ptr %call65, ptr %info, align 8
  br label %for.inc66

for.inc66:                                        ; preds = %if.end56, %if.then55
  %71 = load i32, ptr %i48, align 4
  %inc67 = add nsw i32 %71, 1
  store i32 %inc67, ptr %i48, align 4
  br label %for.cond49, !llvm.loop !80

for.end68:                                        ; preds = %for.cond49
  %72 = load ptr, ptr %info, align 8
  %73 = load i64, ptr %tot_msg_received, align 8
  %call69 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %72, ptr noundef @.str.203, i64 noundef %73)
  store ptr %call69, ptr %info, align 8
  %74 = load ptr, ptr %info, align 8
  %75 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stat_cluster_links_buffer_limit_exceeded = getelementptr inbounds %struct.clusterState, ptr %75, i32 0, i32 26
  %76 = load i64, ptr %stat_cluster_links_buffer_limit_exceeded, align 8
  %call70 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %74, ptr noundef @.str.204, i64 noundef %76)
  store ptr %call70, ptr %info, align 8
  %77 = load ptr, ptr %info, align 8
  ret ptr %77
}

; Function Attrs: nounwind uwtable
define dso_local i32 @countChannelsInSlot(i32 noundef %hashslot) #0 {
entry:
  %hashslot.addr = alloca i32, align 4
  %iter = alloca %struct.raxIterator, align 8
  %j = alloca i32, align 4
  %indexed = alloca [2 x i8], align 1
  store i32 %hashslot, ptr %hashslot.addr, align 4
  store i32 0, ptr %j, align 4
  %0 = load i32, ptr %hashslot.addr, align 4
  %shr = lshr i32 %0, 8
  %and = and i32 %shr, 255
  %conv = trunc i32 %and to i8
  %arrayidx = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 0
  store i8 %conv, ptr %arrayidx, align 1
  %1 = load i32, ptr %hashslot.addr, align 4
  %and1 = and i32 %1, 255
  %conv2 = trunc i32 %and1 to i8
  %arrayidx3 = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 1
  store i8 %conv2, ptr %arrayidx3, align 1
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots_to_channels = getelementptr inbounds %struct.clusterState, ptr %2, i32 0, i32 10
  %3 = load ptr, ptr %slots_to_channels, align 8
  call void @raxStart(ptr noundef %iter, ptr noundef %3)
  %arraydecay = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 0
  %call = call i32 @raxSeek(ptr noundef %iter, ptr noundef @.str.205, ptr noundef %arraydecay, i64 noundef 2)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call4 = call i32 @raxNext(ptr noundef %iter)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %key = getelementptr inbounds %struct.raxIterator, ptr %iter, i32 0, i32 2
  %4 = load ptr, ptr %key, align 8
  %arrayidx5 = getelementptr inbounds i8, ptr %4, i64 0
  %5 = load i8, ptr %arrayidx5, align 1
  %conv6 = zext i8 %5 to i32
  %arrayidx7 = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 0
  %6 = load i8, ptr %arrayidx7, align 1
  %conv8 = zext i8 %6 to i32
  %cmp = icmp ne i32 %conv6, %conv8
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %key10 = getelementptr inbounds %struct.raxIterator, ptr %iter, i32 0, i32 2
  %7 = load ptr, ptr %key10, align 8
  %arrayidx11 = getelementptr inbounds i8, ptr %7, i64 1
  %8 = load i8, ptr %arrayidx11, align 1
  %conv12 = zext i8 %8 to i32
  %arrayidx13 = getelementptr inbounds [2 x i8], ptr %indexed, i64 0, i64 1
  %9 = load i8, ptr %arrayidx13, align 1
  %conv14 = zext i8 %9 to i32
  %cmp15 = icmp ne i32 %conv12, %conv14
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %while.body
  br label %while.end

if.end:                                           ; preds = %lor.lhs.false
  %10 = load i32, ptr %j, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %j, align 4
  br label %while.cond, !llvm.loop !81

while.end:                                        ; preds = %if.then, %while.cond
  call void @raxStop(ptr noundef %iter)
  %11 = load i32, ptr %j, align 4
  ret i32 %11
}

declare void @raxStart(ptr noundef, ptr noundef) #1

declare i32 @raxSeek(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #1

declare i32 @raxNext(ptr noundef) #1

declare void @raxStop(ptr noundef) #1

declare void @pubsubUnsubscribeShardChannels(ptr noundef, i32 noundef) #1

declare void @enterExecutionUnit(i32 noundef, i64 noundef) #1

declare i32 @dbDelete(ptr noundef, ptr noundef) #1

declare void @propagateDeletion(ptr noundef, ptr noundef, i32 noundef) #1

declare void @signalModifiedKey(ptr noundef, ptr noundef, ptr noundef) #1

declare void @moduleNotifyKeyspaceEvent(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #1

declare void @exitExecutionUnit() #1

declare void @postExecutionUnitOperations() #1

; Function Attrs: nounwind uwtable
define dso_local void @slotToChannelUpdate(ptr noundef %channel, i32 noundef %add) #0 {
entry:
  %channel.addr = alloca ptr, align 8
  %add.addr = alloca i32, align 4
  %keylen = alloca i64, align 8
  %hashslot = alloca i32, align 4
  %buf = alloca [64 x i8], align 16
  %indexed = alloca ptr, align 8
  store ptr %channel, ptr %channel.addr, align 8
  store i32 %add, ptr %add.addr, align 4
  %0 = load ptr, ptr %channel.addr, align 8
  %call = call i64 @sdslen(ptr noundef %0)
  store i64 %call, ptr %keylen, align 8
  %1 = load ptr, ptr %channel.addr, align 8
  %2 = load i64, ptr %keylen, align 8
  %conv = trunc i64 %2 to i32
  %call1 = call i32 @keyHashSlot(ptr noundef %1, i32 noundef %conv)
  store i32 %call1, ptr %hashslot, align 4
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  store ptr %arraydecay, ptr %indexed, align 8
  %3 = load i64, ptr %keylen, align 8
  %add2 = add i64 %3, 2
  %cmp = icmp ugt i64 %add2, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i64, ptr %keylen, align 8
  %add4 = add i64 %4, 2
  %call5 = call noalias ptr @zmalloc(i64 noundef %add4) #16
  store ptr %call5, ptr %indexed, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %hashslot, align 4
  %shr = lshr i32 %5, 8
  %and = and i32 %shr, 255
  %conv6 = trunc i32 %and to i8
  %6 = load ptr, ptr %indexed, align 8
  %arrayidx = getelementptr inbounds i8, ptr %6, i64 0
  store i8 %conv6, ptr %arrayidx, align 1
  %7 = load i32, ptr %hashslot, align 4
  %and7 = and i32 %7, 255
  %conv8 = trunc i32 %and7 to i8
  %8 = load ptr, ptr %indexed, align 8
  %arrayidx9 = getelementptr inbounds i8, ptr %8, i64 1
  store i8 %conv8, ptr %arrayidx9, align 1
  %9 = load ptr, ptr %indexed, align 8
  %add.ptr = getelementptr inbounds i8, ptr %9, i64 2
  %10 = load ptr, ptr %channel.addr, align 8
  %11 = load i64, ptr %keylen, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr, ptr align 1 %10, i64 %11, i1 false)
  %12 = load i32, ptr %add.addr, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots_to_channels = getelementptr inbounds %struct.clusterState, ptr %13, i32 0, i32 10
  %14 = load ptr, ptr %slots_to_channels, align 8
  %15 = load ptr, ptr %indexed, align 8
  %16 = load i64, ptr %keylen, align 8
  %add11 = add i64 %16, 2
  %call12 = call i32 @raxInsert(ptr noundef %14, ptr noundef %15, i64 noundef %add11, ptr noundef null, ptr noundef null)
  br label %if.end16

if.else:                                          ; preds = %if.end
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots_to_channels13 = getelementptr inbounds %struct.clusterState, ptr %17, i32 0, i32 10
  %18 = load ptr, ptr %slots_to_channels13, align 8
  %19 = load ptr, ptr %indexed, align 8
  %20 = load i64, ptr %keylen, align 8
  %add14 = add i64 %20, 2
  %call15 = call i32 @raxRemove(ptr noundef %18, ptr noundef %19, i64 noundef %add14, ptr noundef null)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then10
  %21 = load ptr, ptr %indexed, align 8
  %arraydecay17 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %cmp18 = icmp ne ptr %21, %arraydecay17
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end16
  %22 = load ptr, ptr %indexed, align 8
  call void @zfree(ptr noundef %22)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.end16
  ret void
}

declare i32 @keyHashSlot(ptr noundef, i32 noundef) #1

declare i32 @raxInsert(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef) #1

declare i32 @raxRemove(ptr noundef, ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @slotToChannelAdd(ptr noundef %channel) #0 {
entry:
  %channel.addr = alloca ptr, align 8
  store ptr %channel, ptr %channel.addr, align 8
  %0 = load ptr, ptr %channel.addr, align 8
  call void @slotToChannelUpdate(ptr noundef %0, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @slotToChannelDel(ptr noundef %channel) #0 {
entry:
  %channel.addr = alloca ptr, align 8
  store ptr %channel, ptr %channel.addr, align 8
  %0 = load ptr, ptr %channel.addr, align 8
  call void @slotToChannelUpdate(ptr noundef %0, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeIsMyself(ptr noundef %n) #0 {
entry:
  %n.addr = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself = getelementptr inbounds %struct.clusterState, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %myself, align 8
  %cmp = icmp eq ptr %0, %2
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local ptr @getMyClusterNode() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %myself, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterManualFailoverTimeLimit() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 17
  %1 = load i64, ptr %mf_end, align 8
  %conv = trunc i64 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getClusterSize() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %2 = load i64, ptr %arrayidx, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes1 = getelementptr inbounds %struct.clusterState, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %nodes1, align 8
  %ht_used2 = getelementptr inbounds %struct.dict, ptr %4, i32 0, i32 2
  %arrayidx3 = getelementptr inbounds [2 x i64], ptr %ht_used2, i64 0, i64 1
  %5 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %2, %5
  %conv = trunc i64 %add to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getMyShardSlotCount() #0 {
entry:
  %retval = alloca i32, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %flags, align 8
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself1 = getelementptr inbounds %struct.clusterState, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %myself1, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 8
  %5 = load i32, ptr %numslots, align 4
  store i32 %5, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself2 = getelementptr inbounds %struct.clusterState, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %myself2, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %7, i32 0, i32 11
  %8 = load ptr, ptr %slaveof, align 8
  %tobool3 = icmp ne ptr %8, null
  br i1 %tobool3, label %if.then4, label %if.else8

if.then4:                                         ; preds = %if.else
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %myself5 = getelementptr inbounds %struct.clusterState, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %myself5, align 8
  %slaveof6 = getelementptr inbounds %struct._clusterNode, ptr %10, i32 0, i32 11
  %11 = load ptr, ptr %slaveof6, align 8
  %numslots7 = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 8
  %12 = load i32, ptr %numslots7, align 4
  store i32 %12, ptr %retval, align 4
  br label %return

if.else8:                                         ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else8, %if.then4, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define dso_local ptr @getClusterNodesList(ptr noundef %numnodes) #0 {
entry:
  %numnodes.addr = alloca ptr, align 8
  %count = alloca i64, align 8
  %ids = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %j = alloca i32, align 4
  %node = alloca ptr, align 8
  store ptr %numnodes, ptr %numnodes.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %2 = load i64, ptr %arrayidx, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes1 = getelementptr inbounds %struct.clusterState, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %nodes1, align 8
  %ht_used2 = getelementptr inbounds %struct.dict, ptr %4, i32 0, i32 2
  %arrayidx3 = getelementptr inbounds [2 x i64], ptr %ht_used2, i64 0, i64 1
  %5 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %2, %5
  store i64 %add, ptr %count, align 8
  %6 = load i64, ptr %count, align 8
  %add4 = add i64 %6, 1
  %mul = mul i64 %add4, 40
  %call = call noalias ptr @zmalloc(i64 noundef %mul) #16
  store ptr %call, ptr %ids, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes5 = getelementptr inbounds %struct.clusterState, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %nodes5, align 8
  %call6 = call ptr @dictGetIterator(ptr noundef %8)
  store ptr %call6, ptr %di, align 8
  store i32 0, ptr %j, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then, %entry
  %9 = load ptr, ptr %di, align 8
  %call7 = call ptr @dictNext(ptr noundef %9)
  store ptr %call7, ptr %de, align 8
  %cmp = icmp ne ptr %call7, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load ptr, ptr %de, align 8
  %call8 = call ptr @dictGetVal(ptr noundef %10)
  store ptr %call8, ptr %node, align 8
  %11 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %flags, align 8
  %and = and i32 %12, 96
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !82

if.end:                                           ; preds = %while.body
  %call9 = call noalias ptr @zmalloc(i64 noundef 40) #16
  %13 = load ptr, ptr %ids, align 8
  %14 = load i32, ptr %j, align 4
  %idxprom = sext i32 %14 to i64
  %arrayidx10 = getelementptr inbounds ptr, ptr %13, i64 %idxprom
  store ptr %call9, ptr %arrayidx10, align 8
  %15 = load ptr, ptr %ids, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom11 = sext i32 %16 to i64
  %arrayidx12 = getelementptr inbounds ptr, ptr %15, i64 %idxprom11
  %17 = load ptr, ptr %arrayidx12, align 8
  %18 = load ptr, ptr %node, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %18, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %17, ptr align 8 %arraydecay, i64 40, i1 false)
  %19 = load i32, ptr %j, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, ptr %j, align 4
  br label %while.cond, !llvm.loop !82

while.end:                                        ; preds = %while.cond
  %20 = load i32, ptr %j, align 4
  %conv = sext i32 %20 to i64
  %21 = load ptr, ptr %numnodes.addr, align 8
  store i64 %conv, ptr %21, align 8
  %22 = load ptr, ptr %ids, align 8
  %23 = load i32, ptr %j, align 4
  %idxprom13 = sext i32 %23 to i64
  %arrayidx14 = getelementptr inbounds ptr, ptr %22, i64 %idxprom13
  store ptr null, ptr %arrayidx14, align 8
  %24 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %24)
  %25 = load ptr, ptr %ids, align 8
  ret ptr %25
}

; Function Attrs: nounwind uwtable
define dso_local i32 @handleDebugClusterCommand(ptr noundef %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 1
  %2 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call = call i32 @strcasecmp(ptr noundef %3, ptr noundef @.str.207) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load ptr, ptr %c.addr, align 8
  %argv1 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 12
  %5 = load ptr, ptr %argv1, align 8
  %arrayidx2 = getelementptr inbounds ptr, ptr %5, i64 2
  %6 = load ptr, ptr %arrayidx2, align 8
  %ptr3 = getelementptr inbounds %struct.redisObject, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %ptr3, align 8
  %call4 = call i32 @strcasecmp(ptr noundef %7, ptr noundef @.str.208) #12
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %8 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 11
  %9 = load i32, ptr %argc, align 8
  %cmp = icmp ne i32 %9, 5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false6, %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false6
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool7 = icmp ne i32 %10, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  %11 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %11, ptr noundef @.str.209)
  store i32 1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  %12 = load ptr, ptr %c.addr, align 8
  %argv10 = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 12
  %13 = load ptr, ptr %argv10, align 8
  %arrayidx11 = getelementptr inbounds ptr, ptr %13, i64 4
  %14 = load ptr, ptr %arrayidx11, align 8
  %ptr12 = getelementptr inbounds %struct.redisObject, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %ptr12, align 8
  %16 = load ptr, ptr %c.addr, align 8
  %argv13 = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 12
  %17 = load ptr, ptr %argv13, align 8
  %arrayidx14 = getelementptr inbounds ptr, ptr %17, i64 4
  %18 = load ptr, ptr %arrayidx14, align 8
  %ptr15 = getelementptr inbounds %struct.redisObject, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %ptr15, align 8
  %call16 = call i64 @sdslen(ptr noundef %19)
  %conv = trunc i64 %call16 to i32
  %call17 = call ptr @clusterLookupNode(ptr noundef %15, i32 noundef %conv)
  store ptr %call17, ptr %n, align 8
  %20 = load ptr, ptr %n, align 8
  %tobool18 = icmp ne ptr %20, null
  br i1 %tobool18, label %if.end23, label %if.then19

if.then19:                                        ; preds = %if.end9
  %21 = load ptr, ptr %c.addr, align 8
  %22 = load ptr, ptr %c.addr, align 8
  %argv20 = getelementptr inbounds %struct.client, ptr %22, i32 0, i32 12
  %23 = load ptr, ptr %argv20, align 8
  %arrayidx21 = getelementptr inbounds ptr, ptr %23, i64 4
  %24 = load ptr, ptr %arrayidx21, align 8
  %ptr22 = getelementptr inbounds %struct.redisObject, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %ptr22, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %21, ptr noundef @.str.210, ptr noundef %25)
  store i32 1, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.end9
  %26 = load ptr, ptr %c.addr, align 8
  %argv24 = getelementptr inbounds %struct.client, ptr %26, i32 0, i32 12
  %27 = load ptr, ptr %argv24, align 8
  %arrayidx25 = getelementptr inbounds ptr, ptr %27, i64 3
  %28 = load ptr, ptr %arrayidx25, align 8
  %ptr26 = getelementptr inbounds %struct.redisObject, ptr %28, i32 0, i32 2
  %29 = load ptr, ptr %ptr26, align 8
  %call27 = call i32 @strcasecmp(ptr noundef %29, ptr noundef @.str.161) #12
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.else, label %if.then29

if.then29:                                        ; preds = %if.end23
  %30 = load ptr, ptr %n, align 8
  %inbound_link = getelementptr inbounds %struct._clusterNode, ptr %30, i32 0, i32 28
  %31 = load ptr, ptr %inbound_link, align 8
  call void @freeClusterLink(ptr noundef %31)
  br label %if.end51

if.else:                                          ; preds = %if.end23
  %32 = load ptr, ptr %c.addr, align 8
  %argv30 = getelementptr inbounds %struct.client, ptr %32, i32 0, i32 12
  %33 = load ptr, ptr %argv30, align 8
  %arrayidx31 = getelementptr inbounds ptr, ptr %33, i64 3
  %34 = load ptr, ptr %arrayidx31, align 8
  %ptr32 = getelementptr inbounds %struct.redisObject, ptr %34, i32 0, i32 2
  %35 = load ptr, ptr %ptr32, align 8
  %call33 = call i32 @strcasecmp(ptr noundef %35, ptr noundef @.str.162) #12
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.else36, label %if.then35

if.then35:                                        ; preds = %if.else
  %36 = load ptr, ptr %n, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %36, i32 0, i32 27
  %37 = load ptr, ptr %link, align 8
  call void @freeClusterLink(ptr noundef %37)
  br label %if.end50

if.else36:                                        ; preds = %if.else
  %38 = load ptr, ptr %c.addr, align 8
  %argv37 = getelementptr inbounds %struct.client, ptr %38, i32 0, i32 12
  %39 = load ptr, ptr %argv37, align 8
  %arrayidx38 = getelementptr inbounds ptr, ptr %39, i64 3
  %40 = load ptr, ptr %arrayidx38, align 8
  %ptr39 = getelementptr inbounds %struct.redisObject, ptr %40, i32 0, i32 2
  %41 = load ptr, ptr %ptr39, align 8
  %call40 = call i32 @strcasecmp(ptr noundef %41, ptr noundef @.str.211) #12
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.else45, label %if.then42

if.then42:                                        ; preds = %if.else36
  %42 = load ptr, ptr %n, align 8
  %link43 = getelementptr inbounds %struct._clusterNode, ptr %42, i32 0, i32 27
  %43 = load ptr, ptr %link43, align 8
  call void @freeClusterLink(ptr noundef %43)
  %44 = load ptr, ptr %n, align 8
  %inbound_link44 = getelementptr inbounds %struct._clusterNode, ptr %44, i32 0, i32 28
  %45 = load ptr, ptr %inbound_link44, align 8
  call void @freeClusterLink(ptr noundef %45)
  br label %if.end49

if.else45:                                        ; preds = %if.else36
  %46 = load ptr, ptr %c.addr, align 8
  %47 = load ptr, ptr %c.addr, align 8
  %argv46 = getelementptr inbounds %struct.client, ptr %47, i32 0, i32 12
  %48 = load ptr, ptr %argv46, align 8
  %arrayidx47 = getelementptr inbounds ptr, ptr %48, i64 3
  %49 = load ptr, ptr %arrayidx47, align 8
  %ptr48 = getelementptr inbounds %struct.redisObject, ptr %49, i32 0, i32 2
  %50 = load ptr, ptr %ptr48, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %46, ptr noundef @.str.212, ptr noundef %50)
  br label %if.end49

if.end49:                                         ; preds = %if.else45, %if.then42
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then35
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then29
  %51 = load ptr, ptr %c.addr, align 8
  %52 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %51, ptr noundef %52)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end51, %if.then19, %if.then8, %if.then
  %53 = load i32, ptr %retval, align 4
  ret i32 %53
}

declare void @addReply(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodePending(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 96
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterNodeIp(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 21
  %arraydecay = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  ret ptr %arraydecay
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeIsSlave(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterNodeGetSlaveof(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 11
  %1 = load ptr, ptr %slaveof, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterNodeGetName(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  ret ptr %arraydecay
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeTimedOut(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 4
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeIsFailing(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 8
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeIsNoFailover(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 512
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterDebugCommandExtendedHelp() #0 {
entry:
  ret ptr @clusterDebugCommandExtendedHelp.help
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterNodeGetShardId(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %shard_id = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 2
  %arraydecay = getelementptr inbounds [40 x i8], ptr %shard_id, i64 0, i64 0
  ret ptr %arraydecay
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterCommandSpecial(ptr noundef %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %port = alloca i64, align 8
  %cport = alloca i64, align 8
  %j = alloca i32, align 4
  %slot = alloca i32, align 4
  %slots = alloca ptr, align 8
  %del = alloca i32, align 4
  %j134 = alloca i32, align 4
  %startslot = alloca i32, align 4
  %endslot = alloca i32, align 4
  %slots135 = alloca ptr, align 8
  %del137 = alloca i32, align 4
  %slot190 = alloca i32, align 4
  %n = alloca ptr, align 8
  %slot_was_mine = alloca i32, align 4
  %retval419 = alloca i32, align 4
  %reply = alloca ptr, align 8
  %retval436 = alloca i32, align 4
  %n456 = alloca ptr, align 8
  %n505 = alloca ptr, align 8
  %n554 = alloca ptr, align 8
  %force = alloca i32, align 4
  %takeover = alloca i32, align 4
  %epoch = alloca i64, align 8
  %hard = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 1
  %2 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call = call i32 @strcasecmp(ptr noundef %3, ptr noundef @.str.171) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else44, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 11
  %5 = load i32, ptr %argc, align 8
  %cmp = icmp eq i32 %5, 4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %6 = load ptr, ptr %c.addr, align 8
  %argc1 = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 11
  %7 = load i32, ptr %argc1, align 8
  %cmp2 = icmp eq i32 %7, 5
  br i1 %cmp2, label %if.then, label %if.else44

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %8 = load ptr, ptr %c.addr, align 8
  %argv3 = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 12
  %9 = load ptr, ptr %argv3, align 8
  %arrayidx4 = getelementptr inbounds ptr, ptr %9, i64 3
  %10 = load ptr, ptr %arrayidx4, align 8
  %call5 = call i32 @getLongLongFromObject(ptr noundef %10, ptr noundef %port)
  %cmp6 = icmp ne i32 %call5, 0
  br i1 %cmp6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  %11 = load ptr, ptr %c.addr, align 8
  %12 = load ptr, ptr %c.addr, align 8
  %argv8 = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 12
  %13 = load ptr, ptr %argv8, align 8
  %arrayidx9 = getelementptr inbounds ptr, ptr %13, i64 3
  %14 = load ptr, ptr %arrayidx9, align 8
  %ptr10 = getelementptr inbounds %struct.redisObject, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %ptr10, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %11, ptr noundef @.str.215, ptr noundef %15)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %16 = load ptr, ptr %c.addr, align 8
  %argc11 = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 11
  %17 = load i32, ptr %argc11, align 8
  %cmp12 = icmp eq i32 %17, 5
  br i1 %cmp12, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end
  %18 = load ptr, ptr %c.addr, align 8
  %argv14 = getelementptr inbounds %struct.client, ptr %18, i32 0, i32 12
  %19 = load ptr, ptr %argv14, align 8
  %arrayidx15 = getelementptr inbounds ptr, ptr %19, i64 4
  %20 = load ptr, ptr %arrayidx15, align 8
  %call16 = call i32 @getLongLongFromObject(ptr noundef %20, ptr noundef %cport)
  %cmp17 = icmp ne i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %if.then13
  %21 = load ptr, ptr %c.addr, align 8
  %22 = load ptr, ptr %c.addr, align 8
  %argv19 = getelementptr inbounds %struct.client, ptr %22, i32 0, i32 12
  %23 = load ptr, ptr %argv19, align 8
  %arrayidx20 = getelementptr inbounds ptr, ptr %23, i64 4
  %24 = load ptr, ptr %arrayidx20, align 8
  %ptr21 = getelementptr inbounds %struct.redisObject, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %ptr21, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %21, ptr noundef @.str.216, ptr noundef %25)
  store i32 1, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.then13
  br label %if.end23

if.else:                                          ; preds = %if.end
  %26 = load i64, ptr %port, align 8
  %add = add nsw i64 %26, 10000
  store i64 %add, ptr %cport, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.end22
  %27 = load ptr, ptr %c.addr, align 8
  %argv24 = getelementptr inbounds %struct.client, ptr %27, i32 0, i32 12
  %28 = load ptr, ptr %argv24, align 8
  %arrayidx25 = getelementptr inbounds ptr, ptr %28, i64 2
  %29 = load ptr, ptr %arrayidx25, align 8
  %ptr26 = getelementptr inbounds %struct.redisObject, ptr %29, i32 0, i32 2
  %30 = load ptr, ptr %ptr26, align 8
  %31 = load i64, ptr %port, align 8
  %conv = trunc i64 %31 to i32
  %32 = load i64, ptr %cport, align 8
  %conv27 = trunc i64 %32 to i32
  %call28 = call i32 @clusterStartHandshake(ptr noundef %30, i32 noundef %conv, i32 noundef %conv27)
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %land.lhs.true31, label %if.else42

land.lhs.true31:                                  ; preds = %if.end23
  %call32 = call ptr @__errno_location() #14
  %33 = load i32, ptr %call32, align 4
  %cmp33 = icmp eq i32 %33, 22
  br i1 %cmp33, label %if.then35, label %if.else42

if.then35:                                        ; preds = %land.lhs.true31
  %34 = load ptr, ptr %c.addr, align 8
  %35 = load ptr, ptr %c.addr, align 8
  %argv36 = getelementptr inbounds %struct.client, ptr %35, i32 0, i32 12
  %36 = load ptr, ptr %argv36, align 8
  %arrayidx37 = getelementptr inbounds ptr, ptr %36, i64 2
  %37 = load ptr, ptr %arrayidx37, align 8
  %ptr38 = getelementptr inbounds %struct.redisObject, ptr %37, i32 0, i32 2
  %38 = load ptr, ptr %ptr38, align 8
  %39 = load ptr, ptr %c.addr, align 8
  %argv39 = getelementptr inbounds %struct.client, ptr %39, i32 0, i32 12
  %40 = load ptr, ptr %argv39, align 8
  %arrayidx40 = getelementptr inbounds ptr, ptr %40, i64 3
  %41 = load ptr, ptr %arrayidx40, align 8
  %ptr41 = getelementptr inbounds %struct.redisObject, ptr %41, i32 0, i32 2
  %42 = load ptr, ptr %ptr41, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %34, ptr noundef @.str.217, ptr noundef %38, ptr noundef %42)
  br label %if.end43

if.else42:                                        ; preds = %land.lhs.true31, %if.end23
  %43 = load ptr, ptr %c.addr, align 8
  %44 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %43, ptr noundef %44)
  br label %if.end43

if.end43:                                         ; preds = %if.else42, %if.then35
  br label %if.end783

if.else44:                                        ; preds = %lor.lhs.false, %entry
  %45 = load ptr, ptr %c.addr, align 8
  %argv45 = getelementptr inbounds %struct.client, ptr %45, i32 0, i32 12
  %46 = load ptr, ptr %argv45, align 8
  %arrayidx46 = getelementptr inbounds ptr, ptr %46, i64 1
  %47 = load ptr, ptr %arrayidx46, align 8
  %ptr47 = getelementptr inbounds %struct.redisObject, ptr %47, i32 0, i32 2
  %48 = load ptr, ptr %ptr47, align 8
  %call48 = call i32 @strcasecmp(ptr noundef %48, ptr noundef @.str.218) #12
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.else62, label %land.lhs.true50

land.lhs.true50:                                  ; preds = %if.else44
  %49 = load ptr, ptr %c.addr, align 8
  %argc51 = getelementptr inbounds %struct.client, ptr %49, i32 0, i32 11
  %50 = load i32, ptr %argc51, align 8
  %cmp52 = icmp eq i32 %50, 2
  br i1 %cmp52, label %if.then54, label %if.else62

if.then54:                                        ; preds = %land.lhs.true50
  %51 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %arrayidx55 = getelementptr inbounds %struct.redisDb, ptr %51, i64 0
  %call56 = call i64 @dbSize(ptr noundef %arrayidx55, i32 noundef 0)
  %cmp57 = icmp ne i64 %call56, 0
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.then54
  %52 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %52, ptr noundef @.str.219)
  store i32 1, ptr %retval, align 4
  br label %return

if.end60:                                         ; preds = %if.then54
  %53 = load ptr, ptr @myself, align 8
  %call61 = call i32 @clusterDelNodeSlots(ptr noundef %53)
  call void @clusterDoBeforeSleep(i32 noundef 6)
  %54 = load ptr, ptr %c.addr, align 8
  %55 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %54, ptr noundef %55)
  br label %if.end782

if.else62:                                        ; preds = %land.lhs.true50, %if.else44
  %56 = load ptr, ptr %c.addr, align 8
  %argv63 = getelementptr inbounds %struct.client, ptr %56, i32 0, i32 12
  %57 = load ptr, ptr %argv63, align 8
  %arrayidx64 = getelementptr inbounds ptr, ptr %57, i64 1
  %58 = load ptr, ptr %arrayidx64, align 8
  %ptr65 = getelementptr inbounds %struct.redisObject, ptr %58, i32 0, i32 2
  %59 = load ptr, ptr %ptr65, align 8
  %call66 = call i32 @strcasecmp(ptr noundef %59, ptr noundef @.str.220) #12
  %tobool67 = icmp ne i32 %call66, 0
  br i1 %tobool67, label %lor.lhs.false68, label %land.lhs.true74

lor.lhs.false68:                                  ; preds = %if.else62
  %60 = load ptr, ptr %c.addr, align 8
  %argv69 = getelementptr inbounds %struct.client, ptr %60, i32 0, i32 12
  %61 = load ptr, ptr %argv69, align 8
  %arrayidx70 = getelementptr inbounds ptr, ptr %61, i64 1
  %62 = load ptr, ptr %arrayidx70, align 8
  %ptr71 = getelementptr inbounds %struct.redisObject, ptr %62, i32 0, i32 2
  %63 = load ptr, ptr %ptr71, align 8
  %call72 = call i32 @strcasecmp(ptr noundef %63, ptr noundef @.str.221) #12
  %tobool73 = icmp ne i32 %call72, 0
  br i1 %tobool73, label %if.else112, label %land.lhs.true74

land.lhs.true74:                                  ; preds = %lor.lhs.false68, %if.else62
  %64 = load ptr, ptr %c.addr, align 8
  %argc75 = getelementptr inbounds %struct.client, ptr %64, i32 0, i32 11
  %65 = load i32, ptr %argc75, align 8
  %cmp76 = icmp sge i32 %65, 3
  br i1 %cmp76, label %if.then78, label %if.else112

if.then78:                                        ; preds = %land.lhs.true74
  %call79 = call noalias ptr @zmalloc(i64 noundef 16384) #16
  store ptr %call79, ptr %slots, align 8
  %66 = load ptr, ptr %c.addr, align 8
  %argv80 = getelementptr inbounds %struct.client, ptr %66, i32 0, i32 12
  %67 = load ptr, ptr %argv80, align 8
  %arrayidx81 = getelementptr inbounds ptr, ptr %67, i64 1
  %68 = load ptr, ptr %arrayidx81, align 8
  %ptr82 = getelementptr inbounds %struct.redisObject, ptr %68, i32 0, i32 2
  %69 = load ptr, ptr %ptr82, align 8
  %call83 = call i32 @strcasecmp(ptr noundef %69, ptr noundef @.str.221) #12
  %tobool84 = icmp ne i32 %call83, 0
  %lnot = xor i1 %tobool84, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %del, align 4
  %70 = load ptr, ptr %slots, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %70, i8 0, i64 16384, i1 false)
  store i32 2, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then78
  %71 = load i32, ptr %j, align 4
  %72 = load ptr, ptr %c.addr, align 8
  %argc85 = getelementptr inbounds %struct.client, ptr %72, i32 0, i32 11
  %73 = load i32, ptr %argc85, align 8
  %cmp86 = icmp slt i32 %71, %73
  br i1 %cmp86, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %74 = load ptr, ptr %c.addr, align 8
  %75 = load ptr, ptr %c.addr, align 8
  %argv88 = getelementptr inbounds %struct.client, ptr %75, i32 0, i32 12
  %76 = load ptr, ptr %argv88, align 8
  %77 = load i32, ptr %j, align 4
  %idxprom = sext i32 %77 to i64
  %arrayidx89 = getelementptr inbounds ptr, ptr %76, i64 %idxprom
  %78 = load ptr, ptr %arrayidx89, align 8
  %call90 = call i32 @getSlotOrReply(ptr noundef %74, ptr noundef %78)
  store i32 %call90, ptr %slot, align 4
  %cmp91 = icmp eq i32 %call90, -1
  br i1 %cmp91, label %if.then93, label %if.end94

if.then93:                                        ; preds = %for.body
  %79 = load ptr, ptr %slots, align 8
  call void @zfree(ptr noundef %79)
  store i32 1, ptr %retval, align 4
  br label %return

if.end94:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end94
  %80 = load i32, ptr %j, align 4
  %inc = add nsw i32 %80, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !83

for.end:                                          ; preds = %for.cond
  store i32 2, ptr %j, align 4
  br label %for.cond95

for.cond95:                                       ; preds = %for.inc109, %for.end
  %81 = load i32, ptr %j, align 4
  %82 = load ptr, ptr %c.addr, align 8
  %argc96 = getelementptr inbounds %struct.client, ptr %82, i32 0, i32 11
  %83 = load i32, ptr %argc96, align 8
  %cmp97 = icmp slt i32 %81, %83
  br i1 %cmp97, label %for.body99, label %for.end111

for.body99:                                       ; preds = %for.cond95
  %84 = load ptr, ptr %c.addr, align 8
  %85 = load ptr, ptr %c.addr, align 8
  %argv100 = getelementptr inbounds %struct.client, ptr %85, i32 0, i32 12
  %86 = load ptr, ptr %argv100, align 8
  %87 = load i32, ptr %j, align 4
  %idxprom101 = sext i32 %87 to i64
  %arrayidx102 = getelementptr inbounds ptr, ptr %86, i64 %idxprom101
  %88 = load ptr, ptr %arrayidx102, align 8
  %call103 = call i32 @getSlotOrReply(ptr noundef %84, ptr noundef %88)
  store i32 %call103, ptr %slot, align 4
  %89 = load ptr, ptr %c.addr, align 8
  %90 = load ptr, ptr %slots, align 8
  %91 = load i32, ptr %del, align 4
  %92 = load i32, ptr %slot, align 4
  %93 = load i32, ptr %slot, align 4
  %call104 = call i32 @checkSlotAssignmentsOrReply(ptr noundef %89, ptr noundef %90, i32 noundef %91, i32 noundef %92, i32 noundef %93)
  %cmp105 = icmp eq i32 %call104, -1
  br i1 %cmp105, label %if.then107, label %if.end108

if.then107:                                       ; preds = %for.body99
  %94 = load ptr, ptr %slots, align 8
  call void @zfree(ptr noundef %94)
  store i32 1, ptr %retval, align 4
  br label %return

if.end108:                                        ; preds = %for.body99
  br label %for.inc109

for.inc109:                                       ; preds = %if.end108
  %95 = load i32, ptr %j, align 4
  %inc110 = add nsw i32 %95, 1
  store i32 %inc110, ptr %j, align 4
  br label %for.cond95, !llvm.loop !84

for.end111:                                       ; preds = %for.cond95
  %96 = load ptr, ptr %c.addr, align 8
  %97 = load ptr, ptr %slots, align 8
  %98 = load i32, ptr %del, align 4
  call void @clusterUpdateSlots(ptr noundef %96, ptr noundef %97, i32 noundef %98)
  %99 = load ptr, ptr %slots, align 8
  call void @zfree(ptr noundef %99)
  call void @clusterDoBeforeSleep(i32 noundef 6)
  %100 = load ptr, ptr %c.addr, align 8
  %101 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %100, ptr noundef %101)
  br label %if.end781

if.else112:                                       ; preds = %land.lhs.true74, %lor.lhs.false68
  %102 = load ptr, ptr %c.addr, align 8
  %argv113 = getelementptr inbounds %struct.client, ptr %102, i32 0, i32 12
  %103 = load ptr, ptr %argv113, align 8
  %arrayidx114 = getelementptr inbounds ptr, ptr %103, i64 1
  %104 = load ptr, ptr %arrayidx114, align 8
  %ptr115 = getelementptr inbounds %struct.redisObject, ptr %104, i32 0, i32 2
  %105 = load ptr, ptr %ptr115, align 8
  %call116 = call i32 @strcasecmp(ptr noundef %105, ptr noundef @.str.222) #12
  %tobool117 = icmp ne i32 %call116, 0
  br i1 %tobool117, label %lor.lhs.false118, label %land.lhs.true124

lor.lhs.false118:                                 ; preds = %if.else112
  %106 = load ptr, ptr %c.addr, align 8
  %argv119 = getelementptr inbounds %struct.client, ptr %106, i32 0, i32 12
  %107 = load ptr, ptr %argv119, align 8
  %arrayidx120 = getelementptr inbounds ptr, ptr %107, i64 1
  %108 = load ptr, ptr %arrayidx120, align 8
  %ptr121 = getelementptr inbounds %struct.redisObject, ptr %108, i32 0, i32 2
  %109 = load ptr, ptr %ptr121, align 8
  %call122 = call i32 @strcasecmp(ptr noundef %109, ptr noundef @.str.223) #12
  %tobool123 = icmp ne i32 %call122, 0
  br i1 %tobool123, label %if.else179, label %land.lhs.true124

land.lhs.true124:                                 ; preds = %lor.lhs.false118, %if.else112
  %110 = load ptr, ptr %c.addr, align 8
  %argc125 = getelementptr inbounds %struct.client, ptr %110, i32 0, i32 11
  %111 = load i32, ptr %argc125, align 8
  %cmp126 = icmp sge i32 %111, 4
  br i1 %cmp126, label %if.then128, label %if.else179

if.then128:                                       ; preds = %land.lhs.true124
  %112 = load ptr, ptr %c.addr, align 8
  %argc129 = getelementptr inbounds %struct.client, ptr %112, i32 0, i32 11
  %113 = load i32, ptr %argc129, align 8
  %rem = srem i32 %113, 2
  %cmp130 = icmp eq i32 %rem, 1
  br i1 %cmp130, label %if.then132, label %if.end133

if.then132:                                       ; preds = %if.then128
  %114 = load ptr, ptr %c.addr, align 8
  call void @addReplyErrorArity(ptr noundef %114)
  store i32 1, ptr %retval, align 4
  br label %return

if.end133:                                        ; preds = %if.then128
  %call136 = call noalias ptr @zmalloc(i64 noundef 16384) #16
  store ptr %call136, ptr %slots135, align 8
  %115 = load ptr, ptr %c.addr, align 8
  %argv138 = getelementptr inbounds %struct.client, ptr %115, i32 0, i32 12
  %116 = load ptr, ptr %argv138, align 8
  %arrayidx139 = getelementptr inbounds ptr, ptr %116, i64 1
  %117 = load ptr, ptr %arrayidx139, align 8
  %ptr140 = getelementptr inbounds %struct.redisObject, ptr %117, i32 0, i32 2
  %118 = load ptr, ptr %ptr140, align 8
  %call141 = call i32 @strcasecmp(ptr noundef %118, ptr noundef @.str.223) #12
  %tobool142 = icmp ne i32 %call141, 0
  %lnot143 = xor i1 %tobool142, true
  %lnot.ext144 = zext i1 %lnot143 to i32
  store i32 %lnot.ext144, ptr %del137, align 4
  %119 = load ptr, ptr %slots135, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %119, i8 0, i64 16384, i1 false)
  store i32 2, ptr %j134, align 4
  br label %for.cond145

for.cond145:                                      ; preds = %for.inc176, %if.end133
  %120 = load i32, ptr %j134, align 4
  %121 = load ptr, ptr %c.addr, align 8
  %argc146 = getelementptr inbounds %struct.client, ptr %121, i32 0, i32 11
  %122 = load i32, ptr %argc146, align 8
  %cmp147 = icmp slt i32 %120, %122
  br i1 %cmp147, label %for.body149, label %for.end178

for.body149:                                      ; preds = %for.cond145
  %123 = load ptr, ptr %c.addr, align 8
  %124 = load ptr, ptr %c.addr, align 8
  %argv150 = getelementptr inbounds %struct.client, ptr %124, i32 0, i32 12
  %125 = load ptr, ptr %argv150, align 8
  %126 = load i32, ptr %j134, align 4
  %idxprom151 = sext i32 %126 to i64
  %arrayidx152 = getelementptr inbounds ptr, ptr %125, i64 %idxprom151
  %127 = load ptr, ptr %arrayidx152, align 8
  %call153 = call i32 @getSlotOrReply(ptr noundef %123, ptr noundef %127)
  store i32 %call153, ptr %startslot, align 4
  %cmp154 = icmp eq i32 %call153, -1
  br i1 %cmp154, label %if.then156, label %if.end157

if.then156:                                       ; preds = %for.body149
  %128 = load ptr, ptr %slots135, align 8
  call void @zfree(ptr noundef %128)
  store i32 1, ptr %retval, align 4
  br label %return

if.end157:                                        ; preds = %for.body149
  %129 = load ptr, ptr %c.addr, align 8
  %130 = load ptr, ptr %c.addr, align 8
  %argv158 = getelementptr inbounds %struct.client, ptr %130, i32 0, i32 12
  %131 = load ptr, ptr %argv158, align 8
  %132 = load i32, ptr %j134, align 4
  %add159 = add nsw i32 %132, 1
  %idxprom160 = sext i32 %add159 to i64
  %arrayidx161 = getelementptr inbounds ptr, ptr %131, i64 %idxprom160
  %133 = load ptr, ptr %arrayidx161, align 8
  %call162 = call i32 @getSlotOrReply(ptr noundef %129, ptr noundef %133)
  store i32 %call162, ptr %endslot, align 4
  %cmp163 = icmp eq i32 %call162, -1
  br i1 %cmp163, label %if.then165, label %if.end166

if.then165:                                       ; preds = %if.end157
  %134 = load ptr, ptr %slots135, align 8
  call void @zfree(ptr noundef %134)
  store i32 1, ptr %retval, align 4
  br label %return

if.end166:                                        ; preds = %if.end157
  %135 = load i32, ptr %startslot, align 4
  %136 = load i32, ptr %endslot, align 4
  %cmp167 = icmp sgt i32 %135, %136
  br i1 %cmp167, label %if.then169, label %if.end170

if.then169:                                       ; preds = %if.end166
  %137 = load ptr, ptr %c.addr, align 8
  %138 = load i32, ptr %startslot, align 4
  %139 = load i32, ptr %endslot, align 4
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %137, ptr noundef @.str.224, i32 noundef %138, i32 noundef %139)
  %140 = load ptr, ptr %slots135, align 8
  call void @zfree(ptr noundef %140)
  store i32 1, ptr %retval, align 4
  br label %return

if.end170:                                        ; preds = %if.end166
  %141 = load ptr, ptr %c.addr, align 8
  %142 = load ptr, ptr %slots135, align 8
  %143 = load i32, ptr %del137, align 4
  %144 = load i32, ptr %startslot, align 4
  %145 = load i32, ptr %endslot, align 4
  %call171 = call i32 @checkSlotAssignmentsOrReply(ptr noundef %141, ptr noundef %142, i32 noundef %143, i32 noundef %144, i32 noundef %145)
  %cmp172 = icmp eq i32 %call171, -1
  br i1 %cmp172, label %if.then174, label %if.end175

if.then174:                                       ; preds = %if.end170
  %146 = load ptr, ptr %slots135, align 8
  call void @zfree(ptr noundef %146)
  store i32 1, ptr %retval, align 4
  br label %return

if.end175:                                        ; preds = %if.end170
  br label %for.inc176

for.inc176:                                       ; preds = %if.end175
  %147 = load i32, ptr %j134, align 4
  %add177 = add nsw i32 %147, 2
  store i32 %add177, ptr %j134, align 4
  br label %for.cond145, !llvm.loop !85

for.end178:                                       ; preds = %for.cond145
  %148 = load ptr, ptr %c.addr, align 8
  %149 = load ptr, ptr %slots135, align 8
  %150 = load i32, ptr %del137, align 4
  call void @clusterUpdateSlots(ptr noundef %148, ptr noundef %149, i32 noundef %150)
  %151 = load ptr, ptr %slots135, align 8
  call void @zfree(ptr noundef %151)
  call void @clusterDoBeforeSleep(i32 noundef 6)
  %152 = load ptr, ptr %c.addr, align 8
  %153 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %152, ptr noundef %153)
  br label %if.end780

if.else179:                                       ; preds = %land.lhs.true124, %lor.lhs.false118
  %154 = load ptr, ptr %c.addr, align 8
  %argv180 = getelementptr inbounds %struct.client, ptr %154, i32 0, i32 12
  %155 = load ptr, ptr %argv180, align 8
  %arrayidx181 = getelementptr inbounds ptr, ptr %155, i64 1
  %156 = load ptr, ptr %arrayidx181, align 8
  %ptr182 = getelementptr inbounds %struct.redisObject, ptr %156, i32 0, i32 2
  %157 = load ptr, ptr %ptr182, align 8
  %call183 = call i32 @strcasecmp(ptr noundef %157, ptr noundef @.str.225) #12
  %tobool184 = icmp ne i32 %call183, 0
  br i1 %tobool184, label %if.else408, label %land.lhs.true185

land.lhs.true185:                                 ; preds = %if.else179
  %158 = load ptr, ptr %c.addr, align 8
  %argc186 = getelementptr inbounds %struct.client, ptr %158, i32 0, i32 11
  %159 = load i32, ptr %argc186, align 8
  %cmp187 = icmp sge i32 %159, 4
  br i1 %cmp187, label %if.then189, label %if.else408

if.then189:                                       ; preds = %land.lhs.true185
  %160 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %160, i32 0, i32 3
  %161 = load i32, ptr %flags, align 8
  %and = and i32 %161, 2
  %tobool191 = icmp ne i32 %and, 0
  br i1 %tobool191, label %if.then192, label %if.end193

if.then192:                                       ; preds = %if.then189
  %162 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %162, ptr noundef @.str.226)
  store i32 1, ptr %retval, align 4
  br label %return

if.end193:                                        ; preds = %if.then189
  %163 = load ptr, ptr %c.addr, align 8
  %164 = load ptr, ptr %c.addr, align 8
  %argv194 = getelementptr inbounds %struct.client, ptr %164, i32 0, i32 12
  %165 = load ptr, ptr %argv194, align 8
  %arrayidx195 = getelementptr inbounds ptr, ptr %165, i64 2
  %166 = load ptr, ptr %arrayidx195, align 8
  %call196 = call i32 @getSlotOrReply(ptr noundef %163, ptr noundef %166)
  store i32 %call196, ptr %slot190, align 4
  %cmp197 = icmp eq i32 %call196, -1
  br i1 %cmp197, label %if.then199, label %if.end200

if.then199:                                       ; preds = %if.end193
  store i32 1, ptr %retval, align 4
  br label %return

if.end200:                                        ; preds = %if.end193
  %167 = load ptr, ptr %c.addr, align 8
  %argv201 = getelementptr inbounds %struct.client, ptr %167, i32 0, i32 12
  %168 = load ptr, ptr %argv201, align 8
  %arrayidx202 = getelementptr inbounds ptr, ptr %168, i64 3
  %169 = load ptr, ptr %arrayidx202, align 8
  %ptr203 = getelementptr inbounds %struct.redisObject, ptr %169, i32 0, i32 2
  %170 = load ptr, ptr %ptr203, align 8
  %call204 = call i32 @strcasecmp(ptr noundef %170, ptr noundef @.str.227) #12
  %tobool205 = icmp ne i32 %call204, 0
  br i1 %tobool205, label %if.else241, label %land.lhs.true206

land.lhs.true206:                                 ; preds = %if.end200
  %171 = load ptr, ptr %c.addr, align 8
  %argc207 = getelementptr inbounds %struct.client, ptr %171, i32 0, i32 11
  %172 = load i32, ptr %argc207, align 8
  %cmp208 = icmp eq i32 %172, 5
  br i1 %cmp208, label %if.then210, label %if.else241

if.then210:                                       ; preds = %land.lhs.true206
  %173 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots211 = getelementptr inbounds %struct.clusterState, ptr %173, i32 0, i32 9
  %174 = load i32, ptr %slot190, align 4
  %idxprom212 = sext i32 %174 to i64
  %arrayidx213 = getelementptr inbounds [16384 x ptr], ptr %slots211, i64 0, i64 %idxprom212
  %175 = load ptr, ptr %arrayidx213, align 8
  %176 = load ptr, ptr @myself, align 8
  %cmp214 = icmp ne ptr %175, %176
  br i1 %cmp214, label %if.then216, label %if.end217

if.then216:                                       ; preds = %if.then210
  %177 = load ptr, ptr %c.addr, align 8
  %178 = load i32, ptr %slot190, align 4
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %177, ptr noundef @.str.228, i32 noundef %178)
  store i32 1, ptr %retval, align 4
  br label %return

if.end217:                                        ; preds = %if.then210
  %179 = load ptr, ptr %c.addr, align 8
  %argv218 = getelementptr inbounds %struct.client, ptr %179, i32 0, i32 12
  %180 = load ptr, ptr %argv218, align 8
  %arrayidx219 = getelementptr inbounds ptr, ptr %180, i64 4
  %181 = load ptr, ptr %arrayidx219, align 8
  %ptr220 = getelementptr inbounds %struct.redisObject, ptr %181, i32 0, i32 2
  %182 = load ptr, ptr %ptr220, align 8
  %183 = load ptr, ptr %c.addr, align 8
  %argv221 = getelementptr inbounds %struct.client, ptr %183, i32 0, i32 12
  %184 = load ptr, ptr %argv221, align 8
  %arrayidx222 = getelementptr inbounds ptr, ptr %184, i64 4
  %185 = load ptr, ptr %arrayidx222, align 8
  %ptr223 = getelementptr inbounds %struct.redisObject, ptr %185, i32 0, i32 2
  %186 = load ptr, ptr %ptr223, align 8
  %call224 = call i64 @sdslen(ptr noundef %186)
  %conv225 = trunc i64 %call224 to i32
  %call226 = call ptr @clusterLookupNode(ptr noundef %182, i32 noundef %conv225)
  store ptr %call226, ptr %n, align 8
  %187 = load ptr, ptr %n, align 8
  %cmp227 = icmp eq ptr %187, null
  br i1 %cmp227, label %if.then229, label %if.end233

if.then229:                                       ; preds = %if.end217
  %188 = load ptr, ptr %c.addr, align 8
  %189 = load ptr, ptr %c.addr, align 8
  %argv230 = getelementptr inbounds %struct.client, ptr %189, i32 0, i32 12
  %190 = load ptr, ptr %argv230, align 8
  %arrayidx231 = getelementptr inbounds ptr, ptr %190, i64 4
  %191 = load ptr, ptr %arrayidx231, align 8
  %ptr232 = getelementptr inbounds %struct.redisObject, ptr %191, i32 0, i32 2
  %192 = load ptr, ptr %ptr232, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %188, ptr noundef @.str.229, ptr noundef %192)
  store i32 1, ptr %retval, align 4
  br label %return

if.end233:                                        ; preds = %if.end217
  %193 = load ptr, ptr %n, align 8
  %flags234 = getelementptr inbounds %struct._clusterNode, ptr %193, i32 0, i32 3
  %194 = load i32, ptr %flags234, align 8
  %and235 = and i32 %194, 2
  %tobool236 = icmp ne i32 %and235, 0
  br i1 %tobool236, label %if.then237, label %if.end238

if.then237:                                       ; preds = %if.end233
  %195 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %195, ptr noundef @.str.230)
  store i32 1, ptr %retval, align 4
  br label %return

if.end238:                                        ; preds = %if.end233
  %196 = load ptr, ptr %n, align 8
  %197 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to = getelementptr inbounds %struct.clusterState, ptr %197, i32 0, i32 7
  %198 = load i32, ptr %slot190, align 4
  %idxprom239 = sext i32 %198 to i64
  %arrayidx240 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to, i64 0, i64 %idxprom239
  store ptr %196, ptr %arrayidx240, align 8
  br label %if.end407

if.else241:                                       ; preds = %land.lhs.true206, %if.end200
  %199 = load ptr, ptr %c.addr, align 8
  %argv242 = getelementptr inbounds %struct.client, ptr %199, i32 0, i32 12
  %200 = load ptr, ptr %argv242, align 8
  %arrayidx243 = getelementptr inbounds ptr, ptr %200, i64 3
  %201 = load ptr, ptr %arrayidx243, align 8
  %ptr244 = getelementptr inbounds %struct.redisObject, ptr %201, i32 0, i32 2
  %202 = load ptr, ptr %ptr244, align 8
  %call245 = call i32 @strcasecmp(ptr noundef %202, ptr noundef @.str.231) #12
  %tobool246 = icmp ne i32 %call245, 0
  br i1 %tobool246, label %if.else282, label %land.lhs.true247

land.lhs.true247:                                 ; preds = %if.else241
  %203 = load ptr, ptr %c.addr, align 8
  %argc248 = getelementptr inbounds %struct.client, ptr %203, i32 0, i32 11
  %204 = load i32, ptr %argc248, align 8
  %cmp249 = icmp eq i32 %204, 5
  br i1 %cmp249, label %if.then251, label %if.else282

if.then251:                                       ; preds = %land.lhs.true247
  %205 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots252 = getelementptr inbounds %struct.clusterState, ptr %205, i32 0, i32 9
  %206 = load i32, ptr %slot190, align 4
  %idxprom253 = sext i32 %206 to i64
  %arrayidx254 = getelementptr inbounds [16384 x ptr], ptr %slots252, i64 0, i64 %idxprom253
  %207 = load ptr, ptr %arrayidx254, align 8
  %208 = load ptr, ptr @myself, align 8
  %cmp255 = icmp eq ptr %207, %208
  br i1 %cmp255, label %if.then257, label %if.end258

if.then257:                                       ; preds = %if.then251
  %209 = load ptr, ptr %c.addr, align 8
  %210 = load i32, ptr %slot190, align 4
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %209, ptr noundef @.str.232, i32 noundef %210)
  store i32 1, ptr %retval, align 4
  br label %return

if.end258:                                        ; preds = %if.then251
  %211 = load ptr, ptr %c.addr, align 8
  %argv259 = getelementptr inbounds %struct.client, ptr %211, i32 0, i32 12
  %212 = load ptr, ptr %argv259, align 8
  %arrayidx260 = getelementptr inbounds ptr, ptr %212, i64 4
  %213 = load ptr, ptr %arrayidx260, align 8
  %ptr261 = getelementptr inbounds %struct.redisObject, ptr %213, i32 0, i32 2
  %214 = load ptr, ptr %ptr261, align 8
  %215 = load ptr, ptr %c.addr, align 8
  %argv262 = getelementptr inbounds %struct.client, ptr %215, i32 0, i32 12
  %216 = load ptr, ptr %argv262, align 8
  %arrayidx263 = getelementptr inbounds ptr, ptr %216, i64 4
  %217 = load ptr, ptr %arrayidx263, align 8
  %ptr264 = getelementptr inbounds %struct.redisObject, ptr %217, i32 0, i32 2
  %218 = load ptr, ptr %ptr264, align 8
  %call265 = call i64 @sdslen(ptr noundef %218)
  %conv266 = trunc i64 %call265 to i32
  %call267 = call ptr @clusterLookupNode(ptr noundef %214, i32 noundef %conv266)
  store ptr %call267, ptr %n, align 8
  %219 = load ptr, ptr %n, align 8
  %cmp268 = icmp eq ptr %219, null
  br i1 %cmp268, label %if.then270, label %if.end274

if.then270:                                       ; preds = %if.end258
  %220 = load ptr, ptr %c.addr, align 8
  %221 = load ptr, ptr %c.addr, align 8
  %argv271 = getelementptr inbounds %struct.client, ptr %221, i32 0, i32 12
  %222 = load ptr, ptr %argv271, align 8
  %arrayidx272 = getelementptr inbounds ptr, ptr %222, i64 4
  %223 = load ptr, ptr %arrayidx272, align 8
  %ptr273 = getelementptr inbounds %struct.redisObject, ptr %223, i32 0, i32 2
  %224 = load ptr, ptr %ptr273, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %220, ptr noundef @.str.229, ptr noundef %224)
  store i32 1, ptr %retval, align 4
  br label %return

if.end274:                                        ; preds = %if.end258
  %225 = load ptr, ptr %n, align 8
  %flags275 = getelementptr inbounds %struct._clusterNode, ptr %225, i32 0, i32 3
  %226 = load i32, ptr %flags275, align 8
  %and276 = and i32 %226, 2
  %tobool277 = icmp ne i32 %and276, 0
  br i1 %tobool277, label %if.then278, label %if.end279

if.then278:                                       ; preds = %if.end274
  %227 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %227, ptr noundef @.str.230)
  store i32 1, ptr %retval, align 4
  br label %return

if.end279:                                        ; preds = %if.end274
  %228 = load ptr, ptr %n, align 8
  %229 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %229, i32 0, i32 8
  %230 = load i32, ptr %slot190, align 4
  %idxprom280 = sext i32 %230 to i64
  %arrayidx281 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 %idxprom280
  store ptr %228, ptr %arrayidx281, align 8
  br label %if.end406

if.else282:                                       ; preds = %land.lhs.true247, %if.else241
  %231 = load ptr, ptr %c.addr, align 8
  %argv283 = getelementptr inbounds %struct.client, ptr %231, i32 0, i32 12
  %232 = load ptr, ptr %argv283, align 8
  %arrayidx284 = getelementptr inbounds ptr, ptr %232, i64 3
  %233 = load ptr, ptr %arrayidx284, align 8
  %ptr285 = getelementptr inbounds %struct.redisObject, ptr %233, i32 0, i32 2
  %234 = load ptr, ptr %ptr285, align 8
  %call286 = call i32 @strcasecmp(ptr noundef %234, ptr noundef @.str.233) #12
  %tobool287 = icmp ne i32 %call286, 0
  br i1 %tobool287, label %if.else299, label %land.lhs.true288

land.lhs.true288:                                 ; preds = %if.else282
  %235 = load ptr, ptr %c.addr, align 8
  %argc289 = getelementptr inbounds %struct.client, ptr %235, i32 0, i32 11
  %236 = load i32, ptr %argc289, align 8
  %cmp290 = icmp eq i32 %236, 4
  br i1 %cmp290, label %if.then292, label %if.else299

if.then292:                                       ; preds = %land.lhs.true288
  %237 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from293 = getelementptr inbounds %struct.clusterState, ptr %237, i32 0, i32 8
  %238 = load i32, ptr %slot190, align 4
  %idxprom294 = sext i32 %238 to i64
  %arrayidx295 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from293, i64 0, i64 %idxprom294
  store ptr null, ptr %arrayidx295, align 8
  %239 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to296 = getelementptr inbounds %struct.clusterState, ptr %239, i32 0, i32 7
  %240 = load i32, ptr %slot190, align 4
  %idxprom297 = sext i32 %240 to i64
  %arrayidx298 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to296, i64 0, i64 %idxprom297
  store ptr null, ptr %arrayidx298, align 8
  br label %if.end405

if.else299:                                       ; preds = %land.lhs.true288, %if.else282
  %241 = load ptr, ptr %c.addr, align 8
  %argv300 = getelementptr inbounds %struct.client, ptr %241, i32 0, i32 12
  %242 = load ptr, ptr %argv300, align 8
  %arrayidx301 = getelementptr inbounds ptr, ptr %242, i64 3
  %243 = load ptr, ptr %arrayidx301, align 8
  %ptr302 = getelementptr inbounds %struct.redisObject, ptr %243, i32 0, i32 2
  %244 = load ptr, ptr %ptr302, align 8
  %call303 = call i32 @strcasecmp(ptr noundef %244, ptr noundef @.str.164) #12
  %tobool304 = icmp ne i32 %call303, 0
  br i1 %tobool304, label %if.else403, label %land.lhs.true305

land.lhs.true305:                                 ; preds = %if.else299
  %245 = load ptr, ptr %c.addr, align 8
  %argc306 = getelementptr inbounds %struct.client, ptr %245, i32 0, i32 11
  %246 = load i32, ptr %argc306, align 8
  %cmp307 = icmp eq i32 %246, 5
  br i1 %cmp307, label %if.then309, label %if.else403

if.then309:                                       ; preds = %land.lhs.true305
  %247 = load ptr, ptr %c.addr, align 8
  %argv310 = getelementptr inbounds %struct.client, ptr %247, i32 0, i32 12
  %248 = load ptr, ptr %argv310, align 8
  %arrayidx311 = getelementptr inbounds ptr, ptr %248, i64 4
  %249 = load ptr, ptr %arrayidx311, align 8
  %ptr312 = getelementptr inbounds %struct.redisObject, ptr %249, i32 0, i32 2
  %250 = load ptr, ptr %ptr312, align 8
  %251 = load ptr, ptr %c.addr, align 8
  %argv313 = getelementptr inbounds %struct.client, ptr %251, i32 0, i32 12
  %252 = load ptr, ptr %argv313, align 8
  %arrayidx314 = getelementptr inbounds ptr, ptr %252, i64 4
  %253 = load ptr, ptr %arrayidx314, align 8
  %ptr315 = getelementptr inbounds %struct.redisObject, ptr %253, i32 0, i32 2
  %254 = load ptr, ptr %ptr315, align 8
  %call316 = call i64 @sdslen(ptr noundef %254)
  %conv317 = trunc i64 %call316 to i32
  %call318 = call ptr @clusterLookupNode(ptr noundef %250, i32 noundef %conv317)
  store ptr %call318, ptr %n, align 8
  %255 = load ptr, ptr %n, align 8
  %tobool319 = icmp ne ptr %255, null
  br i1 %tobool319, label %if.end324, label %if.then320

if.then320:                                       ; preds = %if.then309
  %256 = load ptr, ptr %c.addr, align 8
  %257 = load ptr, ptr %c.addr, align 8
  %argv321 = getelementptr inbounds %struct.client, ptr %257, i32 0, i32 12
  %258 = load ptr, ptr %argv321, align 8
  %arrayidx322 = getelementptr inbounds ptr, ptr %258, i64 4
  %259 = load ptr, ptr %arrayidx322, align 8
  %ptr323 = getelementptr inbounds %struct.redisObject, ptr %259, i32 0, i32 2
  %260 = load ptr, ptr %ptr323, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %256, ptr noundef @.str.210, ptr noundef %260)
  store i32 1, ptr %retval, align 4
  br label %return

if.end324:                                        ; preds = %if.then309
  %261 = load ptr, ptr %n, align 8
  %flags325 = getelementptr inbounds %struct._clusterNode, ptr %261, i32 0, i32 3
  %262 = load i32, ptr %flags325, align 8
  %and326 = and i32 %262, 2
  %tobool327 = icmp ne i32 %and326, 0
  br i1 %tobool327, label %if.then328, label %if.end329

if.then328:                                       ; preds = %if.end324
  %263 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %263, ptr noundef @.str.230)
  store i32 1, ptr %retval, align 4
  br label %return

if.end329:                                        ; preds = %if.end324
  %264 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots330 = getelementptr inbounds %struct.clusterState, ptr %264, i32 0, i32 9
  %265 = load i32, ptr %slot190, align 4
  %idxprom331 = sext i32 %265 to i64
  %arrayidx332 = getelementptr inbounds [16384 x ptr], ptr %slots330, i64 0, i64 %idxprom331
  %266 = load ptr, ptr %arrayidx332, align 8
  %267 = load ptr, ptr @myself, align 8
  %cmp333 = icmp eq ptr %266, %267
  br i1 %cmp333, label %land.lhs.true335, label %if.end344

land.lhs.true335:                                 ; preds = %if.end329
  %268 = load ptr, ptr %n, align 8
  %269 = load ptr, ptr @myself, align 8
  %cmp336 = icmp ne ptr %268, %269
  br i1 %cmp336, label %if.then338, label %if.end344

if.then338:                                       ; preds = %land.lhs.true335
  %270 = load i32, ptr %slot190, align 4
  %call339 = call i32 @countKeysInSlot(i32 noundef %270)
  %cmp340 = icmp ne i32 %call339, 0
  br i1 %cmp340, label %if.then342, label %if.end343

if.then342:                                       ; preds = %if.then338
  %271 = load ptr, ptr %c.addr, align 8
  %272 = load i32, ptr %slot190, align 4
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %271, ptr noundef @.str.234, i32 noundef %272)
  store i32 1, ptr %retval, align 4
  br label %return

if.end343:                                        ; preds = %if.then338
  br label %if.end344

if.end344:                                        ; preds = %if.end343, %land.lhs.true335, %if.end329
  %273 = load i32, ptr %slot190, align 4
  %call345 = call i32 @countKeysInSlot(i32 noundef %273)
  %cmp346 = icmp eq i32 %call345, 0
  br i1 %cmp346, label %land.lhs.true348, label %if.end357

land.lhs.true348:                                 ; preds = %if.end344
  %274 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to349 = getelementptr inbounds %struct.clusterState, ptr %274, i32 0, i32 7
  %275 = load i32, ptr %slot190, align 4
  %idxprom350 = sext i32 %275 to i64
  %arrayidx351 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to349, i64 0, i64 %idxprom350
  %276 = load ptr, ptr %arrayidx351, align 8
  %tobool352 = icmp ne ptr %276, null
  br i1 %tobool352, label %if.then353, label %if.end357

if.then353:                                       ; preds = %land.lhs.true348
  %277 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to354 = getelementptr inbounds %struct.clusterState, ptr %277, i32 0, i32 7
  %278 = load i32, ptr %slot190, align 4
  %idxprom355 = sext i32 %278 to i64
  %arrayidx356 = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to354, i64 0, i64 %idxprom355
  store ptr null, ptr %arrayidx356, align 8
  br label %if.end357

if.end357:                                        ; preds = %if.then353, %land.lhs.true348, %if.end344
  %279 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots358 = getelementptr inbounds %struct.clusterState, ptr %279, i32 0, i32 9
  %280 = load i32, ptr %slot190, align 4
  %idxprom359 = sext i32 %280 to i64
  %arrayidx360 = getelementptr inbounds [16384 x ptr], ptr %slots358, i64 0, i64 %idxprom359
  %281 = load ptr, ptr %arrayidx360, align 8
  %282 = load ptr, ptr @myself, align 8
  %cmp361 = icmp eq ptr %281, %282
  %conv362 = zext i1 %cmp361 to i32
  store i32 %conv362, ptr %slot_was_mine, align 4
  %283 = load i32, ptr %slot190, align 4
  %call363 = call i32 @clusterDelSlot(i32 noundef %283)
  %284 = load ptr, ptr %n, align 8
  %285 = load i32, ptr %slot190, align 4
  %call364 = call i32 @clusterAddSlot(ptr noundef %284, i32 noundef %285)
  %286 = load i32, ptr %slot_was_mine, align 4
  %tobool365 = icmp ne i32 %286, 0
  br i1 %tobool365, label %land.lhs.true366, label %if.end379

land.lhs.true366:                                 ; preds = %if.end357
  %287 = load ptr, ptr %n, align 8
  %288 = load ptr, ptr @myself, align 8
  %cmp367 = icmp ne ptr %287, %288
  br i1 %cmp367, label %land.lhs.true369, label %if.end379

land.lhs.true369:                                 ; preds = %land.lhs.true366
  %289 = load ptr, ptr @myself, align 8
  %numslots = getelementptr inbounds %struct._clusterNode, ptr %289, i32 0, i32 8
  %290 = load i32, ptr %numslots, align 4
  %cmp370 = icmp eq i32 %290, 0
  br i1 %cmp370, label %land.lhs.true372, label %if.end379

land.lhs.true372:                                 ; preds = %land.lhs.true369
  %291 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 369), align 4
  %tobool373 = icmp ne i32 %291, 0
  br i1 %tobool373, label %if.then374, label %if.end379

if.then374:                                       ; preds = %land.lhs.true372
  br label %do.body

do.body:                                          ; preds = %if.then374
  %292 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp375 = icmp slt i32 2, %292
  br i1 %cmp375, label %if.then377, label %if.end378

if.then377:                                       ; preds = %do.body
  br label %do.end

if.end378:                                        ; preds = %do.body
  %293 = load ptr, ptr %n, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %293, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  %294 = load ptr, ptr %n, align 8
  %human_nodename = getelementptr inbounds %struct._clusterNode, ptr %294, i32 0, i32 23
  %295 = load ptr, ptr %human_nodename, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.78, ptr noundef %arraydecay, ptr noundef %295)
  br label %do.end

do.end:                                           ; preds = %if.end378, %if.then377
  %296 = load ptr, ptr %n, align 8
  call void @clusterSetMaster(ptr noundef %296)
  call void @clusterDoBeforeSleep(i32 noundef 14)
  br label %if.end379

if.end379:                                        ; preds = %do.end, %land.lhs.true372, %land.lhs.true369, %land.lhs.true366, %if.end357
  %297 = load ptr, ptr %n, align 8
  %298 = load ptr, ptr @myself, align 8
  %cmp380 = icmp eq ptr %297, %298
  br i1 %cmp380, label %land.lhs.true382, label %if.end402

land.lhs.true382:                                 ; preds = %if.end379
  %299 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from383 = getelementptr inbounds %struct.clusterState, ptr %299, i32 0, i32 8
  %300 = load i32, ptr %slot190, align 4
  %idxprom384 = sext i32 %300 to i64
  %arrayidx385 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from383, i64 0, i64 %idxprom384
  %301 = load ptr, ptr %arrayidx385, align 8
  %tobool386 = icmp ne ptr %301, null
  br i1 %tobool386, label %if.then387, label %if.end402

if.then387:                                       ; preds = %land.lhs.true382
  %call388 = call i32 @clusterBumpConfigEpochWithoutConsensus()
  %cmp389 = icmp eq i32 %call388, 0
  br i1 %cmp389, label %if.then391, label %if.end398

if.then391:                                       ; preds = %if.then387
  br label %do.body392

do.body392:                                       ; preds = %if.then391
  %302 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp393 = icmp slt i32 2, %302
  br i1 %cmp393, label %if.then395, label %if.end396

if.then395:                                       ; preds = %do.body392
  br label %do.end397

if.end396:                                        ; preds = %do.body392
  %303 = load i32, ptr %slot190, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.235, i32 noundef %303)
  br label %do.end397

do.end397:                                        ; preds = %if.end396, %if.then395
  br label %if.end398

if.end398:                                        ; preds = %do.end397, %if.then387
  %304 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from399 = getelementptr inbounds %struct.clusterState, ptr %304, i32 0, i32 8
  %305 = load i32, ptr %slot190, align 4
  %idxprom400 = sext i32 %305 to i64
  %arrayidx401 = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from399, i64 0, i64 %idxprom400
  store ptr null, ptr %arrayidx401, align 8
  call void @clusterBroadcastPong(i32 noundef 0)
  br label %if.end402

if.end402:                                        ; preds = %if.end398, %land.lhs.true382, %if.end379
  br label %if.end404

if.else403:                                       ; preds = %land.lhs.true305, %if.else299
  %306 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %306, ptr noundef @.str.236)
  store i32 1, ptr %retval, align 4
  br label %return

if.end404:                                        ; preds = %if.end402
  br label %if.end405

if.end405:                                        ; preds = %if.end404, %if.then292
  br label %if.end406

if.end406:                                        ; preds = %if.end405, %if.end279
  br label %if.end407

if.end407:                                        ; preds = %if.end406, %if.end238
  call void @clusterDoBeforeSleep(i32 noundef 6)
  %307 = load ptr, ptr %c.addr, align 8
  %308 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %307, ptr noundef %308)
  br label %if.end779

if.else408:                                       ; preds = %land.lhs.true185, %if.else179
  %309 = load ptr, ptr %c.addr, align 8
  %argv409 = getelementptr inbounds %struct.client, ptr %309, i32 0, i32 12
  %310 = load ptr, ptr %argv409, align 8
  %arrayidx410 = getelementptr inbounds ptr, ptr %310, i64 1
  %311 = load ptr, ptr %arrayidx410, align 8
  %ptr411 = getelementptr inbounds %struct.redisObject, ptr %311, i32 0, i32 2
  %312 = load ptr, ptr %ptr411, align 8
  %call412 = call i32 @strcasecmp(ptr noundef %312, ptr noundef @.str.237) #12
  %tobool413 = icmp ne i32 %call412, 0
  br i1 %tobool413, label %if.else425, label %land.lhs.true414

land.lhs.true414:                                 ; preds = %if.else408
  %313 = load ptr, ptr %c.addr, align 8
  %argc415 = getelementptr inbounds %struct.client, ptr %313, i32 0, i32 11
  %314 = load i32, ptr %argc415, align 8
  %cmp416 = icmp eq i32 %314, 2
  br i1 %cmp416, label %if.then418, label %if.else425

if.then418:                                       ; preds = %land.lhs.true414
  %call420 = call i32 @clusterBumpConfigEpochWithoutConsensus()
  store i32 %call420, ptr %retval419, align 4
  %call421 = call ptr @sdsempty()
  %315 = load i32, ptr %retval419, align 4
  %cmp422 = icmp eq i32 %315, 0
  %cond = select i1 %cmp422, ptr @.str.239, ptr @.str.240
  %316 = load ptr, ptr @myself, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %316, i32 0, i32 4
  %317 = load i64, ptr %configEpoch, align 8
  %call424 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call421, ptr noundef @.str.238, ptr noundef %cond, i64 noundef %317)
  store ptr %call424, ptr %reply, align 8
  %318 = load ptr, ptr %c.addr, align 8
  %319 = load ptr, ptr %reply, align 8
  call void @addReplySds(ptr noundef %318, ptr noundef %319)
  br label %if.end778

if.else425:                                       ; preds = %land.lhs.true414, %if.else408
  %320 = load ptr, ptr %c.addr, align 8
  %argv426 = getelementptr inbounds %struct.client, ptr %320, i32 0, i32 12
  %321 = load ptr, ptr %argv426, align 8
  %arrayidx427 = getelementptr inbounds ptr, ptr %321, i64 1
  %322 = load ptr, ptr %arrayidx427, align 8
  %ptr428 = getelementptr inbounds %struct.redisObject, ptr %322, i32 0, i32 2
  %323 = load ptr, ptr %ptr428, align 8
  %call429 = call i32 @strcasecmp(ptr noundef %323, ptr noundef @.str.241) #12
  %tobool430 = icmp ne i32 %call429, 0
  br i1 %tobool430, label %if.else445, label %land.lhs.true431

land.lhs.true431:                                 ; preds = %if.else425
  %324 = load ptr, ptr %c.addr, align 8
  %argc432 = getelementptr inbounds %struct.client, ptr %324, i32 0, i32 11
  %325 = load i32, ptr %argc432, align 8
  %cmp433 = icmp eq i32 %325, 2
  br i1 %cmp433, label %if.then435, label %if.else445

if.then435:                                       ; preds = %land.lhs.true431
  %call437 = call i32 @clusterSaveConfig(i32 noundef 1)
  store i32 %call437, ptr %retval436, align 4
  %326 = load i32, ptr %retval436, align 4
  %cmp438 = icmp eq i32 %326, 0
  br i1 %cmp438, label %if.then440, label %if.else441

if.then440:                                       ; preds = %if.then435
  %327 = load ptr, ptr %c.addr, align 8
  %328 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %327, ptr noundef %328)
  br label %if.end444

if.else441:                                       ; preds = %if.then435
  %329 = load ptr, ptr %c.addr, align 8
  %call442 = call ptr @__errno_location() #14
  %330 = load i32, ptr %call442, align 4
  %call443 = call ptr @strerror(i32 noundef %330) #15
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %329, ptr noundef @.str.242, ptr noundef %call443)
  br label %if.end444

if.end444:                                        ; preds = %if.else441, %if.then440
  br label %if.end777

if.else445:                                       ; preds = %land.lhs.true431, %if.else425
  %331 = load ptr, ptr %c.addr, align 8
  %argv446 = getelementptr inbounds %struct.client, ptr %331, i32 0, i32 12
  %332 = load ptr, ptr %argv446, align 8
  %arrayidx447 = getelementptr inbounds ptr, ptr %332, i64 1
  %333 = load ptr, ptr %arrayidx447, align 8
  %ptr448 = getelementptr inbounds %struct.redisObject, ptr %333, i32 0, i32 2
  %334 = load ptr, ptr %ptr448, align 8
  %call449 = call i32 @strcasecmp(ptr noundef %334, ptr noundef @.str.243) #12
  %tobool450 = icmp ne i32 %call449, 0
  br i1 %tobool450, label %if.else494, label %land.lhs.true451

land.lhs.true451:                                 ; preds = %if.else445
  %335 = load ptr, ptr %c.addr, align 8
  %argc452 = getelementptr inbounds %struct.client, ptr %335, i32 0, i32 11
  %336 = load i32, ptr %argc452, align 8
  %cmp453 = icmp eq i32 %336, 3
  br i1 %cmp453, label %if.then455, label %if.else494

if.then455:                                       ; preds = %land.lhs.true451
  %337 = load ptr, ptr %c.addr, align 8
  %argv457 = getelementptr inbounds %struct.client, ptr %337, i32 0, i32 12
  %338 = load ptr, ptr %argv457, align 8
  %arrayidx458 = getelementptr inbounds ptr, ptr %338, i64 2
  %339 = load ptr, ptr %arrayidx458, align 8
  %ptr459 = getelementptr inbounds %struct.redisObject, ptr %339, i32 0, i32 2
  %340 = load ptr, ptr %ptr459, align 8
  %341 = load ptr, ptr %c.addr, align 8
  %argv460 = getelementptr inbounds %struct.client, ptr %341, i32 0, i32 12
  %342 = load ptr, ptr %argv460, align 8
  %arrayidx461 = getelementptr inbounds ptr, ptr %342, i64 2
  %343 = load ptr, ptr %arrayidx461, align 8
  %ptr462 = getelementptr inbounds %struct.redisObject, ptr %343, i32 0, i32 2
  %344 = load ptr, ptr %ptr462, align 8
  %call463 = call i64 @sdslen(ptr noundef %344)
  %conv464 = trunc i64 %call463 to i32
  %call465 = call ptr @clusterLookupNode(ptr noundef %340, i32 noundef %conv464)
  store ptr %call465, ptr %n456, align 8
  %345 = load ptr, ptr %n456, align 8
  %tobool466 = icmp ne ptr %345, null
  br i1 %tobool466, label %if.else479, label %if.then467

if.then467:                                       ; preds = %if.then455
  %346 = load ptr, ptr %c.addr, align 8
  %argv468 = getelementptr inbounds %struct.client, ptr %346, i32 0, i32 12
  %347 = load ptr, ptr %argv468, align 8
  %arrayidx469 = getelementptr inbounds ptr, ptr %347, i64 2
  %348 = load ptr, ptr %arrayidx469, align 8
  %ptr470 = getelementptr inbounds %struct.redisObject, ptr %348, i32 0, i32 2
  %349 = load ptr, ptr %ptr470, align 8
  %call471 = call i32 @clusterBlacklistExists(ptr noundef %349)
  %tobool472 = icmp ne i32 %call471, 0
  br i1 %tobool472, label %if.then473, label %if.else474

if.then473:                                       ; preds = %if.then467
  %350 = load ptr, ptr %c.addr, align 8
  %351 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %350, ptr noundef %351)
  br label %if.end478

if.else474:                                       ; preds = %if.then467
  %352 = load ptr, ptr %c.addr, align 8
  %353 = load ptr, ptr %c.addr, align 8
  %argv475 = getelementptr inbounds %struct.client, ptr %353, i32 0, i32 12
  %354 = load ptr, ptr %argv475, align 8
  %arrayidx476 = getelementptr inbounds ptr, ptr %354, i64 2
  %355 = load ptr, ptr %arrayidx476, align 8
  %ptr477 = getelementptr inbounds %struct.redisObject, ptr %355, i32 0, i32 2
  %356 = load ptr, ptr %ptr477, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %352, ptr noundef @.str.210, ptr noundef %356)
  br label %if.end478

if.end478:                                        ; preds = %if.else474, %if.then473
  store i32 1, ptr %retval, align 4
  br label %return

if.else479:                                       ; preds = %if.then455
  %357 = load ptr, ptr %n456, align 8
  %358 = load ptr, ptr @myself, align 8
  %cmp480 = icmp eq ptr %357, %358
  br i1 %cmp480, label %if.then482, label %if.else483

if.then482:                                       ; preds = %if.else479
  %359 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %359, ptr noundef @.str.244)
  store i32 1, ptr %retval, align 4
  br label %return

if.else483:                                       ; preds = %if.else479
  %360 = load ptr, ptr @myself, align 8
  %flags484 = getelementptr inbounds %struct._clusterNode, ptr %360, i32 0, i32 3
  %361 = load i32, ptr %flags484, align 8
  %and485 = and i32 %361, 2
  %tobool486 = icmp ne i32 %and485, 0
  br i1 %tobool486, label %land.lhs.true487, label %if.end491

land.lhs.true487:                                 ; preds = %if.else483
  %362 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %362, i32 0, i32 11
  %363 = load ptr, ptr %slaveof, align 8
  %364 = load ptr, ptr %n456, align 8
  %cmp488 = icmp eq ptr %363, %364
  br i1 %cmp488, label %if.then490, label %if.end491

if.then490:                                       ; preds = %land.lhs.true487
  %365 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %365, ptr noundef @.str.245)
  store i32 1, ptr %retval, align 4
  br label %return

if.end491:                                        ; preds = %land.lhs.true487, %if.else483
  br label %if.end492

if.end492:                                        ; preds = %if.end491
  br label %if.end493

if.end493:                                        ; preds = %if.end492
  %366 = load ptr, ptr %n456, align 8
  call void @clusterBlacklistAddNode(ptr noundef %366)
  %367 = load ptr, ptr %n456, align 8
  call void @clusterDelNode(ptr noundef %367)
  call void @clusterDoBeforeSleep(i32 noundef 6)
  %368 = load ptr, ptr %c.addr, align 8
  %369 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %368, ptr noundef %369)
  br label %if.end776

if.else494:                                       ; preds = %land.lhs.true451, %if.else445
  %370 = load ptr, ptr %c.addr, align 8
  %argv495 = getelementptr inbounds %struct.client, ptr %370, i32 0, i32 12
  %371 = load ptr, ptr %argv495, align 8
  %arrayidx496 = getelementptr inbounds ptr, ptr %371, i64 1
  %372 = load ptr, ptr %arrayidx496, align 8
  %ptr497 = getelementptr inbounds %struct.redisObject, ptr %372, i32 0, i32 2
  %373 = load ptr, ptr %ptr497, align 8
  %call498 = call i32 @strcasecmp(ptr noundef %373, ptr noundef @.str.246) #12
  %tobool499 = icmp ne i32 %call498, 0
  br i1 %tobool499, label %if.else543, label %land.lhs.true500

land.lhs.true500:                                 ; preds = %if.else494
  %374 = load ptr, ptr %c.addr, align 8
  %argc501 = getelementptr inbounds %struct.client, ptr %374, i32 0, i32 11
  %375 = load i32, ptr %argc501, align 8
  %cmp502 = icmp eq i32 %375, 3
  br i1 %cmp502, label %if.then504, label %if.else543

if.then504:                                       ; preds = %land.lhs.true500
  %376 = load ptr, ptr %c.addr, align 8
  %argv506 = getelementptr inbounds %struct.client, ptr %376, i32 0, i32 12
  %377 = load ptr, ptr %argv506, align 8
  %arrayidx507 = getelementptr inbounds ptr, ptr %377, i64 2
  %378 = load ptr, ptr %arrayidx507, align 8
  %ptr508 = getelementptr inbounds %struct.redisObject, ptr %378, i32 0, i32 2
  %379 = load ptr, ptr %ptr508, align 8
  %380 = load ptr, ptr %c.addr, align 8
  %argv509 = getelementptr inbounds %struct.client, ptr %380, i32 0, i32 12
  %381 = load ptr, ptr %argv509, align 8
  %arrayidx510 = getelementptr inbounds ptr, ptr %381, i64 2
  %382 = load ptr, ptr %arrayidx510, align 8
  %ptr511 = getelementptr inbounds %struct.redisObject, ptr %382, i32 0, i32 2
  %383 = load ptr, ptr %ptr511, align 8
  %call512 = call i64 @sdslen(ptr noundef %383)
  %conv513 = trunc i64 %call512 to i32
  %call514 = call ptr @clusterLookupNode(ptr noundef %379, i32 noundef %conv513)
  store ptr %call514, ptr %n505, align 8
  %384 = load ptr, ptr %n505, align 8
  %tobool515 = icmp ne ptr %384, null
  br i1 %tobool515, label %if.end520, label %if.then516

if.then516:                                       ; preds = %if.then504
  %385 = load ptr, ptr %c.addr, align 8
  %386 = load ptr, ptr %c.addr, align 8
  %argv517 = getelementptr inbounds %struct.client, ptr %386, i32 0, i32 12
  %387 = load ptr, ptr %argv517, align 8
  %arrayidx518 = getelementptr inbounds ptr, ptr %387, i64 2
  %388 = load ptr, ptr %arrayidx518, align 8
  %ptr519 = getelementptr inbounds %struct.redisObject, ptr %388, i32 0, i32 2
  %389 = load ptr, ptr %ptr519, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %385, ptr noundef @.str.210, ptr noundef %389)
  store i32 1, ptr %retval, align 4
  br label %return

if.end520:                                        ; preds = %if.then504
  %390 = load ptr, ptr %n505, align 8
  %391 = load ptr, ptr @myself, align 8
  %cmp521 = icmp eq ptr %390, %391
  br i1 %cmp521, label %if.then523, label %if.end524

if.then523:                                       ; preds = %if.end520
  %392 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %392, ptr noundef @.str.247)
  store i32 1, ptr %retval, align 4
  br label %return

if.end524:                                        ; preds = %if.end520
  %393 = load ptr, ptr %n505, align 8
  %flags525 = getelementptr inbounds %struct._clusterNode, ptr %393, i32 0, i32 3
  %394 = load i32, ptr %flags525, align 8
  %and526 = and i32 %394, 2
  %tobool527 = icmp ne i32 %and526, 0
  br i1 %tobool527, label %if.then528, label %if.end529

if.then528:                                       ; preds = %if.end524
  %395 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %395, ptr noundef @.str.248)
  store i32 1, ptr %retval, align 4
  br label %return

if.end529:                                        ; preds = %if.end524
  %396 = load ptr, ptr @myself, align 8
  %call530 = call i32 @clusterNodeIsMaster(ptr noundef %396)
  %tobool531 = icmp ne i32 %call530, 0
  br i1 %tobool531, label %land.lhs.true532, label %if.end542

land.lhs.true532:                                 ; preds = %if.end529
  %397 = load ptr, ptr @myself, align 8
  %numslots533 = getelementptr inbounds %struct._clusterNode, ptr %397, i32 0, i32 8
  %398 = load i32, ptr %numslots533, align 4
  %cmp534 = icmp ne i32 %398, 0
  br i1 %cmp534, label %if.then541, label %lor.lhs.false536

lor.lhs.false536:                                 ; preds = %land.lhs.true532
  %399 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %arrayidx537 = getelementptr inbounds %struct.redisDb, ptr %399, i64 0
  %call538 = call i64 @dbSize(ptr noundef %arrayidx537, i32 noundef 0)
  %cmp539 = icmp ne i64 %call538, 0
  br i1 %cmp539, label %if.then541, label %if.end542

if.then541:                                       ; preds = %lor.lhs.false536, %land.lhs.true532
  %400 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %400, ptr noundef @.str.249)
  store i32 1, ptr %retval, align 4
  br label %return

if.end542:                                        ; preds = %lor.lhs.false536, %if.end529
  %401 = load ptr, ptr %n505, align 8
  call void @clusterSetMaster(ptr noundef %401)
  call void @clusterDoBeforeSleep(i32 noundef 6)
  %402 = load ptr, ptr %c.addr, align 8
  %403 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %402, ptr noundef %403)
  br label %if.end775

if.else543:                                       ; preds = %land.lhs.true500, %if.else494
  %404 = load ptr, ptr %c.addr, align 8
  %argv544 = getelementptr inbounds %struct.client, ptr %404, i32 0, i32 12
  %405 = load ptr, ptr %argv544, align 8
  %arrayidx545 = getelementptr inbounds ptr, ptr %405, i64 1
  %406 = load ptr, ptr %arrayidx545, align 8
  %ptr546 = getelementptr inbounds %struct.redisObject, ptr %406, i32 0, i32 2
  %407 = load ptr, ptr %ptr546, align 8
  %call547 = call i32 @strcasecmp(ptr noundef %407, ptr noundef @.str.250) #12
  %tobool548 = icmp ne i32 %call547, 0
  br i1 %tobool548, label %if.else573, label %land.lhs.true549

land.lhs.true549:                                 ; preds = %if.else543
  %408 = load ptr, ptr %c.addr, align 8
  %argc550 = getelementptr inbounds %struct.client, ptr %408, i32 0, i32 11
  %409 = load i32, ptr %argc550, align 8
  %cmp551 = icmp eq i32 %409, 3
  br i1 %cmp551, label %if.then553, label %if.else573

if.then553:                                       ; preds = %land.lhs.true549
  %410 = load ptr, ptr %c.addr, align 8
  %argv555 = getelementptr inbounds %struct.client, ptr %410, i32 0, i32 12
  %411 = load ptr, ptr %argv555, align 8
  %arrayidx556 = getelementptr inbounds ptr, ptr %411, i64 2
  %412 = load ptr, ptr %arrayidx556, align 8
  %ptr557 = getelementptr inbounds %struct.redisObject, ptr %412, i32 0, i32 2
  %413 = load ptr, ptr %ptr557, align 8
  %414 = load ptr, ptr %c.addr, align 8
  %argv558 = getelementptr inbounds %struct.client, ptr %414, i32 0, i32 12
  %415 = load ptr, ptr %argv558, align 8
  %arrayidx559 = getelementptr inbounds ptr, ptr %415, i64 2
  %416 = load ptr, ptr %arrayidx559, align 8
  %ptr560 = getelementptr inbounds %struct.redisObject, ptr %416, i32 0, i32 2
  %417 = load ptr, ptr %ptr560, align 8
  %call561 = call i64 @sdslen(ptr noundef %417)
  %conv562 = trunc i64 %call561 to i32
  %call563 = call ptr @clusterLookupNode(ptr noundef %413, i32 noundef %conv562)
  store ptr %call563, ptr %n554, align 8
  %418 = load ptr, ptr %n554, align 8
  %tobool564 = icmp ne ptr %418, null
  br i1 %tobool564, label %if.else569, label %if.then565

if.then565:                                       ; preds = %if.then553
  %419 = load ptr, ptr %c.addr, align 8
  %420 = load ptr, ptr %c.addr, align 8
  %argv566 = getelementptr inbounds %struct.client, ptr %420, i32 0, i32 12
  %421 = load ptr, ptr %argv566, align 8
  %arrayidx567 = getelementptr inbounds ptr, ptr %421, i64 2
  %422 = load ptr, ptr %arrayidx567, align 8
  %ptr568 = getelementptr inbounds %struct.redisObject, ptr %422, i32 0, i32 2
  %423 = load ptr, ptr %ptr568, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %419, ptr noundef @.str.210, ptr noundef %423)
  store i32 1, ptr %retval, align 4
  br label %return

if.else569:                                       ; preds = %if.then553
  %424 = load ptr, ptr %c.addr, align 8
  %425 = load ptr, ptr %n554, align 8
  %call570 = call i32 @clusterNodeFailureReportsCount(ptr noundef %425)
  %conv571 = sext i32 %call570 to i64
  call void @addReplyLongLong(ptr noundef %424, i64 noundef %conv571)
  br label %if.end572

if.end572:                                        ; preds = %if.else569
  br label %if.end774

if.else573:                                       ; preds = %land.lhs.true549, %if.else543
  %426 = load ptr, ptr %c.addr, align 8
  %argv574 = getelementptr inbounds %struct.client, ptr %426, i32 0, i32 12
  %427 = load ptr, ptr %argv574, align 8
  %arrayidx575 = getelementptr inbounds ptr, ptr %427, i64 1
  %428 = load ptr, ptr %arrayidx575, align 8
  %ptr576 = getelementptr inbounds %struct.redisObject, ptr %428, i32 0, i32 2
  %429 = load ptr, ptr %ptr576, align 8
  %call577 = call i32 @strcasecmp(ptr noundef %429, ptr noundef @.str.251) #12
  %tobool578 = icmp ne i32 %call577, 0
  br i1 %tobool578, label %if.else662, label %land.lhs.true579

land.lhs.true579:                                 ; preds = %if.else573
  %430 = load ptr, ptr %c.addr, align 8
  %argc580 = getelementptr inbounds %struct.client, ptr %430, i32 0, i32 11
  %431 = load i32, ptr %argc580, align 8
  %cmp581 = icmp eq i32 %431, 2
  br i1 %cmp581, label %if.then587, label %lor.lhs.false583

lor.lhs.false583:                                 ; preds = %land.lhs.true579
  %432 = load ptr, ptr %c.addr, align 8
  %argc584 = getelementptr inbounds %struct.client, ptr %432, i32 0, i32 11
  %433 = load i32, ptr %argc584, align 8
  %cmp585 = icmp eq i32 %433, 3
  br i1 %cmp585, label %if.then587, label %if.else662

if.then587:                                       ; preds = %lor.lhs.false583, %land.lhs.true579
  store i32 0, ptr %force, align 4
  store i32 0, ptr %takeover, align 4
  %434 = load ptr, ptr %c.addr, align 8
  %argc588 = getelementptr inbounds %struct.client, ptr %434, i32 0, i32 11
  %435 = load i32, ptr %argc588, align 8
  %cmp589 = icmp eq i32 %435, 3
  br i1 %cmp589, label %if.then591, label %if.end608

if.then591:                                       ; preds = %if.then587
  %436 = load ptr, ptr %c.addr, align 8
  %argv592 = getelementptr inbounds %struct.client, ptr %436, i32 0, i32 12
  %437 = load ptr, ptr %argv592, align 8
  %arrayidx593 = getelementptr inbounds ptr, ptr %437, i64 2
  %438 = load ptr, ptr %arrayidx593, align 8
  %ptr594 = getelementptr inbounds %struct.redisObject, ptr %438, i32 0, i32 2
  %439 = load ptr, ptr %ptr594, align 8
  %call595 = call i32 @strcasecmp(ptr noundef %439, ptr noundef @.str.252) #12
  %tobool596 = icmp ne i32 %call595, 0
  br i1 %tobool596, label %if.else598, label %if.then597

if.then597:                                       ; preds = %if.then591
  store i32 1, ptr %force, align 4
  br label %if.end607

if.else598:                                       ; preds = %if.then591
  %440 = load ptr, ptr %c.addr, align 8
  %argv599 = getelementptr inbounds %struct.client, ptr %440, i32 0, i32 12
  %441 = load ptr, ptr %argv599, align 8
  %arrayidx600 = getelementptr inbounds ptr, ptr %441, i64 2
  %442 = load ptr, ptr %arrayidx600, align 8
  %ptr601 = getelementptr inbounds %struct.redisObject, ptr %442, i32 0, i32 2
  %443 = load ptr, ptr %ptr601, align 8
  %call602 = call i32 @strcasecmp(ptr noundef %443, ptr noundef @.str.253) #12
  %tobool603 = icmp ne i32 %call602, 0
  br i1 %tobool603, label %if.else605, label %if.then604

if.then604:                                       ; preds = %if.else598
  store i32 1, ptr %takeover, align 4
  store i32 1, ptr %force, align 4
  br label %if.end606

if.else605:                                       ; preds = %if.else598
  %444 = load ptr, ptr %c.addr, align 8
  %445 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 15), align 8
  call void @addReplyErrorObject(ptr noundef %444, ptr noundef %445)
  store i32 1, ptr %retval, align 4
  br label %return

if.end606:                                        ; preds = %if.then604
  br label %if.end607

if.end607:                                        ; preds = %if.end606, %if.then597
  br label %if.end608

if.end608:                                        ; preds = %if.end607, %if.then587
  %446 = load ptr, ptr @myself, align 8
  %call609 = call i32 @clusterNodeIsMaster(ptr noundef %446)
  %tobool610 = icmp ne i32 %call609, 0
  br i1 %tobool610, label %if.then611, label %if.else612

if.then611:                                       ; preds = %if.end608
  %447 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %447, ptr noundef @.str.254)
  store i32 1, ptr %retval, align 4
  br label %return

if.else612:                                       ; preds = %if.end608
  %448 = load ptr, ptr @myself, align 8
  %slaveof613 = getelementptr inbounds %struct._clusterNode, ptr %448, i32 0, i32 11
  %449 = load ptr, ptr %slaveof613, align 8
  %cmp614 = icmp eq ptr %449, null
  br i1 %cmp614, label %if.then616, label %if.else617

if.then616:                                       ; preds = %if.else612
  %450 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %450, ptr noundef @.str.255)
  store i32 1, ptr %retval, align 4
  br label %return

if.else617:                                       ; preds = %if.else612
  %451 = load i32, ptr %force, align 4
  %tobool618 = icmp ne i32 %451, 0
  br i1 %tobool618, label %if.end629, label %land.lhs.true619

land.lhs.true619:                                 ; preds = %if.else617
  %452 = load ptr, ptr @myself, align 8
  %slaveof620 = getelementptr inbounds %struct._clusterNode, ptr %452, i32 0, i32 11
  %453 = load ptr, ptr %slaveof620, align 8
  %flags621 = getelementptr inbounds %struct._clusterNode, ptr %453, i32 0, i32 3
  %454 = load i32, ptr %flags621, align 8
  %and622 = and i32 %454, 8
  %tobool623 = icmp ne i32 %and622, 0
  br i1 %tobool623, label %if.then628, label %lor.lhs.false624

lor.lhs.false624:                                 ; preds = %land.lhs.true619
  %455 = load ptr, ptr @myself, align 8
  %slaveof625 = getelementptr inbounds %struct._clusterNode, ptr %455, i32 0, i32 11
  %456 = load ptr, ptr %slaveof625, align 8
  %link = getelementptr inbounds %struct._clusterNode, ptr %456, i32 0, i32 27
  %457 = load ptr, ptr %link, align 8
  %cmp626 = icmp eq ptr %457, null
  br i1 %cmp626, label %if.then628, label %if.end629

if.then628:                                       ; preds = %lor.lhs.false624, %land.lhs.true619
  %458 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %458, ptr noundef @.str.256)
  store i32 1, ptr %retval, align 4
  br label %return

if.end629:                                        ; preds = %lor.lhs.false624, %if.else617
  br label %if.end630

if.end630:                                        ; preds = %if.end629
  br label %if.end631

if.end631:                                        ; preds = %if.end630
  call void @resetManualFailover()
  %call632 = call i64 @mstime()
  %add633 = add nsw i64 %call632, 5000
  %459 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %459, i32 0, i32 17
  store i64 %add633, ptr %mf_end, align 8
  %460 = load i32, ptr %takeover, align 4
  %tobool634 = icmp ne i32 %460, 0
  br i1 %tobool634, label %if.then635, label %if.else643

if.then635:                                       ; preds = %if.end631
  br label %do.body636

do.body636:                                       ; preds = %if.then635
  %461 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp637 = icmp slt i32 2, %461
  br i1 %cmp637, label %if.then639, label %if.end640

if.then639:                                       ; preds = %do.body636
  br label %do.end641

if.end640:                                        ; preds = %do.body636
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.257)
  br label %do.end641

do.end641:                                        ; preds = %if.end640, %if.then639
  %call642 = call i32 @clusterBumpConfigEpochWithoutConsensus()
  call void @clusterFailoverReplaceYourMaster()
  br label %if.end661

if.else643:                                       ; preds = %if.end631
  %462 = load i32, ptr %force, align 4
  %tobool644 = icmp ne i32 %462, 0
  br i1 %tobool644, label %if.then645, label %if.else652

if.then645:                                       ; preds = %if.else643
  br label %do.body646

do.body646:                                       ; preds = %if.then645
  %463 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp647 = icmp slt i32 2, %463
  br i1 %cmp647, label %if.then649, label %if.end650

if.then649:                                       ; preds = %do.body646
  br label %do.end651

if.end650:                                        ; preds = %do.body646
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.258)
  br label %do.end651

do.end651:                                        ; preds = %if.end650, %if.then649
  %464 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_can_start = getelementptr inbounds %struct.clusterState, ptr %464, i32 0, i32 20
  store i32 1, ptr %mf_can_start, align 8
  br label %if.end660

if.else652:                                       ; preds = %if.else643
  br label %do.body653

do.body653:                                       ; preds = %if.else652
  %465 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp654 = icmp slt i32 2, %465
  br i1 %cmp654, label %if.then656, label %if.end657

if.then656:                                       ; preds = %do.body653
  br label %do.end658

if.end657:                                        ; preds = %do.body653
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.259)
  br label %do.end658

do.end658:                                        ; preds = %if.end657, %if.then656
  %466 = load ptr, ptr @myself, align 8
  %slaveof659 = getelementptr inbounds %struct._clusterNode, ptr %466, i32 0, i32 11
  %467 = load ptr, ptr %slaveof659, align 8
  call void @clusterSendMFStart(ptr noundef %467)
  br label %if.end660

if.end660:                                        ; preds = %do.end658, %do.end651
  br label %if.end661

if.end661:                                        ; preds = %if.end660, %do.end641
  %468 = load ptr, ptr %c.addr, align 8
  %469 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %468, ptr noundef %469)
  br label %if.end773

if.else662:                                       ; preds = %lor.lhs.false583, %if.else573
  %470 = load ptr, ptr %c.addr, align 8
  %argv663 = getelementptr inbounds %struct.client, ptr %470, i32 0, i32 12
  %471 = load ptr, ptr %argv663, align 8
  %arrayidx664 = getelementptr inbounds ptr, ptr %471, i64 1
  %472 = load ptr, ptr %arrayidx664, align 8
  %ptr665 = getelementptr inbounds %struct.redisObject, ptr %472, i32 0, i32 2
  %473 = load ptr, ptr %ptr665, align 8
  %call666 = call i32 @strcasecmp(ptr noundef %473, ptr noundef @.str.260) #12
  %tobool667 = icmp ne i32 %call666, 0
  br i1 %tobool667, label %if.else714, label %land.lhs.true668

land.lhs.true668:                                 ; preds = %if.else662
  %474 = load ptr, ptr %c.addr, align 8
  %argc669 = getelementptr inbounds %struct.client, ptr %474, i32 0, i32 11
  %475 = load i32, ptr %argc669, align 8
  %cmp670 = icmp eq i32 %475, 3
  br i1 %cmp670, label %if.then672, label %if.else714

if.then672:                                       ; preds = %land.lhs.true668
  %476 = load ptr, ptr %c.addr, align 8
  %477 = load ptr, ptr %c.addr, align 8
  %argv673 = getelementptr inbounds %struct.client, ptr %477, i32 0, i32 12
  %478 = load ptr, ptr %argv673, align 8
  %arrayidx674 = getelementptr inbounds ptr, ptr %478, i64 2
  %479 = load ptr, ptr %arrayidx674, align 8
  %call675 = call i32 @getLongLongFromObjectOrReply(ptr noundef %476, ptr noundef %479, ptr noundef %epoch, ptr noundef null)
  %cmp676 = icmp ne i32 %call675, 0
  br i1 %cmp676, label %if.then678, label %if.end679

if.then678:                                       ; preds = %if.then672
  store i32 1, ptr %retval, align 4
  br label %return

if.end679:                                        ; preds = %if.then672
  %480 = load i64, ptr %epoch, align 8
  %cmp680 = icmp slt i64 %480, 0
  br i1 %cmp680, label %if.then682, label %if.else683

if.then682:                                       ; preds = %if.end679
  %481 = load ptr, ptr %c.addr, align 8
  %482 = load i64, ptr %epoch, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %481, ptr noundef @.str.261, i64 noundef %482)
  br label %if.end713

if.else683:                                       ; preds = %if.end679
  %483 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes = getelementptr inbounds %struct.clusterState, ptr %483, i32 0, i32 4
  %484 = load ptr, ptr %nodes, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %484, i32 0, i32 2
  %arrayidx684 = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %485 = load i64, ptr %arrayidx684, align 8
  %486 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %nodes685 = getelementptr inbounds %struct.clusterState, ptr %486, i32 0, i32 4
  %487 = load ptr, ptr %nodes685, align 8
  %ht_used686 = getelementptr inbounds %struct.dict, ptr %487, i32 0, i32 2
  %arrayidx687 = getelementptr inbounds [2 x i64], ptr %ht_used686, i64 0, i64 1
  %488 = load i64, ptr %arrayidx687, align 8
  %add688 = add i64 %485, %488
  %cmp689 = icmp ugt i64 %add688, 1
  br i1 %cmp689, label %if.then691, label %if.else692

if.then691:                                       ; preds = %if.else683
  %489 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %489, ptr noundef @.str.262)
  br label %if.end712

if.else692:                                       ; preds = %if.else683
  %490 = load ptr, ptr @myself, align 8
  %configEpoch693 = getelementptr inbounds %struct._clusterNode, ptr %490, i32 0, i32 4
  %491 = load i64, ptr %configEpoch693, align 8
  %cmp694 = icmp ne i64 %491, 0
  br i1 %cmp694, label %if.then696, label %if.else697

if.then696:                                       ; preds = %if.else692
  %492 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %492, ptr noundef @.str.263)
  br label %if.end711

if.else697:                                       ; preds = %if.else692
  %493 = load i64, ptr %epoch, align 8
  %494 = load ptr, ptr @myself, align 8
  %configEpoch698 = getelementptr inbounds %struct._clusterNode, ptr %494, i32 0, i32 4
  store i64 %493, ptr %configEpoch698, align 8
  br label %do.body699

do.body699:                                       ; preds = %if.else697
  %495 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp700 = icmp slt i32 2, %495
  br i1 %cmp700, label %if.then702, label %if.end703

if.then702:                                       ; preds = %do.body699
  br label %do.end705

if.end703:                                        ; preds = %do.body699
  %496 = load ptr, ptr @myself, align 8
  %configEpoch704 = getelementptr inbounds %struct._clusterNode, ptr %496, i32 0, i32 4
  %497 = load i64, ptr %configEpoch704, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.264, i64 noundef %497)
  br label %do.end705

do.end705:                                        ; preds = %if.end703, %if.then702
  %498 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %498, i32 0, i32 1
  %499 = load i64, ptr %currentEpoch, align 8
  %500 = load i64, ptr %epoch, align 8
  %cmp706 = icmp ult i64 %499, %500
  br i1 %cmp706, label %if.then708, label %if.end710

if.then708:                                       ; preds = %do.end705
  %501 = load i64, ptr %epoch, align 8
  %502 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch709 = getelementptr inbounds %struct.clusterState, ptr %502, i32 0, i32 1
  store i64 %501, ptr %currentEpoch709, align 8
  br label %if.end710

if.end710:                                        ; preds = %if.then708, %do.end705
  call void @clusterDoBeforeSleep(i32 noundef 6)
  %503 = load ptr, ptr %c.addr, align 8
  %504 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %503, ptr noundef %504)
  br label %if.end711

if.end711:                                        ; preds = %if.end710, %if.then696
  br label %if.end712

if.end712:                                        ; preds = %if.end711, %if.then691
  br label %if.end713

if.end713:                                        ; preds = %if.end712, %if.then682
  br label %if.end772

if.else714:                                       ; preds = %land.lhs.true668, %if.else662
  %505 = load ptr, ptr %c.addr, align 8
  %argv715 = getelementptr inbounds %struct.client, ptr %505, i32 0, i32 12
  %506 = load ptr, ptr %argv715, align 8
  %arrayidx716 = getelementptr inbounds ptr, ptr %506, i64 1
  %507 = load ptr, ptr %arrayidx716, align 8
  %ptr717 = getelementptr inbounds %struct.redisObject, ptr %507, i32 0, i32 2
  %508 = load ptr, ptr %ptr717, align 8
  %call718 = call i32 @strcasecmp(ptr noundef %508, ptr noundef @.str.265) #12
  %tobool719 = icmp ne i32 %call718, 0
  br i1 %tobool719, label %if.else758, label %land.lhs.true720

land.lhs.true720:                                 ; preds = %if.else714
  %509 = load ptr, ptr %c.addr, align 8
  %argc721 = getelementptr inbounds %struct.client, ptr %509, i32 0, i32 11
  %510 = load i32, ptr %argc721, align 8
  %cmp722 = icmp eq i32 %510, 2
  br i1 %cmp722, label %if.then728, label %lor.lhs.false724

lor.lhs.false724:                                 ; preds = %land.lhs.true720
  %511 = load ptr, ptr %c.addr, align 8
  %argc725 = getelementptr inbounds %struct.client, ptr %511, i32 0, i32 11
  %512 = load i32, ptr %argc725, align 8
  %cmp726 = icmp eq i32 %512, 3
  br i1 %cmp726, label %if.then728, label %if.else758

if.then728:                                       ; preds = %lor.lhs.false724, %land.lhs.true720
  store i32 0, ptr %hard, align 4
  %513 = load ptr, ptr %c.addr, align 8
  %argc729 = getelementptr inbounds %struct.client, ptr %513, i32 0, i32 11
  %514 = load i32, ptr %argc729, align 8
  %cmp730 = icmp eq i32 %514, 3
  br i1 %cmp730, label %if.then732, label %if.end749

if.then732:                                       ; preds = %if.then728
  %515 = load ptr, ptr %c.addr, align 8
  %argv733 = getelementptr inbounds %struct.client, ptr %515, i32 0, i32 12
  %516 = load ptr, ptr %argv733, align 8
  %arrayidx734 = getelementptr inbounds ptr, ptr %516, i64 2
  %517 = load ptr, ptr %arrayidx734, align 8
  %ptr735 = getelementptr inbounds %struct.redisObject, ptr %517, i32 0, i32 2
  %518 = load ptr, ptr %ptr735, align 8
  %call736 = call i32 @strcasecmp(ptr noundef %518, ptr noundef @.str.266) #12
  %tobool737 = icmp ne i32 %call736, 0
  br i1 %tobool737, label %if.else739, label %if.then738

if.then738:                                       ; preds = %if.then732
  store i32 1, ptr %hard, align 4
  br label %if.end748

if.else739:                                       ; preds = %if.then732
  %519 = load ptr, ptr %c.addr, align 8
  %argv740 = getelementptr inbounds %struct.client, ptr %519, i32 0, i32 12
  %520 = load ptr, ptr %argv740, align 8
  %arrayidx741 = getelementptr inbounds ptr, ptr %520, i64 2
  %521 = load ptr, ptr %arrayidx741, align 8
  %ptr742 = getelementptr inbounds %struct.redisObject, ptr %521, i32 0, i32 2
  %522 = load ptr, ptr %ptr742, align 8
  %call743 = call i32 @strcasecmp(ptr noundef %522, ptr noundef @.str.267) #12
  %tobool744 = icmp ne i32 %call743, 0
  br i1 %tobool744, label %if.else746, label %if.then745

if.then745:                                       ; preds = %if.else739
  store i32 0, ptr %hard, align 4
  br label %if.end747

if.else746:                                       ; preds = %if.else739
  %523 = load ptr, ptr %c.addr, align 8
  %524 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 15), align 8
  call void @addReplyErrorObject(ptr noundef %523, ptr noundef %524)
  store i32 1, ptr %retval, align 4
  br label %return

if.end747:                                        ; preds = %if.then745
  br label %if.end748

if.end748:                                        ; preds = %if.end747, %if.then738
  br label %if.end749

if.end749:                                        ; preds = %if.end748, %if.then728
  %525 = load ptr, ptr @myself, align 8
  %call750 = call i32 @clusterNodeIsMaster(ptr noundef %525)
  %tobool751 = icmp ne i32 %call750, 0
  br i1 %tobool751, label %land.lhs.true752, label %if.end757

land.lhs.true752:                                 ; preds = %if.end749
  %526 = load ptr, ptr %c.addr, align 8
  %db = getelementptr inbounds %struct.client, ptr %526, i32 0, i32 4
  %527 = load ptr, ptr %db, align 8
  %call753 = call i64 @dbSize(ptr noundef %527, i32 noundef 0)
  %cmp754 = icmp ne i64 %call753, 0
  br i1 %cmp754, label %if.then756, label %if.end757

if.then756:                                       ; preds = %land.lhs.true752
  %528 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %528, ptr noundef @.str.268)
  store i32 1, ptr %retval, align 4
  br label %return

if.end757:                                        ; preds = %land.lhs.true752, %if.end749
  %529 = load i32, ptr %hard, align 4
  call void @clusterReset(i32 noundef %529)
  %530 = load ptr, ptr %c.addr, align 8
  %531 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %530, ptr noundef %531)
  br label %if.end771

if.else758:                                       ; preds = %lor.lhs.false724, %if.else714
  %532 = load ptr, ptr %c.addr, align 8
  %argv759 = getelementptr inbounds %struct.client, ptr %532, i32 0, i32 12
  %533 = load ptr, ptr %argv759, align 8
  %arrayidx760 = getelementptr inbounds ptr, ptr %533, i64 1
  %534 = load ptr, ptr %arrayidx760, align 8
  %ptr761 = getelementptr inbounds %struct.redisObject, ptr %534, i32 0, i32 2
  %535 = load ptr, ptr %ptr761, align 8
  %call762 = call i32 @strcasecmp(ptr noundef %535, ptr noundef @.str.269) #12
  %tobool763 = icmp ne i32 %call762, 0
  br i1 %tobool763, label %if.else769, label %land.lhs.true764

land.lhs.true764:                                 ; preds = %if.else758
  %536 = load ptr, ptr %c.addr, align 8
  %argc765 = getelementptr inbounds %struct.client, ptr %536, i32 0, i32 11
  %537 = load i32, ptr %argc765, align 8
  %cmp766 = icmp eq i32 %537, 2
  br i1 %cmp766, label %if.then768, label %if.else769

if.then768:                                       ; preds = %land.lhs.true764
  %538 = load ptr, ptr %c.addr, align 8
  call void @addReplyClusterLinksDescription(ptr noundef %538)
  br label %if.end770

if.else769:                                       ; preds = %land.lhs.true764, %if.else758
  store i32 0, ptr %retval, align 4
  br label %return

if.end770:                                        ; preds = %if.then768
  br label %if.end771

if.end771:                                        ; preds = %if.end770, %if.end757
  br label %if.end772

if.end772:                                        ; preds = %if.end771, %if.end713
  br label %if.end773

if.end773:                                        ; preds = %if.end772, %if.end661
  br label %if.end774

if.end774:                                        ; preds = %if.end773, %if.end572
  br label %if.end775

if.end775:                                        ; preds = %if.end774, %if.end542
  br label %if.end776

if.end776:                                        ; preds = %if.end775, %if.end493
  br label %if.end777

if.end777:                                        ; preds = %if.end776, %if.end444
  br label %if.end778

if.end778:                                        ; preds = %if.end777, %if.then418
  br label %if.end779

if.end779:                                        ; preds = %if.end778, %if.end407
  br label %if.end780

if.end780:                                        ; preds = %if.end779, %for.end178
  br label %if.end781

if.end781:                                        ; preds = %if.end780, %for.end111
  br label %if.end782

if.end782:                                        ; preds = %if.end781, %if.end60
  br label %if.end783

if.end783:                                        ; preds = %if.end782, %if.end43
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end783, %if.else769, %if.then756, %if.else746, %if.then678, %if.then628, %if.then616, %if.then611, %if.else605, %if.then565, %if.then541, %if.then528, %if.then523, %if.then516, %if.then490, %if.then482, %if.end478, %if.else403, %if.then342, %if.then328, %if.then320, %if.then278, %if.then270, %if.then257, %if.then237, %if.then229, %if.then216, %if.then199, %if.then192, %if.then174, %if.then169, %if.then165, %if.then156, %if.then132, %if.then107, %if.then93, %if.then59, %if.then18, %if.then7
  %539 = load i32, ptr %retval, align 4
  ret i32 %539
}

declare void @addReplyErrorArity(ptr noundef) #1

declare void @addReplySds(ptr noundef, ptr noundef) #1

declare void @addReplyErrorObject(ptr noundef, ptr noundef) #1

declare i32 @getLongLongFromObjectOrReply(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterCommandExtendedHelp() #0 {
entry:
  ret ptr @clusterCommandExtendedHelp.help
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterNodeNumSlaves(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %numslaves = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 9
  %1 = load i32, ptr %numslaves, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterNodeGetSlave(ptr noundef %node, i32 noundef %slave_idx) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %slave_idx.addr = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store i32 %slave_idx, ptr %slave_idx.addr, align 4
  %0 = load ptr, ptr %node.addr, align 8
  %slaves = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 10
  %1 = load ptr, ptr %slaves, align 8
  %2 = load i32, ptr %slave_idx.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define dso_local ptr @getMigratingSlotDest(i32 noundef %slot) #0 {
entry:
  %slot.addr = alloca i32, align 4
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %migrating_slots_to = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %slot.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %migrating_slots_to, i64 0, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define dso_local ptr @getImportingSlotSource(i32 noundef %slot) #0 {
entry:
  %slot.addr = alloca i32, align 4
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %importing_slots_from = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 8
  %1 = load i32, ptr %slot.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %importing_slots_from, i64 0, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isClusterHealthy() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %state, align 8
  %cmp = icmp eq i32 %1, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local ptr @getNodeBySlot(i32 noundef %slot) #0 {
entry:
  %slot.addr = alloca i32, align 4
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %slots = getelementptr inbounds %struct.clusterState, ptr %0, i32 0, i32 9
  %1 = load i32, ptr %slot.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [16384 x ptr], ptr %slots, i64 0, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define dso_local ptr @clusterNodeHostname(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %hostname = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 22
  %1 = load ptr, ptr %hostname, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local i64 @clusterNodeReplOffset(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %repl_offset = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 20
  %1 = load i64, ptr %repl_offset, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterAllowFailoverCmd(ptr noundef %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %1, ptr noundef @.str.305)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define dso_local void @clusterPromoteSelfToMaster() #0 {
entry:
  call void @replicationUnsetMaster()
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @connSetPrivateData(ptr noundef %conn, ptr noundef %data) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %1 = load ptr, ptr %conn.addr, align 8
  %private_data = getelementptr inbounds %struct.connection, ptr %1, i32 0, i32 7
  store ptr %0, ptr %private_data, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @connAddr(ptr noundef %conn, ptr noundef %ip, i64 noundef %ip_len, ptr noundef %port, i32 noundef %remote) #0 {
entry:
  %retval = alloca i32, align 4
  %conn.addr = alloca ptr, align 8
  %ip.addr = alloca ptr, align 8
  %ip_len.addr = alloca i64, align 8
  %port.addr = alloca ptr, align 8
  %remote.addr = alloca i32, align 4
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i64 %ip_len, ptr %ip_len.addr, align 8
  store ptr %port, ptr %port.addr, align 8
  store i32 %remote, ptr %remote.addr, align 4
  %0 = load ptr, ptr %conn.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %type, align 8
  %addr = getelementptr inbounds %struct.ConnectionType, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %addr, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load ptr, ptr %conn.addr, align 8
  %type2 = getelementptr inbounds %struct.connection, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %type2, align 8
  %addr3 = getelementptr inbounds %struct.ConnectionType, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %addr3, align 8
  %7 = load ptr, ptr %conn.addr, align 8
  %8 = load ptr, ptr %ip.addr, align 8
  %9 = load i64, ptr %ip_len.addr, align 8
  %10 = load ptr, ptr %port.addr, align 8
  %11 = load i32, ptr %remote.addr, align 4
  %call = call i32 %6(ptr noundef %7, ptr noundef %8, i64 noundef %9, ptr noundef %10, i32 noundef %11)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: allocsize(0)
declare noalias ptr @zcalloc(i64 noundef) #8

; Function Attrs: nounwind uwtable
define internal void @clusterBuildMessageHdr(ptr noundef %hdr, i32 noundef %type, i64 noundef %msglen) #0 {
entry:
  %hdr.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %msglen.addr = alloca i64, align 8
  %offset = alloca i64, align 8
  %master = alloca ptr, align 8
  %announced_tcp_port = alloca i32, align 4
  %announced_tls_port = alloca i32, align 4
  %announced_cport = alloca i32, align 4
  store ptr %hdr, ptr %hdr.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i64 %msglen, ptr %msglen.addr, align 8
  %0 = load ptr, ptr @myself, align 8
  %flags = getelementptr inbounds %struct._clusterNode, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr @myself, align 8
  %slaveof = getelementptr inbounds %struct._clusterNode, ptr %2, i32 0, i32 11
  %3 = load ptr, ptr %slaveof, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %4 = load ptr, ptr @myself, align 8
  %slaveof2 = getelementptr inbounds %struct._clusterNode, ptr %4, i32 0, i32 11
  %5 = load ptr, ptr %slaveof2, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  %6 = load ptr, ptr @myself, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %5, %cond.true ], [ %6, %cond.false ]
  store ptr %cond, ptr %master, align 8
  %call = call zeroext i16 @htons(i16 noundef zeroext 1) #14
  %7 = load ptr, ptr %hdr.addr, align 8
  %ver = getelementptr inbounds %struct.clusterMsg, ptr %7, i32 0, i32 2
  store i16 %call, ptr %ver, align 8
  %8 = load ptr, ptr %hdr.addr, align 8
  %sig = getelementptr inbounds %struct.clusterMsg, ptr %8, i32 0, i32 0
  %arrayidx = getelementptr inbounds [4 x i8], ptr %sig, i64 0, i64 0
  store i8 82, ptr %arrayidx, align 8
  %9 = load ptr, ptr %hdr.addr, align 8
  %sig3 = getelementptr inbounds %struct.clusterMsg, ptr %9, i32 0, i32 0
  %arrayidx4 = getelementptr inbounds [4 x i8], ptr %sig3, i64 0, i64 1
  store i8 67, ptr %arrayidx4, align 1
  %10 = load ptr, ptr %hdr.addr, align 8
  %sig5 = getelementptr inbounds %struct.clusterMsg, ptr %10, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [4 x i8], ptr %sig5, i64 0, i64 2
  store i8 109, ptr %arrayidx6, align 2
  %11 = load ptr, ptr %hdr.addr, align 8
  %sig7 = getelementptr inbounds %struct.clusterMsg, ptr %11, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [4 x i8], ptr %sig7, i64 0, i64 3
  store i8 98, ptr %arrayidx8, align 1
  %12 = load i32, ptr %type.addr, align 4
  %conv = trunc i32 %12 to i16
  %call9 = call zeroext i16 @htons(i16 noundef zeroext %conv) #14
  %13 = load ptr, ptr %hdr.addr, align 8
  %type10 = getelementptr inbounds %struct.clusterMsg, ptr %13, i32 0, i32 4
  store i16 %call9, ptr %type10, align 4
  %14 = load ptr, ptr %hdr.addr, align 8
  %sender = getelementptr inbounds %struct.clusterMsg, ptr %14, i32 0, i32 9
  %arraydecay = getelementptr inbounds [40 x i8], ptr %sender, i64 0, i64 0
  %15 = load ptr, ptr @myself, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %15, i32 0, i32 1
  %arraydecay11 = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 8 %arraydecay11, i64 40, i1 false)
  %16 = load ptr, ptr %hdr.addr, align 8
  %myip = getelementptr inbounds %struct.clusterMsg, ptr %16, i32 0, i32 12
  %arraydecay12 = getelementptr inbounds [46 x i8], ptr %myip, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay12, i8 0, i64 46, i1 false)
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 373), align 8
  %tobool13 = icmp ne ptr %17, null
  br i1 %tobool13, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %18 = load ptr, ptr %hdr.addr, align 8
  %myip14 = getelementptr inbounds %struct.clusterMsg, ptr %18, i32 0, i32 12
  %arraydecay15 = getelementptr inbounds [46 x i8], ptr %myip14, i64 0, i64 0
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 373), align 8
  %call16 = call i64 @redis_strlcpy(ptr noundef %arraydecay15, ptr noundef %19, i64 noundef 46)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  call void @deriveAnnouncedPorts(ptr noundef %announced_tcp_port, ptr noundef %announced_tls_port, ptr noundef %announced_cport)
  %20 = load ptr, ptr %hdr.addr, align 8
  %myslots = getelementptr inbounds %struct.clusterMsg, ptr %20, i32 0, i32 10
  %arraydecay17 = getelementptr inbounds [2048 x i8], ptr %myslots, i64 0, i64 0
  %21 = load ptr, ptr %master, align 8
  %slots = getelementptr inbounds %struct._clusterNode, ptr %21, i32 0, i32 5
  %arraydecay18 = getelementptr inbounds [2048 x i8], ptr %slots, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay17, ptr align 8 %arraydecay18, i64 2048, i1 false)
  %22 = load ptr, ptr %hdr.addr, align 8
  %slaveof19 = getelementptr inbounds %struct.clusterMsg, ptr %22, i32 0, i32 11
  %arraydecay20 = getelementptr inbounds [40 x i8], ptr %slaveof19, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay20, i8 0, i64 40, i1 false)
  %23 = load ptr, ptr @myself, align 8
  %slaveof21 = getelementptr inbounds %struct._clusterNode, ptr %23, i32 0, i32 11
  %24 = load ptr, ptr %slaveof21, align 8
  %cmp = icmp ne ptr %24, null
  br i1 %cmp, label %if.then23, label %if.end29

if.then23:                                        ; preds = %if.end
  %25 = load ptr, ptr %hdr.addr, align 8
  %slaveof24 = getelementptr inbounds %struct.clusterMsg, ptr %25, i32 0, i32 11
  %arraydecay25 = getelementptr inbounds [40 x i8], ptr %slaveof24, i64 0, i64 0
  %26 = load ptr, ptr @myself, align 8
  %slaveof26 = getelementptr inbounds %struct._clusterNode, ptr %26, i32 0, i32 11
  %27 = load ptr, ptr %slaveof26, align 8
  %name27 = getelementptr inbounds %struct._clusterNode, ptr %27, i32 0, i32 1
  %arraydecay28 = getelementptr inbounds [40 x i8], ptr %name27, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay25, ptr align 8 %arraydecay28, i64 40, i1 false)
  br label %if.end29

if.end29:                                         ; preds = %if.then23, %if.end
  %28 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool30 = icmp ne i32 %28, 0
  br i1 %tobool30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end29
  %29 = load i32, ptr %announced_tls_port, align 4
  %conv32 = trunc i32 %29 to i16
  %call33 = call zeroext i16 @htons(i16 noundef zeroext %conv32) #14
  %30 = load ptr, ptr %hdr.addr, align 8
  %port = getelementptr inbounds %struct.clusterMsg, ptr %30, i32 0, i32 3
  store i16 %call33, ptr %port, align 2
  %31 = load i32, ptr %announced_tcp_port, align 4
  %conv34 = trunc i32 %31 to i16
  %call35 = call zeroext i16 @htons(i16 noundef zeroext %conv34) #14
  %32 = load ptr, ptr %hdr.addr, align 8
  %pport = getelementptr inbounds %struct.clusterMsg, ptr %32, i32 0, i32 15
  store i16 %call35, ptr %pport, align 2
  br label %if.end42

if.else:                                          ; preds = %if.end29
  %33 = load i32, ptr %announced_tcp_port, align 4
  %conv36 = trunc i32 %33 to i16
  %call37 = call zeroext i16 @htons(i16 noundef zeroext %conv36) #14
  %34 = load ptr, ptr %hdr.addr, align 8
  %port38 = getelementptr inbounds %struct.clusterMsg, ptr %34, i32 0, i32 3
  store i16 %call37, ptr %port38, align 2
  %35 = load i32, ptr %announced_tls_port, align 4
  %conv39 = trunc i32 %35 to i16
  %call40 = call zeroext i16 @htons(i16 noundef zeroext %conv39) #14
  %36 = load ptr, ptr %hdr.addr, align 8
  %pport41 = getelementptr inbounds %struct.clusterMsg, ptr %36, i32 0, i32 15
  store i16 %call40, ptr %pport41, align 2
  br label %if.end42

if.end42:                                         ; preds = %if.else, %if.then31
  %37 = load i32, ptr %announced_cport, align 4
  %conv43 = trunc i32 %37 to i16
  %call44 = call zeroext i16 @htons(i16 noundef zeroext %conv43) #14
  %38 = load ptr, ptr %hdr.addr, align 8
  %cport = getelementptr inbounds %struct.clusterMsg, ptr %38, i32 0, i32 16
  store i16 %call44, ptr %cport, align 8
  %39 = load ptr, ptr @myself, align 8
  %flags45 = getelementptr inbounds %struct._clusterNode, ptr %39, i32 0, i32 3
  %40 = load i32, ptr %flags45, align 8
  %conv46 = trunc i32 %40 to i16
  %call47 = call zeroext i16 @htons(i16 noundef zeroext %conv46) #14
  %41 = load ptr, ptr %hdr.addr, align 8
  %flags48 = getelementptr inbounds %struct.clusterMsg, ptr %41, i32 0, i32 17
  store i16 %call47, ptr %flags48, align 2
  %42 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %state = getelementptr inbounds %struct.clusterState, ptr %42, i32 0, i32 2
  %43 = load i32, ptr %state, align 8
  %conv49 = trunc i32 %43 to i8
  %44 = load ptr, ptr %hdr.addr, align 8
  %state50 = getelementptr inbounds %struct.clusterMsg, ptr %44, i32 0, i32 18
  store i8 %conv49, ptr %state50, align 4
  %45 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %currentEpoch = getelementptr inbounds %struct.clusterState, ptr %45, i32 0, i32 1
  %46 = load i64, ptr %currentEpoch, align 8
  %call51 = call i64 @intrev64(i64 noundef %46)
  %47 = load ptr, ptr %hdr.addr, align 8
  %currentEpoch52 = getelementptr inbounds %struct.clusterMsg, ptr %47, i32 0, i32 6
  store i64 %call51, ptr %currentEpoch52, align 8
  %48 = load ptr, ptr %master, align 8
  %configEpoch = getelementptr inbounds %struct._clusterNode, ptr %48, i32 0, i32 4
  %49 = load i64, ptr %configEpoch, align 8
  %call53 = call i64 @intrev64(i64 noundef %49)
  %50 = load ptr, ptr %hdr.addr, align 8
  %configEpoch54 = getelementptr inbounds %struct.clusterMsg, ptr %50, i32 0, i32 7
  store i64 %call53, ptr %configEpoch54, align 8
  %51 = load ptr, ptr @myself, align 8
  %flags55 = getelementptr inbounds %struct._clusterNode, ptr %51, i32 0, i32 3
  %52 = load i32, ptr %flags55, align 8
  %and56 = and i32 %52, 2
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %if.then58, label %if.else60

if.then58:                                        ; preds = %if.end42
  %call59 = call i64 @replicationGetSlaveOffset()
  store i64 %call59, ptr %offset, align 8
  br label %if.end61

if.else60:                                        ; preds = %if.end42
  %53 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  store i64 %53, ptr %offset, align 8
  br label %if.end61

if.end61:                                         ; preds = %if.else60, %if.then58
  %54 = load i64, ptr %offset, align 8
  %call62 = call i64 @intrev64(i64 noundef %54)
  %55 = load ptr, ptr %hdr.addr, align 8
  %offset63 = getelementptr inbounds %struct.clusterMsg, ptr %55, i32 0, i32 8
  store i64 %call62, ptr %offset63, align 8
  %56 = load ptr, ptr @myself, align 8
  %call64 = call i32 @clusterNodeIsMaster(ptr noundef %56)
  %tobool65 = icmp ne i32 %call64, 0
  br i1 %tobool65, label %land.lhs.true66, label %if.end72

land.lhs.true66:                                  ; preds = %if.end61
  %57 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %mf_end = getelementptr inbounds %struct.clusterState, ptr %57, i32 0, i32 17
  %58 = load i64, ptr %mf_end, align 8
  %tobool67 = icmp ne i64 %58, 0
  br i1 %tobool67, label %if.then68, label %if.end72

if.then68:                                        ; preds = %land.lhs.true66
  %59 = load ptr, ptr %hdr.addr, align 8
  %mflags = getelementptr inbounds %struct.clusterMsg, ptr %59, i32 0, i32 19
  %arrayidx69 = getelementptr inbounds [3 x i8], ptr %mflags, i64 0, i64 0
  %60 = load i8, ptr %arrayidx69, align 1
  %conv70 = zext i8 %60 to i32
  %or = or i32 %conv70, 1
  %conv71 = trunc i32 %or to i8
  store i8 %conv71, ptr %arrayidx69, align 1
  br label %if.end72

if.end72:                                         ; preds = %if.then68, %land.lhs.true66, %if.end61
  %61 = load i64, ptr %msglen.addr, align 8
  %conv73 = trunc i64 %61 to i32
  %call74 = call i32 @htonl(i32 noundef %conv73) #14
  %62 = load ptr, ptr %hdr.addr, align 8
  %totlen = getelementptr inbounds %struct.clusterMsg, ptr %62, i32 0, i32 1
  store i32 %call74, ptr %totlen, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @freeClusterLinkOnBufferLimitReached(ptr noundef %link) #0 {
entry:
  %link.addr = alloca ptr, align 8
  %mem_link = alloca i64, align 8
  store ptr %link, ptr %link.addr, align 8
  %0 = load ptr, ptr %link.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 383), align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end10

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %link.addr, align 8
  %send_msg_queue_mem = getelementptr inbounds %struct.clusterLink, ptr %2, i32 0, i32 4
  %3 = load i64, ptr %send_msg_queue_mem, align 8
  store i64 %3, ptr %mem_link, align 8
  %4 = load i64, ptr %mem_link, align 8
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 383), align 8
  %cmp2 = icmp ugt i64 %4, %5
  br i1 %cmp2, label %if.then3, label %if.end10

if.then3:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then3
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp4 = icmp slt i32 3, %6
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %do.body
  br label %do.end

if.end6:                                          ; preds = %do.body
  %7 = load ptr, ptr %link.addr, align 8
  %inbound = getelementptr inbounds %struct.clusterLink, ptr %7, i32 0, i32 9
  %8 = load i32, ptr %inbound, align 8
  %tobool = icmp ne i32 %8, 0
  %cond = select i1 %tobool, ptr @.str.161, ptr @.str.162
  %9 = load ptr, ptr %link.addr, align 8
  %node = getelementptr inbounds %struct.clusterLink, ptr %9, i32 0, i32 8
  %10 = load ptr, ptr %node, align 8
  %tobool7 = icmp ne ptr %10, null
  br i1 %tobool7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end6
  %11 = load ptr, ptr %link.addr, align 8
  %node8 = getelementptr inbounds %struct.clusterLink, ptr %11, i32 0, i32 8
  %12 = load ptr, ptr %node8, align 8
  %name = getelementptr inbounds %struct._clusterNode, ptr %12, i32 0, i32 1
  %arraydecay = getelementptr inbounds [40 x i8], ptr %name, i64 0, i64 0
  br label %cond.end

cond.false:                                       ; preds = %if.end6
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond9 = phi ptr [ %arraydecay, %cond.true ], [ @.str.304, %cond.false ]
  %13 = load i64, ptr %mem_link, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.307, ptr noundef %cond, ptr noundef %cond9, i64 noundef %13)
  br label %do.end

do.end:                                           ; preds = %cond.end, %if.then5
  %14 = load ptr, ptr %link.addr, align 8
  call void @freeClusterLink(ptr noundef %14)
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 367), align 8
  %stat_cluster_links_buffer_limit_exceeded = getelementptr inbounds %struct.clusterState, ptr %15, i32 0, i32 26
  %16 = load i64, ptr %stat_cluster_links_buffer_limit_exceeded, align 8
  %inc = add i64 %16, 1
  store i64 %inc, ptr %stat_cluster_links_buffer_limit_exceeded, align 8
  br label %if.end10

if.end10:                                         ; preds = %do.end, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @connCreate(ptr noundef %ct) #0 {
entry:
  %ct.addr = alloca ptr, align 8
  store ptr %ct, ptr %ct.addr, align 8
  %0 = load ptr, ptr %ct.addr, align 8
  %conn_create = getelementptr inbounds %struct.ConnectionType, ptr %0, i32 0, i32 9
  %1 = load ptr, ptr %conn_create, align 8
  %call = call ptr %1()
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal i32 @connConnect(ptr noundef %conn, ptr noundef %addr, i32 noundef %port, ptr noundef %src_addr, ptr noundef %connect_handler) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %addr.addr = alloca ptr, align 8
  %port.addr = alloca i32, align 4
  %src_addr.addr = alloca ptr, align 8
  %connect_handler.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i32 %port, ptr %port.addr, align 4
  store ptr %src_addr, ptr %src_addr.addr, align 8
  store ptr %connect_handler, ptr %connect_handler.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %connect = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 13
  %2 = load ptr, ptr %connect, align 8
  %3 = load ptr, ptr %conn.addr, align 8
  %4 = load ptr, ptr %addr.addr, align 8
  %5 = load i32, ptr %port.addr, align 4
  %6 = load ptr, ptr %src_addr.addr, align 8
  %7 = load ptr, ptr %connect_handler.addr, align 8
  %call = call i32 %2(ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef %6, ptr noundef %7)
  ret i32 %call
}

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #3 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nocallback nofree nosync nounwind willreturn }
attributes #5 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #10 = { allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #12 = { nounwind willreturn memory(read) }
attributes #13 = { noreturn nounwind }
attributes #14 = { nounwind willreturn memory(none) }
attributes #15 = { nounwind }
attributes #16 = { allocsize(0) }
attributes #17 = { allocsize(1) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
