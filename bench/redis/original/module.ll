target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.redisServer = type { i32, i64, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i32, i64, i32, i32, i32, ptr, ptr, i32, i32, i64, ptr, ptr, ptr, ptr, [2 x i32], i32, i32, i32, i32, i32, [16 x ptr], i32, ptr, ptr, i32, [8 x %struct.connListener], i32, %struct.connListener, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i32, ptr, [3 x %struct.pause_event], [256 x i8], ptr, i64, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, ptr, i64, i64, i64, %struct.malloc_stats, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, [4 x i64], i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [7 x %struct.anon.2], i64, i64, i64, i64, i64, i64, [4 x %struct.durationStats], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i32, ptr, [3 x %struct.clientBufferLimitsConfig], i32, i32, ptr, i32, i32, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, ptr, i32, i64, i64, i64, i64, ptr, i32, ptr, i32, i32, i32, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, ptr, i32, i32, ptr, i32, i32, i32, [2 x i32], i32, %struct.redisOpArray, i32, ptr, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [41 x i8], [41 x i8], i64, i64, i64, i64, i32, i32, ptr, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, ptr, ptr, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, ptr, i32, ptr, i64, i32, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i64, i32, ptr, i32, i32, i64, i64, i32, i32, i32, i32, i32, i64, [3 x i32], i32, i32, i32, [9 x i32], ptr, ptr, i32, i64, ptr, ptr, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i32, i64, i64, i64, i64, i64, ptr, ptr, i32, ptr, i32, i32, i32, i64, i64, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i64, i32, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, i64, ptr, i32, %struct.aclInfo, i32, i64, i32, i32, i32, %struct.redisTLSContextConfig, ptr, ptr, ptr, ptr, ptr, i64, i32, ptr, i32, i32, i32, i64, i32, ptr }
%struct.connListener = type { [16 x i32], i32, ptr, i32, i32, ptr, ptr }
%struct.pause_event = type { i32, i64 }
%struct.malloc_stats = type { i64, i64, i64, i64, i64 }
%struct.anon.2 = type { i64, i64, [16 x i64], i32 }
%struct.durationStats = type { i64, i64, i64 }
%struct.clientBufferLimitsConfig = type { i64, i64, i64 }
%struct.redisOpArray = type { ptr, i32, i32 }
%struct.aclInfo = type { i64, i64, i64, i64 }
%struct.redisTLSContextConfig = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32 }
%struct.sharedObjectsStruct = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [4 x ptr], [4 x ptr], [4 x ptr], [4 x ptr], ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr], [10000 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], ptr, ptr }
%struct.anon.15 = type { i64, ptr }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.RedisModuleForkInfo = type { ptr, ptr }
%struct.dictType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.RedisModuleDefragCtx = type { i64, ptr, ptr, i32 }
%struct.RedisModuleCtx = type { ptr, ptr, ptr, ptr, ptr, i32, i32, i32, ptr, i32, ptr, ptr, ptr, ptr, i64, ptr }
%struct.RedisModulePoolAllocBlock = type { i32, i32, ptr, [0 x i8] }
%struct.client = type { i64, i64, ptr, i32, ptr, ptr, ptr, ptr, ptr, i64, i64, i32, ptr, i32, i32, ptr, i64, ptr, ptr, ptr, ptr, i32, i32, i64, ptr, i64, ptr, i64, i64, i64, i32, ptr, i64, i64, i32, i32, i32, i32, i64, i64, ptr, i64, i64, i64, i64, i64, i64, i64, i64, [41 x i8], i32, ptr, i32, i32, %struct.multiState, %struct.blockingState, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, i32, ptr, ptr, ptr, i64, %struct.listNode, i64, i64, i32, i64, ptr }
%struct.multiState = type { ptr, i32, i32, i32, i64, i32 }
%struct.blockingState = type { i32, i64, i32, ptr, i32, i32, i64, ptr, ptr }
%struct.listNode = type { ptr, ptr, ptr }
%struct.RedisModuleAsyncRMCallPromise = type { i64, ptr, ptr, ptr, ptr, ptr }
%struct.RedisModuleKey = type { ptr, ptr, ptr, ptr, ptr, i32, %union.anon }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.listTypeEntry, i64 }
%struct.listTypeEntry = type { ptr, ptr, %struct.quicklistEntry }
%struct.quicklistEntry = type { ptr, ptr, ptr, ptr, i64, i64, i32 }
%struct.anon.1 = type { %struct.streamID, i64, i32 }
%struct.streamID = type { i64, i64 }
%struct.RedisModule = type { ptr, ptr, i32, i32, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i64 }
%struct.AutoMemEntry = type { ptr, i32 }
%struct.redisDb = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i64, i64, ptr, i32, [2 x %struct.dbDictState] }
%struct.dbDictState = type { i32, i32, i64, i64, ptr }
%struct.list = type { ptr, ptr, ptr, ptr, ptr, i64 }
%struct.clientReplyBlock = type { i64, i64, [0 x i8] }
%struct.redisCommand = type { ptr, ptr, ptr, ptr, i32, ptr, ptr, i32, ptr, i32, ptr, i32, ptr, i32, i64, i64, ptr, i32, ptr, i32, ptr, ptr, i64, i64, i64, i64, i32, ptr, ptr, %struct.keySpec, ptr, ptr, ptr }
%struct.keySpec = type { ptr, i64, i32, %union.anon.3, i32, %union.anon.6 }
%union.anon.3 = type { %struct.anon.5 }
%struct.anon.5 = type { ptr, i32 }
%union.anon.6 = type { %struct.anon.7 }
%struct.anon.7 = type { i32, i32, i32 }
%struct.RedisModuleCommand = type { ptr, ptr, ptr }
%struct.redisObject = type { i32, i32, ptr }
%struct.getKeysResult = type { [256 x %struct.keyReference], ptr, i32, i32 }
%struct.keyReference = type { i32, i32 }
%struct.anon.4 = type { i32 }
%struct.redisCommandArg = type { ptr, i32, i32, ptr, ptr, ptr, i32, ptr, i32, ptr, ptr }
%struct.RedisModuleCommandInfo = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, ptr }
%struct.RedisModuleCommandHistoryEntry = type { ptr, ptr }
%struct.commandHistory = type { ptr, ptr }
%struct.RedisModuleCommandKeySpec = type { ptr, i64, i32, %union.anon.9, i32, %union.anon.12 }
%union.anon.9 = type { %struct.anon.11 }
%struct.anon.11 = type { ptr, i32 }
%union.anon.12 = type { %struct.anon.13 }
%struct.anon.13 = type { i32, i32, i32 }
%struct.anon.10 = type { i32 }
%struct.anon.14 = type { i32, i32, i32 }
%struct.anon.8 = type { i32, i32, i32 }
%struct.RedisModuleCommandInfoVersion = type { i32, i64, i64, i64 }
%struct.RedisModuleCommandArg = type { ptr, i32, i32, ptr, ptr, ptr, i32, ptr, ptr, ptr }
%struct.ModuleConfig = type { ptr, ptr, %union.get_fn, %union.set_fn, ptr, ptr }
%union.get_fn = type { ptr }
%union.set_fn = type { ptr }
%struct.RedisModuleBlockedClient = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i64, i64 }
%struct.RedisModuleDict = type { ptr }
%struct.RedisModuleServerInfoData = type { ptr }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.RedisModuleStreamID = type { i64, i64 }
%struct.sdshdr8 = type { i8, i8, i8, [0 x i8] }
%struct.sdshdr16 = type <{ i16, i16, i8, [0 x i8] }>
%struct.sdshdr32 = type <{ i32, i32, i8, [0 x i8] }>
%struct.sdshdr64 = type <{ i64, i64, i8, [0 x i8] }>
%struct.user = type { ptr, i32, ptr, ptr, ptr }
%struct.RedisModuleClientInfo = type { i64, i64, i64, [46 x i8], i16, i16 }
%struct.connection = type { ptr, i32, i32, i32, i16, i16, i16, ptr, ptr, ptr, ptr }
%struct.RedisModuleReplicationInfo = type { i64, i32, ptr, i32, ptr, ptr, i64, i64 }
%struct.RedisModuleKeyOptCtx = type { ptr, ptr, i32, i32 }
%struct.listTypeIterator = type { ptr, i8, i8, ptr, ptr }
%struct.anon.0 = type { i32, %struct.zrangespec, %struct.zlexrangespec, i32, i32, ptr, i32 }
%struct.zrangespec = type { double, double, i32, i32 }
%struct.zlexrangespec = type { ptr, ptr, i32, i32 }
%struct.zset = type { ptr, ptr }
%struct.zskiplistNode = type { ptr, double, ptr, [0 x %struct.zskiplistLevel] }
%struct.zskiplistLevel = type { ptr, i64 }
%struct.stream = type { ptr, i64, %struct.streamID, %struct.streamID, %struct.streamID, i64, ptr }
%struct.RedisModuleUser = type { ptr, i32 }
%struct.listIter = type { ptr, i32 }
%struct.RedisModuleCommandFilterCtx = type { ptr, i32, i32, ptr }
%struct.RedisModuleCommandFilter = type { ptr, ptr, i32 }
%struct.RedisModuleType = type { i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, [10 x i8] }
%struct.moduleValue = type { ptr, ptr }
%struct.typemethods = type { i64, ptr, ptr, ptr, ptr, ptr, ptr, %struct.anon.16, %struct.anon.17, %struct.anon.18, %struct.anon.19 }
%struct.anon.16 = type { ptr, ptr, i32 }
%struct.anon.17 = type { ptr, ptr, ptr, ptr }
%struct.anon.18 = type { ptr, ptr, ptr, ptr }
%struct.anon.19 = type { ptr }
%struct.RedisModuleIO = type { i64, ptr, ptr, i32, ptr, ptr, i32, ptr }
%union.anon.20 = type { i64 }
%union.anon.21 = type { i64 }
%struct.RedisModuleDigest = type { [20 x i8], [20 x i8], ptr, i32 }
%struct._rio = type { ptr, ptr, ptr, ptr, ptr, i64, i64, i64, i64, %union.anon.22 }
%union.anon.22 = type { %struct.anon.25 }
%struct.anon.25 = type { ptr, i64, ptr, i64, i64 }
%struct.anon.23 = type { ptr, i64 }
%struct.RedisModuleAuthCtx = type { ptr, ptr }
%struct.RedisModuleKeyspaceSubscriber = type { ptr, ptr, i32, i32 }
%struct.RedisModulePostExecUnitJob = type { ptr, ptr, ptr, ptr, i32 }
%struct.moduleClusterReceiver = type { i64, ptr, ptr, ptr }
%struct.raxIterator = type { i32, ptr, ptr, ptr, i64, i64, [128 x i8], ptr, %struct.raxStack, ptr }
%struct.raxStack = type { ptr, i64, i64, [32 x ptr], i32 }
%struct.RedisModuleTimer = type { ptr, ptr, ptr, i32 }
%struct.EventLoopData = type { ptr, ptr, ptr }
%struct.EventLoopOneShot = type { ptr, ptr }
%struct.ConnectionType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.RedisModuleDictIter = type { ptr, %struct.raxIterator }
%struct.RedisModuleInfoCtx = type { ptr, ptr, ptr, i32, i32, i32 }
%struct.RedisModuleSharedAPI = type { ptr, ptr }
%struct.rax = type { ptr, i64, i64 }
%struct.RedisModuleScanCursor = type { i64, i32 }
%struct.ScanCBData = type { ptr, ptr, ptr }
%struct.ScanKeyCBData = type { ptr, ptr, ptr }
%struct.RedisModuleEvent = type { i64, i64 }
%struct.RedisModuleEventListener = type { ptr, %struct.RedisModuleEvent, ptr }
%struct.RedisModuleModuleChange = type { i64, ptr, i32 }
%struct.RedisModuleKeyInfo = type { i64, ptr }
%struct.RedisModuleFlushInfo = type { i64, i32, i32 }
%struct.KeyInfo = type { i32, ptr, ptr, i32 }
%struct.RedisModuleLoadingProgressInfo = type { i64, i32, i32 }
%struct.moduleLoadQueueEntry = type { ptr, i32, ptr }
%struct.dict = type { ptr, [2 x ptr], [2 x i64], i64, i16, [2 x i8], [0 x ptr] }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }
%struct.configEnum = type { ptr, i32 }
%struct.RedisModuleRdbStream = type { i32, %union.anon.27 }
%union.anon.27 = type { ptr }

@moduleTempClientCount = internal global i64 0, align 8
@moduleTempClients = internal global ptr null, align 8
@moduleTempClientMinCount = internal global i64 0, align 8
@moduleTempClientCap = internal global i64 0, align 8
@server = external global %struct.redisServer, align 8
@.str = private unnamed_addr constant [152 x i8] c"API misuse detected in module %s: RedisModule_ReplyWith*(REDISMODULE_POSTPONED_LEN) not matched by the same number of RedisModule_SetReply*Len() calls.\00", align 1
@.str.1 = private unnamed_addr constant [8 x i8] c"promise\00", align 1
@.str.2 = private unnamed_addr constant [9 x i8] c"module.c\00", align 1
@getMonotonicUs = external global ptr, align 8
@.str.3 = private unnamed_addr constant [8 x i8] c" \0D\0A|@=,\00", align 1
@.str.4 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.6 = private unnamed_addr constant [9 x i8] c"readonly\00", align 1
@.str.7 = private unnamed_addr constant [6 x i8] c"admin\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"deny-oom\00", align 1
@.str.9 = private unnamed_addr constant [12 x i8] c"deny-script\00", align 1
@.str.10 = private unnamed_addr constant [14 x i8] c"allow-loading\00", align 1
@.str.11 = private unnamed_addr constant [7 x i8] c"pubsub\00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"random\00", align 1
@.str.13 = private unnamed_addr constant [9 x i8] c"blocking\00", align 1
@.str.14 = private unnamed_addr constant [12 x i8] c"allow-stale\00", align 1
@.str.15 = private unnamed_addr constant [11 x i8] c"no-monitor\00", align 1
@.str.16 = private unnamed_addr constant [11 x i8] c"no-slowlog\00", align 1
@.str.17 = private unnamed_addr constant [5 x i8] c"fast\00", align 1
@.str.18 = private unnamed_addr constant [8 x i8] c"no-auth\00", align 1
@.str.19 = private unnamed_addr constant [14 x i8] c"may-replicate\00", align 1
@.str.20 = private unnamed_addr constant [12 x i8] c"getkeys-api\00", align 1
@.str.21 = private unnamed_addr constant [16 x i8] c"getchannels-api\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"no-cluster\00", align 1
@.str.23 = private unnamed_addr constant [18 x i8] c"no-mandatory-keys\00", align 1
@.str.24 = private unnamed_addr constant [11 x i8] c"allow-busy\00", align 1
@.str.25 = private unnamed_addr constant [73 x i8] c"dictAdd(server.commands, sdsdup(declared_name), cp->rediscmd) == DICT_OK\00", align 1
@.str.26 = private unnamed_addr constant [78 x i8] c"dictAdd(server.orig_commands, sdsdup(declared_name), cp->rediscmd) == DICT_OK\00", align 1
@.str.27 = private unnamed_addr constant [16 x i8] c"count < INT_MAX\00", align 1
@.str.28 = private unnamed_addr constant [47 x i8] c"Unrecognized categories flag %s on module load\00", align 1
@.str.29 = private unnamed_addr constant [42 x i8] c"count < SIZE_MAX / sizeof(commandHistory)\00", align 1
@.str.30 = private unnamed_addr constant [26 x i8] c"Unknown begin_search_type\00", align 1
@.str.31 = private unnamed_addr constant [23 x i8] c"Unknown find_keys_type\00", align 1
@modules = dso_local global ptr null, align 8
@RM_Yield.yield_nesting = internal global i32 0, align 4
@.str.32 = private unnamed_addr constant [41 x i8] c"(NULL string reply referenced in module)\00", align 1
@.str.33 = private unnamed_addr constant [150 x i8] c"Module attempted to use an in-place string modify operation with a string referenced multiple times. Please check the code for API usage correctness.\00", align 1
@.str.34 = private unnamed_addr constant [4 x i8] c"-%s\00", align 1
@.str.35 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"\0D\0A\00", align 1
@shared = external global %struct.sharedObjectsStruct, align 8
@.str.37 = private unnamed_addr constant [35 x i8] c"Invalid module empty reply type %d\00", align 1
@.str.38 = private unnamed_addr constant [29 x i8] c"Invalid module reply type %d\00", align 1
@.str.39 = private unnamed_addr constant [148 x i8] c"API misuse detected in module %s: RedisModule_ReplySet*Length() called without previous RedisModule_ReplyWith*(ctx,REDISMODULE_POSTPONED_LEN) call.\00", align 1
@.str.40 = private unnamed_addr constant [4 x i8] c"txt\00", align 1
@.str.41 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.42 = private unnamed_addr constant [19 x i8] c"<dma-empty-string>\00", align 1
@.str.43 = private unnamed_addr constant [18 x i8] c"key->iter != NULL\00", align 1
@.str.44 = private unnamed_addr constant [44 x i8] c"listTypeNext(key->iter, &key->u.list.entry)\00", align 1
@.str.45 = private unnamed_addr constant [26 x i8] c"Unsupported zset encoding\00", align 1
@.str.46 = private unnamed_addr constant [77 x i8] c"cannot run as user, no user directly attached to context or context's client\00", align 1
@.str.47 = private unnamed_addr constant [43 x i8] c"command '%S' is not allowed on script mode\00", align 1
@.str.48 = private unnamed_addr constant [58 x i8] c"Write command '%S' was called while write is not allowed.\00", align 1
@.str.49 = private unnamed_addr constant [13 x i8] c"-NOPERM %S\0D\0A\00", align 1
@.str.50 = private unnamed_addr constant [76 x i8] c"Can not execute a write command '%S' while the cluster is down and readonly\00", align 1
@.str.51 = private unnamed_addr constant [57 x i8] c"Can not execute a command '%S' while the cluster is down\00", align 1
@.str.52 = private unnamed_addr constant [54 x i8] c"Attempted to access a non local key in a cluster node\00", align 1
@.str.53 = private unnamed_addr constant [37 x i8] c"flags & REDISMODULE_ARGV_ALLOW_BLOCK\00", align 1
@.str.54 = private unnamed_addr constant [12 x i8] c"ctx->module\00", align 1
@.str.55 = private unnamed_addr constant [65 x i8] c"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\00", align 1
@ModuleTypeNameCharSet = dso_local global ptr @.str.55, align 8
@moduleTypeLookupModuleByID.cache = internal global [3 x %struct.anon.15] zeroinitializer, align 16
@.str.56 = private unnamed_addr constant [42 x i8] c"cmd->proc == RedisModuleCommandDispatcher\00", align 1
@.str.57 = private unnamed_addr constant [34 x i8] c"not supported for this module key\00", align 1
@.str.58 = private unnamed_addr constant [26 x i8] c"module key failed to copy\00", align 1
@.str.59 = private unnamed_addr constant [154 x i8] c"Error loading data from RDB (short read or EOF). Read performed by module '%s' about type '%s' after reading '%llu' bytes of a value for key named: '%s'.\00", align 1
@.str.60 = private unnamed_addr constant [7 x i8] c"(null)\00", align 1
@.str.61 = private unnamed_addr constant [79 x i8] c"Fatal: AOF method for module data type '%s' tried to emit unknown command '%s'\00", align 1
@.str.62 = private unnamed_addr constant [114 x i8] c"Fatal: AOF method for module data type '%s' tried to call RedisModule_EmitAOF() with wrong format specifiers '%s'\00", align 1
@.str.63 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.64 = private unnamed_addr constant [8 x i8] c"verbose\00", align 1
@.str.65 = private unnamed_addr constant [7 x i8] c"notice\00", align 1
@.str.66 = private unnamed_addr constant [8 x i8] c"warning\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"<%s> \00", align 1
@.str.68 = private unnamed_addr constant [7 x i8] c"module\00", align 1
@.str.69 = private unnamed_addr constant [24 x i8] c"timeout is out of range\00", align 1
@.str.70 = private unnamed_addr constant [47 x i8] c"Blocking module command called from Lua script\00", align 1
@.str.71 = private unnamed_addr constant [48 x i8] c"Blocking module command called from transaction\00", align 1
@.str.72 = private unnamed_addr constant [61 x i8] c"Blocking module command called from a Reply callback context\00", align 1
@.str.73 = private unnamed_addr constant [75 x i8] c"Clients undergoing module based authentication can only be blocked on auth\00", align 1
@moduleAuthCallbacks = internal global ptr null, align 8
@.str.74 = private unnamed_addr constant [35 x i8] c"result == REDISMODULE_AUTH_HANDLED\00", align 1
@.str.75 = private unnamed_addr constant [83 x i8] c"Module blocking client on auth when not currently undergoing module authentication\00", align 1
@moduleUnblockedClientsMutex = internal global %union.pthread_mutex_t zeroinitializer, align 8
@moduleUnblockedClients = internal global ptr null, align 8
@.str.76 = private unnamed_addr constant [2 x i8] c"A\00", align 1
@.str.77 = private unnamed_addr constant [30 x i8] c"server.execution_nesting == 0\00", align 1
@.str.78 = private unnamed_addr constant [30 x i8] c"server.execution_nesting == 1\00", align 1
@moduleGIL = internal global %union.pthread_mutex_t zeroinitializer, align 8
@moduleKeyspaceSubscribers = internal global ptr null, align 8
@modulePostExecUnitJobs = internal global ptr null, align 8
@clusterReceivers = internal global [255 x ptr] zeroinitializer, align 16
@aeTimer = dso_local global i64 -1, align 8
@Timers = internal global ptr null, align 8
@.str.79 = private unnamed_addr constant [2 x i8] c"^\00", align 1
@moduleEventLoopMutex = internal global %union.pthread_mutex_t zeroinitializer, align 8
@moduleEventLoopOneShots = dso_local global ptr null, align 8
@DefaultUser = external global ptr, align 8
@.str.80 = private unnamed_addr constant [13 x i8] c"user != NULL\00", align 1
@.str.81 = private unnamed_addr constant [4 x i8] c"_%s\00", align 1
@.str.82 = private unnamed_addr constant [7 x i8] c"# %S\0D\0A\00", align 1
@.str.83 = private unnamed_addr constant [7 x i8] c"%s_%s:\00", align 1
@.str.84 = private unnamed_addr constant [7 x i8] c"%s=%S,\00", align 1
@.str.85 = private unnamed_addr constant [11 x i8] c"%s_%s:%S\0D\0A\00", align 1
@.str.86 = private unnamed_addr constant [7 x i8] c"%s=%s,\00", align 1
@.str.87 = private unnamed_addr constant [11 x i8] c"%s_%s:%s\0D\0A\00", align 1
@.str.88 = private unnamed_addr constant [10 x i8] c"%s=%.17g,\00", align 1
@.str.89 = private unnamed_addr constant [14 x i8] c"%s_%s:%.17g\0D\0A\00", align 1
@.str.90 = private unnamed_addr constant [7 x i8] c"%s=%I,\00", align 1
@.str.91 = private unnamed_addr constant [11 x i8] c"%s_%s:%I\0D\0A\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"%s=%U,\00", align 1
@.str.93 = private unnamed_addr constant [11 x i8] c"%s_%s:%U\0D\0A\00", align 1
@moduleCommandFilters = internal global ptr null, align 8
@.str.94 = private unnamed_addr constant [24 x i8] c"str->type == OBJ_STRING\00", align 1
@.str.95 = private unnamed_addr constant [18 x i8] c"redis-module-fork\00", align 1
@.str.96 = private unnamed_addr constant [26 x i8] c"Can't fork for module: %s\00", align 1
@moduleForkInfo = internal global %struct.RedisModuleForkInfo zeroinitializer, align 8
@.str.97 = private unnamed_addr constant [30 x i8] c"Module fork started pid: %ld \00", align 1
@.str.98 = private unnamed_addr constant [12 x i8] c"Module fork\00", align 1
@.str.99 = private unnamed_addr constant [39 x i8] c"Killing running module fork child: %ld\00", align 1
@.str.100 = private unnamed_addr constant [55 x i8] c"Module fork exited pid: %ld, retcode: %d, bysignal: %d\00", align 1
@moduleEventVersions = internal global [18 x i64] [i64 1, i64 -1, i64 1, i64 -1, i64 1, i64 -1, i64 -1, i64 -1, i64 1, i64 1, i64 1, i64 1, i64 -1, i64 -1, i64 -1, i64 -1, i64 -1, i64 1], align 16
@RedisModule_EventListeners = dso_local global ptr null, align 8
@.str.101 = private unnamed_addr constant [83 x i8] c"modulePopulateClientInfoStructure(&civ1,data, el->event.dataver) == REDISMODULE_OK\00", align 1
@.str.102 = private unnamed_addr constant [82 x i8] c"modulePopulateReplicationInfoStructure(&riv1,el->event.dataver) == REDISMODULE_OK\00", align 1
@processModuleLoadingProgressEvent.next_event = internal global i64 0, align 8
@moduleAPIDictType = dso_local global %struct.dictType { ptr @dictCStringKeyHash, ptr null, ptr null, ptr @dictCStringKeyCompare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@sdsKeyValueHashDictType = dso_local global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@modulesDictType = external global %struct.dictType, align 8
@.str.103 = private unnamed_addr constant [45 x i8] c"Can't create the pipe for module threads: %s\00", align 1
@.str.104 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.105 = private unnamed_addr constant [43 x i8] c"Can't load module from %s: server aborting\00", align 1
@.str.106 = private unnamed_addr constant [92 x i8] c"Module Configuration detected without loadmodule directive or no ApplyConfig call: aborting\00", align 1
@.str.107 = private unnamed_addr constant [65 x i8] c"dictDelete(cmd->subcommands_dict, sub->declared_name) == DICT_OK\00", align 1
@.str.108 = private unnamed_addr constant [54 x i8] c"dictDelete(server.commands, cmd->fullname) == DICT_OK\00", align 1
@.str.109 = private unnamed_addr constant [59 x i8] c"dictDelete(server.orig_commands, cmd->fullname) == DICT_OK\00", align 1
@.str.110 = private unnamed_addr constant [7 x i8] c"CONFIG\00", align 1
@.str.111 = private unnamed_addr constant [41 x i8] c"CONFIG specified without name value pair\00", align 1
@.str.112 = private unnamed_addr constant [5 x i8] c"ARGS\00", align 1
@.str.113 = private unnamed_addr constant [49 x i8] c"Syntax Error from arguments to loadex around %s.\00", align 1
@.str.114 = private unnamed_addr constant [64 x i8] c"Module %s failed to load: It does not have execute permissions.\00", align 1
@.str.115 = private unnamed_addr constant [29 x i8] c"Module %s failed to load: %s\00", align 1
@.str.116 = private unnamed_addr constant [19 x i8] c"RedisModule_OnLoad\00", align 1
@.str.117 = private unnamed_addr constant [74 x i8] c"Module %s does not export RedisModule_OnLoad() symbol. Module not loaded.\00", align 1
@.str.118 = private unnamed_addr constant [51 x i8] c"Module %s initialization failed. Module not loaded\00", align 1
@.str.119 = private unnamed_addr constant [27 x i8] c"Module '%s' loaded from %s\00", align 1
@.str.120 = private unnamed_addr constant [93 x i8] c"Module Configurations were not set, likely a missing LoadConfigs call. Unloading the module.\00", align 1
@.str.121 = private unnamed_addr constant [95 x i8] c"Loadex configurations were not applied, likely due to invalid arguments. Unloading the module.\00", align 1
@.str.122 = private unnamed_addr constant [30 x i8] c"no such module with that name\00", align 1
@.str.123 = private unnamed_addr constant [68 x i8] c"the module exports one or more module-side data types, can't unload\00", align 1
@.str.124 = private unnamed_addr constant [86 x i8] c"the module exports APIs used by other modules. Please unload them first and try again\00", align 1
@.str.125 = private unnamed_addr constant [83 x i8] c"the module has blocked clients. Please wait for them to be unblocked and try again\00", align 1
@.str.126 = private unnamed_addr constant [88 x i8] c"the module holds timer that is not fired. Please stop the timer or wait until it fires.\00", align 1
@.str.127 = private unnamed_addr constant [21 x i8] c"RedisModule_OnUnload\00", align 1
@.str.128 = private unnamed_addr constant [45 x i8] c"Module %s OnUnload failed.  Unload canceled.\00", align 1
@.str.129 = private unnamed_addr constant [14 x i8] c"Unknown error\00", align 1
@.str.130 = private unnamed_addr constant [45 x i8] c"Error when trying to close the %s module: %s\00", align 1
@.str.131 = private unnamed_addr constant [19 x i8] c"Module %s unloaded\00", align 1
@.str.132 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.133 = private unnamed_addr constant [4 x i8] c"ver\00", align 1
@.str.134 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str.135 = private unnamed_addr constant [5 x i8] c"args\00", align 1
@.str.136 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.137 = private unnamed_addr constant [2 x i8] c"|\00", align 1
@.str.138 = private unnamed_addr constant [2 x i8] c"]\00", align 1
@.str.139 = private unnamed_addr constant [18 x i8] c"handle-io-errors|\00", align 1
@.str.140 = private unnamed_addr constant [24 x i8] c"handle-repl-async-load|\00", align 1
@.str.141 = private unnamed_addr constant [29 x i8] c"no-implicit-signal-modified|\00", align 1
@.str.142 = private unnamed_addr constant [72 x i8] c"module:name=%S,ver=%i,api=%i,filters=%i,usedby=%S,using=%S,options=%S\0D\0A\00", align 1
@.str.143 = private unnamed_addr constant [34 x i8] c"Invalid flag(s) for configuration\00", align 1
@.str.144 = private unnamed_addr constant [53 x i8] c"Numeric flag provided for non-numeric configuration.\00", align 1
@.str.145 = private unnamed_addr constant [47 x i8] c"Enum flag provided for non-enum configuration.\00", align 1
@.str.146 = private unnamed_addr constant [49 x i8] c"Invalid character %c in Module resource name %s.\00", align 1
@.str.147 = private unnamed_addr constant [6 x i8] c"%s.%s\00", align 1
@.str.148 = private unnamed_addr constant [46 x i8] c"Issue during loading of configuration %s : %s\00", align 1
@.str.149 = private unnamed_addr constant [63 x i8] c"Issue attempting to set default value of configuration %s : %s\00", align 1
@.str.150 = private unnamed_addr constant [49 x i8] c"Configuration by the name: %s already registered\00", align 1
@.str.151 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.152 = private unnamed_addr constant [44 x i8] c"stream->type == REDISMODULE_RDB_STREAM_FILE\00", align 1
@.str.153 = private unnamed_addr constant [5 x i8] c"help\00", align 1
@.str.154 = private unnamed_addr constant [5 x i8] c"LIST\00", align 1
@.str.155 = private unnamed_addr constant [37 x i8] c"    Return a list of loaded modules.\00", align 1
@.str.156 = private unnamed_addr constant [24 x i8] c"LOAD <path> [<arg> ...]\00", align 1
@.str.157 = private unnamed_addr constant [77 x i8] c"    Load a module library from <path>, passing to it any optional arguments.\00", align 1
@.str.158 = private unnamed_addr constant [67 x i8] c"LOADEX <path> [[CONFIG NAME VALUE] [CONFIG NAME VALUE]] [ARGS ...]\00", align 1
@.str.159 = private unnamed_addr constant [102 x i8] c"    Load a module library from <path>, while passing it module configurations and optional arguments.\00", align 1
@.str.160 = private unnamed_addr constant [14 x i8] c"UNLOAD <name>\00", align 1
@.str.161 = private unnamed_addr constant [21 x i8] c"    Unload a module.\00", align 1
@__const.moduleCommand.help = private unnamed_addr constant [9 x ptr] [ptr @.str.154, ptr @.str.155, ptr @.str.156, ptr @.str.157, ptr @.str.158, ptr @.str.159, ptr @.str.160, ptr @.str.161, ptr null], align 16
@.str.162 = private unnamed_addr constant [5 x i8] c"load\00", align 1
@.str.163 = private unnamed_addr constant [59 x i8] c"Error loading the extension. Please check the server logs.\00", align 1
@.str.164 = private unnamed_addr constant [7 x i8] c"loadex\00", align 1
@.str.165 = private unnamed_addr constant [7 x i8] c"unload\00", align 1
@.str.166 = private unnamed_addr constant [24 x i8] c"operation not possible.\00", align 1
@.str.167 = private unnamed_addr constant [27 x i8] c"Error unloading module: %s\00", align 1
@.str.168 = private unnamed_addr constant [30 x i8] c"Error unloading module %s: %s\00", align 1
@.str.169 = private unnamed_addr constant [5 x i8] c"list\00", align 1
@__const.moduleDefragGlobals.defrag_ctx = private unnamed_addr constant %struct.RedisModuleDefragCtx { i64 0, ptr null, ptr null, i32 -1 }, align 8
@.str.170 = private unnamed_addr constant [18 x i8] c"RedisModule_Alloc\00", align 1
@.str.171 = private unnamed_addr constant [21 x i8] c"RedisModule_TryAlloc\00", align 1
@.str.172 = private unnamed_addr constant [19 x i8] c"RedisModule_Calloc\00", align 1
@.str.173 = private unnamed_addr constant [20 x i8] c"RedisModule_Realloc\00", align 1
@.str.174 = private unnamed_addr constant [17 x i8] c"RedisModule_Free\00", align 1
@.str.175 = private unnamed_addr constant [19 x i8] c"RedisModule_Strdup\00", align 1
@.str.176 = private unnamed_addr constant [26 x i8] c"RedisModule_CreateCommand\00", align 1
@.str.177 = private unnamed_addr constant [23 x i8] c"RedisModule_GetCommand\00", align 1
@.str.178 = private unnamed_addr constant [29 x i8] c"RedisModule_CreateSubcommand\00", align 1
@.str.179 = private unnamed_addr constant [27 x i8] c"RedisModule_SetCommandInfo\00", align 1
@.str.180 = private unnamed_addr constant [36 x i8] c"RedisModule_SetCommandACLCategories\00", align 1
@.str.181 = private unnamed_addr constant [27 x i8] c"RedisModule_AddACLCategory\00", align 1
@.str.182 = private unnamed_addr constant [29 x i8] c"RedisModule_SetModuleAttribs\00", align 1
@.str.183 = private unnamed_addr constant [29 x i8] c"RedisModule_IsModuleNameBusy\00", align 1
@.str.184 = private unnamed_addr constant [23 x i8] c"RedisModule_WrongArity\00", align 1
@.str.185 = private unnamed_addr constant [30 x i8] c"RedisModule_ReplyWithLongLong\00", align 1
@.str.186 = private unnamed_addr constant [27 x i8] c"RedisModule_ReplyWithError\00", align 1
@.str.187 = private unnamed_addr constant [33 x i8] c"RedisModule_ReplyWithErrorFormat\00", align 1
@.str.188 = private unnamed_addr constant [34 x i8] c"RedisModule_ReplyWithSimpleString\00", align 1
@.str.189 = private unnamed_addr constant [27 x i8] c"RedisModule_ReplyWithArray\00", align 1
@.str.190 = private unnamed_addr constant [25 x i8] c"RedisModule_ReplyWithMap\00", align 1
@.str.191 = private unnamed_addr constant [25 x i8] c"RedisModule_ReplyWithSet\00", align 1
@.str.192 = private unnamed_addr constant [31 x i8] c"RedisModule_ReplyWithAttribute\00", align 1
@.str.193 = private unnamed_addr constant [31 x i8] c"RedisModule_ReplyWithNullArray\00", align 1
@.str.194 = private unnamed_addr constant [32 x i8] c"RedisModule_ReplyWithEmptyArray\00", align 1
@.str.195 = private unnamed_addr constant [32 x i8] c"RedisModule_ReplySetArrayLength\00", align 1
@.str.196 = private unnamed_addr constant [30 x i8] c"RedisModule_ReplySetMapLength\00", align 1
@.str.197 = private unnamed_addr constant [30 x i8] c"RedisModule_ReplySetSetLength\00", align 1
@.str.198 = private unnamed_addr constant [36 x i8] c"RedisModule_ReplySetAttributeLength\00", align 1
@.str.199 = private unnamed_addr constant [28 x i8] c"RedisModule_ReplyWithString\00", align 1
@.str.200 = private unnamed_addr constant [33 x i8] c"RedisModule_ReplyWithEmptyString\00", align 1
@.str.201 = private unnamed_addr constant [36 x i8] c"RedisModule_ReplyWithVerbatimString\00", align 1
@.str.202 = private unnamed_addr constant [40 x i8] c"RedisModule_ReplyWithVerbatimStringType\00", align 1
@.str.203 = private unnamed_addr constant [34 x i8] c"RedisModule_ReplyWithStringBuffer\00", align 1
@.str.204 = private unnamed_addr constant [29 x i8] c"RedisModule_ReplyWithCString\00", align 1
@.str.205 = private unnamed_addr constant [26 x i8] c"RedisModule_ReplyWithNull\00", align 1
@.str.206 = private unnamed_addr constant [26 x i8] c"RedisModule_ReplyWithBool\00", align 1
@.str.207 = private unnamed_addr constant [31 x i8] c"RedisModule_ReplyWithCallReply\00", align 1
@.str.208 = private unnamed_addr constant [28 x i8] c"RedisModule_ReplyWithDouble\00", align 1
@.str.209 = private unnamed_addr constant [31 x i8] c"RedisModule_ReplyWithBigNumber\00", align 1
@.str.210 = private unnamed_addr constant [32 x i8] c"RedisModule_ReplyWithLongDouble\00", align 1
@.str.211 = private unnamed_addr constant [26 x i8] c"RedisModule_GetSelectedDb\00", align 1
@.str.212 = private unnamed_addr constant [21 x i8] c"RedisModule_SelectDb\00", align 1
@.str.213 = private unnamed_addr constant [22 x i8] c"RedisModule_KeyExists\00", align 1
@.str.214 = private unnamed_addr constant [20 x i8] c"RedisModule_OpenKey\00", align 1
@.str.215 = private unnamed_addr constant [31 x i8] c"RedisModule_GetOpenKeyModesAll\00", align 1
@.str.216 = private unnamed_addr constant [21 x i8] c"RedisModule_CloseKey\00", align 1
@.str.217 = private unnamed_addr constant [20 x i8] c"RedisModule_KeyType\00", align 1
@.str.218 = private unnamed_addr constant [24 x i8] c"RedisModule_ValueLength\00", align 1
@.str.219 = private unnamed_addr constant [21 x i8] c"RedisModule_ListPush\00", align 1
@.str.220 = private unnamed_addr constant [20 x i8] c"RedisModule_ListPop\00", align 1
@.str.221 = private unnamed_addr constant [20 x i8] c"RedisModule_ListGet\00", align 1
@.str.222 = private unnamed_addr constant [20 x i8] c"RedisModule_ListSet\00", align 1
@.str.223 = private unnamed_addr constant [23 x i8] c"RedisModule_ListInsert\00", align 1
@.str.224 = private unnamed_addr constant [23 x i8] c"RedisModule_ListDelete\00", align 1
@.str.225 = private unnamed_addr constant [29 x i8] c"RedisModule_StringToLongLong\00", align 1
@.str.226 = private unnamed_addr constant [30 x i8] c"RedisModule_StringToULongLong\00", align 1
@.str.227 = private unnamed_addr constant [27 x i8] c"RedisModule_StringToDouble\00", align 1
@.str.228 = private unnamed_addr constant [31 x i8] c"RedisModule_StringToLongDouble\00", align 1
@.str.229 = private unnamed_addr constant [29 x i8] c"RedisModule_StringToStreamID\00", align 1
@.str.230 = private unnamed_addr constant [17 x i8] c"RedisModule_Call\00", align 1
@.str.231 = private unnamed_addr constant [27 x i8] c"RedisModule_CallReplyProto\00", align 1
@.str.232 = private unnamed_addr constant [26 x i8] c"RedisModule_FreeCallReply\00", align 1
@.str.233 = private unnamed_addr constant [29 x i8] c"RedisModule_CallReplyInteger\00", align 1
@.str.234 = private unnamed_addr constant [28 x i8] c"RedisModule_CallReplyDouble\00", align 1
@.str.235 = private unnamed_addr constant [31 x i8] c"RedisModule_CallReplyBigNumber\00", align 1
@.str.236 = private unnamed_addr constant [30 x i8] c"RedisModule_CallReplyVerbatim\00", align 1
@.str.237 = private unnamed_addr constant [26 x i8] c"RedisModule_CallReplyBool\00", align 1
@.str.238 = private unnamed_addr constant [32 x i8] c"RedisModule_CallReplySetElement\00", align 1
@.str.239 = private unnamed_addr constant [32 x i8] c"RedisModule_CallReplyMapElement\00", align 1
@.str.240 = private unnamed_addr constant [38 x i8] c"RedisModule_CallReplyAttributeElement\00", align 1
@.str.241 = private unnamed_addr constant [46 x i8] c"RedisModule_CallReplyPromiseSetUnblockHandler\00", align 1
@.str.242 = private unnamed_addr constant [34 x i8] c"RedisModule_CallReplyPromiseAbort\00", align 1
@.str.243 = private unnamed_addr constant [31 x i8] c"RedisModule_CallReplyAttribute\00", align 1
@.str.244 = private unnamed_addr constant [26 x i8] c"RedisModule_CallReplyType\00", align 1
@.str.245 = private unnamed_addr constant [28 x i8] c"RedisModule_CallReplyLength\00", align 1
@.str.246 = private unnamed_addr constant [34 x i8] c"RedisModule_CallReplyArrayElement\00", align 1
@.str.247 = private unnamed_addr constant [31 x i8] c"RedisModule_CallReplyStringPtr\00", align 1
@.str.248 = private unnamed_addr constant [38 x i8] c"RedisModule_CreateStringFromCallReply\00", align 1
@.str.249 = private unnamed_addr constant [25 x i8] c"RedisModule_CreateString\00", align 1
@.str.250 = private unnamed_addr constant [37 x i8] c"RedisModule_CreateStringFromLongLong\00", align 1
@.str.251 = private unnamed_addr constant [38 x i8] c"RedisModule_CreateStringFromULongLong\00", align 1
@.str.252 = private unnamed_addr constant [35 x i8] c"RedisModule_CreateStringFromDouble\00", align 1
@.str.253 = private unnamed_addr constant [39 x i8] c"RedisModule_CreateStringFromLongDouble\00", align 1
@.str.254 = private unnamed_addr constant [35 x i8] c"RedisModule_CreateStringFromString\00", align 1
@.str.255 = private unnamed_addr constant [37 x i8] c"RedisModule_CreateStringFromStreamID\00", align 1
@.str.256 = private unnamed_addr constant [31 x i8] c"RedisModule_CreateStringPrintf\00", align 1
@.str.257 = private unnamed_addr constant [23 x i8] c"RedisModule_FreeString\00", align 1
@.str.258 = private unnamed_addr constant [25 x i8] c"RedisModule_StringPtrLen\00", align 1
@.str.259 = private unnamed_addr constant [23 x i8] c"RedisModule_AutoMemory\00", align 1
@.str.260 = private unnamed_addr constant [22 x i8] c"RedisModule_Replicate\00", align 1
@.str.261 = private unnamed_addr constant [30 x i8] c"RedisModule_ReplicateVerbatim\00", align 1
@.str.262 = private unnamed_addr constant [22 x i8] c"RedisModule_DeleteKey\00", align 1
@.str.263 = private unnamed_addr constant [22 x i8] c"RedisModule_UnlinkKey\00", align 1
@.str.264 = private unnamed_addr constant [22 x i8] c"RedisModule_StringSet\00", align 1
@.str.265 = private unnamed_addr constant [22 x i8] c"RedisModule_StringDMA\00", align 1
@.str.266 = private unnamed_addr constant [27 x i8] c"RedisModule_StringTruncate\00", align 1
@.str.267 = private unnamed_addr constant [22 x i8] c"RedisModule_SetExpire\00", align 1
@.str.268 = private unnamed_addr constant [22 x i8] c"RedisModule_GetExpire\00", align 1
@.str.269 = private unnamed_addr constant [25 x i8] c"RedisModule_SetAbsExpire\00", align 1
@.str.270 = private unnamed_addr constant [25 x i8] c"RedisModule_GetAbsExpire\00", align 1
@.str.271 = private unnamed_addr constant [25 x i8] c"RedisModule_ResetDataset\00", align 1
@.str.272 = private unnamed_addr constant [19 x i8] c"RedisModule_DbSize\00", align 1
@.str.273 = private unnamed_addr constant [22 x i8] c"RedisModule_RandomKey\00", align 1
@.str.274 = private unnamed_addr constant [20 x i8] c"RedisModule_ZsetAdd\00", align 1
@.str.275 = private unnamed_addr constant [23 x i8] c"RedisModule_ZsetIncrby\00", align 1
@.str.276 = private unnamed_addr constant [22 x i8] c"RedisModule_ZsetScore\00", align 1
@.str.277 = private unnamed_addr constant [20 x i8] c"RedisModule_ZsetRem\00", align 1
@.str.278 = private unnamed_addr constant [26 x i8] c"RedisModule_ZsetRangeStop\00", align 1
@.str.279 = private unnamed_addr constant [34 x i8] c"RedisModule_ZsetFirstInScoreRange\00", align 1
@.str.280 = private unnamed_addr constant [33 x i8] c"RedisModule_ZsetLastInScoreRange\00", align 1
@.str.281 = private unnamed_addr constant [32 x i8] c"RedisModule_ZsetFirstInLexRange\00", align 1
@.str.282 = private unnamed_addr constant [31 x i8] c"RedisModule_ZsetLastInLexRange\00", align 1
@.str.283 = private unnamed_addr constant [36 x i8] c"RedisModule_ZsetRangeCurrentElement\00", align 1
@.str.284 = private unnamed_addr constant [26 x i8] c"RedisModule_ZsetRangeNext\00", align 1
@.str.285 = private unnamed_addr constant [26 x i8] c"RedisModule_ZsetRangePrev\00", align 1
@.str.286 = private unnamed_addr constant [32 x i8] c"RedisModule_ZsetRangeEndReached\00", align 1
@.str.287 = private unnamed_addr constant [20 x i8] c"RedisModule_HashSet\00", align 1
@.str.288 = private unnamed_addr constant [20 x i8] c"RedisModule_HashGet\00", align 1
@.str.289 = private unnamed_addr constant [22 x i8] c"RedisModule_StreamAdd\00", align 1
@.str.290 = private unnamed_addr constant [25 x i8] c"RedisModule_StreamDelete\00", align 1
@.str.291 = private unnamed_addr constant [32 x i8] c"RedisModule_StreamIteratorStart\00", align 1
@.str.292 = private unnamed_addr constant [31 x i8] c"RedisModule_StreamIteratorStop\00", align 1
@.str.293 = private unnamed_addr constant [33 x i8] c"RedisModule_StreamIteratorNextID\00", align 1
@.str.294 = private unnamed_addr constant [36 x i8] c"RedisModule_StreamIteratorNextField\00", align 1
@.str.295 = private unnamed_addr constant [33 x i8] c"RedisModule_StreamIteratorDelete\00", align 1
@.str.296 = private unnamed_addr constant [31 x i8] c"RedisModule_StreamTrimByLength\00", align 1
@.str.297 = private unnamed_addr constant [27 x i8] c"RedisModule_StreamTrimByID\00", align 1
@.str.298 = private unnamed_addr constant [34 x i8] c"RedisModule_IsKeysPositionRequest\00", align 1
@.str.299 = private unnamed_addr constant [21 x i8] c"RedisModule_KeyAtPos\00", align 1
@.str.300 = private unnamed_addr constant [30 x i8] c"RedisModule_KeyAtPosWithFlags\00", align 1
@.str.301 = private unnamed_addr constant [38 x i8] c"RedisModule_IsChannelsPositionRequest\00", align 1
@.str.302 = private unnamed_addr constant [34 x i8] c"RedisModule_ChannelAtPosWithFlags\00", align 1
@.str.303 = private unnamed_addr constant [24 x i8] c"RedisModule_GetClientId\00", align 1
@.str.304 = private unnamed_addr constant [34 x i8] c"RedisModule_GetClientUserNameById\00", align 1
@.str.305 = private unnamed_addr constant [28 x i8] c"RedisModule_GetContextFlags\00", align 1
@.str.306 = private unnamed_addr constant [32 x i8] c"RedisModule_AvoidReplicaTraffic\00", align 1
@.str.307 = private unnamed_addr constant [22 x i8] c"RedisModule_PoolAlloc\00", align 1
@.str.308 = private unnamed_addr constant [27 x i8] c"RedisModule_CreateDataType\00", align 1
@.str.309 = private unnamed_addr constant [31 x i8] c"RedisModule_ModuleTypeSetValue\00", align 1
@.str.310 = private unnamed_addr constant [35 x i8] c"RedisModule_ModuleTypeReplaceValue\00", align 1
@.str.311 = private unnamed_addr constant [30 x i8] c"RedisModule_ModuleTypeGetType\00", align 1
@.str.312 = private unnamed_addr constant [31 x i8] c"RedisModule_ModuleTypeGetValue\00", align 1
@.str.313 = private unnamed_addr constant [22 x i8] c"RedisModule_IsIOError\00", align 1
@.str.314 = private unnamed_addr constant [29 x i8] c"RedisModule_SetModuleOptions\00", align 1
@.str.315 = private unnamed_addr constant [30 x i8] c"RedisModule_SignalModifiedKey\00", align 1
@.str.316 = private unnamed_addr constant [25 x i8] c"RedisModule_SaveUnsigned\00", align 1
@.str.317 = private unnamed_addr constant [25 x i8] c"RedisModule_LoadUnsigned\00", align 1
@.str.318 = private unnamed_addr constant [23 x i8] c"RedisModule_SaveSigned\00", align 1
@.str.319 = private unnamed_addr constant [23 x i8] c"RedisModule_LoadSigned\00", align 1
@.str.320 = private unnamed_addr constant [23 x i8] c"RedisModule_SaveString\00", align 1
@.str.321 = private unnamed_addr constant [29 x i8] c"RedisModule_SaveStringBuffer\00", align 1
@.str.322 = private unnamed_addr constant [23 x i8] c"RedisModule_LoadString\00", align 1
@.str.323 = private unnamed_addr constant [29 x i8] c"RedisModule_LoadStringBuffer\00", align 1
@.str.324 = private unnamed_addr constant [23 x i8] c"RedisModule_SaveDouble\00", align 1
@.str.325 = private unnamed_addr constant [23 x i8] c"RedisModule_LoadDouble\00", align 1
@.str.326 = private unnamed_addr constant [22 x i8] c"RedisModule_SaveFloat\00", align 1
@.str.327 = private unnamed_addr constant [22 x i8] c"RedisModule_LoadFloat\00", align 1
@.str.328 = private unnamed_addr constant [27 x i8] c"RedisModule_SaveLongDouble\00", align 1
@.str.329 = private unnamed_addr constant [27 x i8] c"RedisModule_LoadLongDouble\00", align 1
@.str.330 = private unnamed_addr constant [33 x i8] c"RedisModule_SaveDataTypeToString\00", align 1
@.str.331 = private unnamed_addr constant [35 x i8] c"RedisModule_LoadDataTypeFromString\00", align 1
@.str.332 = private unnamed_addr constant [41 x i8] c"RedisModule_LoadDataTypeFromStringEncver\00", align 1
@.str.333 = private unnamed_addr constant [20 x i8] c"RedisModule_EmitAOF\00", align 1
@.str.334 = private unnamed_addr constant [16 x i8] c"RedisModule_Log\00", align 1
@.str.335 = private unnamed_addr constant [23 x i8] c"RedisModule_LogIOError\00", align 1
@.str.336 = private unnamed_addr constant [20 x i8] c"RedisModule__Assert\00", align 1
@.str.337 = private unnamed_addr constant [29 x i8] c"RedisModule_LatencyAddSample\00", align 1
@.str.338 = private unnamed_addr constant [31 x i8] c"RedisModule_StringAppendBuffer\00", align 1
@.str.339 = private unnamed_addr constant [33 x i8] c"RedisModule_TrimStringAllocation\00", align 1
@.str.340 = private unnamed_addr constant [25 x i8] c"RedisModule_RetainString\00", align 1
@.str.341 = private unnamed_addr constant [23 x i8] c"RedisModule_HoldString\00", align 1
@.str.342 = private unnamed_addr constant [26 x i8] c"RedisModule_StringCompare\00", align 1
@.str.343 = private unnamed_addr constant [29 x i8] c"RedisModule_GetContextFromIO\00", align 1
@.str.344 = private unnamed_addr constant [29 x i8] c"RedisModule_GetKeyNameFromIO\00", align 1
@.str.345 = private unnamed_addr constant [36 x i8] c"RedisModule_GetKeyNameFromModuleKey\00", align 1
@.str.346 = private unnamed_addr constant [33 x i8] c"RedisModule_GetDbIdFromModuleKey\00", align 1
@.str.347 = private unnamed_addr constant [26 x i8] c"RedisModule_GetDbIdFromIO\00", align 1
@.str.348 = private unnamed_addr constant [33 x i8] c"RedisModule_GetKeyNameFromOptCtx\00", align 1
@.str.349 = private unnamed_addr constant [35 x i8] c"RedisModule_GetToKeyNameFromOptCtx\00", align 1
@.str.350 = private unnamed_addr constant [30 x i8] c"RedisModule_GetDbIdFromOptCtx\00", align 1
@.str.351 = private unnamed_addr constant [32 x i8] c"RedisModule_GetToDbIdFromOptCtx\00", align 1
@.str.352 = private unnamed_addr constant [36 x i8] c"RedisModule_GetKeyNameFromDefragCtx\00", align 1
@.str.353 = private unnamed_addr constant [33 x i8] c"RedisModule_GetDbIdFromDefragCtx\00", align 1
@.str.354 = private unnamed_addr constant [33 x i8] c"RedisModule_GetKeyNameFromDigest\00", align 1
@.str.355 = private unnamed_addr constant [30 x i8] c"RedisModule_GetDbIdFromDigest\00", align 1
@.str.356 = private unnamed_addr constant [24 x i8] c"RedisModule_BlockClient\00", align 1
@.str.357 = private unnamed_addr constant [38 x i8] c"RedisModule_BlockClientGetPrivateData\00", align 1
@.str.358 = private unnamed_addr constant [38 x i8] c"RedisModule_BlockClientSetPrivateData\00", align 1
@.str.359 = private unnamed_addr constant [30 x i8] c"RedisModule_BlockClientOnAuth\00", align 1
@.str.360 = private unnamed_addr constant [26 x i8] c"RedisModule_UnblockClient\00", align 1
@.str.361 = private unnamed_addr constant [34 x i8] c"RedisModule_IsBlockedReplyRequest\00", align 1
@.str.362 = private unnamed_addr constant [36 x i8] c"RedisModule_IsBlockedTimeoutRequest\00", align 1
@.str.363 = private unnamed_addr constant [40 x i8] c"RedisModule_GetBlockedClientPrivateData\00", align 1
@.str.364 = private unnamed_addr constant [23 x i8] c"RedisModule_AbortBlock\00", align 1
@.str.365 = private unnamed_addr constant [25 x i8] c"RedisModule_Milliseconds\00", align 1
@.str.366 = private unnamed_addr constant [34 x i8] c"RedisModule_MonotonicMicroseconds\00", align 1
@.str.367 = private unnamed_addr constant [25 x i8] c"RedisModule_Microseconds\00", align 1
@.str.368 = private unnamed_addr constant [31 x i8] c"RedisModule_CachedMicroseconds\00", align 1
@.str.369 = private unnamed_addr constant [42 x i8] c"RedisModule_BlockedClientMeasureTimeStart\00", align 1
@.str.370 = private unnamed_addr constant [40 x i8] c"RedisModule_BlockedClientMeasureTimeEnd\00", align 1
@.str.371 = private unnamed_addr constant [33 x i8] c"RedisModule_GetThreadSafeContext\00", align 1
@.str.372 = private unnamed_addr constant [41 x i8] c"RedisModule_GetDetachedThreadSafeContext\00", align 1
@.str.373 = private unnamed_addr constant [34 x i8] c"RedisModule_FreeThreadSafeContext\00", align 1
@.str.374 = private unnamed_addr constant [34 x i8] c"RedisModule_ThreadSafeContextLock\00", align 1
@.str.375 = private unnamed_addr constant [37 x i8] c"RedisModule_ThreadSafeContextTryLock\00", align 1
@.str.376 = private unnamed_addr constant [36 x i8] c"RedisModule_ThreadSafeContextUnlock\00", align 1
@.str.377 = private unnamed_addr constant [34 x i8] c"RedisModule_DigestAddStringBuffer\00", align 1
@.str.378 = private unnamed_addr constant [30 x i8] c"RedisModule_DigestAddLongLong\00", align 1
@.str.379 = private unnamed_addr constant [30 x i8] c"RedisModule_DigestEndSequence\00", align 1
@.str.380 = private unnamed_addr constant [32 x i8] c"RedisModule_NotifyKeyspaceEvent\00", align 1
@.str.381 = private unnamed_addr constant [36 x i8] c"RedisModule_GetNotifyKeyspaceEvents\00", align 1
@.str.382 = private unnamed_addr constant [38 x i8] c"RedisModule_SubscribeToKeyspaceEvents\00", align 1
@.str.383 = private unnamed_addr constant [35 x i8] c"RedisModule_AddPostNotificationJob\00", align 1
@.str.384 = private unnamed_addr constant [43 x i8] c"RedisModule_RegisterClusterMessageReceiver\00", align 1
@.str.385 = private unnamed_addr constant [31 x i8] c"RedisModule_SendClusterMessage\00", align 1
@.str.386 = private unnamed_addr constant [31 x i8] c"RedisModule_GetClusterNodeInfo\00", align 1
@.str.387 = private unnamed_addr constant [32 x i8] c"RedisModule_GetClusterNodesList\00", align 1
@.str.388 = private unnamed_addr constant [33 x i8] c"RedisModule_FreeClusterNodesList\00", align 1
@.str.389 = private unnamed_addr constant [24 x i8] c"RedisModule_CreateTimer\00", align 1
@.str.390 = private unnamed_addr constant [22 x i8] c"RedisModule_StopTimer\00", align 1
@.str.391 = private unnamed_addr constant [25 x i8] c"RedisModule_GetTimerInfo\00", align 1
@.str.392 = private unnamed_addr constant [27 x i8] c"RedisModule_GetMyClusterID\00", align 1
@.str.393 = private unnamed_addr constant [27 x i8] c"RedisModule_GetClusterSize\00", align 1
@.str.394 = private unnamed_addr constant [27 x i8] c"RedisModule_GetRandomBytes\00", align 1
@.str.395 = private unnamed_addr constant [30 x i8] c"RedisModule_GetRandomHexChars\00", align 1
@.str.396 = private unnamed_addr constant [38 x i8] c"RedisModule_BlockedClientDisconnected\00", align 1
@.str.397 = private unnamed_addr constant [34 x i8] c"RedisModule_SetDisconnectCallback\00", align 1
@.str.398 = private unnamed_addr constant [35 x i8] c"RedisModule_GetBlockedClientHandle\00", align 1
@.str.399 = private unnamed_addr constant [28 x i8] c"RedisModule_SetClusterFlags\00", align 1
@.str.400 = private unnamed_addr constant [23 x i8] c"RedisModule_CreateDict\00", align 1
@.str.401 = private unnamed_addr constant [21 x i8] c"RedisModule_FreeDict\00", align 1
@.str.402 = private unnamed_addr constant [21 x i8] c"RedisModule_DictSize\00", align 1
@.str.403 = private unnamed_addr constant [21 x i8] c"RedisModule_DictSetC\00", align 1
@.str.404 = private unnamed_addr constant [25 x i8] c"RedisModule_DictReplaceC\00", align 1
@.str.405 = private unnamed_addr constant [20 x i8] c"RedisModule_DictSet\00", align 1
@.str.406 = private unnamed_addr constant [24 x i8] c"RedisModule_DictReplace\00", align 1
@.str.407 = private unnamed_addr constant [21 x i8] c"RedisModule_DictGetC\00", align 1
@.str.408 = private unnamed_addr constant [20 x i8] c"RedisModule_DictGet\00", align 1
@.str.409 = private unnamed_addr constant [21 x i8] c"RedisModule_DictDelC\00", align 1
@.str.410 = private unnamed_addr constant [20 x i8] c"RedisModule_DictDel\00", align 1
@.str.411 = private unnamed_addr constant [31 x i8] c"RedisModule_DictIteratorStartC\00", align 1
@.str.412 = private unnamed_addr constant [30 x i8] c"RedisModule_DictIteratorStart\00", align 1
@.str.413 = private unnamed_addr constant [29 x i8] c"RedisModule_DictIteratorStop\00", align 1
@.str.414 = private unnamed_addr constant [32 x i8] c"RedisModule_DictIteratorReseekC\00", align 1
@.str.415 = private unnamed_addr constant [31 x i8] c"RedisModule_DictIteratorReseek\00", align 1
@.str.416 = private unnamed_addr constant [22 x i8] c"RedisModule_DictNextC\00", align 1
@.str.417 = private unnamed_addr constant [22 x i8] c"RedisModule_DictPrevC\00", align 1
@.str.418 = private unnamed_addr constant [21 x i8] c"RedisModule_DictNext\00", align 1
@.str.419 = private unnamed_addr constant [21 x i8] c"RedisModule_DictPrev\00", align 1
@.str.420 = private unnamed_addr constant [25 x i8] c"RedisModule_DictCompareC\00", align 1
@.str.421 = private unnamed_addr constant [24 x i8] c"RedisModule_DictCompare\00", align 1
@.str.422 = private unnamed_addr constant [28 x i8] c"RedisModule_ExportSharedAPI\00", align 1
@.str.423 = private unnamed_addr constant [25 x i8] c"RedisModule_GetSharedAPI\00", align 1
@.str.424 = private unnamed_addr constant [34 x i8] c"RedisModule_RegisterCommandFilter\00", align 1
@.str.425 = private unnamed_addr constant [36 x i8] c"RedisModule_UnregisterCommandFilter\00", align 1
@.str.426 = private unnamed_addr constant [35 x i8] c"RedisModule_CommandFilterArgsCount\00", align 1
@.str.427 = private unnamed_addr constant [32 x i8] c"RedisModule_CommandFilterArgGet\00", align 1
@.str.428 = private unnamed_addr constant [35 x i8] c"RedisModule_CommandFilterArgInsert\00", align 1
@.str.429 = private unnamed_addr constant [36 x i8] c"RedisModule_CommandFilterArgReplace\00", align 1
@.str.430 = private unnamed_addr constant [35 x i8] c"RedisModule_CommandFilterArgDelete\00", align 1
@.str.431 = private unnamed_addr constant [37 x i8] c"RedisModule_CommandFilterGetClientId\00", align 1
@.str.432 = private unnamed_addr constant [17 x i8] c"RedisModule_Fork\00", align 1
@.str.433 = private unnamed_addr constant [31 x i8] c"RedisModule_SendChildHeartbeat\00", align 1
@.str.434 = private unnamed_addr constant [26 x i8] c"RedisModule_ExitFromChild\00", align 1
@.str.435 = private unnamed_addr constant [26 x i8] c"RedisModule_KillForkChild\00", align 1
@.str.436 = private unnamed_addr constant [29 x i8] c"RedisModule_RegisterInfoFunc\00", align 1
@.str.437 = private unnamed_addr constant [27 x i8] c"RedisModule_InfoAddSection\00", align 1
@.str.438 = private unnamed_addr constant [31 x i8] c"RedisModule_InfoBeginDictField\00", align 1
@.str.439 = private unnamed_addr constant [29 x i8] c"RedisModule_InfoEndDictField\00", align 1
@.str.440 = private unnamed_addr constant [31 x i8] c"RedisModule_InfoAddFieldString\00", align 1
@.str.441 = private unnamed_addr constant [32 x i8] c"RedisModule_InfoAddFieldCString\00", align 1
@.str.442 = private unnamed_addr constant [31 x i8] c"RedisModule_InfoAddFieldDouble\00", align 1
@.str.443 = private unnamed_addr constant [33 x i8] c"RedisModule_InfoAddFieldLongLong\00", align 1
@.str.444 = private unnamed_addr constant [34 x i8] c"RedisModule_InfoAddFieldULongLong\00", align 1
@.str.445 = private unnamed_addr constant [26 x i8] c"RedisModule_GetServerInfo\00", align 1
@.str.446 = private unnamed_addr constant [27 x i8] c"RedisModule_FreeServerInfo\00", align 1
@.str.447 = private unnamed_addr constant [31 x i8] c"RedisModule_ServerInfoGetField\00", align 1
@.str.448 = private unnamed_addr constant [32 x i8] c"RedisModule_ServerInfoGetFieldC\00", align 1
@.str.449 = private unnamed_addr constant [37 x i8] c"RedisModule_ServerInfoGetFieldSigned\00", align 1
@.str.450 = private unnamed_addr constant [39 x i8] c"RedisModule_ServerInfoGetFieldUnsigned\00", align 1
@.str.451 = private unnamed_addr constant [37 x i8] c"RedisModule_ServerInfoGetFieldDouble\00", align 1
@.str.452 = private unnamed_addr constant [30 x i8] c"RedisModule_GetClientInfoById\00", align 1
@.str.453 = private unnamed_addr constant [30 x i8] c"RedisModule_GetClientNameById\00", align 1
@.str.454 = private unnamed_addr constant [30 x i8] c"RedisModule_SetClientNameById\00", align 1
@.str.455 = private unnamed_addr constant [27 x i8] c"RedisModule_PublishMessage\00", align 1
@.str.456 = private unnamed_addr constant [32 x i8] c"RedisModule_PublishMessageShard\00", align 1
@.str.457 = private unnamed_addr constant [35 x i8] c"RedisModule_SubscribeToServerEvent\00", align 1
@.str.458 = private unnamed_addr constant [19 x i8] c"RedisModule_SetLRU\00", align 1
@.str.459 = private unnamed_addr constant [19 x i8] c"RedisModule_GetLRU\00", align 1
@.str.460 = private unnamed_addr constant [19 x i8] c"RedisModule_SetLFU\00", align 1
@.str.461 = private unnamed_addr constant [19 x i8] c"RedisModule_GetLFU\00", align 1
@.str.462 = private unnamed_addr constant [30 x i8] c"RedisModule_BlockClientOnKeys\00", align 1
@.str.463 = private unnamed_addr constant [39 x i8] c"RedisModule_BlockClientOnKeysWithFlags\00", align 1
@.str.464 = private unnamed_addr constant [29 x i8] c"RedisModule_SignalKeyAsReady\00", align 1
@.str.465 = private unnamed_addr constant [37 x i8] c"RedisModule_GetBlockedClientReadyKey\00", align 1
@.str.466 = private unnamed_addr constant [31 x i8] c"RedisModule_GetUsedMemoryRatio\00", align 1
@.str.467 = private unnamed_addr constant [23 x i8] c"RedisModule_MallocSize\00", align 1
@.str.468 = private unnamed_addr constant [29 x i8] c"RedisModule_MallocUsableSize\00", align 1
@.str.469 = private unnamed_addr constant [29 x i8] c"RedisModule_MallocSizeString\00", align 1
@.str.470 = private unnamed_addr constant [27 x i8] c"RedisModule_MallocSizeDict\00", align 1
@.str.471 = private unnamed_addr constant [29 x i8] c"RedisModule_ScanCursorCreate\00", align 1
@.str.472 = private unnamed_addr constant [30 x i8] c"RedisModule_ScanCursorDestroy\00", align 1
@.str.473 = private unnamed_addr constant [30 x i8] c"RedisModule_ScanCursorRestart\00", align 1
@.str.474 = private unnamed_addr constant [17 x i8] c"RedisModule_Scan\00", align 1
@.str.475 = private unnamed_addr constant [20 x i8] c"RedisModule_ScanKey\00", align 1
@.str.476 = private unnamed_addr constant [29 x i8] c"RedisModule_CreateModuleUser\00", align 1
@.str.477 = private unnamed_addr constant [27 x i8] c"RedisModule_SetContextUser\00", align 1
@.str.478 = private unnamed_addr constant [29 x i8] c"RedisModule_SetModuleUserACL\00", align 1
@.str.479 = private unnamed_addr constant [35 x i8] c"RedisModule_SetModuleUserACLString\00", align 1
@.str.480 = private unnamed_addr constant [35 x i8] c"RedisModule_GetModuleUserACLString\00", align 1
@.str.481 = private unnamed_addr constant [31 x i8] c"RedisModule_GetCurrentUserName\00", align 1
@.str.482 = private unnamed_addr constant [38 x i8] c"RedisModule_GetModuleUserFromUserName\00", align 1
@.str.483 = private unnamed_addr constant [39 x i8] c"RedisModule_ACLCheckCommandPermissions\00", align 1
@.str.484 = private unnamed_addr constant [35 x i8] c"RedisModule_ACLCheckKeyPermissions\00", align 1
@.str.485 = private unnamed_addr constant [39 x i8] c"RedisModule_ACLCheckChannelPermissions\00", align 1
@.str.486 = private unnamed_addr constant [27 x i8] c"RedisModule_ACLAddLogEntry\00", align 1
@.str.487 = private unnamed_addr constant [37 x i8] c"RedisModule_ACLAddLogEntryByUserName\00", align 1
@.str.488 = private unnamed_addr constant [27 x i8] c"RedisModule_FreeModuleUser\00", align 1
@.str.489 = private unnamed_addr constant [41 x i8] c"RedisModule_DeauthenticateAndCloseClient\00", align 1
@.str.490 = private unnamed_addr constant [42 x i8] c"RedisModule_AuthenticateClientWithACLUser\00", align 1
@.str.491 = private unnamed_addr constant [39 x i8] c"RedisModule_AuthenticateClientWithUser\00", align 1
@.str.492 = private unnamed_addr constant [31 x i8] c"RedisModule_GetContextFlagsAll\00", align 1
@.str.493 = private unnamed_addr constant [32 x i8] c"RedisModule_GetModuleOptionsAll\00", align 1
@.str.494 = private unnamed_addr constant [44 x i8] c"RedisModule_GetKeyspaceNotificationFlagsAll\00", align 1
@.str.495 = private unnamed_addr constant [32 x i8] c"RedisModule_IsSubEventSupported\00", align 1
@.str.496 = private unnamed_addr constant [29 x i8] c"RedisModule_GetServerVersion\00", align 1
@.str.497 = private unnamed_addr constant [33 x i8] c"RedisModule_GetClientCertificate\00", align 1
@.str.498 = private unnamed_addr constant [40 x i8] c"RedisModule_RedactClientCommandArgument\00", align 1
@.str.499 = private unnamed_addr constant [27 x i8] c"RedisModule_GetCommandKeys\00", align 1
@.str.500 = private unnamed_addr constant [36 x i8] c"RedisModule_GetCommandKeysWithFlags\00", align 1
@.str.501 = private unnamed_addr constant [34 x i8] c"RedisModule_GetCurrentCommandName\00", align 1
@.str.502 = private unnamed_addr constant [33 x i8] c"RedisModule_GetTypeMethodVersion\00", align 1
@.str.503 = private unnamed_addr constant [31 x i8] c"RedisModule_RegisterDefragFunc\00", align 1
@.str.504 = private unnamed_addr constant [24 x i8] c"RedisModule_DefragAlloc\00", align 1
@.str.505 = private unnamed_addr constant [36 x i8] c"RedisModule_DefragRedisModuleString\00", align 1
@.str.506 = private unnamed_addr constant [29 x i8] c"RedisModule_DefragShouldStop\00", align 1
@.str.507 = private unnamed_addr constant [28 x i8] c"RedisModule_DefragCursorSet\00", align 1
@.str.508 = private unnamed_addr constant [28 x i8] c"RedisModule_DefragCursorGet\00", align 1
@.str.509 = private unnamed_addr constant [25 x i8] c"RedisModule_EventLoopAdd\00", align 1
@.str.510 = private unnamed_addr constant [25 x i8] c"RedisModule_EventLoopDel\00", align 1
@.str.511 = private unnamed_addr constant [32 x i8] c"RedisModule_EventLoopAddOneShot\00", align 1
@.str.512 = private unnamed_addr constant [18 x i8] c"RedisModule_Yield\00", align 1
@.str.513 = private unnamed_addr constant [31 x i8] c"RedisModule_RegisterBoolConfig\00", align 1
@.str.514 = private unnamed_addr constant [34 x i8] c"RedisModule_RegisterNumericConfig\00", align 1
@.str.515 = private unnamed_addr constant [33 x i8] c"RedisModule_RegisterStringConfig\00", align 1
@.str.516 = private unnamed_addr constant [31 x i8] c"RedisModule_RegisterEnumConfig\00", align 1
@.str.517 = private unnamed_addr constant [24 x i8] c"RedisModule_LoadConfigs\00", align 1
@.str.518 = private unnamed_addr constant [33 x i8] c"RedisModule_RegisterAuthCallback\00", align 1
@.str.519 = private unnamed_addr constant [36 x i8] c"RedisModule_RdbStreamCreateFromFile\00", align 1
@.str.520 = private unnamed_addr constant [26 x i8] c"RedisModule_RdbStreamFree\00", align 1
@.str.521 = private unnamed_addr constant [20 x i8] c"RedisModule_RdbLoad\00", align 1
@.str.522 = private unnamed_addr constant [20 x i8] c"RedisModule_RdbSave\00", align 1
@.str.523 = private unnamed_addr constant [12 x i8] c"!promise->c\00", align 1
@.str.524 = private unnamed_addr constant [38 x i8] c"Invalid command info: version missing\00", align 1
@.str.525 = private unnamed_addr constant [51 x i8] c"Invalid command info: history[%zd].changes missing\00", align 1
@.str.526 = private unnamed_addr constant [41 x i8] c"Invalid command info: Too many key specs\00", align 1
@.str.527 = private unnamed_addr constant [93 x i8] c"Invalid command info: key_specs[%zd].flags: Exactly one of the flags RO, RW, OW, RM required\00", align 1
@.str.528 = private unnamed_addr constant [93 x i8] c"Invalid command info: key_specs[%zd].flags: INSERT, DELETE and UPDATE are mutually exclusive\00", align 1
@.str.529 = private unnamed_addr constant [99 x i8] c"Invalid command info: key_specs[%zd].bs.keyword.keyword required when begin_search_type is KEYWORD\00", align 1
@.str.530 = private unnamed_addr constant [73 x i8] c"Invalid command info: key_specs[%zd].begin_search_type: Invalid value %d\00", align 1
@.str.531 = private unnamed_addr constant [70 x i8] c"Invalid command info: key_specs[%zd].find_keys_type: Invalid value %d\00", align 1
@.str.532 = private unnamed_addr constant [55 x i8] c"Invalid command info: Argument \22%s\22: Undefined type %d\00", align 1
@.str.533 = private unnamed_addr constant [76 x i8] c"Invalid command info: Argument \22%s\22: token required when type is PURE_TOKEN\00", align 1
@.str.534 = private unnamed_addr constant [78 x i8] c"Invalid command info: Argument \22%s\22: key_spec_index required when type is KEY\00", align 1
@.str.535 = private unnamed_addr constant [81 x i8] c"Invalid command info: Argument \22%s\22: key_spec_index specified but type isn't KEY\00", align 1
@.str.536 = private unnamed_addr constant [51 x i8] c"Invalid command info: Argument \22%s\22: Invalid flags\00", align 1
@.str.537 = private unnamed_addr constant [82 x i8] c"Invalid command info: Argument \22%s\22: subargs required when type is ONEOF or BLOCK\00", align 1
@.str.538 = private unnamed_addr constant [86 x i8] c"Invalid command info: Argument \22%s\22: subargs specified but type isn't ONEOF nor BLOCK\00", align 1
@__const.moduleConvertKeySpecsFlags.map = private unnamed_addr constant [12 x [2 x i64]] [[2 x i64] [i64 1, i64 1], [2 x i64] [i64 2, i64 2], [2 x i64] [i64 4, i64 4], [2 x i64] [i64 8, i64 8], [2 x i64] [i64 16, i64 16], [2 x i64] [i64 64, i64 64], [2 x i64] [i64 32, i64 32], [2 x i64] [i64 128, i64 128], [2 x i64] [i64 256, i64 256], [2 x i64] [i64 512, i64 512], [2 x i64] [i64 1024, i64 1024], [2 x i64] zeroinitializer], align 16
@.str.539 = private unnamed_addr constant [50 x i8] c"count < SIZE_MAX / sizeof(struct redisCommandArg)\00", align 1
@.str.540 = private unnamed_addr constant [18 x i8] c"key->iter == NULL\00", align 1
@.str.541 = private unnamed_addr constant [29 x i8] c"key->value->type == OBJ_LIST\00", align 1
@configerr = internal global [256 x i8] zeroinitializer, align 16

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Alloc(i64 noundef %bytes) #0 {
entry:
  %bytes.addr = alloca i64, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  %0 = load i64, ptr %bytes.addr, align 8
  %call = call ptr @zmalloc_usable(i64 noundef %0, ptr noundef null)
  ret ptr %call
}

declare ptr @zmalloc_usable(i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_TryAlloc(i64 noundef %bytes) #0 {
entry:
  %bytes.addr = alloca i64, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  %0 = load i64, ptr %bytes.addr, align 8
  %call = call ptr @ztrymalloc_usable(i64 noundef %0, ptr noundef null)
  ret ptr %call
}

declare ptr @ztrymalloc_usable(i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Calloc(i64 noundef %nmemb, i64 noundef %size) #0 {
entry:
  %nmemb.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store i64 %nmemb, ptr %nmemb.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %nmemb.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %mul = mul i64 %0, %1
  %call = call ptr @zcalloc_usable(i64 noundef %mul, ptr noundef null)
  ret ptr %call
}

declare ptr @zcalloc_usable(i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Realloc(ptr noundef %ptr, i64 noundef %bytes) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %bytes.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i64, ptr %bytes.addr, align 8
  %call = call ptr @zrealloc_usable(ptr noundef %0, i64 noundef %1, ptr noundef null)
  ret ptr %call
}

declare ptr @zrealloc_usable(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_Free(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @zfree(ptr noundef %0)
  ret void
}

declare void @zfree(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Strdup(ptr noundef %str) #0 {
entry:
  %str.addr = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call noalias ptr @zstrdup(ptr noundef %0)
  ret ptr %call
}

declare noalias ptr @zstrdup(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @poolAllocRelease(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %head = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %pa_head = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 13
  %1 = load ptr, ptr %pa_head, align 8
  store ptr %1, ptr %head, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load ptr, ptr %head, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %head, align 8
  %next1 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %next1, align 8
  store ptr %4, ptr %next, align 8
  %5 = load ptr, ptr %head, align 8
  call void @zfree(ptr noundef %5)
  %6 = load ptr, ptr %next, align 8
  store ptr %6, ptr %head, align 8
  br label %while.cond, !llvm.loop !5

while.end:                                        ; preds = %while.cond
  %7 = load ptr, ptr %ctx.addr, align 8
  %pa_head2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 13
  store ptr null, ptr %pa_head2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_PoolAlloc(ptr noundef %ctx, i64 noundef %bytes) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %bytes.addr = alloca i64, align 8
  %b = alloca ptr, align 8
  %left = alloca i64, align 8
  %alignment = alloca i64, align 8
  %blocksize = alloca i64, align 8
  %retval48 = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  %0 = load i64, ptr %bytes.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %pa_head = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 13
  %2 = load ptr, ptr %pa_head, align 8
  store ptr %2, ptr %b, align 8
  %3 = load ptr, ptr %b, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %4 = load ptr, ptr %b, align 8
  %size = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %size, align 8
  %6 = load ptr, ptr %b, align 8
  %used = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %used, align 4
  %sub = sub i32 %5, %7
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ 0, %cond.false ]
  %conv = zext i32 %cond to i64
  store i64 %conv, ptr %left, align 8
  %8 = load i64, ptr %left, align 8
  %9 = load i64, ptr %bytes.addr, align 8
  %cmp1 = icmp uge i64 %8, %9
  br i1 %cmp1, label %if.then3, label %if.end33

if.then3:                                         ; preds = %cond.end
  store i64 8, ptr %alignment, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then3
  %10 = load i64, ptr %bytes.addr, align 8
  %11 = load i64, ptr %alignment, align 8
  %cmp4 = icmp ult i64 %10, %11
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %12 = load i64, ptr %alignment, align 8
  %div = udiv i64 %12, 2
  %13 = load i64, ptr %bytes.addr, align 8
  %cmp6 = icmp uge i64 %div, %13
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %14 = phi i1 [ false, %while.cond ], [ %cmp6, %land.rhs ]
  br i1 %14, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %15 = load i64, ptr %alignment, align 8
  %div8 = udiv i64 %15, 2
  store i64 %div8, ptr %alignment, align 8
  br label %while.cond, !llvm.loop !7

while.end:                                        ; preds = %land.end
  %16 = load ptr, ptr %b, align 8
  %used9 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %16, i32 0, i32 1
  %17 = load i32, ptr %used9, align 4
  %conv10 = zext i32 %17 to i64
  %18 = load i64, ptr %alignment, align 8
  %rem = urem i64 %conv10, %18
  %tobool11 = icmp ne i64 %rem, 0
  br i1 %tobool11, label %if.then12, label %if.end20

if.then12:                                        ; preds = %while.end
  %19 = load i64, ptr %alignment, align 8
  %20 = load ptr, ptr %b, align 8
  %used13 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %20, i32 0, i32 1
  %21 = load i32, ptr %used13, align 4
  %conv14 = zext i32 %21 to i64
  %22 = load i64, ptr %alignment, align 8
  %rem15 = urem i64 %conv14, %22
  %sub16 = sub i64 %19, %rem15
  %23 = load ptr, ptr %b, align 8
  %used17 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %23, i32 0, i32 1
  %24 = load i32, ptr %used17, align 4
  %conv18 = zext i32 %24 to i64
  %add = add i64 %conv18, %sub16
  %conv19 = trunc i64 %add to i32
  store i32 %conv19, ptr %used17, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then12, %while.end
  %25 = load ptr, ptr %b, align 8
  %used21 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %25, i32 0, i32 1
  %26 = load i32, ptr %used21, align 4
  %27 = load ptr, ptr %b, align 8
  %size22 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %27, i32 0, i32 0
  %28 = load i32, ptr %size22, align 8
  %cmp23 = icmp ugt i32 %26, %28
  br i1 %cmp23, label %cond.true25, label %cond.false26

cond.true25:                                      ; preds = %if.end20
  br label %cond.end30

cond.false26:                                     ; preds = %if.end20
  %29 = load ptr, ptr %b, align 8
  %size27 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %29, i32 0, i32 0
  %30 = load i32, ptr %size27, align 8
  %31 = load ptr, ptr %b, align 8
  %used28 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %31, i32 0, i32 1
  %32 = load i32, ptr %used28, align 4
  %sub29 = sub i32 %30, %32
  br label %cond.end30

cond.end30:                                       ; preds = %cond.false26, %cond.true25
  %cond31 = phi i32 [ 0, %cond.true25 ], [ %sub29, %cond.false26 ]
  %conv32 = zext i32 %cond31 to i64
  store i64 %conv32, ptr %left, align 8
  br label %if.end33

if.end33:                                         ; preds = %cond.end30, %cond.end
  %33 = load i64, ptr %left, align 8
  %34 = load i64, ptr %bytes.addr, align 8
  %cmp34 = icmp ult i64 %33, %34
  br i1 %cmp34, label %if.then36, label %if.end47

if.then36:                                        ; preds = %if.end33
  store i64 8192, ptr %blocksize, align 8
  %35 = load i64, ptr %blocksize, align 8
  %36 = load i64, ptr %bytes.addr, align 8
  %cmp37 = icmp ult i64 %35, %36
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.then36
  %37 = load i64, ptr %bytes.addr, align 8
  store i64 %37, ptr %blocksize, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %if.then36
  %38 = load i64, ptr %blocksize, align 8
  %add41 = add i64 16, %38
  %call = call noalias ptr @zmalloc(i64 noundef %add41) #11
  store ptr %call, ptr %b, align 8
  %39 = load i64, ptr %blocksize, align 8
  %conv42 = trunc i64 %39 to i32
  %40 = load ptr, ptr %b, align 8
  %size43 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %40, i32 0, i32 0
  store i32 %conv42, ptr %size43, align 8
  %41 = load ptr, ptr %b, align 8
  %used44 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %41, i32 0, i32 1
  store i32 0, ptr %used44, align 4
  %42 = load ptr, ptr %ctx.addr, align 8
  %pa_head45 = getelementptr inbounds %struct.RedisModuleCtx, ptr %42, i32 0, i32 13
  %43 = load ptr, ptr %pa_head45, align 8
  %44 = load ptr, ptr %b, align 8
  %next = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %44, i32 0, i32 2
  store ptr %43, ptr %next, align 8
  %45 = load ptr, ptr %b, align 8
  %46 = load ptr, ptr %ctx.addr, align 8
  %pa_head46 = getelementptr inbounds %struct.RedisModuleCtx, ptr %46, i32 0, i32 13
  store ptr %45, ptr %pa_head46, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.end40, %if.end33
  %47 = load ptr, ptr %b, align 8
  %memory = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %47, i32 0, i32 3
  %arraydecay = getelementptr inbounds [0 x i8], ptr %memory, i64 0, i64 0
  %48 = load ptr, ptr %b, align 8
  %used49 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %48, i32 0, i32 1
  %49 = load i32, ptr %used49, align 4
  %idx.ext = zext i32 %49 to i64
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay, i64 %idx.ext
  store ptr %add.ptr, ptr %retval48, align 8
  %50 = load i64, ptr %bytes.addr, align 8
  %51 = load ptr, ptr %b, align 8
  %used50 = getelementptr inbounds %struct.RedisModulePoolAllocBlock, ptr %51, i32 0, i32 1
  %52 = load i32, ptr %used50, align 4
  %conv51 = zext i32 %52 to i64
  %add52 = add i64 %conv51, %50
  %conv53 = trunc i64 %add52 to i32
  store i32 %conv53, ptr %used50, align 4
  %53 = load ptr, ptr %retval48, align 8
  store ptr %53, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end47, %if.then
  %54 = load ptr, ptr %retval, align 8
  ret ptr %54
}

; Function Attrs: allocsize(0)
declare noalias ptr @zmalloc(i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleAllocTempClient() #0 {
entry:
  %c = alloca ptr, align 8
  store ptr null, ptr %c, align 8
  %0 = load i64, ptr @moduleTempClientCount, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @moduleTempClients, align 8
  %2 = load i64, ptr @moduleTempClientCount, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr @moduleTempClientCount, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %dec
  %3 = load ptr, ptr %arrayidx, align 8
  store ptr %3, ptr %c, align 8
  %4 = load i64, ptr @moduleTempClientCount, align 8
  %5 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp1 = icmp ult i64 %4, %5
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %6 = load i64, ptr @moduleTempClientCount, align 8
  store i64 %6, ptr @moduleTempClientMinCount, align 8
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  br label %if.end3

if.else:                                          ; preds = %entry
  %call = call ptr @createClient(ptr noundef null)
  store ptr %call, ptr %c, align 8
  %7 = load ptr, ptr %c, align 8
  %flags = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 1
  %8 = load i64, ptr %flags, align 8
  %or = or i64 %8, 134217728
  store i64 %or, ptr %flags, align 8
  %9 = load ptr, ptr %c, align 8
  %user = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 20
  store ptr null, ptr %user, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.else, %if.end
  %10 = load ptr, ptr %c, align 8
  ret ptr %10
}

declare ptr @createClient(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleReleaseTempClient(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %promise = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load i64, ptr @moduleTempClientCount, align 8
  %1 = load i64, ptr @moduleTempClientCap, align 8
  %cmp = icmp eq i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr @moduleTempClientCap, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %3 = load i64, ptr @moduleTempClientCap, align 8
  %mul = mul i64 %3, 2
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 32, %cond.false ]
  store i64 %cond, ptr @moduleTempClientCap, align 8
  %4 = load ptr, ptr @moduleTempClients, align 8
  %5 = load i64, ptr @moduleTempClientCap, align 8
  %mul1 = mul i64 8, %5
  %call = call ptr @zrealloc(ptr noundef %4, i64 noundef %mul1) #12
  store ptr %call, ptr @moduleTempClients, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %6 = load ptr, ptr %c.addr, align 8
  call void @clearClientConnectionState(ptr noundef %6)
  %7 = load ptr, ptr %c.addr, align 8
  %reply = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 24
  %8 = load ptr, ptr %reply, align 8
  call void @listEmpty(ptr noundef %8)
  %9 = load ptr, ptr %c.addr, align 8
  %reply_bytes = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 25
  store i64 0, ptr %reply_bytes, align 8
  %10 = load ptr, ptr %c.addr, align 8
  %duration = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 29
  store i64 0, ptr %duration, align 8
  %11 = load ptr, ptr %c.addr, align 8
  call void @resetClient(ptr noundef %11)
  %12 = load ptr, ptr %c.addr, align 8
  %bufpos = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 82
  store i32 0, ptr %bufpos, align 8
  %13 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 1
  store i64 134217728, ptr %flags, align 8
  %14 = load ptr, ptr %c.addr, align 8
  %user = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 20
  store ptr null, ptr %user, align 8
  %15 = load ptr, ptr %c.addr, align 8
  %realcmd = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 19
  store ptr null, ptr %realcmd, align 8
  %16 = load ptr, ptr %c.addr, align 8
  %lastcmd = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 18
  store ptr null, ptr %lastcmd, align 8
  %17 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 17
  store ptr null, ptr %cmd, align 8
  %18 = load ptr, ptr %c.addr, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %18, i32 0, i32 55
  %async_rm_call_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 8
  %19 = load ptr, ptr %async_rm_call_handle, align 8
  %tobool2 = icmp ne ptr %19, null
  br i1 %tobool2, label %if.then3, label %if.end9

if.then3:                                         ; preds = %if.end
  %20 = load ptr, ptr %c.addr, align 8
  %bstate4 = getelementptr inbounds %struct.client, ptr %20, i32 0, i32 55
  %async_rm_call_handle5 = getelementptr inbounds %struct.blockingState, ptr %bstate4, i32 0, i32 8
  %21 = load ptr, ptr %async_rm_call_handle5, align 8
  store ptr %21, ptr %promise, align 8
  %22 = load ptr, ptr %promise, align 8
  %c6 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %22, i32 0, i32 4
  store ptr null, ptr %c6, align 8
  %23 = load ptr, ptr %promise, align 8
  call void @freeRedisModuleAsyncRMCallPromise(ptr noundef %23)
  %24 = load ptr, ptr %c.addr, align 8
  %bstate7 = getelementptr inbounds %struct.client, ptr %24, i32 0, i32 55
  %async_rm_call_handle8 = getelementptr inbounds %struct.blockingState, ptr %bstate7, i32 0, i32 8
  store ptr null, ptr %async_rm_call_handle8, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then3, %if.end
  %25 = load ptr, ptr %c.addr, align 8
  %26 = load ptr, ptr @moduleTempClients, align 8
  %27 = load i64, ptr @moduleTempClientCount, align 8
  %inc = add i64 %27, 1
  store i64 %inc, ptr @moduleTempClientCount, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %26, i64 %27
  store ptr %25, ptr %arrayidx, align 8
  ret void
}

; Function Attrs: allocsize(1)
declare ptr @zrealloc(ptr noundef, i64 noundef) #3

declare void @clearClientConnectionState(ptr noundef) #1

declare void @listEmpty(ptr noundef) #1

declare void @resetClient(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @freeRedisModuleAsyncRMCallPromise(ptr noundef %promise) #0 {
entry:
  %promise.addr = alloca ptr, align 8
  store ptr %promise, ptr %promise.addr, align 8
  %0 = load ptr, ptr %promise.addr, align 8
  %ref_count = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %ref_count, align 8
  %dec = add i64 %1, -1
  store i64 %dec, ptr %ref_count, align 8
  %cmp = icmp ugt i64 %dec, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %promise.addr, align 8
  %c = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %3, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  call void @_serverAssert(ptr noundef @.str.523, ptr noundef @.str.2, i32 noundef 649)
  call void @abort() #13
  unreachable

4:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load ptr, ptr %promise.addr, align 8
  call void @zfree(ptr noundef %5)
  br label %return

return:                                           ; preds = %cond.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleCreateEmptyKey(ptr noundef %key, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %obj = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load i32, ptr %type.addr, align 4
  switch i32 %4, label %sw.default [
    i32 2, label %sw.bb
    i32 5, label %sw.bb2
    i32 3, label %sw.bb4
    i32 7, label %sw.bb6
  ]

sw.bb:                                            ; preds = %if.end
  %call = call ptr @createListListpackObject()
  store ptr %call, ptr %obj, align 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.end
  %call3 = call ptr @createZsetListpackObject()
  store ptr %call3, ptr %obj, align 8
  br label %sw.epilog

sw.bb4:                                           ; preds = %if.end
  %call5 = call ptr @createHashObject()
  store ptr %call5, ptr %obj, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.end
  %call7 = call ptr @createStreamObject()
  store ptr %call7, ptr %obj, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb6, %sw.bb4, %sw.bb2, %sw.bb
  %5 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %db, align 8
  %7 = load ptr, ptr %key.addr, align 8
  %key8 = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %key8, align 8
  %9 = load ptr, ptr %obj, align 8
  call void @dbAdd(ptr noundef %6, ptr noundef %8, ptr noundef %9)
  %10 = load ptr, ptr %obj, align 8
  %11 = load ptr, ptr %key.addr, align 8
  %value9 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 3
  store ptr %10, ptr %value9, align 8
  %12 = load ptr, ptr %key.addr, align 8
  call void @moduleInitKeyTypeSpecific(ptr noundef %12)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

declare ptr @createListListpackObject() #1

declare ptr @createZsetListpackObject() #1

declare ptr @createHashObject() #1

declare ptr @createStreamObject() #1

declare void @dbAdd(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @moduleInitKeyTypeSpecific(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %bf.load = load i32, ptr %1, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %sw.epilog [
    i32 3, label %sw.bb
    i32 6, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  call void @zsetKeyReset(ptr noundef %2)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %3 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 6
  %signalready = getelementptr inbounds %struct.anon.1, ptr %u, i32 0, i32 2
  store i32 0, ptr %signalready, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %sw.bb, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleDelKeyIfEmpty(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %isempty = alloca i32, align 4
  %o = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value1, align 8
  store ptr %5, ptr %o, align 8
  %6 = load ptr, ptr %o, align 8
  %bf.load = load i32, ptr %6, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb3
    i32 3, label %sw.bb7
    i32 4, label %sw.bb11
    i32 6, label %sw.bb15
  ]

sw.bb:                                            ; preds = %if.end
  %7 = load ptr, ptr %o, align 8
  %call = call i64 @listTypeLength(ptr noundef %7)
  %cmp2 = icmp eq i64 %call, 0
  %conv = zext i1 %cmp2 to i32
  store i32 %conv, ptr %isempty, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.end
  %8 = load ptr, ptr %o, align 8
  %call4 = call i64 @setTypeSize(ptr noundef %8)
  %cmp5 = icmp eq i64 %call4, 0
  %conv6 = zext i1 %cmp5 to i32
  store i32 %conv6, ptr %isempty, align 4
  br label %sw.epilog

sw.bb7:                                           ; preds = %if.end
  %9 = load ptr, ptr %o, align 8
  %call8 = call i64 @zsetLength(ptr noundef %9)
  %cmp9 = icmp eq i64 %call8, 0
  %conv10 = zext i1 %cmp9 to i32
  store i32 %conv10, ptr %isempty, align 4
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end
  %10 = load ptr, ptr %o, align 8
  %call12 = call i64 @hashTypeLength(ptr noundef %10)
  %cmp13 = icmp eq i64 %call12, 0
  %conv14 = zext i1 %cmp13 to i32
  store i32 %conv14, ptr %isempty, align 4
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.end
  %11 = load ptr, ptr %o, align 8
  %call16 = call i64 @streamLength(ptr noundef %11)
  %cmp17 = icmp eq i64 %call16, 0
  %conv18 = zext i1 %cmp17 to i32
  store i32 %conv18, ptr %isempty, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  store i32 0, ptr %isempty, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb15, %sw.bb11, %sw.bb7, %sw.bb3, %sw.bb
  %12 = load i32, ptr %isempty, align 4
  %tobool19 = icmp ne i32 %12, 0
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %sw.epilog
  %13 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %iter, align 8
  %tobool21 = icmp ne ptr %14, null
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then20
  %15 = load ptr, ptr %key.addr, align 8
  call void @moduleFreeKeyIterator(ptr noundef %15)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then20
  %16 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %db, align 8
  %18 = load ptr, ptr %key.addr, align 8
  %key24 = getelementptr inbounds %struct.RedisModuleKey, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %key24, align 8
  %call25 = call i32 @dbDelete(ptr noundef %17, ptr noundef %19)
  %20 = load ptr, ptr %key.addr, align 8
  %value26 = getelementptr inbounds %struct.RedisModuleKey, ptr %20, i32 0, i32 3
  store ptr null, ptr %value26, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %sw.epilog
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.end23, %if.then
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

declare i64 @listTypeLength(ptr noundef) #1

declare i64 @setTypeSize(ptr noundef) #1

declare i64 @zsetLength(ptr noundef) #1

declare i64 @hashTypeLength(ptr noundef) #1

declare i64 @streamLength(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @moduleFreeKeyIterator(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %iter, align 8
  %cmp = icmp ne ptr %1, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.43, ptr noundef @.str.2, i32 noundef 718)
  call void @abort() #13
  unreachable

2:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %2, %cond.true
  %3 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %sw.default [
    i32 1, label %sw.bb
    i32 6, label %sw.bb3
  ]

sw.bb:                                            ; preds = %cond.end
  %5 = load ptr, ptr %key.addr, align 8
  %iter2 = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %iter2, align 8
  call void @listTypeReleaseIterator(ptr noundef %6)
  br label %sw.epilog

sw.bb3:                                           ; preds = %cond.end
  %7 = load ptr, ptr %key.addr, align 8
  %iter4 = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %iter4, align 8
  call void @streamIteratorStop(ptr noundef %8)
  %9 = load ptr, ptr %key.addr, align 8
  %iter5 = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 4
  %10 = load ptr, ptr %iter5, align 8
  call void @zfree(ptr noundef %10)
  br label %sw.epilog

sw.default:                                       ; preds = %cond.end
  call void @_serverAssert(ptr noundef @.str.151, ptr noundef @.str.2, i32 noundef 725)
  call void @abort() #13
  unreachable

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb
  %11 = load ptr, ptr %key.addr, align 8
  %iter6 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 4
  store ptr null, ptr %iter6, align 8
  ret void
}

declare i32 @dbDelete(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetApi(ptr noundef %funcname, ptr noundef %targetPtrPtr) #0 {
entry:
  %retval = alloca i32, align 4
  %funcname.addr = alloca ptr, align 8
  %targetPtrPtr.addr = alloca ptr, align 8
  %he = alloca ptr, align 8
  store ptr %funcname, ptr %funcname.addr, align 8
  store ptr %targetPtrPtr, ptr %targetPtrPtr.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 37), align 8
  %1 = load ptr, ptr %funcname.addr, align 8
  %call = call ptr @dictFind(ptr noundef %0, ptr noundef %1)
  store ptr %call, ptr %he, align 8
  %2 = load ptr, ptr %he, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %he, align 8
  %call1 = call ptr @dictGetVal(ptr noundef %3)
  %4 = load ptr, ptr %targetPtrPtr.addr, align 8
  store ptr %call1, ptr %4, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

declare ptr @dictFind(ptr noundef, ptr noundef) #1

declare ptr @dictGetVal(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @modulePostExecutionUnitOperations() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end6

if.end:                                           ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  call void @blockingOperationEnds()
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %tobool3 = icmp ne ptr %2, null
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then2
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  call void @unprotectClient(ptr noundef %3)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.then2
  call void @unblockPostponedClients()
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.end, %if.then
  ret void
}

declare void @blockingOperationEnds() #1

declare void @unprotectClient(ptr noundef) #1

declare void @unblockPostponedClients() #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleFreeContext(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 528
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @exitExecutionUnit()
  call void @postExecutionUnitOperations()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  call void @autoMemoryCollect(ptr noundef %2)
  %3 = load ptr, ptr %ctx.addr, align 8
  call void @poolAllocRelease(ptr noundef %3)
  %4 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 8
  %5 = load ptr, ptr %postponed_arrays, align 8
  %tobool1 = icmp ne ptr %5, null
  br i1 %tobool1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %6 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %6, i32 0, i32 8
  %7 = load ptr, ptr %postponed_arrays3, align 8
  call void @zfree(ptr noundef %7)
  %8 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 9
  store i32 0, ptr %postponed_arrays_count, align 8
  br label %do.body

do.body:                                          ; preds = %if.then2
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 3, %9
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %do.body
  br label %do.end

if.end5:                                          ; preds = %do.body
  %10 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %name, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str, ptr noundef %12)
  br label %do.end

do.end:                                           ; preds = %if.end5, %if.then4
  br label %if.end6

if.end6:                                          ; preds = %do.end, %if.end
  %13 = load ptr, ptr %ctx.addr, align 8
  %flags7 = getelementptr inbounds %struct.RedisModuleCtx, ptr %13, i32 0, i32 7
  %14 = load i32, ptr %flags7, align 8
  %and8 = and i32 %14, 64
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end6
  %15 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %client, align 8
  call void @moduleReleaseTempClient(ptr noundef %16)
  br label %if.end17

if.else:                                          ; preds = %if.end6
  %17 = load ptr, ptr %ctx.addr, align 8
  %flags11 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i32 0, i32 7
  %18 = load i32, ptr %flags11, align 8
  %and12 = and i32 %18, 128
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.else
  %19 = load ptr, ptr %ctx.addr, align 8
  %client15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %client15, align 8
  call void @freeClient(ptr noundef %20)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.else
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.then10
  ret void
}

declare void @exitExecutionUnit() #1

declare void @postExecutionUnitOperations() #1

; Function Attrs: nounwind uwtable
define dso_local void @autoMemoryCollect(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %ptr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %flags1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %flags1, align 8
  %and2 = and i32 %3, -2
  store i32 %and2, ptr %flags1, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, ptr %j, align 4
  %5 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i32 0, i32 6
  %6 = load i32, ptr %amqueue_used, align 4
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %ctx.addr, align 8
  %amqueue = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %amqueue, align 8
  %9 = load i32, ptr %j, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds %struct.AutoMemEntry, ptr %8, i64 %idxprom
  %ptr3 = getelementptr inbounds %struct.AutoMemEntry, ptr %arrayidx, i32 0, i32 0
  %10 = load ptr, ptr %ptr3, align 8
  store ptr %10, ptr %ptr, align 8
  %11 = load ptr, ptr %ctx.addr, align 8
  %amqueue4 = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i32 0, i32 4
  %12 = load ptr, ptr %amqueue4, align 8
  %13 = load i32, ptr %j, align 4
  %idxprom5 = sext i32 %13 to i64
  %arrayidx6 = getelementptr inbounds %struct.AutoMemEntry, ptr %12, i64 %idxprom5
  %type = getelementptr inbounds %struct.AutoMemEntry, ptr %arrayidx6, i32 0, i32 1
  %14 = load i32, ptr %type, align 8
  switch i32 %14, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb7
    i32 0, label %sw.bb8
    i32 4, label %sw.bb9
    i32 5, label %sw.bb10
  ]

sw.bb:                                            ; preds = %for.body
  %15 = load ptr, ptr %ptr, align 8
  call void @decrRefCount(ptr noundef %15)
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.body
  %16 = load ptr, ptr %ptr, align 8
  call void @RM_FreeCallReply(ptr noundef %16)
  br label %sw.epilog

sw.bb8:                                           ; preds = %for.body
  %17 = load ptr, ptr %ptr, align 8
  call void @RM_CloseKey(ptr noundef %17)
  br label %sw.epilog

sw.bb9:                                           ; preds = %for.body
  %18 = load ptr, ptr %ptr, align 8
  call void @RM_FreeDict(ptr noundef null, ptr noundef %18)
  br label %sw.epilog

sw.bb10:                                          ; preds = %for.body
  %19 = load ptr, ptr %ptr, align 8
  call void @RM_FreeServerInfo(ptr noundef null, ptr noundef %19)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb, %for.body
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %20 = load i32, ptr %j, align 4
  %inc = add nsw i32 %20, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !8

for.end:                                          ; preds = %for.cond
  %21 = load ptr, ptr %ctx.addr, align 8
  %flags11 = getelementptr inbounds %struct.RedisModuleCtx, ptr %21, i32 0, i32 7
  %22 = load i32, ptr %flags11, align 8
  %or = or i32 %22, 1
  store i32 %or, ptr %flags11, align 8
  %23 = load ptr, ptr %ctx.addr, align 8
  %amqueue12 = getelementptr inbounds %struct.RedisModuleCtx, ptr %23, i32 0, i32 4
  %24 = load ptr, ptr %amqueue12, align 8
  call void @zfree(ptr noundef %24)
  %25 = load ptr, ptr %ctx.addr, align 8
  %amqueue13 = getelementptr inbounds %struct.RedisModuleCtx, ptr %25, i32 0, i32 4
  store ptr null, ptr %amqueue13, align 8
  %26 = load ptr, ptr %ctx.addr, align 8
  %amqueue_len = getelementptr inbounds %struct.RedisModuleCtx, ptr %26, i32 0, i32 5
  store i32 0, ptr %amqueue_len, align 8
  %27 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used14 = getelementptr inbounds %struct.RedisModuleCtx, ptr %27, i32 0, i32 6
  store i32 0, ptr %amqueue_used14, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

declare void @_serverLog(i32 noundef, ptr noundef, ...) #1

declare void @freeClient(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleCallCommandUnblockedHandler(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %promise = alloca ptr, align 8
  %module = alloca ptr, align 8
  %reply = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 55
  %async_rm_call_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 8
  %1 = load ptr, ptr %async_rm_call_handle, align 8
  store ptr %1, ptr %promise, align 8
  %2 = load ptr, ptr %promise, align 8
  %tobool = icmp ne ptr %2, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.1, ptr noundef @.str.2, i32 noundef 855)
  call void @abort() #13
  unreachable

3:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load ptr, ptr %promise, align 8
  %module3 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %module3, align 8
  store ptr %5, ptr %module, align 8
  %6 = load ptr, ptr %promise, align 8
  %on_unblocked = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %on_unblocked, align 8
  %tobool4 = icmp ne ptr %7, null
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %8 = load ptr, ptr %c.addr, align 8
  call void @moduleReleaseTempClient(ptr noundef %8)
  br label %return

if.end:                                           ; preds = %cond.end
  %9 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %9, i32 noundef 64)
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  %10 = load ptr, ptr %client, align 8
  %11 = load ptr, ptr %c.addr, align 8
  %db = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 4
  %12 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %12, i32 0, i32 6
  %13 = load i32, ptr %id, align 8
  %call = call i32 @selectDb(ptr noundef %10, i32 noundef %13)
  %14 = load ptr, ptr %c.addr, align 8
  %call5 = call ptr @moduleParseReply(ptr noundef %14, ptr noundef null)
  store ptr %call5, ptr %reply, align 8
  %15 = load ptr, ptr %module, align 8
  %in_call = getelementptr inbounds %struct.RedisModule, ptr %15, i32 0, i32 10
  %16 = load i32, ptr %in_call, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %in_call, align 4
  %17 = load ptr, ptr %promise, align 8
  %on_unblocked6 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %on_unblocked6, align 8
  %19 = load ptr, ptr %reply, align 8
  %20 = load ptr, ptr %promise, align 8
  %private_data = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %20, i32 0, i32 1
  %21 = load ptr, ptr %private_data, align 8
  call void %18(ptr noundef %ctx, ptr noundef %19, ptr noundef %21)
  %22 = load ptr, ptr %module, align 8
  %in_call7 = getelementptr inbounds %struct.RedisModule, ptr %22, i32 0, i32 10
  %23 = load i32, ptr %in_call7, align 4
  %dec = add nsw i32 %23, -1
  store i32 %dec, ptr %in_call7, align 4
  call void @moduleFreeContext(ptr noundef %ctx)
  %24 = load ptr, ptr %c.addr, align 8
  call void @moduleReleaseTempClient(ptr noundef %24)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @_serverAssert(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: noreturn nounwind
declare void @abort() #4

; Function Attrs: nounwind uwtable
define dso_local void @moduleCreateContext(ptr noundef %out_ctx, ptr noundef %module, i32 noundef %ctx_flags) #0 {
entry:
  %out_ctx.addr = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %ctx_flags.addr = alloca i32, align 4
  store ptr %out_ctx, ptr %out_ctx.addr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 %ctx_flags, ptr %ctx_flags.addr, align 4
  %0 = load ptr, ptr %out_ctx.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %0, i8 0, i64 120, i1 false)
  %1 = load ptr, ptr %out_ctx.addr, align 8
  %getapifuncptr = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 0
  store ptr @RM_GetApi, ptr %getapifuncptr, align 8
  %2 = load ptr, ptr %module.addr, align 8
  %3 = load ptr, ptr %out_ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %3, i32 0, i32 1
  store ptr %2, ptr %module1, align 8
  %4 = load i32, ptr %ctx_flags.addr, align 4
  %5 = load ptr, ptr %out_ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i32 0, i32 7
  store i32 %4, ptr %flags, align 8
  %6 = load i32, ptr %ctx_flags.addr, align 4
  %and = and i32 %6, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call ptr @moduleAllocTempClient()
  %7 = load ptr, ptr %out_ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 2
  store ptr %call, ptr %client, align 8
  br label %if.end7

if.else:                                          ; preds = %entry
  %8 = load i32, ptr %ctx_flags.addr, align 4
  %and2 = and i32 %8, 128
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %call5 = call ptr @createClient(ptr noundef null)
  %9 = load ptr, ptr %out_ctx.addr, align 8
  %client6 = getelementptr inbounds %struct.RedisModuleCtx, ptr %9, i32 0, i32 2
  store ptr %call5, ptr %client6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %10 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool8 = icmp ne i32 %10, 0
  br i1 %tobool8, label %if.then9, label %if.else11

if.then9:                                         ; preds = %if.end7
  %11 = load ptr, ptr @getMonotonicUs, align 8
  %call10 = call i64 %11()
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div = sdiv i32 1000000, %12
  %conv = sext i32 %div to i64
  %add = add i64 %call10, %conv
  %13 = load ptr, ptr %out_ctx.addr, align 8
  %next_yield_time = getelementptr inbounds %struct.RedisModuleCtx, ptr %13, i32 0, i32 14
  store i64 %add, ptr %next_yield_time, align 8
  br label %if.end15

if.else11:                                        ; preds = %if.end7
  %14 = load ptr, ptr @getMonotonicUs, align 8
  %call12 = call i64 %14()
  %15 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 385), align 8
  %mul = mul nsw i64 %15, 1000
  %add13 = add i64 %call12, %mul
  %16 = load ptr, ptr %out_ctx.addr, align 8
  %next_yield_time14 = getelementptr inbounds %struct.RedisModuleCtx, ptr %16, i32 0, i32 14
  store i64 %add13, ptr %next_yield_time14, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.else11, %if.then9
  %17 = load i32, ptr %ctx_flags.addr, align 4
  %and16 = and i32 %17, 528
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end15
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end15
  ret void
}

declare i32 @selectDb(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @moduleParseReply(ptr noundef %c, ptr noundef %ctx) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %proto = alloca ptr, align 8
  %o = alloca ptr, align 8
  %reply8 = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %buf = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 84
  %1 = load ptr, ptr %buf, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %bufpos = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 82
  %3 = load i32, ptr %bufpos, align 8
  %conv = sext i32 %3 to i64
  %call = call ptr @sdsnewlen(ptr noundef %1, i64 noundef %conv)
  store ptr %call, ptr %proto, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %bufpos1 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 82
  store i32 0, ptr %bufpos1, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %5 = load ptr, ptr %c.addr, align 8
  %reply = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 24
  %6 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.list, ptr %6, i32 0, i32 5
  %7 = load i64, ptr %len, align 8
  %tobool = icmp ne i64 %7, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load ptr, ptr %c.addr, align 8
  %reply2 = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 24
  %9 = load ptr, ptr %reply2, align 8
  %head = getelementptr inbounds %struct.list, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %head, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %value, align 8
  store ptr %11, ptr %o, align 8
  %12 = load ptr, ptr %proto, align 8
  %13 = load ptr, ptr %o, align 8
  %buf3 = getelementptr inbounds %struct.clientReplyBlock, ptr %13, i32 0, i32 2
  %arraydecay = getelementptr inbounds [0 x i8], ptr %buf3, i64 0, i64 0
  %14 = load ptr, ptr %o, align 8
  %used = getelementptr inbounds %struct.clientReplyBlock, ptr %14, i32 0, i32 1
  %15 = load i64, ptr %used, align 8
  %call4 = call ptr @sdscatlen(ptr noundef %12, ptr noundef %arraydecay, i64 noundef %15)
  store ptr %call4, ptr %proto, align 8
  %16 = load ptr, ptr %c.addr, align 8
  %reply5 = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 24
  %17 = load ptr, ptr %reply5, align 8
  %18 = load ptr, ptr %c.addr, align 8
  %reply6 = getelementptr inbounds %struct.client, ptr %18, i32 0, i32 24
  %19 = load ptr, ptr %reply6, align 8
  %head7 = getelementptr inbounds %struct.list, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %head7, align 8
  call void @listDelNode(ptr noundef %17, ptr noundef %20)
  br label %while.cond, !llvm.loop !9

while.end:                                        ; preds = %while.cond
  %21 = load ptr, ptr %proto, align 8
  %22 = load ptr, ptr %c.addr, align 8
  %deferred_reply_errors = getelementptr inbounds %struct.client, ptr %22, i32 0, i32 26
  %23 = load ptr, ptr %deferred_reply_errors, align 8
  %24 = load ptr, ptr %ctx.addr, align 8
  %call9 = call ptr @callReplyCreate(ptr noundef %21, ptr noundef %23, ptr noundef %24)
  store ptr %call9, ptr %reply8, align 8
  %25 = load ptr, ptr %c.addr, align 8
  %deferred_reply_errors10 = getelementptr inbounds %struct.client, ptr %25, i32 0, i32 26
  store ptr null, ptr %deferred_reply_errors10, align 8
  %26 = load ptr, ptr %reply8, align 8
  ret ptr %26
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #5

declare void @enterExecutionUnit(i32 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RedisModuleCommandDispatcher(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cp = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %i = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 17
  %1 = load ptr, ptr %cmd, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 32
  %2 = load ptr, ptr %module_cmd, align 8
  store ptr %2, ptr %cp, align 8
  %3 = load ptr, ptr %cp, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommand, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %4, i32 noundef 512)
  %5 = load ptr, ptr %c.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %5, ptr %client, align 8
  %6 = load ptr, ptr %cp, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %func, align 8
  %8 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 12
  %9 = load ptr, ptr %argv, align 8
  %10 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 11
  %11 = load i32, ptr %argc, align 8
  %call = call i32 %7(ptr noundef %ctx, ptr noundef %9, i32 noundef %11)
  call void @moduleFreeContext(ptr noundef %ctx)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %12 = load i32, ptr %i, align 4
  %13 = load ptr, ptr %c.addr, align 8
  %argc1 = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 11
  %14 = load i32, ptr %argc1, align 8
  %cmp = icmp slt i32 %12, %14
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load ptr, ptr %c.addr, align 8
  %argv2 = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 12
  %16 = load ptr, ptr %argv2, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %16, i64 %idxprom
  %18 = load ptr, ptr %arrayidx, align 8
  %refcount = getelementptr inbounds %struct.redisObject, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %refcount, align 4
  %cmp3 = icmp sgt i32 %19, 1
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %20 = load ptr, ptr %c.addr, align 8
  %argv4 = getelementptr inbounds %struct.client, ptr %20, i32 0, i32 12
  %21 = load ptr, ptr %argv4, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom5 = sext i32 %22 to i64
  %arrayidx6 = getelementptr inbounds ptr, ptr %21, i64 %idxprom5
  %23 = load ptr, ptr %arrayidx6, align 8
  call void @trimStringObjectIfNeeded(ptr noundef %23, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %24 = load i32, ptr %i, align 4
  %inc = add nsw i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @trimStringObjectIfNeeded(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleGetCommandKeysViaAPI(ptr noundef %cmd, ptr noundef %argv, i32 noundef %argc, ptr noundef %result) #0 {
entry:
  %cmd.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %result.addr = alloca ptr, align 8
  %cp = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 32
  %1 = load ptr, ptr %module_cmd, align 8
  store ptr %1, ptr %cp, align 8
  %2 = load ptr, ptr %cp, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommand, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %3, i32 noundef 2)
  %4 = load ptr, ptr %result.addr, align 8
  %call = call ptr @getKeysPrepareResult(ptr noundef %4, i32 noundef 256)
  %5 = load ptr, ptr %result.addr, align 8
  %keys_result = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 12
  store ptr %5, ptr %keys_result, align 8
  %6 = load ptr, ptr %cp, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %func, align 8
  %8 = load ptr, ptr %argv.addr, align 8
  %9 = load i32, ptr %argc.addr, align 4
  %call1 = call i32 %7(ptr noundef %ctx, ptr noundef %8, i32 noundef %9)
  call void @moduleFreeContext(ptr noundef %ctx)
  %10 = load ptr, ptr %result.addr, align 8
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %10, i32 0, i32 2
  %11 = load i32, ptr %numkeys, align 8
  ret i32 %11
}

declare ptr @getKeysPrepareResult(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleGetCommandChannelsViaAPI(ptr noundef %cmd, ptr noundef %argv, i32 noundef %argc, ptr noundef %result) #0 {
entry:
  %cmd.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %result.addr = alloca ptr, align 8
  %cp = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 32
  %1 = load ptr, ptr %module_cmd, align 8
  store ptr %1, ptr %cp, align 8
  %2 = load ptr, ptr %cp, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommand, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %3, i32 noundef 256)
  %4 = load ptr, ptr %result.addr, align 8
  %call = call ptr @getKeysPrepareResult(ptr noundef %4, i32 noundef 256)
  %5 = load ptr, ptr %result.addr, align 8
  %keys_result = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 12
  store ptr %5, ptr %keys_result, align 8
  %6 = load ptr, ptr %cp, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %func, align 8
  %8 = load ptr, ptr %argv.addr, align 8
  %9 = load i32, ptr %argc.addr, align 4
  %call1 = call i32 %7(ptr noundef %ctx, ptr noundef %8, i32 noundef %9)
  call void @moduleFreeContext(ptr noundef %ctx)
  %10 = load ptr, ptr %result.addr, align 8
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %10, i32 0, i32 2
  %11 = load i32, ptr %numkeys, align 8
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_IsKeysPositionRequest(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_KeyAtPosWithFlags(ptr noundef %ctx, i32 noundef %pos, i32 noundef %flags) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %res = alloca ptr, align 8
  %newsize = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags1, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %keys_result = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 12
  %3 = load ptr, ptr %keys_result, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load i32, ptr %pos.addr, align 4
  %cmp = icmp sle i32 %4, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load ptr, ptr %ctx.addr, align 8
  %keys_result5 = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i32 0, i32 12
  %6 = load ptr, ptr %keys_result5, align 8
  store ptr %6, ptr %res, align 8
  %7 = load ptr, ptr %res, align 8
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %7, i32 0, i32 2
  %8 = load i32, ptr %numkeys, align 8
  %9 = load ptr, ptr %res, align 8
  %size = getelementptr inbounds %struct.getKeysResult, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %size, align 4
  %cmp6 = icmp eq i32 %8, %10
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end4
  %11 = load ptr, ptr %res, align 8
  %size8 = getelementptr inbounds %struct.getKeysResult, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %size8, align 4
  %13 = load ptr, ptr %res, align 8
  %size9 = getelementptr inbounds %struct.getKeysResult, ptr %13, i32 0, i32 3
  %14 = load i32, ptr %size9, align 4
  %cmp10 = icmp sgt i32 %14, 8192
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then7
  br label %cond.end

cond.false:                                       ; preds = %if.then7
  %15 = load ptr, ptr %res, align 8
  %size11 = getelementptr inbounds %struct.getKeysResult, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %size11, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 8192, %cond.true ], [ %16, %cond.false ]
  %add = add nsw i32 %12, %cond
  store i32 %add, ptr %newsize, align 4
  %17 = load ptr, ptr %res, align 8
  %18 = load i32, ptr %newsize, align 4
  %call = call ptr @getKeysPrepareResult(ptr noundef %17, i32 noundef %18)
  br label %if.end12

if.end12:                                         ; preds = %cond.end, %if.end4
  %19 = load i32, ptr %pos.addr, align 4
  %20 = load ptr, ptr %res, align 8
  %keys = getelementptr inbounds %struct.getKeysResult, ptr %20, i32 0, i32 1
  %21 = load ptr, ptr %keys, align 8
  %22 = load ptr, ptr %res, align 8
  %numkeys13 = getelementptr inbounds %struct.getKeysResult, ptr %22, i32 0, i32 2
  %23 = load i32, ptr %numkeys13, align 8
  %idxprom = sext i32 %23 to i64
  %arrayidx = getelementptr inbounds %struct.keyReference, ptr %21, i64 %idxprom
  %pos14 = getelementptr inbounds %struct.keyReference, ptr %arrayidx, i32 0, i32 0
  store i32 %19, ptr %pos14, align 4
  %24 = load i32, ptr %flags.addr, align 4
  %conv = sext i32 %24 to i64
  %call15 = call i64 @moduleConvertKeySpecsFlags(i64 noundef %conv, i32 noundef 1)
  %conv16 = trunc i64 %call15 to i32
  %25 = load ptr, ptr %res, align 8
  %keys17 = getelementptr inbounds %struct.getKeysResult, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %keys17, align 8
  %27 = load ptr, ptr %res, align 8
  %numkeys18 = getelementptr inbounds %struct.getKeysResult, ptr %27, i32 0, i32 2
  %28 = load i32, ptr %numkeys18, align 8
  %idxprom19 = sext i32 %28 to i64
  %arrayidx20 = getelementptr inbounds %struct.keyReference, ptr %26, i64 %idxprom19
  %flags21 = getelementptr inbounds %struct.keyReference, ptr %arrayidx20, i32 0, i32 1
  store i32 %conv16, ptr %flags21, align 4
  %29 = load ptr, ptr %res, align 8
  %numkeys22 = getelementptr inbounds %struct.getKeysResult, ptr %29, i32 0, i32 2
  %30 = load i32, ptr %numkeys22, align 8
  %inc = add nsw i32 %30, 1
  store i32 %inc, ptr %numkeys22, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then3, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @moduleConvertKeySpecsFlags(i64 noundef %flags, i32 noundef %from_api) #0 {
entry:
  %flags.addr = alloca i64, align 8
  %from_api.addr = alloca i32, align 4
  %out = alloca i64, align 8
  %map = alloca [12 x [2 x i64]], align 16
  %from_idx = alloca i32, align 4
  %to_idx = alloca i32, align 4
  %i = alloca i32, align 4
  store i64 %flags, ptr %flags.addr, align 8
  store i32 %from_api, ptr %from_api.addr, align 4
  store i64 0, ptr %out, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %map, ptr align 16 @__const.moduleConvertKeySpecsFlags.map, i64 192, i1 false)
  %0 = load i32, ptr %from_api.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i32 0, i32 1
  store i32 %cond, ptr %from_idx, align 4
  %1 = load i32, ptr %from_idx, align 4
  %tobool1 = icmp ne i32 %1, 0
  %lnot = xor i1 %tobool1, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %to_idx, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [12 x [2 x i64]], ptr %map, i64 0, i64 %idxprom
  %arrayidx2 = getelementptr inbounds [2 x i64], ptr %arrayidx, i64 0, i64 0
  %3 = load i64, ptr %arrayidx2, align 16
  %tobool3 = icmp ne i64 %3, 0
  br i1 %tobool3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, ptr %flags.addr, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom4 = sext i32 %5 to i64
  %arrayidx5 = getelementptr inbounds [12 x [2 x i64]], ptr %map, i64 0, i64 %idxprom4
  %6 = load i32, ptr %from_idx, align 4
  %idxprom6 = sext i32 %6 to i64
  %arrayidx7 = getelementptr inbounds [2 x i64], ptr %arrayidx5, i64 0, i64 %idxprom6
  %7 = load i64, ptr %arrayidx7, align 8
  %and = and i64 %4, %7
  %tobool8 = icmp ne i64 %and, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %8 to i64
  %arrayidx10 = getelementptr inbounds [12 x [2 x i64]], ptr %map, i64 0, i64 %idxprom9
  %9 = load i32, ptr %to_idx, align 4
  %idxprom11 = sext i32 %9 to i64
  %arrayidx12 = getelementptr inbounds [2 x i64], ptr %arrayidx10, i64 0, i64 %idxprom11
  %10 = load i64, ptr %arrayidx12, align 8
  %11 = load i64, ptr %out, align 8
  %or = or i64 %11, %10
  store i64 %or, ptr %out, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %12 = load i32, ptr %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !11

for.end:                                          ; preds = %for.cond
  %13 = load i64, ptr %out, align 8
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_KeyAtPos(ptr noundef %ctx, i32 noundef %pos) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %flags = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  %call = call i64 @moduleConvertKeySpecsFlags(i64 noundef 50, i32 noundef 0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %flags, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i32, ptr %pos.addr, align 4
  %2 = load i32, ptr %flags, align 4
  call void @RM_KeyAtPosWithFlags(ptr noundef %0, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_IsChannelsPositionRequest(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 256
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ChannelAtPosWithFlags(ptr noundef %ctx, i32 noundef %pos, i32 noundef %flags) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %res = alloca ptr, align 8
  %newsize = alloca i32, align 4
  %new_flags = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags1, align 8
  %and = and i32 %1, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %keys_result = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 12
  %3 = load ptr, ptr %keys_result, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load i32, ptr %pos.addr, align 4
  %cmp = icmp sle i32 %4, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load ptr, ptr %ctx.addr, align 8
  %keys_result5 = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i32 0, i32 12
  %6 = load ptr, ptr %keys_result5, align 8
  store ptr %6, ptr %res, align 8
  %7 = load ptr, ptr %res, align 8
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %7, i32 0, i32 2
  %8 = load i32, ptr %numkeys, align 8
  %9 = load ptr, ptr %res, align 8
  %size = getelementptr inbounds %struct.getKeysResult, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %size, align 4
  %cmp6 = icmp eq i32 %8, %10
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end4
  %11 = load ptr, ptr %res, align 8
  %size8 = getelementptr inbounds %struct.getKeysResult, ptr %11, i32 0, i32 3
  %12 = load i32, ptr %size8, align 4
  %13 = load ptr, ptr %res, align 8
  %size9 = getelementptr inbounds %struct.getKeysResult, ptr %13, i32 0, i32 3
  %14 = load i32, ptr %size9, align 4
  %cmp10 = icmp sgt i32 %14, 8192
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then7
  br label %cond.end

cond.false:                                       ; preds = %if.then7
  %15 = load ptr, ptr %res, align 8
  %size11 = getelementptr inbounds %struct.getKeysResult, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %size11, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 8192, %cond.true ], [ %16, %cond.false ]
  %add = add nsw i32 %12, %cond
  store i32 %add, ptr %newsize, align 4
  %17 = load ptr, ptr %res, align 8
  %18 = load i32, ptr %newsize, align 4
  %call = call ptr @getKeysPrepareResult(ptr noundef %17, i32 noundef %18)
  br label %if.end12

if.end12:                                         ; preds = %cond.end, %if.end4
  store i32 0, ptr %new_flags, align 4
  %19 = load i32, ptr %flags.addr, align 4
  %conv = sext i32 %19 to i64
  %and13 = and i64 %conv, 4
  %tobool14 = icmp ne i64 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end18

if.then15:                                        ; preds = %if.end12
  %20 = load i32, ptr %new_flags, align 4
  %conv16 = sext i32 %20 to i64
  %or = or i64 %conv16, 4096
  %conv17 = trunc i64 %or to i32
  store i32 %conv17, ptr %new_flags, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.then15, %if.end12
  %21 = load i32, ptr %flags.addr, align 4
  %conv19 = sext i32 %21 to i64
  %and20 = and i64 %conv19, 8
  %tobool21 = icmp ne i64 %and20, 0
  br i1 %tobool21, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end18
  %22 = load i32, ptr %new_flags, align 4
  %conv23 = sext i32 %22 to i64
  %or24 = or i64 %conv23, 8192
  %conv25 = trunc i64 %or24 to i32
  store i32 %conv25, ptr %new_flags, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %if.end18
  %23 = load i32, ptr %flags.addr, align 4
  %conv27 = sext i32 %23 to i64
  %and28 = and i64 %conv27, 2
  %tobool29 = icmp ne i64 %and28, 0
  br i1 %tobool29, label %if.then30, label %if.end34

if.then30:                                        ; preds = %if.end26
  %24 = load i32, ptr %new_flags, align 4
  %conv31 = sext i32 %24 to i64
  %or32 = or i64 %conv31, 16384
  %conv33 = trunc i64 %or32 to i32
  store i32 %conv33, ptr %new_flags, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then30, %if.end26
  %25 = load i32, ptr %flags.addr, align 4
  %conv35 = sext i32 %25 to i64
  %and36 = and i64 %conv35, 1
  %tobool37 = icmp ne i64 %and36, 0
  br i1 %tobool37, label %if.then38, label %if.end42

if.then38:                                        ; preds = %if.end34
  %26 = load i32, ptr %new_flags, align 4
  %conv39 = sext i32 %26 to i64
  %or40 = or i64 %conv39, 2048
  %conv41 = trunc i64 %or40 to i32
  store i32 %conv41, ptr %new_flags, align 4
  br label %if.end42

if.end42:                                         ; preds = %if.then38, %if.end34
  %27 = load i32, ptr %pos.addr, align 4
  %28 = load ptr, ptr %res, align 8
  %keys = getelementptr inbounds %struct.getKeysResult, ptr %28, i32 0, i32 1
  %29 = load ptr, ptr %keys, align 8
  %30 = load ptr, ptr %res, align 8
  %numkeys43 = getelementptr inbounds %struct.getKeysResult, ptr %30, i32 0, i32 2
  %31 = load i32, ptr %numkeys43, align 8
  %idxprom = sext i32 %31 to i64
  %arrayidx = getelementptr inbounds %struct.keyReference, ptr %29, i64 %idxprom
  %pos44 = getelementptr inbounds %struct.keyReference, ptr %arrayidx, i32 0, i32 0
  store i32 %27, ptr %pos44, align 4
  %32 = load i32, ptr %new_flags, align 4
  %33 = load ptr, ptr %res, align 8
  %keys45 = getelementptr inbounds %struct.getKeysResult, ptr %33, i32 0, i32 1
  %34 = load ptr, ptr %keys45, align 8
  %35 = load ptr, ptr %res, align 8
  %numkeys46 = getelementptr inbounds %struct.getKeysResult, ptr %35, i32 0, i32 2
  %36 = load i32, ptr %numkeys46, align 8
  %idxprom47 = sext i32 %36 to i64
  %arrayidx48 = getelementptr inbounds %struct.keyReference, ptr %34, i64 %idxprom47
  %flags49 = getelementptr inbounds %struct.keyReference, ptr %arrayidx48, i32 0, i32 1
  store i32 %32, ptr %flags49, align 4
  %37 = load ptr, ptr %res, align 8
  %numkeys50 = getelementptr inbounds %struct.getKeysResult, ptr %37, i32 0, i32 2
  %38 = load i32, ptr %numkeys50, align 8
  %inc = add nsw i32 %38, 1
  store i32 %inc, ptr %numkeys50, align 8
  br label %return

return:                                           ; preds = %if.end42, %if.then3, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isCommandNameValid(ptr noundef %name) #0 {
entry:
  %retval = alloca i32, align 4
  %name.addr = alloca ptr, align 8
  %block_chars = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr @.str.3, ptr %block_chars, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %1 = load ptr, ptr %block_chars, align 8
  %call = call ptr @strpbrk(ptr noundef %0, ptr noundef %1) #14
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strpbrk(ptr noundef, ptr noundef) #6

; Function Attrs: nounwind uwtable
define dso_local i64 @commandFlagsFromString(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  %j = alloca i32, align 4
  %flags = alloca i64, align 8
  %tokens = alloca ptr, align 8
  %t = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 0, ptr %flags, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #14
  %call1 = call ptr @sdssplitlen(ptr noundef %0, i64 noundef %call, ptr noundef @.str.4, i32 noundef 1, ptr noundef %count)
  store ptr %call1, ptr %tokens, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr %count, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %tokens, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  store ptr %6, ptr %t, align 8
  %7 = load ptr, ptr %t, align 8
  %call2 = call i32 @strcasecmp(ptr noundef %7, ptr noundef @.str.5) #14
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %for.body
  %8 = load i64, ptr %flags, align 8
  %or = or i64 %8, 1
  store i64 %or, ptr %flags, align 8
  br label %if.end115

if.else:                                          ; preds = %for.body
  %9 = load ptr, ptr %t, align 8
  %call3 = call i32 @strcasecmp(ptr noundef %9, ptr noundef @.str.6) #14
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.else7, label %if.then5

if.then5:                                         ; preds = %if.else
  %10 = load i64, ptr %flags, align 8
  %or6 = or i64 %10, 2
  store i64 %or6, ptr %flags, align 8
  br label %if.end114

if.else7:                                         ; preds = %if.else
  %11 = load ptr, ptr %t, align 8
  %call8 = call i32 @strcasecmp(ptr noundef %11, ptr noundef @.str.7) #14
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.else12, label %if.then10

if.then10:                                        ; preds = %if.else7
  %12 = load i64, ptr %flags, align 8
  %or11 = or i64 %12, 16
  store i64 %or11, ptr %flags, align 8
  br label %if.end113

if.else12:                                        ; preds = %if.else7
  %13 = load ptr, ptr %t, align 8
  %call13 = call i32 @strcasecmp(ptr noundef %13, ptr noundef @.str.8) #14
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.else17, label %if.then15

if.then15:                                        ; preds = %if.else12
  %14 = load i64, ptr %flags, align 8
  %or16 = or i64 %14, 4
  store i64 %or16, ptr %flags, align 8
  br label %if.end112

if.else17:                                        ; preds = %if.else12
  %15 = load ptr, ptr %t, align 8
  %call18 = call i32 @strcasecmp(ptr noundef %15, ptr noundef @.str.9) #14
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.else22, label %if.then20

if.then20:                                        ; preds = %if.else17
  %16 = load i64, ptr %flags, align 8
  %or21 = or i64 %16, 64
  store i64 %or21, ptr %flags, align 8
  br label %if.end111

if.else22:                                        ; preds = %if.else17
  %17 = load ptr, ptr %t, align 8
  %call23 = call i32 @strcasecmp(ptr noundef %17, ptr noundef @.str.10) #14
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.else27, label %if.then25

if.then25:                                        ; preds = %if.else22
  %18 = load i64, ptr %flags, align 8
  %or26 = or i64 %18, 512
  store i64 %or26, ptr %flags, align 8
  br label %if.end110

if.else27:                                        ; preds = %if.else22
  %19 = load ptr, ptr %t, align 8
  %call28 = call i32 @strcasecmp(ptr noundef %19, ptr noundef @.str.11) #14
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.else32, label %if.then30

if.then30:                                        ; preds = %if.else27
  %20 = load i64, ptr %flags, align 8
  %or31 = or i64 %20, 32
  store i64 %or31, ptr %flags, align 8
  br label %if.end109

if.else32:                                        ; preds = %if.else27
  %21 = load ptr, ptr %t, align 8
  %call33 = call i32 @strcasecmp(ptr noundef %21, ptr noundef @.str.12) #14
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.else36, label %if.then35

if.then35:                                        ; preds = %if.else32
  br label %if.end108

if.else36:                                        ; preds = %if.else32
  %22 = load ptr, ptr %t, align 8
  %call37 = call i32 @strcasecmp(ptr noundef %22, ptr noundef @.str.13) #14
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.else41, label %if.then39

if.then39:                                        ; preds = %if.else36
  %23 = load i64, ptr %flags, align 8
  %or40 = or i64 %23, 256
  store i64 %or40, ptr %flags, align 8
  br label %if.end107

if.else41:                                        ; preds = %if.else36
  %24 = load ptr, ptr %t, align 8
  %call42 = call i32 @strcasecmp(ptr noundef %24, ptr noundef @.str.14) #14
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.else46, label %if.then44

if.then44:                                        ; preds = %if.else41
  %25 = load i64, ptr %flags, align 8
  %or45 = or i64 %25, 1024
  store i64 %or45, ptr %flags, align 8
  br label %if.end106

if.else46:                                        ; preds = %if.else41
  %26 = load ptr, ptr %t, align 8
  %call47 = call i32 @strcasecmp(ptr noundef %26, ptr noundef @.str.15) #14
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.else51, label %if.then49

if.then49:                                        ; preds = %if.else46
  %27 = load i64, ptr %flags, align 8
  %or50 = or i64 %27, 2048
  store i64 %or50, ptr %flags, align 8
  br label %if.end105

if.else51:                                        ; preds = %if.else46
  %28 = load ptr, ptr %t, align 8
  %call52 = call i32 @strcasecmp(ptr noundef %28, ptr noundef @.str.16) #14
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.else56, label %if.then54

if.then54:                                        ; preds = %if.else51
  %29 = load i64, ptr %flags, align 8
  %or55 = or i64 %29, 4096
  store i64 %or55, ptr %flags, align 8
  br label %if.end104

if.else56:                                        ; preds = %if.else51
  %30 = load ptr, ptr %t, align 8
  %call57 = call i32 @strcasecmp(ptr noundef %30, ptr noundef @.str.17) #14
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.else61, label %if.then59

if.then59:                                        ; preds = %if.else56
  %31 = load i64, ptr %flags, align 8
  %or60 = or i64 %31, 16384
  store i64 %or60, ptr %flags, align 8
  br label %if.end103

if.else61:                                        ; preds = %if.else56
  %32 = load ptr, ptr %t, align 8
  %call62 = call i32 @strcasecmp(ptr noundef %32, ptr noundef @.str.18) #14
  %tobool63 = icmp ne i32 %call62, 0
  br i1 %tobool63, label %if.else66, label %if.then64

if.then64:                                        ; preds = %if.else61
  %33 = load i64, ptr %flags, align 8
  %or65 = or i64 %33, 32768
  store i64 %or65, ptr %flags, align 8
  br label %if.end102

if.else66:                                        ; preds = %if.else61
  %34 = load ptr, ptr %t, align 8
  %call67 = call i32 @strcasecmp(ptr noundef %34, ptr noundef @.str.19) #14
  %tobool68 = icmp ne i32 %call67, 0
  br i1 %tobool68, label %if.else71, label %if.then69

if.then69:                                        ; preds = %if.else66
  %35 = load i64, ptr %flags, align 8
  %or70 = or i64 %35, 65536
  store i64 %or70, ptr %flags, align 8
  br label %if.end101

if.else71:                                        ; preds = %if.else66
  %36 = load ptr, ptr %t, align 8
  %call72 = call i32 @strcasecmp(ptr noundef %36, ptr noundef @.str.20) #14
  %tobool73 = icmp ne i32 %call72, 0
  br i1 %tobool73, label %if.else76, label %if.then74

if.then74:                                        ; preds = %if.else71
  %37 = load i64, ptr %flags, align 8
  %or75 = or i64 %37, 2097152
  store i64 %or75, ptr %flags, align 8
  br label %if.end100

if.else76:                                        ; preds = %if.else71
  %38 = load ptr, ptr %t, align 8
  %call77 = call i32 @strcasecmp(ptr noundef %38, ptr noundef @.str.21) #14
  %tobool78 = icmp ne i32 %call77, 0
  br i1 %tobool78, label %if.else81, label %if.then79

if.then79:                                        ; preds = %if.else76
  %39 = load i64, ptr %flags, align 8
  %or80 = or i64 %39, 134217728
  store i64 %or80, ptr %flags, align 8
  br label %if.end99

if.else81:                                        ; preds = %if.else76
  %40 = load ptr, ptr %t, align 8
  %call82 = call i32 @strcasecmp(ptr noundef %40, ptr noundef @.str.22) #14
  %tobool83 = icmp ne i32 %call82, 0
  br i1 %tobool83, label %if.else86, label %if.then84

if.then84:                                        ; preds = %if.else81
  %41 = load i64, ptr %flags, align 8
  %or85 = or i64 %41, 4194304
  store i64 %or85, ptr %flags, align 8
  br label %if.end98

if.else86:                                        ; preds = %if.else81
  %42 = load ptr, ptr %t, align 8
  %call87 = call i32 @strcasecmp(ptr noundef %42, ptr noundef @.str.23) #14
  %tobool88 = icmp ne i32 %call87, 0
  br i1 %tobool88, label %if.else91, label %if.then89

if.then89:                                        ; preds = %if.else86
  %43 = load i64, ptr %flags, align 8
  %or90 = or i64 %43, 524288
  store i64 %or90, ptr %flags, align 8
  br label %if.end97

if.else91:                                        ; preds = %if.else86
  %44 = load ptr, ptr %t, align 8
  %call92 = call i32 @strcasecmp(ptr noundef %44, ptr noundef @.str.24) #14
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %if.else96, label %if.then94

if.then94:                                        ; preds = %if.else91
  %45 = load i64, ptr %flags, align 8
  %or95 = or i64 %45, 67108864
  store i64 %or95, ptr %flags, align 8
  br label %if.end

if.else96:                                        ; preds = %if.else91
  br label %for.end

if.end:                                           ; preds = %if.then94
  br label %if.end97

if.end97:                                         ; preds = %if.end, %if.then89
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %if.then84
  br label %if.end99

if.end99:                                         ; preds = %if.end98, %if.then79
  br label %if.end100

if.end100:                                        ; preds = %if.end99, %if.then74
  br label %if.end101

if.end101:                                        ; preds = %if.end100, %if.then69
  br label %if.end102

if.end102:                                        ; preds = %if.end101, %if.then64
  br label %if.end103

if.end103:                                        ; preds = %if.end102, %if.then59
  br label %if.end104

if.end104:                                        ; preds = %if.end103, %if.then54
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.then49
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %if.then44
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %if.then39
  br label %if.end108

if.end108:                                        ; preds = %if.end107, %if.then35
  br label %if.end109

if.end109:                                        ; preds = %if.end108, %if.then30
  br label %if.end110

if.end110:                                        ; preds = %if.end109, %if.then25
  br label %if.end111

if.end111:                                        ; preds = %if.end110, %if.then20
  br label %if.end112

if.end112:                                        ; preds = %if.end111, %if.then15
  br label %if.end113

if.end113:                                        ; preds = %if.end112, %if.then10
  br label %if.end114

if.end114:                                        ; preds = %if.end113, %if.then5
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end115
  %46 = load i32, ptr %j, align 4
  %inc = add nsw i32 %46, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %if.else96, %for.cond
  %47 = load ptr, ptr %tokens, align 8
  %48 = load i32, ptr %count, align 4
  call void @sdsfreesplitres(ptr noundef %47, i32 noundef %48)
  %49 = load i32, ptr %j, align 4
  %50 = load i32, ptr %count, align 4
  %cmp116 = icmp ne i32 %49, %50
  br i1 %cmp116, label %if.then117, label %if.end118

if.then117:                                       ; preds = %for.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end118:                                        ; preds = %for.end
  %51 = load i64, ptr %flags, align 8
  store i64 %51, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end118, %if.then117
  %52 = load i64, ptr %retval, align 8
  ret i64 %52
}

declare ptr @sdssplitlen(ptr noundef, i64 noundef, ptr noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #6

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcasecmp(ptr noundef, ptr noundef) #6

declare void @sdsfreesplitres(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CreateCommand(ptr noundef %ctx, ptr noundef %name, ptr noundef %cmdfunc, ptr noundef %strflags, i32 noundef %firstkey, i32 noundef %lastkey, i32 noundef %keystep) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %cmdfunc.addr = alloca ptr, align 8
  %strflags.addr = alloca ptr, align 8
  %firstkey.addr = alloca i32, align 4
  %lastkey.addr = alloca i32, align 4
  %keystep.addr = alloca i32, align 4
  %flags = alloca i64, align 8
  %declared_name = alloca ptr, align 8
  %cp = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %cmdfunc, ptr %cmdfunc.addr, align 8
  store ptr %strflags, ptr %strflags.addr, align 8
  store i32 %firstkey, ptr %firstkey.addr, align 4
  store i32 %lastkey, ptr %lastkey.addr, align 4
  store i32 %keystep, ptr %keystep.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %1, i32 0, i32 18
  %2 = load i32, ptr %onload, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %strflags.addr, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %4 = load ptr, ptr %strflags.addr, align 8
  %call = call i64 @commandFlagsFromString(ptr noundef %4)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %flags, align 8
  %5 = load i64, ptr %flags, align 8
  %cmp = icmp eq i64 %5, -1
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %cond.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %cond.end
  %6 = load i64, ptr %flags, align 8
  %and = and i64 %6, 4194304
  %tobool4 = icmp ne i64 %and, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end3
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool5 = icmp ne i32 %7, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end3
  %8 = load ptr, ptr %name.addr, align 8
  %call8 = call i32 @isCommandNameValid(ptr noundef %8)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end7
  store i32 1, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end7
  %9 = load ptr, ptr %name.addr, align 8
  %call12 = call ptr @lookupCommandByCString(ptr noundef %9)
  %cmp13 = icmp ne ptr %call12, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  store i32 1, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end11
  %10 = load ptr, ptr %name.addr, align 8
  %call16 = call ptr @sdsnew(ptr noundef %10)
  store ptr %call16, ptr %declared_name, align 8
  %11 = load ptr, ptr %ctx.addr, align 8
  %module17 = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %module17, align 8
  %13 = load ptr, ptr %declared_name, align 8
  %14 = load ptr, ptr %declared_name, align 8
  %call18 = call ptr @sdsdup(ptr noundef %14)
  %15 = load ptr, ptr %cmdfunc.addr, align 8
  %16 = load i64, ptr %flags, align 8
  %17 = load i32, ptr %firstkey.addr, align 4
  %18 = load i32, ptr %lastkey.addr, align 4
  %19 = load i32, ptr %keystep.addr, align 4
  %call19 = call ptr @moduleCreateCommandProxy(ptr noundef %12, ptr noundef %13, ptr noundef %call18, ptr noundef %15, i64 noundef %16, i32 noundef %17, i32 noundef %18, i32 noundef %19)
  store ptr %call19, ptr %cp, align 8
  %20 = load ptr, ptr %cmdfunc.addr, align 8
  %tobool20 = icmp ne ptr %20, null
  %cond21 = select i1 %tobool20, i32 -1, i32 -2
  %21 = load ptr, ptr %cp, align 8
  %rediscmd = getelementptr inbounds %struct.RedisModuleCommand, ptr %21, i32 0, i32 2
  %22 = load ptr, ptr %rediscmd, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %22, i32 0, i32 13
  store i32 %cond21, ptr %arity, align 8
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %24 = load ptr, ptr %declared_name, align 8
  %call22 = call ptr @sdsdup(ptr noundef %24)
  %25 = load ptr, ptr %cp, align 8
  %rediscmd23 = getelementptr inbounds %struct.RedisModuleCommand, ptr %25, i32 0, i32 2
  %26 = load ptr, ptr %rediscmd23, align 8
  %call24 = call i32 @dictAdd(ptr noundef %23, ptr noundef %call22, ptr noundef %26)
  %cmp25 = icmp eq i32 %call24, 0
  %lnot = xor i1 %cmp25, true
  %lnot26 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot26 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool27 = icmp ne i64 %conv, 0
  br i1 %tobool27, label %cond.true28, label %cond.false29

cond.true28:                                      ; preds = %if.end15
  br label %cond.end30

cond.false29:                                     ; preds = %if.end15
  call void @_serverAssert(ptr noundef @.str.25, ptr noundef @.str.2, i32 noundef 1278)
  call void @abort() #13
  unreachable

27:                                               ; No predecessors!
  br label %cond.end30

cond.end30:                                       ; preds = %27, %cond.true28
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 13), align 8
  %29 = load ptr, ptr %declared_name, align 8
  %call31 = call ptr @sdsdup(ptr noundef %29)
  %30 = load ptr, ptr %cp, align 8
  %rediscmd32 = getelementptr inbounds %struct.RedisModuleCommand, ptr %30, i32 0, i32 2
  %31 = load ptr, ptr %rediscmd32, align 8
  %call33 = call i32 @dictAdd(ptr noundef %28, ptr noundef %call31, ptr noundef %31)
  %cmp34 = icmp eq i32 %call33, 0
  %lnot36 = xor i1 %cmp34, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %tobool41 = icmp ne i64 %conv40, 0
  br i1 %tobool41, label %cond.true42, label %cond.false43

cond.true42:                                      ; preds = %cond.end30
  br label %cond.end44

cond.false43:                                     ; preds = %cond.end30
  call void @_serverAssert(ptr noundef @.str.26, ptr noundef @.str.2, i32 noundef 1279)
  call void @abort() #13
  unreachable

32:                                               ; No predecessors!
  br label %cond.end44

cond.end44:                                       ; preds = %32, %cond.true42
  %33 = load ptr, ptr %declared_name, align 8
  %call45 = call i64 @ACLGetCommandID(ptr noundef %33)
  %conv46 = trunc i64 %call45 to i32
  %34 = load ptr, ptr %cp, align 8
  %rediscmd47 = getelementptr inbounds %struct.RedisModuleCommand, ptr %34, i32 0, i32 2
  %35 = load ptr, ptr %rediscmd47, align 8
  %id = getelementptr inbounds %struct.redisCommand, ptr %35, i32 0, i32 26
  store i32 %conv46, ptr %id, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end44, %if.then14, %if.then10, %if.then6, %if.then2, %if.then
  %36 = load i32, ptr %retval, align 4
  ret i32 %36
}

declare ptr @lookupCommandByCString(ptr noundef) #1

declare ptr @sdsnew(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleCreateCommandProxy(ptr noundef %module, ptr noundef %declared_name, ptr noundef %fullname, ptr noundef %cmdfunc, i64 noundef %flags, i32 noundef %firstkey, i32 noundef %lastkey, i32 noundef %keystep) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %declared_name.addr = alloca ptr, align 8
  %fullname.addr = alloca ptr, align 8
  %cmdfunc.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %firstkey.addr = alloca i32, align 4
  %lastkey.addr = alloca i32, align 4
  %keystep.addr = alloca i32, align 4
  %cp = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %declared_name, ptr %declared_name.addr, align 8
  store ptr %fullname, ptr %fullname.addr, align 8
  store ptr %cmdfunc, ptr %cmdfunc.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  store i32 %firstkey, ptr %firstkey.addr, align 4
  store i32 %lastkey, ptr %lastkey.addr, align 4
  store i32 %keystep, ptr %keystep.addr, align 4
  %call = call noalias ptr @zcalloc(i64 noundef 24) #11
  store ptr %call, ptr %cp, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %1 = load ptr, ptr %cp, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCommand, ptr %1, i32 0, i32 0
  store ptr %0, ptr %module1, align 8
  %2 = load ptr, ptr %cmdfunc.addr, align 8
  %3 = load ptr, ptr %cp, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %3, i32 0, i32 1
  store ptr %2, ptr %func, align 8
  %call2 = call noalias ptr @zcalloc(i64 noundef 312) #11
  %4 = load ptr, ptr %cp, align 8
  %rediscmd3 = getelementptr inbounds %struct.RedisModuleCommand, ptr %4, i32 0, i32 2
  store ptr %call2, ptr %rediscmd3, align 8
  %5 = load ptr, ptr %declared_name.addr, align 8
  %6 = load ptr, ptr %cp, align 8
  %rediscmd4 = getelementptr inbounds %struct.RedisModuleCommand, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %rediscmd4, align 8
  %declared_name5 = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 0
  store ptr %5, ptr %declared_name5, align 8
  %8 = load ptr, ptr %fullname.addr, align 8
  %9 = load ptr, ptr %cp, align 8
  %rediscmd6 = getelementptr inbounds %struct.RedisModuleCommand, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %rediscmd6, align 8
  %fullname7 = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 27
  store ptr %8, ptr %fullname7, align 8
  %11 = load ptr, ptr %cp, align 8
  %rediscmd8 = getelementptr inbounds %struct.RedisModuleCommand, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %rediscmd8, align 8
  %group = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 7
  store i32 17, ptr %group, align 8
  %13 = load ptr, ptr %cp, align 8
  %rediscmd9 = getelementptr inbounds %struct.RedisModuleCommand, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %rediscmd9, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %14, i32 0, i32 12
  store ptr @RedisModuleCommandDispatcher, ptr %proc, align 8
  %15 = load i64, ptr %flags.addr, align 8
  %or = or i64 %15, 8
  %16 = load ptr, ptr %cp, align 8
  %rediscmd10 = getelementptr inbounds %struct.RedisModuleCommand, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %rediscmd10, align 8
  %flags11 = getelementptr inbounds %struct.redisCommand, ptr %17, i32 0, i32 14
  store i64 %or, ptr %flags11, align 8
  %18 = load ptr, ptr %cp, align 8
  %19 = load ptr, ptr %cp, align 8
  %rediscmd12 = getelementptr inbounds %struct.RedisModuleCommand, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %rediscmd12, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %20, i32 0, i32 32
  store ptr %18, ptr %module_cmd, align 8
  %21 = load i32, ptr %firstkey.addr, align 4
  %cmp = icmp ne i32 %21, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %22 = load ptr, ptr %cp, align 8
  %rediscmd13 = getelementptr inbounds %struct.RedisModuleCommand, ptr %22, i32 0, i32 2
  %23 = load ptr, ptr %rediscmd13, align 8
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %23, i32 0, i32 17
  store i32 1, ptr %key_specs_num, align 8
  %call14 = call noalias ptr @zcalloc(i64 noundef 56) #11
  %24 = load ptr, ptr %cp, align 8
  %rediscmd15 = getelementptr inbounds %struct.RedisModuleCommand, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %rediscmd15, align 8
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %25, i32 0, i32 16
  store ptr %call14, ptr %key_specs, align 8
  %26 = load ptr, ptr %cp, align 8
  %rediscmd16 = getelementptr inbounds %struct.RedisModuleCommand, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %rediscmd16, align 8
  %key_specs17 = getelementptr inbounds %struct.redisCommand, ptr %27, i32 0, i32 16
  %28 = load ptr, ptr %key_specs17, align 8
  %arrayidx = getelementptr inbounds %struct.keySpec, ptr %28, i64 0
  %flags18 = getelementptr inbounds %struct.keySpec, ptr %arrayidx, i32 0, i32 1
  store i64 50, ptr %flags18, align 8
  %29 = load i64, ptr %flags.addr, align 8
  %and = and i64 %29, 2097152
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then19, label %if.end

if.then19:                                        ; preds = %if.then
  %30 = load ptr, ptr %cp, align 8
  %rediscmd20 = getelementptr inbounds %struct.RedisModuleCommand, ptr %30, i32 0, i32 2
  %31 = load ptr, ptr %rediscmd20, align 8
  %key_specs21 = getelementptr inbounds %struct.redisCommand, ptr %31, i32 0, i32 16
  %32 = load ptr, ptr %key_specs21, align 8
  %arrayidx22 = getelementptr inbounds %struct.keySpec, ptr %32, i64 0
  %flags23 = getelementptr inbounds %struct.keySpec, ptr %arrayidx22, i32 0, i32 1
  %33 = load i64, ptr %flags23, align 8
  %or24 = or i64 %33, 1024
  store i64 %or24, ptr %flags23, align 8
  br label %if.end

if.end:                                           ; preds = %if.then19, %if.then
  %34 = load ptr, ptr %cp, align 8
  %rediscmd25 = getelementptr inbounds %struct.RedisModuleCommand, ptr %34, i32 0, i32 2
  %35 = load ptr, ptr %rediscmd25, align 8
  %key_specs26 = getelementptr inbounds %struct.redisCommand, ptr %35, i32 0, i32 16
  %36 = load ptr, ptr %key_specs26, align 8
  %arrayidx27 = getelementptr inbounds %struct.keySpec, ptr %36, i64 0
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx27, i32 0, i32 2
  store i32 2, ptr %begin_search_type, align 8
  %37 = load i32, ptr %firstkey.addr, align 4
  %38 = load ptr, ptr %cp, align 8
  %rediscmd28 = getelementptr inbounds %struct.RedisModuleCommand, ptr %38, i32 0, i32 2
  %39 = load ptr, ptr %rediscmd28, align 8
  %key_specs29 = getelementptr inbounds %struct.redisCommand, ptr %39, i32 0, i32 16
  %40 = load ptr, ptr %key_specs29, align 8
  %arrayidx30 = getelementptr inbounds %struct.keySpec, ptr %40, i64 0
  %bs = getelementptr inbounds %struct.keySpec, ptr %arrayidx30, i32 0, i32 3
  %pos = getelementptr inbounds %struct.anon.4, ptr %bs, i32 0, i32 0
  store i32 %37, ptr %pos, align 8
  %41 = load ptr, ptr %cp, align 8
  %rediscmd31 = getelementptr inbounds %struct.RedisModuleCommand, ptr %41, i32 0, i32 2
  %42 = load ptr, ptr %rediscmd31, align 8
  %key_specs32 = getelementptr inbounds %struct.redisCommand, ptr %42, i32 0, i32 16
  %43 = load ptr, ptr %key_specs32, align 8
  %arrayidx33 = getelementptr inbounds %struct.keySpec, ptr %43, i64 0
  %find_keys_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx33, i32 0, i32 4
  store i32 2, ptr %find_keys_type, align 8
  %44 = load i32, ptr %lastkey.addr, align 4
  %cmp34 = icmp slt i32 %44, 0
  br i1 %cmp34, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %45 = load i32, ptr %lastkey.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %46 = load i32, ptr %lastkey.addr, align 4
  %47 = load i32, ptr %firstkey.addr, align 4
  %sub = sub nsw i32 %46, %47
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %45, %cond.true ], [ %sub, %cond.false ]
  %48 = load ptr, ptr %cp, align 8
  %rediscmd35 = getelementptr inbounds %struct.RedisModuleCommand, ptr %48, i32 0, i32 2
  %49 = load ptr, ptr %rediscmd35, align 8
  %key_specs36 = getelementptr inbounds %struct.redisCommand, ptr %49, i32 0, i32 16
  %50 = load ptr, ptr %key_specs36, align 8
  %arrayidx37 = getelementptr inbounds %struct.keySpec, ptr %50, i64 0
  %fk = getelementptr inbounds %struct.keySpec, ptr %arrayidx37, i32 0, i32 5
  %lastkey38 = getelementptr inbounds %struct.anon.7, ptr %fk, i32 0, i32 0
  store i32 %cond, ptr %lastkey38, align 4
  %51 = load i32, ptr %keystep.addr, align 4
  %52 = load ptr, ptr %cp, align 8
  %rediscmd39 = getelementptr inbounds %struct.RedisModuleCommand, ptr %52, i32 0, i32 2
  %53 = load ptr, ptr %rediscmd39, align 8
  %key_specs40 = getelementptr inbounds %struct.redisCommand, ptr %53, i32 0, i32 16
  %54 = load ptr, ptr %key_specs40, align 8
  %arrayidx41 = getelementptr inbounds %struct.keySpec, ptr %54, i64 0
  %fk42 = getelementptr inbounds %struct.keySpec, ptr %arrayidx41, i32 0, i32 5
  %keystep43 = getelementptr inbounds %struct.anon.7, ptr %fk42, i32 0, i32 1
  store i32 %51, ptr %keystep43, align 4
  %55 = load ptr, ptr %cp, align 8
  %rediscmd44 = getelementptr inbounds %struct.RedisModuleCommand, ptr %55, i32 0, i32 2
  %56 = load ptr, ptr %rediscmd44, align 8
  %key_specs45 = getelementptr inbounds %struct.redisCommand, ptr %56, i32 0, i32 16
  %57 = load ptr, ptr %key_specs45, align 8
  %arrayidx46 = getelementptr inbounds %struct.keySpec, ptr %57, i64 0
  %fk47 = getelementptr inbounds %struct.keySpec, ptr %arrayidx46, i32 0, i32 5
  %limit = getelementptr inbounds %struct.anon.7, ptr %fk47, i32 0, i32 2
  store i32 0, ptr %limit, align 4
  br label %if.end52

if.else:                                          ; preds = %entry
  %58 = load ptr, ptr %cp, align 8
  %rediscmd48 = getelementptr inbounds %struct.RedisModuleCommand, ptr %58, i32 0, i32 2
  %59 = load ptr, ptr %rediscmd48, align 8
  %key_specs_num49 = getelementptr inbounds %struct.redisCommand, ptr %59, i32 0, i32 17
  store i32 0, ptr %key_specs_num49, align 8
  %60 = load ptr, ptr %cp, align 8
  %rediscmd50 = getelementptr inbounds %struct.RedisModuleCommand, ptr %60, i32 0, i32 2
  %61 = load ptr, ptr %rediscmd50, align 8
  %key_specs51 = getelementptr inbounds %struct.redisCommand, ptr %61, i32 0, i32 16
  store ptr null, ptr %key_specs51, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.else, %cond.end
  %62 = load ptr, ptr %cp, align 8
  %rediscmd53 = getelementptr inbounds %struct.RedisModuleCommand, ptr %62, i32 0, i32 2
  %63 = load ptr, ptr %rediscmd53, align 8
  call void @populateCommandLegacyRangeSpec(ptr noundef %63)
  %64 = load ptr, ptr %cp, align 8
  %rediscmd54 = getelementptr inbounds %struct.RedisModuleCommand, ptr %64, i32 0, i32 2
  %65 = load ptr, ptr %rediscmd54, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %65, i32 0, i32 22
  store i64 0, ptr %microseconds, align 8
  %66 = load ptr, ptr %cp, align 8
  %rediscmd55 = getelementptr inbounds %struct.RedisModuleCommand, ptr %66, i32 0, i32 2
  %67 = load ptr, ptr %rediscmd55, align 8
  %calls = getelementptr inbounds %struct.redisCommand, ptr %67, i32 0, i32 23
  store i64 0, ptr %calls, align 8
  %68 = load ptr, ptr %cp, align 8
  %rediscmd56 = getelementptr inbounds %struct.RedisModuleCommand, ptr %68, i32 0, i32 2
  %69 = load ptr, ptr %rediscmd56, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %69, i32 0, i32 24
  store i64 0, ptr %rejected_calls, align 8
  %70 = load ptr, ptr %cp, align 8
  %rediscmd57 = getelementptr inbounds %struct.RedisModuleCommand, ptr %70, i32 0, i32 2
  %71 = load ptr, ptr %rediscmd57, align 8
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %71, i32 0, i32 25
  store i64 0, ptr %failed_calls, align 8
  %72 = load ptr, ptr %cp, align 8
  ret ptr %72
}

declare ptr @sdsdup(ptr noundef) #1

declare i32 @dictAdd(ptr noundef, ptr noundef, ptr noundef) #1

declare i64 @ACLGetCommandID(ptr noundef) #1

; Function Attrs: allocsize(0)
declare noalias ptr @zcalloc(i64 noundef) #2

declare void @populateCommandLegacyRangeSpec(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetCommand(ptr noundef %ctx, ptr noundef %name) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %cp = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %call = call ptr @lookupCommandByCString(ptr noundef %0)
  store ptr %call, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %cmd, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %2, i32 0, i32 14
  %3 = load i64, ptr %flags, align 8
  %and = and i64 %3, 8
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %cmd, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 32
  %5 = load ptr, ptr %module_cmd, align 8
  store ptr %5, ptr %cp, align 8
  %6 = load ptr, ptr %cp, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommand, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %module, align 8
  %8 = load ptr, ptr %ctx.addr, align 8
  %module2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %module2, align 8
  %cmp = icmp ne ptr %7, %9
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %10 = load ptr, ptr %cp, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CreateSubcommand(ptr noundef %parent, ptr noundef %name, ptr noundef %cmdfunc, ptr noundef %strflags, i32 noundef %firstkey, i32 noundef %lastkey, i32 noundef %keystep) #0 {
entry:
  %retval = alloca i32, align 4
  %parent.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %cmdfunc.addr = alloca ptr, align 8
  %strflags.addr = alloca ptr, align 8
  %firstkey.addr = alloca i32, align 4
  %lastkey.addr = alloca i32, align 4
  %keystep.addr = alloca i32, align 4
  %flags = alloca i64, align 8
  %parent_cmd = alloca ptr, align 8
  %parent_cp = alloca ptr, align 8
  %declared_name = alloca ptr, align 8
  %fullname = alloca ptr, align 8
  %cp = alloca ptr, align 8
  store ptr %parent, ptr %parent.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %cmdfunc, ptr %cmdfunc.addr, align 8
  store ptr %strflags, ptr %strflags.addr, align 8
  store i32 %firstkey, ptr %firstkey.addr, align 4
  store i32 %lastkey, ptr %lastkey.addr, align 4
  store i32 %keystep, ptr %keystep.addr, align 4
  %0 = load ptr, ptr %parent.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommand, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %module, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %1, i32 0, i32 18
  %2 = load i32, ptr %onload, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %strflags.addr, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %4 = load ptr, ptr %strflags.addr, align 8
  %call = call i64 @commandFlagsFromString(ptr noundef %4)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %flags, align 8
  %5 = load i64, ptr %flags, align 8
  %cmp = icmp eq i64 %5, -1
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %cond.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %cond.end
  %6 = load i64, ptr %flags, align 8
  %and = and i64 %6, 4194304
  %tobool4 = icmp ne i64 %and, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end3
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool5 = icmp ne i32 %7, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %if.end3
  %8 = load ptr, ptr %parent.addr, align 8
  %rediscmd = getelementptr inbounds %struct.RedisModuleCommand, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %rediscmd, align 8
  store ptr %9, ptr %parent_cmd, align 8
  %10 = load ptr, ptr %parent_cmd, align 8
  %parent8 = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 31
  %11 = load ptr, ptr %parent8, align 8
  %tobool9 = icmp ne ptr %11, null
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  store i32 1, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end7
  %12 = load ptr, ptr %parent_cmd, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 32
  %13 = load ptr, ptr %module_cmd, align 8
  store ptr %13, ptr %parent_cp, align 8
  %14 = load ptr, ptr %parent_cp, align 8
  %func = getelementptr inbounds %struct.RedisModuleCommand, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %func, align 8
  %tobool12 = icmp ne ptr %15, null
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  store i32 1, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end11
  %16 = load ptr, ptr %name.addr, align 8
  %call15 = call i32 @isCommandNameValid(ptr noundef %16)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end14
  store i32 1, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end14
  %17 = load ptr, ptr %name.addr, align 8
  %call19 = call ptr @sdsnew(ptr noundef %17)
  store ptr %call19, ptr %declared_name, align 8
  %18 = load ptr, ptr %parent_cmd, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 30
  %19 = load ptr, ptr %subcommands_dict, align 8
  %tobool20 = icmp ne ptr %19, null
  br i1 %tobool20, label %land.lhs.true21, label %if.end25

land.lhs.true21:                                  ; preds = %if.end18
  %20 = load ptr, ptr %parent_cmd, align 8
  %21 = load ptr, ptr %declared_name, align 8
  %call22 = call ptr @lookupSubcommand(ptr noundef %20, ptr noundef %21)
  %cmp23 = icmp ne ptr %call22, null
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %land.lhs.true21
  %22 = load ptr, ptr %declared_name, align 8
  call void @sdsfree(ptr noundef %22)
  store i32 1, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %land.lhs.true21, %if.end18
  %23 = load ptr, ptr %parent_cmd, align 8
  %fullname26 = getelementptr inbounds %struct.redisCommand, ptr %23, i32 0, i32 27
  %24 = load ptr, ptr %fullname26, align 8
  %25 = load ptr, ptr %name.addr, align 8
  %call27 = call ptr @catSubCommandFullname(ptr noundef %24, ptr noundef %25)
  store ptr %call27, ptr %fullname, align 8
  %26 = load ptr, ptr %parent.addr, align 8
  %module28 = getelementptr inbounds %struct.RedisModuleCommand, ptr %26, i32 0, i32 0
  %27 = load ptr, ptr %module28, align 8
  %28 = load ptr, ptr %declared_name, align 8
  %29 = load ptr, ptr %fullname, align 8
  %30 = load ptr, ptr %cmdfunc.addr, align 8
  %31 = load i64, ptr %flags, align 8
  %32 = load i32, ptr %firstkey.addr, align 4
  %33 = load i32, ptr %lastkey.addr, align 4
  %34 = load i32, ptr %keystep.addr, align 4
  %call29 = call ptr @moduleCreateCommandProxy(ptr noundef %27, ptr noundef %28, ptr noundef %29, ptr noundef %30, i64 noundef %31, i32 noundef %32, i32 noundef %33, i32 noundef %34)
  store ptr %call29, ptr %cp, align 8
  %35 = load ptr, ptr %cp, align 8
  %rediscmd30 = getelementptr inbounds %struct.RedisModuleCommand, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %rediscmd30, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %36, i32 0, i32 13
  store i32 -2, ptr %arity, align 8
  %37 = load ptr, ptr %parent_cmd, align 8
  %38 = load ptr, ptr %cp, align 8
  %rediscmd31 = getelementptr inbounds %struct.RedisModuleCommand, ptr %38, i32 0, i32 2
  %39 = load ptr, ptr %rediscmd31, align 8
  %40 = load ptr, ptr %name.addr, align 8
  call void @commandAddSubcommand(ptr noundef %37, ptr noundef %39, ptr noundef %40)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.then24, %if.then17, %if.then13, %if.then10, %if.then6, %if.then2, %if.then
  %41 = load i32, ptr %retval, align 4
  ret i32 %41
}

declare ptr @lookupSubcommand(ptr noundef, ptr noundef) #1

declare void @sdsfree(ptr noundef) #1

declare ptr @catSubCommandFullname(ptr noundef, ptr noundef) #1

declare void @commandAddSubcommand(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @populateArgsStructure(ptr noundef %args) #0 {
entry:
  %retval = alloca i32, align 4
  %args.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  store ptr %args, ptr %args.addr, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %count, align 4
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %if.end
  %1 = load ptr, ptr %args.addr, align 8
  %name = getelementptr inbounds %struct.redisCommandArg, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %name, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i32, ptr %count, align 4
  %cmp = icmp slt i32 %3, 2147483647
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  br label %cond.end

cond.false:                                       ; preds = %while.body
  call void @_serverAssert(ptr noundef @.str.27, ptr noundef @.str.2, i32 noundef 1446)
  call void @abort() #13
  unreachable

4:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load ptr, ptr %args.addr, align 8
  %subargs = getelementptr inbounds %struct.redisCommandArg, ptr %5, i32 0, i32 9
  %6 = load ptr, ptr %subargs, align 8
  %call = call i32 @populateArgsStructure(ptr noundef %6)
  %7 = load ptr, ptr %args.addr, align 8
  %num_args = getelementptr inbounds %struct.redisCommandArg, ptr %7, i32 0, i32 8
  store i32 %call, ptr %num_args, align 8
  %8 = load i32, ptr %count, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %count, align 4
  %9 = load ptr, ptr %args.addr, align 8
  %incdec.ptr = getelementptr inbounds %struct.redisCommandArg, ptr %9, i32 1
  store ptr %incdec.ptr, ptr %args.addr, align 8
  br label %while.cond, !llvm.loop !13

while.end:                                        ; preds = %while.cond
  %10 = load i32, ptr %count, align 4
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_AddACLCategory(ptr noundef %ctx, ptr noundef %name) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %1, i32 0, i32 18
  %2 = load i32, ptr %onload, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %name.addr, align 8
  %call1 = call i32 @moduleVerifyResourceName(ptr noundef %3)
  %cmp = icmp eq i32 %call1, 1
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call ptr @__errno_location() #15
  store i32 22, ptr %call3, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %name.addr, align 8
  %call5 = call i64 @ACLGetCommandCategoryFlagByName(ptr noundef %4)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end4
  %call8 = call ptr @__errno_location() #15
  store i32 16, ptr %call8, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end4
  %5 = load ptr, ptr %name.addr, align 8
  %call10 = call i32 @ACLAddCommandCategory(ptr noundef %5, i64 noundef 0)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end9
  %6 = load ptr, ptr %ctx.addr, align 8
  %module13 = getelementptr inbounds %struct.RedisModuleCtx, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %module13, align 8
  %num_acl_categories_added = getelementptr inbounds %struct.RedisModule, ptr %7, i32 0, i32 19
  %8 = load i64, ptr %num_acl_categories_added, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %num_acl_categories_added, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end9
  %call14 = call ptr @__errno_location() #15
  store i32 12, ptr %call14, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then12, %if.then7, %if.then2, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #7

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleVerifyResourceName(ptr noundef %name) #0 {
entry:
  %retval = alloca i32, align 4
  %name.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %curr_char = alloca i8, align 1
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load ptr, ptr %name.addr, align 8
  %3 = load i64, ptr %i, align 8
  %arrayidx2 = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load i8, ptr %arrayidx2, align 1
  %conv3 = sext i8 %4 to i32
  %cmp4 = icmp ne i32 %conv3, 0
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %name.addr, align 8
  %6 = load i64, ptr %i, align 8
  %arrayidx6 = getelementptr inbounds i8, ptr %5, i64 %6
  %7 = load i8, ptr %arrayidx6, align 1
  store i8 %7, ptr %curr_char, align 1
  %8 = load i8, ptr %curr_char, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp sge i32 %conv7, 97
  br i1 %cmp8, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %for.body
  %9 = load i8, ptr %curr_char, align 1
  %conv10 = sext i8 %9 to i32
  %cmp11 = icmp sle i32 %conv10, 122
  br i1 %cmp11, label %if.then36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %for.body
  %10 = load i8, ptr %curr_char, align 1
  %conv13 = sext i8 %10 to i32
  %cmp14 = icmp sge i32 %conv13, 65
  br i1 %cmp14, label %land.lhs.true16, label %lor.lhs.false20

land.lhs.true16:                                  ; preds = %lor.lhs.false
  %11 = load i8, ptr %curr_char, align 1
  %conv17 = sext i8 %11 to i32
  %cmp18 = icmp sle i32 %conv17, 90
  br i1 %cmp18, label %if.then36, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %land.lhs.true16, %lor.lhs.false
  %12 = load i8, ptr %curr_char, align 1
  %conv21 = sext i8 %12 to i32
  %cmp22 = icmp sge i32 %conv21, 48
  br i1 %cmp22, label %land.lhs.true24, label %lor.lhs.false28

land.lhs.true24:                                  ; preds = %lor.lhs.false20
  %13 = load i8, ptr %curr_char, align 1
  %conv25 = sext i8 %13 to i32
  %cmp26 = icmp sle i32 %conv25, 57
  br i1 %cmp26, label %if.then36, label %lor.lhs.false28

lor.lhs.false28:                                  ; preds = %land.lhs.true24, %lor.lhs.false20
  %14 = load i8, ptr %curr_char, align 1
  %conv29 = sext i8 %14 to i32
  %cmp30 = icmp eq i32 %conv29, 95
  br i1 %cmp30, label %if.then36, label %lor.lhs.false32

lor.lhs.false32:                                  ; preds = %lor.lhs.false28
  %15 = load i8, ptr %curr_char, align 1
  %conv33 = sext i8 %15 to i32
  %cmp34 = icmp eq i32 %conv33, 45
  br i1 %cmp34, label %if.then36, label %if.end37

if.then36:                                        ; preds = %lor.lhs.false32, %lor.lhs.false28, %land.lhs.true24, %land.lhs.true16, %land.lhs.true
  br label %for.inc

if.end37:                                         ; preds = %lor.lhs.false32
  br label %do.body

do.body:                                          ; preds = %if.end37
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp38 = icmp slt i32 3, %16
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %do.body
  br label %do.end

if.end41:                                         ; preds = %do.body
  %17 = load i8, ptr %curr_char, align 1
  %conv42 = sext i8 %17 to i32
  %18 = load ptr, ptr %name.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.146, i32 noundef %conv42, ptr noundef %18)
  br label %do.end

do.end:                                           ; preds = %if.end41, %if.then40
  store i32 1, ptr %retval, align 4
  br label %return

for.inc:                                          ; preds = %if.then36
  %19 = load i64, ptr %i, align 8
  %inc = add i64 %19, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %do.end, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

declare i64 @ACLGetCommandCategoryFlagByName(ptr noundef) #1

declare i32 @ACLAddCommandCategory(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @matchAclCategoryFlag(ptr noundef %flag, ptr noundef %acl_categories_flags) #0 {
entry:
  %retval = alloca i32, align 4
  %flag.addr = alloca ptr, align 8
  %acl_categories_flags.addr = alloca ptr, align 8
  %this_flag = alloca i64, align 8
  store ptr %flag, ptr %flag.addr, align 8
  store ptr %acl_categories_flags, ptr %acl_categories_flags.addr, align 8
  %0 = load ptr, ptr %flag.addr, align 8
  %call = call i64 @ACLGetCommandCategoryFlagByName(ptr noundef %0)
  store i64 %call, ptr %this_flag, align 8
  %1 = load i64, ptr %this_flag, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %this_flag, align 8
  %3 = load ptr, ptr %acl_categories_flags.addr, align 8
  %4 = load i64, ptr %3, align 8
  %or = or i64 %4, %2
  store i64 %or, ptr %3, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define dso_local i64 @categoryFlagsFromString(ptr noundef %aclflags) #0 {
entry:
  %retval = alloca i64, align 8
  %aclflags.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  %j = alloca i32, align 4
  %acl_categories_flags = alloca i64, align 8
  %tokens = alloca ptr, align 8
  %t = alloca ptr, align 8
  store ptr %aclflags, ptr %aclflags.addr, align 8
  store i64 0, ptr %acl_categories_flags, align 8
  %0 = load ptr, ptr %aclflags.addr, align 8
  %1 = load ptr, ptr %aclflags.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #14
  %call1 = call ptr @sdssplitlen(ptr noundef %0, i64 noundef %call, ptr noundef @.str.4, i32 noundef 1, ptr noundef %count)
  store ptr %call1, ptr %tokens, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr %count, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %tokens, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  store ptr %6, ptr %t, align 8
  %7 = load ptr, ptr %t, align 8
  %call2 = call i32 @matchAclCategoryFlag(ptr noundef %7, ptr noundef %acl_categories_flags)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end5, label %if.then

if.then:                                          ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp3 = icmp slt i32 3, %8
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %9 = load ptr, ptr %t, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.28, ptr noundef %9)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then4
  br label %for.end

if.end5:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end5
  %10 = load i32, ptr %j, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !15

for.end:                                          ; preds = %do.end, %for.cond
  %11 = load ptr, ptr %tokens, align 8
  %12 = load i32, ptr %count, align 4
  call void @sdsfreesplitres(ptr noundef %11, i32 noundef %12)
  %13 = load i32, ptr %j, align 4
  %14 = load i32, ptr %count, align 4
  %cmp6 = icmp ne i32 %13, %14
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %for.end
  store i64 -1, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %for.end
  %15 = load i64, ptr %acl_categories_flags, align 8
  store i64 %15, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then7
  %16 = load i64, ptr %retval, align 8
  ret i64 %16
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetCommandACLCategories(ptr noundef %command, ptr noundef %aclflags) #0 {
entry:
  %retval = alloca i32, align 4
  %command.addr = alloca ptr, align 8
  %aclflags.addr = alloca ptr, align 8
  %categories_flags = alloca i64, align 8
  %rcmd = alloca ptr, align 8
  store ptr %command, ptr %command.addr, align 8
  store ptr %aclflags, ptr %aclflags.addr, align 8
  %0 = load ptr, ptr %command.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %command.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommand, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %module, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false2, label %if.then

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %command.addr, align 8
  %module3 = getelementptr inbounds %struct.RedisModuleCommand, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %module3, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 18
  %5 = load i32, ptr %onload, align 4
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %6 = load ptr, ptr %aclflags.addr, align 8
  %tobool5 = icmp ne ptr %6, null
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %7 = load ptr, ptr %aclflags.addr, align 8
  %call = call i64 @categoryFlagsFromString(ptr noundef %7)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %categories_flags, align 8
  %8 = load i64, ptr %categories_flags, align 8
  %cmp = icmp eq i64 %8, -1
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %cond.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %cond.end
  %9 = load ptr, ptr %command.addr, align 8
  %rediscmd = getelementptr inbounds %struct.RedisModuleCommand, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %rediscmd, align 8
  store ptr %10, ptr %rcmd, align 8
  %11 = load i64, ptr %categories_flags, align 8
  %12 = load ptr, ptr %rcmd, align 8
  %acl_categories = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 15
  store i64 %11, ptr %acl_categories, align 8
  %13 = load ptr, ptr %command.addr, align 8
  %module8 = getelementptr inbounds %struct.RedisModuleCommand, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %module8, align 8
  %num_commands_with_acl_categories = getelementptr inbounds %struct.RedisModule, ptr %14, i32 0, i32 17
  %15 = load i32, ptr %num_commands_with_acl_categories, align 8
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %num_commands_with_acl_categories, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetCommandInfo(ptr noundef %command, ptr noundef %info) #0 {
entry:
  %retval = alloca i32, align 4
  %command.addr = alloca ptr, align 8
  %info.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %version = alloca ptr, align 8
  %count = alloca i64, align 8
  %j = alloca i64, align 8
  %entry62 = alloca ptr, align 8
  %count87 = alloca i32, align 4
  %tokens = alloca ptr, align 8
  %j99 = alloca i32, align 4
  %count125 = alloca i64, align 8
  %j152 = alloca i64, align 8
  %spec = alloca ptr, align 8
  store ptr %command, ptr %command.addr, align 8
  store ptr %info, ptr %info.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %call = call i32 @moduleValidateCommandInfo(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #15
  store i32 22, ptr %call1, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %command.addr, align 8
  %rediscmd = getelementptr inbounds %struct.RedisModuleCommand, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %rediscmd, align 8
  store ptr %2, ptr %cmd, align 8
  %3 = load ptr, ptr %cmd, align 8
  %summary = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %summary, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load ptr, ptr %cmd, align 8
  %complexity = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %complexity, align 8
  %tobool3 = icmp ne ptr %6, null
  br i1 %tobool3, label %if.then21, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %7 = load ptr, ptr %cmd, align 8
  %since = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %since, align 8
  %tobool5 = icmp ne ptr %8, null
  br i1 %tobool5, label %if.then21, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false4
  %9 = load ptr, ptr %cmd, align 8
  %history = getelementptr inbounds %struct.redisCommand, ptr %9, i32 0, i32 8
  %10 = load ptr, ptr %history, align 8
  %tobool7 = icmp ne ptr %10, null
  br i1 %tobool7, label %if.then21, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %lor.lhs.false6
  %11 = load ptr, ptr %cmd, align 8
  %tips = getelementptr inbounds %struct.redisCommand, ptr %11, i32 0, i32 10
  %12 = load ptr, ptr %tips, align 8
  %tobool9 = icmp ne ptr %12, null
  br i1 %tobool9, label %if.then21, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %lor.lhs.false8
  %13 = load ptr, ptr %cmd, align 8
  %args = getelementptr inbounds %struct.redisCommand, ptr %13, i32 0, i32 21
  %14 = load ptr, ptr %args, align 8
  %tobool11 = icmp ne ptr %14, null
  br i1 %tobool11, label %if.then21, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %lor.lhs.false10
  %15 = load ptr, ptr %cmd, align 8
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %15, i32 0, i32 17
  %16 = load i32, ptr %key_specs_num, align 8
  %cmp = icmp eq i32 %16, 0
  br i1 %cmp, label %if.end23, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false12
  %17 = load ptr, ptr %cmd, align 8
  %key_specs_num14 = getelementptr inbounds %struct.redisCommand, ptr %17, i32 0, i32 17
  %18 = load i32, ptr %key_specs_num14, align 8
  %cmp15 = icmp eq i32 %18, 1
  br i1 %cmp15, label %land.lhs.true, label %if.then21

land.lhs.true:                                    ; preds = %lor.lhs.false13
  %19 = load ptr, ptr %cmd, align 8
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %19, i32 0, i32 16
  %20 = load ptr, ptr %key_specs, align 8
  %arrayidx = getelementptr inbounds %struct.keySpec, ptr %20, i64 0
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx, i32 0, i32 2
  %21 = load i32, ptr %begin_search_type, align 8
  %cmp16 = icmp eq i32 %21, 2
  br i1 %cmp16, label %land.lhs.true17, label %if.then21

land.lhs.true17:                                  ; preds = %land.lhs.true
  %22 = load ptr, ptr %cmd, align 8
  %key_specs18 = getelementptr inbounds %struct.redisCommand, ptr %22, i32 0, i32 16
  %23 = load ptr, ptr %key_specs18, align 8
  %arrayidx19 = getelementptr inbounds %struct.keySpec, ptr %23, i64 0
  %find_keys_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx19, i32 0, i32 4
  %24 = load i32, ptr %find_keys_type, align 8
  %cmp20 = icmp eq i32 %24, 2
  br i1 %cmp20, label %if.end23, label %if.then21

if.then21:                                        ; preds = %land.lhs.true17, %land.lhs.true, %lor.lhs.false13, %lor.lhs.false10, %lor.lhs.false8, %lor.lhs.false6, %lor.lhs.false4, %lor.lhs.false, %if.end
  %call22 = call ptr @__errno_location() #15
  store i32 17, ptr %call22, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %land.lhs.true17, %lor.lhs.false12
  %25 = load ptr, ptr %info.addr, align 8
  %summary24 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %summary24, align 8
  %tobool25 = icmp ne ptr %26, null
  br i1 %tobool25, label %if.then26, label %if.end30

if.then26:                                        ; preds = %if.end23
  %27 = load ptr, ptr %info.addr, align 8
  %summary27 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %summary27, align 8
  %call28 = call noalias ptr @zstrdup(ptr noundef %28)
  %29 = load ptr, ptr %cmd, align 8
  %summary29 = getelementptr inbounds %struct.redisCommand, ptr %29, i32 0, i32 1
  store ptr %call28, ptr %summary29, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then26, %if.end23
  %30 = load ptr, ptr %info.addr, align 8
  %complexity31 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %30, i32 0, i32 2
  %31 = load ptr, ptr %complexity31, align 8
  %tobool32 = icmp ne ptr %31, null
  br i1 %tobool32, label %if.then33, label %if.end37

if.then33:                                        ; preds = %if.end30
  %32 = load ptr, ptr %info.addr, align 8
  %complexity34 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %complexity34, align 8
  %call35 = call noalias ptr @zstrdup(ptr noundef %33)
  %34 = load ptr, ptr %cmd, align 8
  %complexity36 = getelementptr inbounds %struct.redisCommand, ptr %34, i32 0, i32 2
  store ptr %call35, ptr %complexity36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then33, %if.end30
  %35 = load ptr, ptr %info.addr, align 8
  %since38 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %35, i32 0, i32 3
  %36 = load ptr, ptr %since38, align 8
  %tobool39 = icmp ne ptr %36, null
  br i1 %tobool39, label %if.then40, label %if.end44

if.then40:                                        ; preds = %if.end37
  %37 = load ptr, ptr %info.addr, align 8
  %since41 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %37, i32 0, i32 3
  %38 = load ptr, ptr %since41, align 8
  %call42 = call noalias ptr @zstrdup(ptr noundef %38)
  %39 = load ptr, ptr %cmd, align 8
  %since43 = getelementptr inbounds %struct.redisCommand, ptr %39, i32 0, i32 3
  store ptr %call42, ptr %since43, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then40, %if.end37
  %40 = load ptr, ptr %info.addr, align 8
  %version45 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %40, i32 0, i32 0
  %41 = load ptr, ptr %version45, align 8
  store ptr %41, ptr %version, align 8
  %42 = load ptr, ptr %info.addr, align 8
  %history46 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %42, i32 0, i32 4
  %43 = load ptr, ptr %history46, align 8
  %tobool47 = icmp ne ptr %43, null
  br i1 %tobool47, label %if.then48, label %if.end83

if.then48:                                        ; preds = %if.end44
  store i64 0, ptr %count, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then48
  %44 = load ptr, ptr %version, align 8
  %45 = load ptr, ptr %info.addr, align 8
  %history49 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %45, i32 0, i32 4
  %46 = load ptr, ptr %history49, align 8
  %47 = load i64, ptr %count, align 8
  %conv = trunc i64 %47 to i32
  %call50 = call ptr @moduleCmdHistoryEntryAt(ptr noundef %44, ptr noundef %46, i32 noundef %conv)
  %since51 = getelementptr inbounds %struct.RedisModuleCommandHistoryEntry, ptr %call50, i32 0, i32 0
  %48 = load ptr, ptr %since51, align 8
  %tobool52 = icmp ne ptr %48, null
  br i1 %tobool52, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %49 = load i64, ptr %count, align 8
  %inc = add i64 %49, 1
  store i64 %inc, ptr %count, align 8
  br label %while.cond, !llvm.loop !16

while.end:                                        ; preds = %while.cond
  %50 = load i64, ptr %count, align 8
  %cmp53 = icmp ult i64 %50, 1152921504606846975
  %lnot = xor i1 %cmp53, true
  %lnot55 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot55 to i32
  %conv56 = sext i32 %lnot.ext to i64
  %tobool57 = icmp ne i64 %conv56, 0
  br i1 %tobool57, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.end
  br label %cond.end

cond.false:                                       ; preds = %while.end
  call void @_serverAssert(ptr noundef @.str.29, ptr noundef @.str.2, i32 noundef 1881)
  call void @abort() #13
  unreachable

51:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %51, %cond.true
  %52 = load i64, ptr %count, align 8
  %add = add i64 %52, 1
  %mul = mul i64 16, %add
  %call58 = call noalias ptr @zmalloc(i64 noundef %mul) #11
  %53 = load ptr, ptr %cmd, align 8
  %history59 = getelementptr inbounds %struct.redisCommand, ptr %53, i32 0, i32 8
  store ptr %call58, ptr %history59, align 8
  store i64 0, ptr %j, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %54 = load i64, ptr %j, align 8
  %55 = load i64, ptr %count, align 8
  %cmp60 = icmp ult i64 %54, %55
  br i1 %cmp60, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load ptr, ptr %version, align 8
  %57 = load ptr, ptr %info.addr, align 8
  %history63 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %57, i32 0, i32 4
  %58 = load ptr, ptr %history63, align 8
  %59 = load i64, ptr %j, align 8
  %conv64 = trunc i64 %59 to i32
  %call65 = call ptr @moduleCmdHistoryEntryAt(ptr noundef %56, ptr noundef %58, i32 noundef %conv64)
  store ptr %call65, ptr %entry62, align 8
  %60 = load ptr, ptr %entry62, align 8
  %since66 = getelementptr inbounds %struct.RedisModuleCommandHistoryEntry, ptr %60, i32 0, i32 0
  %61 = load ptr, ptr %since66, align 8
  %call67 = call noalias ptr @zstrdup(ptr noundef %61)
  %62 = load ptr, ptr %cmd, align 8
  %history68 = getelementptr inbounds %struct.redisCommand, ptr %62, i32 0, i32 8
  %63 = load ptr, ptr %history68, align 8
  %64 = load i64, ptr %j, align 8
  %arrayidx69 = getelementptr inbounds %struct.commandHistory, ptr %63, i64 %64
  %since70 = getelementptr inbounds %struct.commandHistory, ptr %arrayidx69, i32 0, i32 0
  store ptr %call67, ptr %since70, align 8
  %65 = load ptr, ptr %entry62, align 8
  %changes = getelementptr inbounds %struct.RedisModuleCommandHistoryEntry, ptr %65, i32 0, i32 1
  %66 = load ptr, ptr %changes, align 8
  %call71 = call noalias ptr @zstrdup(ptr noundef %66)
  %67 = load ptr, ptr %cmd, align 8
  %history72 = getelementptr inbounds %struct.redisCommand, ptr %67, i32 0, i32 8
  %68 = load ptr, ptr %history72, align 8
  %69 = load i64, ptr %j, align 8
  %arrayidx73 = getelementptr inbounds %struct.commandHistory, ptr %68, i64 %69
  %changes74 = getelementptr inbounds %struct.commandHistory, ptr %arrayidx73, i32 0, i32 1
  store ptr %call71, ptr %changes74, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %70 = load i64, ptr %j, align 8
  %inc75 = add i64 %70, 1
  store i64 %inc75, ptr %j, align 8
  br label %for.cond, !llvm.loop !17

for.end:                                          ; preds = %for.cond
  %71 = load ptr, ptr %cmd, align 8
  %history76 = getelementptr inbounds %struct.redisCommand, ptr %71, i32 0, i32 8
  %72 = load ptr, ptr %history76, align 8
  %73 = load i64, ptr %count, align 8
  %arrayidx77 = getelementptr inbounds %struct.commandHistory, ptr %72, i64 %73
  %since78 = getelementptr inbounds %struct.commandHistory, ptr %arrayidx77, i32 0, i32 0
  store ptr null, ptr %since78, align 8
  %74 = load ptr, ptr %cmd, align 8
  %history79 = getelementptr inbounds %struct.redisCommand, ptr %74, i32 0, i32 8
  %75 = load ptr, ptr %history79, align 8
  %76 = load i64, ptr %count, align 8
  %arrayidx80 = getelementptr inbounds %struct.commandHistory, ptr %75, i64 %76
  %changes81 = getelementptr inbounds %struct.commandHistory, ptr %arrayidx80, i32 0, i32 1
  store ptr null, ptr %changes81, align 8
  %77 = load i64, ptr %count, align 8
  %conv82 = trunc i64 %77 to i32
  %78 = load ptr, ptr %cmd, align 8
  %num_history = getelementptr inbounds %struct.redisCommand, ptr %78, i32 0, i32 9
  store i32 %conv82, ptr %num_history, align 8
  br label %if.end83

if.end83:                                         ; preds = %for.end, %if.end44
  %79 = load ptr, ptr %info.addr, align 8
  %tips84 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %79, i32 0, i32 5
  %80 = load ptr, ptr %tips84, align 8
  %tobool85 = icmp ne ptr %80, null
  br i1 %tobool85, label %if.then86, label %if.end116

if.then86:                                        ; preds = %if.end83
  %81 = load ptr, ptr %info.addr, align 8
  %tips88 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %81, i32 0, i32 5
  %82 = load ptr, ptr %tips88, align 8
  %83 = load ptr, ptr %info.addr, align 8
  %tips89 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %83, i32 0, i32 5
  %84 = load ptr, ptr %tips89, align 8
  %call90 = call i64 @strlen(ptr noundef %84) #14
  %call91 = call ptr @sdssplitlen(ptr noundef %82, i64 noundef %call90, ptr noundef @.str.4, i32 noundef 1, ptr noundef %count87)
  store ptr %call91, ptr %tokens, align 8
  %85 = load ptr, ptr %tokens, align 8
  %tobool92 = icmp ne ptr %85, null
  br i1 %tobool92, label %if.then93, label %if.end115

if.then93:                                        ; preds = %if.then86
  %86 = load i32, ptr %count87, align 4
  %add94 = add nsw i32 %86, 1
  %conv95 = sext i32 %add94 to i64
  %mul96 = mul i64 8, %conv95
  %call97 = call noalias ptr @zmalloc(i64 noundef %mul96) #11
  %87 = load ptr, ptr %cmd, align 8
  %tips98 = getelementptr inbounds %struct.redisCommand, ptr %87, i32 0, i32 10
  store ptr %call97, ptr %tips98, align 8
  store i32 0, ptr %j99, align 4
  br label %for.cond100

for.cond100:                                      ; preds = %for.inc109, %if.then93
  %88 = load i32, ptr %j99, align 4
  %89 = load i32, ptr %count87, align 4
  %cmp101 = icmp slt i32 %88, %89
  br i1 %cmp101, label %for.body103, label %for.end111

for.body103:                                      ; preds = %for.cond100
  %90 = load ptr, ptr %tokens, align 8
  %91 = load i32, ptr %j99, align 4
  %idxprom = sext i32 %91 to i64
  %arrayidx104 = getelementptr inbounds ptr, ptr %90, i64 %idxprom
  %92 = load ptr, ptr %arrayidx104, align 8
  %call105 = call noalias ptr @zstrdup(ptr noundef %92)
  %93 = load ptr, ptr %cmd, align 8
  %tips106 = getelementptr inbounds %struct.redisCommand, ptr %93, i32 0, i32 10
  %94 = load ptr, ptr %tips106, align 8
  %95 = load i32, ptr %j99, align 4
  %idxprom107 = sext i32 %95 to i64
  %arrayidx108 = getelementptr inbounds ptr, ptr %94, i64 %idxprom107
  store ptr %call105, ptr %arrayidx108, align 8
  br label %for.inc109

for.inc109:                                       ; preds = %for.body103
  %96 = load i32, ptr %j99, align 4
  %inc110 = add nsw i32 %96, 1
  store i32 %inc110, ptr %j99, align 4
  br label %for.cond100, !llvm.loop !18

for.end111:                                       ; preds = %for.cond100
  %97 = load ptr, ptr %cmd, align 8
  %tips112 = getelementptr inbounds %struct.redisCommand, ptr %97, i32 0, i32 10
  %98 = load ptr, ptr %tips112, align 8
  %99 = load i32, ptr %count87, align 4
  %idxprom113 = sext i32 %99 to i64
  %arrayidx114 = getelementptr inbounds ptr, ptr %98, i64 %idxprom113
  store ptr null, ptr %arrayidx114, align 8
  %100 = load i32, ptr %count87, align 4
  %101 = load ptr, ptr %cmd, align 8
  %num_tips = getelementptr inbounds %struct.redisCommand, ptr %101, i32 0, i32 11
  store i32 %100, ptr %num_tips, align 8
  %102 = load ptr, ptr %tokens, align 8
  %103 = load i32, ptr %count87, align 4
  call void @sdsfreesplitres(ptr noundef %102, i32 noundef %103)
  br label %if.end115

if.end115:                                        ; preds = %for.end111, %if.then86
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.end83
  %104 = load ptr, ptr %info.addr, align 8
  %arity = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %104, i32 0, i32 6
  %105 = load i32, ptr %arity, align 8
  %tobool117 = icmp ne i32 %105, 0
  br i1 %tobool117, label %if.then118, label %if.end121

if.then118:                                       ; preds = %if.end116
  %106 = load ptr, ptr %info.addr, align 8
  %arity119 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %106, i32 0, i32 6
  %107 = load i32, ptr %arity119, align 8
  %108 = load ptr, ptr %cmd, align 8
  %arity120 = getelementptr inbounds %struct.redisCommand, ptr %108, i32 0, i32 13
  store i32 %107, ptr %arity120, align 8
  br label %if.end121

if.end121:                                        ; preds = %if.then118, %if.end116
  %109 = load ptr, ptr %info.addr, align 8
  %key_specs122 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %109, i32 0, i32 7
  %110 = load ptr, ptr %key_specs122, align 8
  %tobool123 = icmp ne ptr %110, null
  br i1 %tobool123, label %if.then124, label %if.end264

if.then124:                                       ; preds = %if.end121
  store i64 0, ptr %count125, align 8
  br label %while.cond126

while.cond126:                                    ; preds = %while.body132, %if.then124
  %111 = load ptr, ptr %version, align 8
  %112 = load ptr, ptr %info.addr, align 8
  %key_specs127 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %112, i32 0, i32 7
  %113 = load ptr, ptr %key_specs127, align 8
  %114 = load i64, ptr %count125, align 8
  %conv128 = trunc i64 %114 to i32
  %call129 = call ptr @moduleCmdKeySpecAt(ptr noundef %111, ptr noundef %113, i32 noundef %conv128)
  %begin_search_type130 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %call129, i32 0, i32 2
  %115 = load i32, ptr %begin_search_type130, align 8
  %tobool131 = icmp ne i32 %115, 0
  br i1 %tobool131, label %while.body132, label %while.end134

while.body132:                                    ; preds = %while.cond126
  %116 = load i64, ptr %count125, align 8
  %inc133 = add i64 %116, 1
  store i64 %inc133, ptr %count125, align 8
  br label %while.cond126, !llvm.loop !19

while.end134:                                     ; preds = %while.cond126
  %117 = load i64, ptr %count125, align 8
  %cmp135 = icmp ult i64 %117, 2147483647
  %lnot137 = xor i1 %cmp135, true
  %lnot139 = xor i1 %lnot137, true
  %lnot.ext140 = zext i1 %lnot139 to i32
  %conv141 = sext i32 %lnot.ext140 to i64
  %tobool142 = icmp ne i64 %conv141, 0
  br i1 %tobool142, label %cond.true143, label %cond.false144

cond.true143:                                     ; preds = %while.end134
  br label %cond.end145

cond.false144:                                    ; preds = %while.end134
  call void @_serverAssert(ptr noundef @.str.27, ptr noundef @.str.2, i32 noundef 1915)
  call void @abort() #13
  unreachable

118:                                              ; No predecessors!
  br label %cond.end145

cond.end145:                                      ; preds = %118, %cond.true143
  %119 = load ptr, ptr %cmd, align 8
  %key_specs146 = getelementptr inbounds %struct.redisCommand, ptr %119, i32 0, i32 16
  %120 = load ptr, ptr %key_specs146, align 8
  call void @zfree(ptr noundef %120)
  %121 = load i64, ptr %count125, align 8
  %mul147 = mul i64 56, %121
  %call148 = call noalias ptr @zmalloc(i64 noundef %mul147) #11
  %122 = load ptr, ptr %cmd, align 8
  %key_specs149 = getelementptr inbounds %struct.redisCommand, ptr %122, i32 0, i32 16
  store ptr %call148, ptr %key_specs149, align 8
  %123 = load i64, ptr %count125, align 8
  %conv150 = trunc i64 %123 to i32
  %124 = load ptr, ptr %cmd, align 8
  %key_specs_num151 = getelementptr inbounds %struct.redisCommand, ptr %124, i32 0, i32 17
  store i32 %conv150, ptr %key_specs_num151, align 8
  store i64 0, ptr %j152, align 8
  br label %for.cond153

for.cond153:                                      ; preds = %for.inc261, %cond.end145
  %125 = load i64, ptr %j152, align 8
  %126 = load i64, ptr %count125, align 8
  %cmp154 = icmp ult i64 %125, %126
  br i1 %cmp154, label %for.body156, label %for.end263

for.body156:                                      ; preds = %for.cond153
  %127 = load ptr, ptr %version, align 8
  %128 = load ptr, ptr %info.addr, align 8
  %key_specs157 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %128, i32 0, i32 7
  %129 = load ptr, ptr %key_specs157, align 8
  %130 = load i64, ptr %j152, align 8
  %conv158 = trunc i64 %130 to i32
  %call159 = call ptr @moduleCmdKeySpecAt(ptr noundef %127, ptr noundef %129, i32 noundef %conv158)
  store ptr %call159, ptr %spec, align 8
  %131 = load ptr, ptr %spec, align 8
  %notes = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %131, i32 0, i32 0
  %132 = load ptr, ptr %notes, align 8
  %tobool160 = icmp ne ptr %132, null
  br i1 %tobool160, label %cond.true161, label %cond.false164

cond.true161:                                     ; preds = %for.body156
  %133 = load ptr, ptr %spec, align 8
  %notes162 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %133, i32 0, i32 0
  %134 = load ptr, ptr %notes162, align 8
  %call163 = call noalias ptr @zstrdup(ptr noundef %134)
  br label %cond.end165

cond.false164:                                    ; preds = %for.body156
  br label %cond.end165

cond.end165:                                      ; preds = %cond.false164, %cond.true161
  %cond = phi ptr [ %call163, %cond.true161 ], [ null, %cond.false164 ]
  %135 = load ptr, ptr %cmd, align 8
  %key_specs166 = getelementptr inbounds %struct.redisCommand, ptr %135, i32 0, i32 16
  %136 = load ptr, ptr %key_specs166, align 8
  %137 = load i64, ptr %j152, align 8
  %arrayidx167 = getelementptr inbounds %struct.keySpec, ptr %136, i64 %137
  %notes168 = getelementptr inbounds %struct.keySpec, ptr %arrayidx167, i32 0, i32 0
  store ptr %cond, ptr %notes168, align 8
  %138 = load ptr, ptr %spec, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %138, i32 0, i32 1
  %139 = load i64, ptr %flags, align 8
  %call169 = call i64 @moduleConvertKeySpecsFlags(i64 noundef %139, i32 noundef 1)
  %140 = load ptr, ptr %cmd, align 8
  %key_specs170 = getelementptr inbounds %struct.redisCommand, ptr %140, i32 0, i32 16
  %141 = load ptr, ptr %key_specs170, align 8
  %142 = load i64, ptr %j152, align 8
  %arrayidx171 = getelementptr inbounds %struct.keySpec, ptr %141, i64 %142
  %flags172 = getelementptr inbounds %struct.keySpec, ptr %arrayidx171, i32 0, i32 1
  store i64 %call169, ptr %flags172, align 8
  %143 = load ptr, ptr %spec, align 8
  %begin_search_type173 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %143, i32 0, i32 2
  %144 = load i32, ptr %begin_search_type173, align 8
  switch i32 %144, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb177
    i32 3, label %sw.bb185
  ]

sw.bb:                                            ; preds = %cond.end165
  %145 = load ptr, ptr %cmd, align 8
  %key_specs174 = getelementptr inbounds %struct.redisCommand, ptr %145, i32 0, i32 16
  %146 = load ptr, ptr %key_specs174, align 8
  %147 = load i64, ptr %j152, align 8
  %arrayidx175 = getelementptr inbounds %struct.keySpec, ptr %146, i64 %147
  %begin_search_type176 = getelementptr inbounds %struct.keySpec, ptr %arrayidx175, i32 0, i32 2
  store i32 1, ptr %begin_search_type176, align 8
  br label %sw.epilog

sw.bb177:                                         ; preds = %cond.end165
  %148 = load ptr, ptr %cmd, align 8
  %key_specs178 = getelementptr inbounds %struct.redisCommand, ptr %148, i32 0, i32 16
  %149 = load ptr, ptr %key_specs178, align 8
  %150 = load i64, ptr %j152, align 8
  %arrayidx179 = getelementptr inbounds %struct.keySpec, ptr %149, i64 %150
  %begin_search_type180 = getelementptr inbounds %struct.keySpec, ptr %arrayidx179, i32 0, i32 2
  store i32 2, ptr %begin_search_type180, align 8
  %151 = load ptr, ptr %spec, align 8
  %bs = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %151, i32 0, i32 3
  %pos = getelementptr inbounds %struct.anon.10, ptr %bs, i32 0, i32 0
  %152 = load i32, ptr %pos, align 8
  %153 = load ptr, ptr %cmd, align 8
  %key_specs181 = getelementptr inbounds %struct.redisCommand, ptr %153, i32 0, i32 16
  %154 = load ptr, ptr %key_specs181, align 8
  %155 = load i64, ptr %j152, align 8
  %arrayidx182 = getelementptr inbounds %struct.keySpec, ptr %154, i64 %155
  %bs183 = getelementptr inbounds %struct.keySpec, ptr %arrayidx182, i32 0, i32 3
  %pos184 = getelementptr inbounds %struct.anon.4, ptr %bs183, i32 0, i32 0
  store i32 %152, ptr %pos184, align 8
  br label %sw.epilog

sw.bb185:                                         ; preds = %cond.end165
  %156 = load ptr, ptr %cmd, align 8
  %key_specs186 = getelementptr inbounds %struct.redisCommand, ptr %156, i32 0, i32 16
  %157 = load ptr, ptr %key_specs186, align 8
  %158 = load i64, ptr %j152, align 8
  %arrayidx187 = getelementptr inbounds %struct.keySpec, ptr %157, i64 %158
  %begin_search_type188 = getelementptr inbounds %struct.keySpec, ptr %arrayidx187, i32 0, i32 2
  store i32 3, ptr %begin_search_type188, align 8
  %159 = load ptr, ptr %spec, align 8
  %bs189 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %159, i32 0, i32 3
  %keyword = getelementptr inbounds %struct.anon.11, ptr %bs189, i32 0, i32 0
  %160 = load ptr, ptr %keyword, align 8
  %call190 = call noalias ptr @zstrdup(ptr noundef %160)
  %161 = load ptr, ptr %cmd, align 8
  %key_specs191 = getelementptr inbounds %struct.redisCommand, ptr %161, i32 0, i32 16
  %162 = load ptr, ptr %key_specs191, align 8
  %163 = load i64, ptr %j152, align 8
  %arrayidx192 = getelementptr inbounds %struct.keySpec, ptr %162, i64 %163
  %bs193 = getelementptr inbounds %struct.keySpec, ptr %arrayidx192, i32 0, i32 3
  %keyword194 = getelementptr inbounds %struct.anon.5, ptr %bs193, i32 0, i32 0
  store ptr %call190, ptr %keyword194, align 8
  %164 = load ptr, ptr %spec, align 8
  %bs195 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %164, i32 0, i32 3
  %startfrom = getelementptr inbounds %struct.anon.11, ptr %bs195, i32 0, i32 1
  %165 = load i32, ptr %startfrom, align 8
  %166 = load ptr, ptr %cmd, align 8
  %key_specs196 = getelementptr inbounds %struct.redisCommand, ptr %166, i32 0, i32 16
  %167 = load ptr, ptr %key_specs196, align 8
  %168 = load i64, ptr %j152, align 8
  %arrayidx197 = getelementptr inbounds %struct.keySpec, ptr %167, i64 %168
  %bs198 = getelementptr inbounds %struct.keySpec, ptr %arrayidx197, i32 0, i32 3
  %startfrom199 = getelementptr inbounds %struct.anon.5, ptr %bs198, i32 0, i32 1
  store i32 %165, ptr %startfrom199, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %cond.end165
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 1941, ptr noundef @.str.30)
  call void @abort() #13
  unreachable

sw.epilog:                                        ; preds = %sw.bb185, %sw.bb177, %sw.bb
  %169 = load ptr, ptr %spec, align 8
  %find_keys_type200 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %169, i32 0, i32 4
  %170 = load i32, ptr %find_keys_type200, align 8
  switch i32 %170, label %sw.default259 [
    i32 0, label %sw.bb201
    i32 1, label %sw.bb213
    i32 2, label %sw.bb217
    i32 3, label %sw.bb239
  ]

sw.bb201:                                         ; preds = %sw.epilog
  %171 = load ptr, ptr %cmd, align 8
  %key_specs202 = getelementptr inbounds %struct.redisCommand, ptr %171, i32 0, i32 16
  %172 = load ptr, ptr %key_specs202, align 8
  %173 = load i64, ptr %j152, align 8
  %arrayidx203 = getelementptr inbounds %struct.keySpec, ptr %172, i64 %173
  %find_keys_type204 = getelementptr inbounds %struct.keySpec, ptr %arrayidx203, i32 0, i32 4
  store i32 2, ptr %find_keys_type204, align 8
  %174 = load ptr, ptr %cmd, align 8
  %key_specs205 = getelementptr inbounds %struct.redisCommand, ptr %174, i32 0, i32 16
  %175 = load ptr, ptr %key_specs205, align 8
  %176 = load i64, ptr %j152, align 8
  %arrayidx206 = getelementptr inbounds %struct.keySpec, ptr %175, i64 %176
  %fk = getelementptr inbounds %struct.keySpec, ptr %arrayidx206, i32 0, i32 5
  %lastkey = getelementptr inbounds %struct.anon.7, ptr %fk, i32 0, i32 0
  store i32 0, ptr %lastkey, align 4
  %177 = load ptr, ptr %cmd, align 8
  %key_specs207 = getelementptr inbounds %struct.redisCommand, ptr %177, i32 0, i32 16
  %178 = load ptr, ptr %key_specs207, align 8
  %179 = load i64, ptr %j152, align 8
  %arrayidx208 = getelementptr inbounds %struct.keySpec, ptr %178, i64 %179
  %fk209 = getelementptr inbounds %struct.keySpec, ptr %arrayidx208, i32 0, i32 5
  %keystep = getelementptr inbounds %struct.anon.7, ptr %fk209, i32 0, i32 1
  store i32 1, ptr %keystep, align 4
  %180 = load ptr, ptr %cmd, align 8
  %key_specs210 = getelementptr inbounds %struct.redisCommand, ptr %180, i32 0, i32 16
  %181 = load ptr, ptr %key_specs210, align 8
  %182 = load i64, ptr %j152, align 8
  %arrayidx211 = getelementptr inbounds %struct.keySpec, ptr %181, i64 %182
  %fk212 = getelementptr inbounds %struct.keySpec, ptr %arrayidx211, i32 0, i32 5
  %limit = getelementptr inbounds %struct.anon.7, ptr %fk212, i32 0, i32 2
  store i32 0, ptr %limit, align 4
  br label %sw.epilog260

sw.bb213:                                         ; preds = %sw.epilog
  %183 = load ptr, ptr %cmd, align 8
  %key_specs214 = getelementptr inbounds %struct.redisCommand, ptr %183, i32 0, i32 16
  %184 = load ptr, ptr %key_specs214, align 8
  %185 = load i64, ptr %j152, align 8
  %arrayidx215 = getelementptr inbounds %struct.keySpec, ptr %184, i64 %185
  %find_keys_type216 = getelementptr inbounds %struct.keySpec, ptr %arrayidx215, i32 0, i32 4
  store i32 1, ptr %find_keys_type216, align 8
  br label %sw.epilog260

sw.bb217:                                         ; preds = %sw.epilog
  %186 = load ptr, ptr %cmd, align 8
  %key_specs218 = getelementptr inbounds %struct.redisCommand, ptr %186, i32 0, i32 16
  %187 = load ptr, ptr %key_specs218, align 8
  %188 = load i64, ptr %j152, align 8
  %arrayidx219 = getelementptr inbounds %struct.keySpec, ptr %187, i64 %188
  %find_keys_type220 = getelementptr inbounds %struct.keySpec, ptr %arrayidx219, i32 0, i32 4
  store i32 2, ptr %find_keys_type220, align 8
  %189 = load ptr, ptr %spec, align 8
  %fk221 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %189, i32 0, i32 5
  %lastkey222 = getelementptr inbounds %struct.anon.13, ptr %fk221, i32 0, i32 0
  %190 = load i32, ptr %lastkey222, align 4
  %191 = load ptr, ptr %cmd, align 8
  %key_specs223 = getelementptr inbounds %struct.redisCommand, ptr %191, i32 0, i32 16
  %192 = load ptr, ptr %key_specs223, align 8
  %193 = load i64, ptr %j152, align 8
  %arrayidx224 = getelementptr inbounds %struct.keySpec, ptr %192, i64 %193
  %fk225 = getelementptr inbounds %struct.keySpec, ptr %arrayidx224, i32 0, i32 5
  %lastkey226 = getelementptr inbounds %struct.anon.7, ptr %fk225, i32 0, i32 0
  store i32 %190, ptr %lastkey226, align 4
  %194 = load ptr, ptr %spec, align 8
  %fk227 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %194, i32 0, i32 5
  %keystep228 = getelementptr inbounds %struct.anon.13, ptr %fk227, i32 0, i32 1
  %195 = load i32, ptr %keystep228, align 4
  %196 = load ptr, ptr %cmd, align 8
  %key_specs229 = getelementptr inbounds %struct.redisCommand, ptr %196, i32 0, i32 16
  %197 = load ptr, ptr %key_specs229, align 8
  %198 = load i64, ptr %j152, align 8
  %arrayidx230 = getelementptr inbounds %struct.keySpec, ptr %197, i64 %198
  %fk231 = getelementptr inbounds %struct.keySpec, ptr %arrayidx230, i32 0, i32 5
  %keystep232 = getelementptr inbounds %struct.anon.7, ptr %fk231, i32 0, i32 1
  store i32 %195, ptr %keystep232, align 4
  %199 = load ptr, ptr %spec, align 8
  %fk233 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %199, i32 0, i32 5
  %limit234 = getelementptr inbounds %struct.anon.13, ptr %fk233, i32 0, i32 2
  %200 = load i32, ptr %limit234, align 4
  %201 = load ptr, ptr %cmd, align 8
  %key_specs235 = getelementptr inbounds %struct.redisCommand, ptr %201, i32 0, i32 16
  %202 = load ptr, ptr %key_specs235, align 8
  %203 = load i64, ptr %j152, align 8
  %arrayidx236 = getelementptr inbounds %struct.keySpec, ptr %202, i64 %203
  %fk237 = getelementptr inbounds %struct.keySpec, ptr %arrayidx236, i32 0, i32 5
  %limit238 = getelementptr inbounds %struct.anon.7, ptr %fk237, i32 0, i32 2
  store i32 %200, ptr %limit238, align 4
  br label %sw.epilog260

sw.bb239:                                         ; preds = %sw.epilog
  %204 = load ptr, ptr %cmd, align 8
  %key_specs240 = getelementptr inbounds %struct.redisCommand, ptr %204, i32 0, i32 16
  %205 = load ptr, ptr %key_specs240, align 8
  %206 = load i64, ptr %j152, align 8
  %arrayidx241 = getelementptr inbounds %struct.keySpec, ptr %205, i64 %206
  %find_keys_type242 = getelementptr inbounds %struct.keySpec, ptr %arrayidx241, i32 0, i32 4
  store i32 3, ptr %find_keys_type242, align 8
  %207 = load ptr, ptr %spec, align 8
  %fk243 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %207, i32 0, i32 5
  %keynumidx = getelementptr inbounds %struct.anon.14, ptr %fk243, i32 0, i32 0
  %208 = load i32, ptr %keynumidx, align 4
  %209 = load ptr, ptr %cmd, align 8
  %key_specs244 = getelementptr inbounds %struct.redisCommand, ptr %209, i32 0, i32 16
  %210 = load ptr, ptr %key_specs244, align 8
  %211 = load i64, ptr %j152, align 8
  %arrayidx245 = getelementptr inbounds %struct.keySpec, ptr %210, i64 %211
  %fk246 = getelementptr inbounds %struct.keySpec, ptr %arrayidx245, i32 0, i32 5
  %keynumidx247 = getelementptr inbounds %struct.anon.8, ptr %fk246, i32 0, i32 0
  store i32 %208, ptr %keynumidx247, align 4
  %212 = load ptr, ptr %spec, align 8
  %fk248 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %212, i32 0, i32 5
  %firstkey = getelementptr inbounds %struct.anon.14, ptr %fk248, i32 0, i32 1
  %213 = load i32, ptr %firstkey, align 4
  %214 = load ptr, ptr %cmd, align 8
  %key_specs249 = getelementptr inbounds %struct.redisCommand, ptr %214, i32 0, i32 16
  %215 = load ptr, ptr %key_specs249, align 8
  %216 = load i64, ptr %j152, align 8
  %arrayidx250 = getelementptr inbounds %struct.keySpec, ptr %215, i64 %216
  %fk251 = getelementptr inbounds %struct.keySpec, ptr %arrayidx250, i32 0, i32 5
  %firstkey252 = getelementptr inbounds %struct.anon.8, ptr %fk251, i32 0, i32 1
  store i32 %213, ptr %firstkey252, align 4
  %217 = load ptr, ptr %spec, align 8
  %fk253 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %217, i32 0, i32 5
  %keystep254 = getelementptr inbounds %struct.anon.14, ptr %fk253, i32 0, i32 2
  %218 = load i32, ptr %keystep254, align 4
  %219 = load ptr, ptr %cmd, align 8
  %key_specs255 = getelementptr inbounds %struct.redisCommand, ptr %219, i32 0, i32 16
  %220 = load ptr, ptr %key_specs255, align 8
  %221 = load i64, ptr %j152, align 8
  %arrayidx256 = getelementptr inbounds %struct.keySpec, ptr %220, i64 %221
  %fk257 = getelementptr inbounds %struct.keySpec, ptr %arrayidx256, i32 0, i32 5
  %keystep258 = getelementptr inbounds %struct.anon.8, ptr %fk257, i32 0, i32 2
  store i32 %218, ptr %keystep258, align 4
  br label %sw.epilog260

sw.default259:                                    ; preds = %sw.epilog
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 1969, ptr noundef @.str.31)
  call void @abort() #13
  unreachable

sw.epilog260:                                     ; preds = %sw.bb239, %sw.bb217, %sw.bb213, %sw.bb201
  br label %for.inc261

for.inc261:                                       ; preds = %sw.epilog260
  %222 = load i64, ptr %j152, align 8
  %inc262 = add i64 %222, 1
  store i64 %inc262, ptr %j152, align 8
  br label %for.cond153, !llvm.loop !20

for.end263:                                       ; preds = %for.cond153
  %223 = load ptr, ptr %cmd, align 8
  call void @populateCommandLegacyRangeSpec(ptr noundef %223)
  br label %if.end264

if.end264:                                        ; preds = %for.end263, %if.end121
  %224 = load ptr, ptr %info.addr, align 8
  %args265 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %224, i32 0, i32 8
  %225 = load ptr, ptr %args265, align 8
  %tobool266 = icmp ne ptr %225, null
  br i1 %tobool266, label %if.then267, label %if.end273

if.then267:                                       ; preds = %if.end264
  %226 = load ptr, ptr %info.addr, align 8
  %args268 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %226, i32 0, i32 8
  %227 = load ptr, ptr %args268, align 8
  %228 = load ptr, ptr %version, align 8
  %call269 = call ptr @moduleCopyCommandArgs(ptr noundef %227, ptr noundef %228)
  %229 = load ptr, ptr %cmd, align 8
  %args270 = getelementptr inbounds %struct.redisCommand, ptr %229, i32 0, i32 21
  store ptr %call269, ptr %args270, align 8
  %230 = load ptr, ptr %cmd, align 8
  %args271 = getelementptr inbounds %struct.redisCommand, ptr %230, i32 0, i32 21
  %231 = load ptr, ptr %args271, align 8
  %call272 = call i32 @populateArgsStructure(ptr noundef %231)
  %232 = load ptr, ptr %cmd, align 8
  %num_args = getelementptr inbounds %struct.redisCommand, ptr %232, i32 0, i32 19
  store i32 %call272, ptr %num_args, align 8
  br label %if.end273

if.end273:                                        ; preds = %if.then267, %if.end264
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end273, %if.then21, %if.then
  %233 = load i32, ptr %retval, align 4
  ret i32 %233
}

; Function Attrs: nounwind uwtable
define internal i32 @moduleValidateCommandInfo(ptr noundef %info) #0 {
entry:
  %retval = alloca i32, align 4
  %info.addr = alloca ptr, align 8
  %version = alloca ptr, align 8
  %j = alloca i64, align 8
  %j23 = alloca i64, align 8
  %spec = alloca ptr, align 8
  %key_flags = alloca i64, align 8
  %write_flags = alloca i64, align 8
  store ptr %info, ptr %info.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %version1 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %version1, align 8
  store ptr %1, ptr %version, align 8
  %2 = load ptr, ptr %version, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end3, label %if.then

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 3, %3
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.524)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %entry
  %4 = load ptr, ptr %info.addr, align 8
  %history = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %history, align 8
  %tobool4 = icmp ne ptr %5, null
  br i1 %tobool4, label %if.then5, label %if.end20

if.then5:                                         ; preds = %if.end3
  store i64 0, ptr %j, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then5
  %6 = load ptr, ptr %version, align 8
  %7 = load ptr, ptr %info.addr, align 8
  %history6 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %history6, align 8
  %9 = load i64, ptr %j, align 8
  %conv = trunc i64 %9 to i32
  %call = call ptr @moduleCmdHistoryEntryAt(ptr noundef %6, ptr noundef %8, i32 noundef %conv)
  %since = getelementptr inbounds %struct.RedisModuleCommandHistoryEntry, ptr %call, i32 0, i32 0
  %10 = load ptr, ptr %since, align 8
  %tobool7 = icmp ne ptr %10, null
  br i1 %tobool7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %version, align 8
  %12 = load ptr, ptr %info.addr, align 8
  %history8 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %history8, align 8
  %14 = load i64, ptr %j, align 8
  %conv9 = trunc i64 %14 to i32
  %call10 = call ptr @moduleCmdHistoryEntryAt(ptr noundef %11, ptr noundef %13, i32 noundef %conv9)
  %changes = getelementptr inbounds %struct.RedisModuleCommandHistoryEntry, ptr %call10, i32 0, i32 1
  %15 = load ptr, ptr %changes, align 8
  %tobool11 = icmp ne ptr %15, null
  br i1 %tobool11, label %if.end19, label %if.then12

if.then12:                                        ; preds = %for.body
  br label %do.body13

do.body13:                                        ; preds = %if.then12
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp14 = icmp slt i32 3, %16
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %do.body13
  br label %do.end18

if.end17:                                         ; preds = %do.body13
  %17 = load i64, ptr %j, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.525, i64 noundef %17)
  br label %do.end18

do.end18:                                         ; preds = %if.end17, %if.then16
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %18 = load i64, ptr %j, align 8
  %inc = add i64 %18, 1
  store i64 %inc, ptr %j, align 8
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  br label %if.end20

if.end20:                                         ; preds = %for.end, %if.end3
  %19 = load ptr, ptr %info.addr, align 8
  %key_specs = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %19, i32 0, i32 7
  %20 = load ptr, ptr %key_specs, align 8
  %tobool21 = icmp ne ptr %20, null
  br i1 %tobool21, label %if.then22, label %if.end105

if.then22:                                        ; preds = %if.end20
  store i64 0, ptr %j23, align 8
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc102, %if.then22
  %21 = load ptr, ptr %version, align 8
  %22 = load ptr, ptr %info.addr, align 8
  %key_specs25 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %22, i32 0, i32 7
  %23 = load ptr, ptr %key_specs25, align 8
  %24 = load i64, ptr %j23, align 8
  %conv26 = trunc i64 %24 to i32
  %call27 = call ptr @moduleCmdKeySpecAt(ptr noundef %21, ptr noundef %23, i32 noundef %conv26)
  %begin_search_type = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %call27, i32 0, i32 2
  %25 = load i32, ptr %begin_search_type, align 8
  %tobool28 = icmp ne i32 %25, 0
  br i1 %tobool28, label %for.body29, label %for.end104

for.body29:                                       ; preds = %for.cond24
  %26 = load ptr, ptr %version, align 8
  %27 = load ptr, ptr %info.addr, align 8
  %key_specs30 = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %27, i32 0, i32 7
  %28 = load ptr, ptr %key_specs30, align 8
  %29 = load i64, ptr %j23, align 8
  %conv31 = trunc i64 %29 to i32
  %call32 = call ptr @moduleCmdKeySpecAt(ptr noundef %26, ptr noundef %28, i32 noundef %conv31)
  store ptr %call32, ptr %spec, align 8
  %30 = load i64, ptr %j23, align 8
  %cmp33 = icmp uge i64 %30, 2147483647
  br i1 %cmp33, label %if.then35, label %if.end42

if.then35:                                        ; preds = %for.body29
  br label %do.body36

do.body36:                                        ; preds = %if.then35
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp37 = icmp slt i32 3, %31
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %do.body36
  br label %do.end41

if.end40:                                         ; preds = %do.body36
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.526)
  br label %do.end41

do.end41:                                         ; preds = %if.end40, %if.then39
  store i32 0, ptr %retval, align 4
  br label %return

if.end42:                                         ; preds = %for.body29
  store i64 15, ptr %key_flags, align 8
  store i64 224, ptr %write_flags, align 8
  %32 = load ptr, ptr %spec, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %32, i32 0, i32 1
  %33 = load i64, ptr %flags, align 8
  %34 = load i64, ptr %key_flags, align 8
  %and = and i64 %33, %34
  %call43 = call i32 @isPowerOfTwo(i64 noundef %and)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %if.end52, label %if.then45

if.then45:                                        ; preds = %if.end42
  br label %do.body46

do.body46:                                        ; preds = %if.then45
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp47 = icmp slt i32 3, %35
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %do.body46
  br label %do.end51

if.end50:                                         ; preds = %do.body46
  %36 = load i64, ptr %j23, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.527, i64 noundef %36)
  br label %do.end51

do.end51:                                         ; preds = %if.end50, %if.then49
  store i32 0, ptr %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end42
  %37 = load ptr, ptr %spec, align 8
  %flags53 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %37, i32 0, i32 1
  %38 = load i64, ptr %flags53, align 8
  %39 = load i64, ptr %write_flags, align 8
  %and54 = and i64 %38, %39
  %cmp55 = icmp ne i64 %and54, 0
  br i1 %cmp55, label %land.lhs.true, label %if.end68

land.lhs.true:                                    ; preds = %if.end52
  %40 = load ptr, ptr %spec, align 8
  %flags57 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %40, i32 0, i32 1
  %41 = load i64, ptr %flags57, align 8
  %42 = load i64, ptr %write_flags, align 8
  %and58 = and i64 %41, %42
  %call59 = call i32 @isPowerOfTwo(i64 noundef %and58)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %if.end68, label %if.then61

if.then61:                                        ; preds = %land.lhs.true
  br label %do.body62

do.body62:                                        ; preds = %if.then61
  %43 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp63 = icmp slt i32 3, %43
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %do.body62
  br label %do.end67

if.end66:                                         ; preds = %do.body62
  %44 = load i64, ptr %j23, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.528, i64 noundef %44)
  br label %do.end67

do.end67:                                         ; preds = %if.end66, %if.then65
  store i32 0, ptr %retval, align 4
  br label %return

if.end68:                                         ; preds = %land.lhs.true, %if.end52
  %45 = load ptr, ptr %spec, align 8
  %begin_search_type69 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %45, i32 0, i32 2
  %46 = load i32, ptr %begin_search_type69, align 8
  switch i32 %46, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb70
    i32 3, label %sw.bb71
  ]

sw.bb:                                            ; preds = %if.end68
  br label %sw.epilog

sw.bb70:                                          ; preds = %if.end68
  br label %sw.epilog

sw.bb71:                                          ; preds = %if.end68
  %47 = load ptr, ptr %spec, align 8
  %bs = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %47, i32 0, i32 3
  %keyword = getelementptr inbounds %struct.anon.11, ptr %bs, i32 0, i32 0
  %48 = load ptr, ptr %keyword, align 8
  %cmp72 = icmp eq ptr %48, null
  br i1 %cmp72, label %if.then74, label %if.end81

if.then74:                                        ; preds = %sw.bb71
  br label %do.body75

do.body75:                                        ; preds = %if.then74
  %49 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp76 = icmp slt i32 3, %49
  br i1 %cmp76, label %if.then78, label %if.end79

if.then78:                                        ; preds = %do.body75
  br label %do.end80

if.end79:                                         ; preds = %do.body75
  %50 = load i64, ptr %j23, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.529, i64 noundef %50)
  br label %do.end80

do.end80:                                         ; preds = %if.end79, %if.then78
  store i32 0, ptr %retval, align 4
  br label %return

if.end81:                                         ; preds = %sw.bb71
  br label %sw.epilog

sw.default:                                       ; preds = %if.end68
  br label %do.body82

do.body82:                                        ; preds = %sw.default
  %51 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp83 = icmp slt i32 3, %51
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %do.body82
  br label %do.end88

if.end86:                                         ; preds = %do.body82
  %52 = load i64, ptr %j23, align 8
  %53 = load ptr, ptr %spec, align 8
  %begin_search_type87 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %53, i32 0, i32 2
  %54 = load i32, ptr %begin_search_type87, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.530, i64 noundef %52, i32 noundef %54)
  br label %do.end88

do.end88:                                         ; preds = %if.end86, %if.then85
  store i32 0, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.end81, %sw.bb70, %sw.bb
  %55 = load ptr, ptr %spec, align 8
  %find_keys_type = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %55, i32 0, i32 4
  %56 = load i32, ptr %find_keys_type, align 8
  switch i32 %56, label %sw.default93 [
    i32 0, label %sw.bb89
    i32 1, label %sw.bb90
    i32 2, label %sw.bb91
    i32 3, label %sw.bb92
  ]

sw.bb89:                                          ; preds = %sw.epilog
  br label %sw.epilog101

sw.bb90:                                          ; preds = %sw.epilog
  br label %sw.epilog101

sw.bb91:                                          ; preds = %sw.epilog
  br label %sw.epilog101

sw.bb92:                                          ; preds = %sw.epilog
  br label %sw.epilog101

sw.default93:                                     ; preds = %sw.epilog
  br label %do.body94

do.body94:                                        ; preds = %sw.default93
  %57 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp95 = icmp slt i32 3, %57
  br i1 %cmp95, label %if.then97, label %if.end98

if.then97:                                        ; preds = %do.body94
  br label %do.end100

if.end98:                                         ; preds = %do.body94
  %58 = load i64, ptr %j23, align 8
  %59 = load ptr, ptr %spec, align 8
  %find_keys_type99 = getelementptr inbounds %struct.RedisModuleCommandKeySpec, ptr %59, i32 0, i32 4
  %60 = load i32, ptr %find_keys_type99, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.531, i64 noundef %58, i32 noundef %60)
  br label %do.end100

do.end100:                                        ; preds = %if.end98, %if.then97
  store i32 0, ptr %retval, align 4
  br label %return

sw.epilog101:                                     ; preds = %sw.bb92, %sw.bb91, %sw.bb90, %sw.bb89
  br label %for.inc102

for.inc102:                                       ; preds = %sw.epilog101
  %61 = load i64, ptr %j23, align 8
  %inc103 = add i64 %61, 1
  store i64 %inc103, ptr %j23, align 8
  br label %for.cond24, !llvm.loop !22

for.end104:                                       ; preds = %for.cond24
  br label %if.end105

if.end105:                                        ; preds = %for.end104, %if.end20
  %62 = load ptr, ptr %info.addr, align 8
  %args = getelementptr inbounds %struct.RedisModuleCommandInfo, ptr %62, i32 0, i32 8
  %63 = load ptr, ptr %args, align 8
  %64 = load ptr, ptr %version, align 8
  %call106 = call i32 @moduleValidateCommandArgs(ptr noundef %63, ptr noundef %64)
  store i32 %call106, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end105, %do.end100, %do.end88, %do.end80, %do.end67, %do.end51, %do.end41, %do.end18, %do.end
  %65 = load i32, ptr %retval, align 4
  ret i32 %65
}

; Function Attrs: nounwind uwtable
define internal ptr @moduleCmdHistoryEntryAt(ptr noundef %version, ptr noundef %entries, i32 noundef %index) #0 {
entry:
  %version.addr = alloca ptr, align 8
  %entries.addr = alloca ptr, align 8
  %index.addr = alloca i32, align 4
  %offset = alloca i64, align 8
  store ptr %version, ptr %version.addr, align 8
  store ptr %entries, ptr %entries.addr, align 8
  store i32 %index, ptr %index.addr, align 4
  %0 = load i32, ptr %index.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load ptr, ptr %version.addr, align 8
  %sizeof_historyentry = getelementptr inbounds %struct.RedisModuleCommandInfoVersion, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %sizeof_historyentry, align 8
  %mul = mul i64 %conv, %2
  store i64 %mul, ptr %offset, align 8
  %3 = load ptr, ptr %entries.addr, align 8
  %4 = load i64, ptr %offset, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 %4
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define internal ptr @moduleCmdKeySpecAt(ptr noundef %version, ptr noundef %keyspecs, i32 noundef %index) #0 {
entry:
  %version.addr = alloca ptr, align 8
  %keyspecs.addr = alloca ptr, align 8
  %index.addr = alloca i32, align 4
  %offset = alloca i64, align 8
  store ptr %version, ptr %version.addr, align 8
  store ptr %keyspecs, ptr %keyspecs.addr, align 8
  store i32 %index, ptr %index.addr, align 4
  %0 = load i32, ptr %index.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load ptr, ptr %version.addr, align 8
  %sizeof_keyspec = getelementptr inbounds %struct.RedisModuleCommandInfoVersion, ptr %1, i32 0, i32 2
  %2 = load i64, ptr %sizeof_keyspec, align 8
  %mul = mul i64 %conv, %2
  store i64 %mul, ptr %offset, align 8
  %3 = load ptr, ptr %keyspecs.addr, align 8
  %4 = load i64, ptr %offset, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 %4
  ret ptr %add.ptr
}

declare void @_serverPanic(ptr noundef, i32 noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define internal ptr @moduleCopyCommandArgs(ptr noundef %args, ptr noundef %version) #0 {
entry:
  %args.addr = alloca ptr, align 8
  %version.addr = alloca ptr, align 8
  %count = alloca i64, align 8
  %realargs = alloca ptr, align 8
  %j = alloca i64, align 8
  %arg = alloca ptr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %version, ptr %version.addr, align 8
  store i64 0, ptr %count, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %version.addr, align 8
  %1 = load ptr, ptr %args.addr, align 8
  %2 = load i64, ptr %count, align 8
  %conv = trunc i64 %2 to i32
  %call = call ptr @moduleCmdArgAt(ptr noundef %0, ptr noundef %1, i32 noundef %conv)
  %name = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %call, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i64, ptr %count, align 8
  %inc = add i64 %4, 1
  store i64 %inc, ptr %count, align 8
  br label %while.cond, !llvm.loop !23

while.end:                                        ; preds = %while.cond
  %5 = load i64, ptr %count, align 8
  %cmp = icmp ult i64 %5, 230584300921369395
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv3 = sext i32 %lnot.ext to i64
  %tobool4 = icmp ne i64 %conv3, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.end
  br label %cond.end

cond.false:                                       ; preds = %while.end
  call void @_serverAssert(ptr noundef @.str.539, ptr noundef @.str.2, i32 noundef 2193)
  call void @abort() #13
  unreachable

6:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %6, %cond.true
  %7 = load i64, ptr %count, align 8
  %add = add i64 %7, 1
  %mul = mul i64 %add, 80
  %call5 = call noalias ptr @zcalloc(i64 noundef %mul) #11
  store ptr %call5, ptr %realargs, align 8
  store i64 0, ptr %j, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %8 = load i64, ptr %j, align 8
  %9 = load i64, ptr %count, align 8
  %cmp6 = icmp ult i64 %8, %9
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %version.addr, align 8
  %11 = load ptr, ptr %args.addr, align 8
  %12 = load i64, ptr %j, align 8
  %conv8 = trunc i64 %12 to i32
  %call9 = call ptr @moduleCmdArgAt(ptr noundef %10, ptr noundef %11, i32 noundef %conv8)
  store ptr %call9, ptr %arg, align 8
  %13 = load ptr, ptr %arg, align 8
  %name10 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %name10, align 8
  %call11 = call noalias ptr @zstrdup(ptr noundef %14)
  %15 = load ptr, ptr %realargs, align 8
  %16 = load i64, ptr %j, align 8
  %arrayidx = getelementptr inbounds %struct.redisCommandArg, ptr %15, i64 %16
  %name12 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx, i32 0, i32 0
  store ptr %call11, ptr %name12, align 8
  %17 = load ptr, ptr %arg, align 8
  %type = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %type, align 8
  %call13 = call i32 @moduleConvertArgType(i32 noundef %18, ptr noundef null)
  %19 = load ptr, ptr %realargs, align 8
  %20 = load i64, ptr %j, align 8
  %arrayidx14 = getelementptr inbounds %struct.redisCommandArg, ptr %19, i64 %20
  %type15 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx14, i32 0, i32 1
  store i32 %call13, ptr %type15, align 8
  %21 = load ptr, ptr %arg, align 8
  %type16 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %21, i32 0, i32 1
  %22 = load i32, ptr %type16, align 8
  %cmp17 = icmp eq i32 %22, 3
  br i1 %cmp17, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %23 = load ptr, ptr %arg, align 8
  %key_spec_index = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %23, i32 0, i32 2
  %24 = load i32, ptr %key_spec_index, align 4
  %25 = load ptr, ptr %realargs, align 8
  %26 = load i64, ptr %j, align 8
  %arrayidx19 = getelementptr inbounds %struct.redisCommandArg, ptr %25, i64 %26
  %key_spec_index20 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx19, i32 0, i32 2
  store i32 %24, ptr %key_spec_index20, align 4
  br label %if.end

if.else:                                          ; preds = %for.body
  %27 = load ptr, ptr %realargs, align 8
  %28 = load i64, ptr %j, align 8
  %arrayidx21 = getelementptr inbounds %struct.redisCommandArg, ptr %27, i64 %28
  %key_spec_index22 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx21, i32 0, i32 2
  store i32 -1, ptr %key_spec_index22, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %29 = load ptr, ptr %arg, align 8
  %token = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %29, i32 0, i32 3
  %30 = load ptr, ptr %token, align 8
  %tobool23 = icmp ne ptr %30, null
  br i1 %tobool23, label %if.then24, label %if.end29

if.then24:                                        ; preds = %if.end
  %31 = load ptr, ptr %arg, align 8
  %token25 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %31, i32 0, i32 3
  %32 = load ptr, ptr %token25, align 8
  %call26 = call noalias ptr @zstrdup(ptr noundef %32)
  %33 = load ptr, ptr %realargs, align 8
  %34 = load i64, ptr %j, align 8
  %arrayidx27 = getelementptr inbounds %struct.redisCommandArg, ptr %33, i64 %34
  %token28 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx27, i32 0, i32 3
  store ptr %call26, ptr %token28, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.then24, %if.end
  %35 = load ptr, ptr %arg, align 8
  %summary = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %35, i32 0, i32 4
  %36 = load ptr, ptr %summary, align 8
  %tobool30 = icmp ne ptr %36, null
  br i1 %tobool30, label %if.then31, label %if.end36

if.then31:                                        ; preds = %if.end29
  %37 = load ptr, ptr %arg, align 8
  %summary32 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %37, i32 0, i32 4
  %38 = load ptr, ptr %summary32, align 8
  %call33 = call noalias ptr @zstrdup(ptr noundef %38)
  %39 = load ptr, ptr %realargs, align 8
  %40 = load i64, ptr %j, align 8
  %arrayidx34 = getelementptr inbounds %struct.redisCommandArg, ptr %39, i64 %40
  %summary35 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx34, i32 0, i32 4
  store ptr %call33, ptr %summary35, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.then31, %if.end29
  %41 = load ptr, ptr %arg, align 8
  %since = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %41, i32 0, i32 5
  %42 = load ptr, ptr %since, align 8
  %tobool37 = icmp ne ptr %42, null
  br i1 %tobool37, label %if.then38, label %if.end43

if.then38:                                        ; preds = %if.end36
  %43 = load ptr, ptr %arg, align 8
  %since39 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %43, i32 0, i32 5
  %44 = load ptr, ptr %since39, align 8
  %call40 = call noalias ptr @zstrdup(ptr noundef %44)
  %45 = load ptr, ptr %realargs, align 8
  %46 = load i64, ptr %j, align 8
  %arrayidx41 = getelementptr inbounds %struct.redisCommandArg, ptr %45, i64 %46
  %since42 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx41, i32 0, i32 5
  store ptr %call40, ptr %since42, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.then38, %if.end36
  %47 = load ptr, ptr %arg, align 8
  %deprecated_since = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %47, i32 0, i32 7
  %48 = load ptr, ptr %deprecated_since, align 8
  %tobool44 = icmp ne ptr %48, null
  br i1 %tobool44, label %if.then45, label %if.end50

if.then45:                                        ; preds = %if.end43
  %49 = load ptr, ptr %arg, align 8
  %deprecated_since46 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %49, i32 0, i32 7
  %50 = load ptr, ptr %deprecated_since46, align 8
  %call47 = call noalias ptr @zstrdup(ptr noundef %50)
  %51 = load ptr, ptr %realargs, align 8
  %52 = load i64, ptr %j, align 8
  %arrayidx48 = getelementptr inbounds %struct.redisCommandArg, ptr %51, i64 %52
  %deprecated_since49 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx48, i32 0, i32 7
  store ptr %call47, ptr %deprecated_since49, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then45, %if.end43
  %53 = load ptr, ptr %arg, align 8
  %display_text = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %53, i32 0, i32 9
  %54 = load ptr, ptr %display_text, align 8
  %tobool51 = icmp ne ptr %54, null
  br i1 %tobool51, label %if.then52, label %if.end57

if.then52:                                        ; preds = %if.end50
  %55 = load ptr, ptr %arg, align 8
  %display_text53 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %55, i32 0, i32 9
  %56 = load ptr, ptr %display_text53, align 8
  %call54 = call noalias ptr @zstrdup(ptr noundef %56)
  %57 = load ptr, ptr %realargs, align 8
  %58 = load i64, ptr %j, align 8
  %arrayidx55 = getelementptr inbounds %struct.redisCommandArg, ptr %57, i64 %58
  %display_text56 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx55, i32 0, i32 10
  store ptr %call54, ptr %display_text56, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then52, %if.end50
  %59 = load ptr, ptr %arg, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %59, i32 0, i32 6
  %60 = load i32, ptr %flags, align 8
  %call58 = call i32 @moduleConvertArgFlags(i32 noundef %60)
  %61 = load ptr, ptr %realargs, align 8
  %62 = load i64, ptr %j, align 8
  %arrayidx59 = getelementptr inbounds %struct.redisCommandArg, ptr %61, i64 %62
  %flags60 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx59, i32 0, i32 6
  store i32 %call58, ptr %flags60, align 8
  %63 = load ptr, ptr %arg, align 8
  %subargs = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %63, i32 0, i32 8
  %64 = load ptr, ptr %subargs, align 8
  %tobool61 = icmp ne ptr %64, null
  br i1 %tobool61, label %if.then62, label %if.end67

if.then62:                                        ; preds = %if.end57
  %65 = load ptr, ptr %arg, align 8
  %subargs63 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %65, i32 0, i32 8
  %66 = load ptr, ptr %subargs63, align 8
  %67 = load ptr, ptr %version.addr, align 8
  %call64 = call ptr @moduleCopyCommandArgs(ptr noundef %66, ptr noundef %67)
  %68 = load ptr, ptr %realargs, align 8
  %69 = load i64, ptr %j, align 8
  %arrayidx65 = getelementptr inbounds %struct.redisCommandArg, ptr %68, i64 %69
  %subargs66 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx65, i32 0, i32 9
  store ptr %call64, ptr %subargs66, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then62, %if.end57
  br label %for.inc

for.inc:                                          ; preds = %if.end67
  %70 = load i64, ptr %j, align 8
  %inc68 = add i64 %70, 1
  store i64 %inc68, ptr %j, align 8
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %for.cond
  %71 = load ptr, ptr %realargs, align 8
  ret ptr %71
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleGetHandleByName(ptr noundef %modulename) #0 {
entry:
  %modulename.addr = alloca ptr, align 8
  store ptr %modulename, ptr %modulename.addr, align 8
  %0 = load ptr, ptr @modules, align 8
  %1 = load ptr, ptr %modulename.addr, align 8
  %call = call ptr @dictFetchValue(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

declare ptr @dictFetchValue(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleIsModuleCommand(ptr noundef %module_handle, ptr noundef %cmd) #0 {
entry:
  %retval = alloca i32, align 4
  %module_handle.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %cp = alloca ptr, align 8
  store ptr %module_handle, ptr %module_handle.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %proc, align 8
  %cmp = icmp ne ptr %1, @RedisModuleCommandDispatcher
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module_handle.addr, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %cmd.addr, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 32
  %4 = load ptr, ptr %module_cmd, align 8
  store ptr %4, ptr %cp, align 8
  %5 = load ptr, ptr %cp, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommand, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %module, align 8
  %7 = load ptr, ptr %module_handle.addr, align 8
  %cmp4 = icmp eq ptr %6, %7
  %conv = zext i1 %cmp4 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleListConfigMatch(ptr noundef %config, ptr noundef %name) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  store ptr %config, ptr %config.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %config.addr, align 8
  %name1 = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %name1, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %call = call i32 @strcasecmp(ptr noundef %1, ptr noundef %2) #14
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleListFree(ptr noundef %config) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %module_config = alloca ptr, align 8
  store ptr %config, ptr %config.addr, align 8
  %0 = load ptr, ptr %config.addr, align 8
  store ptr %0, ptr %module_config, align 8
  %1 = load ptr, ptr %module_config, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %name, align 8
  call void @sdsfree(ptr noundef %2)
  %3 = load ptr, ptr %config.addr, align 8
  call void @zfree(ptr noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SetModuleAttribs(ptr noundef %ctx, ptr noundef %name, i32 noundef %ver, i32 noundef %apiver) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %ver.addr = alloca i32, align 4
  %apiver.addr = alloca i32, align 4
  %module = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %ver, ptr %ver.addr, align 4
  store i32 %apiver, ptr %apiver.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module1, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call = call noalias ptr @zmalloc(i64 noundef 128) #11
  store ptr %call, ptr %module, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %call2 = call ptr @sdsnew(ptr noundef %2)
  %3 = load ptr, ptr %module, align 8
  %name3 = getelementptr inbounds %struct.RedisModule, ptr %3, i32 0, i32 1
  store ptr %call2, ptr %name3, align 8
  %4 = load i32, ptr %ver.addr, align 4
  %5 = load ptr, ptr %module, align 8
  %ver4 = getelementptr inbounds %struct.RedisModule, ptr %5, i32 0, i32 2
  store i32 %4, ptr %ver4, align 8
  %6 = load i32, ptr %apiver.addr, align 4
  %7 = load ptr, ptr %module, align 8
  %apiver5 = getelementptr inbounds %struct.RedisModule, ptr %7, i32 0, i32 3
  store i32 %6, ptr %apiver5, align 4
  %call6 = call ptr @listCreate()
  %8 = load ptr, ptr %module, align 8
  %types = getelementptr inbounds %struct.RedisModule, ptr %8, i32 0, i32 4
  store ptr %call6, ptr %types, align 8
  %call7 = call ptr @listCreate()
  %9 = load ptr, ptr %module, align 8
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %9, i32 0, i32 5
  store ptr %call7, ptr %usedby, align 8
  %call8 = call ptr @listCreate()
  %10 = load ptr, ptr %module, align 8
  %using = getelementptr inbounds %struct.RedisModule, ptr %10, i32 0, i32 6
  store ptr %call8, ptr %using, align 8
  %call9 = call ptr @listCreate()
  %11 = load ptr, ptr %module, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %11, i32 0, i32 7
  store ptr %call9, ptr %filters, align 8
  %call10 = call ptr @listCreate()
  %12 = load ptr, ptr %module, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %12, i32 0, i32 8
  store ptr %call10, ptr %module_configs, align 8
  %13 = load ptr, ptr %module, align 8
  %module_configs11 = getelementptr inbounds %struct.RedisModule, ptr %13, i32 0, i32 8
  %14 = load ptr, ptr %module_configs11, align 8
  %match = getelementptr inbounds %struct.list, ptr %14, i32 0, i32 4
  store ptr @moduleListConfigMatch, ptr %match, align 8
  %15 = load ptr, ptr %module, align 8
  %module_configs12 = getelementptr inbounds %struct.RedisModule, ptr %15, i32 0, i32 8
  %16 = load ptr, ptr %module_configs12, align 8
  %free = getelementptr inbounds %struct.list, ptr %16, i32 0, i32 3
  store ptr @moduleListFree, ptr %free, align 8
  %17 = load ptr, ptr %module, align 8
  %in_call = getelementptr inbounds %struct.RedisModule, ptr %17, i32 0, i32 10
  store i32 0, ptr %in_call, align 4
  %18 = load ptr, ptr %module, align 8
  %configs_initialized = getelementptr inbounds %struct.RedisModule, ptr %18, i32 0, i32 9
  store i32 0, ptr %configs_initialized, align 8
  %19 = load ptr, ptr %module, align 8
  %in_hook = getelementptr inbounds %struct.RedisModule, ptr %19, i32 0, i32 11
  store i32 0, ptr %in_hook, align 8
  %20 = load ptr, ptr %module, align 8
  %options = getelementptr inbounds %struct.RedisModule, ptr %20, i32 0, i32 12
  store i32 0, ptr %options, align 4
  %21 = load ptr, ptr %module, align 8
  %info_cb = getelementptr inbounds %struct.RedisModule, ptr %21, i32 0, i32 14
  store ptr null, ptr %info_cb, align 8
  %22 = load ptr, ptr %module, align 8
  %defrag_cb = getelementptr inbounds %struct.RedisModule, ptr %22, i32 0, i32 15
  store ptr null, ptr %defrag_cb, align 8
  %23 = load ptr, ptr %module, align 8
  %loadmod = getelementptr inbounds %struct.RedisModule, ptr %23, i32 0, i32 16
  store ptr null, ptr %loadmod, align 8
  %24 = load ptr, ptr %module, align 8
  %num_commands_with_acl_categories = getelementptr inbounds %struct.RedisModule, ptr %24, i32 0, i32 17
  store i32 0, ptr %num_commands_with_acl_categories, align 8
  %25 = load ptr, ptr %module, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %25, i32 0, i32 18
  store i32 1, ptr %onload, align 4
  %26 = load ptr, ptr %module, align 8
  %num_acl_categories_added = getelementptr inbounds %struct.RedisModule, ptr %26, i32 0, i32 19
  store i64 0, ptr %num_acl_categories_added, align 8
  %27 = load ptr, ptr %module, align 8
  %28 = load ptr, ptr %ctx.addr, align 8
  %module13 = getelementptr inbounds %struct.RedisModuleCtx, ptr %28, i32 0, i32 1
  store ptr %27, ptr %module13, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare ptr @listCreate() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_IsModuleNameBusy(ptr noundef %name) #0 {
entry:
  %name.addr = alloca ptr, align 8
  %modulename = alloca ptr, align 8
  %de = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %call = call ptr @sdsnew(ptr noundef %0)
  store ptr %call, ptr %modulename, align 8
  %1 = load ptr, ptr @modules, align 8
  %2 = load ptr, ptr %modulename, align 8
  %call1 = call ptr @dictFind(ptr noundef %1, ptr noundef %2)
  store ptr %call1, ptr %de, align 8
  %3 = load ptr, ptr %modulename, align 8
  call void @sdsfree(ptr noundef %3)
  %4 = load ptr, ptr %de, align 8
  %cmp = icmp ne ptr %4, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_Milliseconds() #0 {
entry:
  %call = call i64 @mstime()
  ret i64 %call
}

declare i64 @mstime() #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MonotonicMicroseconds() #0 {
entry:
  %0 = load ptr, ptr @getMonotonicUs, align 8
  %call = call i64 %0()
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_Microseconds() #0 {
entry:
  %call = call i64 @ustime()
  ret i64 %call
}

declare i64 @ustime() #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_CachedMicroseconds() #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 353), align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_BlockedClientMeasureTimeStart(ptr noundef %bc) #0 {
entry:
  %bc.addr = alloca ptr, align 8
  store ptr %bc, ptr %bc.addr, align 8
  %0 = load ptr, ptr %bc.addr, align 8
  %background_timer = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i32 0, i32 13
  call void @elapsedStart(ptr noundef %background_timer)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @elapsedStart(ptr noundef %start_time) #0 {
entry:
  %start_time.addr = alloca ptr, align 8
  store ptr %start_time, ptr %start_time.addr, align 8
  %0 = load ptr, ptr @getMonotonicUs, align 8
  %call = call i64 %0()
  %1 = load ptr, ptr %start_time.addr, align 8
  store i64 %call, ptr %1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_BlockedClientMeasureTimeEnd(ptr noundef %bc) #0 {
entry:
  %retval = alloca i32, align 4
  %bc.addr = alloca ptr, align 8
  store ptr %bc, ptr %bc.addr, align 8
  %0 = load ptr, ptr %bc.addr, align 8
  %background_timer = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i32 0, i32 13
  %1 = load i64, ptr %background_timer, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %bc.addr, align 8
  %background_timer1 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %2, i32 0, i32 13
  %3 = load i64, ptr %background_timer1, align 8
  %call = call i64 @elapsedUs(i64 noundef %3)
  %4 = load ptr, ptr %bc.addr, align 8
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %4, i32 0, i32 14
  %5 = load i64, ptr %background_duration, align 8
  %add = add i64 %5, %call
  store i64 %add, ptr %background_duration, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i64 @elapsedUs(i64 noundef %start_time) #0 {
entry:
  %start_time.addr = alloca i64, align 8
  store i64 %start_time, ptr %start_time.addr, align 8
  %0 = load ptr, ptr @getMonotonicUs, align 8
  %call = call i64 %0()
  %1 = load i64, ptr %start_time.addr, align 8
  %sub = sub i64 %call, %1
  ret i64 %sub
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_Yield(ptr noundef %ctx, i32 noundef %flags, ptr noundef %busy_reply) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %busy_reply.addr = alloca ptr, align 8
  %now = alloca i64, align 8
  %prev_busy_module_yield_reply = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %busy_reply, ptr %busy_reply.addr, align 8
  %0 = load i32, ptr @RM_Yield.yield_nesting, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr @RM_Yield.yield_nesting, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, ptr @RM_Yield.yield_nesting, align 4
  %2 = load ptr, ptr @getMonotonicUs, align 8
  %call = call i64 %2()
  store i64 %call, ptr %now, align 8
  %3 = load i64, ptr %now, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %next_yield_time = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 14
  %5 = load i64, ptr %next_yield_time, align 8
  %cmp = icmp sge i64 %3, %5
  br i1 %cmp, label %if.then1, label %if.end16

if.then1:                                         ; preds = %if.end
  %6 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool2 = icmp ne i32 %6, 0
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then1
  call void @processEventsWhileBlocked()
  br label %if.end14

if.else:                                          ; preds = %if.then1
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 32), align 8
  store ptr %7, ptr %prev_busy_module_yield_reply, align 8
  %8 = load ptr, ptr %busy_reply.addr, align 8
  store ptr %8, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 32), align 8
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.end9, label %if.then5

if.then5:                                         ; preds = %if.else
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  call void @blockingOperationStarts()
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %tobool6 = icmp ne ptr %10, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then5
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  call void @protectClient(ptr noundef %11)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then5
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.else
  %12 = load i32, ptr %flags.addr, align 4
  %and = and i32 %12, 2
  %tobool10 = icmp ne i32 %and, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %or = or i32 %13, 2
  store i32 %or, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end9
  call void @processEventsWhileBlocked()
  %14 = load ptr, ptr %prev_busy_module_yield_reply, align 8
  store ptr %14, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 32), align 8
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %and13 = and i32 %15, -3
  store i32 %and13, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end12, %if.then3
  %16 = load i64, ptr %now, align 8
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div = sdiv i32 1000000, %17
  %conv = sext i32 %div to i64
  %add = add nsw i64 %16, %conv
  %18 = load ptr, ptr %ctx.addr, align 8
  %next_yield_time15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %18, i32 0, i32 14
  store i64 %add, ptr %next_yield_time15, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.end14, %if.end
  %19 = load i32, ptr @RM_Yield.yield_nesting, align 4
  %dec = add nsw i32 %19, -1
  store i32 %dec, ptr @RM_Yield.yield_nesting, align 4
  br label %return

return:                                           ; preds = %if.end16, %if.then
  ret void
}

declare void @processEventsWhileBlocked() #1

declare void @blockingOperationStarts() #1

declare void @protectClient(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SetModuleOptions(ptr noundef %ctx, i32 noundef %options) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %options.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %options, ptr %options.addr, align 4
  %0 = load i32, ptr %options.addr, align 4
  %1 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %options1 = getelementptr inbounds %struct.RedisModule, ptr %2, i32 0, i32 12
  store i32 %0, ptr %options1, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SignalModifiedKey(ptr noundef %ctx, ptr noundef %keyname) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %keyname.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %keyname, ptr %keyname.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %client1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %client1, align 8
  %db = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %db, align 8
  %5 = load ptr, ptr %keyname.addr, align 8
  call void @signalModifiedKey(ptr noundef %1, ptr noundef %4, ptr noundef %5)
  ret i32 0
}

declare void @signalModifiedKey(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_AutoMemory(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %or = or i32 %1, 1
  store i32 %or, ptr %flags, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @autoMemoryAdd(ptr noundef %ctx, i32 noundef %type, ptr noundef %ptr) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %ptr.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %amqueue_used, align 4
  %4 = load ptr, ptr %ctx.addr, align 8
  %amqueue_len = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 5
  %5 = load i32, ptr %amqueue_len, align 8
  %cmp = icmp eq i32 %3, %5
  br i1 %cmp, label %if.then1, label %if.end11

if.then1:                                         ; preds = %if.end
  %6 = load ptr, ptr %ctx.addr, align 8
  %amqueue_len2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %amqueue_len2, align 8
  %mul = mul nsw i32 %7, 2
  store i32 %mul, ptr %amqueue_len2, align 8
  %8 = load ptr, ptr %ctx.addr, align 8
  %amqueue_len3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 5
  %9 = load i32, ptr %amqueue_len3, align 8
  %cmp4 = icmp slt i32 %9, 16
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.then1
  %10 = load ptr, ptr %ctx.addr, align 8
  %amqueue_len6 = getelementptr inbounds %struct.RedisModuleCtx, ptr %10, i32 0, i32 5
  store i32 16, ptr %amqueue_len6, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.then1
  %11 = load ptr, ptr %ctx.addr, align 8
  %amqueue = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i32 0, i32 4
  %12 = load ptr, ptr %amqueue, align 8
  %13 = load ptr, ptr %ctx.addr, align 8
  %amqueue_len8 = getelementptr inbounds %struct.RedisModuleCtx, ptr %13, i32 0, i32 5
  %14 = load i32, ptr %amqueue_len8, align 8
  %conv = sext i32 %14 to i64
  %mul9 = mul i64 16, %conv
  %call = call ptr @zrealloc(ptr noundef %12, i64 noundef %mul9) #12
  %15 = load ptr, ptr %ctx.addr, align 8
  %amqueue10 = getelementptr inbounds %struct.RedisModuleCtx, ptr %15, i32 0, i32 4
  store ptr %call, ptr %amqueue10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.end7, %if.end
  %16 = load i32, ptr %type.addr, align 4
  %17 = load ptr, ptr %ctx.addr, align 8
  %amqueue12 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %amqueue12, align 8
  %19 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used13 = getelementptr inbounds %struct.RedisModuleCtx, ptr %19, i32 0, i32 6
  %20 = load i32, ptr %amqueue_used13, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr inbounds %struct.AutoMemEntry, ptr %18, i64 %idxprom
  %type14 = getelementptr inbounds %struct.AutoMemEntry, ptr %arrayidx, i32 0, i32 1
  store i32 %16, ptr %type14, align 8
  %21 = load ptr, ptr %ptr.addr, align 8
  %22 = load ptr, ptr %ctx.addr, align 8
  %amqueue15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %amqueue15, align 8
  %24 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used16 = getelementptr inbounds %struct.RedisModuleCtx, ptr %24, i32 0, i32 6
  %25 = load i32, ptr %amqueue_used16, align 4
  %idxprom17 = sext i32 %25 to i64
  %arrayidx18 = getelementptr inbounds %struct.AutoMemEntry, ptr %23, i64 %idxprom17
  %ptr19 = getelementptr inbounds %struct.AutoMemEntry, ptr %arrayidx18, i32 0, i32 0
  store ptr %21, ptr %ptr19, align 8
  %26 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used20 = getelementptr inbounds %struct.RedisModuleCtx, ptr %26, i32 0, i32 6
  %27 = load i32, ptr %amqueue_used20, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, ptr %amqueue_used20, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @autoMemoryFreed(ptr noundef %ctx, i32 noundef %type, ptr noundef %ptr) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %ptr.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  %j = alloca i32, align 4
  %side = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %amqueue_used, align 4
  %add = add nsw i32 %3, 1
  %div = sdiv i32 %add, 2
  store i32 %div, ptr %count, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc34, %if.end
  %4 = load i32, ptr %j, align 4
  %5 = load i32, ptr %count, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %for.body, label %for.end36

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %side, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %6 = load i32, ptr %side, align 4
  %cmp2 = icmp slt i32 %6, 2
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %7 = load i32, ptr %side, align 4
  %cmp4 = icmp eq i32 %7, 0
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body3
  %8 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used5 = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 6
  %9 = load i32, ptr %amqueue_used5, align 4
  %sub = sub nsw i32 %9, 1
  %10 = load i32, ptr %j, align 4
  %sub6 = sub nsw i32 %sub, %10
  br label %cond.end

cond.false:                                       ; preds = %for.body3
  %11 = load i32, ptr %j, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub6, %cond.true ], [ %11, %cond.false ]
  store i32 %cond, ptr %i, align 4
  %12 = load ptr, ptr %ctx.addr, align 8
  %amqueue = getelementptr inbounds %struct.RedisModuleCtx, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %amqueue, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom = sext i32 %14 to i64
  %arrayidx = getelementptr inbounds %struct.AutoMemEntry, ptr %13, i64 %idxprom
  %type7 = getelementptr inbounds %struct.AutoMemEntry, ptr %arrayidx, i32 0, i32 1
  %15 = load i32, ptr %type7, align 8
  %16 = load i32, ptr %type.addr, align 4
  %cmp8 = icmp eq i32 %15, %16
  br i1 %cmp8, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %cond.end
  %17 = load ptr, ptr %ctx.addr, align 8
  %amqueue9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %amqueue9, align 8
  %19 = load i32, ptr %i, align 4
  %idxprom10 = sext i32 %19 to i64
  %arrayidx11 = getelementptr inbounds %struct.AutoMemEntry, ptr %18, i64 %idxprom10
  %ptr12 = getelementptr inbounds %struct.AutoMemEntry, ptr %arrayidx11, i32 0, i32 0
  %20 = load ptr, ptr %ptr12, align 8
  %21 = load ptr, ptr %ptr.addr, align 8
  %cmp13 = icmp eq ptr %20, %21
  br i1 %cmp13, label %if.then14, label %if.end33

if.then14:                                        ; preds = %land.lhs.true
  %22 = load ptr, ptr %ctx.addr, align 8
  %amqueue15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %amqueue15, align 8
  %24 = load i32, ptr %i, align 4
  %idxprom16 = sext i32 %24 to i64
  %arrayidx17 = getelementptr inbounds %struct.AutoMemEntry, ptr %23, i64 %idxprom16
  %type18 = getelementptr inbounds %struct.AutoMemEntry, ptr %arrayidx17, i32 0, i32 1
  store i32 3, ptr %type18, align 8
  %25 = load i32, ptr %i, align 4
  %26 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used19 = getelementptr inbounds %struct.RedisModuleCtx, ptr %26, i32 0, i32 6
  %27 = load i32, ptr %amqueue_used19, align 4
  %sub20 = sub nsw i32 %27, 1
  %cmp21 = icmp ne i32 %25, %sub20
  br i1 %cmp21, label %if.then22, label %if.end31

if.then22:                                        ; preds = %if.then14
  %28 = load ptr, ptr %ctx.addr, align 8
  %amqueue23 = getelementptr inbounds %struct.RedisModuleCtx, ptr %28, i32 0, i32 4
  %29 = load ptr, ptr %amqueue23, align 8
  %30 = load i32, ptr %i, align 4
  %idxprom24 = sext i32 %30 to i64
  %arrayidx25 = getelementptr inbounds %struct.AutoMemEntry, ptr %29, i64 %idxprom24
  %31 = load ptr, ptr %ctx.addr, align 8
  %amqueue26 = getelementptr inbounds %struct.RedisModuleCtx, ptr %31, i32 0, i32 4
  %32 = load ptr, ptr %amqueue26, align 8
  %33 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used27 = getelementptr inbounds %struct.RedisModuleCtx, ptr %33, i32 0, i32 6
  %34 = load i32, ptr %amqueue_used27, align 4
  %sub28 = sub nsw i32 %34, 1
  %idxprom29 = sext i32 %sub28 to i64
  %arrayidx30 = getelementptr inbounds %struct.AutoMemEntry, ptr %32, i64 %idxprom29
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx25, ptr align 8 %arrayidx30, i64 16, i1 false)
  br label %if.end31

if.end31:                                         ; preds = %if.then22, %if.then14
  %35 = load ptr, ptr %ctx.addr, align 8
  %amqueue_used32 = getelementptr inbounds %struct.RedisModuleCtx, ptr %35, i32 0, i32 6
  %36 = load i32, ptr %amqueue_used32, align 4
  %dec = add nsw i32 %36, -1
  store i32 %dec, ptr %amqueue_used32, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %land.lhs.true, %cond.end
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %37 = load i32, ptr %side, align 4
  %inc = add nsw i32 %37, 1
  store i32 %inc, ptr %side, align 4
  br label %for.cond1, !llvm.loop !25

for.end:                                          ; preds = %for.cond1
  br label %for.inc34

for.inc34:                                        ; preds = %for.end
  %38 = load i32, ptr %j, align 4
  %inc35 = add nsw i32 %38, 1
  store i32 %inc35, ptr %j, align 4
  br label %for.cond, !llvm.loop !26

for.end36:                                        ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end36, %if.end31, %if.then
  %39 = load i32, ptr %retval, align 4
  ret i32 %39
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #8

declare void @decrRefCount(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeCallReply(ptr noundef %reply) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %promise = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store ptr null, ptr %ctx, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call i32 @callReplyType(ptr noundef %0)
  %cmp = icmp eq i32 %call, 12
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %reply.addr, align 8
  %call1 = call ptr @callReplyGetPrivateData(ptr noundef %1)
  store ptr %call1, ptr %promise, align 8
  %2 = load ptr, ptr %promise, align 8
  %ctx2 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %2, i32 0, i32 5
  %3 = load ptr, ptr %ctx2, align 8
  store ptr %3, ptr %ctx, align 8
  %4 = load ptr, ptr %promise, align 8
  call void @freeRedisModuleAsyncRMCallPromise(ptr noundef %4)
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %reply.addr, align 8
  %call3 = call ptr @callReplyGetPrivateData(ptr noundef %5)
  store ptr %call3, ptr %ctx, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load ptr, ptr %reply.addr, align 8
  call void @freeCallReply(ptr noundef %6)
  %7 = load ptr, ptr %ctx, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %8 = load ptr, ptr %ctx, align 8
  %9 = load ptr, ptr %reply.addr, align 8
  %call5 = call i32 @autoMemoryFreed(ptr noundef %8, i32 noundef 2, ptr noundef %9)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_CloseKey(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  call void @moduleCloseKey(ptr noundef %1)
  %2 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %ctx, align 8
  %4 = load ptr, ptr %key.addr, align 8
  %call = call i32 @autoMemoryFreed(ptr noundef %3, i32 noundef 0, ptr noundef %4)
  %5 = load ptr, ptr %key.addr, align 8
  call void @zfree(ptr noundef %5)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeDict(ptr noundef %ctx, ptr noundef %d) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %d.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %2 = load ptr, ptr %d.addr, align 8
  %call = call i32 @autoMemoryFreed(ptr noundef %1, i32 noundef 4, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %d.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %rax, align 8
  call void @raxFree(ptr noundef %4)
  %5 = load ptr, ptr %d.addr, align 8
  call void @zfree(ptr noundef %5)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeServerInfo(ptr noundef %ctx, ptr noundef %data) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %2 = load ptr, ptr %data.addr, align 8
  %call = call i32 @autoMemoryFreed(ptr noundef %1, i32 noundef 5, ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %data.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleServerInfoData, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %rax, align 8
  call void @raxFreeWithCallback(ptr noundef %4, ptr noundef @sdsfree)
  %5 = load ptr, ptr %data.addr, align 8
  call void @zfree(ptr noundef %5)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateString(ptr noundef %ctx, ptr noundef %ptr, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %o = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %call = call ptr @createStringObject(ptr noundef %0, i64 noundef %1)
  store ptr %call, ptr %o, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load ptr, ptr %o, align 8
  call void @autoMemoryAdd(ptr noundef %3, i32 noundef 1, ptr noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %o, align 8
  ret ptr %5
}

declare ptr @createStringObject(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringPrintf(ptr noundef %ctx, ptr noundef %fmt, ...) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %o = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  %call = call ptr @sdsempty()
  store ptr %call, ptr %s, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %s, align 8
  %1 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call2 = call ptr @sdscatvprintf(ptr noundef %0, ptr noundef %1, ptr noundef %arraydecay1)
  store ptr %call2, ptr %s, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay3)
  %2 = load ptr, ptr %s, align 8
  %call4 = call ptr @createObject(i32 noundef 0, ptr noundef %2)
  store ptr %call4, ptr %o, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %ctx.addr, align 8
  %5 = load ptr, ptr %o, align 8
  call void @autoMemoryAdd(ptr noundef %4, i32 noundef 1, ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %o, align 8
  ret ptr %6
}

declare ptr @sdsempty() #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #9

declare ptr @sdscatvprintf(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #9

declare ptr @createObject(i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromLongLong(ptr noundef %ctx, i64 noundef %ll) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ll.addr = alloca i64, align 8
  %buf = alloca [21 x i8], align 16
  %len = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %ll, ptr %ll.addr, align 8
  %arraydecay = getelementptr inbounds [21 x i8], ptr %buf, i64 0, i64 0
  %0 = load i64, ptr %ll.addr, align 8
  %call = call i32 @ll2string(ptr noundef %arraydecay, i64 noundef 21, i64 noundef %0)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %len, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %arraydecay1 = getelementptr inbounds [21 x i8], ptr %buf, i64 0, i64 0
  %2 = load i64, ptr %len, align 8
  %call2 = call ptr @RM_CreateString(ptr noundef %1, ptr noundef %arraydecay1, i64 noundef %2)
  ret ptr %call2
}

declare i32 @ll2string(ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromULongLong(ptr noundef %ctx, i64 noundef %ull) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ull.addr = alloca i64, align 8
  %buf = alloca [21 x i8], align 16
  %len = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %ull, ptr %ull.addr, align 8
  %arraydecay = getelementptr inbounds [21 x i8], ptr %buf, i64 0, i64 0
  %0 = load i64, ptr %ull.addr, align 8
  %call = call i32 @ull2string(ptr noundef %arraydecay, i64 noundef 21, i64 noundef %0)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %len, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %arraydecay1 = getelementptr inbounds [21 x i8], ptr %buf, i64 0, i64 0
  %2 = load i64, ptr %len, align 8
  %call2 = call ptr @RM_CreateString(ptr noundef %1, ptr noundef %arraydecay1, i64 noundef %2)
  ret ptr %call2
}

declare i32 @ull2string(ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromDouble(ptr noundef %ctx, double noundef %d) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %d.addr = alloca double, align 8
  %buf = alloca [128 x i8], align 16
  %len = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store double %d, ptr %d.addr, align 8
  %arraydecay = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %0 = load double, ptr %d.addr, align 8
  %call = call i32 @d2string(ptr noundef %arraydecay, i64 noundef 128, double noundef %0)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %len, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %arraydecay1 = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %2 = load i64, ptr %len, align 8
  %call2 = call ptr @RM_CreateString(ptr noundef %1, ptr noundef %arraydecay1, i64 noundef %2)
  ret ptr %call2
}

declare i32 @d2string(ptr noundef, i64 noundef, double noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromLongDouble(ptr noundef %ctx, x86_fp80 noundef %ld, i32 noundef %humanfriendly) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ld.addr = alloca x86_fp80, align 16
  %humanfriendly.addr = alloca i32, align 4
  %buf = alloca [5120 x i8], align 16
  %len = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store x86_fp80 %ld, ptr %ld.addr, align 16
  store i32 %humanfriendly, ptr %humanfriendly.addr, align 4
  %arraydecay = getelementptr inbounds [5120 x i8], ptr %buf, i64 0, i64 0
  %0 = load x86_fp80, ptr %ld.addr, align 16
  %1 = load i32, ptr %humanfriendly.addr, align 4
  %tobool = icmp ne i32 %1, 0
  %cond = select i1 %tobool, i32 1, i32 0
  %call = call i32 @ld2string(ptr noundef %arraydecay, i64 noundef 5120, x86_fp80 noundef %0, i32 noundef %cond)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %len, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %arraydecay1 = getelementptr inbounds [5120 x i8], ptr %buf, i64 0, i64 0
  %3 = load i64, ptr %len, align 8
  %call2 = call ptr @RM_CreateString(ptr noundef %2, ptr noundef %arraydecay1, i64 noundef %3)
  ret ptr %call2
}

declare i32 @ld2string(ptr noundef, i64 noundef, x86_fp80 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %o = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call ptr @dupStringObject(ptr noundef %0)
  store ptr %call, ptr %o, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %o, align 8
  call void @autoMemoryAdd(ptr noundef %2, i32 noundef 1, ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %o, align 8
  ret ptr %4
}

declare ptr @dupStringObject(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromStreamID(ptr noundef %ctx, ptr noundef %id) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %id.addr = alloca ptr, align 8
  %streamid = alloca %struct.streamID, align 8
  %o = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %id, ptr %id.addr, align 8
  %ms = getelementptr inbounds %struct.streamID, ptr %streamid, i32 0, i32 0
  %0 = load ptr, ptr %id.addr, align 8
  %ms1 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %ms1, align 8
  store i64 %1, ptr %ms, align 8
  %seq = getelementptr inbounds %struct.streamID, ptr %streamid, i32 0, i32 1
  %2 = load ptr, ptr %id.addr, align 8
  %seq2 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %seq2, align 8
  store i64 %3, ptr %seq, align 8
  %call = call ptr @createObjectFromStreamID(ptr noundef %streamid)
  store ptr %call, ptr %o, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %ctx.addr, align 8
  %6 = load ptr, ptr %o, align 8
  call void @autoMemoryAdd(ptr noundef %5, i32 noundef 1, ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %o, align 8
  ret ptr %7
}

declare ptr @createObjectFromStreamID(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  call void @decrRefCount(ptr noundef %0)
  %1 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %str.addr, align 8
  %call = call i32 @autoMemoryFreed(ptr noundef %2, i32 noundef 1, ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_RetainString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %2 = load ptr, ptr %str.addr, align 8
  %call = call i32 @autoMemoryFreed(ptr noundef %1, i32 noundef 1, ptr noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load ptr, ptr %str.addr, align 8
  call void @incrRefCount(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  ret void
}

declare void @incrRefCount(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_HoldString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %refcount = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %refcount, align 4
  %cmp = icmp eq i32 %1, 2147483646
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %str.addr, align 8
  %call = call ptr @RM_CreateStringFromString(ptr noundef %2, ptr noundef %3)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %str.addr, align 8
  call void @incrRefCount(ptr noundef %4)
  %5 = load ptr, ptr %ctx.addr, align 8
  %cmp1 = icmp ne ptr %5, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %6 = load ptr, ptr %ctx.addr, align 8
  %7 = load ptr, ptr %str.addr, align 8
  call void @autoMemoryAdd(ptr noundef %6, i32 noundef 1, ptr noundef %7)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %8 = load ptr, ptr %str.addr, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_StringPtrLen(ptr noundef %str, ptr noundef %len) #0 {
entry:
  %retval = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %errmsg = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end2

if.then:                                          ; preds = %entry
  store ptr @.str.32, ptr %errmsg, align 8
  %1 = load ptr, ptr %len.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %2 = load ptr, ptr %errmsg, align 8
  %call = call i64 @strlen(ptr noundef %2) #14
  %3 = load ptr, ptr %len.addr, align 8
  store i64 %call, ptr %3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %4 = load ptr, ptr %errmsg, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %entry
  %5 = load ptr, ptr %len.addr, align 8
  %tobool3 = icmp ne ptr %5, null
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end2
  %6 = load ptr, ptr %str.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %ptr, align 8
  %call5 = call i64 @sdslen(ptr noundef %7)
  %8 = load ptr, ptr %len.addr, align 8
  store i64 %call5, ptr %8, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end2
  %9 = load ptr, ptr %str.addr, align 8
  %ptr7 = getelementptr inbounds %struct.redisObject, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %ptr7, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.end
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define internal i64 @sdslen(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %flags = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %flags, align 1
  %2 = load i8, ptr %flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %3 = load i8, ptr %flags, align 1
  %conv1 = zext i8 %3 to i32
  %shr = ashr i32 %conv1, 3
  %conv2 = sext i32 %shr to i64
  store i64 %conv2, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 -3
  %len = getelementptr inbounds %struct.sdshdr8, ptr %add.ptr, i32 0, i32 0
  %5 = load i8, ptr %len, align 1
  %conv4 = zext i8 %5 to i64
  store i64 %conv4, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  %6 = load ptr, ptr %s.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, ptr %6, i64 -5
  %len7 = getelementptr inbounds %struct.sdshdr16, ptr %add.ptr6, i32 0, i32 0
  %7 = load i16, ptr %len7, align 1
  %conv8 = zext i16 %7 to i64
  store i64 %conv8, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, ptr %8, i64 -9
  %len11 = getelementptr inbounds %struct.sdshdr32, ptr %add.ptr10, i32 0, i32 0
  %9 = load i32, ptr %len11, align 1
  %conv12 = zext i32 %9 to i64
  store i64 %conv12, ptr %retval, align 8
  br label %return

sw.bb13:                                          ; preds = %entry
  %10 = load ptr, ptr %s.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, ptr %10, i64 -17
  %len15 = getelementptr inbounds %struct.sdshdr64, ptr %add.ptr14, i32 0, i32 0
  %11 = load i64, ptr %len15, align 1
  store i64 %11, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToLongLong(ptr noundef %str, ptr noundef %ll) #0 {
entry:
  %str.addr = alloca ptr, align 8
  %ll.addr = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  store ptr %ll, ptr %ll.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %2 = load ptr, ptr %str.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr1, align 8
  %call = call i64 @sdslen(ptr noundef %3)
  %4 = load ptr, ptr %ll.addr, align 8
  %call2 = call i32 @string2ll(ptr noundef %1, i64 noundef %call, ptr noundef %4)
  %tobool = icmp ne i32 %call2, 0
  %cond = select i1 %tobool, i32 0, i32 1
  ret i32 %cond
}

declare i32 @string2ll(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToULongLong(ptr noundef %str, ptr noundef %ull) #0 {
entry:
  %str.addr = alloca ptr, align 8
  %ull.addr = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  store ptr %ull, ptr %ull.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %2 = load ptr, ptr %ull.addr, align 8
  %call = call i32 @string2ull(ptr noundef %1, ptr noundef %2)
  %tobool = icmp ne i32 %call, 0
  %cond = select i1 %tobool, i32 0, i32 1
  ret i32 %cond
}

declare i32 @string2ull(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToDouble(ptr noundef %str, ptr noundef %d) #0 {
entry:
  %str.addr = alloca ptr, align 8
  %d.addr = alloca ptr, align 8
  %retval1 = alloca i32, align 4
  store ptr %str, ptr %str.addr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %1 = load ptr, ptr %d.addr, align 8
  %call = call i32 @getDoubleFromObject(ptr noundef %0, ptr noundef %1)
  store i32 %call, ptr %retval1, align 4
  %2 = load i32, ptr %retval1, align 4
  %cmp = icmp eq i32 %2, 0
  %cond = select i1 %cmp, i32 0, i32 1
  ret i32 %cond
}

declare i32 @getDoubleFromObject(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToLongDouble(ptr noundef %str, ptr noundef %ld) #0 {
entry:
  %str.addr = alloca ptr, align 8
  %ld.addr = alloca ptr, align 8
  %retval1 = alloca i32, align 4
  store ptr %str, ptr %str.addr, align 8
  store ptr %ld, ptr %ld.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %2 = load ptr, ptr %str.addr, align 8
  %ptr2 = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr2, align 8
  %call = call i64 @sdslen(ptr noundef %3)
  %4 = load ptr, ptr %ld.addr, align 8
  %call3 = call i32 @string2ld(ptr noundef %1, i64 noundef %call, ptr noundef %4)
  store i32 %call3, ptr %retval1, align 4
  %5 = load i32, ptr %retval1, align 4
  %tobool = icmp ne i32 %5, 0
  %cond = select i1 %tobool, i32 0, i32 1
  ret i32 %cond
}

declare i32 @string2ld(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringToStreamID(ptr noundef %str, ptr noundef %id) #0 {
entry:
  %retval = alloca i32, align 4
  %str.addr = alloca ptr, align 8
  %id.addr = alloca ptr, align 8
  %streamid = alloca %struct.streamID, align 8
  store ptr %str, ptr %str.addr, align 8
  store ptr %id, ptr %id.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call i32 @streamParseID(ptr noundef %0, ptr noundef %streamid)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %ms = getelementptr inbounds %struct.streamID, ptr %streamid, i32 0, i32 0
  %1 = load i64, ptr %ms, align 8
  %2 = load ptr, ptr %id.addr, align 8
  %ms1 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %2, i32 0, i32 0
  store i64 %1, ptr %ms1, align 8
  %seq = getelementptr inbounds %struct.streamID, ptr %streamid, i32 0, i32 1
  %3 = load i64, ptr %seq, align 8
  %4 = load ptr, ptr %id.addr, align 8
  %seq2 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %4, i32 0, i32 1
  store i64 %3, ptr %seq2, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

declare i32 @streamParseID(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringCompare(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call i32 @compareStringObjects(ptr noundef %0, ptr noundef %1)
  ret i32 %call
}

declare i32 @compareStringObjects(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleAssertUnsharedString(ptr noundef %str) #0 {
entry:
  %retval = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %refcount = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %refcount, align 4
  %cmp = icmp ne i32 %1, 1
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 3, %2
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.33)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %entry
  %3 = load ptr, ptr %str.addr, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  %cmp4 = icmp eq i32 %bf.clear, 8
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end3
  %4 = load ptr, ptr %str.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %ptr, align 8
  %6 = load ptr, ptr %str.addr, align 8
  %ptr6 = getelementptr inbounds %struct.redisObject, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %ptr6, align 8
  %call = call i64 @sdslen(ptr noundef %7)
  %call7 = call ptr @sdsnewlen(ptr noundef %5, i64 noundef %call)
  %8 = load ptr, ptr %str.addr, align 8
  %ptr8 = getelementptr inbounds %struct.redisObject, ptr %8, i32 0, i32 2
  store ptr %call7, ptr %ptr8, align 8
  %9 = load ptr, ptr %str.addr, align 8
  %bf.load9 = load i32, ptr %9, align 8
  %bf.clear10 = and i32 %bf.load9, -241
  %bf.set = or i32 %bf.clear10, 0
  store i32 %bf.set, ptr %9, align 8
  br label %if.end23

if.else:                                          ; preds = %if.end3
  %10 = load ptr, ptr %str.addr, align 8
  %bf.load11 = load i32, ptr %10, align 8
  %bf.lshr12 = lshr i32 %bf.load11, 4
  %bf.clear13 = and i32 %bf.lshr12, 15
  %cmp14 = icmp eq i32 %bf.clear13, 1
  br i1 %cmp14, label %if.then15, label %if.end22

if.then15:                                        ; preds = %if.else
  %11 = load ptr, ptr %str.addr, align 8
  %ptr16 = getelementptr inbounds %struct.redisObject, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %ptr16, align 8
  %13 = ptrtoint ptr %12 to i64
  %call17 = call ptr @sdsfromlonglong(i64 noundef %13)
  %14 = load ptr, ptr %str.addr, align 8
  %ptr18 = getelementptr inbounds %struct.redisObject, ptr %14, i32 0, i32 2
  store ptr %call17, ptr %ptr18, align 8
  %15 = load ptr, ptr %str.addr, align 8
  %bf.load19 = load i32, ptr %15, align 8
  %bf.clear20 = and i32 %bf.load19, -241
  %bf.set21 = or i32 %bf.clear20, 0
  store i32 %bf.set21, ptr %15, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.then15, %if.else
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then5
  %16 = load ptr, ptr %str.addr, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end23, %do.end
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

declare ptr @sdsnewlen(ptr noundef, i64 noundef) #1

declare ptr @sdsfromlonglong(i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringAppendBuffer(ptr noundef %ctx, ptr noundef %str, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call ptr @moduleAssertUnsharedString(ptr noundef %0)
  store ptr %call, ptr %str.addr, align 8
  %1 = load ptr, ptr %str.addr, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %str.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %4 = load ptr, ptr %buf.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %call1 = call ptr @sdscatlen(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  %6 = load ptr, ptr %str.addr, align 8
  %ptr2 = getelementptr inbounds %struct.redisObject, ptr %6, i32 0, i32 2
  store ptr %call1, ptr %ptr2, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare ptr @sdscatlen(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_TrimStringAllocation(ptr noundef %str) #0 {
entry:
  %str.addr = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %str.addr, align 8
  call void @trimStringObjectIfNeeded(ptr noundef %1, i32 noundef 1)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_WrongArity(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  call void @addReplyErrorArity(ptr noundef %1)
  ret i32 0
}

declare void @addReplyErrorArity(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleGetReplyClient(ptr noundef %ctx) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else4

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %blocked_client, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %4 = load ptr, ptr %ctx.addr, align 8
  %blocked_client3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %blocked_client3, align 8
  %reply_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %5, i32 0, i32 9
  %6 = load ptr, ptr %reply_client, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.else4:                                         ; preds = %entry
  %7 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %client, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else4, %if.else, %if.then2
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithLongLong(ptr noundef %ctx, i64 noundef %ll) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %ll.addr = alloca i64, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %ll, ptr %ll.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load i64, ptr %ll.addr, align 8
  call void @addReplyLongLong(ptr noundef %2, i64 noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare void @addReplyLongLong(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithError(ptr noundef %ctx, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load ptr, ptr %err.addr, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %2, ptr noundef @.str.34, ptr noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare void @addReplyErrorFormat(ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithErrorFormat(ptr noundef %ctx, ptr noundef %fmt, ...) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %len = alloca i32, align 4
  %hyphenfmt = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %fmt.addr, align 8
  %call1 = call i64 @strlen(ptr noundef %2) #14
  %add = add i64 %call1, 2
  %conv = trunc i64 %add to i32
  store i32 %conv, ptr %len, align 4
  %3 = load i32, ptr %len, align 4
  %conv2 = sext i32 %3 to i64
  %call3 = call noalias ptr @zmalloc(i64 noundef %conv2) #11
  store ptr %call3, ptr %hyphenfmt, align 8
  %4 = load ptr, ptr %hyphenfmt, align 8
  %5 = load i32, ptr %len, align 4
  %conv4 = sext i32 %5 to i64
  %6 = load ptr, ptr %fmt.addr, align 8
  %call5 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %4, i64 noundef %conv4, ptr noundef @.str.34, ptr noundef %6) #16
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %7 = load ptr, ptr %c, align 8
  %8 = load ptr, ptr %hyphenfmt, align 8
  %arraydecay6 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @addReplyErrorFormatInternal(ptr noundef %7, i32 noundef 0, ptr noundef %8, ptr noundef %arraydecay6)
  %arraydecay7 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay7)
  %9 = load ptr, ptr %hyphenfmt, align 8
  call void @zfree(ptr noundef %9)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #10

declare void @addReplyErrorFormatInternal(ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithSimpleString(ptr noundef %ctx, ptr noundef %msg) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %msg.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  call void @addReplyProto(ptr noundef %2, ptr noundef @.str.35, i64 noundef 1)
  %3 = load ptr, ptr %c, align 8
  %4 = load ptr, ptr %msg.addr, align 8
  %5 = load ptr, ptr %msg.addr, align 8
  %call1 = call i64 @strlen(ptr noundef %5) #14
  call void @addReplyProto(ptr noundef %3, ptr noundef %4, i64 noundef %call1)
  %6 = load ptr, ptr %c, align 8
  call void @addReplyProto(ptr noundef %6, ptr noundef @.str.36, i64 noundef 2)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare void @addReplyProto(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleReplyWithCollection(ptr noundef %ctx, i64 noundef %len, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %type.addr = alloca i32, align 4
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %len.addr, align 8
  %cmp1 = icmp eq i64 %2, -1
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays = getelementptr inbounds %struct.RedisModuleCtx, ptr %3, i32 0, i32 8
  %4 = load ptr, ptr %postponed_arrays, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i32 0, i32 9
  %6 = load i32, ptr %postponed_arrays_count, align 8
  %add = add nsw i32 %6, 1
  %conv = sext i32 %add to i64
  %mul = mul i64 8, %conv
  %call3 = call ptr @zrealloc(ptr noundef %4, i64 noundef %mul) #12
  %7 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays4 = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 8
  store ptr %call3, ptr %postponed_arrays4, align 8
  %8 = load ptr, ptr %c, align 8
  %call5 = call ptr @addReplyDeferredLen(ptr noundef %8)
  %9 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays6 = getelementptr inbounds %struct.RedisModuleCtx, ptr %9, i32 0, i32 8
  %10 = load ptr, ptr %postponed_arrays6, align 8
  %11 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count7 = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i32 0, i32 9
  %12 = load i32, ptr %postponed_arrays_count7, align 8
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %10, i64 %idxprom
  store ptr %call5, ptr %arrayidx, align 8
  %13 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count8 = getelementptr inbounds %struct.RedisModuleCtx, ptr %13, i32 0, i32 9
  %14 = load i32, ptr %postponed_arrays_count8, align 8
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %postponed_arrays_count8, align 8
  br label %if.end28

if.else:                                          ; preds = %if.end
  %15 = load i64, ptr %len.addr, align 8
  %cmp9 = icmp eq i64 %15, 0
  br i1 %cmp9, label %if.then11, label %if.else20

if.then11:                                        ; preds = %if.else
  %16 = load i32, ptr %type.addr, align 4
  switch i32 %16, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb12
    i32 3, label %sw.bb15
    i32 4, label %sw.bb19
  ]

sw.bb:                                            ; preds = %if.then11
  %17 = load ptr, ptr %c, align 8
  %18 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 12), align 8
  call void @addReply(ptr noundef %17, ptr noundef %18)
  br label %sw.epilog

sw.bb12:                                          ; preds = %if.then11
  %19 = load ptr, ptr %c, align 8
  %20 = load ptr, ptr %c, align 8
  %resp = getelementptr inbounds %struct.client, ptr %20, i32 0, i32 3
  %21 = load i32, ptr %resp, align 8
  %idxprom13 = sext i32 %21 to i64
  %arrayidx14 = getelementptr inbounds [4 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 10), i64 0, i64 %idxprom13
  %22 = load ptr, ptr %arrayidx14, align 8
  call void @addReply(ptr noundef %19, ptr noundef %22)
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.then11
  %23 = load ptr, ptr %c, align 8
  %24 = load ptr, ptr %c, align 8
  %resp16 = getelementptr inbounds %struct.client, ptr %24, i32 0, i32 3
  %25 = load i32, ptr %resp16, align 8
  %idxprom17 = sext i32 %25 to i64
  %arrayidx18 = getelementptr inbounds [4 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 11), i64 0, i64 %idxprom17
  %26 = load ptr, ptr %arrayidx18, align 8
  call void @addReply(ptr noundef %23, ptr noundef %26)
  br label %sw.epilog

sw.bb19:                                          ; preds = %if.then11
  %27 = load ptr, ptr %c, align 8
  %28 = load i64, ptr %len.addr, align 8
  call void @addReplyAttributeLen(ptr noundef %27, i64 noundef %28)
  br label %sw.epilog

sw.default:                                       ; preds = %if.then11
  %29 = load i32, ptr %type.addr, align 4
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 3118, ptr noundef @.str.37, i32 noundef %29)
  call void @abort() #13
  unreachable

sw.epilog:                                        ; preds = %sw.bb19, %sw.bb15, %sw.bb12, %sw.bb
  br label %if.end27

if.else20:                                        ; preds = %if.else
  %30 = load i32, ptr %type.addr, align 4
  switch i32 %30, label %sw.default25 [
    i32 1, label %sw.bb21
    i32 2, label %sw.bb22
    i32 3, label %sw.bb23
    i32 4, label %sw.bb24
  ]

sw.bb21:                                          ; preds = %if.else20
  %31 = load ptr, ptr %c, align 8
  %32 = load i64, ptr %len.addr, align 8
  call void @addReplyArrayLen(ptr noundef %31, i64 noundef %32)
  br label %sw.epilog26

sw.bb22:                                          ; preds = %if.else20
  %33 = load ptr, ptr %c, align 8
  %34 = load i64, ptr %len.addr, align 8
  call void @addReplyMapLen(ptr noundef %33, i64 noundef %34)
  br label %sw.epilog26

sw.bb23:                                          ; preds = %if.else20
  %35 = load ptr, ptr %c, align 8
  %36 = load i64, ptr %len.addr, align 8
  call void @addReplySetLen(ptr noundef %35, i64 noundef %36)
  br label %sw.epilog26

sw.bb24:                                          ; preds = %if.else20
  %37 = load ptr, ptr %c, align 8
  %38 = load i64, ptr %len.addr, align 8
  call void @addReplyAttributeLen(ptr noundef %37, i64 noundef %38)
  br label %sw.epilog26

sw.default25:                                     ; preds = %if.else20
  %39 = load i32, ptr %type.addr, align 4
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 3134, ptr noundef @.str.38, i32 noundef %39)
  call void @abort() #13
  unreachable

sw.epilog26:                                      ; preds = %sw.bb24, %sw.bb23, %sw.bb22, %sw.bb21
  br label %if.end27

if.end27:                                         ; preds = %sw.epilog26, %sw.epilog
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then2
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end28, %if.then
  %40 = load i32, ptr %retval, align 4
  ret i32 %40
}

declare ptr @addReplyDeferredLen(ptr noundef) #1

declare void @addReply(ptr noundef, ptr noundef) #1

declare void @addReplyAttributeLen(ptr noundef, i64 noundef) #1

declare void @addReplyArrayLen(ptr noundef, i64 noundef) #1

declare void @addReplyMapLen(ptr noundef, i64 noundef) #1

declare void @addReplySetLen(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithArray(ptr noundef %ctx, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %call = call i32 @moduleReplyWithCollection(ptr noundef %0, i64 noundef %1, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithMap(ptr noundef %ctx, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %call = call i32 @moduleReplyWithCollection(ptr noundef %0, i64 noundef %1, i32 noundef 2)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithSet(ptr noundef %ctx, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %call = call i32 @moduleReplyWithCollection(ptr noundef %0, i64 noundef %1, i32 noundef 3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithAttribute(ptr noundef %ctx, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %resp = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %resp, align 8
  %cmp = icmp eq i32 %2, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  %call = call i32 @moduleReplyWithCollection(ptr noundef %3, i64 noundef %4, i32 noundef 4)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithNullArray(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  call void @addReplyNullArray(ptr noundef %2)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

declare void @addReplyNullArray(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithEmptyArray(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 12), align 8
  call void @addReply(ptr noundef %2, ptr noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleReplySetCollectionLength(ptr noundef %ctx, i64 noundef %len, i32 noundef %type) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %type.addr = alloca i32, align 4
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end29

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 9
  %3 = load i32, ptr %postponed_arrays_count, align 8
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then2
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp3 = icmp slt i32 3, %4
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %do.body
  br label %do.end

if.end5:                                          ; preds = %do.body
  %5 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %name, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.39, ptr noundef %7)
  br label %do.end

do.end:                                           ; preds = %if.end5, %if.then4
  br label %if.end29

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count7 = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 9
  %9 = load i32, ptr %postponed_arrays_count7, align 8
  %dec = add nsw i32 %9, -1
  store i32 %dec, ptr %postponed_arrays_count7, align 8
  %10 = load i32, ptr %type.addr, align 4
  switch i32 %10, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb9
    i32 3, label %sw.bb14
    i32 4, label %sw.bb19
  ]

sw.bb:                                            ; preds = %if.end6
  %11 = load ptr, ptr %c, align 8
  %12 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays = getelementptr inbounds %struct.RedisModuleCtx, ptr %12, i32 0, i32 8
  %13 = load ptr, ptr %postponed_arrays, align 8
  %14 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count8 = getelementptr inbounds %struct.RedisModuleCtx, ptr %14, i32 0, i32 9
  %15 = load i32, ptr %postponed_arrays_count8, align 8
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %13, i64 %idxprom
  %16 = load ptr, ptr %arrayidx, align 8
  %17 = load i64, ptr %len.addr, align 8
  call void @setDeferredArrayLen(ptr noundef %11, ptr noundef %16, i64 noundef %17)
  br label %sw.epilog

sw.bb9:                                           ; preds = %if.end6
  %18 = load ptr, ptr %c, align 8
  %19 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays10 = getelementptr inbounds %struct.RedisModuleCtx, ptr %19, i32 0, i32 8
  %20 = load ptr, ptr %postponed_arrays10, align 8
  %21 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count11 = getelementptr inbounds %struct.RedisModuleCtx, ptr %21, i32 0, i32 9
  %22 = load i32, ptr %postponed_arrays_count11, align 8
  %idxprom12 = sext i32 %22 to i64
  %arrayidx13 = getelementptr inbounds ptr, ptr %20, i64 %idxprom12
  %23 = load ptr, ptr %arrayidx13, align 8
  %24 = load i64, ptr %len.addr, align 8
  call void @setDeferredMapLen(ptr noundef %18, ptr noundef %23, i64 noundef %24)
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end6
  %25 = load ptr, ptr %c, align 8
  %26 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays15 = getelementptr inbounds %struct.RedisModuleCtx, ptr %26, i32 0, i32 8
  %27 = load ptr, ptr %postponed_arrays15, align 8
  %28 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count16 = getelementptr inbounds %struct.RedisModuleCtx, ptr %28, i32 0, i32 9
  %29 = load i32, ptr %postponed_arrays_count16, align 8
  %idxprom17 = sext i32 %29 to i64
  %arrayidx18 = getelementptr inbounds ptr, ptr %27, i64 %idxprom17
  %30 = load ptr, ptr %arrayidx18, align 8
  %31 = load i64, ptr %len.addr, align 8
  call void @setDeferredSetLen(ptr noundef %25, ptr noundef %30, i64 noundef %31)
  br label %sw.epilog

sw.bb19:                                          ; preds = %if.end6
  %32 = load ptr, ptr %c, align 8
  %33 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays20 = getelementptr inbounds %struct.RedisModuleCtx, ptr %33, i32 0, i32 8
  %34 = load ptr, ptr %postponed_arrays20, align 8
  %35 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count21 = getelementptr inbounds %struct.RedisModuleCtx, ptr %35, i32 0, i32 9
  %36 = load i32, ptr %postponed_arrays_count21, align 8
  %idxprom22 = sext i32 %36 to i64
  %arrayidx23 = getelementptr inbounds ptr, ptr %34, i64 %idxprom22
  %37 = load ptr, ptr %arrayidx23, align 8
  %38 = load i64, ptr %len.addr, align 8
  call void @setDeferredAttributeLen(ptr noundef %32, ptr noundef %37, i64 noundef %38)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end6
  %39 = load i32, ptr %type.addr, align 4
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 3256, ptr noundef @.str.38, i32 noundef %39)
  call void @abort() #13
  unreachable

sw.epilog:                                        ; preds = %sw.bb19, %sw.bb14, %sw.bb9, %sw.bb
  %40 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays_count24 = getelementptr inbounds %struct.RedisModuleCtx, ptr %40, i32 0, i32 9
  %41 = load i32, ptr %postponed_arrays_count24, align 8
  %cmp25 = icmp eq i32 %41, 0
  br i1 %cmp25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %sw.epilog
  %42 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays27 = getelementptr inbounds %struct.RedisModuleCtx, ptr %42, i32 0, i32 8
  %43 = load ptr, ptr %postponed_arrays27, align 8
  call void @zfree(ptr noundef %43)
  %44 = load ptr, ptr %ctx.addr, align 8
  %postponed_arrays28 = getelementptr inbounds %struct.RedisModuleCtx, ptr %44, i32 0, i32 8
  store ptr null, ptr %postponed_arrays28, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %sw.epilog, %do.end, %if.then
  ret void
}

declare void @setDeferredArrayLen(ptr noundef, ptr noundef, i64 noundef) #1

declare void @setDeferredMapLen(ptr noundef, ptr noundef, i64 noundef) #1

declare void @setDeferredSetLen(ptr noundef, ptr noundef, i64 noundef) #1

declare void @setDeferredAttributeLen(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_ReplySetArrayLength(ptr noundef %ctx, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  call void @moduleReplySetCollectionLength(ptr noundef %0, i64 noundef %1, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ReplySetMapLength(ptr noundef %ctx, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  call void @moduleReplySetCollectionLength(ptr noundef %0, i64 noundef %1, i32 noundef 2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ReplySetSetLength(ptr noundef %ctx, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  call void @moduleReplySetCollectionLength(ptr noundef %0, i64 noundef %1, i32 noundef 3)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ReplySetAttributeLength(ptr noundef %ctx, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %resp = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %resp, align 8
  %cmp = icmp eq i32 %2, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  call void @moduleReplySetCollectionLength(ptr noundef %3, i64 noundef %4, i32 noundef 4)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithStringBuffer(ptr noundef %ctx, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load ptr, ptr %buf.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  call void @addReplyBulkCBuffer(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

declare void @addReplyBulkCBuffer(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithCString(ptr noundef %ctx, ptr noundef %buf) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load ptr, ptr %buf.addr, align 8
  call void @addReplyBulkCString(ptr noundef %2, ptr noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare void @addReplyBulkCString(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load ptr, ptr %str.addr, align 8
  call void @addReplyBulk(ptr noundef %2, ptr noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare void @addReplyBulk(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithEmptyString(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 2), align 8
  call void @addReply(ptr noundef %2, ptr noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithVerbatimStringType(ptr noundef %ctx, ptr noundef %buf, i64 noundef %len, ptr noundef %ext) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %ext.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %ext, ptr %ext.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load ptr, ptr %buf.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  %5 = load ptr, ptr %ext.addr, align 8
  call void @addReplyVerbatim(ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr noundef %5)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare void @addReplyVerbatim(ptr noundef, ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithVerbatimString(ptr noundef %ctx, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %buf.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  %call = call i32 @RM_ReplyWithVerbatimStringType(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef @.str.40)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithNull(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  call void @addReplyNull(ptr noundef %2)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

declare void @addReplyNull(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithBool(ptr noundef %ctx, i32 noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %b.addr = alloca i32, align 4
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %b, ptr %b.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load i32, ptr %b.addr, align 4
  call void @addReplyBool(ptr noundef %2, i32 noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare void @addReplyBool(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithCallReply(ptr noundef %ctx, ptr noundef %reply) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %reply.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %proto_len = alloca i64, align 8
  %proto = alloca ptr, align 8
  %errors = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %resp = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 3
  %3 = load i32, ptr %resp, align 8
  %cmp1 = icmp eq i32 %3, 2
  br i1 %cmp1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %reply.addr, align 8
  %call2 = call i32 @callReplyIsResp3(ptr noundef %4)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %5 = load ptr, ptr %reply.addr, align 8
  %call5 = call ptr @callReplyGetProto(ptr noundef %5, ptr noundef %proto_len)
  store ptr %call5, ptr %proto, align 8
  %6 = load ptr, ptr %c, align 8
  %7 = load ptr, ptr %proto, align 8
  %8 = load i64, ptr %proto_len, align 8
  call void @addReplyProto(ptr noundef %6, ptr noundef %7, i64 noundef %8)
  %9 = load ptr, ptr %reply.addr, align 8
  %call6 = call ptr @callReplyDeferredErrorList(ptr noundef %9)
  store ptr %call6, ptr %errors, align 8
  %10 = load ptr, ptr %errors, align 8
  %tobool7 = icmp ne ptr %10, null
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  %11 = load ptr, ptr %c, align 8
  %12 = load ptr, ptr %errors, align 8
  call void @deferredAfterErrorReply(ptr noundef %11, ptr noundef %12)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then3, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

declare i32 @callReplyIsResp3(ptr noundef) #1

declare ptr @callReplyGetProto(ptr noundef, ptr noundef) #1

declare ptr @callReplyDeferredErrorList(ptr noundef) #1

declare void @deferredAfterErrorReply(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithDouble(ptr noundef %ctx, double noundef %d) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %d.addr = alloca double, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store double %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load double, ptr %d.addr, align 8
  call void @addReplyDouble(ptr noundef %2, double noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare void @addReplyDouble(ptr noundef, double noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithBigNumber(ptr noundef %ctx, ptr noundef %bignum, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %bignum.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %bignum, ptr %bignum.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load ptr, ptr %bignum.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  call void @addReplyBigNum(ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

declare void @addReplyBigNum(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplyWithLongDouble(ptr noundef %ctx, x86_fp80 noundef %ld) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %ld.addr = alloca x86_fp80, align 16
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store x86_fp80 %ld, ptr %ld.addr, align 16
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr @moduleGetReplyClient(ptr noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %3 = load x86_fp80, ptr %ld.addr, align 16
  call void @addReplyHumanLongDouble(ptr noundef %2, x86_fp80 noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare void @addReplyHumanLongDouble(ptr noundef, x86_fp80 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_Replicate(ptr noundef %ctx, ptr noundef %cmdname, ptr noundef %fmt, ...) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %cmdname.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %argv = alloca ptr, align 8
  %argc = alloca i32, align 4
  %flags = alloca i32, align 4
  %j = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %target = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cmdname, ptr %cmdname.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr null, ptr %argv, align 8
  store i32 0, ptr %argc, align 4
  store i32 0, ptr %flags, align 4
  %0 = load ptr, ptr %cmdname.addr, align 8
  %call = call ptr @lookupCommandByCString(ptr noundef %0)
  store ptr %call, ptr %cmd, align 8
  %1 = load ptr, ptr %cmd, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %2 = load ptr, ptr %cmdname.addr, align 8
  %3 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call2 = call ptr @moduleCreateArgvFromUserFormat(ptr noundef %2, ptr noundef %3, ptr noundef %argc, ptr noundef %flags, ptr noundef %arraydecay1)
  store ptr %call2, ptr %argv, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay3)
  %4 = load ptr, ptr %argv, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  store i32 0, ptr %target, align 4
  %5 = load i32, ptr %flags, align 4
  %and = and i32 %5, 2
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  %6 = load i32, ptr %target, align 4
  %or = or i32 %6, 1
  store i32 %or, ptr %target, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end5
  %7 = load i32, ptr %flags, align 4
  %and9 = and i32 %7, 4
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end8
  %8 = load i32, ptr %target, align 4
  %or12 = or i32 %8, 2
  store i32 %or12, ptr %target, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end8
  %9 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %11, i32 0, i32 6
  %12 = load i32, ptr %id, align 8
  %13 = load ptr, ptr %argv, align 8
  %14 = load i32, ptr %argc, align 4
  %15 = load i32, ptr %target, align 4
  call void @alsoPropagate(i32 noundef %12, ptr noundef %13, i32 noundef %14, i32 noundef %15)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end13
  %16 = load i32, ptr %j, align 4
  %17 = load i32, ptr %argc, align 4
  %cmp14 = icmp slt i32 %16, %17
  br i1 %cmp14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %argv, align 8
  %19 = load i32, ptr %j, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %18, i64 %idxprom
  %20 = load ptr, ptr %arrayidx, align 8
  call void @decrRefCount(ptr noundef %20)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load i32, ptr %j, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %argv, align 8
  call void @zfree(ptr noundef %22)
  %23 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  %inc15 = add nsw i64 %23, 1
  store i64 %inc15, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then4, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleCreateArgvFromUserFormat(ptr noundef %cmdname, ptr noundef %fmt, ptr noundef %argcp, ptr noundef %flags, ptr noundef %ap) #0 {
entry:
  %retval = alloca ptr, align 8
  %cmdname.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %argcp.addr = alloca ptr, align 8
  %flags.addr = alloca ptr, align 8
  %ap.addr = alloca ptr, align 8
  %argc = alloca i32, align 4
  %argv_size = alloca i32, align 4
  %j = alloca i32, align 4
  %argv = alloca ptr, align 8
  %p = alloca ptr, align 8
  %cstr = alloca ptr, align 8
  %obj = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %len = alloca i64, align 8
  %ll = alloca i64, align 8
  %v = alloca ptr, align 8
  %vlen = alloca i64, align 8
  %i = alloca i64, align 8
  store ptr %cmdname, ptr %cmdname.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr %argcp, ptr %argcp.addr, align 8
  store ptr %flags, ptr %flags.addr, align 8
  store ptr %ap, ptr %ap.addr, align 8
  store i32 0, ptr %argc, align 4
  store ptr null, ptr %argv, align 8
  %0 = load ptr, ptr %fmt.addr, align 8
  %call = call i64 @strlen(ptr noundef %0) #14
  %add = add i64 %call, 1
  %conv = trunc i64 %add to i32
  store i32 %conv, ptr %argv_size, align 4
  %1 = load ptr, ptr %argv, align 8
  %2 = load i32, ptr %argv_size, align 4
  %conv1 = sext i32 %2 to i64
  %mul = mul i64 8, %conv1
  %call2 = call ptr @zrealloc(ptr noundef %1, i64 noundef %mul) #12
  store ptr %call2, ptr %argv, align 8
  %3 = load ptr, ptr %cmdname.addr, align 8
  %4 = load ptr, ptr %cmdname.addr, align 8
  %call3 = call i64 @strlen(ptr noundef %4) #14
  %call4 = call ptr @createStringObject(ptr noundef %3, i64 noundef %call3)
  %5 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 0
  store ptr %call4, ptr %arrayidx, align 8
  %6 = load i32, ptr %argc, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %argc, align 4
  %7 = load ptr, ptr %fmt.addr, align 8
  store ptr %7, ptr %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end252, %entry
  %8 = load ptr, ptr %p, align 8
  %9 = load i8, ptr %8, align 1
  %tobool = icmp ne i8 %9, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load ptr, ptr %p, align 8
  %11 = load i8, ptr %10, align 1
  %conv5 = sext i8 %11 to i32
  %cmp = icmp eq i32 %conv5, 99
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %12 = load ptr, ptr %ap.addr, align 8
  %gp_offset_p = getelementptr inbounds %struct.__va_list_tag, ptr %12, i32 0, i32 0
  %gp_offset = load i32, ptr %gp_offset_p, align 8
  %fits_in_gp = icmp ule i32 %gp_offset, 40
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %if.then
  %13 = getelementptr inbounds %struct.__va_list_tag, ptr %12, i32 0, i32 3
  %reg_save_area = load ptr, ptr %13, align 8
  %14 = getelementptr i8, ptr %reg_save_area, i32 %gp_offset
  %15 = add i32 %gp_offset, 8
  store i32 %15, ptr %gp_offset_p, align 8
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %if.then
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag, ptr %12, i32 0, i32 2
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i32 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %14, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %16 = load ptr, ptr %vaarg.addr, align 8
  store ptr %16, ptr %cstr, align 8
  %17 = load ptr, ptr %cstr, align 8
  %18 = load ptr, ptr %cstr, align 8
  %call7 = call i64 @strlen(ptr noundef %18) #14
  %call8 = call ptr @createStringObject(ptr noundef %17, i64 noundef %call7)
  %19 = load ptr, ptr %argv, align 8
  %20 = load i32, ptr %argc, align 4
  %inc9 = add nsw i32 %20, 1
  store i32 %inc9, ptr %argc, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx10 = getelementptr inbounds ptr, ptr %19, i64 %idxprom
  store ptr %call8, ptr %arrayidx10, align 8
  br label %if.end252

if.else:                                          ; preds = %while.body
  %21 = load ptr, ptr %p, align 8
  %22 = load i8, ptr %21, align 1
  %conv11 = sext i8 %22 to i32
  %cmp12 = icmp eq i32 %conv11, 115
  br i1 %cmp12, label %if.then14, label %if.else36

if.then14:                                        ; preds = %if.else
  %23 = load ptr, ptr %ap.addr, align 8
  %gp_offset_p15 = getelementptr inbounds %struct.__va_list_tag, ptr %23, i32 0, i32 0
  %gp_offset16 = load i32, ptr %gp_offset_p15, align 8
  %fits_in_gp17 = icmp ule i32 %gp_offset16, 40
  br i1 %fits_in_gp17, label %vaarg.in_reg18, label %vaarg.in_mem20

vaarg.in_reg18:                                   ; preds = %if.then14
  %24 = getelementptr inbounds %struct.__va_list_tag, ptr %23, i32 0, i32 3
  %reg_save_area19 = load ptr, ptr %24, align 8
  %25 = getelementptr i8, ptr %reg_save_area19, i32 %gp_offset16
  %26 = add i32 %gp_offset16, 8
  store i32 %26, ptr %gp_offset_p15, align 8
  br label %vaarg.end24

vaarg.in_mem20:                                   ; preds = %if.then14
  %overflow_arg_area_p21 = getelementptr inbounds %struct.__va_list_tag, ptr %23, i32 0, i32 2
  %overflow_arg_area22 = load ptr, ptr %overflow_arg_area_p21, align 8
  %overflow_arg_area.next23 = getelementptr i8, ptr %overflow_arg_area22, i32 8
  store ptr %overflow_arg_area.next23, ptr %overflow_arg_area_p21, align 8
  br label %vaarg.end24

vaarg.end24:                                      ; preds = %vaarg.in_mem20, %vaarg.in_reg18
  %vaarg.addr25 = phi ptr [ %25, %vaarg.in_reg18 ], [ %overflow_arg_area22, %vaarg.in_mem20 ]
  %27 = load ptr, ptr %vaarg.addr25, align 8
  store ptr %27, ptr %obj, align 8
  %28 = load ptr, ptr %obj, align 8
  %refcount = getelementptr inbounds %struct.redisObject, ptr %28, i32 0, i32 1
  %29 = load i32, ptr %refcount, align 4
  %cmp26 = icmp eq i32 %29, 2147483646
  br i1 %cmp26, label %if.then28, label %if.else32

if.then28:                                        ; preds = %vaarg.end24
  %30 = load ptr, ptr %obj, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %30, i32 0, i32 2
  %31 = load ptr, ptr %ptr, align 8
  %32 = load ptr, ptr %obj, align 8
  %ptr29 = getelementptr inbounds %struct.redisObject, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %ptr29, align 8
  %call30 = call i64 @sdslen(ptr noundef %33)
  %call31 = call ptr @createStringObject(ptr noundef %31, i64 noundef %call30)
  store ptr %call31, ptr %obj, align 8
  br label %if.end

if.else32:                                        ; preds = %vaarg.end24
  %34 = load ptr, ptr %obj, align 8
  call void @incrRefCount(ptr noundef %34)
  br label %if.end

if.end:                                           ; preds = %if.else32, %if.then28
  %35 = load ptr, ptr %obj, align 8
  %36 = load ptr, ptr %argv, align 8
  %37 = load i32, ptr %argc, align 4
  %inc33 = add nsw i32 %37, 1
  store i32 %inc33, ptr %argc, align 4
  %idxprom34 = sext i32 %37 to i64
  %arrayidx35 = getelementptr inbounds ptr, ptr %36, i64 %idxprom34
  store ptr %35, ptr %arrayidx35, align 8
  br label %if.end251

if.else36:                                        ; preds = %if.else
  %38 = load ptr, ptr %p, align 8
  %39 = load i8, ptr %38, align 1
  %conv37 = sext i8 %39 to i32
  %cmp38 = icmp eq i32 %conv37, 98
  br i1 %cmp38, label %if.then40, label %if.else67

if.then40:                                        ; preds = %if.else36
  %40 = load ptr, ptr %ap.addr, align 8
  %gp_offset_p41 = getelementptr inbounds %struct.__va_list_tag, ptr %40, i32 0, i32 0
  %gp_offset42 = load i32, ptr %gp_offset_p41, align 8
  %fits_in_gp43 = icmp ule i32 %gp_offset42, 40
  br i1 %fits_in_gp43, label %vaarg.in_reg44, label %vaarg.in_mem46

vaarg.in_reg44:                                   ; preds = %if.then40
  %41 = getelementptr inbounds %struct.__va_list_tag, ptr %40, i32 0, i32 3
  %reg_save_area45 = load ptr, ptr %41, align 8
  %42 = getelementptr i8, ptr %reg_save_area45, i32 %gp_offset42
  %43 = add i32 %gp_offset42, 8
  store i32 %43, ptr %gp_offset_p41, align 8
  br label %vaarg.end50

vaarg.in_mem46:                                   ; preds = %if.then40
  %overflow_arg_area_p47 = getelementptr inbounds %struct.__va_list_tag, ptr %40, i32 0, i32 2
  %overflow_arg_area48 = load ptr, ptr %overflow_arg_area_p47, align 8
  %overflow_arg_area.next49 = getelementptr i8, ptr %overflow_arg_area48, i32 8
  store ptr %overflow_arg_area.next49, ptr %overflow_arg_area_p47, align 8
  br label %vaarg.end50

vaarg.end50:                                      ; preds = %vaarg.in_mem46, %vaarg.in_reg44
  %vaarg.addr51 = phi ptr [ %42, %vaarg.in_reg44 ], [ %overflow_arg_area48, %vaarg.in_mem46 ]
  %44 = load ptr, ptr %vaarg.addr51, align 8
  store ptr %44, ptr %buf, align 8
  %45 = load ptr, ptr %ap.addr, align 8
  %gp_offset_p52 = getelementptr inbounds %struct.__va_list_tag, ptr %45, i32 0, i32 0
  %gp_offset53 = load i32, ptr %gp_offset_p52, align 8
  %fits_in_gp54 = icmp ule i32 %gp_offset53, 40
  br i1 %fits_in_gp54, label %vaarg.in_reg55, label %vaarg.in_mem57

vaarg.in_reg55:                                   ; preds = %vaarg.end50
  %46 = getelementptr inbounds %struct.__va_list_tag, ptr %45, i32 0, i32 3
  %reg_save_area56 = load ptr, ptr %46, align 8
  %47 = getelementptr i8, ptr %reg_save_area56, i32 %gp_offset53
  %48 = add i32 %gp_offset53, 8
  store i32 %48, ptr %gp_offset_p52, align 8
  br label %vaarg.end61

vaarg.in_mem57:                                   ; preds = %vaarg.end50
  %overflow_arg_area_p58 = getelementptr inbounds %struct.__va_list_tag, ptr %45, i32 0, i32 2
  %overflow_arg_area59 = load ptr, ptr %overflow_arg_area_p58, align 8
  %overflow_arg_area.next60 = getelementptr i8, ptr %overflow_arg_area59, i32 8
  store ptr %overflow_arg_area.next60, ptr %overflow_arg_area_p58, align 8
  br label %vaarg.end61

vaarg.end61:                                      ; preds = %vaarg.in_mem57, %vaarg.in_reg55
  %vaarg.addr62 = phi ptr [ %47, %vaarg.in_reg55 ], [ %overflow_arg_area59, %vaarg.in_mem57 ]
  %49 = load i64, ptr %vaarg.addr62, align 8
  store i64 %49, ptr %len, align 8
  %50 = load ptr, ptr %buf, align 8
  %51 = load i64, ptr %len, align 8
  %call63 = call ptr @createStringObject(ptr noundef %50, i64 noundef %51)
  %52 = load ptr, ptr %argv, align 8
  %53 = load i32, ptr %argc, align 4
  %inc64 = add nsw i32 %53, 1
  store i32 %inc64, ptr %argc, align 4
  %idxprom65 = sext i32 %53 to i64
  %arrayidx66 = getelementptr inbounds ptr, ptr %52, i64 %idxprom65
  store ptr %call63, ptr %arrayidx66, align 8
  br label %if.end250

if.else67:                                        ; preds = %if.else36
  %54 = load ptr, ptr %p, align 8
  %55 = load i8, ptr %54, align 1
  %conv68 = sext i8 %55 to i32
  %cmp69 = icmp eq i32 %conv68, 108
  br i1 %cmp69, label %if.then71, label %if.else87

if.then71:                                        ; preds = %if.else67
  %56 = load ptr, ptr %ap.addr, align 8
  %gp_offset_p72 = getelementptr inbounds %struct.__va_list_tag, ptr %56, i32 0, i32 0
  %gp_offset73 = load i32, ptr %gp_offset_p72, align 8
  %fits_in_gp74 = icmp ule i32 %gp_offset73, 40
  br i1 %fits_in_gp74, label %vaarg.in_reg75, label %vaarg.in_mem77

vaarg.in_reg75:                                   ; preds = %if.then71
  %57 = getelementptr inbounds %struct.__va_list_tag, ptr %56, i32 0, i32 3
  %reg_save_area76 = load ptr, ptr %57, align 8
  %58 = getelementptr i8, ptr %reg_save_area76, i32 %gp_offset73
  %59 = add i32 %gp_offset73, 8
  store i32 %59, ptr %gp_offset_p72, align 8
  br label %vaarg.end81

vaarg.in_mem77:                                   ; preds = %if.then71
  %overflow_arg_area_p78 = getelementptr inbounds %struct.__va_list_tag, ptr %56, i32 0, i32 2
  %overflow_arg_area79 = load ptr, ptr %overflow_arg_area_p78, align 8
  %overflow_arg_area.next80 = getelementptr i8, ptr %overflow_arg_area79, i32 8
  store ptr %overflow_arg_area.next80, ptr %overflow_arg_area_p78, align 8
  br label %vaarg.end81

vaarg.end81:                                      ; preds = %vaarg.in_mem77, %vaarg.in_reg75
  %vaarg.addr82 = phi ptr [ %58, %vaarg.in_reg75 ], [ %overflow_arg_area79, %vaarg.in_mem77 ]
  %60 = load i64, ptr %vaarg.addr82, align 8
  store i64 %60, ptr %ll, align 8
  %61 = load i64, ptr %ll, align 8
  %call83 = call ptr @createStringObjectFromLongLongWithSds(i64 noundef %61)
  %62 = load ptr, ptr %argv, align 8
  %63 = load i32, ptr %argc, align 4
  %inc84 = add nsw i32 %63, 1
  store i32 %inc84, ptr %argc, align 4
  %idxprom85 = sext i32 %63 to i64
  %arrayidx86 = getelementptr inbounds ptr, ptr %62, i64 %idxprom85
  store ptr %call83, ptr %arrayidx86, align 8
  br label %if.end249

if.else87:                                        ; preds = %if.else67
  %64 = load ptr, ptr %p, align 8
  %65 = load i8, ptr %64, align 1
  %conv88 = sext i8 %65 to i32
  %cmp89 = icmp eq i32 %conv88, 118
  br i1 %cmp89, label %if.then91, label %if.else128

if.then91:                                        ; preds = %if.else87
  %66 = load ptr, ptr %ap.addr, align 8
  %gp_offset_p92 = getelementptr inbounds %struct.__va_list_tag, ptr %66, i32 0, i32 0
  %gp_offset93 = load i32, ptr %gp_offset_p92, align 8
  %fits_in_gp94 = icmp ule i32 %gp_offset93, 40
  br i1 %fits_in_gp94, label %vaarg.in_reg95, label %vaarg.in_mem97

vaarg.in_reg95:                                   ; preds = %if.then91
  %67 = getelementptr inbounds %struct.__va_list_tag, ptr %66, i32 0, i32 3
  %reg_save_area96 = load ptr, ptr %67, align 8
  %68 = getelementptr i8, ptr %reg_save_area96, i32 %gp_offset93
  %69 = add i32 %gp_offset93, 8
  store i32 %69, ptr %gp_offset_p92, align 8
  br label %vaarg.end101

vaarg.in_mem97:                                   ; preds = %if.then91
  %overflow_arg_area_p98 = getelementptr inbounds %struct.__va_list_tag, ptr %66, i32 0, i32 2
  %overflow_arg_area99 = load ptr, ptr %overflow_arg_area_p98, align 8
  %overflow_arg_area.next100 = getelementptr i8, ptr %overflow_arg_area99, i32 8
  store ptr %overflow_arg_area.next100, ptr %overflow_arg_area_p98, align 8
  br label %vaarg.end101

vaarg.end101:                                     ; preds = %vaarg.in_mem97, %vaarg.in_reg95
  %vaarg.addr102 = phi ptr [ %68, %vaarg.in_reg95 ], [ %overflow_arg_area99, %vaarg.in_mem97 ]
  %70 = load ptr, ptr %vaarg.addr102, align 8
  store ptr %70, ptr %v, align 8
  %71 = load ptr, ptr %ap.addr, align 8
  %gp_offset_p103 = getelementptr inbounds %struct.__va_list_tag, ptr %71, i32 0, i32 0
  %gp_offset104 = load i32, ptr %gp_offset_p103, align 8
  %fits_in_gp105 = icmp ule i32 %gp_offset104, 40
  br i1 %fits_in_gp105, label %vaarg.in_reg106, label %vaarg.in_mem108

vaarg.in_reg106:                                  ; preds = %vaarg.end101
  %72 = getelementptr inbounds %struct.__va_list_tag, ptr %71, i32 0, i32 3
  %reg_save_area107 = load ptr, ptr %72, align 8
  %73 = getelementptr i8, ptr %reg_save_area107, i32 %gp_offset104
  %74 = add i32 %gp_offset104, 8
  store i32 %74, ptr %gp_offset_p103, align 8
  br label %vaarg.end112

vaarg.in_mem108:                                  ; preds = %vaarg.end101
  %overflow_arg_area_p109 = getelementptr inbounds %struct.__va_list_tag, ptr %71, i32 0, i32 2
  %overflow_arg_area110 = load ptr, ptr %overflow_arg_area_p109, align 8
  %overflow_arg_area.next111 = getelementptr i8, ptr %overflow_arg_area110, i32 8
  store ptr %overflow_arg_area.next111, ptr %overflow_arg_area_p109, align 8
  br label %vaarg.end112

vaarg.end112:                                     ; preds = %vaarg.in_mem108, %vaarg.in_reg106
  %vaarg.addr113 = phi ptr [ %73, %vaarg.in_reg106 ], [ %overflow_arg_area110, %vaarg.in_mem108 ]
  %75 = load i64, ptr %vaarg.addr113, align 8
  store i64 %75, ptr %vlen, align 8
  %76 = load i64, ptr %vlen, align 8
  %sub = sub i64 %76, 1
  %77 = load i32, ptr %argv_size, align 4
  %conv114 = sext i32 %77 to i64
  %add115 = add i64 %conv114, %sub
  %conv116 = trunc i64 %add115 to i32
  store i32 %conv116, ptr %argv_size, align 4
  %78 = load ptr, ptr %argv, align 8
  %79 = load i32, ptr %argv_size, align 4
  %conv117 = sext i32 %79 to i64
  %mul118 = mul i64 8, %conv117
  %call119 = call ptr @zrealloc(ptr noundef %78, i64 noundef %mul118) #12
  store ptr %call119, ptr %argv, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %vaarg.end112
  %80 = load i64, ptr %i, align 8
  %81 = load i64, ptr %vlen, align 8
  %cmp120 = icmp ult i64 %80, %81
  br i1 %cmp120, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %82 = load ptr, ptr %v, align 8
  %83 = load i64, ptr %i, align 8
  %arrayidx122 = getelementptr inbounds ptr, ptr %82, i64 %83
  %84 = load ptr, ptr %arrayidx122, align 8
  call void @incrRefCount(ptr noundef %84)
  %85 = load ptr, ptr %v, align 8
  %86 = load i64, ptr %i, align 8
  %arrayidx123 = getelementptr inbounds ptr, ptr %85, i64 %86
  %87 = load ptr, ptr %arrayidx123, align 8
  %88 = load ptr, ptr %argv, align 8
  %89 = load i32, ptr %argc, align 4
  %inc124 = add nsw i32 %89, 1
  store i32 %inc124, ptr %argc, align 4
  %idxprom125 = sext i32 %89 to i64
  %arrayidx126 = getelementptr inbounds ptr, ptr %88, i64 %idxprom125
  store ptr %87, ptr %arrayidx126, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %90 = load i64, ptr %i, align 8
  %inc127 = add i64 %90, 1
  store i64 %inc127, ptr %i, align 8
  br label %for.cond, !llvm.loop !28

for.end:                                          ; preds = %for.cond
  br label %if.end248

if.else128:                                       ; preds = %if.else87
  %91 = load ptr, ptr %p, align 8
  %92 = load i8, ptr %91, align 1
  %conv129 = sext i8 %92 to i32
  %cmp130 = icmp eq i32 %conv129, 33
  br i1 %cmp130, label %if.then132, label %if.else136

if.then132:                                       ; preds = %if.else128
  %93 = load ptr, ptr %flags.addr, align 8
  %tobool133 = icmp ne ptr %93, null
  br i1 %tobool133, label %if.then134, label %if.end135

if.then134:                                       ; preds = %if.then132
  %94 = load ptr, ptr %flags.addr, align 8
  %95 = load i32, ptr %94, align 4
  %or = or i32 %95, 1
  store i32 %or, ptr %94, align 4
  br label %if.end135

if.end135:                                        ; preds = %if.then134, %if.then132
  br label %if.end247

if.else136:                                       ; preds = %if.else128
  %96 = load ptr, ptr %p, align 8
  %97 = load i8, ptr %96, align 1
  %conv137 = sext i8 %97 to i32
  %cmp138 = icmp eq i32 %conv137, 65
  br i1 %cmp138, label %if.then140, label %if.else145

if.then140:                                       ; preds = %if.else136
  %98 = load ptr, ptr %flags.addr, align 8
  %tobool141 = icmp ne ptr %98, null
  br i1 %tobool141, label %if.then142, label %if.end144

if.then142:                                       ; preds = %if.then140
  %99 = load ptr, ptr %flags.addr, align 8
  %100 = load i32, ptr %99, align 4
  %or143 = or i32 %100, 2
  store i32 %or143, ptr %99, align 4
  br label %if.end144

if.end144:                                        ; preds = %if.then142, %if.then140
  br label %if.end246

if.else145:                                       ; preds = %if.else136
  %101 = load ptr, ptr %p, align 8
  %102 = load i8, ptr %101, align 1
  %conv146 = sext i8 %102 to i32
  %cmp147 = icmp eq i32 %conv146, 82
  br i1 %cmp147, label %if.then149, label %if.else154

if.then149:                                       ; preds = %if.else145
  %103 = load ptr, ptr %flags.addr, align 8
  %tobool150 = icmp ne ptr %103, null
  br i1 %tobool150, label %if.then151, label %if.end153

if.then151:                                       ; preds = %if.then149
  %104 = load ptr, ptr %flags.addr, align 8
  %105 = load i32, ptr %104, align 4
  %or152 = or i32 %105, 4
  store i32 %or152, ptr %104, align 4
  br label %if.end153

if.end153:                                        ; preds = %if.then151, %if.then149
  br label %if.end245

if.else154:                                       ; preds = %if.else145
  %106 = load ptr, ptr %p, align 8
  %107 = load i8, ptr %106, align 1
  %conv155 = sext i8 %107 to i32
  %cmp156 = icmp eq i32 %conv155, 51
  br i1 %cmp156, label %if.then158, label %if.else163

if.then158:                                       ; preds = %if.else154
  %108 = load ptr, ptr %flags.addr, align 8
  %tobool159 = icmp ne ptr %108, null
  br i1 %tobool159, label %if.then160, label %if.end162

if.then160:                                       ; preds = %if.then158
  %109 = load ptr, ptr %flags.addr, align 8
  %110 = load i32, ptr %109, align 4
  %or161 = or i32 %110, 8
  store i32 %or161, ptr %109, align 4
  br label %if.end162

if.end162:                                        ; preds = %if.then160, %if.then158
  br label %if.end244

if.else163:                                       ; preds = %if.else154
  %111 = load ptr, ptr %p, align 8
  %112 = load i8, ptr %111, align 1
  %conv164 = sext i8 %112 to i32
  %cmp165 = icmp eq i32 %conv164, 48
  br i1 %cmp165, label %if.then167, label %if.else172

if.then167:                                       ; preds = %if.else163
  %113 = load ptr, ptr %flags.addr, align 8
  %tobool168 = icmp ne ptr %113, null
  br i1 %tobool168, label %if.then169, label %if.end171

if.then169:                                       ; preds = %if.then167
  %114 = load ptr, ptr %flags.addr, align 8
  %115 = load i32, ptr %114, align 4
  %or170 = or i32 %115, 16
  store i32 %or170, ptr %114, align 4
  br label %if.end171

if.end171:                                        ; preds = %if.then169, %if.then167
  br label %if.end243

if.else172:                                       ; preds = %if.else163
  %116 = load ptr, ptr %p, align 8
  %117 = load i8, ptr %116, align 1
  %conv173 = sext i8 %117 to i32
  %cmp174 = icmp eq i32 %conv173, 67
  br i1 %cmp174, label %if.then176, label %if.else181

if.then176:                                       ; preds = %if.else172
  %118 = load ptr, ptr %flags.addr, align 8
  %tobool177 = icmp ne ptr %118, null
  br i1 %tobool177, label %if.then178, label %if.end180

if.then178:                                       ; preds = %if.then176
  %119 = load ptr, ptr %flags.addr, align 8
  %120 = load i32, ptr %119, align 4
  %or179 = or i32 %120, 32
  store i32 %or179, ptr %119, align 4
  br label %if.end180

if.end180:                                        ; preds = %if.then178, %if.then176
  br label %if.end242

if.else181:                                       ; preds = %if.else172
  %121 = load ptr, ptr %p, align 8
  %122 = load i8, ptr %121, align 1
  %conv182 = sext i8 %122 to i32
  %cmp183 = icmp eq i32 %conv182, 83
  br i1 %cmp183, label %if.then185, label %if.else190

if.then185:                                       ; preds = %if.else181
  %123 = load ptr, ptr %flags.addr, align 8
  %tobool186 = icmp ne ptr %123, null
  br i1 %tobool186, label %if.then187, label %if.end189

if.then187:                                       ; preds = %if.then185
  %124 = load ptr, ptr %flags.addr, align 8
  %125 = load i32, ptr %124, align 4
  %or188 = or i32 %125, 64
  store i32 %or188, ptr %124, align 4
  br label %if.end189

if.end189:                                        ; preds = %if.then187, %if.then185
  br label %if.end241

if.else190:                                       ; preds = %if.else181
  %126 = load ptr, ptr %p, align 8
  %127 = load i8, ptr %126, align 1
  %conv191 = sext i8 %127 to i32
  %cmp192 = icmp eq i32 %conv191, 87
  br i1 %cmp192, label %if.then194, label %if.else199

if.then194:                                       ; preds = %if.else190
  %128 = load ptr, ptr %flags.addr, align 8
  %tobool195 = icmp ne ptr %128, null
  br i1 %tobool195, label %if.then196, label %if.end198

if.then196:                                       ; preds = %if.then194
  %129 = load ptr, ptr %flags.addr, align 8
  %130 = load i32, ptr %129, align 4
  %or197 = or i32 %130, 128
  store i32 %or197, ptr %129, align 4
  br label %if.end198

if.end198:                                        ; preds = %if.then196, %if.then194
  br label %if.end240

if.else199:                                       ; preds = %if.else190
  %131 = load ptr, ptr %p, align 8
  %132 = load i8, ptr %131, align 1
  %conv200 = sext i8 %132 to i32
  %cmp201 = icmp eq i32 %conv200, 77
  br i1 %cmp201, label %if.then203, label %if.else208

if.then203:                                       ; preds = %if.else199
  %133 = load ptr, ptr %flags.addr, align 8
  %tobool204 = icmp ne ptr %133, null
  br i1 %tobool204, label %if.then205, label %if.end207

if.then205:                                       ; preds = %if.then203
  %134 = load ptr, ptr %flags.addr, align 8
  %135 = load i32, ptr %134, align 4
  %or206 = or i32 %135, 512
  store i32 %or206, ptr %134, align 4
  br label %if.end207

if.end207:                                        ; preds = %if.then205, %if.then203
  br label %if.end239

if.else208:                                       ; preds = %if.else199
  %136 = load ptr, ptr %p, align 8
  %137 = load i8, ptr %136, align 1
  %conv209 = sext i8 %137 to i32
  %cmp210 = icmp eq i32 %conv209, 69
  br i1 %cmp210, label %if.then212, label %if.else217

if.then212:                                       ; preds = %if.else208
  %138 = load ptr, ptr %flags.addr, align 8
  %tobool213 = icmp ne ptr %138, null
  br i1 %tobool213, label %if.then214, label %if.end216

if.then214:                                       ; preds = %if.then212
  %139 = load ptr, ptr %flags.addr, align 8
  %140 = load i32, ptr %139, align 4
  %or215 = or i32 %140, 256
  store i32 %or215, ptr %139, align 4
  br label %if.end216

if.end216:                                        ; preds = %if.then214, %if.then212
  br label %if.end238

if.else217:                                       ; preds = %if.else208
  %141 = load ptr, ptr %p, align 8
  %142 = load i8, ptr %141, align 1
  %conv218 = sext i8 %142 to i32
  %cmp219 = icmp eq i32 %conv218, 68
  br i1 %cmp219, label %if.then221, label %if.else226

if.then221:                                       ; preds = %if.else217
  %143 = load ptr, ptr %flags.addr, align 8
  %tobool222 = icmp ne ptr %143, null
  br i1 %tobool222, label %if.then223, label %if.end225

if.then223:                                       ; preds = %if.then221
  %144 = load ptr, ptr %flags.addr, align 8
  %145 = load i32, ptr %144, align 4
  %or224 = or i32 %145, 1280
  store i32 %or224, ptr %144, align 4
  br label %if.end225

if.end225:                                        ; preds = %if.then223, %if.then221
  br label %if.end237

if.else226:                                       ; preds = %if.else217
  %146 = load ptr, ptr %p, align 8
  %147 = load i8, ptr %146, align 1
  %conv227 = sext i8 %147 to i32
  %cmp228 = icmp eq i32 %conv227, 75
  br i1 %cmp228, label %if.then230, label %if.else235

if.then230:                                       ; preds = %if.else226
  %148 = load ptr, ptr %flags.addr, align 8
  %tobool231 = icmp ne ptr %148, null
  br i1 %tobool231, label %if.then232, label %if.end234

if.then232:                                       ; preds = %if.then230
  %149 = load ptr, ptr %flags.addr, align 8
  %150 = load i32, ptr %149, align 4
  %or233 = or i32 %150, 2048
  store i32 %or233, ptr %149, align 4
  br label %if.end234

if.end234:                                        ; preds = %if.then232, %if.then230
  br label %if.end236

if.else235:                                       ; preds = %if.else226
  br label %fmterr

if.end236:                                        ; preds = %if.end234
  br label %if.end237

if.end237:                                        ; preds = %if.end236, %if.end225
  br label %if.end238

if.end238:                                        ; preds = %if.end237, %if.end216
  br label %if.end239

if.end239:                                        ; preds = %if.end238, %if.end207
  br label %if.end240

if.end240:                                        ; preds = %if.end239, %if.end198
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.end189
  br label %if.end242

if.end242:                                        ; preds = %if.end241, %if.end180
  br label %if.end243

if.end243:                                        ; preds = %if.end242, %if.end171
  br label %if.end244

if.end244:                                        ; preds = %if.end243, %if.end162
  br label %if.end245

if.end245:                                        ; preds = %if.end244, %if.end153
  br label %if.end246

if.end246:                                        ; preds = %if.end245, %if.end144
  br label %if.end247

if.end247:                                        ; preds = %if.end246, %if.end135
  br label %if.end248

if.end248:                                        ; preds = %if.end247, %for.end
  br label %if.end249

if.end249:                                        ; preds = %if.end248, %vaarg.end81
  br label %if.end250

if.end250:                                        ; preds = %if.end249, %vaarg.end61
  br label %if.end251

if.end251:                                        ; preds = %if.end250, %if.end
  br label %if.end252

if.end252:                                        ; preds = %if.end251, %vaarg.end
  %151 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %151, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %while.cond, !llvm.loop !29

while.end:                                        ; preds = %while.cond
  %152 = load ptr, ptr %argcp.addr, align 8
  %tobool253 = icmp ne ptr %152, null
  br i1 %tobool253, label %if.then254, label %if.end255

if.then254:                                       ; preds = %while.end
  %153 = load i32, ptr %argc, align 4
  %154 = load ptr, ptr %argcp.addr, align 8
  store i32 %153, ptr %154, align 4
  br label %if.end255

if.end255:                                        ; preds = %if.then254, %while.end
  %155 = load ptr, ptr %argv, align 8
  store ptr %155, ptr %retval, align 8
  br label %return

fmterr:                                           ; preds = %if.else235
  store i32 0, ptr %j, align 4
  br label %for.cond256

for.cond256:                                      ; preds = %for.inc262, %fmterr
  %156 = load i32, ptr %j, align 4
  %157 = load i32, ptr %argc, align 4
  %cmp257 = icmp slt i32 %156, %157
  br i1 %cmp257, label %for.body259, label %for.end264

for.body259:                                      ; preds = %for.cond256
  %158 = load ptr, ptr %argv, align 8
  %159 = load i32, ptr %j, align 4
  %idxprom260 = sext i32 %159 to i64
  %arrayidx261 = getelementptr inbounds ptr, ptr %158, i64 %idxprom260
  %160 = load ptr, ptr %arrayidx261, align 8
  call void @decrRefCount(ptr noundef %160)
  br label %for.inc262

for.inc262:                                       ; preds = %for.body259
  %161 = load i32, ptr %j, align 4
  %inc263 = add nsw i32 %161, 1
  store i32 %inc263, ptr %j, align 4
  br label %for.cond256, !llvm.loop !30

for.end264:                                       ; preds = %for.cond256
  %162 = load ptr, ptr %argv, align 8
  call void @zfree(ptr noundef %162)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end264, %if.end255
  %163 = load ptr, ptr %retval, align 8
  ret ptr %163
}

declare void @alsoPropagate(i32 noundef, ptr noundef, i32 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ReplicateVerbatim(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %id, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %client1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %client1, align 8
  %argv = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 12
  %6 = load ptr, ptr %argv, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %client2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %client2, align 8
  %argc = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 11
  %9 = load i32, ptr %argc, align 8
  call void @alsoPropagate(i32 noundef %3, ptr noundef %6, i32 noundef %9, i32 noundef 3)
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  %inc = add nsw i64 %10, 1
  store i64 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_GetClientId(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i64, align 8
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %client1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %client1, align 8
  %id = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 0
  %4 = load i64, ptr %id, align 8
  store i64 %4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i64, ptr %retval, align 8
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetClientUserNameById(ptr noundef %ctx, i64 noundef %id) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %id.addr = alloca i64, align 8
  %client = alloca ptr, align 8
  %name = alloca ptr, align 8
  %str = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %id, ptr %id.addr, align 8
  %0 = load i64, ptr %id.addr, align 8
  %call = call ptr @lookupClientByID(i64 noundef %0)
  store ptr %call, ptr %client, align 8
  %1 = load ptr, ptr %client, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #15
  store i32 2, ptr %call1, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %client, align 8
  %user = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 20
  %3 = load ptr, ptr %user, align 8
  %cmp2 = icmp eq ptr %3, null
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @__errno_location() #15
  store i32 95, ptr %call4, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %4 = load ptr, ptr %client, align 8
  %user6 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 20
  %5 = load ptr, ptr %user6, align 8
  %name7 = getelementptr inbounds %struct.user, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %name7, align 8
  %call8 = call ptr @sdsnew(ptr noundef %6)
  store ptr %call8, ptr %name, align 8
  %7 = load ptr, ptr %name, align 8
  %call9 = call ptr @createObject(i32 noundef 0, ptr noundef %7)
  store ptr %call9, ptr %str, align 8
  %8 = load ptr, ptr %ctx.addr, align 8
  %9 = load ptr, ptr %str, align 8
  call void @autoMemoryAdd(ptr noundef %8, i32 noundef 1, ptr noundef %9)
  %10 = load ptr, ptr %str, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then3, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

declare ptr @lookupClientByID(i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @modulePopulateClientInfoStructure(ptr noundef %ci, ptr noundef %client, i32 noundef %structver) #0 {
entry:
  %retval = alloca i32, align 4
  %ci.addr = alloca ptr, align 8
  %client.addr = alloca ptr, align 8
  %structver.addr = alloca i32, align 4
  %ci1 = alloca ptr, align 8
  %port = alloca i32, align 4
  store ptr %ci, ptr %ci.addr, align 8
  store ptr %client, ptr %client.addr, align 8
  store i32 %structver, ptr %structver.addr, align 4
  %0 = load i32, ptr %structver.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ci.addr, align 8
  store ptr %1, ptr %ci1, align 8
  %2 = load ptr, ptr %ci1, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %2, i8 0, i64 80, i1 false)
  %3 = load i32, ptr %structver.addr, align 4
  %conv = sext i32 %3 to i64
  %4 = load ptr, ptr %ci1, align 8
  %version = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %4, i32 0, i32 0
  store i64 %conv, ptr %version, align 8
  %5 = load ptr, ptr %client.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %flags, align 8
  %and = and i64 %6, 8
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %7 = load ptr, ptr %ci1, align 8
  %flags2 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %7, i32 0, i32 1
  %8 = load i64, ptr %flags2, align 8
  %or = or i64 %8, 32
  store i64 %or, ptr %flags2, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %9 = load ptr, ptr %client.addr, align 8
  %flags4 = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 1
  %10 = load i64, ptr %flags4, align 8
  %and5 = and i64 %10, 262144
  %tobool6 = icmp ne i64 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end3
  %11 = load ptr, ptr %ci1, align 8
  %flags8 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %flags8, align 8
  %or9 = or i64 %12, 2
  store i64 %or9, ptr %flags8, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end3
  %13 = load ptr, ptr %client.addr, align 8
  %flags11 = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 1
  %14 = load i64, ptr %flags11, align 8
  %and12 = and i64 %14, 2048
  %tobool13 = icmp ne i64 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end10
  %15 = load ptr, ptr %ci1, align 8
  %flags15 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %15, i32 0, i32 1
  %16 = load i64, ptr %flags15, align 8
  %or16 = or i64 %16, 16
  store i64 %or16, ptr %flags15, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end10
  %17 = load ptr, ptr %client.addr, align 8
  %flags18 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 1
  %18 = load i64, ptr %flags18, align 8
  %and19 = and i64 %18, 2147483648
  %tobool20 = icmp ne i64 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end17
  %19 = load ptr, ptr %ci1, align 8
  %flags22 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %19, i32 0, i32 1
  %20 = load i64, ptr %flags22, align 8
  %or23 = or i64 %20, 8
  store i64 %or23, ptr %flags22, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end17
  %21 = load ptr, ptr %client.addr, align 8
  %flags25 = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 1
  %22 = load i64, ptr %flags25, align 8
  %and26 = and i64 %22, 16
  %tobool27 = icmp ne i64 %and26, 0
  br i1 %tobool27, label %if.then28, label %if.end31

if.then28:                                        ; preds = %if.end24
  %23 = load ptr, ptr %ci1, align 8
  %flags29 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %23, i32 0, i32 1
  %24 = load i64, ptr %flags29, align 8
  %or30 = or i64 %24, 4
  store i64 %or30, ptr %flags29, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %if.end24
  %25 = load ptr, ptr %client.addr, align 8
  %conn = getelementptr inbounds %struct.client, ptr %25, i32 0, i32 2
  %26 = load ptr, ptr %conn, align 8
  %type = getelementptr inbounds %struct.connection, ptr %26, i32 0, i32 0
  %27 = load ptr, ptr %type, align 8
  %call = call ptr @connectionTypeTls()
  %cmp32 = icmp eq ptr %27, %call
  br i1 %cmp32, label %if.then34, label %if.end37

if.then34:                                        ; preds = %if.end31
  %28 = load ptr, ptr %ci1, align 8
  %flags35 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %28, i32 0, i32 1
  %29 = load i64, ptr %flags35, align 8
  %or36 = or i64 %29, 1
  store i64 %or36, ptr %flags35, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then34, %if.end31
  %30 = load ptr, ptr %client.addr, align 8
  %conn38 = getelementptr inbounds %struct.client, ptr %30, i32 0, i32 2
  %31 = load ptr, ptr %conn38, align 8
  %32 = load ptr, ptr %ci1, align 8
  %addr = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %32, i32 0, i32 3
  %arraydecay = getelementptr inbounds [46 x i8], ptr %addr, i64 0, i64 0
  %call39 = call i32 @connAddrPeerName(ptr noundef %31, ptr noundef %arraydecay, i64 noundef 46, ptr noundef %port)
  %33 = load i32, ptr %port, align 4
  %conv40 = trunc i32 %33 to i16
  %34 = load ptr, ptr %ci1, align 8
  %port41 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %34, i32 0, i32 4
  store i16 %conv40, ptr %port41, align 2
  %35 = load ptr, ptr %client.addr, align 8
  %db = getelementptr inbounds %struct.client, ptr %35, i32 0, i32 4
  %36 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %36, i32 0, i32 6
  %37 = load i32, ptr %id, align 8
  %conv42 = trunc i32 %37 to i16
  %38 = load ptr, ptr %ci1, align 8
  %db43 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %38, i32 0, i32 5
  store i16 %conv42, ptr %db43, align 8
  %39 = load ptr, ptr %client.addr, align 8
  %id44 = getelementptr inbounds %struct.client, ptr %39, i32 0, i32 0
  %40 = load i64, ptr %id44, align 8
  %41 = load ptr, ptr %ci1, align 8
  %id45 = getelementptr inbounds %struct.RedisModuleClientInfo, ptr %41, i32 0, i32 2
  store i64 %40, ptr %id45, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end37, %if.then
  %42 = load i32, ptr %retval, align 4
  ret i32 %42
}

declare ptr @connectionTypeTls() #1

; Function Attrs: nounwind uwtable
define internal i32 @connAddrPeerName(ptr noundef %conn, ptr noundef %ip, i64 noundef %ip_len, ptr noundef %port) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %ip.addr = alloca ptr, align 8
  %ip_len.addr = alloca i64, align 8
  %port.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i64 %ip_len, ptr %ip_len.addr, align 8
  store ptr %port, ptr %port.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %1 = load ptr, ptr %ip.addr, align 8
  %2 = load i64, ptr %ip_len.addr, align 8
  %3 = load ptr, ptr %port.addr, align 8
  %call = call i32 @connAddr(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @modulePopulateReplicationInfoStructure(ptr noundef %ri, i32 noundef %structver) #0 {
entry:
  %retval = alloca i32, align 4
  %ri.addr = alloca ptr, align 8
  %structver.addr = alloca i32, align 4
  %ri1 = alloca ptr, align 8
  store ptr %ri, ptr %ri.addr, align 8
  store i32 %structver, ptr %structver.addr, align 4
  %0 = load i32, ptr %structver.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ri.addr, align 8
  store ptr %1, ptr %ri1, align 8
  %2 = load ptr, ptr %ri1, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %2, i8 0, i64 64, i1 false)
  %3 = load i32, ptr %structver.addr, align 4
  %conv = sext i32 %3 to i64
  %4 = load ptr, ptr %ri1, align 8
  %version = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %4, i32 0, i32 0
  store i64 %conv, ptr %version, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %cmp1 = icmp eq ptr %5, null
  %conv2 = zext i1 %cmp1 to i32
  %6 = load ptr, ptr %ri1, align 8
  %master = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %6, i32 0, i32 1
  store i32 %conv2, ptr %master, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %8, %cond.true ], [ @.str.41, %cond.false ]
  %9 = load ptr, ptr %ri1, align 8
  %masterhost = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %9, i32 0, i32 2
  store ptr %cond, ptr %masterhost, align 8
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 284), align 8
  %11 = load ptr, ptr %ri1, align 8
  %masterport = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %11, i32 0, i32 3
  store i32 %10, ptr %masterport, align 8
  %12 = load ptr, ptr %ri1, align 8
  %replid1 = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %12, i32 0, i32 4
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 260), ptr %replid1, align 8
  %13 = load ptr, ptr %ri1, align 8
  %replid2 = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %13, i32 0, i32 5
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 261), ptr %replid2, align 8
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %15 = load ptr, ptr %ri1, align 8
  %repl1_offset = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %15, i32 0, i32 6
  store i64 %14, ptr %repl1_offset, align 8
  %16 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 263), align 8
  %17 = load ptr, ptr %ri1, align 8
  %repl2_offset = getelementptr inbounds %struct.RedisModuleReplicationInfo, ptr %17, i32 0, i32 7
  store i64 %16, ptr %repl2_offset, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetClientInfoById(ptr noundef %ci, i64 noundef %id) #0 {
entry:
  %retval = alloca i32, align 4
  %ci.addr = alloca ptr, align 8
  %id.addr = alloca i64, align 8
  %client = alloca ptr, align 8
  %structver = alloca i64, align 8
  store ptr %ci, ptr %ci.addr, align 8
  store i64 %id, ptr %id.addr, align 8
  %0 = load i64, ptr %id.addr, align 8
  %call = call ptr @lookupClientByID(i64 noundef %0)
  store ptr %call, ptr %client, align 8
  %1 = load ptr, ptr %client, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ci.addr, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %ci.addr, align 8
  %arrayidx = getelementptr inbounds i64, ptr %3, i64 0
  %4 = load i64, ptr %arrayidx, align 8
  store i64 %4, ptr %structver, align 8
  %5 = load ptr, ptr %ci.addr, align 8
  %6 = load ptr, ptr %client, align 8
  %7 = load i64, ptr %structver, align 8
  %conv = trunc i64 %7 to i32
  %call4 = call i32 @modulePopulateClientInfoStructure(ptr noundef %5, ptr noundef %6, i32 noundef %conv)
  store i32 %call4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetClientNameById(ptr noundef %ctx, i64 noundef %id) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %id.addr = alloca i64, align 8
  %client = alloca ptr, align 8
  %name2 = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %id, ptr %id.addr, align 8
  %0 = load i64, ptr %id.addr, align 8
  %call = call ptr @lookupClientByID(i64 noundef %0)
  store ptr %call, ptr %client, align 8
  %1 = load ptr, ptr %client, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %client, align 8
  %name = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 5
  %3 = load ptr, ptr %name, align 8
  %cmp1 = icmp eq ptr %3, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %client, align 8
  %name3 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %name3, align 8
  store ptr %5, ptr %name2, align 8
  %6 = load ptr, ptr %name2, align 8
  call void @incrRefCount(ptr noundef %6)
  %7 = load ptr, ptr %ctx.addr, align 8
  %8 = load ptr, ptr %name2, align 8
  call void @autoMemoryAdd(ptr noundef %7, i32 noundef 1, ptr noundef %8)
  %9 = load ptr, ptr %name2, align 8
  store ptr %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetClientNameById(i64 noundef %id, ptr noundef %name) #0 {
entry:
  %retval = alloca i32, align 4
  %id.addr = alloca i64, align 8
  %name.addr = alloca ptr, align 8
  %client = alloca ptr, align 8
  store i64 %id, ptr %id.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load i64, ptr %id.addr, align 8
  %call = call ptr @lookupClientByID(i64 noundef %0)
  store ptr %call, ptr %client, align 8
  %1 = load ptr, ptr %client, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #15
  store i32 2, ptr %call1, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %client, align 8
  %3 = load ptr, ptr %name.addr, align 8
  %call2 = call i32 @clientSetName(ptr noundef %2, ptr noundef %3, ptr noundef null)
  %cmp3 = icmp eq i32 %call2, -1
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call ptr @__errno_location() #15
  store i32 22, ptr %call5, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare i32 @clientSetName(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_PublishMessage(ptr noundef %ctx, ptr noundef %channel, ptr noundef %message) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %channel.addr = alloca ptr, align 8
  %message.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %channel, ptr %channel.addr, align 8
  store ptr %message, ptr %message.addr, align 8
  %0 = load ptr, ptr %channel.addr, align 8
  %1 = load ptr, ptr %message.addr, align 8
  %call = call i32 @pubsubPublishMessageAndPropagateToCluster(ptr noundef %0, ptr noundef %1, i32 noundef 0)
  ret i32 %call
}

declare i32 @pubsubPublishMessageAndPropagateToCluster(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_PublishMessageShard(ptr noundef %ctx, ptr noundef %channel, ptr noundef %message) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %channel.addr = alloca ptr, align 8
  %message.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %channel, ptr %channel.addr, align 8
  store ptr %message, ptr %message.addr, align 8
  %0 = load ptr, ptr %channel.addr, align 8
  %1 = load ptr, ptr %message.addr, align 8
  %call = call i32 @pubsubPublishMessageAndPropagateToCluster(ptr noundef %0, ptr noundef %1, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetSelectedDb(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %id, align 8
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetContextFlags(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %flags = alloca i32, align 4
  %c = alloca ptr, align 8
  %level = alloca float, align 4
  %retval100 = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 0, ptr %flags, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end30

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %client, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.then2, label %if.end18

if.then2:                                         ; preds = %if.then
  %3 = load ptr, ptr %ctx.addr, align 8
  %client3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %client3, align 8
  %flags4 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %flags4, align 8
  %and = and i64 %5, 2199023255552
  %tobool5 = icmp ne i64 %and, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then2
  %6 = load i32, ptr %flags, align 4
  %or = or i32 %6, 2097152
  store i32 %or, ptr %flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then2
  %7 = load ptr, ptr %ctx.addr, align 8
  %client7 = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %client7, align 8
  %flags8 = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 1
  %9 = load i64, ptr %flags8, align 8
  %and9 = and i64 %9, 2
  %tobool10 = icmp ne i64 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end
  %10 = load i32, ptr %flags, align 4
  %or12 = or i32 %10, 4096
  store i32 %or12, ptr %flags, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end
  %11 = load ptr, ptr %ctx.addr, align 8
  %client14 = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %client14, align 8
  %resp = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 3
  %13 = load i32, ptr %resp, align 8
  %cmp = icmp eq i32 %13, 3
  br i1 %cmp, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end13
  %14 = load i32, ptr %flags, align 4
  %or16 = or i32 %14, 4194304
  store i32 %or16, ptr %flags, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end13
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.then
  %15 = load ptr, ptr %ctx.addr, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %15, i32 0, i32 3
  %16 = load ptr, ptr %blocked_client, align 8
  %tobool19 = icmp ne ptr %16, null
  br i1 %tobool19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end18
  %17 = load ptr, ptr %ctx.addr, align 8
  %blocked_client20 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %blocked_client20, align 8
  %client21 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %client21, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end18
  %20 = load ptr, ptr %ctx.addr, align 8
  %client22 = getelementptr inbounds %struct.RedisModuleCtx, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %client22, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %19, %cond.true ], [ %21, %cond.false ]
  store ptr %cond, ptr %c, align 8
  %22 = load ptr, ptr %c, align 8
  %tobool23 = icmp ne ptr %22, null
  br i1 %tobool23, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %cond.end
  %23 = load ptr, ptr %c, align 8
  %flags24 = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 1
  %24 = load i64, ptr %flags24, align 8
  %and25 = and i64 %24, 4128
  %tobool26 = icmp ne i64 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %land.lhs.true
  %25 = load i32, ptr %flags, align 4
  %or28 = or i32 %25, 524288
  store i32 %or28, ptr %flags, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %land.lhs.true, %cond.end
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %entry
  %call = call i32 @scriptIsRunning()
  %tobool31 = icmp ne i32 %call, 0
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end30
  %26 = load i32, ptr %flags, align 4
  %or33 = or i32 %26, 1
  store i32 %or33, ptr %flags, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end30
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 30), align 4
  %tobool35 = icmp ne i32 %27, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end34
  %28 = load i32, ptr %flags, align 4
  %or37 = or i32 %28, 2
  store i32 %or37, ptr %flags, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end34
  %29 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool39 = icmp ne i32 %29, 0
  br i1 %tobool39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %if.end38
  %30 = load i32, ptr %flags, align 4
  %or41 = or i32 %30, 32
  store i32 %or41, ptr %flags, align 4
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %if.end38
  %31 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 82), align 8
  %tobool43 = icmp ne i32 %31, 0
  br i1 %tobool43, label %if.then44, label %if.else

if.then44:                                        ; preds = %if.end42
  %32 = load i32, ptr %flags, align 4
  %or45 = or i32 %32, 8388608
  store i32 %or45, ptr %flags, align 4
  br label %if.end50

if.else:                                          ; preds = %if.end42
  %33 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool46 = icmp ne i32 %33, 0
  br i1 %tobool46, label %if.then47, label %if.end49

if.then47:                                        ; preds = %if.else
  %34 = load i32, ptr %flags, align 4
  %or48 = or i32 %34, 8192
  store i32 %or48, ptr %flags, align 4
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %if.else
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then44
  %35 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  %cmp51 = icmp ugt i64 %35, 0
  br i1 %cmp51, label %land.lhs.true52, label %if.end61

land.lhs.true52:                                  ; preds = %if.end50
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool53 = icmp ne ptr %36, null
  br i1 %tobool53, label %lor.lhs.false, label %if.then55

lor.lhs.false:                                    ; preds = %land.lhs.true52
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 299), align 8
  %tobool54 = icmp ne i32 %37, 0
  br i1 %tobool54, label %if.end61, label %if.then55

if.then55:                                        ; preds = %lor.lhs.false, %land.lhs.true52
  %38 = load i32, ptr %flags, align 4
  %or56 = or i32 %38, 256
  store i32 %or56, ptr %flags, align 4
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 316), align 8
  %cmp57 = icmp ne i32 %39, 1792
  br i1 %cmp57, label %if.then58, label %if.end60

if.then58:                                        ; preds = %if.then55
  %40 = load i32, ptr %flags, align 4
  %or59 = or i32 %40, 512
  store i32 %or59, ptr %flags, align 4
  br label %if.end60

if.end60:                                         ; preds = %if.then58, %if.then55
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %lor.lhs.false, %if.end50
  %41 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp62 = icmp ne i32 %41, 0
  br i1 %cmp62, label %if.then63, label %if.end65

if.then63:                                        ; preds = %if.end61
  %42 = load i32, ptr %flags, align 4
  %or64 = or i32 %42, 64
  store i32 %or64, ptr %flags, align 4
  br label %if.end65

if.end65:                                         ; preds = %if.then63, %if.end61
  %43 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 224), align 8
  %cmp66 = icmp sgt i32 %43, 0
  br i1 %cmp66, label %if.then67, label %if.end69

if.then67:                                        ; preds = %if.end65
  %44 = load i32, ptr %flags, align 4
  %or68 = or i32 %44, 128
  store i32 %or68, ptr %flags, align 4
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %if.end65
  %45 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %cmp70 = icmp eq ptr %45, null
  br i1 %cmp70, label %if.then71, label %if.else73

if.then71:                                        ; preds = %if.end69
  %46 = load i32, ptr %flags, align 4
  %or72 = or i32 %46, 4
  store i32 %or72, ptr %flags, align 4
  br label %if.end99

if.else73:                                        ; preds = %if.end69
  %47 = load i32, ptr %flags, align 4
  %or74 = or i32 %47, 8
  store i32 %or74, ptr %flags, align 4
  %48 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 298), align 4
  %tobool75 = icmp ne i32 %48, 0
  br i1 %tobool75, label %if.then76, label %if.end78

if.then76:                                        ; preds = %if.else73
  %49 = load i32, ptr %flags, align 4
  %or77 = or i32 %49, 16
  store i32 %or77, ptr %flags, align 4
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %if.else73
  %50 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp79 = icmp eq i32 %50, 1
  br i1 %cmp79, label %if.then82, label %lor.lhs.false80

lor.lhs.false80:                                  ; preds = %if.end78
  %51 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp81 = icmp eq i32 %51, 2
  br i1 %cmp81, label %if.then82, label %if.else84

if.then82:                                        ; preds = %lor.lhs.false80, %if.end78
  %52 = load i32, ptr %flags, align 4
  %or83 = or i32 %52, 32768
  store i32 %or83, ptr %flags, align 4
  br label %if.end94

if.else84:                                        ; preds = %lor.lhs.false80
  %53 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp85 = icmp eq i32 %53, 11
  br i1 %cmp85, label %if.then86, label %if.else88

if.then86:                                        ; preds = %if.else84
  %54 = load i32, ptr %flags, align 4
  %or87 = or i32 %54, 65536
  store i32 %or87, ptr %flags, align 4
  br label %if.end93

if.else88:                                        ; preds = %if.else84
  %55 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp89 = icmp eq i32 %55, 12
  br i1 %cmp89, label %if.then90, label %if.end92

if.then90:                                        ; preds = %if.else88
  %56 = load i32, ptr %flags, align 4
  %or91 = or i32 %56, 131072
  store i32 %or91, ptr %flags, align 4
  br label %if.end92

if.end92:                                         ; preds = %if.then90, %if.else88
  br label %if.end93

if.end93:                                         ; preds = %if.end92, %if.then86
  br label %if.end94

if.end94:                                         ; preds = %if.end93, %if.then82
  %57 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp95 = icmp ne i32 %57, 12
  br i1 %cmp95, label %if.then96, label %if.end98

if.then96:                                        ; preds = %if.end94
  %58 = load i32, ptr %flags, align 4
  %or97 = or i32 %58, 16384
  store i32 %or97, ptr %flags, align 4
  br label %if.end98

if.end98:                                         ; preds = %if.then96, %if.end94
  br label %if.end99

if.end99:                                         ; preds = %if.end98, %if.then71
  %call101 = call i32 @getMaxmemoryState(ptr noundef null, ptr noundef null, ptr noundef null, ptr noundef %level)
  store i32 %call101, ptr %retval100, align 4
  %59 = load i32, ptr %retval100, align 4
  %cmp102 = icmp eq i32 %59, -1
  br i1 %cmp102, label %if.then103, label %if.end105

if.then103:                                       ; preds = %if.end99
  %60 = load i32, ptr %flags, align 4
  %or104 = or i32 %60, 1024
  store i32 %or104, ptr %flags, align 4
  br label %if.end105

if.end105:                                        ; preds = %if.then103, %if.end99
  %61 = load float, ptr %level, align 4
  %conv = fpext float %61 to double
  %cmp106 = fcmp ogt double %conv, 7.500000e-01
  br i1 %cmp106, label %if.then108, label %if.end110

if.then108:                                       ; preds = %if.end105
  %62 = load i32, ptr %flags, align 4
  %or109 = or i32 %62, 2048
  store i32 %or109, ptr %flags, align 4
  br label %if.end110

if.end110:                                        ; preds = %if.then108, %if.end105
  %call111 = call i32 @hasActiveChildProcess()
  %tobool112 = icmp ne i32 %call111, 0
  br i1 %tobool112, label %if.then113, label %if.end115

if.then113:                                       ; preds = %if.end110
  %63 = load i32, ptr %flags, align 4
  %or114 = or i32 %63, 262144
  store i32 %or114, ptr %flags, align 4
  br label %if.end115

if.end115:                                        ; preds = %if.then113, %if.end110
  %64 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 9), align 8
  %tobool116 = icmp ne i32 %64, 0
  br i1 %tobool116, label %if.then117, label %if.end119

if.then117:                                       ; preds = %if.end115
  %65 = load i32, ptr %flags, align 4
  %or118 = or i32 %65, 1048576
  store i32 %or118, ptr %flags, align 4
  br label %if.end119

if.end119:                                        ; preds = %if.then117, %if.end115
  %66 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 40), align 8
  %len = getelementptr inbounds %struct.list, ptr %66, i32 0, i32 5
  %67 = load i64, ptr %len, align 8
  %cmp120 = icmp ugt i64 %67, 0
  br i1 %cmp120, label %if.then122, label %if.end124

if.then122:                                       ; preds = %if.end119
  %68 = load i32, ptr %flags, align 4
  %or123 = or i32 %68, 16777216
  store i32 %or123, ptr %flags, align 4
  br label %if.end124

if.end124:                                        ; preds = %if.then122, %if.end119
  %69 = load i32, ptr %flags, align 4
  ret i32 %69
}

declare i32 @scriptIsRunning() #1

declare i32 @getMaxmemoryState(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare i32 @hasActiveChildProcess() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_AvoidReplicaTraffic() #0 {
entry:
  %call = call i32 @isPausedActionsWithUpdate(i32 noundef 16)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  ret i32 %lnot.ext
}

declare i32 @isPausedActionsWithUpdate(i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SelectDb(ptr noundef %ctx, i32 noundef %newid) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %newid.addr = alloca i32, align 4
  %retval1 = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %newid, ptr %newid.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %2 = load i32, ptr %newid.addr, align 4
  %call = call i32 @selectDb(ptr noundef %1, i32 noundef %2)
  store i32 %call, ptr %retval1, align 4
  %3 = load i32, ptr %retval1, align 4
  %cmp = icmp eq i32 %3, 0
  %cond = select i1 %cmp, i32 0, i32 1
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_KeyExists(ptr noundef %ctx, ptr noundef %keyname) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %keyname.addr = alloca ptr, align 8
  %value = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %keyname, ptr %keyname.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %db, align 8
  %3 = load ptr, ptr %keyname.addr, align 8
  %call = call ptr @lookupKeyReadWithFlags(ptr noundef %2, ptr noundef %3, i32 noundef 1)
  store ptr %call, ptr %value, align 8
  %4 = load ptr, ptr %value, align 8
  %cmp = icmp ne ptr %4, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare ptr @lookupKeyReadWithFlags(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_OpenKey(ptr noundef %ctx, ptr noundef %keyname, i32 noundef %mode) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %keyname.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %kp = alloca ptr, align 8
  %value = alloca ptr, align 8
  %flags = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %keyname, ptr %keyname.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store i32 0, ptr %flags, align 4
  %0 = load i32, ptr %mode.addr, align 4
  %and = and i32 %0, 65536
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 1, i32 0
  %1 = load i32, ptr %flags, align 4
  %or = or i32 %1, %cond
  store i32 %or, ptr %flags, align 4
  %2 = load i32, ptr %mode.addr, align 4
  %and1 = and i32 %2, 131072
  %tobool2 = icmp ne i32 %and1, 0
  %cond3 = select i1 %tobool2, i32 2, i32 0
  %3 = load i32, ptr %flags, align 4
  %or4 = or i32 %3, %cond3
  store i32 %or4, ptr %flags, align 4
  %4 = load i32, ptr %mode.addr, align 4
  %and5 = and i32 %4, 262144
  %tobool6 = icmp ne i32 %and5, 0
  %cond7 = select i1 %tobool6, i32 4, i32 0
  %5 = load i32, ptr %flags, align 4
  %or8 = or i32 %5, %cond7
  store i32 %or8, ptr %flags, align 4
  %6 = load i32, ptr %mode.addr, align 4
  %and9 = and i32 %6, 524288
  %tobool10 = icmp ne i32 %and9, 0
  %cond11 = select i1 %tobool10, i32 16, i32 0
  %7 = load i32, ptr %flags, align 4
  %or12 = or i32 %7, %cond11
  store i32 %or12, ptr %flags, align 4
  %8 = load i32, ptr %mode.addr, align 4
  %and13 = and i32 %8, 1048576
  %tobool14 = icmp ne i32 %and13, 0
  %cond15 = select i1 %tobool14, i32 23, i32 0
  %9 = load i32, ptr %flags, align 4
  %or16 = or i32 %9, %cond15
  store i32 %or16, ptr %flags, align 4
  %10 = load i32, ptr %mode.addr, align 4
  %and17 = and i32 %10, 2
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %db, align 8
  %14 = load ptr, ptr %keyname.addr, align 8
  %15 = load i32, ptr %flags, align 4
  %call = call ptr @lookupKeyWriteWithFlags(ptr noundef %13, ptr noundef %14, i32 noundef %15)
  store ptr %call, ptr %value, align 8
  br label %if.end23

if.else:                                          ; preds = %entry
  %16 = load ptr, ptr %ctx.addr, align 8
  %client19 = getelementptr inbounds %struct.RedisModuleCtx, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %client19, align 8
  %db20 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %db20, align 8
  %19 = load ptr, ptr %keyname.addr, align 8
  %20 = load i32, ptr %flags, align 4
  %call21 = call ptr @lookupKeyReadWithFlags(ptr noundef %18, ptr noundef %19, i32 noundef %20)
  store ptr %call21, ptr %value, align 8
  %21 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %21, null
  br i1 %cmp, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.else
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end23

if.end23:                                         ; preds = %if.end, %if.then
  %call24 = call noalias ptr @zmalloc(i64 noundef 128) #11
  store ptr %call24, ptr %kp, align 8
  %22 = load ptr, ptr %kp, align 8
  %23 = load ptr, ptr %ctx.addr, align 8
  %24 = load ptr, ptr %keyname.addr, align 8
  %25 = load ptr, ptr %value, align 8
  %26 = load i32, ptr %mode.addr, align 4
  call void @moduleInitKey(ptr noundef %22, ptr noundef %23, ptr noundef %24, ptr noundef %25, i32 noundef %26)
  %27 = load ptr, ptr %ctx.addr, align 8
  %28 = load ptr, ptr %kp, align 8
  call void @autoMemoryAdd(ptr noundef %27, i32 noundef 0, ptr noundef %28)
  %29 = load ptr, ptr %kp, align 8
  store ptr %29, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end23, %if.then22
  %30 = load ptr, ptr %retval, align 8
  ret ptr %30
}

declare ptr @lookupKeyWriteWithFlags(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @moduleInitKey(ptr noundef %kp, ptr noundef %ctx, ptr noundef %keyname, ptr noundef %value, i32 noundef %mode) #0 {
entry:
  %kp.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %keyname.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  store ptr %kp, ptr %kp.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %keyname, ptr %keyname.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %kp.addr, align 8
  %ctx1 = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 0
  store ptr %0, ptr %ctx1, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %db, align 8
  %5 = load ptr, ptr %kp.addr, align 8
  %db2 = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 1
  store ptr %4, ptr %db2, align 8
  %6 = load ptr, ptr %keyname.addr, align 8
  %7 = load ptr, ptr %kp.addr, align 8
  %key = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 2
  store ptr %6, ptr %key, align 8
  %8 = load ptr, ptr %keyname.addr, align 8
  call void @incrRefCount(ptr noundef %8)
  %9 = load ptr, ptr %value.addr, align 8
  %10 = load ptr, ptr %kp.addr, align 8
  %value3 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 3
  store ptr %9, ptr %value3, align 8
  %11 = load ptr, ptr %kp.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 4
  store ptr null, ptr %iter, align 8
  %12 = load i32, ptr %mode.addr, align 4
  %13 = load ptr, ptr %kp.addr, align 8
  %mode4 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 5
  store i32 %12, ptr %mode4, align 8
  %14 = load ptr, ptr %kp.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %14, i32 0, i32 3
  %15 = load ptr, ptr %value5, align 8
  %tobool = icmp ne ptr %15, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load ptr, ptr %kp.addr, align 8
  call void @moduleInitKeyTypeSpecific(ptr noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetOpenKeyModesAll() #0 {
entry:
  ret i32 2031619
}

; Function Attrs: nounwind uwtable
define internal void @moduleCloseKey(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %signal = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %ctx, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load ptr, ptr %key.addr, align 8
  %ctx1 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %ctx1, align 8
  %module2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %module2, align 8
  %options = getelementptr inbounds %struct.RedisModule, ptr %5, i32 0, i32 12
  %6 = load i32, ptr %options, align 4
  %and = and i32 %6, 2
  %tobool3 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool3, true
  %lnot.ext = zext i1 %lnot to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %lnot.ext, %cond.true ], [ 1, %cond.false ]
  store i32 %cond, ptr %signal, align 4
  %7 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %mode, align 8
  %and4 = and i32 %8, 2
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end
  %9 = load i32, ptr %signal, align 4
  %tobool6 = icmp ne i32 %9, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load ptr, ptr %key.addr, align 8
  %ctx7 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %ctx7, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %client, align 8
  %13 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %db, align 8
  %15 = load ptr, ptr %key.addr, align 8
  %key8 = getelementptr inbounds %struct.RedisModuleKey, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %key8, align 8
  call void @signalModifiedKey(ptr noundef %12, ptr noundef %14, ptr noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %cond.end
  %17 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %value, align 8
  %tobool9 = icmp ne ptr %18, null
  br i1 %tobool9, label %if.then10, label %if.end21

if.then10:                                        ; preds = %if.end
  %19 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %19, i32 0, i32 4
  %20 = load ptr, ptr %iter, align 8
  %tobool11 = icmp ne ptr %20, null
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then10
  %21 = load ptr, ptr %key.addr, align 8
  call void @moduleFreeKeyIterator(ptr noundef %21)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then10
  %22 = load ptr, ptr %key.addr, align 8
  %value14 = getelementptr inbounds %struct.RedisModuleKey, ptr %22, i32 0, i32 3
  %23 = load ptr, ptr %value14, align 8
  %bf.load = load i32, ptr %23, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %sw.epilog [
    i32 3, label %sw.bb
    i32 6, label %sw.bb15
  ]

sw.bb:                                            ; preds = %if.end13
  %24 = load ptr, ptr %key.addr, align 8
  call void @RM_ZsetRangeStop(ptr noundef %24)
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.end13
  %25 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %25, i32 0, i32 6
  %signalready = getelementptr inbounds %struct.anon.1, ptr %u, i32 0, i32 2
  %26 = load i32, ptr %signalready, align 8
  %tobool16 = icmp ne i32 %26, 0
  br i1 %tobool16, label %if.then17, label %if.end20

if.then17:                                        ; preds = %sw.bb15
  %27 = load ptr, ptr %key.addr, align 8
  %db18 = getelementptr inbounds %struct.RedisModuleKey, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %db18, align 8
  %29 = load ptr, ptr %key.addr, align 8
  %key19 = getelementptr inbounds %struct.RedisModuleKey, ptr %29, i32 0, i32 2
  %30 = load ptr, ptr %key19, align 8
  call void @signalKeyAsReady(ptr noundef %28, ptr noundef %30, i32 noundef 6)
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %sw.bb15
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end20, %sw.bb, %if.end13
  br label %if.end21

if.end21:                                         ; preds = %sw.epilog, %if.end
  %31 = load ptr, ptr %key.addr, align 8
  %iter22 = getelementptr inbounds %struct.RedisModuleKey, ptr %31, i32 0, i32 4
  %32 = load ptr, ptr %iter22, align 8
  %cmp = icmp eq ptr %32, null
  %lnot23 = xor i1 %cmp, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv = sext i32 %lnot.ext26 to i64
  %tobool27 = icmp ne i64 %conv, 0
  br i1 %tobool27, label %cond.true28, label %cond.false29

cond.true28:                                      ; preds = %if.end21
  br label %cond.end30

cond.false29:                                     ; preds = %if.end21
  call void @_serverAssert(ptr noundef @.str.540, ptr noundef @.str.2, i32 noundef 4097)
  call void @abort() #13
  unreachable

33:                                               ; No predecessors!
  br label %cond.end30

cond.end30:                                       ; preds = %33, %cond.true28
  %34 = load ptr, ptr %key.addr, align 8
  %key31 = getelementptr inbounds %struct.RedisModuleKey, ptr %34, i32 0, i32 2
  %35 = load ptr, ptr %key31, align 8
  call void @decrRefCount(ptr noundef %35)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_KeyType(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb4
    i32 3, label %sw.bb5
    i32 4, label %sw.bb6
    i32 5, label %sw.bb7
    i32 6, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb3:                                           ; preds = %if.end
  store i32 2, ptr %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %if.end
  store i32 4, ptr %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %if.end
  store i32 5, ptr %retval, align 4
  br label %return

sw.bb6:                                           ; preds = %if.end
  store i32 3, ptr %retval, align 4
  br label %return

sw.bb7:                                           ; preds = %if.end
  store i32 6, ptr %retval, align 4
  br label %return

sw.bb8:                                           ; preds = %if.end
  store i32 7, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_ValueLength(ptr noundef %key) #0 {
entry:
  %retval = alloca i64, align 8
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  switch i32 %bf.clear, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb4
    i32 2, label %sw.bb7
    i32 3, label %sw.bb10
    i32 4, label %sw.bb13
    i32 6, label %sw.bb16
  ]

sw.bb:                                            ; preds = %if.end
  %5 = load ptr, ptr %key.addr, align 8
  %value3 = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %value3, align 8
  %call = call i64 @stringObjectLen(ptr noundef %6)
  store i64 %call, ptr %retval, align 8
  br label %return

sw.bb4:                                           ; preds = %if.end
  %7 = load ptr, ptr %key.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %value5, align 8
  %call6 = call i64 @listTypeLength(ptr noundef %8)
  store i64 %call6, ptr %retval, align 8
  br label %return

sw.bb7:                                           ; preds = %if.end
  %9 = load ptr, ptr %key.addr, align 8
  %value8 = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 3
  %10 = load ptr, ptr %value8, align 8
  %call9 = call i64 @setTypeSize(ptr noundef %10)
  store i64 %call9, ptr %retval, align 8
  br label %return

sw.bb10:                                          ; preds = %if.end
  %11 = load ptr, ptr %key.addr, align 8
  %value11 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %value11, align 8
  %call12 = call i64 @zsetLength(ptr noundef %12)
  store i64 %call12, ptr %retval, align 8
  br label %return

sw.bb13:                                          ; preds = %if.end
  %13 = load ptr, ptr %key.addr, align 8
  %value14 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %value14, align 8
  %call15 = call i64 @hashTypeLength(ptr noundef %14)
  store i64 %call15, ptr %retval, align 8
  br label %return

sw.bb16:                                          ; preds = %if.end
  %15 = load ptr, ptr %key.addr, align 8
  %value17 = getelementptr inbounds %struct.RedisModuleKey, ptr %15, i32 0, i32 3
  %16 = load ptr, ptr %value17, align 8
  %call18 = call i64 @streamLength(ptr noundef %16)
  store i64 %call18, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %if.end
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb16, %sw.bb13, %sw.bb10, %sw.bb7, %sw.bb4, %sw.bb, %if.then
  %17 = load i64, ptr %retval, align 8
  ret i64 %17
}

declare i64 @stringObjectLen(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DeleteKey(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %db, align 8
  %6 = load ptr, ptr %key.addr, align 8
  %key3 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %key3, align 8
  %call = call i32 @dbDelete(ptr noundef %5, ptr noundef %7)
  %8 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  store ptr null, ptr %value4, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_UnlinkKey(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %db, align 8
  %6 = load ptr, ptr %key.addr, align 8
  %key3 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %key3, align 8
  %call = call i32 @dbAsyncDelete(ptr noundef %5, ptr noundef %7)
  %8 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  store ptr null, ptr %value4, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

declare i32 @dbAsyncDelete(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_GetExpire(ptr noundef %key) #0 {
entry:
  %retval = alloca i64, align 8
  %key.addr = alloca ptr, align 8
  %expire = alloca i64, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %db, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %key1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %key1, align 8
  %call = call i64 @getExpire(ptr noundef %1, ptr noundef %3)
  store i64 %call, ptr %expire, align 8
  %4 = load i64, ptr %expire, align 8
  %cmp = icmp eq i64 %4, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %value, align 8
  %cmp2 = icmp eq ptr %6, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %call3 = call i64 @commandTimeSnapshot()
  %7 = load i64, ptr %expire, align 8
  %sub = sub nsw i64 %7, %call3
  store i64 %sub, ptr %expire, align 8
  %8 = load i64, ptr %expire, align 8
  %cmp4 = icmp sge i64 %8, 0
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %9 = load i64, ptr %expire, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %9, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

declare i64 @getExpire(ptr noundef, ptr noundef) #1

declare i64 @commandTimeSnapshot() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetExpire(ptr noundef %key, i64 noundef %expire) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %expire.addr = alloca i64, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %expire, ptr %expire.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %lor.lhs.false1

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %4 = load i64, ptr %expire.addr, align 8
  %cmp2 = icmp slt i64 %4, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false1
  %5 = load i64, ptr %expire.addr, align 8
  %cmp3 = icmp ne i64 %5, -1
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false1
  %6 = load i64, ptr %expire.addr, align 8
  %cmp4 = icmp ne i64 %6, -1
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %call = call i64 @commandTimeSnapshot()
  %7 = load i64, ptr %expire.addr, align 8
  %add = add nsw i64 %7, %call
  store i64 %add, ptr %expire.addr, align 8
  %8 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %ctx, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %client, align 8
  %11 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %db, align 8
  %13 = load ptr, ptr %key.addr, align 8
  %key6 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %key6, align 8
  %15 = load i64, ptr %expire.addr, align 8
  call void @setExpire(ptr noundef %10, ptr noundef %12, ptr noundef %14, i64 noundef %15)
  br label %if.end10

if.else:                                          ; preds = %if.end
  %16 = load ptr, ptr %key.addr, align 8
  %db7 = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %db7, align 8
  %18 = load ptr, ptr %key.addr, align 8
  %key8 = getelementptr inbounds %struct.RedisModuleKey, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %key8, align 8
  %call9 = call i32 @removeExpire(ptr noundef %17, ptr noundef %19)
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then5
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

declare void @setExpire(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #1

declare i32 @removeExpire(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_GetAbsExpire(ptr noundef %key) #0 {
entry:
  %retval = alloca i64, align 8
  %key.addr = alloca ptr, align 8
  %expire = alloca i64, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %db, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %key1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %key1, align 8
  %call = call i64 @getExpire(ptr noundef %1, ptr noundef %3)
  store i64 %call, ptr %expire, align 8
  %4 = load i64, ptr %expire, align 8
  %cmp = icmp eq i64 %4, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %value, align 8
  %cmp2 = icmp eq ptr %6, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load i64, ptr %expire, align 8
  store i64 %7, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i64, ptr %retval, align 8
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetAbsExpire(ptr noundef %key, i64 noundef %expire) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %expire.addr = alloca i64, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %expire, ptr %expire.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %lor.lhs.false1

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %4 = load i64, ptr %expire.addr, align 8
  %cmp2 = icmp slt i64 %4, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false1
  %5 = load i64, ptr %expire.addr, align 8
  %cmp3 = icmp ne i64 %5, -1
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false1
  %6 = load i64, ptr %expire.addr, align 8
  %cmp4 = icmp ne i64 %6, -1
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %7 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %ctx, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %client, align 8
  %10 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %db, align 8
  %12 = load ptr, ptr %key.addr, align 8
  %key6 = getelementptr inbounds %struct.RedisModuleKey, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %key6, align 8
  %14 = load i64, ptr %expire.addr, align 8
  call void @setExpire(ptr noundef %9, ptr noundef %11, ptr noundef %13, i64 noundef %14)
  br label %if.end9

if.else:                                          ; preds = %if.end
  %15 = load ptr, ptr %key.addr, align 8
  %db7 = getelementptr inbounds %struct.RedisModuleKey, ptr %15, i32 0, i32 1
  %16 = load ptr, ptr %db7, align 8
  %17 = load ptr, ptr %key.addr, align 8
  %key8 = getelementptr inbounds %struct.RedisModuleKey, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %key8, align 8
  %call = call i32 @removeExpire(ptr noundef %16, ptr noundef %18)
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then5
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ResetDataset(i32 noundef %restart_aof, i32 noundef %async) #0 {
entry:
  %restart_aof.addr = alloca i32, align 4
  %async.addr = alloca i32, align 4
  store i32 %restart_aof, ptr %restart_aof.addr, align 4
  store i32 %async, ptr %async.addr, align 4
  %0 = load i32, ptr %restart_aof.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @stopAppendOnly()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %2 = load i32, ptr %async.addr, align 4
  %tobool1 = icmp ne i32 %2, 0
  %cond = select i1 %tobool1, i32 1, i32 0
  %or = or i32 %cond, 2
  call void @flushAllDataAndResetRDB(i32 noundef %or)
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 184), align 4
  %tobool2 = icmp ne i32 %3, 0
  br i1 %tobool2, label %land.lhs.true3, label %if.end6

land.lhs.true3:                                   ; preds = %if.end
  %4 = load i32, ptr %restart_aof.addr, align 4
  %tobool4 = icmp ne i32 %4, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true3
  call void @restartAOFAfterSYNC()
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true3, %if.end
  ret void
}

declare void @stopAppendOnly() #1

declare void @flushAllDataAndResetRDB(i32 noundef) #1

declare void @restartAOFAfterSYNC() #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_DbSize(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %db, align 8
  %call = call i64 @dbSize(ptr noundef %2, i32 noundef 0)
  ret i64 %call
}

declare i64 @dbSize(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_RandomKey(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %key = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %db, align 8
  %call = call ptr @dbRandomKey(ptr noundef %2)
  store ptr %call, ptr %key, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load ptr, ptr %key, align 8
  call void @autoMemoryAdd(ptr noundef %3, i32 noundef 1, ptr noundef %4)
  %5 = load ptr, ptr %key, align 8
  ret ptr %5
}

declare ptr @dbRandomKey(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetKeyNameFromOptCtx(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %from_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %from_key, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetToKeyNameFromOptCtx(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %to_key, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetDbIdFromOptCtx(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %from_dbid, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetToDbIdFromOptCtx(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %to_dbid, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringSet(ptr noundef %key, ptr noundef %str) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %iter, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %call = call i32 @RM_DeleteKey(ptr noundef %4)
  %5 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %ctx, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %client, align 8
  %8 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %db, align 8
  %10 = load ptr, ptr %key.addr, align 8
  %key2 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %key2, align 8
  %12 = load ptr, ptr %str.addr, align 8
  call void @setKey(ptr noundef %7, ptr noundef %9, ptr noundef %11, ptr noundef %12, i32 noundef 2)
  %13 = load ptr, ptr %str.addr, align 8
  %14 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %14, i32 0, i32 3
  store ptr %13, ptr %value, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

declare void @setKey(ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_StringDMA(ptr noundef %key, ptr noundef %len, i32 noundef %mode) #0 {
entry:
  %retval = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %emptystring = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store ptr @.str.42, ptr %emptystring, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %len.addr, align 8
  store i64 0, ptr %2, align 8
  %3 = load ptr, ptr %emptystring, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp2 = icmp ne i32 %bf.clear, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load i32, ptr %mode.addr, align 4
  %and = and i32 %6, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end4
  %7 = load ptr, ptr %key.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %value5, align 8
  %bf.load6 = load i32, ptr %8, align 8
  %bf.lshr = lshr i32 %bf.load6, 4
  %bf.clear7 = and i32 %bf.lshr, 15
  %cmp8 = icmp ne i32 %bf.clear7, 0
  br i1 %cmp8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %lor.lhs.false, %if.end4
  %9 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %db, align 8
  %11 = load ptr, ptr %key.addr, align 8
  %key10 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %key10, align 8
  %13 = load ptr, ptr %key.addr, align 8
  %value11 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %value11, align 8
  %call = call ptr @dbUnshareStringValue(ptr noundef %10, ptr noundef %12, ptr noundef %14)
  %15 = load ptr, ptr %key.addr, align 8
  %value12 = getelementptr inbounds %struct.RedisModuleKey, ptr %15, i32 0, i32 3
  store ptr %call, ptr %value12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then9, %lor.lhs.false
  %16 = load ptr, ptr %key.addr, align 8
  %value14 = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %value14, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %ptr, align 8
  %call15 = call i64 @sdslen(ptr noundef %18)
  %19 = load ptr, ptr %len.addr, align 8
  store i64 %call15, ptr %19, align 8
  %20 = load ptr, ptr %key.addr, align 8
  %value16 = getelementptr inbounds %struct.RedisModuleKey, ptr %20, i32 0, i32 3
  %21 = load ptr, ptr %value16, align 8
  %ptr17 = getelementptr inbounds %struct.redisObject, ptr %21, i32 0, i32 2
  %22 = load ptr, ptr %ptr17, align 8
  store ptr %22, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end13, %if.then3, %if.then
  %23 = load ptr, ptr %retval, align 8
  ret ptr %23
}

declare ptr @dbUnshareStringValue(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StringTruncate(ptr noundef %key, i64 noundef %newlen) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %newlen.addr = alloca i64, align 8
  %o = alloca ptr, align 8
  %curlen = alloca i64, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %newlen, ptr %newlen.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %6 = load i64, ptr %newlen.addr, align 8
  %cmp5 = icmp ugt i64 %6, 536870912
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  %7 = load ptr, ptr %key.addr, align 8
  %value8 = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %value8, align 8
  %cmp9 = icmp eq ptr %8, null
  br i1 %cmp9, label %land.lhs.true10, label %if.end13

land.lhs.true10:                                  ; preds = %if.end7
  %9 = load i64, ptr %newlen.addr, align 8
  %cmp11 = icmp eq i64 %9, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %land.lhs.true10
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %land.lhs.true10, %if.end7
  %10 = load ptr, ptr %key.addr, align 8
  %value14 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %value14, align 8
  %cmp15 = icmp eq ptr %11, null
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end13
  %12 = load i64, ptr %newlen.addr, align 8
  %call = call ptr @sdsnewlen(ptr noundef null, i64 noundef %12)
  %call17 = call ptr @createObject(i32 noundef 0, ptr noundef %call)
  store ptr %call17, ptr %o, align 8
  %13 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %ctx, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %client, align 8
  %16 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %db, align 8
  %18 = load ptr, ptr %key.addr, align 8
  %key18 = getelementptr inbounds %struct.RedisModuleKey, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %key18, align 8
  %20 = load ptr, ptr %o, align 8
  call void @setKey(ptr noundef %15, ptr noundef %17, ptr noundef %19, ptr noundef %20, i32 noundef 2)
  %21 = load ptr, ptr %o, align 8
  %22 = load ptr, ptr %key.addr, align 8
  %value19 = getelementptr inbounds %struct.RedisModuleKey, ptr %22, i32 0, i32 3
  store ptr %21, ptr %value19, align 8
  %23 = load ptr, ptr %o, align 8
  call void @decrRefCount(ptr noundef %23)
  br label %if.end55

if.else:                                          ; preds = %if.end13
  %24 = load ptr, ptr %key.addr, align 8
  %db20 = getelementptr inbounds %struct.RedisModuleKey, ptr %24, i32 0, i32 1
  %25 = load ptr, ptr %db20, align 8
  %26 = load ptr, ptr %key.addr, align 8
  %key21 = getelementptr inbounds %struct.RedisModuleKey, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %key21, align 8
  %28 = load ptr, ptr %key.addr, align 8
  %value22 = getelementptr inbounds %struct.RedisModuleKey, ptr %28, i32 0, i32 3
  %29 = load ptr, ptr %value22, align 8
  %call23 = call ptr @dbUnshareStringValue(ptr noundef %25, ptr noundef %27, ptr noundef %29)
  %30 = load ptr, ptr %key.addr, align 8
  %value24 = getelementptr inbounds %struct.RedisModuleKey, ptr %30, i32 0, i32 3
  store ptr %call23, ptr %value24, align 8
  %31 = load ptr, ptr %key.addr, align 8
  %value25 = getelementptr inbounds %struct.RedisModuleKey, ptr %31, i32 0, i32 3
  %32 = load ptr, ptr %value25, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %ptr, align 8
  %call26 = call i64 @sdslen(ptr noundef %33)
  store i64 %call26, ptr %curlen, align 8
  %34 = load i64, ptr %newlen.addr, align 8
  %35 = load i64, ptr %curlen, align 8
  %cmp27 = icmp ugt i64 %34, %35
  br i1 %cmp27, label %if.then28, label %if.else34

if.then28:                                        ; preds = %if.else
  %36 = load ptr, ptr %key.addr, align 8
  %value29 = getelementptr inbounds %struct.RedisModuleKey, ptr %36, i32 0, i32 3
  %37 = load ptr, ptr %value29, align 8
  %ptr30 = getelementptr inbounds %struct.redisObject, ptr %37, i32 0, i32 2
  %38 = load ptr, ptr %ptr30, align 8
  %39 = load i64, ptr %newlen.addr, align 8
  %call31 = call ptr @sdsgrowzero(ptr noundef %38, i64 noundef %39)
  %40 = load ptr, ptr %key.addr, align 8
  %value32 = getelementptr inbounds %struct.RedisModuleKey, ptr %40, i32 0, i32 3
  %41 = load ptr, ptr %value32, align 8
  %ptr33 = getelementptr inbounds %struct.redisObject, ptr %41, i32 0, i32 2
  store ptr %call31, ptr %ptr33, align 8
  br label %if.end54

if.else34:                                        ; preds = %if.else
  %42 = load i64, ptr %newlen.addr, align 8
  %43 = load i64, ptr %curlen, align 8
  %cmp35 = icmp ult i64 %42, %43
  br i1 %cmp35, label %if.then36, label %if.end53

if.then36:                                        ; preds = %if.else34
  %44 = load ptr, ptr %key.addr, align 8
  %value37 = getelementptr inbounds %struct.RedisModuleKey, ptr %44, i32 0, i32 3
  %45 = load ptr, ptr %value37, align 8
  %ptr38 = getelementptr inbounds %struct.redisObject, ptr %45, i32 0, i32 2
  %46 = load ptr, ptr %ptr38, align 8
  %47 = load i64, ptr %newlen.addr, align 8
  call void @sdssubstr(ptr noundef %46, i64 noundef 0, i64 noundef %47)
  %48 = load ptr, ptr %key.addr, align 8
  %value39 = getelementptr inbounds %struct.RedisModuleKey, ptr %48, i32 0, i32 3
  %49 = load ptr, ptr %value39, align 8
  %ptr40 = getelementptr inbounds %struct.redisObject, ptr %49, i32 0, i32 2
  %50 = load ptr, ptr %ptr40, align 8
  %call41 = call i64 @sdslen(ptr noundef %50)
  %51 = load ptr, ptr %key.addr, align 8
  %value42 = getelementptr inbounds %struct.RedisModuleKey, ptr %51, i32 0, i32 3
  %52 = load ptr, ptr %value42, align 8
  %ptr43 = getelementptr inbounds %struct.redisObject, ptr %52, i32 0, i32 2
  %53 = load ptr, ptr %ptr43, align 8
  %call44 = call i64 @sdsavail(ptr noundef %53)
  %cmp45 = icmp ult i64 %call41, %call44
  br i1 %cmp45, label %if.then46, label %if.end52

if.then46:                                        ; preds = %if.then36
  %54 = load ptr, ptr %key.addr, align 8
  %value47 = getelementptr inbounds %struct.RedisModuleKey, ptr %54, i32 0, i32 3
  %55 = load ptr, ptr %value47, align 8
  %ptr48 = getelementptr inbounds %struct.redisObject, ptr %55, i32 0, i32 2
  %56 = load ptr, ptr %ptr48, align 8
  %call49 = call ptr @sdsRemoveFreeSpace(ptr noundef %56, i32 noundef 0)
  %57 = load ptr, ptr %key.addr, align 8
  %value50 = getelementptr inbounds %struct.RedisModuleKey, ptr %57, i32 0, i32 3
  %58 = load ptr, ptr %value50, align 8
  %ptr51 = getelementptr inbounds %struct.redisObject, ptr %58, i32 0, i32 2
  store ptr %call49, ptr %ptr51, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.then46, %if.then36
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.else34
  br label %if.end54

if.end54:                                         ; preds = %if.end53, %if.then28
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.then16
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end55, %if.then12, %if.then6, %if.then3, %if.then
  %59 = load i32, ptr %retval, align 4
  ret i32 %59
}

declare ptr @sdsgrowzero(ptr noundef, i64 noundef) #1

declare void @sdssubstr(ptr noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @sdsavail(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %flags = alloca i8, align 1
  %sh = alloca ptr, align 8
  %sh6 = alloca ptr, align 8
  %sh15 = alloca ptr, align 8
  %sh22 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %flags, align 1
  %2 = load i8, ptr %flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb5
    i32 3, label %sw.bb14
    i32 4, label %sw.bb21
  ]

sw.bb:                                            ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 -3
  store ptr %add.ptr, ptr %sh, align 8
  %4 = load ptr, ptr %sh, align 8
  %alloc = getelementptr inbounds %struct.sdshdr8, ptr %4, i32 0, i32 1
  %5 = load i8, ptr %alloc, align 1
  %conv2 = zext i8 %5 to i32
  %6 = load ptr, ptr %sh, align 8
  %len = getelementptr inbounds %struct.sdshdr8, ptr %6, i32 0, i32 0
  %7 = load i8, ptr %len, align 1
  %conv3 = zext i8 %7 to i32
  %sub = sub nsw i32 %conv2, %conv3
  %conv4 = sext i32 %sub to i64
  store i64 %conv4, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, ptr %8, i64 -5
  store ptr %add.ptr7, ptr %sh6, align 8
  %9 = load ptr, ptr %sh6, align 8
  %alloc8 = getelementptr inbounds %struct.sdshdr16, ptr %9, i32 0, i32 1
  %10 = load i16, ptr %alloc8, align 1
  %conv9 = zext i16 %10 to i32
  %11 = load ptr, ptr %sh6, align 8
  %len10 = getelementptr inbounds %struct.sdshdr16, ptr %11, i32 0, i32 0
  %12 = load i16, ptr %len10, align 1
  %conv11 = zext i16 %12 to i32
  %sub12 = sub nsw i32 %conv9, %conv11
  %conv13 = sext i32 %sub12 to i64
  store i64 %conv13, ptr %retval, align 8
  br label %return

sw.bb14:                                          ; preds = %entry
  %13 = load ptr, ptr %s.addr, align 8
  %add.ptr16 = getelementptr inbounds i8, ptr %13, i64 -9
  store ptr %add.ptr16, ptr %sh15, align 8
  %14 = load ptr, ptr %sh15, align 8
  %alloc17 = getelementptr inbounds %struct.sdshdr32, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %alloc17, align 1
  %16 = load ptr, ptr %sh15, align 8
  %len18 = getelementptr inbounds %struct.sdshdr32, ptr %16, i32 0, i32 0
  %17 = load i32, ptr %len18, align 1
  %sub19 = sub i32 %15, %17
  %conv20 = zext i32 %sub19 to i64
  store i64 %conv20, ptr %retval, align 8
  br label %return

sw.bb21:                                          ; preds = %entry
  %18 = load ptr, ptr %s.addr, align 8
  %add.ptr23 = getelementptr inbounds i8, ptr %18, i64 -17
  store ptr %add.ptr23, ptr %sh22, align 8
  %19 = load ptr, ptr %sh22, align 8
  %alloc24 = getelementptr inbounds %struct.sdshdr64, ptr %19, i32 0, i32 1
  %20 = load i64, ptr %alloc24, align 1
  %21 = load ptr, ptr %sh22, align 8
  %len25 = getelementptr inbounds %struct.sdshdr64, ptr %21, i32 0, i32 0
  %22 = load i64, ptr %len25, align 1
  %sub26 = sub i64 %20, %22
  store i64 %sub26, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb21, %sw.bb14, %sw.bb5, %sw.bb1, %sw.bb
  %23 = load i64, ptr %retval, align 8
  ret i64 %23
}

declare ptr @sdsRemoveFreeSpace(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleListIteratorSeek(ptr noundef %key, i64 noundef %index, i32 noundef %mode) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %mode.addr = alloca i32, align 4
  %length = alloca i64, align 8
  %dir = alloca i8, align 1
  store ptr %key, ptr %key.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.else
  %3 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 1
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = call ptr @__errno_location() #15
  store i32 95, ptr %call4, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  br label %if.end5

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %key.addr, align 8
  %mode6 = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 5
  %6 = load i32, ptr %mode6, align 8
  %7 = load i32, ptr %mode.addr, align 4
  %and = and i32 %6, %7
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end5
  %call9 = call ptr @__errno_location() #15
  store i32 9, ptr %call9, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end5
  %8 = load ptr, ptr %key.addr, align 8
  %value11 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %value11, align 8
  %call12 = call i64 @listTypeLength(ptr noundef %9)
  store i64 %call12, ptr %length, align 8
  %10 = load i64, ptr %index.addr, align 8
  %11 = load i64, ptr %length, align 8
  %sub = sub nsw i64 0, %11
  %cmp13 = icmp slt i64 %10, %sub
  br i1 %cmp13, label %if.then16, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %if.end10
  %12 = load i64, ptr %index.addr, align 8
  %13 = load i64, ptr %length, align 8
  %cmp15 = icmp sge i64 %12, %13
  br i1 %cmp15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %lor.lhs.false14, %if.end10
  %call17 = call ptr @__errno_location() #15
  store i32 33, ptr %call17, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %lor.lhs.false14
  %14 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %iter, align 8
  %cmp19 = icmp eq ptr %15, null
  br i1 %cmp19, label %if.then20, label %if.end43

if.then20:                                        ; preds = %if.end18
  %16 = load ptr, ptr %key.addr, align 8
  %value21 = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %value21, align 8
  %18 = load i64, ptr %index.addr, align 8
  %call22 = call ptr @listTypeInitIterator(ptr noundef %17, i64 noundef %18, i8 noundef zeroext 1)
  %19 = load ptr, ptr %key.addr, align 8
  %iter23 = getelementptr inbounds %struct.RedisModuleKey, ptr %19, i32 0, i32 4
  store ptr %call22, ptr %iter23, align 8
  %20 = load ptr, ptr %key.addr, align 8
  %iter24 = getelementptr inbounds %struct.RedisModuleKey, ptr %20, i32 0, i32 4
  %21 = load ptr, ptr %iter24, align 8
  %cmp25 = icmp ne ptr %21, null
  %lnot = xor i1 %cmp25, true
  %lnot26 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot26 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool27 = icmp ne i64 %conv, 0
  br i1 %tobool27, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then20
  br label %cond.end

cond.false:                                       ; preds = %if.then20
  call void @_serverAssert(ptr noundef @.str.43, ptr noundef @.str.2, i32 noundef 4440)
  call void @abort() #13
  unreachable

22:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %22, %cond.true
  %23 = load ptr, ptr %key.addr, align 8
  %iter28 = getelementptr inbounds %struct.RedisModuleKey, ptr %23, i32 0, i32 4
  %24 = load ptr, ptr %iter28, align 8
  %25 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %25, i32 0, i32 6
  %entry29 = getelementptr inbounds %struct.anon, ptr %u, i32 0, i32 0
  %call30 = call i32 @listTypeNext(ptr noundef %24, ptr noundef %entry29)
  %tobool31 = icmp ne i32 %call30, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %tobool37 = icmp ne i64 %conv36, 0
  br i1 %tobool37, label %cond.true38, label %cond.false39

cond.true38:                                      ; preds = %cond.end
  br label %cond.end40

cond.false39:                                     ; preds = %cond.end
  call void @_serverAssert(ptr noundef @.str.44, ptr noundef @.str.2, i32 noundef 4441)
  call void @abort() #13
  unreachable

26:                                               ; No predecessors!
  br label %cond.end40

cond.end40:                                       ; preds = %26, %cond.true38
  %27 = load i64, ptr %index.addr, align 8
  %28 = load ptr, ptr %key.addr, align 8
  %u41 = getelementptr inbounds %struct.RedisModuleKey, ptr %28, i32 0, i32 6
  %index42 = getelementptr inbounds %struct.anon, ptr %u41, i32 0, i32 1
  store i64 %27, ptr %index42, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.end18
  %29 = load i64, ptr %index.addr, align 8
  %cmp44 = icmp slt i64 %29, 0
  br i1 %cmp44, label %land.lhs.true, label %if.else51

land.lhs.true:                                    ; preds = %if.end43
  %30 = load ptr, ptr %key.addr, align 8
  %u46 = getelementptr inbounds %struct.RedisModuleKey, ptr %30, i32 0, i32 6
  %index47 = getelementptr inbounds %struct.anon, ptr %u46, i32 0, i32 1
  %31 = load i64, ptr %index47, align 8
  %cmp48 = icmp sge i64 %31, 0
  br i1 %cmp48, label %if.then50, label %if.else51

if.then50:                                        ; preds = %land.lhs.true
  %32 = load i64, ptr %length, align 8
  %33 = load i64, ptr %index.addr, align 8
  %add = add nsw i64 %33, %32
  store i64 %add, ptr %index.addr, align 8
  br label %if.end62

if.else51:                                        ; preds = %land.lhs.true, %if.end43
  %34 = load i64, ptr %index.addr, align 8
  %cmp52 = icmp sge i64 %34, 0
  br i1 %cmp52, label %land.lhs.true54, label %if.end61

land.lhs.true54:                                  ; preds = %if.else51
  %35 = load ptr, ptr %key.addr, align 8
  %u55 = getelementptr inbounds %struct.RedisModuleKey, ptr %35, i32 0, i32 6
  %index56 = getelementptr inbounds %struct.anon, ptr %u55, i32 0, i32 1
  %36 = load i64, ptr %index56, align 8
  %cmp57 = icmp slt i64 %36, 0
  br i1 %cmp57, label %if.then59, label %if.end61

if.then59:                                        ; preds = %land.lhs.true54
  %37 = load i64, ptr %length, align 8
  %38 = load i64, ptr %index.addr, align 8
  %sub60 = sub nsw i64 %38, %37
  store i64 %sub60, ptr %index.addr, align 8
  br label %if.end61

if.end61:                                         ; preds = %if.then59, %land.lhs.true54, %if.else51
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.then50
  %39 = load i64, ptr %index.addr, align 8
  %40 = load ptr, ptr %key.addr, align 8
  %u63 = getelementptr inbounds %struct.RedisModuleKey, ptr %40, i32 0, i32 6
  %index64 = getelementptr inbounds %struct.anon, ptr %u63, i32 0, i32 1
  %41 = load i64, ptr %index64, align 8
  %cmp65 = icmp eq i64 %39, %41
  br i1 %cmp65, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.end62
  store i32 1, ptr %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.end62
  %42 = load ptr, ptr %key.addr, align 8
  %u69 = getelementptr inbounds %struct.RedisModuleKey, ptr %42, i32 0, i32 6
  %index70 = getelementptr inbounds %struct.anon, ptr %u69, i32 0, i32 1
  %43 = load i64, ptr %index70, align 8
  %44 = load i64, ptr %index.addr, align 8
  %cmp71 = icmp slt i64 %43, %44
  %cond = select i1 %cmp71, i32 1, i32 0
  %conv73 = trunc i32 %cond to i8
  store i8 %conv73, ptr %dir, align 1
  %45 = load ptr, ptr %key.addr, align 8
  %iter74 = getelementptr inbounds %struct.RedisModuleKey, ptr %45, i32 0, i32 4
  %46 = load ptr, ptr %iter74, align 8
  %47 = load ptr, ptr %key.addr, align 8
  %u75 = getelementptr inbounds %struct.RedisModuleKey, ptr %47, i32 0, i32 6
  %entry76 = getelementptr inbounds %struct.anon, ptr %u75, i32 0, i32 0
  %48 = load i8, ptr %dir, align 1
  call void @listTypeSetIteratorDirection(ptr noundef %46, ptr noundef %entry76, i8 noundef zeroext %48)
  br label %while.cond

while.cond:                                       ; preds = %cond.end94, %if.end68
  %49 = load ptr, ptr %key.addr, align 8
  %u77 = getelementptr inbounds %struct.RedisModuleKey, ptr %49, i32 0, i32 6
  %index78 = getelementptr inbounds %struct.anon, ptr %u77, i32 0, i32 1
  %50 = load i64, ptr %index78, align 8
  %51 = load i64, ptr %index.addr, align 8
  %cmp79 = icmp ne i64 %50, %51
  br i1 %cmp79, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %52 = load ptr, ptr %key.addr, align 8
  %iter81 = getelementptr inbounds %struct.RedisModuleKey, ptr %52, i32 0, i32 4
  %53 = load ptr, ptr %iter81, align 8
  %54 = load ptr, ptr %key.addr, align 8
  %u82 = getelementptr inbounds %struct.RedisModuleKey, ptr %54, i32 0, i32 6
  %entry83 = getelementptr inbounds %struct.anon, ptr %u82, i32 0, i32 0
  %call84 = call i32 @listTypeNext(ptr noundef %53, ptr noundef %entry83)
  %tobool85 = icmp ne i32 %call84, 0
  %lnot86 = xor i1 %tobool85, true
  %lnot88 = xor i1 %lnot86, true
  %lnot.ext89 = zext i1 %lnot88 to i32
  %conv90 = sext i32 %lnot.ext89 to i64
  %tobool91 = icmp ne i64 %conv90, 0
  br i1 %tobool91, label %cond.true92, label %cond.false93

cond.true92:                                      ; preds = %while.body
  br label %cond.end94

cond.false93:                                     ; preds = %while.body
  call void @_serverAssert(ptr noundef @.str.44, ptr noundef @.str.2, i32 noundef 4457)
  call void @abort() #13
  unreachable

55:                                               ; No predecessors!
  br label %cond.end94

cond.end94:                                       ; preds = %55, %cond.true92
  %56 = load i8, ptr %dir, align 1
  %conv95 = zext i8 %56 to i32
  %cmp96 = icmp eq i32 %conv95, 0
  %cond98 = select i1 %cmp96, i32 -1, i32 1
  %conv99 = sext i32 %cond98 to i64
  %57 = load ptr, ptr %key.addr, align 8
  %u100 = getelementptr inbounds %struct.RedisModuleKey, ptr %57, i32 0, i32 6
  %index101 = getelementptr inbounds %struct.anon, ptr %u100, i32 0, i32 1
  %58 = load i64, ptr %index101, align 8
  %add102 = add nsw i64 %58, %conv99
  store i64 %add102, ptr %index101, align 8
  br label %while.cond, !llvm.loop !31

while.end:                                        ; preds = %while.cond
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then67, %cond.end40, %if.then16, %if.then8, %if.then3, %if.then
  %59 = load i32, ptr %retval, align 4
  ret i32 %59
}

declare ptr @listTypeInitIterator(ptr noundef, i64 noundef, i8 noundef zeroext) #1

declare i32 @listTypeNext(ptr noundef, ptr noundef) #1

declare void @listTypeSetIteratorDirection(ptr noundef, ptr noundef, i8 noundef zeroext) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ListPush(ptr noundef %key, i32 noundef %where, ptr noundef %ele) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %where.addr = alloca i32, align 4
  %ele.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %where, ptr %where.addr, align 4
  store ptr %ele, ptr %ele.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %ele.addr, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %4 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp3 = icmp ne i32 %bf.clear, 1
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %call5 = call ptr @__errno_location() #15
  store i32 95, ptr %call5, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %mode, align 8
  %and = and i32 %7, 2
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end6
  %call9 = call ptr @__errno_location() #15
  store i32 9, ptr %call9, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %8 = load ptr, ptr %key.addr, align 8
  %mode11 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 5
  %9 = load i32, ptr %mode11, align 8
  %and12 = and i32 %9, 2
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end10
  store i32 1, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end10
  %10 = load ptr, ptr %key.addr, align 8
  %value16 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %value16, align 8
  %tobool17 = icmp ne ptr %11, null
  br i1 %tobool17, label %land.lhs.true18, label %if.end24

land.lhs.true18:                                  ; preds = %if.end15
  %12 = load ptr, ptr %key.addr, align 8
  %value19 = getelementptr inbounds %struct.RedisModuleKey, ptr %12, i32 0, i32 3
  %13 = load ptr, ptr %value19, align 8
  %bf.load20 = load i32, ptr %13, align 8
  %bf.clear21 = and i32 %bf.load20, 15
  %cmp22 = icmp ne i32 %bf.clear21, 1
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %land.lhs.true18
  store i32 1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %land.lhs.true18, %if.end15
  %14 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %iter, align 8
  %tobool25 = icmp ne ptr %15, null
  br i1 %tobool25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end24
  %16 = load ptr, ptr %key.addr, align 8
  call void @moduleFreeKeyIterator(ptr noundef %16)
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %if.end24
  %17 = load ptr, ptr %key.addr, align 8
  %value28 = getelementptr inbounds %struct.RedisModuleKey, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %value28, align 8
  %cmp29 = icmp eq ptr %18, null
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end27
  %19 = load ptr, ptr %key.addr, align 8
  %call31 = call i32 @moduleCreateEmptyKey(ptr noundef %19, i32 noundef 2)
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end27
  %20 = load ptr, ptr %key.addr, align 8
  %value33 = getelementptr inbounds %struct.RedisModuleKey, ptr %20, i32 0, i32 3
  %21 = load ptr, ptr %value33, align 8
  %22 = load ptr, ptr %key.addr, align 8
  call void @listTypeTryConversionAppend(ptr noundef %21, ptr noundef %ele.addr, i32 noundef 0, i32 noundef 0, ptr noundef @moduleFreeListIterator, ptr noundef %22)
  %23 = load ptr, ptr %key.addr, align 8
  %value34 = getelementptr inbounds %struct.RedisModuleKey, ptr %23, i32 0, i32 3
  %24 = load ptr, ptr %value34, align 8
  %25 = load ptr, ptr %ele.addr, align 8
  %26 = load i32, ptr %where.addr, align 4
  %cmp35 = icmp eq i32 %26, 0
  %cond = select i1 %cmp35, i32 0, i32 1
  call void @listTypePush(ptr noundef %24, ptr noundef %25, i32 noundef %cond)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end32, %if.then23, %if.then14, %if.then8, %if.then4, %if.then
  %27 = load i32, ptr %retval, align 4
  ret i32 %27
}

declare void @listTypeTryConversionAppend(ptr noundef, ptr noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @moduleFreeListIterator(ptr noundef %data) #0 {
entry:
  %data.addr = alloca ptr, align 8
  %key = alloca ptr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  store ptr %0, ptr %key, align 8
  %1 = load ptr, ptr %key, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %bf.load = load i32, ptr %2, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp eq i32 %bf.clear, 1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.541, ptr noundef @.str.2, i32 noundef 734)
  call void @abort() #13
  unreachable

3:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load ptr, ptr %key, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %iter, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %6 = load ptr, ptr %key, align 8
  call void @moduleFreeKeyIterator(ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  ret void
}

declare void @listTypePush(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ListPop(ptr noundef %key, i32 noundef %where) #0 {
entry:
  %retval = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %where.addr = alloca i32, align 4
  %ele = alloca ptr, align 8
  %decoded = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %where, ptr %where.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %3 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp2 = icmp ne i32 %bf.clear, 1
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = call ptr @__errno_location() #15
  store i32 95, ptr %call4, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %5 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 5
  %6 = load i32, ptr %mode, align 8
  %and = and i32 %6, 2
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.else5
  %call8 = call ptr @__errno_location() #15
  store i32 9, ptr %call8, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else5
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %if.end10

if.end10:                                         ; preds = %if.end9
  %7 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %iter, align 8
  %tobool11 = icmp ne ptr %8, null
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %9 = load ptr, ptr %key.addr, align 8
  call void @moduleFreeKeyIterator(ptr noundef %9)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10
  %10 = load ptr, ptr %key.addr, align 8
  %value14 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %value14, align 8
  %12 = load i32, ptr %where.addr, align 4
  %cmp15 = icmp eq i32 %12, 0
  %cond = select i1 %cmp15, i32 0, i32 1
  %call16 = call ptr @listTypePop(ptr noundef %11, i32 noundef %cond)
  store ptr %call16, ptr %ele, align 8
  %13 = load ptr, ptr %ele, align 8
  %call17 = call ptr @getDecodedObject(ptr noundef %13)
  store ptr %call17, ptr %decoded, align 8
  %14 = load ptr, ptr %ele, align 8
  call void @decrRefCount(ptr noundef %14)
  %15 = load ptr, ptr %key.addr, align 8
  %call18 = call i32 @moduleDelKeyIfEmpty(ptr noundef %15)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.end13
  %16 = load ptr, ptr %key.addr, align 8
  %value21 = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %value21, align 8
  %18 = load ptr, ptr %key.addr, align 8
  call void @listTypeTryConversion(ptr noundef %17, i32 noundef 2, ptr noundef @moduleFreeListIterator, ptr noundef %18)
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end13
  %19 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %ctx, align 8
  %21 = load ptr, ptr %decoded, align 8
  call void @autoMemoryAdd(ptr noundef %20, i32 noundef 1, ptr noundef %21)
  %22 = load ptr, ptr %decoded, align 8
  store ptr %22, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end22, %if.then7, %if.then3, %if.then
  %23 = load ptr, ptr %retval, align 8
  ret ptr %23
}

declare ptr @listTypePop(ptr noundef, i32 noundef) #1

declare ptr @getDecodedObject(ptr noundef) #1

declare void @listTypeTryConversion(ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ListGet(ptr noundef %key, i64 noundef %index) #0 {
entry:
  %retval = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %elem = alloca ptr, align 8
  %decoded = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load i64, ptr %index.addr, align 8
  %call = call i32 @moduleListIteratorSeek(ptr noundef %0, i64 noundef %1, i32 noundef 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 6
  %entry1 = getelementptr inbounds %struct.anon, ptr %u, i32 0, i32 0
  %call2 = call ptr @listTypeGet(ptr noundef %entry1)
  store ptr %call2, ptr %elem, align 8
  %3 = load ptr, ptr %elem, align 8
  %call3 = call ptr @getDecodedObject(ptr noundef %3)
  store ptr %call3, ptr %decoded, align 8
  %4 = load ptr, ptr %elem, align 8
  call void @decrRefCount(ptr noundef %4)
  %5 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %ctx, align 8
  %7 = load ptr, ptr %decoded, align 8
  call void @autoMemoryAdd(ptr noundef %6, i32 noundef 1, ptr noundef %7)
  %8 = load ptr, ptr %decoded, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

declare ptr @listTypeGet(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ListSet(ptr noundef %key, i64 noundef %index, ptr noundef %value) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value1, align 8
  %tobool2 = icmp ne ptr %2, null
  br i1 %tobool2, label %lor.lhs.false, label %if.then4

lor.lhs.false:                                    ; preds = %if.end
  %3 = load ptr, ptr %key.addr, align 8
  %value3 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value3, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 1
  br i1 %cmp, label %if.then4, label %if.end6

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %call5 = call ptr @__errno_location() #15
  store i32 95, ptr %call5, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %5 = load ptr, ptr %key.addr, align 8
  %value7 = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %value7, align 8
  %7 = load ptr, ptr %key.addr, align 8
  call void @listTypeTryConversionAppend(ptr noundef %6, ptr noundef %value.addr, i32 noundef 0, i32 noundef 0, ptr noundef @moduleFreeListIterator, ptr noundef %7)
  %8 = load ptr, ptr %key.addr, align 8
  %9 = load i64, ptr %index.addr, align 8
  %call8 = call i32 @moduleListIteratorSeek(ptr noundef %8, i64 noundef %9, i32 noundef 2)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end6
  %10 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 6
  %entry11 = getelementptr inbounds %struct.anon, ptr %u, i32 0, i32 0
  %11 = load ptr, ptr %value.addr, align 8
  call void @listTypeReplace(ptr noundef %entry11, ptr noundef %11)
  %12 = load ptr, ptr %key.addr, align 8
  call void @moduleFreeKeyIterator(ptr noundef %12)
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end6
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then10, %if.then4, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

declare void @listTypeReplace(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ListInsert(ptr noundef %key, i64 noundef %index, ptr noundef %value) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %where = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %land.lhs.true, label %if.else8

land.lhs.true:                                    ; preds = %if.else
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %cmp2 = icmp eq ptr %3, null
  br i1 %cmp2, label %land.lhs.true3, label %if.else8

land.lhs.true3:                                   ; preds = %land.lhs.true
  %4 = load i64, ptr %index.addr, align 8
  %cmp4 = icmp eq i64 %4, 0
  br i1 %cmp4, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true3
  %5 = load i64, ptr %index.addr, align 8
  %cmp5 = icmp eq i64 %5, -1
  br i1 %cmp5, label %if.then6, label %if.else8

if.then6:                                         ; preds = %lor.lhs.false, %land.lhs.true3
  %6 = load ptr, ptr %key.addr, align 8
  %7 = load ptr, ptr %value.addr, align 8
  %call7 = call i32 @RM_ListPush(ptr noundef %6, i32 noundef 1, ptr noundef %7)
  store i32 %call7, ptr %retval, align 4
  br label %return

if.else8:                                         ; preds = %lor.lhs.false, %land.lhs.true, %if.else
  %8 = load ptr, ptr %key.addr, align 8
  %cmp9 = icmp ne ptr %8, null
  br i1 %cmp9, label %land.lhs.true10, label %if.else24

land.lhs.true10:                                  ; preds = %if.else8
  %9 = load ptr, ptr %key.addr, align 8
  %value11 = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 3
  %10 = load ptr, ptr %value11, align 8
  %cmp12 = icmp ne ptr %10, null
  br i1 %cmp12, label %land.lhs.true13, label %if.else24

land.lhs.true13:                                  ; preds = %land.lhs.true10
  %11 = load ptr, ptr %key.addr, align 8
  %value14 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %value14, align 8
  %bf.load = load i32, ptr %12, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp15 = icmp eq i32 %bf.clear, 1
  br i1 %cmp15, label %land.lhs.true16, label %if.else24

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %13 = load i64, ptr %index.addr, align 8
  %14 = load ptr, ptr %key.addr, align 8
  %value17 = getelementptr inbounds %struct.RedisModuleKey, ptr %14, i32 0, i32 3
  %15 = load ptr, ptr %value17, align 8
  %call18 = call i64 @listTypeLength(ptr noundef %15)
  %cmp19 = icmp eq i64 %13, %call18
  br i1 %cmp19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %land.lhs.true16
  %16 = load i64, ptr %index.addr, align 8
  %cmp21 = icmp eq i64 %16, -1
  br i1 %cmp21, label %if.then22, label %if.else24

if.then22:                                        ; preds = %lor.lhs.false20, %land.lhs.true16
  %17 = load ptr, ptr %key.addr, align 8
  %18 = load ptr, ptr %value.addr, align 8
  %call23 = call i32 @RM_ListPush(ptr noundef %17, i32 noundef 1, ptr noundef %18)
  store i32 %call23, ptr %retval, align 4
  br label %return

if.else24:                                        ; preds = %lor.lhs.false20, %land.lhs.true13, %land.lhs.true10, %if.else8
  %19 = load ptr, ptr %key.addr, align 8
  %cmp25 = icmp ne ptr %19, null
  br i1 %cmp25, label %land.lhs.true26, label %if.end

land.lhs.true26:                                  ; preds = %if.else24
  %20 = load ptr, ptr %key.addr, align 8
  %value27 = getelementptr inbounds %struct.RedisModuleKey, ptr %20, i32 0, i32 3
  %21 = load ptr, ptr %value27, align 8
  %cmp28 = icmp ne ptr %21, null
  br i1 %cmp28, label %land.lhs.true29, label %if.end

land.lhs.true29:                                  ; preds = %land.lhs.true26
  %22 = load ptr, ptr %key.addr, align 8
  %value30 = getelementptr inbounds %struct.RedisModuleKey, ptr %22, i32 0, i32 3
  %23 = load ptr, ptr %value30, align 8
  %bf.load31 = load i32, ptr %23, align 8
  %bf.clear32 = and i32 %bf.load31, 15
  %cmp33 = icmp eq i32 %bf.clear32, 1
  br i1 %cmp33, label %land.lhs.true34, label %if.end

land.lhs.true34:                                  ; preds = %land.lhs.true29
  %24 = load i64, ptr %index.addr, align 8
  %cmp35 = icmp eq i64 %24, 0
  br i1 %cmp35, label %if.then41, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %land.lhs.true34
  %25 = load i64, ptr %index.addr, align 8
  %26 = load ptr, ptr %key.addr, align 8
  %value37 = getelementptr inbounds %struct.RedisModuleKey, ptr %26, i32 0, i32 3
  %27 = load ptr, ptr %value37, align 8
  %call38 = call i64 @listTypeLength(ptr noundef %27)
  %sub = sub nsw i64 0, %call38
  %sub39 = sub nsw i64 %sub, 1
  %cmp40 = icmp eq i64 %25, %sub39
  br i1 %cmp40, label %if.then41, label %if.end

if.then41:                                        ; preds = %lor.lhs.false36, %land.lhs.true34
  %28 = load ptr, ptr %key.addr, align 8
  %29 = load ptr, ptr %value.addr, align 8
  %call42 = call i32 @RM_ListPush(ptr noundef %28, i32 noundef 0, ptr noundef %29)
  store i32 %call42, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false36, %land.lhs.true29, %land.lhs.true26, %if.else24
  br label %if.end43

if.end43:                                         ; preds = %if.end
  br label %if.end44

if.end44:                                         ; preds = %if.end43
  br label %if.end45

if.end45:                                         ; preds = %if.end44
  %30 = load ptr, ptr %key.addr, align 8
  %value46 = getelementptr inbounds %struct.RedisModuleKey, ptr %30, i32 0, i32 3
  %31 = load ptr, ptr %value46, align 8
  %32 = load ptr, ptr %key.addr, align 8
  call void @listTypeTryConversionAppend(ptr noundef %31, ptr noundef %value.addr, i32 noundef 0, i32 noundef 0, ptr noundef @moduleFreeListIterator, ptr noundef %32)
  %33 = load ptr, ptr %key.addr, align 8
  %34 = load i64, ptr %index.addr, align 8
  %call47 = call i32 @moduleListIteratorSeek(ptr noundef %33, i64 noundef %34, i32 noundef 2)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then49, label %if.else52

if.then49:                                        ; preds = %if.end45
  %35 = load i64, ptr %index.addr, align 8
  %cmp50 = icmp slt i64 %35, 0
  %cond = select i1 %cmp50, i32 1, i32 0
  store i32 %cond, ptr %where, align 4
  %36 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %36, i32 0, i32 6
  %entry51 = getelementptr inbounds %struct.anon, ptr %u, i32 0, i32 0
  %37 = load ptr, ptr %value.addr, align 8
  %38 = load i32, ptr %where, align 4
  call void @listTypeInsert(ptr noundef %entry51, ptr noundef %37, i32 noundef %38)
  %39 = load ptr, ptr %key.addr, align 8
  call void @moduleFreeKeyIterator(ptr noundef %39)
  store i32 0, ptr %retval, align 4
  br label %return

if.else52:                                        ; preds = %if.end45
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else52, %if.then49, %if.then41, %if.then22, %if.then6, %if.then
  %40 = load i32, ptr %retval, align 4
  ret i32 %40
}

declare void @listTypeInsert(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ListDelete(ptr noundef %key, i64 noundef %index) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %li = alloca ptr, align 8
  %reverse = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load i64, ptr %index.addr, align 8
  %call = call i32 @moduleListIteratorSeek(ptr noundef %0, i64 noundef %1, i32 noundef 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else35

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %iter, align 8
  %4 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 6
  %entry1 = getelementptr inbounds %struct.anon, ptr %u, i32 0, i32 0
  call void @listTypeDelete(ptr noundef %3, ptr noundef %entry1)
  %5 = load ptr, ptr %key.addr, align 8
  %call2 = call i32 @moduleDelKeyIfEmpty(ptr noundef %5)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %value, align 8
  %8 = load ptr, ptr %key.addr, align 8
  call void @listTypeTryConversion(ptr noundef %7, i32 noundef 2, ptr noundef @moduleFreeListIterator, ptr noundef %8)
  %9 = load ptr, ptr %key.addr, align 8
  %iter5 = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 4
  %10 = load ptr, ptr %iter5, align 8
  %tobool6 = icmp ne ptr %10, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %11 = load ptr, ptr %key.addr, align 8
  %iter9 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 4
  %12 = load ptr, ptr %iter9, align 8
  %13 = load ptr, ptr %key.addr, align 8
  %u10 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 6
  %entry11 = getelementptr inbounds %struct.anon, ptr %u10, i32 0, i32 0
  %call12 = call i32 @listTypeNext(ptr noundef %12, ptr noundef %entry11)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.else33

if.then14:                                        ; preds = %if.end8
  %14 = load ptr, ptr %key.addr, align 8
  %iter15 = getelementptr inbounds %struct.RedisModuleKey, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %iter15, align 8
  store ptr %15, ptr %li, align 8
  %16 = load ptr, ptr %li, align 8
  %direction = getelementptr inbounds %struct.listTypeIterator, ptr %16, i32 0, i32 2
  %17 = load i8, ptr %direction, align 1
  %conv = zext i8 %17 to i32
  %cmp = icmp eq i32 %conv, 0
  %conv16 = zext i1 %cmp to i32
  store i32 %conv16, ptr %reverse, align 4
  %18 = load ptr, ptr %key.addr, align 8
  %u17 = getelementptr inbounds %struct.RedisModuleKey, ptr %18, i32 0, i32 6
  %index18 = getelementptr inbounds %struct.anon, ptr %u17, i32 0, i32 1
  %19 = load i64, ptr %index18, align 8
  %cmp19 = icmp slt i64 %19, 0
  br i1 %cmp19, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.then14
  %20 = load i32, ptr %reverse, align 4
  %tobool22 = icmp ne i32 %20, 0
  %cond = select i1 %tobool22, i32 0, i32 1
  %conv23 = sext i32 %cond to i64
  %21 = load ptr, ptr %key.addr, align 8
  %u24 = getelementptr inbounds %struct.RedisModuleKey, ptr %21, i32 0, i32 6
  %index25 = getelementptr inbounds %struct.anon, ptr %u24, i32 0, i32 1
  %22 = load i64, ptr %index25, align 8
  %add = add nsw i64 %22, %conv23
  store i64 %add, ptr %index25, align 8
  br label %if.end32

if.else:                                          ; preds = %if.then14
  %23 = load i32, ptr %reverse, align 4
  %tobool26 = icmp ne i32 %23, 0
  %cond27 = select i1 %tobool26, i32 -1, i32 0
  %conv28 = sext i32 %cond27 to i64
  %24 = load ptr, ptr %key.addr, align 8
  %u29 = getelementptr inbounds %struct.RedisModuleKey, ptr %24, i32 0, i32 6
  %index30 = getelementptr inbounds %struct.anon, ptr %u29, i32 0, i32 1
  %25 = load i64, ptr %index30, align 8
  %add31 = add nsw i64 %25, %conv28
  store i64 %add31, ptr %index30, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.else, %if.then21
  br label %if.end34

if.else33:                                        ; preds = %if.end8
  %26 = load ptr, ptr %key.addr, align 8
  call void @moduleFreeKeyIterator(ptr noundef %26)
  br label %if.end34

if.end34:                                         ; preds = %if.else33, %if.end32
  store i32 0, ptr %retval, align 4
  br label %return

if.else35:                                        ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else35, %if.end34, %if.then7, %if.then4
  %27 = load i32, ptr %retval, align 4
  ret i32 %27
}

declare void @listTypeDelete(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleZsetAddFlagsToCoreFlags(i32 noundef %flags) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %retflags = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %retflags, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %retflags, align 4
  %or = or i32 %1, 4
  store i32 %or, ptr %retflags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %flags.addr, align 4
  %and1 = and i32 %2, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = load i32, ptr %retflags, align 4
  %or4 = or i32 %3, 2
  store i32 %or4, ptr %retflags, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %flags.addr, align 4
  %and6 = and i32 %4, 32
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %5 = load i32, ptr %retflags, align 4
  %or9 = or i32 %5, 8
  store i32 %or9, ptr %retflags, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end5
  %6 = load i32, ptr %flags.addr, align 4
  %and11 = and i32 %6, 64
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end10
  %7 = load i32, ptr %retflags, align 4
  %or14 = or i32 %7, 16
  store i32 %or14, ptr %retflags, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end10
  %8 = load i32, ptr %retflags, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleZsetAddFlagsFromCoreFlags(i32 noundef %flags) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %retflags = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %retflags, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %retflags, align 4
  %or = or i32 %1, 4
  store i32 %or, ptr %retflags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %flags.addr, align 4
  %and1 = and i32 %2, 8
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = load i32, ptr %retflags, align 4
  %or4 = or i32 %3, 8
  store i32 %or4, ptr %retflags, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %flags.addr, align 4
  %and6 = and i32 %4, 1
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %5 = load i32, ptr %retflags, align 4
  %or9 = or i32 %5, 16
  store i32 %or9, ptr %retflags, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end5
  %6 = load i32, ptr %retflags, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetAdd(ptr noundef %key, double noundef %score, ptr noundef %ele, ptr noundef %flagsptr) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %score.addr = alloca double, align 8
  %ele.addr = alloca ptr, align 8
  %flagsptr.addr = alloca ptr, align 8
  %in_flags = alloca i32, align 4
  %out_flags = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store double %score, ptr %score.addr, align 8
  store ptr %ele, ptr %ele.addr, align 8
  store ptr %flagsptr, ptr %flagsptr.addr, align 8
  store i32 0, ptr %in_flags, align 4
  store i32 0, ptr %out_flags, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %value5, align 8
  %cmp6 = icmp eq ptr %7, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %8 = load ptr, ptr %key.addr, align 8
  %call = call i32 @moduleCreateEmptyKey(ptr noundef %8, i32 noundef 5)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %9 = load ptr, ptr %flagsptr.addr, align 8
  %tobool9 = icmp ne ptr %9, null
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %10 = load ptr, ptr %flagsptr.addr, align 8
  %11 = load i32, ptr %10, align 4
  %call11 = call i32 @moduleZsetAddFlagsToCoreFlags(i32 noundef %11)
  store i32 %call11, ptr %in_flags, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %12 = load ptr, ptr %key.addr, align 8
  %value13 = getelementptr inbounds %struct.RedisModuleKey, ptr %12, i32 0, i32 3
  %13 = load ptr, ptr %value13, align 8
  %14 = load double, ptr %score.addr, align 8
  %15 = load ptr, ptr %ele.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %ptr, align 8
  %17 = load i32, ptr %in_flags, align 4
  %call14 = call i32 @zsetAdd(ptr noundef %13, double noundef %14, ptr noundef %16, i32 noundef %17, ptr noundef %out_flags, ptr noundef null)
  %cmp15 = icmp eq i32 %call14, 0
  br i1 %cmp15, label %if.then16, label %if.end21

if.then16:                                        ; preds = %if.end12
  %18 = load ptr, ptr %flagsptr.addr, align 8
  %tobool17 = icmp ne ptr %18, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then16
  %19 = load ptr, ptr %flagsptr.addr, align 8
  store i32 0, ptr %19, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then16
  %20 = load ptr, ptr %key.addr, align 8
  %call20 = call i32 @moduleDelKeyIfEmpty(ptr noundef %20)
  store i32 1, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end12
  %21 = load ptr, ptr %flagsptr.addr, align 8
  %tobool22 = icmp ne ptr %21, null
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end21
  %22 = load i32, ptr %out_flags, align 4
  %call24 = call i32 @moduleZsetAddFlagsFromCoreFlags(i32 noundef %22)
  %23 = load ptr, ptr %flagsptr.addr, align 8
  store i32 %call24, ptr %23, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end21
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.end19, %if.then3, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

declare i32 @zsetAdd(ptr noundef, double noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetIncrby(ptr noundef %key, double noundef %score, ptr noundef %ele, ptr noundef %flagsptr, ptr noundef %newscore) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %score.addr = alloca double, align 8
  %ele.addr = alloca ptr, align 8
  %flagsptr.addr = alloca ptr, align 8
  %newscore.addr = alloca ptr, align 8
  %in_flags = alloca i32, align 4
  %out_flags = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store double %score, ptr %score.addr, align 8
  store ptr %ele, ptr %ele.addr, align 8
  store ptr %flagsptr, ptr %flagsptr.addr, align 8
  store ptr %newscore, ptr %newscore.addr, align 8
  store i32 0, ptr %in_flags, align 4
  store i32 0, ptr %out_flags, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %value5, align 8
  %cmp6 = icmp eq ptr %7, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %8 = load ptr, ptr %key.addr, align 8
  %call = call i32 @moduleCreateEmptyKey(ptr noundef %8, i32 noundef 5)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %9 = load ptr, ptr %flagsptr.addr, align 8
  %tobool9 = icmp ne ptr %9, null
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %10 = load ptr, ptr %flagsptr.addr, align 8
  %11 = load i32, ptr %10, align 4
  %call11 = call i32 @moduleZsetAddFlagsToCoreFlags(i32 noundef %11)
  store i32 %call11, ptr %in_flags, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %12 = load i32, ptr %in_flags, align 4
  %or = or i32 %12, 1
  store i32 %or, ptr %in_flags, align 4
  %13 = load ptr, ptr %key.addr, align 8
  %value13 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %value13, align 8
  %15 = load double, ptr %score.addr, align 8
  %16 = load ptr, ptr %ele.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %ptr, align 8
  %18 = load i32, ptr %in_flags, align 4
  %19 = load ptr, ptr %newscore.addr, align 8
  %call14 = call i32 @zsetAdd(ptr noundef %14, double noundef %15, ptr noundef %17, i32 noundef %18, ptr noundef %out_flags, ptr noundef %19)
  %cmp15 = icmp eq i32 %call14, 0
  br i1 %cmp15, label %if.then16, label %if.end21

if.then16:                                        ; preds = %if.end12
  %20 = load ptr, ptr %flagsptr.addr, align 8
  %tobool17 = icmp ne ptr %20, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then16
  %21 = load ptr, ptr %flagsptr.addr, align 8
  store i32 0, ptr %21, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.then16
  %22 = load ptr, ptr %key.addr, align 8
  %call20 = call i32 @moduleDelKeyIfEmpty(ptr noundef %22)
  store i32 1, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end12
  %23 = load ptr, ptr %flagsptr.addr, align 8
  %tobool22 = icmp ne ptr %23, null
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end21
  %24 = load i32, ptr %out_flags, align 4
  %call24 = call i32 @moduleZsetAddFlagsFromCoreFlags(i32 noundef %24)
  %25 = load ptr, ptr %flagsptr.addr, align 8
  store i32 %call24, ptr %25, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end21
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.end19, %if.then3, %if.then
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetRem(ptr noundef %key, ptr noundef %ele, ptr noundef %deleted) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %ele.addr = alloca ptr, align 8
  %deleted.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %ele, ptr %ele.addr, align 8
  store ptr %deleted, ptr %deleted.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %value5, align 8
  %cmp6 = icmp ne ptr %7, null
  br i1 %cmp6, label %land.lhs.true7, label %if.else

land.lhs.true7:                                   ; preds = %if.end4
  %8 = load ptr, ptr %key.addr, align 8
  %value8 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %value8, align 8
  %10 = load ptr, ptr %ele.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %ptr, align 8
  %call = call i32 @zsetDel(ptr noundef %9, ptr noundef %11)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %land.lhs.true7
  %12 = load ptr, ptr %deleted.addr, align 8
  %tobool11 = icmp ne ptr %12, null
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then10
  %13 = load ptr, ptr %deleted.addr, align 8
  store i32 1, ptr %13, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then10
  %14 = load ptr, ptr %key.addr, align 8
  %call14 = call i32 @moduleDelKeyIfEmpty(ptr noundef %14)
  br label %if.end18

if.else:                                          ; preds = %land.lhs.true7, %if.end4
  %15 = load ptr, ptr %deleted.addr, align 8
  %tobool15 = icmp ne ptr %15, null
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.else
  %16 = load ptr, ptr %deleted.addr, align 8
  store i32 0, ptr %16, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.else
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end13
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then3, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare i32 @zsetDel(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetScore(ptr noundef %key, ptr noundef %ele, ptr noundef %score) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %ele.addr = alloca ptr, align 8
  %score.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %ele, ptr %ele.addr, align 8
  store ptr %score, ptr %score.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp2 = icmp ne i32 %bf.clear, 3
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value5, align 8
  %6 = load ptr, ptr %ele.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %ptr, align 8
  %8 = load ptr, ptr %score.addr, align 8
  %call = call i32 @zsetScore(ptr noundef %5, ptr noundef %7, ptr noundef %8)
  %cmp6 = icmp eq i32 %call, -1
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  store i32 1, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then7, %if.then3, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

declare i32 @zsetScore(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_ZsetRangeStop(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 6
  %type = getelementptr inbounds %struct.anon.0, ptr %u, i32 0, i32 0
  %5 = load i32, ptr %type, align 8
  %cmp2 = icmp eq i32 %5, 1
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %u4 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 6
  %lrs = getelementptr inbounds %struct.anon.0, ptr %u4, i32 0, i32 2
  call void @zslFreeLexRange(ptr noundef %lrs)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %7 = load ptr, ptr %key.addr, align 8
  call void @zsetKeyReset(ptr noundef %7)
  br label %return

return:                                           ; preds = %if.end5, %if.then
  ret void
}

declare void @zslFreeLexRange(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @zsetKeyReset(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 6
  %type = getelementptr inbounds %struct.anon.0, ptr %u, i32 0, i32 0
  store i32 0, ptr %type, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %u1 = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 6
  %current = getelementptr inbounds %struct.anon.0, ptr %u1, i32 0, i32 5
  store ptr null, ptr %current, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %u2 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 6
  %er = getelementptr inbounds %struct.anon.0, ptr %u2, i32 0, i32 6
  store i32 1, ptr %er, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetRangeEndReached(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 6
  %er = getelementptr inbounds %struct.anon.0, ptr %u, i32 0, i32 6
  %5 = load i32, ptr %er, align 8
  store i32 %5, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define dso_local i32 @zsetInitScoreRange(ptr noundef %key, double noundef %min, double noundef %max, i32 noundef %minex, i32 noundef %maxex, i32 noundef %first) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %min.addr = alloca double, align 8
  %max.addr = alloca double, align 8
  %minex.addr = alloca i32, align 4
  %maxex.addr = alloca i32, align 4
  %first.addr = alloca i32, align 4
  %zrs = alloca ptr, align 8
  %zs = alloca ptr, align 8
  %zsl = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store double %min, ptr %min.addr, align 8
  store double %max, ptr %max.addr, align 8
  store i32 %minex, ptr %minex.addr, align 4
  store i32 %maxex, ptr %maxex.addr, align 4
  store i32 %first, ptr %first.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  call void @RM_ZsetRangeStop(ptr noundef %4)
  %5 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 6
  %type = getelementptr inbounds %struct.anon.0, ptr %u, i32 0, i32 0
  store i32 2, ptr %type, align 8
  %6 = load ptr, ptr %key.addr, align 8
  %u2 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 6
  %er = getelementptr inbounds %struct.anon.0, ptr %u2, i32 0, i32 6
  store i32 0, ptr %er, align 8
  %7 = load ptr, ptr %key.addr, align 8
  %u3 = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 6
  %rs = getelementptr inbounds %struct.anon.0, ptr %u3, i32 0, i32 1
  store ptr %rs, ptr %zrs, align 8
  %8 = load double, ptr %min.addr, align 8
  %9 = load ptr, ptr %zrs, align 8
  %min4 = getelementptr inbounds %struct.zrangespec, ptr %9, i32 0, i32 0
  store double %8, ptr %min4, align 8
  %10 = load double, ptr %max.addr, align 8
  %11 = load ptr, ptr %zrs, align 8
  %max5 = getelementptr inbounds %struct.zrangespec, ptr %11, i32 0, i32 1
  store double %10, ptr %max5, align 8
  %12 = load i32, ptr %minex.addr, align 4
  %13 = load ptr, ptr %zrs, align 8
  %minex6 = getelementptr inbounds %struct.zrangespec, ptr %13, i32 0, i32 2
  store i32 %12, ptr %minex6, align 8
  %14 = load i32, ptr %maxex.addr, align 4
  %15 = load ptr, ptr %zrs, align 8
  %maxex7 = getelementptr inbounds %struct.zrangespec, ptr %15, i32 0, i32 3
  store i32 %14, ptr %maxex7, align 4
  %16 = load ptr, ptr %key.addr, align 8
  %value8 = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %value8, align 8
  %bf.load9 = load i32, ptr %17, align 8
  %bf.lshr = lshr i32 %bf.load9, 4
  %bf.clear10 = and i32 %bf.lshr, 15
  %cmp11 = icmp eq i32 %bf.clear10, 11
  br i1 %cmp11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %18 = load i32, ptr %first.addr, align 4
  %tobool13 = icmp ne i32 %18, 0
  br i1 %tobool13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then12
  %19 = load ptr, ptr %key.addr, align 8
  %value14 = getelementptr inbounds %struct.RedisModuleKey, ptr %19, i32 0, i32 3
  %20 = load ptr, ptr %value14, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %ptr, align 8
  %22 = load ptr, ptr %zrs, align 8
  %call = call ptr @zzlFirstInRange(ptr noundef %21, ptr noundef %22)
  br label %cond.end

cond.false:                                       ; preds = %if.then12
  %23 = load ptr, ptr %key.addr, align 8
  %value15 = getelementptr inbounds %struct.RedisModuleKey, ptr %23, i32 0, i32 3
  %24 = load ptr, ptr %value15, align 8
  %ptr16 = getelementptr inbounds %struct.redisObject, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %ptr16, align 8
  %26 = load ptr, ptr %zrs, align 8
  %call17 = call ptr @zzlLastInRange(ptr noundef %25, ptr noundef %26)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ %call17, %cond.false ]
  %27 = load ptr, ptr %key.addr, align 8
  %u18 = getelementptr inbounds %struct.RedisModuleKey, ptr %27, i32 0, i32 6
  %current = getelementptr inbounds %struct.anon.0, ptr %u18, i32 0, i32 5
  store ptr %cond, ptr %current, align 8
  br label %if.end39

if.else:                                          ; preds = %if.end
  %28 = load ptr, ptr %key.addr, align 8
  %value19 = getelementptr inbounds %struct.RedisModuleKey, ptr %28, i32 0, i32 3
  %29 = load ptr, ptr %value19, align 8
  %bf.load20 = load i32, ptr %29, align 8
  %bf.lshr21 = lshr i32 %bf.load20, 4
  %bf.clear22 = and i32 %bf.lshr21, 15
  %cmp23 = icmp eq i32 %bf.clear22, 7
  br i1 %cmp23, label %if.then24, label %if.else37

if.then24:                                        ; preds = %if.else
  %30 = load ptr, ptr %key.addr, align 8
  %value25 = getelementptr inbounds %struct.RedisModuleKey, ptr %30, i32 0, i32 3
  %31 = load ptr, ptr %value25, align 8
  %ptr26 = getelementptr inbounds %struct.redisObject, ptr %31, i32 0, i32 2
  %32 = load ptr, ptr %ptr26, align 8
  store ptr %32, ptr %zs, align 8
  %33 = load ptr, ptr %zs, align 8
  %zsl27 = getelementptr inbounds %struct.zset, ptr %33, i32 0, i32 1
  %34 = load ptr, ptr %zsl27, align 8
  store ptr %34, ptr %zsl, align 8
  %35 = load i32, ptr %first.addr, align 4
  %tobool28 = icmp ne i32 %35, 0
  br i1 %tobool28, label %cond.true29, label %cond.false31

cond.true29:                                      ; preds = %if.then24
  %36 = load ptr, ptr %zsl, align 8
  %37 = load ptr, ptr %zrs, align 8
  %call30 = call ptr @zslNthInRange(ptr noundef %36, ptr noundef %37, i64 noundef 0)
  br label %cond.end33

cond.false31:                                     ; preds = %if.then24
  %38 = load ptr, ptr %zsl, align 8
  %39 = load ptr, ptr %zrs, align 8
  %call32 = call ptr @zslNthInRange(ptr noundef %38, ptr noundef %39, i64 noundef -1)
  br label %cond.end33

cond.end33:                                       ; preds = %cond.false31, %cond.true29
  %cond34 = phi ptr [ %call30, %cond.true29 ], [ %call32, %cond.false31 ]
  %40 = load ptr, ptr %key.addr, align 8
  %u35 = getelementptr inbounds %struct.RedisModuleKey, ptr %40, i32 0, i32 6
  %current36 = getelementptr inbounds %struct.anon.0, ptr %u35, i32 0, i32 5
  store ptr %cond34, ptr %current36, align 8
  br label %if.end38

if.else37:                                        ; preds = %if.else
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 4886, ptr noundef @.str.45)
  call void @abort() #13
  unreachable

if.end38:                                         ; preds = %cond.end33
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %cond.end
  %41 = load ptr, ptr %key.addr, align 8
  %u40 = getelementptr inbounds %struct.RedisModuleKey, ptr %41, i32 0, i32 6
  %current41 = getelementptr inbounds %struct.anon.0, ptr %u40, i32 0, i32 5
  %42 = load ptr, ptr %current41, align 8
  %cmp42 = icmp eq ptr %42, null
  br i1 %cmp42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %if.end39
  %43 = load ptr, ptr %key.addr, align 8
  %u44 = getelementptr inbounds %struct.RedisModuleKey, ptr %43, i32 0, i32 6
  %er45 = getelementptr inbounds %struct.anon.0, ptr %u44, i32 0, i32 6
  store i32 1, ptr %er45, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %if.end39
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end46, %if.then
  %44 = load i32, ptr %retval, align 4
  ret i32 %44
}

declare ptr @zzlFirstInRange(ptr noundef, ptr noundef) #1

declare ptr @zzlLastInRange(ptr noundef, ptr noundef) #1

declare ptr @zslNthInRange(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetFirstInScoreRange(ptr noundef %key, double noundef %min, double noundef %max, i32 noundef %minex, i32 noundef %maxex) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %min.addr = alloca double, align 8
  %max.addr = alloca double, align 8
  %minex.addr = alloca i32, align 4
  %maxex.addr = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store double %min, ptr %min.addr, align 8
  store double %max, ptr %max.addr, align 8
  store i32 %minex, ptr %minex.addr, align 4
  store i32 %maxex, ptr %maxex.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load double, ptr %min.addr, align 8
  %2 = load double, ptr %max.addr, align 8
  %3 = load i32, ptr %minex.addr, align 4
  %4 = load i32, ptr %maxex.addr, align 4
  %call = call i32 @zsetInitScoreRange(ptr noundef %0, double noundef %1, double noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetLastInScoreRange(ptr noundef %key, double noundef %min, double noundef %max, i32 noundef %minex, i32 noundef %maxex) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %min.addr = alloca double, align 8
  %max.addr = alloca double, align 8
  %minex.addr = alloca i32, align 4
  %maxex.addr = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store double %min, ptr %min.addr, align 8
  store double %max, ptr %max.addr, align 8
  store i32 %minex, ptr %minex.addr, align 4
  store i32 %maxex, ptr %maxex.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load double, ptr %min.addr, align 8
  %2 = load double, ptr %max.addr, align 8
  %3 = load i32, ptr %minex.addr, align 4
  %4 = load i32, ptr %maxex.addr, align 4
  %call = call i32 @zsetInitScoreRange(ptr noundef %0, double noundef %1, double noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef 0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @zsetInitLexRange(ptr noundef %key, ptr noundef %min, ptr noundef %max, i32 noundef %first) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %min.addr = alloca ptr, align 8
  %max.addr = alloca ptr, align 8
  %first.addr = alloca i32, align 4
  %zlrs = alloca ptr, align 8
  %zs = alloca ptr, align 8
  %zsl = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %min, ptr %min.addr, align 8
  store ptr %max, ptr %max.addr, align 8
  store i32 %first, ptr %first.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  call void @RM_ZsetRangeStop(ptr noundef %4)
  %5 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 6
  %er = getelementptr inbounds %struct.anon.0, ptr %u, i32 0, i32 6
  store i32 0, ptr %er, align 8
  %6 = load ptr, ptr %key.addr, align 8
  %u2 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 6
  %lrs = getelementptr inbounds %struct.anon.0, ptr %u2, i32 0, i32 2
  store ptr %lrs, ptr %zlrs, align 8
  %7 = load ptr, ptr %min.addr, align 8
  %8 = load ptr, ptr %max.addr, align 8
  %9 = load ptr, ptr %zlrs, align 8
  %call = call i32 @zslParseLexRange(ptr noundef %7, ptr noundef %8, ptr noundef %9)
  %cmp3 = icmp eq i32 %call, -1
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %10 = load ptr, ptr %key.addr, align 8
  %u6 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 6
  %type = getelementptr inbounds %struct.anon.0, ptr %u6, i32 0, i32 0
  store i32 1, ptr %type, align 8
  %11 = load ptr, ptr %key.addr, align 8
  %value7 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %value7, align 8
  %bf.load8 = load i32, ptr %12, align 8
  %bf.lshr = lshr i32 %bf.load8, 4
  %bf.clear9 = and i32 %bf.lshr, 15
  %cmp10 = icmp eq i32 %bf.clear9, 11
  br i1 %cmp10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end5
  %13 = load i32, ptr %first.addr, align 4
  %tobool12 = icmp ne i32 %13, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then11
  %14 = load ptr, ptr %key.addr, align 8
  %value13 = getelementptr inbounds %struct.RedisModuleKey, ptr %14, i32 0, i32 3
  %15 = load ptr, ptr %value13, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %ptr, align 8
  %17 = load ptr, ptr %zlrs, align 8
  %call14 = call ptr @zzlFirstInLexRange(ptr noundef %16, ptr noundef %17)
  br label %cond.end

cond.false:                                       ; preds = %if.then11
  %18 = load ptr, ptr %key.addr, align 8
  %value15 = getelementptr inbounds %struct.RedisModuleKey, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %value15, align 8
  %ptr16 = getelementptr inbounds %struct.redisObject, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %ptr16, align 8
  %21 = load ptr, ptr %zlrs, align 8
  %call17 = call ptr @zzlLastInLexRange(ptr noundef %20, ptr noundef %21)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call14, %cond.true ], [ %call17, %cond.false ]
  %22 = load ptr, ptr %key.addr, align 8
  %u18 = getelementptr inbounds %struct.RedisModuleKey, ptr %22, i32 0, i32 6
  %current = getelementptr inbounds %struct.anon.0, ptr %u18, i32 0, i32 5
  store ptr %cond, ptr %current, align 8
  br label %if.end39

if.else:                                          ; preds = %if.end5
  %23 = load ptr, ptr %key.addr, align 8
  %value19 = getelementptr inbounds %struct.RedisModuleKey, ptr %23, i32 0, i32 3
  %24 = load ptr, ptr %value19, align 8
  %bf.load20 = load i32, ptr %24, align 8
  %bf.lshr21 = lshr i32 %bf.load20, 4
  %bf.clear22 = and i32 %bf.lshr21, 15
  %cmp23 = icmp eq i32 %bf.clear22, 7
  br i1 %cmp23, label %if.then24, label %if.else37

if.then24:                                        ; preds = %if.else
  %25 = load ptr, ptr %key.addr, align 8
  %value25 = getelementptr inbounds %struct.RedisModuleKey, ptr %25, i32 0, i32 3
  %26 = load ptr, ptr %value25, align 8
  %ptr26 = getelementptr inbounds %struct.redisObject, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %ptr26, align 8
  store ptr %27, ptr %zs, align 8
  %28 = load ptr, ptr %zs, align 8
  %zsl27 = getelementptr inbounds %struct.zset, ptr %28, i32 0, i32 1
  %29 = load ptr, ptr %zsl27, align 8
  store ptr %29, ptr %zsl, align 8
  %30 = load i32, ptr %first.addr, align 4
  %tobool28 = icmp ne i32 %30, 0
  br i1 %tobool28, label %cond.true29, label %cond.false31

cond.true29:                                      ; preds = %if.then24
  %31 = load ptr, ptr %zsl, align 8
  %32 = load ptr, ptr %zlrs, align 8
  %call30 = call ptr @zslNthInLexRange(ptr noundef %31, ptr noundef %32, i64 noundef 0)
  br label %cond.end33

cond.false31:                                     ; preds = %if.then24
  %33 = load ptr, ptr %zsl, align 8
  %34 = load ptr, ptr %zlrs, align 8
  %call32 = call ptr @zslNthInLexRange(ptr noundef %33, ptr noundef %34, i64 noundef -1)
  br label %cond.end33

cond.end33:                                       ; preds = %cond.false31, %cond.true29
  %cond34 = phi ptr [ %call30, %cond.true29 ], [ %call32, %cond.false31 ]
  %35 = load ptr, ptr %key.addr, align 8
  %u35 = getelementptr inbounds %struct.RedisModuleKey, ptr %35, i32 0, i32 6
  %current36 = getelementptr inbounds %struct.anon.0, ptr %u35, i32 0, i32 5
  store ptr %cond34, ptr %current36, align 8
  br label %if.end38

if.else37:                                        ; preds = %if.else
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 4950, ptr noundef @.str.45)
  call void @abort() #13
  unreachable

if.end38:                                         ; preds = %cond.end33
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %cond.end
  %36 = load ptr, ptr %key.addr, align 8
  %u40 = getelementptr inbounds %struct.RedisModuleKey, ptr %36, i32 0, i32 6
  %current41 = getelementptr inbounds %struct.anon.0, ptr %u40, i32 0, i32 5
  %37 = load ptr, ptr %current41, align 8
  %cmp42 = icmp eq ptr %37, null
  br i1 %cmp42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %if.end39
  %38 = load ptr, ptr %key.addr, align 8
  %u44 = getelementptr inbounds %struct.RedisModuleKey, ptr %38, i32 0, i32 6
  %er45 = getelementptr inbounds %struct.anon.0, ptr %u44, i32 0, i32 6
  store i32 1, ptr %er45, align 8
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %if.end39
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end46, %if.then4, %if.then
  %39 = load i32, ptr %retval, align 4
  ret i32 %39
}

declare i32 @zslParseLexRange(ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @zzlFirstInLexRange(ptr noundef, ptr noundef) #1

declare ptr @zzlLastInLexRange(ptr noundef, ptr noundef) #1

declare ptr @zslNthInLexRange(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetFirstInLexRange(ptr noundef %key, ptr noundef %min, ptr noundef %max) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %min.addr = alloca ptr, align 8
  %max.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %min, ptr %min.addr, align 8
  store ptr %max, ptr %max.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %min.addr, align 8
  %2 = load ptr, ptr %max.addr, align 8
  %call = call i32 @zsetInitLexRange(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetLastInLexRange(ptr noundef %key, ptr noundef %min, ptr noundef %max) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %min.addr = alloca ptr, align 8
  %max.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %min, ptr %min.addr, align 8
  store ptr %max, ptr %max.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %min.addr, align 8
  %2 = load ptr, ptr %max.addr, align 8
  %call = call i32 @zsetInitLexRange(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef 0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ZsetRangeCurrentElement(ptr noundef %key, ptr noundef %score) #0 {
entry:
  %retval = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %score.addr = alloca ptr, align 8
  %str = alloca ptr, align 8
  %eptr = alloca ptr, align 8
  %sptr = alloca ptr, align 8
  %ele = alloca ptr, align 8
  %ln = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %score, ptr %score.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 6
  %current = getelementptr inbounds %struct.anon.0, ptr %u, i32 0, i32 5
  %5 = load ptr, ptr %current, align 8
  %cmp2 = icmp eq ptr %5, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %value5, align 8
  %bf.load6 = load i32, ptr %7, align 8
  %bf.lshr = lshr i32 %bf.load6, 4
  %bf.clear7 = and i32 %bf.lshr, 15
  %cmp8 = icmp eq i32 %bf.clear7, 11
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end4
  %8 = load ptr, ptr %key.addr, align 8
  %u10 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 6
  %current11 = getelementptr inbounds %struct.anon.0, ptr %u10, i32 0, i32 5
  %9 = load ptr, ptr %current11, align 8
  store ptr %9, ptr %eptr, align 8
  %10 = load ptr, ptr %eptr, align 8
  %call = call ptr @lpGetObject(ptr noundef %10)
  store ptr %call, ptr %ele, align 8
  %11 = load ptr, ptr %score.addr, align 8
  %tobool12 = icmp ne ptr %11, null
  br i1 %tobool12, label %if.then13, label %if.end17

if.then13:                                        ; preds = %if.then9
  %12 = load ptr, ptr %key.addr, align 8
  %value14 = getelementptr inbounds %struct.RedisModuleKey, ptr %12, i32 0, i32 3
  %13 = load ptr, ptr %value14, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %ptr, align 8
  %15 = load ptr, ptr %eptr, align 8
  %call15 = call ptr @lpNext(ptr noundef %14, ptr noundef %15)
  store ptr %call15, ptr %sptr, align 8
  %16 = load ptr, ptr %sptr, align 8
  %call16 = call double @zzlGetScore(ptr noundef %16)
  %17 = load ptr, ptr %score.addr, align 8
  store double %call16, ptr %17, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then13, %if.then9
  %18 = load ptr, ptr %ele, align 8
  %call18 = call ptr @createObject(i32 noundef 0, ptr noundef %18)
  store ptr %call18, ptr %str, align 8
  br label %if.end37

if.else:                                          ; preds = %if.end4
  %19 = load ptr, ptr %key.addr, align 8
  %value19 = getelementptr inbounds %struct.RedisModuleKey, ptr %19, i32 0, i32 3
  %20 = load ptr, ptr %value19, align 8
  %bf.load20 = load i32, ptr %20, align 8
  %bf.lshr21 = lshr i32 %bf.load20, 4
  %bf.clear22 = and i32 %bf.lshr21, 15
  %cmp23 = icmp eq i32 %bf.clear22, 7
  br i1 %cmp23, label %if.then24, label %if.else35

if.then24:                                        ; preds = %if.else
  %21 = load ptr, ptr %key.addr, align 8
  %u25 = getelementptr inbounds %struct.RedisModuleKey, ptr %21, i32 0, i32 6
  %current26 = getelementptr inbounds %struct.anon.0, ptr %u25, i32 0, i32 5
  %22 = load ptr, ptr %current26, align 8
  store ptr %22, ptr %ln, align 8
  %23 = load ptr, ptr %score.addr, align 8
  %tobool27 = icmp ne ptr %23, null
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.then24
  %24 = load ptr, ptr %ln, align 8
  %score29 = getelementptr inbounds %struct.zskiplistNode, ptr %24, i32 0, i32 1
  %25 = load double, ptr %score29, align 8
  %26 = load ptr, ptr %score.addr, align 8
  store double %25, ptr %26, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.then24
  %27 = load ptr, ptr %ln, align 8
  %ele31 = getelementptr inbounds %struct.zskiplistNode, ptr %27, i32 0, i32 0
  %28 = load ptr, ptr %ele31, align 8
  %29 = load ptr, ptr %ln, align 8
  %ele32 = getelementptr inbounds %struct.zskiplistNode, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %ele32, align 8
  %call33 = call i64 @sdslen(ptr noundef %30)
  %call34 = call ptr @createStringObject(ptr noundef %28, i64 noundef %call33)
  store ptr %call34, ptr %str, align 8
  br label %if.end36

if.else35:                                        ; preds = %if.else
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 5001, ptr noundef @.str.45)
  call void @abort() #13
  unreachable

if.end36:                                         ; preds = %if.end30
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end17
  %31 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %ctx, align 8
  %33 = load ptr, ptr %str, align 8
  call void @autoMemoryAdd(ptr noundef %32, i32 noundef 1, ptr noundef %33)
  %34 = load ptr, ptr %str, align 8
  store ptr %34, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end37, %if.then3, %if.then
  %35 = load ptr, ptr %retval, align 8
  ret ptr %35
}

declare ptr @lpGetObject(ptr noundef) #1

declare ptr @lpNext(ptr noundef, ptr noundef) #1

declare double @zzlGetScore(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetRangeNext(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %zl = alloca ptr, align 8
  %eptr = alloca ptr, align 8
  %next = alloca ptr, align 8
  %saved_next = alloca ptr, align 8
  %score = alloca double, align 8
  %ln = alloca ptr, align 8
  %next61 = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 6
  %type = getelementptr inbounds %struct.anon.0, ptr %u, i32 0, i32 0
  %5 = load i32, ptr %type, align 8
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %lor.lhs.false3, label %if.then6

lor.lhs.false3:                                   ; preds = %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %u4 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 6
  %current = getelementptr inbounds %struct.anon.0, ptr %u4, i32 0, i32 5
  %7 = load ptr, ptr %current, align 8
  %tobool5 = icmp ne ptr %7, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false3, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %lor.lhs.false3
  %8 = load ptr, ptr %key.addr, align 8
  %value8 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %value8, align 8
  %bf.load9 = load i32, ptr %9, align 8
  %bf.lshr = lshr i32 %bf.load9, 4
  %bf.clear10 = and i32 %bf.lshr, 15
  %cmp11 = icmp eq i32 %bf.clear10, 11
  br i1 %cmp11, label %if.then12, label %if.else52

if.then12:                                        ; preds = %if.end7
  %10 = load ptr, ptr %key.addr, align 8
  %value13 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %value13, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %ptr, align 8
  store ptr %12, ptr %zl, align 8
  %13 = load ptr, ptr %key.addr, align 8
  %u14 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 6
  %current15 = getelementptr inbounds %struct.anon.0, ptr %u14, i32 0, i32 5
  %14 = load ptr, ptr %current15, align 8
  store ptr %14, ptr %eptr, align 8
  %15 = load ptr, ptr %zl, align 8
  %16 = load ptr, ptr %eptr, align 8
  %call = call ptr @lpNext(ptr noundef %15, ptr noundef %16)
  store ptr %call, ptr %next, align 8
  %17 = load ptr, ptr %next, align 8
  %tobool16 = icmp ne ptr %17, null
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.then12
  %18 = load ptr, ptr %zl, align 8
  %19 = load ptr, ptr %next, align 8
  %call18 = call ptr @lpNext(ptr noundef %18, ptr noundef %19)
  store ptr %call18, ptr %next, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.then12
  %20 = load ptr, ptr %next, align 8
  %cmp20 = icmp eq ptr %20, null
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end19
  %21 = load ptr, ptr %key.addr, align 8
  %u22 = getelementptr inbounds %struct.RedisModuleKey, ptr %21, i32 0, i32 6
  %er = getelementptr inbounds %struct.anon.0, ptr %u22, i32 0, i32 6
  store i32 1, ptr %er, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end19
  %22 = load ptr, ptr %key.addr, align 8
  %u23 = getelementptr inbounds %struct.RedisModuleKey, ptr %22, i32 0, i32 6
  %type24 = getelementptr inbounds %struct.anon.0, ptr %u23, i32 0, i32 0
  %23 = load i32, ptr %type24, align 8
  %cmp25 = icmp eq i32 %23, 2
  br i1 %cmp25, label %if.then26, label %if.else36

if.then26:                                        ; preds = %if.else
  %24 = load ptr, ptr %next, align 8
  store ptr %24, ptr %saved_next, align 8
  %25 = load ptr, ptr %zl, align 8
  %26 = load ptr, ptr %next, align 8
  %call27 = call ptr @lpNext(ptr noundef %25, ptr noundef %26)
  store ptr %call27, ptr %next, align 8
  %27 = load ptr, ptr %next, align 8
  %call28 = call double @zzlGetScore(ptr noundef %27)
  store double %call28, ptr %score, align 8
  %28 = load double, ptr %score, align 8
  %29 = load ptr, ptr %key.addr, align 8
  %u29 = getelementptr inbounds %struct.RedisModuleKey, ptr %29, i32 0, i32 6
  %rs = getelementptr inbounds %struct.anon.0, ptr %u29, i32 0, i32 1
  %call30 = call i32 @zslValueLteMax(double noundef %28, ptr noundef %rs)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.end35, label %if.then32

if.then32:                                        ; preds = %if.then26
  %30 = load ptr, ptr %key.addr, align 8
  %u33 = getelementptr inbounds %struct.RedisModuleKey, ptr %30, i32 0, i32 6
  %er34 = getelementptr inbounds %struct.anon.0, ptr %u33, i32 0, i32 6
  store i32 1, ptr %er34, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.then26
  %31 = load ptr, ptr %saved_next, align 8
  store ptr %31, ptr %next, align 8
  br label %if.end49

if.else36:                                        ; preds = %if.else
  %32 = load ptr, ptr %key.addr, align 8
  %u37 = getelementptr inbounds %struct.RedisModuleKey, ptr %32, i32 0, i32 6
  %type38 = getelementptr inbounds %struct.anon.0, ptr %u37, i32 0, i32 0
  %33 = load i32, ptr %type38, align 8
  %cmp39 = icmp eq i32 %33, 1
  br i1 %cmp39, label %if.then40, label %if.end48

if.then40:                                        ; preds = %if.else36
  %34 = load ptr, ptr %next, align 8
  %35 = load ptr, ptr %key.addr, align 8
  %u41 = getelementptr inbounds %struct.RedisModuleKey, ptr %35, i32 0, i32 6
  %lrs = getelementptr inbounds %struct.anon.0, ptr %u41, i32 0, i32 2
  %call42 = call i32 @zzlLexValueLteMax(ptr noundef %34, ptr noundef %lrs)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.end47, label %if.then44

if.then44:                                        ; preds = %if.then40
  %36 = load ptr, ptr %key.addr, align 8
  %u45 = getelementptr inbounds %struct.RedisModuleKey, ptr %36, i32 0, i32 6
  %er46 = getelementptr inbounds %struct.anon.0, ptr %u45, i32 0, i32 6
  store i32 1, ptr %er46, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.then40
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.else36
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.end35
  %37 = load ptr, ptr %next, align 8
  %38 = load ptr, ptr %key.addr, align 8
  %u50 = getelementptr inbounds %struct.RedisModuleKey, ptr %38, i32 0, i32 6
  %current51 = getelementptr inbounds %struct.anon.0, ptr %u50, i32 0, i32 5
  store ptr %37, ptr %current51, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.else52:                                        ; preds = %if.end7
  %39 = load ptr, ptr %key.addr, align 8
  %value53 = getelementptr inbounds %struct.RedisModuleKey, ptr %39, i32 0, i32 3
  %40 = load ptr, ptr %value53, align 8
  %bf.load54 = load i32, ptr %40, align 8
  %bf.lshr55 = lshr i32 %bf.load54, 4
  %bf.clear56 = and i32 %bf.lshr55, 15
  %cmp57 = icmp eq i32 %bf.clear56, 7
  br i1 %cmp57, label %if.then58, label %if.else95

if.then58:                                        ; preds = %if.else52
  %41 = load ptr, ptr %key.addr, align 8
  %u59 = getelementptr inbounds %struct.RedisModuleKey, ptr %41, i32 0, i32 6
  %current60 = getelementptr inbounds %struct.anon.0, ptr %u59, i32 0, i32 5
  %42 = load ptr, ptr %current60, align 8
  store ptr %42, ptr %ln, align 8
  %43 = load ptr, ptr %ln, align 8
  %level = getelementptr inbounds %struct.zskiplistNode, ptr %43, i32 0, i32 3
  %arrayidx = getelementptr inbounds [0 x %struct.zskiplistLevel], ptr %level, i64 0, i64 0
  %forward = getelementptr inbounds %struct.zskiplistLevel, ptr %arrayidx, i32 0, i32 0
  %44 = load ptr, ptr %forward, align 8
  store ptr %44, ptr %next61, align 8
  %45 = load ptr, ptr %next61, align 8
  %cmp62 = icmp eq ptr %45, null
  br i1 %cmp62, label %if.then63, label %if.else66

if.then63:                                        ; preds = %if.then58
  %46 = load ptr, ptr %key.addr, align 8
  %u64 = getelementptr inbounds %struct.RedisModuleKey, ptr %46, i32 0, i32 6
  %er65 = getelementptr inbounds %struct.anon.0, ptr %u64, i32 0, i32 6
  store i32 1, ptr %er65, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.else66:                                        ; preds = %if.then58
  %47 = load ptr, ptr %key.addr, align 8
  %u67 = getelementptr inbounds %struct.RedisModuleKey, ptr %47, i32 0, i32 6
  %type68 = getelementptr inbounds %struct.anon.0, ptr %u67, i32 0, i32 0
  %48 = load i32, ptr %type68, align 8
  %cmp69 = icmp eq i32 %48, 2
  br i1 %cmp69, label %land.lhs.true, label %if.else78

land.lhs.true:                                    ; preds = %if.else66
  %49 = load ptr, ptr %next61, align 8
  %score70 = getelementptr inbounds %struct.zskiplistNode, ptr %49, i32 0, i32 1
  %50 = load double, ptr %score70, align 8
  %51 = load ptr, ptr %key.addr, align 8
  %u71 = getelementptr inbounds %struct.RedisModuleKey, ptr %51, i32 0, i32 6
  %rs72 = getelementptr inbounds %struct.anon.0, ptr %u71, i32 0, i32 1
  %call73 = call i32 @zslValueLteMax(double noundef %50, ptr noundef %rs72)
  %tobool74 = icmp ne i32 %call73, 0
  br i1 %tobool74, label %if.else78, label %if.then75

if.then75:                                        ; preds = %land.lhs.true
  %52 = load ptr, ptr %key.addr, align 8
  %u76 = getelementptr inbounds %struct.RedisModuleKey, ptr %52, i32 0, i32 6
  %er77 = getelementptr inbounds %struct.anon.0, ptr %u76, i32 0, i32 6
  store i32 1, ptr %er77, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.else78:                                        ; preds = %land.lhs.true, %if.else66
  %53 = load ptr, ptr %key.addr, align 8
  %u79 = getelementptr inbounds %struct.RedisModuleKey, ptr %53, i32 0, i32 6
  %type80 = getelementptr inbounds %struct.anon.0, ptr %u79, i32 0, i32 0
  %54 = load i32, ptr %type80, align 8
  %cmp81 = icmp eq i32 %54, 1
  br i1 %cmp81, label %if.then82, label %if.end91

if.then82:                                        ; preds = %if.else78
  %55 = load ptr, ptr %next61, align 8
  %ele = getelementptr inbounds %struct.zskiplistNode, ptr %55, i32 0, i32 0
  %56 = load ptr, ptr %ele, align 8
  %57 = load ptr, ptr %key.addr, align 8
  %u83 = getelementptr inbounds %struct.RedisModuleKey, ptr %57, i32 0, i32 6
  %lrs84 = getelementptr inbounds %struct.anon.0, ptr %u83, i32 0, i32 2
  %call85 = call i32 @zslLexValueLteMax(ptr noundef %56, ptr noundef %lrs84)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.end90, label %if.then87

if.then87:                                        ; preds = %if.then82
  %58 = load ptr, ptr %key.addr, align 8
  %u88 = getelementptr inbounds %struct.RedisModuleKey, ptr %58, i32 0, i32 6
  %er89 = getelementptr inbounds %struct.anon.0, ptr %u88, i32 0, i32 6
  store i32 1, ptr %er89, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end90:                                         ; preds = %if.then82
  br label %if.end91

if.end91:                                         ; preds = %if.end90, %if.else78
  br label %if.end92

if.end92:                                         ; preds = %if.end91
  %59 = load ptr, ptr %next61, align 8
  %60 = load ptr, ptr %key.addr, align 8
  %u93 = getelementptr inbounds %struct.RedisModuleKey, ptr %60, i32 0, i32 6
  %current94 = getelementptr inbounds %struct.anon.0, ptr %u93, i32 0, i32 5
  store ptr %59, ptr %current94, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.else95:                                        ; preds = %if.else52
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 5067, ptr noundef @.str.45)
  call void @abort() #13
  unreachable

return:                                           ; preds = %if.end92, %if.then87, %if.then75, %if.then63, %if.end49, %if.then44, %if.then32, %if.then21, %if.then6, %if.then
  %61 = load i32, ptr %retval, align 4
  ret i32 %61
}

declare i32 @zslValueLteMax(double noundef, ptr noundef) #1

declare i32 @zzlLexValueLteMax(ptr noundef, ptr noundef) #1

declare i32 @zslLexValueLteMax(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ZsetRangePrev(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %zl = alloca ptr, align 8
  %eptr = alloca ptr, align 8
  %prev = alloca ptr, align 8
  %saved_prev = alloca ptr, align 8
  %score = alloca double, align 8
  %ln = alloca ptr, align 8
  %prev61 = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 6
  %type = getelementptr inbounds %struct.anon.0, ptr %u, i32 0, i32 0
  %5 = load i32, ptr %type, align 8
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %lor.lhs.false3, label %if.then6

lor.lhs.false3:                                   ; preds = %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %u4 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 6
  %current = getelementptr inbounds %struct.anon.0, ptr %u4, i32 0, i32 5
  %7 = load ptr, ptr %current, align 8
  %tobool5 = icmp ne ptr %7, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false3, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %lor.lhs.false3
  %8 = load ptr, ptr %key.addr, align 8
  %value8 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %value8, align 8
  %bf.load9 = load i32, ptr %9, align 8
  %bf.lshr = lshr i32 %bf.load9, 4
  %bf.clear10 = and i32 %bf.lshr, 15
  %cmp11 = icmp eq i32 %bf.clear10, 11
  br i1 %cmp11, label %if.then12, label %if.else52

if.then12:                                        ; preds = %if.end7
  %10 = load ptr, ptr %key.addr, align 8
  %value13 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %value13, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %ptr, align 8
  store ptr %12, ptr %zl, align 8
  %13 = load ptr, ptr %key.addr, align 8
  %u14 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 6
  %current15 = getelementptr inbounds %struct.anon.0, ptr %u14, i32 0, i32 5
  %14 = load ptr, ptr %current15, align 8
  store ptr %14, ptr %eptr, align 8
  %15 = load ptr, ptr %zl, align 8
  %16 = load ptr, ptr %eptr, align 8
  %call = call ptr @lpPrev(ptr noundef %15, ptr noundef %16)
  store ptr %call, ptr %prev, align 8
  %17 = load ptr, ptr %prev, align 8
  %tobool16 = icmp ne ptr %17, null
  br i1 %tobool16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.then12
  %18 = load ptr, ptr %zl, align 8
  %19 = load ptr, ptr %prev, align 8
  %call18 = call ptr @lpPrev(ptr noundef %18, ptr noundef %19)
  store ptr %call18, ptr %prev, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.then12
  %20 = load ptr, ptr %prev, align 8
  %cmp20 = icmp eq ptr %20, null
  br i1 %cmp20, label %if.then21, label %if.else

if.then21:                                        ; preds = %if.end19
  %21 = load ptr, ptr %key.addr, align 8
  %u22 = getelementptr inbounds %struct.RedisModuleKey, ptr %21, i32 0, i32 6
  %er = getelementptr inbounds %struct.anon.0, ptr %u22, i32 0, i32 6
  store i32 1, ptr %er, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end19
  %22 = load ptr, ptr %key.addr, align 8
  %u23 = getelementptr inbounds %struct.RedisModuleKey, ptr %22, i32 0, i32 6
  %type24 = getelementptr inbounds %struct.anon.0, ptr %u23, i32 0, i32 0
  %23 = load i32, ptr %type24, align 8
  %cmp25 = icmp eq i32 %23, 2
  br i1 %cmp25, label %if.then26, label %if.else36

if.then26:                                        ; preds = %if.else
  %24 = load ptr, ptr %prev, align 8
  store ptr %24, ptr %saved_prev, align 8
  %25 = load ptr, ptr %zl, align 8
  %26 = load ptr, ptr %prev, align 8
  %call27 = call ptr @lpNext(ptr noundef %25, ptr noundef %26)
  store ptr %call27, ptr %prev, align 8
  %27 = load ptr, ptr %prev, align 8
  %call28 = call double @zzlGetScore(ptr noundef %27)
  store double %call28, ptr %score, align 8
  %28 = load double, ptr %score, align 8
  %29 = load ptr, ptr %key.addr, align 8
  %u29 = getelementptr inbounds %struct.RedisModuleKey, ptr %29, i32 0, i32 6
  %rs = getelementptr inbounds %struct.anon.0, ptr %u29, i32 0, i32 1
  %call30 = call i32 @zslValueGteMin(double noundef %28, ptr noundef %rs)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.end35, label %if.then32

if.then32:                                        ; preds = %if.then26
  %30 = load ptr, ptr %key.addr, align 8
  %u33 = getelementptr inbounds %struct.RedisModuleKey, ptr %30, i32 0, i32 6
  %er34 = getelementptr inbounds %struct.anon.0, ptr %u33, i32 0, i32 6
  store i32 1, ptr %er34, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.then26
  %31 = load ptr, ptr %saved_prev, align 8
  store ptr %31, ptr %prev, align 8
  br label %if.end49

if.else36:                                        ; preds = %if.else
  %32 = load ptr, ptr %key.addr, align 8
  %u37 = getelementptr inbounds %struct.RedisModuleKey, ptr %32, i32 0, i32 6
  %type38 = getelementptr inbounds %struct.anon.0, ptr %u37, i32 0, i32 0
  %33 = load i32, ptr %type38, align 8
  %cmp39 = icmp eq i32 %33, 1
  br i1 %cmp39, label %if.then40, label %if.end48

if.then40:                                        ; preds = %if.else36
  %34 = load ptr, ptr %prev, align 8
  %35 = load ptr, ptr %key.addr, align 8
  %u41 = getelementptr inbounds %struct.RedisModuleKey, ptr %35, i32 0, i32 6
  %lrs = getelementptr inbounds %struct.anon.0, ptr %u41, i32 0, i32 2
  %call42 = call i32 @zzlLexValueGteMin(ptr noundef %34, ptr noundef %lrs)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.end47, label %if.then44

if.then44:                                        ; preds = %if.then40
  %36 = load ptr, ptr %key.addr, align 8
  %u45 = getelementptr inbounds %struct.RedisModuleKey, ptr %36, i32 0, i32 6
  %er46 = getelementptr inbounds %struct.anon.0, ptr %u45, i32 0, i32 6
  store i32 1, ptr %er46, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.then40
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.else36
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.end35
  %37 = load ptr, ptr %prev, align 8
  %38 = load ptr, ptr %key.addr, align 8
  %u50 = getelementptr inbounds %struct.RedisModuleKey, ptr %38, i32 0, i32 6
  %current51 = getelementptr inbounds %struct.anon.0, ptr %u50, i32 0, i32 5
  store ptr %37, ptr %current51, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.else52:                                        ; preds = %if.end7
  %39 = load ptr, ptr %key.addr, align 8
  %value53 = getelementptr inbounds %struct.RedisModuleKey, ptr %39, i32 0, i32 3
  %40 = load ptr, ptr %value53, align 8
  %bf.load54 = load i32, ptr %40, align 8
  %bf.lshr55 = lshr i32 %bf.load54, 4
  %bf.clear56 = and i32 %bf.lshr55, 15
  %cmp57 = icmp eq i32 %bf.clear56, 7
  br i1 %cmp57, label %if.then58, label %if.else95

if.then58:                                        ; preds = %if.else52
  %41 = load ptr, ptr %key.addr, align 8
  %u59 = getelementptr inbounds %struct.RedisModuleKey, ptr %41, i32 0, i32 6
  %current60 = getelementptr inbounds %struct.anon.0, ptr %u59, i32 0, i32 5
  %42 = load ptr, ptr %current60, align 8
  store ptr %42, ptr %ln, align 8
  %43 = load ptr, ptr %ln, align 8
  %backward = getelementptr inbounds %struct.zskiplistNode, ptr %43, i32 0, i32 2
  %44 = load ptr, ptr %backward, align 8
  store ptr %44, ptr %prev61, align 8
  %45 = load ptr, ptr %prev61, align 8
  %cmp62 = icmp eq ptr %45, null
  br i1 %cmp62, label %if.then63, label %if.else66

if.then63:                                        ; preds = %if.then58
  %46 = load ptr, ptr %key.addr, align 8
  %u64 = getelementptr inbounds %struct.RedisModuleKey, ptr %46, i32 0, i32 6
  %er65 = getelementptr inbounds %struct.anon.0, ptr %u64, i32 0, i32 6
  store i32 1, ptr %er65, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.else66:                                        ; preds = %if.then58
  %47 = load ptr, ptr %key.addr, align 8
  %u67 = getelementptr inbounds %struct.RedisModuleKey, ptr %47, i32 0, i32 6
  %type68 = getelementptr inbounds %struct.anon.0, ptr %u67, i32 0, i32 0
  %48 = load i32, ptr %type68, align 8
  %cmp69 = icmp eq i32 %48, 2
  br i1 %cmp69, label %land.lhs.true, label %if.else78

land.lhs.true:                                    ; preds = %if.else66
  %49 = load ptr, ptr %prev61, align 8
  %score70 = getelementptr inbounds %struct.zskiplistNode, ptr %49, i32 0, i32 1
  %50 = load double, ptr %score70, align 8
  %51 = load ptr, ptr %key.addr, align 8
  %u71 = getelementptr inbounds %struct.RedisModuleKey, ptr %51, i32 0, i32 6
  %rs72 = getelementptr inbounds %struct.anon.0, ptr %u71, i32 0, i32 1
  %call73 = call i32 @zslValueGteMin(double noundef %50, ptr noundef %rs72)
  %tobool74 = icmp ne i32 %call73, 0
  br i1 %tobool74, label %if.else78, label %if.then75

if.then75:                                        ; preds = %land.lhs.true
  %52 = load ptr, ptr %key.addr, align 8
  %u76 = getelementptr inbounds %struct.RedisModuleKey, ptr %52, i32 0, i32 6
  %er77 = getelementptr inbounds %struct.anon.0, ptr %u76, i32 0, i32 6
  store i32 1, ptr %er77, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.else78:                                        ; preds = %land.lhs.true, %if.else66
  %53 = load ptr, ptr %key.addr, align 8
  %u79 = getelementptr inbounds %struct.RedisModuleKey, ptr %53, i32 0, i32 6
  %type80 = getelementptr inbounds %struct.anon.0, ptr %u79, i32 0, i32 0
  %54 = load i32, ptr %type80, align 8
  %cmp81 = icmp eq i32 %54, 1
  br i1 %cmp81, label %if.then82, label %if.end91

if.then82:                                        ; preds = %if.else78
  %55 = load ptr, ptr %prev61, align 8
  %ele = getelementptr inbounds %struct.zskiplistNode, ptr %55, i32 0, i32 0
  %56 = load ptr, ptr %ele, align 8
  %57 = load ptr, ptr %key.addr, align 8
  %u83 = getelementptr inbounds %struct.RedisModuleKey, ptr %57, i32 0, i32 6
  %lrs84 = getelementptr inbounds %struct.anon.0, ptr %u83, i32 0, i32 2
  %call85 = call i32 @zslLexValueGteMin(ptr noundef %56, ptr noundef %lrs84)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.end90, label %if.then87

if.then87:                                        ; preds = %if.then82
  %58 = load ptr, ptr %key.addr, align 8
  %u88 = getelementptr inbounds %struct.RedisModuleKey, ptr %58, i32 0, i32 6
  %er89 = getelementptr inbounds %struct.anon.0, ptr %u88, i32 0, i32 6
  store i32 1, ptr %er89, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end90:                                         ; preds = %if.then82
  br label %if.end91

if.end91:                                         ; preds = %if.end90, %if.else78
  br label %if.end92

if.end92:                                         ; preds = %if.end91
  %59 = load ptr, ptr %prev61, align 8
  %60 = load ptr, ptr %key.addr, align 8
  %u93 = getelementptr inbounds %struct.RedisModuleKey, ptr %60, i32 0, i32 6
  %current94 = getelementptr inbounds %struct.anon.0, ptr %u93, i32 0, i32 5
  store ptr %59, ptr %current94, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.else95:                                        ; preds = %if.else52
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 5131, ptr noundef @.str.45)
  call void @abort() #13
  unreachable

return:                                           ; preds = %if.end92, %if.then87, %if.then75, %if.then63, %if.end49, %if.then44, %if.then32, %if.then21, %if.then6, %if.then
  %61 = load i32, ptr %retval, align 4
  ret i32 %61
}

declare ptr @lpPrev(ptr noundef, ptr noundef) #1

declare i32 @zslValueGteMin(double noundef, ptr noundef) #1

declare i32 @zzlLexValueGteMin(ptr noundef, ptr noundef) #1

declare i32 @zslLexValueGteMin(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_HashSet(ptr noundef %key, i32 noundef %flags, ...) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %count = alloca i32, align 4
  %field = alloca ptr, align 8
  %value18 = alloca ptr, align 8
  %cfield = alloca ptr, align 8
  %exists = alloca i32, align 4
  %low_flags = alloca i32, align 4
  %argv = alloca [2 x ptr], align 16
  %updated = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %and = and i32 %1, -24
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %land.lhs.true, label %if.else6

land.lhs.true:                                    ; preds = %if.else
  %4 = load ptr, ptr %key.addr, align 8
  %value3 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value3, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 4
  br i1 %cmp, label %if.then4, label %if.else6

if.then4:                                         ; preds = %land.lhs.true
  %call5 = call ptr @__errno_location() #15
  store i32 95, ptr %call5, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.else6:                                         ; preds = %land.lhs.true, %if.else
  %6 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %mode, align 8
  %and7 = and i32 %7, 2
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.end, label %if.then9

if.then9:                                         ; preds = %if.else6
  %call10 = call ptr @__errno_location() #15
  store i32 9, ptr %call10, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else6
  br label %if.end11

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11
  %8 = load ptr, ptr %key.addr, align 8
  %value13 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %value13, align 8
  %cmp14 = icmp eq ptr %9, null
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end12
  %10 = load ptr, ptr %key.addr, align 8
  %call16 = call i32 @moduleCreateEmptyKey(ptr noundef %10, i32 noundef 3)
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end12
  store i32 0, ptr %count, align 4
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  br label %while.body

while.body:                                       ; preds = %if.end105, %if.end86, %if.end75, %if.end17
  %11 = load i32, ptr %flags.addr, align 4
  %and19 = and i32 %11, 4
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.else28

if.then21:                                        ; preds = %while.body
  %arraydecay22 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %gp_offset_p = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay22, i32 0, i32 0
  %gp_offset = load i32, ptr %gp_offset_p, align 16
  %fits_in_gp = icmp ule i32 %gp_offset, 40
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %if.then21
  %12 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay22, i32 0, i32 3
  %reg_save_area = load ptr, ptr %12, align 16
  %13 = getelementptr i8, ptr %reg_save_area, i32 %gp_offset
  %14 = add i32 %gp_offset, 8
  store i32 %14, ptr %gp_offset_p, align 16
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %if.then21
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay22, i32 0, i32 2
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i32 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %13, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %15 = load ptr, ptr %vaarg.addr, align 8
  store ptr %15, ptr %cfield, align 8
  %16 = load ptr, ptr %cfield, align 8
  %cmp23 = icmp eq ptr %16, null
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %vaarg.end
  br label %while.end

if.end25:                                         ; preds = %vaarg.end
  %17 = load ptr, ptr %cfield, align 8
  %18 = load ptr, ptr %cfield, align 8
  %call26 = call i64 @strlen(ptr noundef %18) #14
  %call27 = call ptr @createRawStringObject(ptr noundef %17, i64 noundef %call26)
  store ptr %call27, ptr %field, align 8
  br label %if.end44

if.else28:                                        ; preds = %while.body
  %arraydecay29 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %gp_offset_p30 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay29, i32 0, i32 0
  %gp_offset31 = load i32, ptr %gp_offset_p30, align 16
  %fits_in_gp32 = icmp ule i32 %gp_offset31, 40
  br i1 %fits_in_gp32, label %vaarg.in_reg33, label %vaarg.in_mem35

vaarg.in_reg33:                                   ; preds = %if.else28
  %19 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay29, i32 0, i32 3
  %reg_save_area34 = load ptr, ptr %19, align 16
  %20 = getelementptr i8, ptr %reg_save_area34, i32 %gp_offset31
  %21 = add i32 %gp_offset31, 8
  store i32 %21, ptr %gp_offset_p30, align 16
  br label %vaarg.end39

vaarg.in_mem35:                                   ; preds = %if.else28
  %overflow_arg_area_p36 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay29, i32 0, i32 2
  %overflow_arg_area37 = load ptr, ptr %overflow_arg_area_p36, align 8
  %overflow_arg_area.next38 = getelementptr i8, ptr %overflow_arg_area37, i32 8
  store ptr %overflow_arg_area.next38, ptr %overflow_arg_area_p36, align 8
  br label %vaarg.end39

vaarg.end39:                                      ; preds = %vaarg.in_mem35, %vaarg.in_reg33
  %vaarg.addr40 = phi ptr [ %20, %vaarg.in_reg33 ], [ %overflow_arg_area37, %vaarg.in_mem35 ]
  %22 = load ptr, ptr %vaarg.addr40, align 8
  store ptr %22, ptr %field, align 8
  %23 = load ptr, ptr %field, align 8
  %cmp41 = icmp eq ptr %23, null
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %vaarg.end39
  br label %while.end

if.end43:                                         ; preds = %vaarg.end39
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.end25
  %arraydecay45 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %gp_offset_p46 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay45, i32 0, i32 0
  %gp_offset47 = load i32, ptr %gp_offset_p46, align 16
  %fits_in_gp48 = icmp ule i32 %gp_offset47, 40
  br i1 %fits_in_gp48, label %vaarg.in_reg49, label %vaarg.in_mem51

vaarg.in_reg49:                                   ; preds = %if.end44
  %24 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay45, i32 0, i32 3
  %reg_save_area50 = load ptr, ptr %24, align 16
  %25 = getelementptr i8, ptr %reg_save_area50, i32 %gp_offset47
  %26 = add i32 %gp_offset47, 8
  store i32 %26, ptr %gp_offset_p46, align 16
  br label %vaarg.end55

vaarg.in_mem51:                                   ; preds = %if.end44
  %overflow_arg_area_p52 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay45, i32 0, i32 2
  %overflow_arg_area53 = load ptr, ptr %overflow_arg_area_p52, align 8
  %overflow_arg_area.next54 = getelementptr i8, ptr %overflow_arg_area53, i32 8
  store ptr %overflow_arg_area.next54, ptr %overflow_arg_area_p52, align 8
  br label %vaarg.end55

vaarg.end55:                                      ; preds = %vaarg.in_mem51, %vaarg.in_reg49
  %vaarg.addr56 = phi ptr [ %25, %vaarg.in_reg49 ], [ %overflow_arg_area53, %vaarg.in_mem51 ]
  %27 = load ptr, ptr %vaarg.addr56, align 8
  store ptr %27, ptr %value18, align 8
  %28 = load i32, ptr %flags.addr, align 4
  %and57 = and i32 %28, 3
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then59, label %if.end77

if.then59:                                        ; preds = %vaarg.end55
  %29 = load ptr, ptr %key.addr, align 8
  %value60 = getelementptr inbounds %struct.RedisModuleKey, ptr %29, i32 0, i32 3
  %30 = load ptr, ptr %value60, align 8
  %31 = load ptr, ptr %field, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %31, i32 0, i32 2
  %32 = load ptr, ptr %ptr, align 8
  %call61 = call i32 @hashTypeExists(ptr noundef %30, ptr noundef %32)
  store i32 %call61, ptr %exists, align 4
  %33 = load i32, ptr %flags.addr, align 4
  %and62 = and i32 %33, 2
  %tobool63 = icmp ne i32 %and62, 0
  br i1 %tobool63, label %land.lhs.true64, label %lor.lhs.false66

land.lhs.true64:                                  ; preds = %if.then59
  %34 = load i32, ptr %exists, align 4
  %tobool65 = icmp ne i32 %34, 0
  br i1 %tobool65, label %lor.lhs.false66, label %if.then71

lor.lhs.false66:                                  ; preds = %land.lhs.true64, %if.then59
  %35 = load i32, ptr %flags.addr, align 4
  %and67 = and i32 %35, 1
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %land.lhs.true69, label %if.end76

land.lhs.true69:                                  ; preds = %lor.lhs.false66
  %36 = load i32, ptr %exists, align 4
  %tobool70 = icmp ne i32 %36, 0
  br i1 %tobool70, label %if.then71, label %if.end76

if.then71:                                        ; preds = %land.lhs.true69, %land.lhs.true64
  %37 = load i32, ptr %flags.addr, align 4
  %and72 = and i32 %37, 4
  %tobool73 = icmp ne i32 %and72, 0
  br i1 %tobool73, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.then71
  %38 = load ptr, ptr %field, align 8
  call void @decrRefCount(ptr noundef %38)
  br label %if.end75

if.end75:                                         ; preds = %if.then74, %if.then71
  br label %while.body

if.end76:                                         ; preds = %land.lhs.true69, %lor.lhs.false66
  br label %if.end77

if.end77:                                         ; preds = %if.end76, %vaarg.end55
  %39 = load ptr, ptr %value18, align 8
  %cmp78 = icmp eq ptr %39, inttoptr (i64 1 to ptr)
  br i1 %cmp78, label %if.then79, label %if.end87

if.then79:                                        ; preds = %if.end77
  %40 = load ptr, ptr %key.addr, align 8
  %value80 = getelementptr inbounds %struct.RedisModuleKey, ptr %40, i32 0, i32 3
  %41 = load ptr, ptr %value80, align 8
  %42 = load ptr, ptr %field, align 8
  %ptr81 = getelementptr inbounds %struct.redisObject, ptr %42, i32 0, i32 2
  %43 = load ptr, ptr %ptr81, align 8
  %call82 = call i32 @hashTypeDelete(ptr noundef %41, ptr noundef %43)
  %44 = load i32, ptr %count, align 4
  %add = add nsw i32 %44, %call82
  store i32 %add, ptr %count, align 4
  %45 = load i32, ptr %flags.addr, align 4
  %and83 = and i32 %45, 4
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %if.then85, label %if.end86

if.then85:                                        ; preds = %if.then79
  %46 = load ptr, ptr %field, align 8
  call void @decrRefCount(ptr noundef %46)
  br label %if.end86

if.end86:                                         ; preds = %if.then85, %if.then79
  br label %while.body

if.end87:                                         ; preds = %if.end77
  store i32 0, ptr %low_flags, align 4
  %47 = load i32, ptr %flags.addr, align 4
  %and88 = and i32 %47, 4
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.end87
  %48 = load i32, ptr %low_flags, align 4
  %or = or i32 %48, 1
  store i32 %or, ptr %low_flags, align 4
  br label %if.end91

if.end91:                                         ; preds = %if.then90, %if.end87
  %arrayinit.begin = getelementptr inbounds [2 x ptr], ptr %argv, i64 0, i64 0
  %49 = load ptr, ptr %field, align 8
  store ptr %49, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %50 = load ptr, ptr %value18, align 8
  store ptr %50, ptr %arrayinit.element, align 8
  %51 = load ptr, ptr %key.addr, align 8
  %value92 = getelementptr inbounds %struct.RedisModuleKey, ptr %51, i32 0, i32 3
  %52 = load ptr, ptr %value92, align 8
  %arraydecay93 = getelementptr inbounds [2 x ptr], ptr %argv, i64 0, i64 0
  call void @hashTypeTryConversion(ptr noundef %52, ptr noundef %arraydecay93, i32 noundef 0, i32 noundef 1)
  %53 = load ptr, ptr %key.addr, align 8
  %value94 = getelementptr inbounds %struct.RedisModuleKey, ptr %53, i32 0, i32 3
  %54 = load ptr, ptr %value94, align 8
  %55 = load ptr, ptr %field, align 8
  %ptr95 = getelementptr inbounds %struct.redisObject, ptr %55, i32 0, i32 2
  %56 = load ptr, ptr %ptr95, align 8
  %57 = load ptr, ptr %value18, align 8
  %ptr96 = getelementptr inbounds %struct.redisObject, ptr %57, i32 0, i32 2
  %58 = load ptr, ptr %ptr96, align 8
  %59 = load i32, ptr %low_flags, align 4
  %call97 = call i32 @hashTypeSet(ptr noundef %54, ptr noundef %56, ptr noundef %58, i32 noundef %59)
  store i32 %call97, ptr %updated, align 4
  %60 = load i32, ptr %flags.addr, align 4
  %and98 = and i32 %60, 16
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end91
  br label %cond.end

cond.false:                                       ; preds = %if.end91
  %61 = load i32, ptr %updated, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 1, %cond.true ], [ %61, %cond.false ]
  %62 = load i32, ptr %count, align 4
  %add100 = add nsw i32 %62, %cond
  store i32 %add100, ptr %count, align 4
  %63 = load i32, ptr %flags.addr, align 4
  %and101 = and i32 %63, 4
  %tobool102 = icmp ne i32 %and101, 0
  br i1 %tobool102, label %if.then103, label %if.end105

if.then103:                                       ; preds = %cond.end
  %64 = load ptr, ptr %field, align 8
  %ptr104 = getelementptr inbounds %struct.redisObject, ptr %64, i32 0, i32 2
  store ptr null, ptr %ptr104, align 8
  %65 = load ptr, ptr %field, align 8
  call void @decrRefCount(ptr noundef %65)
  br label %if.end105

if.end105:                                        ; preds = %if.then103, %cond.end
  br label %while.body

while.end:                                        ; preds = %if.then42, %if.then24
  %arraydecay106 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay106)
  %66 = load ptr, ptr %key.addr, align 8
  %call107 = call i32 @moduleDelKeyIfEmpty(ptr noundef %66)
  %67 = load i32, ptr %count, align 4
  %cmp108 = icmp eq i32 %67, 0
  br i1 %cmp108, label %if.then109, label %if.end111

if.then109:                                       ; preds = %while.end
  %call110 = call ptr @__errno_location() #15
  store i32 2, ptr %call110, align 4
  br label %if.end111

if.end111:                                        ; preds = %if.then109, %while.end
  %68 = load i32, ptr %count, align 4
  store i32 %68, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end111, %if.then9, %if.then4, %if.then
  %69 = load i32, ptr %retval, align 4
  ret i32 %69
}

declare ptr @createRawStringObject(ptr noundef, i64 noundef) #1

declare i32 @hashTypeExists(ptr noundef, ptr noundef) #1

declare i32 @hashTypeDelete(ptr noundef, ptr noundef) #1

declare void @hashTypeTryConversion(ptr noundef, ptr noundef, i32 noundef, i32 noundef) #1

declare i32 @hashTypeSet(ptr noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_HashGet(ptr noundef %key, i32 noundef %flags, ...) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %field = alloca ptr, align 8
  %valueptr = alloca ptr, align 8
  %existsptr = alloca ptr, align 8
  %cfield = alloca ptr, align 8
  %decoded = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  br label %while.body

while.body:                                       ; preds = %if.end79, %if.end
  %4 = load i32, ptr %flags.addr, align 4
  %and = and i32 %4, 4
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %while.body
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %gp_offset_p = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay4, i32 0, i32 0
  %gp_offset = load i32, ptr %gp_offset_p, align 16
  %fits_in_gp = icmp ule i32 %gp_offset, 40
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %if.then3
  %5 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay4, i32 0, i32 3
  %reg_save_area = load ptr, ptr %5, align 16
  %6 = getelementptr i8, ptr %reg_save_area, i32 %gp_offset
  %7 = add i32 %gp_offset, 8
  store i32 %7, ptr %gp_offset_p, align 16
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %if.then3
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay4, i32 0, i32 2
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i32 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %6, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %8 = load ptr, ptr %vaarg.addr, align 8
  store ptr %8, ptr %cfield, align 8
  %9 = load ptr, ptr %cfield, align 8
  %cmp5 = icmp eq ptr %9, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %vaarg.end
  br label %while.end

if.end7:                                          ; preds = %vaarg.end
  %10 = load ptr, ptr %cfield, align 8
  %11 = load ptr, ptr %cfield, align 8
  %call = call i64 @strlen(ptr noundef %11) #14
  %call8 = call ptr @createRawStringObject(ptr noundef %10, i64 noundef %call)
  store ptr %call8, ptr %field, align 8
  br label %if.end24

if.else:                                          ; preds = %while.body
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %gp_offset_p10 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay9, i32 0, i32 0
  %gp_offset11 = load i32, ptr %gp_offset_p10, align 16
  %fits_in_gp12 = icmp ule i32 %gp_offset11, 40
  br i1 %fits_in_gp12, label %vaarg.in_reg13, label %vaarg.in_mem15

vaarg.in_reg13:                                   ; preds = %if.else
  %12 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay9, i32 0, i32 3
  %reg_save_area14 = load ptr, ptr %12, align 16
  %13 = getelementptr i8, ptr %reg_save_area14, i32 %gp_offset11
  %14 = add i32 %gp_offset11, 8
  store i32 %14, ptr %gp_offset_p10, align 16
  br label %vaarg.end19

vaarg.in_mem15:                                   ; preds = %if.else
  %overflow_arg_area_p16 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay9, i32 0, i32 2
  %overflow_arg_area17 = load ptr, ptr %overflow_arg_area_p16, align 8
  %overflow_arg_area.next18 = getelementptr i8, ptr %overflow_arg_area17, i32 8
  store ptr %overflow_arg_area.next18, ptr %overflow_arg_area_p16, align 8
  br label %vaarg.end19

vaarg.end19:                                      ; preds = %vaarg.in_mem15, %vaarg.in_reg13
  %vaarg.addr20 = phi ptr [ %13, %vaarg.in_reg13 ], [ %overflow_arg_area17, %vaarg.in_mem15 ]
  %15 = load ptr, ptr %vaarg.addr20, align 8
  store ptr %15, ptr %field, align 8
  %16 = load ptr, ptr %field, align 8
  %cmp21 = icmp eq ptr %16, null
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %vaarg.end19
  br label %while.end

if.end23:                                         ; preds = %vaarg.end19
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.end7
  %17 = load i32, ptr %flags.addr, align 4
  %and25 = and i32 %17, 8
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.else47

if.then27:                                        ; preds = %if.end24
  %arraydecay28 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %gp_offset_p29 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay28, i32 0, i32 0
  %gp_offset30 = load i32, ptr %gp_offset_p29, align 16
  %fits_in_gp31 = icmp ule i32 %gp_offset30, 40
  br i1 %fits_in_gp31, label %vaarg.in_reg32, label %vaarg.in_mem34

vaarg.in_reg32:                                   ; preds = %if.then27
  %18 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay28, i32 0, i32 3
  %reg_save_area33 = load ptr, ptr %18, align 16
  %19 = getelementptr i8, ptr %reg_save_area33, i32 %gp_offset30
  %20 = add i32 %gp_offset30, 8
  store i32 %20, ptr %gp_offset_p29, align 16
  br label %vaarg.end38

vaarg.in_mem34:                                   ; preds = %if.then27
  %overflow_arg_area_p35 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay28, i32 0, i32 2
  %overflow_arg_area36 = load ptr, ptr %overflow_arg_area_p35, align 8
  %overflow_arg_area.next37 = getelementptr i8, ptr %overflow_arg_area36, i32 8
  store ptr %overflow_arg_area.next37, ptr %overflow_arg_area_p35, align 8
  br label %vaarg.end38

vaarg.end38:                                      ; preds = %vaarg.in_mem34, %vaarg.in_reg32
  %vaarg.addr39 = phi ptr [ %19, %vaarg.in_reg32 ], [ %overflow_arg_area36, %vaarg.in_mem34 ]
  %21 = load ptr, ptr %vaarg.addr39, align 8
  store ptr %21, ptr %existsptr, align 8
  %22 = load ptr, ptr %key.addr, align 8
  %value40 = getelementptr inbounds %struct.RedisModuleKey, ptr %22, i32 0, i32 3
  %23 = load ptr, ptr %value40, align 8
  %tobool41 = icmp ne ptr %23, null
  br i1 %tobool41, label %if.then42, label %if.else45

if.then42:                                        ; preds = %vaarg.end38
  %24 = load ptr, ptr %key.addr, align 8
  %value43 = getelementptr inbounds %struct.RedisModuleKey, ptr %24, i32 0, i32 3
  %25 = load ptr, ptr %value43, align 8
  %26 = load ptr, ptr %field, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %ptr, align 8
  %call44 = call i32 @hashTypeExists(ptr noundef %25, ptr noundef %27)
  %28 = load ptr, ptr %existsptr, align 8
  store i32 %call44, ptr %28, align 4
  br label %if.end46

if.else45:                                        ; preds = %vaarg.end38
  %29 = load ptr, ptr %existsptr, align 8
  store i32 0, ptr %29, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.else45, %if.then42
  br label %if.end75

if.else47:                                        ; preds = %if.end24
  %arraydecay48 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %gp_offset_p49 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay48, i32 0, i32 0
  %gp_offset50 = load i32, ptr %gp_offset_p49, align 16
  %fits_in_gp51 = icmp ule i32 %gp_offset50, 40
  br i1 %fits_in_gp51, label %vaarg.in_reg52, label %vaarg.in_mem54

vaarg.in_reg52:                                   ; preds = %if.else47
  %30 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay48, i32 0, i32 3
  %reg_save_area53 = load ptr, ptr %30, align 16
  %31 = getelementptr i8, ptr %reg_save_area53, i32 %gp_offset50
  %32 = add i32 %gp_offset50, 8
  store i32 %32, ptr %gp_offset_p49, align 16
  br label %vaarg.end58

vaarg.in_mem54:                                   ; preds = %if.else47
  %overflow_arg_area_p55 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay48, i32 0, i32 2
  %overflow_arg_area56 = load ptr, ptr %overflow_arg_area_p55, align 8
  %overflow_arg_area.next57 = getelementptr i8, ptr %overflow_arg_area56, i32 8
  store ptr %overflow_arg_area.next57, ptr %overflow_arg_area_p55, align 8
  br label %vaarg.end58

vaarg.end58:                                      ; preds = %vaarg.in_mem54, %vaarg.in_reg52
  %vaarg.addr59 = phi ptr [ %31, %vaarg.in_reg52 ], [ %overflow_arg_area56, %vaarg.in_mem54 ]
  %33 = load ptr, ptr %vaarg.addr59, align 8
  store ptr %33, ptr %valueptr, align 8
  %34 = load ptr, ptr %key.addr, align 8
  %value60 = getelementptr inbounds %struct.RedisModuleKey, ptr %34, i32 0, i32 3
  %35 = load ptr, ptr %value60, align 8
  %tobool61 = icmp ne ptr %35, null
  br i1 %tobool61, label %if.then62, label %if.else73

if.then62:                                        ; preds = %vaarg.end58
  %36 = load ptr, ptr %key.addr, align 8
  %value63 = getelementptr inbounds %struct.RedisModuleKey, ptr %36, i32 0, i32 3
  %37 = load ptr, ptr %value63, align 8
  %38 = load ptr, ptr %field, align 8
  %ptr64 = getelementptr inbounds %struct.redisObject, ptr %38, i32 0, i32 2
  %39 = load ptr, ptr %ptr64, align 8
  %call65 = call ptr @hashTypeGetValueObject(ptr noundef %37, ptr noundef %39)
  %40 = load ptr, ptr %valueptr, align 8
  store ptr %call65, ptr %40, align 8
  %41 = load ptr, ptr %valueptr, align 8
  %42 = load ptr, ptr %41, align 8
  %tobool66 = icmp ne ptr %42, null
  br i1 %tobool66, label %if.then67, label %if.end69

if.then67:                                        ; preds = %if.then62
  %43 = load ptr, ptr %valueptr, align 8
  %44 = load ptr, ptr %43, align 8
  %call68 = call ptr @getDecodedObject(ptr noundef %44)
  store ptr %call68, ptr %decoded, align 8
  %45 = load ptr, ptr %valueptr, align 8
  %46 = load ptr, ptr %45, align 8
  call void @decrRefCount(ptr noundef %46)
  %47 = load ptr, ptr %decoded, align 8
  %48 = load ptr, ptr %valueptr, align 8
  store ptr %47, ptr %48, align 8
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %if.then62
  %49 = load ptr, ptr %valueptr, align 8
  %50 = load ptr, ptr %49, align 8
  %tobool70 = icmp ne ptr %50, null
  br i1 %tobool70, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.end69
  %51 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %51, i32 0, i32 0
  %52 = load ptr, ptr %ctx, align 8
  %53 = load ptr, ptr %valueptr, align 8
  %54 = load ptr, ptr %53, align 8
  call void @autoMemoryAdd(ptr noundef %52, i32 noundef 1, ptr noundef %54)
  br label %if.end72

if.end72:                                         ; preds = %if.then71, %if.end69
  br label %if.end74

if.else73:                                        ; preds = %vaarg.end58
  %55 = load ptr, ptr %valueptr, align 8
  store ptr null, ptr %55, align 8
  br label %if.end74

if.end74:                                         ; preds = %if.else73, %if.end72
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.end46
  %56 = load i32, ptr %flags.addr, align 4
  %and76 = and i32 %56, 4
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %if.then78, label %if.end79

if.then78:                                        ; preds = %if.end75
  %57 = load ptr, ptr %field, align 8
  call void @decrRefCount(ptr noundef %57)
  br label %if.end79

if.end79:                                         ; preds = %if.then78, %if.end75
  br label %while.body

while.end:                                        ; preds = %if.then22, %if.then6
  %arraydecay80 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay80)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %58 = load i32, ptr %retval, align 4
  ret i32 %58
}

declare ptr @hashTypeGetValueObject(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StreamAdd(ptr noundef %key, i32 noundef %flags, ptr noundef %id, ptr noundef %argv, i64 noundef %numfields) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %id.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %numfields.addr = alloca i64, align 8
  %created = alloca i32, align 4
  %s = alloca ptr, align 8
  %added_id = alloca %struct.streamID, align 8
  %use_id = alloca %struct.streamID, align 8
  %use_id_ptr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %id, ptr %id.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i64 %numfields, ptr %numfields.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %numfields.addr, align 8
  %cmp = icmp ne i64 %1, 0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false2

land.lhs.true:                                    ; preds = %lor.lhs.false
  %2 = load ptr, ptr %argv.addr, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false2, label %if.then

lor.lhs.false2:                                   ; preds = %land.lhs.true, %lor.lhs.false
  %3 = load i32, ptr %flags.addr, align 4
  %and = and i32 %3, -2
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %4 = load i32, ptr %flags.addr, align 4
  %and5 = and i32 %4, 1
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.else, label %land.lhs.true7

land.lhs.true7:                                   ; preds = %lor.lhs.false4
  %5 = load ptr, ptr %id.addr, align 8
  %tobool8 = icmp ne ptr %5, null
  br i1 %tobool8, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true7, %lor.lhs.false2, %land.lhs.true, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true7, %lor.lhs.false4
  %6 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %value, align 8
  %tobool9 = icmp ne ptr %7, null
  br i1 %tobool9, label %land.lhs.true10, label %if.else15

land.lhs.true10:                                  ; preds = %if.else
  %8 = load ptr, ptr %key.addr, align 8
  %value11 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %value11, align 8
  %bf.load = load i32, ptr %9, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp12 = icmp ne i32 %bf.clear, 6
  br i1 %cmp12, label %if.then13, label %if.else15

if.then13:                                        ; preds = %land.lhs.true10
  %call14 = call ptr @__errno_location() #15
  store i32 95, ptr %call14, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else15:                                        ; preds = %land.lhs.true10, %if.else
  %10 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 5
  %11 = load i32, ptr %mode, align 8
  %and16 = and i32 %11, 2
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.else20, label %if.then18

if.then18:                                        ; preds = %if.else15
  %call19 = call ptr @__errno_location() #15
  store i32 9, ptr %call19, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else20:                                        ; preds = %if.else15
  %12 = load i32, ptr %flags.addr, align 4
  %and21 = and i32 %12, 1
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.end, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %if.else20
  %13 = load ptr, ptr %id.addr, align 8
  %ms = getelementptr inbounds %struct.RedisModuleStreamID, ptr %13, i32 0, i32 0
  %14 = load i64, ptr %ms, align 8
  %cmp24 = icmp eq i64 %14, 0
  br i1 %cmp24, label %land.lhs.true25, label %if.end

land.lhs.true25:                                  ; preds = %land.lhs.true23
  %15 = load ptr, ptr %id.addr, align 8
  %seq = getelementptr inbounds %struct.RedisModuleStreamID, ptr %15, i32 0, i32 1
  %16 = load i64, ptr %seq, align 8
  %cmp26 = icmp eq i64 %16, 0
  br i1 %cmp26, label %if.then27, label %if.end

if.then27:                                        ; preds = %land.lhs.true25
  %call28 = call ptr @__errno_location() #15
  store i32 33, ptr %call28, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true25, %land.lhs.true23, %if.else20
  br label %if.end29

if.end29:                                         ; preds = %if.end
  br label %if.end30

if.end30:                                         ; preds = %if.end29
  br label %if.end31

if.end31:                                         ; preds = %if.end30
  store i32 0, ptr %created, align 4
  %17 = load ptr, ptr %key.addr, align 8
  %value32 = getelementptr inbounds %struct.RedisModuleKey, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %value32, align 8
  %cmp33 = icmp eq ptr %18, null
  br i1 %cmp33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  %19 = load ptr, ptr %key.addr, align 8
  %call35 = call i32 @moduleCreateEmptyKey(ptr noundef %19, i32 noundef 7)
  store i32 1, ptr %created, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %20 = load ptr, ptr %key.addr, align 8
  %value37 = getelementptr inbounds %struct.RedisModuleKey, ptr %20, i32 0, i32 3
  %21 = load ptr, ptr %value37, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %21, i32 0, i32 2
  %22 = load ptr, ptr %ptr, align 8
  store ptr %22, ptr %s, align 8
  %23 = load ptr, ptr %s, align 8
  %last_id = getelementptr inbounds %struct.stream, ptr %23, i32 0, i32 2
  %ms38 = getelementptr inbounds %struct.streamID, ptr %last_id, i32 0, i32 0
  %24 = load i64, ptr %ms38, align 8
  %cmp39 = icmp eq i64 %24, -1
  br i1 %cmp39, label %land.lhs.true40, label %if.end46

land.lhs.true40:                                  ; preds = %if.end36
  %25 = load ptr, ptr %s, align 8
  %last_id41 = getelementptr inbounds %struct.stream, ptr %25, i32 0, i32 2
  %seq42 = getelementptr inbounds %struct.streamID, ptr %last_id41, i32 0, i32 1
  %26 = load i64, ptr %seq42, align 8
  %cmp43 = icmp eq i64 %26, -1
  br i1 %cmp43, label %if.then44, label %if.end46

if.then44:                                        ; preds = %land.lhs.true40
  %call45 = call ptr @__errno_location() #15
  store i32 27, ptr %call45, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end46:                                         ; preds = %land.lhs.true40, %if.end36
  store ptr null, ptr %use_id_ptr, align 8
  %27 = load i32, ptr %flags.addr, align 4
  %and47 = and i32 %27, 1
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.end54, label %if.then49

if.then49:                                        ; preds = %if.end46
  %28 = load ptr, ptr %id.addr, align 8
  %ms50 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %28, i32 0, i32 0
  %29 = load i64, ptr %ms50, align 8
  %ms51 = getelementptr inbounds %struct.streamID, ptr %use_id, i32 0, i32 0
  store i64 %29, ptr %ms51, align 8
  %30 = load ptr, ptr %id.addr, align 8
  %seq52 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %30, i32 0, i32 1
  %31 = load i64, ptr %seq52, align 8
  %seq53 = getelementptr inbounds %struct.streamID, ptr %use_id, i32 0, i32 1
  store i64 %31, ptr %seq53, align 8
  store ptr %use_id, ptr %use_id_ptr, align 8
  br label %if.end54

if.end54:                                         ; preds = %if.then49, %if.end46
  %32 = load ptr, ptr %s, align 8
  %33 = load ptr, ptr %argv.addr, align 8
  %34 = load i64, ptr %numfields.addr, align 8
  %35 = load ptr, ptr %use_id_ptr, align 8
  %call55 = call i32 @streamAppendItem(ptr noundef %32, ptr noundef %33, i64 noundef %34, ptr noundef %added_id, ptr noundef %35, i32 noundef 1)
  %cmp56 = icmp eq i32 %call55, -1
  br i1 %cmp56, label %if.then57, label %if.end62

if.then57:                                        ; preds = %if.end54
  %36 = load i32, ptr %created, align 4
  %tobool58 = icmp ne i32 %36, 0
  br i1 %tobool58, label %if.then59, label %if.end61

if.then59:                                        ; preds = %if.then57
  %37 = load ptr, ptr %key.addr, align 8
  %call60 = call i32 @moduleDelKeyIfEmpty(ptr noundef %37)
  br label %if.end61

if.end61:                                         ; preds = %if.then59, %if.then57
  store i32 1, ptr %retval, align 4
  br label %return

if.end62:                                         ; preds = %if.end54
  %38 = load i32, ptr %created, align 4
  %tobool63 = icmp ne i32 %38, 0
  br i1 %tobool63, label %if.end65, label %if.then64

if.then64:                                        ; preds = %if.end62
  %39 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %39, i32 0, i32 6
  %signalready = getelementptr inbounds %struct.anon.1, ptr %u, i32 0, i32 2
  store i32 1, ptr %signalready, align 8
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.end62
  %40 = load ptr, ptr %id.addr, align 8
  %cmp66 = icmp ne ptr %40, null
  br i1 %cmp66, label %if.then67, label %if.end72

if.then67:                                        ; preds = %if.end65
  %ms68 = getelementptr inbounds %struct.streamID, ptr %added_id, i32 0, i32 0
  %41 = load i64, ptr %ms68, align 8
  %42 = load ptr, ptr %id.addr, align 8
  %ms69 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %42, i32 0, i32 0
  store i64 %41, ptr %ms69, align 8
  %seq70 = getelementptr inbounds %struct.streamID, ptr %added_id, i32 0, i32 1
  %43 = load i64, ptr %seq70, align 8
  %44 = load ptr, ptr %id.addr, align 8
  %seq71 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %44, i32 0, i32 1
  store i64 %43, ptr %seq71, align 8
  br label %if.end72

if.end72:                                         ; preds = %if.then67, %if.end65
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end72, %if.end61, %if.then44, %if.then27, %if.then18, %if.then13, %if.then
  %45 = load i32, ptr %retval, align 4
  ret i32 %45
}

declare i32 @streamAppendItem(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StreamDelete(ptr noundef %key, ptr noundef %id) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %id.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %streamid = alloca %struct.streamID, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %id, ptr %id.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %id.addr, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %lor.lhs.false3, label %if.then5

lor.lhs.false3:                                   ; preds = %if.else
  %4 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value4, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 6
  br i1 %cmp, label %if.then5, label %if.else7

if.then5:                                         ; preds = %lor.lhs.false3, %if.else
  %call6 = call ptr @__errno_location() #15
  store i32 95, ptr %call6, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else7:                                         ; preds = %lor.lhs.false3
  %6 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %mode, align 8
  %and = and i32 %7, 2
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %lor.lhs.false9, label %if.then11

lor.lhs.false9:                                   ; preds = %if.else7
  %8 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %iter, align 8
  %cmp10 = icmp ne ptr %9, null
  br i1 %cmp10, label %if.then11, label %if.end

if.then11:                                        ; preds = %lor.lhs.false9, %if.else7
  %call12 = call ptr @__errno_location() #15
  store i32 9, ptr %call12, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false9
  br label %if.end13

if.end13:                                         ; preds = %if.end
  br label %if.end14

if.end14:                                         ; preds = %if.end13
  %10 = load ptr, ptr %key.addr, align 8
  %value15 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %value15, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %ptr, align 8
  store ptr %12, ptr %s, align 8
  %ms = getelementptr inbounds %struct.streamID, ptr %streamid, i32 0, i32 0
  %13 = load ptr, ptr %id.addr, align 8
  %ms16 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %13, i32 0, i32 0
  %14 = load i64, ptr %ms16, align 8
  store i64 %14, ptr %ms, align 8
  %seq = getelementptr inbounds %struct.streamID, ptr %streamid, i32 0, i32 1
  %15 = load ptr, ptr %id.addr, align 8
  %seq17 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %15, i32 0, i32 1
  %16 = load i64, ptr %seq17, align 8
  store i64 %16, ptr %seq, align 8
  %17 = load ptr, ptr %s, align 8
  %call18 = call i32 @streamDeleteItem(ptr noundef %17, ptr noundef %streamid)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.end14
  store i32 0, ptr %retval, align 4
  br label %return

if.else21:                                        ; preds = %if.end14
  %call22 = call ptr @__errno_location() #15
  store i32 2, ptr %call22, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else21, %if.then20, %if.then11, %if.then5, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

declare i32 @streamDeleteItem(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StreamIteratorStart(ptr noundef %key, i32 noundef %flags, ptr noundef %start, ptr noundef %end) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %start.addr = alloca ptr, align 8
  %end.addr = alloca ptr, align 8
  %lower = alloca %struct.streamID, align 8
  %upper = alloca %struct.streamID, align 8
  %.compoundliteral = alloca %struct.streamID, align 8
  %.compoundliteral20 = alloca %struct.streamID, align 8
  %s = alloca ptr, align 8
  %rev = alloca i32, align 4
  %si = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %start, ptr %start.addr, align 8
  store ptr %end, ptr %end.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %and = and i32 %1, -4
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %2 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %lor.lhs.false3, label %if.then5

lor.lhs.false3:                                   ; preds = %if.else
  %4 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value4, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 6
  br i1 %cmp, label %if.then5, label %if.else7

if.then5:                                         ; preds = %lor.lhs.false3, %if.else
  %call6 = call ptr @__errno_location() #15
  store i32 95, ptr %call6, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else7:                                         ; preds = %lor.lhs.false3
  %6 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %iter, align 8
  %tobool8 = icmp ne ptr %7, null
  br i1 %tobool8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.else7
  %call10 = call ptr @__errno_location() #15
  store i32 9, ptr %call10, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else7
  br label %if.end11

if.end11:                                         ; preds = %if.end
  br label %if.end12

if.end12:                                         ; preds = %if.end11
  %8 = load ptr, ptr %start.addr, align 8
  %tobool13 = icmp ne ptr %8, null
  br i1 %tobool13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end12
  %ms = getelementptr inbounds %struct.streamID, ptr %.compoundliteral, i32 0, i32 0
  %9 = load ptr, ptr %start.addr, align 8
  %ms15 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %9, i32 0, i32 0
  %10 = load i64, ptr %ms15, align 8
  store i64 %10, ptr %ms, align 8
  %seq = getelementptr inbounds %struct.streamID, ptr %.compoundliteral, i32 0, i32 1
  %11 = load ptr, ptr %start.addr, align 8
  %seq16 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %seq16, align 8
  store i64 %12, ptr %seq, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %lower, ptr align 8 %.compoundliteral, i64 16, i1 false)
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end12
  %13 = load ptr, ptr %end.addr, align 8
  %tobool18 = icmp ne ptr %13, null
  br i1 %tobool18, label %if.then19, label %if.end25

if.then19:                                        ; preds = %if.end17
  %ms21 = getelementptr inbounds %struct.streamID, ptr %.compoundliteral20, i32 0, i32 0
  %14 = load ptr, ptr %end.addr, align 8
  %ms22 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %ms22, align 8
  store i64 %15, ptr %ms21, align 8
  %seq23 = getelementptr inbounds %struct.streamID, ptr %.compoundliteral20, i32 0, i32 1
  %16 = load ptr, ptr %end.addr, align 8
  %seq24 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %16, i32 0, i32 1
  %17 = load i64, ptr %seq24, align 8
  store i64 %17, ptr %seq23, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %upper, ptr align 8 %.compoundliteral20, i64 16, i1 false)
  br label %if.end25

if.end25:                                         ; preds = %if.then19, %if.end17
  %18 = load i32, ptr %flags.addr, align 4
  %and26 = and i32 %18, 1
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then28, label %if.end40

if.then28:                                        ; preds = %if.end25
  %19 = load ptr, ptr %start.addr, align 8
  %tobool29 = icmp ne ptr %19, null
  br i1 %tobool29, label %land.lhs.true, label %lor.lhs.false32

land.lhs.true:                                    ; preds = %if.then28
  %call30 = call i32 @streamIncrID(ptr noundef %lower)
  %cmp31 = icmp ne i32 %call30, 0
  br i1 %cmp31, label %if.then37, label %lor.lhs.false32

lor.lhs.false32:                                  ; preds = %land.lhs.true, %if.then28
  %20 = load ptr, ptr %end.addr, align 8
  %tobool33 = icmp ne ptr %20, null
  br i1 %tobool33, label %land.lhs.true34, label %if.end39

land.lhs.true34:                                  ; preds = %lor.lhs.false32
  %call35 = call i32 @streamDecrID(ptr noundef %upper)
  %cmp36 = icmp ne i32 %call35, 0
  br i1 %cmp36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %land.lhs.true34, %land.lhs.true
  %call38 = call ptr @__errno_location() #15
  store i32 33, ptr %call38, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end39:                                         ; preds = %land.lhs.true34, %lor.lhs.false32
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.end25
  %21 = load ptr, ptr %key.addr, align 8
  %value41 = getelementptr inbounds %struct.RedisModuleKey, ptr %21, i32 0, i32 3
  %22 = load ptr, ptr %value41, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %22, i32 0, i32 2
  %23 = load ptr, ptr %ptr, align 8
  store ptr %23, ptr %s, align 8
  %24 = load i32, ptr %flags.addr, align 4
  %and42 = and i32 %24, 2
  store i32 %and42, ptr %rev, align 4
  %call43 = call noalias ptr @zmalloc(i64 noundef 648) #11
  store ptr %call43, ptr %si, align 8
  %25 = load ptr, ptr %si, align 8
  %26 = load ptr, ptr %s, align 8
  %27 = load ptr, ptr %start.addr, align 8
  %tobool44 = icmp ne ptr %27, null
  br i1 %tobool44, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end40
  br label %cond.end

cond.false:                                       ; preds = %if.end40
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %lower, %cond.true ], [ null, %cond.false ]
  %28 = load ptr, ptr %end.addr, align 8
  %tobool45 = icmp ne ptr %28, null
  br i1 %tobool45, label %cond.true46, label %cond.false47

cond.true46:                                      ; preds = %cond.end
  br label %cond.end48

cond.false47:                                     ; preds = %cond.end
  br label %cond.end48

cond.end48:                                       ; preds = %cond.false47, %cond.true46
  %cond49 = phi ptr [ %upper, %cond.true46 ], [ null, %cond.false47 ]
  %29 = load i32, ptr %rev, align 4
  call void @streamIteratorStart(ptr noundef %25, ptr noundef %26, ptr noundef %cond, ptr noundef %cond49, i32 noundef %29)
  %30 = load ptr, ptr %si, align 8
  %31 = load ptr, ptr %key.addr, align 8
  %iter50 = getelementptr inbounds %struct.RedisModuleKey, ptr %31, i32 0, i32 4
  store ptr %30, ptr %iter50, align 8
  %32 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %32, i32 0, i32 6
  %currentid = getelementptr inbounds %struct.anon.1, ptr %u, i32 0, i32 0
  %ms51 = getelementptr inbounds %struct.streamID, ptr %currentid, i32 0, i32 0
  store i64 0, ptr %ms51, align 8
  %33 = load ptr, ptr %key.addr, align 8
  %u52 = getelementptr inbounds %struct.RedisModuleKey, ptr %33, i32 0, i32 6
  %currentid53 = getelementptr inbounds %struct.anon.1, ptr %u52, i32 0, i32 0
  %seq54 = getelementptr inbounds %struct.streamID, ptr %currentid53, i32 0, i32 1
  store i64 0, ptr %seq54, align 8
  %34 = load ptr, ptr %key.addr, align 8
  %u55 = getelementptr inbounds %struct.RedisModuleKey, ptr %34, i32 0, i32 6
  %numfieldsleft = getelementptr inbounds %struct.anon.1, ptr %u55, i32 0, i32 1
  store i64 0, ptr %numfieldsleft, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end48, %if.then37, %if.then9, %if.then5, %if.then
  %35 = load i32, ptr %retval, align 4
  ret i32 %35
}

declare i32 @streamIncrID(ptr noundef) #1

declare i32 @streamDecrID(ptr noundef) #1

declare void @streamIteratorStart(ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StreamIteratorStop(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.else
  %3 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 6
  br i1 %cmp, label %if.then3, label %if.else5

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = call ptr @__errno_location() #15
  store i32 95, ptr %call4, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %5 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %iter, align 8
  %tobool6 = icmp ne ptr %6, null
  br i1 %tobool6, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.else5
  %call8 = call ptr @__errno_location() #15
  store i32 9, ptr %call8, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else5
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %if.end10

if.end10:                                         ; preds = %if.end9
  %7 = load ptr, ptr %key.addr, align 8
  %iter11 = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %iter11, align 8
  call void @streamIteratorStop(ptr noundef %8)
  %9 = load ptr, ptr %key.addr, align 8
  %iter12 = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 4
  %10 = load ptr, ptr %iter12, align 8
  call void @zfree(ptr noundef %10)
  %11 = load ptr, ptr %key.addr, align 8
  %iter13 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 4
  store ptr null, ptr %iter13, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then7, %if.then3, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

declare void @streamIteratorStop(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StreamIteratorNextID(ptr noundef %key, ptr noundef %id, ptr noundef %numfields) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %id.addr = alloca ptr, align 8
  %numfields.addr = alloca ptr, align 8
  %si = alloca ptr, align 8
  %num_ptr = alloca ptr, align 8
  %streamid_ptr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %id, ptr %id.addr, align 8
  store ptr %numfields, ptr %numfields.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.else
  %3 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 6
  br i1 %cmp, label %if.then3, label %if.else5

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = call ptr @__errno_location() #15
  store i32 95, ptr %call4, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %5 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %iter, align 8
  %tobool6 = icmp ne ptr %6, null
  br i1 %tobool6, label %if.end, label %if.then7

if.then7:                                         ; preds = %if.else5
  %call8 = call ptr @__errno_location() #15
  store i32 9, ptr %call8, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else5
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %if.end10

if.end10:                                         ; preds = %if.end9
  %7 = load ptr, ptr %key.addr, align 8
  %iter11 = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %iter11, align 8
  store ptr %8, ptr %si, align 8
  %9 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 6
  %numfieldsleft = getelementptr inbounds %struct.anon.1, ptr %u, i32 0, i32 1
  store ptr %numfieldsleft, ptr %num_ptr, align 8
  %10 = load ptr, ptr %key.addr, align 8
  %u12 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 6
  %currentid = getelementptr inbounds %struct.anon.1, ptr %u12, i32 0, i32 0
  store ptr %currentid, ptr %streamid_ptr, align 8
  %11 = load ptr, ptr %si, align 8
  %12 = load ptr, ptr %streamid_ptr, align 8
  %13 = load ptr, ptr %num_ptr, align 8
  %call13 = call i32 @streamIteratorGetID(ptr noundef %11, ptr noundef %12, ptr noundef %13)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then15, label %if.else24

if.then15:                                        ; preds = %if.end10
  %14 = load ptr, ptr %id.addr, align 8
  %tobool16 = icmp ne ptr %14, null
  br i1 %tobool16, label %if.then17, label %if.end20

if.then17:                                        ; preds = %if.then15
  %15 = load ptr, ptr %streamid_ptr, align 8
  %ms = getelementptr inbounds %struct.streamID, ptr %15, i32 0, i32 0
  %16 = load i64, ptr %ms, align 8
  %17 = load ptr, ptr %id.addr, align 8
  %ms18 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %17, i32 0, i32 0
  store i64 %16, ptr %ms18, align 8
  %18 = load ptr, ptr %streamid_ptr, align 8
  %seq = getelementptr inbounds %struct.streamID, ptr %18, i32 0, i32 1
  %19 = load i64, ptr %seq, align 8
  %20 = load ptr, ptr %id.addr, align 8
  %seq19 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %20, i32 0, i32 1
  store i64 %19, ptr %seq19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %if.then15
  %21 = load ptr, ptr %numfields.addr, align 8
  %tobool21 = icmp ne ptr %21, null
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end20
  %22 = load ptr, ptr %num_ptr, align 8
  %23 = load i64, ptr %22, align 8
  %24 = load ptr, ptr %numfields.addr, align 8
  store i64 %23, ptr %24, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.end20
  store i32 0, ptr %retval, align 4
  br label %return

if.else24:                                        ; preds = %if.end10
  %25 = load ptr, ptr %key.addr, align 8
  %u25 = getelementptr inbounds %struct.RedisModuleKey, ptr %25, i32 0, i32 6
  %currentid26 = getelementptr inbounds %struct.anon.1, ptr %u25, i32 0, i32 0
  %ms27 = getelementptr inbounds %struct.streamID, ptr %currentid26, i32 0, i32 0
  store i64 0, ptr %ms27, align 8
  %26 = load ptr, ptr %key.addr, align 8
  %u28 = getelementptr inbounds %struct.RedisModuleKey, ptr %26, i32 0, i32 6
  %currentid29 = getelementptr inbounds %struct.anon.1, ptr %u28, i32 0, i32 0
  %seq30 = getelementptr inbounds %struct.streamID, ptr %currentid29, i32 0, i32 1
  store i64 0, ptr %seq30, align 8
  %27 = load ptr, ptr %key.addr, align 8
  %u31 = getelementptr inbounds %struct.RedisModuleKey, ptr %27, i32 0, i32 6
  %numfieldsleft32 = getelementptr inbounds %struct.anon.1, ptr %u31, i32 0, i32 1
  store i64 0, ptr %numfieldsleft32, align 8
  %call33 = call ptr @__errno_location() #15
  store i32 2, ptr %call33, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else24, %if.end23, %if.then7, %if.then3, %if.then
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

declare i32 @streamIteratorGetID(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StreamIteratorNextField(ptr noundef %key, ptr noundef %field_ptr, ptr noundef %value_ptr) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %field_ptr.addr = alloca ptr, align 8
  %value_ptr.addr = alloca ptr, align 8
  %si = alloca ptr, align 8
  %field = alloca ptr, align 8
  %value17 = alloca ptr, align 8
  %field_len = alloca i64, align 8
  %value_len = alloca i64, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %field_ptr, ptr %field_ptr.addr, align 8
  store ptr %value_ptr, ptr %value_ptr.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.else
  %3 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 6
  br i1 %cmp, label %if.then3, label %if.else5

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = call ptr @__errno_location() #15
  store i32 95, ptr %call4, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %5 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %iter, align 8
  %tobool6 = icmp ne ptr %6, null
  br i1 %tobool6, label %if.else9, label %if.then7

if.then7:                                         ; preds = %if.else5
  %call8 = call ptr @__errno_location() #15
  store i32 9, ptr %call8, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else9:                                         ; preds = %if.else5
  %7 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 6
  %numfieldsleft = getelementptr inbounds %struct.anon.1, ptr %u, i32 0, i32 1
  %8 = load i64, ptr %numfieldsleft, align 8
  %cmp10 = icmp sle i64 %8, 0
  br i1 %cmp10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.else9
  %call12 = call ptr @__errno_location() #15
  store i32 2, ptr %call12, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else9
  br label %if.end13

if.end13:                                         ; preds = %if.end
  br label %if.end14

if.end14:                                         ; preds = %if.end13
  br label %if.end15

if.end15:                                         ; preds = %if.end14
  %9 = load ptr, ptr %key.addr, align 8
  %iter16 = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 4
  %10 = load ptr, ptr %iter16, align 8
  store ptr %10, ptr %si, align 8
  %11 = load ptr, ptr %si, align 8
  call void @streamIteratorGetField(ptr noundef %11, ptr noundef %field, ptr noundef %value17, ptr noundef %field_len, ptr noundef %value_len)
  %12 = load ptr, ptr %field_ptr.addr, align 8
  %tobool18 = icmp ne ptr %12, null
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end15
  %13 = load ptr, ptr %field, align 8
  %14 = load i64, ptr %field_len, align 8
  %call20 = call ptr @createRawStringObject(ptr noundef %13, i64 noundef %14)
  %15 = load ptr, ptr %field_ptr.addr, align 8
  store ptr %call20, ptr %15, align 8
  %16 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %ctx, align 8
  %18 = load ptr, ptr %field_ptr.addr, align 8
  %19 = load ptr, ptr %18, align 8
  call void @autoMemoryAdd(ptr noundef %17, i32 noundef 1, ptr noundef %19)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end15
  %20 = load ptr, ptr %value_ptr.addr, align 8
  %tobool22 = icmp ne ptr %20, null
  br i1 %tobool22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.end21
  %21 = load ptr, ptr %value17, align 8
  %22 = load i64, ptr %value_len, align 8
  %call24 = call ptr @createRawStringObject(ptr noundef %21, i64 noundef %22)
  %23 = load ptr, ptr %value_ptr.addr, align 8
  store ptr %call24, ptr %23, align 8
  %24 = load ptr, ptr %key.addr, align 8
  %ctx25 = getelementptr inbounds %struct.RedisModuleKey, ptr %24, i32 0, i32 0
  %25 = load ptr, ptr %ctx25, align 8
  %26 = load ptr, ptr %value_ptr.addr, align 8
  %27 = load ptr, ptr %26, align 8
  call void @autoMemoryAdd(ptr noundef %25, i32 noundef 1, ptr noundef %27)
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.end21
  %28 = load ptr, ptr %key.addr, align 8
  %u27 = getelementptr inbounds %struct.RedisModuleKey, ptr %28, i32 0, i32 6
  %numfieldsleft28 = getelementptr inbounds %struct.anon.1, ptr %u27, i32 0, i32 1
  %29 = load i64, ptr %numfieldsleft28, align 8
  %dec = add nsw i64 %29, -1
  store i64 %dec, ptr %numfieldsleft28, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end26, %if.then11, %if.then7, %if.then3, %if.then
  %30 = load i32, ptr %retval, align 4
  ret i32 %30
}

declare void @streamIteratorGetField(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StreamIteratorDelete(ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %si = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.else
  %3 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value2, align 8
  %bf.load = load i32, ptr %4, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 6
  br i1 %cmp, label %if.then3, label %if.else5

if.then3:                                         ; preds = %lor.lhs.false, %if.else
  %call4 = call ptr @__errno_location() #15
  store i32 95, ptr %call4, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else5:                                         ; preds = %lor.lhs.false
  %5 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 5
  %6 = load i32, ptr %mode, align 8
  %and = and i32 %6, 2
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %lor.lhs.false7, label %if.then9

lor.lhs.false7:                                   ; preds = %if.else5
  %7 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %iter, align 8
  %tobool8 = icmp ne ptr %8, null
  br i1 %tobool8, label %if.else11, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false7, %if.else5
  %call10 = call ptr @__errno_location() #15
  store i32 9, ptr %call10, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.else11:                                        ; preds = %lor.lhs.false7
  %9 = load ptr, ptr %key.addr, align 8
  %u = getelementptr inbounds %struct.RedisModuleKey, ptr %9, i32 0, i32 6
  %currentid = getelementptr inbounds %struct.anon.1, ptr %u, i32 0, i32 0
  %ms = getelementptr inbounds %struct.streamID, ptr %currentid, i32 0, i32 0
  %10 = load i64, ptr %ms, align 8
  %cmp12 = icmp eq i64 %10, 0
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else11
  %11 = load ptr, ptr %key.addr, align 8
  %u13 = getelementptr inbounds %struct.RedisModuleKey, ptr %11, i32 0, i32 6
  %currentid14 = getelementptr inbounds %struct.anon.1, ptr %u13, i32 0, i32 0
  %seq = getelementptr inbounds %struct.streamID, ptr %currentid14, i32 0, i32 1
  %12 = load i64, ptr %seq, align 8
  %cmp15 = icmp eq i64 %12, 0
  br i1 %cmp15, label %if.then16, label %if.end

if.then16:                                        ; preds = %land.lhs.true
  %call17 = call ptr @__errno_location() #15
  store i32 2, ptr %call17, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.else11
  br label %if.end18

if.end18:                                         ; preds = %if.end
  br label %if.end19

if.end19:                                         ; preds = %if.end18
  br label %if.end20

if.end20:                                         ; preds = %if.end19
  %13 = load ptr, ptr %key.addr, align 8
  %iter21 = getelementptr inbounds %struct.RedisModuleKey, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %iter21, align 8
  store ptr %14, ptr %si, align 8
  %15 = load ptr, ptr %si, align 8
  %16 = load ptr, ptr %key.addr, align 8
  %u22 = getelementptr inbounds %struct.RedisModuleKey, ptr %16, i32 0, i32 6
  %currentid23 = getelementptr inbounds %struct.anon.1, ptr %u22, i32 0, i32 0
  call void @streamIteratorRemoveEntry(ptr noundef %15, ptr noundef %currentid23)
  %17 = load ptr, ptr %key.addr, align 8
  %u24 = getelementptr inbounds %struct.RedisModuleKey, ptr %17, i32 0, i32 6
  %currentid25 = getelementptr inbounds %struct.anon.1, ptr %u24, i32 0, i32 0
  %ms26 = getelementptr inbounds %struct.streamID, ptr %currentid25, i32 0, i32 0
  store i64 0, ptr %ms26, align 8
  %18 = load ptr, ptr %key.addr, align 8
  %u27 = getelementptr inbounds %struct.RedisModuleKey, ptr %18, i32 0, i32 6
  %currentid28 = getelementptr inbounds %struct.anon.1, ptr %u27, i32 0, i32 0
  %seq29 = getelementptr inbounds %struct.streamID, ptr %currentid28, i32 0, i32 1
  store i64 0, ptr %seq29, align 8
  %19 = load ptr, ptr %key.addr, align 8
  %u30 = getelementptr inbounds %struct.RedisModuleKey, ptr %19, i32 0, i32 6
  %numfieldsleft = getelementptr inbounds %struct.anon.1, ptr %u30, i32 0, i32 1
  store i64 0, ptr %numfieldsleft, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end20, %if.then16, %if.then9, %if.then3, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

declare void @streamIteratorRemoveEntry(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_StreamTrimByLength(ptr noundef %key, i32 noundef %flags, i64 noundef %length) #0 {
entry:
  %retval = alloca i64, align 8
  %key.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %length.addr = alloca i64, align 8
  %approx = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i64 %length, ptr %length.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %and = and i32 %1, -2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load i64, ptr %length.addr, align 8
  %cmp = icmp slt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i64 -1, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %lor.lhs.false2
  %3 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value, align 8
  %tobool3 = icmp ne ptr %4, null
  br i1 %tobool3, label %lor.lhs.false4, label %if.then7

lor.lhs.false4:                                   ; preds = %if.else
  %5 = load ptr, ptr %key.addr, align 8
  %value5 = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %value5, align 8
  %bf.load = load i32, ptr %6, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp6 = icmp ne i32 %bf.clear, 6
  br i1 %cmp6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %lor.lhs.false4, %if.else
  %call8 = call ptr @__errno_location() #15
  store i32 95, ptr %call8, align 4
  store i64 -1, ptr %retval, align 8
  br label %return

if.else9:                                         ; preds = %lor.lhs.false4
  %7 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %mode, align 8
  %and10 = and i32 %8, 2
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.end, label %if.then12

if.then12:                                        ; preds = %if.else9
  %call13 = call ptr @__errno_location() #15
  store i32 9, ptr %call13, align 4
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else9
  br label %if.end14

if.end14:                                         ; preds = %if.end
  br label %if.end15

if.end15:                                         ; preds = %if.end14
  %9 = load i32, ptr %flags.addr, align 4
  %and16 = and i32 %9, 1
  %tobool17 = icmp ne i32 %and16, 0
  %cond = select i1 %tobool17, i32 1, i32 0
  store i32 %cond, ptr %approx, align 4
  %10 = load ptr, ptr %key.addr, align 8
  %value18 = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %value18, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %ptr, align 8
  %13 = load i64, ptr %length.addr, align 8
  %14 = load i32, ptr %approx, align 4
  %call19 = call i64 @streamTrimByLength(ptr noundef %12, i64 noundef %13, i32 noundef %14)
  store i64 %call19, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then12, %if.then7, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

declare i64 @streamTrimByLength(ptr noundef, i64 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_StreamTrimByID(ptr noundef %key, i32 noundef %flags, ptr noundef %id) #0 {
entry:
  %retval = alloca i64, align 8
  %key.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %id.addr = alloca ptr, align 8
  %approx = alloca i32, align 4
  %minid = alloca %struct.streamID, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %id, ptr %id.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %and = and i32 %1, -2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = load ptr, ptr %id.addr, align 8
  %tobool3 = icmp ne ptr %2, null
  br i1 %tobool3, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i64 -1, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %lor.lhs.false2
  %3 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value, align 8
  %tobool4 = icmp ne ptr %4, null
  br i1 %tobool4, label %lor.lhs.false5, label %if.then7

lor.lhs.false5:                                   ; preds = %if.else
  %5 = load ptr, ptr %key.addr, align 8
  %value6 = getelementptr inbounds %struct.RedisModuleKey, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %value6, align 8
  %bf.load = load i32, ptr %6, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 6
  br i1 %cmp, label %if.then7, label %if.else9

if.then7:                                         ; preds = %lor.lhs.false5, %if.else
  %call8 = call ptr @__errno_location() #15
  store i32 95, ptr %call8, align 4
  store i64 -1, ptr %retval, align 8
  br label %return

if.else9:                                         ; preds = %lor.lhs.false5
  %7 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %mode, align 8
  %and10 = and i32 %8, 2
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.end, label %if.then12

if.then12:                                        ; preds = %if.else9
  %call13 = call ptr @__errno_location() #15
  store i32 9, ptr %call13, align 4
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.else9
  br label %if.end14

if.end14:                                         ; preds = %if.end
  br label %if.end15

if.end15:                                         ; preds = %if.end14
  %9 = load i32, ptr %flags.addr, align 4
  %and16 = and i32 %9, 1
  %tobool17 = icmp ne i32 %and16, 0
  %cond = select i1 %tobool17, i32 1, i32 0
  store i32 %cond, ptr %approx, align 4
  %ms = getelementptr inbounds %struct.streamID, ptr %minid, i32 0, i32 0
  %10 = load ptr, ptr %id.addr, align 8
  %ms18 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %10, i32 0, i32 0
  %11 = load i64, ptr %ms18, align 8
  store i64 %11, ptr %ms, align 8
  %seq = getelementptr inbounds %struct.streamID, ptr %minid, i32 0, i32 1
  %12 = load ptr, ptr %id.addr, align 8
  %seq19 = getelementptr inbounds %struct.RedisModuleStreamID, ptr %12, i32 0, i32 1
  %13 = load i64, ptr %seq19, align 8
  store i64 %13, ptr %seq, align 8
  %14 = load ptr, ptr %key.addr, align 8
  %value20 = getelementptr inbounds %struct.RedisModuleKey, ptr %14, i32 0, i32 3
  %15 = load ptr, ptr %value20, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %ptr, align 8
  %17 = load i32, ptr %approx, align 4
  %18 = getelementptr inbounds { i64, i64 }, ptr %minid, i32 0, i32 0
  %19 = load i64, ptr %18, align 8
  %20 = getelementptr inbounds { i64, i64 }, ptr %minid, i32 0, i32 1
  %21 = load i64, ptr %20, align 8
  %call21 = call i64 @streamTrimByID(ptr noundef %16, i64 %19, i64 %21, i32 noundef %17)
  store i64 %call21, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then12, %if.then7, %if.then
  %22 = load i64, ptr %retval, align 8
  ret i64 %22
}

declare i64 @streamTrimByID(ptr noundef, i64, i64, i32 noundef) #1

declare i32 @callReplyType(ptr noundef) #1

declare ptr @callReplyGetPrivateData(ptr noundef) #1

declare void @freeCallReply(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyType(ptr noundef %reply) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call i32 @callReplyType(ptr noundef %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_CallReplyLength(ptr noundef %reply) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call i64 @callReplyGetLen(ptr noundef %0)
  ret i64 %call
}

declare i64 @callReplyGetLen(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyArrayElement(ptr noundef %reply, i64 noundef %idx) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %idx.addr = alloca i64, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store i64 %idx, ptr %idx.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %1 = load i64, ptr %idx.addr, align 8
  %call = call ptr @callReplyGetArrayElement(ptr noundef %0, i64 noundef %1)
  ret ptr %call
}

declare ptr @callReplyGetArrayElement(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_CallReplyInteger(ptr noundef %reply) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call i64 @callReplyGetLongLong(ptr noundef %0)
  ret i64 %call
}

declare i64 @callReplyGetLongLong(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local double @RM_CallReplyDouble(ptr noundef %reply) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call double @callReplyGetDouble(ptr noundef %0)
  ret double %call
}

declare double @callReplyGetDouble(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyBigNumber(ptr noundef %reply, ptr noundef %len) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %1 = load ptr, ptr %len.addr, align 8
  %call = call ptr @callReplyGetBigNumber(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

declare ptr @callReplyGetBigNumber(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyVerbatim(ptr noundef %reply, ptr noundef %len, ptr noundef %format) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %format.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  store ptr %format, ptr %format.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %1 = load ptr, ptr %len.addr, align 8
  %2 = load ptr, ptr %format.addr, align 8
  %call = call ptr @callReplyGetVerbatim(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

declare ptr @callReplyGetVerbatim(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyBool(ptr noundef %reply) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call i32 @callReplyGetBool(ptr noundef %0)
  ret i32 %call
}

declare i32 @callReplyGetBool(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplySetElement(ptr noundef %reply, i64 noundef %idx) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %idx.addr = alloca i64, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store i64 %idx, ptr %idx.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %1 = load i64, ptr %idx.addr, align 8
  %call = call ptr @callReplyGetSetElement(ptr noundef %0, i64 noundef %1)
  ret ptr %call
}

declare ptr @callReplyGetSetElement(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyMapElement(ptr noundef %reply, i64 noundef %idx, ptr noundef %key, ptr noundef %val) #0 {
entry:
  %retval = alloca i32, align 4
  %reply.addr = alloca ptr, align 8
  %idx.addr = alloca i64, align 8
  %key.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store i64 %idx, ptr %idx.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %1 = load i64, ptr %idx.addr, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %3 = load ptr, ptr %val.addr, align 8
  %call = call i32 @callReplyGetMapElement(ptr noundef %0, i64 noundef %1, ptr noundef %2, ptr noundef %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare i32 @callReplyGetMapElement(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyAttribute(ptr noundef %reply) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call ptr @callReplyGetAttribute(ptr noundef %0)
  ret ptr %call
}

declare ptr @callReplyGetAttribute(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyAttributeElement(ptr noundef %reply, i64 noundef %idx, ptr noundef %key, ptr noundef %val) #0 {
entry:
  %retval = alloca i32, align 4
  %reply.addr = alloca ptr, align 8
  %idx.addr = alloca i64, align 8
  %key.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store i64 %idx, ptr %idx.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %1 = load i64, ptr %idx.addr, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %3 = load ptr, ptr %val.addr, align 8
  %call = call i32 @callReplyGetAttributeElement(ptr noundef %0, i64 noundef %1, ptr noundef %2, ptr noundef %3)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare i32 @callReplyGetAttributeElement(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_CallReplyPromiseSetUnblockHandler(ptr noundef %reply, ptr noundef %on_unblock, ptr noundef %private_data) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %on_unblock.addr = alloca ptr, align 8
  %private_data.addr = alloca ptr, align 8
  %promise = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store ptr %on_unblock, ptr %on_unblock.addr, align 8
  store ptr %private_data, ptr %private_data.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call ptr @callReplyGetPrivateData(ptr noundef %0)
  store ptr %call, ptr %promise, align 8
  %1 = load ptr, ptr %on_unblock.addr, align 8
  %2 = load ptr, ptr %promise, align 8
  %on_unblocked = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %2, i32 0, i32 3
  store ptr %1, ptr %on_unblocked, align 8
  %3 = load ptr, ptr %private_data.addr, align 8
  %4 = load ptr, ptr %promise, align 8
  %private_data1 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %4, i32 0, i32 1
  store ptr %3, ptr %private_data1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CallReplyPromiseAbort(ptr noundef %reply, ptr noundef %private_data) #0 {
entry:
  %retval = alloca i32, align 4
  %reply.addr = alloca ptr, align 8
  %private_data.addr = alloca ptr, align 8
  %promise = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store ptr %private_data, ptr %private_data.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call ptr @callReplyGetPrivateData(ptr noundef %0)
  store ptr %call, ptr %promise, align 8
  %1 = load ptr, ptr %promise, align 8
  %c = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %promise, align 8
  %c1 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %c1, align 8
  %flags = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %flags, align 8
  %and = and i64 %5, 16
  %tobool2 = icmp ne i64 %and, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %private_data.addr, align 8
  %tobool5 = icmp ne ptr %6, null
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %7 = load ptr, ptr %promise, align 8
  %private_data7 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %private_data7, align 8
  %9 = load ptr, ptr %private_data.addr, align 8
  store ptr %8, ptr %9, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %10 = load ptr, ptr %promise, align 8
  %private_data9 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %10, i32 0, i32 1
  store ptr null, ptr %private_data9, align 8
  %11 = load ptr, ptr %promise, align 8
  %on_unblocked = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %11, i32 0, i32 3
  store ptr null, ptr %on_unblocked, align 8
  %12 = load ptr, ptr %promise, align 8
  %c10 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %c10, align 8
  call void @unblockClient(ptr noundef %13, i32 noundef 0)
  %14 = load ptr, ptr %promise, align 8
  %c11 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %14, i32 0, i32 4
  %15 = load ptr, ptr %c11, align 8
  call void @moduleReleaseTempClient(ptr noundef %15)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then3, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

declare void @unblockClient(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyStringPtr(ptr noundef %reply, ptr noundef %len) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %private_len = alloca i64, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %len.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr %private_len, ptr %len.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %reply.addr, align 8
  %2 = load ptr, ptr %len.addr, align 8
  %call = call ptr @callReplyGetString(ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

declare ptr @callReplyGetString(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateStringFromCallReply(ptr noundef %reply) #0 {
entry:
  %retval = alloca ptr, align 8
  %reply.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %len = alloca i64, align 8
  %str = alloca ptr, align 8
  %buf = alloca [64 x i8], align 16
  %len5 = alloca i32, align 4
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %call = call ptr @callReplyGetPrivateData(ptr noundef %0)
  store ptr %call, ptr %ctx, align 8
  %1 = load ptr, ptr %reply.addr, align 8
  %call1 = call i32 @callReplyType(ptr noundef %1)
  switch i32 %call1, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
    i32 2, label %sw.bb4
  ]

sw.bb:                                            ; preds = %entry, %entry
  %2 = load ptr, ptr %reply.addr, align 8
  %call2 = call ptr @callReplyGetString(ptr noundef %2, ptr noundef %len)
  store ptr %call2, ptr %str, align 8
  %3 = load ptr, ptr %ctx, align 8
  %4 = load ptr, ptr %str, align 8
  %5 = load i64, ptr %len, align 8
  %call3 = call ptr @RM_CreateString(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  store ptr %call3, ptr %retval, align 8
  br label %return

sw.bb4:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %6 = load ptr, ptr %reply.addr, align 8
  %call6 = call i64 @callReplyGetLongLong(ptr noundef %6)
  %call7 = call i32 @ll2string(ptr noundef %arraydecay, i64 noundef 64, i64 noundef %call6)
  store i32 %call7, ptr %len5, align 4
  %7 = load ptr, ptr %ctx, align 8
  %arraydecay8 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %8 = load i32, ptr %len5, align 4
  %conv = sext i32 %8 to i64
  %call9 = call ptr @RM_CreateString(ptr noundef %7, ptr noundef %arraydecay8, i64 noundef %conv)
  store ptr %call9, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb4, %sw.bb
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SetContextUser(ptr noundef %ctx, ptr noundef %user) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %user.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %user, ptr %user.addr, align 8
  %0 = load ptr, ptr %user.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %user1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 15
  store ptr %0, ptr %user1, align 8
  ret void
}

declare ptr @createStringObjectFromLongLongWithSds(i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_Call(ptr noundef %ctx, ptr noundef %cmdname, ptr noundef %fmt, ...) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cmdname.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %argv = alloca ptr, align 8
  %argc = alloca i32, align 4
  %flags = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %reply = alloca ptr, align 8
  %replicate = alloca i32, align 4
  %error_as_call_replies = alloca i32, align 4
  %cmd_flags = alloca i64, align 8
  %user = alloca ptr, align 8
  %msg = alloca ptr, align 8
  %err = alloca ptr, align 8
  %msg90 = alloca ptr, align 8
  %oom_state = alloca i32, align 4
  %msg118 = alloca ptr, align 8
  %msg137 = alloca ptr, align 8
  %msg158 = alloca ptr, align 8
  %deny_write_type = alloca i32, align 4
  %obey_client = alloca i32, align 4
  %msg176 = alloca ptr, align 8
  %msg190 = alloca ptr, align 8
  %msg211 = alloca ptr, align 8
  %acl_errpos = alloca i32, align 4
  %acl_retval = alloca i32, align 4
  %object = alloca ptr, align 8
  %acl_msg = alloca ptr, align 8
  %msg251 = alloca ptr, align 8
  %error_code = alloca i32, align 4
  %msg280 = alloca ptr, align 8
  %prev_replication_allowed = alloca i32, align 4
  %call_flags = alloca i32, align 4
  %promise = alloca ptr, align 8
  %.compoundliteral = alloca %struct.RedisModuleAsyncRMCallPromise, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cmdname, ptr %cmdname.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr null, ptr %c, align 8
  store ptr null, ptr %argv, align 8
  store i32 0, ptr %argc, align 4
  store i32 0, ptr %flags, align 4
  store ptr null, ptr %reply, align 8
  store i32 0, ptr %replicate, align 4
  store i32 0, ptr %error_as_call_replies, align 4
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %cmdname.addr, align 8
  %1 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call = call ptr @moduleCreateArgvFromUserFormat(ptr noundef %0, ptr noundef %1, ptr noundef %argc, ptr noundef %flags, ptr noundef %arraydecay1)
  store ptr %call, ptr %argv, align 8
  %2 = load i32, ptr %flags, align 4
  %and = and i32 %2, 1
  store i32 %and, ptr %replicate, align 4
  %3 = load i32, ptr %flags, align 4
  %and2 = and i32 %3, 256
  store i32 %and2, ptr %error_as_call_replies, align 4
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay3)
  %call4 = call ptr @moduleAllocTempClient()
  store ptr %call4, ptr %c, align 8
  %4 = load i32, ptr %flags, align 4
  %and5 = and i32 %4, 2048
  %tobool = icmp ne i32 %and5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %c, align 8
  %flags6 = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %flags6, align 8
  %or = or i64 %6, 2199023255552
  store i64 %or, ptr %flags6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %db, align 8
  %10 = load ptr, ptr %c, align 8
  %db7 = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 4
  store ptr %9, ptr %db7, align 8
  %11 = load ptr, ptr %argv, align 8
  %12 = load ptr, ptr %c, align 8
  %argv8 = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 12
  store ptr %11, ptr %argv8, align 8
  %13 = load i32, ptr %argc, align 4
  %14 = load ptr, ptr %c, align 8
  %argv_len = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 13
  store i32 %13, ptr %argv_len, align 8
  %15 = load ptr, ptr %c, align 8
  %argc9 = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 11
  store i32 %13, ptr %argc9, align 8
  %16 = load ptr, ptr %c, align 8
  %resp = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 3
  store i32 2, ptr %resp, align 8
  %17 = load i32, ptr %flags, align 4
  %and10 = and i32 %17, 8
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %18 = load ptr, ptr %c, align 8
  %resp13 = getelementptr inbounds %struct.client, ptr %18, i32 0, i32 3
  store i32 3, ptr %resp13, align 8
  br label %if.end21

if.else:                                          ; preds = %if.end
  %19 = load i32, ptr %flags, align 4
  %and14 = and i32 %19, 16
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %if.else
  %20 = load ptr, ptr %ctx.addr, align 8
  %client17 = getelementptr inbounds %struct.RedisModuleCtx, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %client17, align 8
  %resp18 = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 3
  %22 = load i32, ptr %resp18, align 8
  %23 = load ptr, ptr %c, align 8
  %resp19 = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 3
  store i32 %22, ptr %resp19, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %if.else
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then12
  %24 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %24, i32 0, i32 1
  %25 = load ptr, ptr %module, align 8
  %tobool22 = icmp ne ptr %25, null
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end21
  %26 = load ptr, ptr %ctx.addr, align 8
  %module24 = getelementptr inbounds %struct.RedisModuleCtx, ptr %26, i32 0, i32 1
  %27 = load ptr, ptr %module24, align 8
  %in_call = getelementptr inbounds %struct.RedisModule, ptr %27, i32 0, i32 10
  %28 = load i32, ptr %in_call, align 4
  %inc = add nsw i32 %28, 1
  store i32 %inc, ptr %in_call, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end21
  store ptr null, ptr %user, align 8
  %29 = load i32, ptr %flags, align 4
  %and26 = and i32 %29, 32
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then28, label %if.end45

if.then28:                                        ; preds = %if.end25
  %30 = load ptr, ptr %ctx.addr, align 8
  %user29 = getelementptr inbounds %struct.RedisModuleCtx, ptr %30, i32 0, i32 15
  %31 = load ptr, ptr %user29, align 8
  %tobool30 = icmp ne ptr %31, null
  br i1 %tobool30, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then28
  %32 = load ptr, ptr %ctx.addr, align 8
  %user31 = getelementptr inbounds %struct.RedisModuleCtx, ptr %32, i32 0, i32 15
  %33 = load ptr, ptr %user31, align 8
  %user32 = getelementptr inbounds %struct.RedisModuleUser, ptr %33, i32 0, i32 0
  %34 = load ptr, ptr %user32, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then28
  %35 = load ptr, ptr %ctx.addr, align 8
  %client33 = getelementptr inbounds %struct.RedisModuleCtx, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %client33, align 8
  %user34 = getelementptr inbounds %struct.client, ptr %36, i32 0, i32 20
  %37 = load ptr, ptr %user34, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %34, %cond.true ], [ %37, %cond.false ]
  store ptr %cond, ptr %user, align 8
  %38 = load ptr, ptr %user, align 8
  %tobool35 = icmp ne ptr %38, null
  br i1 %tobool35, label %if.end43, label %if.then36

if.then36:                                        ; preds = %cond.end
  %call37 = call ptr @__errno_location() #15
  store i32 95, ptr %call37, align 4
  %39 = load i32, ptr %error_as_call_replies, align 4
  %tobool38 = icmp ne i32 %39, 0
  br i1 %tobool38, label %if.then39, label %if.end42

if.then39:                                        ; preds = %if.then36
  %call40 = call ptr @sdsnew(ptr noundef @.str.46)
  store ptr %call40, ptr %msg, align 8
  %40 = load ptr, ptr %msg, align 8
  %41 = load ptr, ptr %ctx.addr, align 8
  %call41 = call ptr @callReplyCreateError(ptr noundef %40, ptr noundef %41)
  store ptr %call41, ptr %reply, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.then39, %if.then36
  br label %cleanup

if.end43:                                         ; preds = %cond.end
  %42 = load ptr, ptr %user, align 8
  %43 = load ptr, ptr %c, align 8
  %user44 = getelementptr inbounds %struct.client, ptr %43, i32 0, i32 20
  store ptr %42, ptr %user44, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.end43, %if.end25
  %44 = load ptr, ptr %argv, align 8
  %cmp = icmp eq ptr %44, null
  br i1 %cmp, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.end45
  %call47 = call ptr @__errno_location() #15
  store i32 9, ptr %call47, align 4
  br label %cleanup

if.end48:                                         ; preds = %if.end45
  %45 = load ptr, ptr %c, align 8
  call void @moduleCallCommandFilters(ptr noundef %45)
  %46 = load ptr, ptr %c, align 8
  %argv49 = getelementptr inbounds %struct.client, ptr %46, i32 0, i32 12
  %47 = load ptr, ptr %argv49, align 8
  %48 = load ptr, ptr %c, align 8
  %argc50 = getelementptr inbounds %struct.client, ptr %48, i32 0, i32 11
  %49 = load i32, ptr %argc50, align 8
  %call51 = call ptr @lookupCommand(ptr noundef %47, i32 noundef %49)
  %50 = load ptr, ptr %c, align 8
  %realcmd = getelementptr inbounds %struct.client, ptr %50, i32 0, i32 19
  store ptr %call51, ptr %realcmd, align 8
  %51 = load ptr, ptr %c, align 8
  %lastcmd = getelementptr inbounds %struct.client, ptr %51, i32 0, i32 18
  store ptr %call51, ptr %lastcmd, align 8
  %52 = load ptr, ptr %c, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %52, i32 0, i32 17
  store ptr %call51, ptr %cmd, align 8
  %53 = load ptr, ptr %c, align 8
  %54 = load i32, ptr %error_as_call_replies, align 4
  %tobool52 = icmp ne i32 %54, 0
  br i1 %tobool52, label %cond.true53, label %cond.false54

cond.true53:                                      ; preds = %if.end48
  br label %cond.end55

cond.false54:                                     ; preds = %if.end48
  br label %cond.end55

cond.end55:                                       ; preds = %cond.false54, %cond.true53
  %cond56 = phi ptr [ %err, %cond.true53 ], [ null, %cond.false54 ]
  %call57 = call i32 @commandCheckExistence(ptr noundef %53, ptr noundef %cond56)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.end65, label %if.then59

if.then59:                                        ; preds = %cond.end55
  %call60 = call ptr @__errno_location() #15
  store i32 2, ptr %call60, align 4
  %55 = load i32, ptr %error_as_call_replies, align 4
  %tobool61 = icmp ne i32 %55, 0
  br i1 %tobool61, label %if.then62, label %if.end64

if.then62:                                        ; preds = %if.then59
  %56 = load ptr, ptr %err, align 8
  %57 = load ptr, ptr %ctx.addr, align 8
  %call63 = call ptr @callReplyCreateError(ptr noundef %56, ptr noundef %57)
  store ptr %call63, ptr %reply, align 8
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %if.then59
  br label %cleanup

if.end65:                                         ; preds = %cond.end55
  %58 = load ptr, ptr %c, align 8
  %59 = load i32, ptr %error_as_call_replies, align 4
  %tobool66 = icmp ne i32 %59, 0
  br i1 %tobool66, label %cond.true67, label %cond.false68

cond.true67:                                      ; preds = %if.end65
  br label %cond.end69

cond.false68:                                     ; preds = %if.end65
  br label %cond.end69

cond.end69:                                       ; preds = %cond.false68, %cond.true67
  %cond70 = phi ptr [ %err, %cond.true67 ], [ null, %cond.false68 ]
  %call71 = call i32 @commandCheckArity(ptr noundef %58, ptr noundef %cond70)
  %tobool72 = icmp ne i32 %call71, 0
  br i1 %tobool72, label %if.end79, label %if.then73

if.then73:                                        ; preds = %cond.end69
  %call74 = call ptr @__errno_location() #15
  store i32 22, ptr %call74, align 4
  %60 = load i32, ptr %error_as_call_replies, align 4
  %tobool75 = icmp ne i32 %60, 0
  br i1 %tobool75, label %if.then76, label %if.end78

if.then76:                                        ; preds = %if.then73
  %61 = load ptr, ptr %err, align 8
  %62 = load ptr, ptr %ctx.addr, align 8
  %call77 = call ptr @callReplyCreateError(ptr noundef %61, ptr noundef %62)
  store ptr %call77, ptr %reply, align 8
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %if.then73
  br label %cleanup

if.end79:                                         ; preds = %cond.end69
  %63 = load ptr, ptr %c, align 8
  %call80 = call i64 @getCommandFlags(ptr noundef %63)
  store i64 %call80, ptr %cmd_flags, align 8
  %64 = load i32, ptr %flags, align 4
  %and81 = and i32 %64, 64
  %tobool82 = icmp ne i32 %and81, 0
  br i1 %tobool82, label %if.then83, label %if.end97

if.then83:                                        ; preds = %if.end79
  %65 = load i64, ptr %cmd_flags, align 8
  %and84 = and i64 %65, 64
  %tobool85 = icmp ne i64 %and84, 0
  br i1 %tobool85, label %if.then86, label %if.end96

if.then86:                                        ; preds = %if.then83
  %call87 = call ptr @__errno_location() #15
  store i32 29, ptr %call87, align 4
  %66 = load i32, ptr %error_as_call_replies, align 4
  %tobool88 = icmp ne i32 %66, 0
  br i1 %tobool88, label %if.then89, label %if.end95

if.then89:                                        ; preds = %if.then86
  %call91 = call ptr @sdsempty()
  %67 = load ptr, ptr %c, align 8
  %cmd92 = getelementptr inbounds %struct.client, ptr %67, i32 0, i32 17
  %68 = load ptr, ptr %cmd92, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %68, i32 0, i32 27
  %69 = load ptr, ptr %fullname, align 8
  %call93 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call91, ptr noundef @.str.47, ptr noundef %69)
  store ptr %call93, ptr %msg90, align 8
  %70 = load ptr, ptr %msg90, align 8
  %71 = load ptr, ptr %ctx.addr, align 8
  %call94 = call ptr @callReplyCreateError(ptr noundef %70, ptr noundef %71)
  store ptr %call94, ptr %reply, align 8
  br label %if.end95

if.end95:                                         ; preds = %if.then89, %if.then86
  br label %cleanup

if.end96:                                         ; preds = %if.then83
  br label %if.end97

if.end97:                                         ; preds = %if.end96, %if.end79
  %72 = load i32, ptr %flags, align 4
  %and98 = and i32 %72, 512
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %land.lhs.true, label %if.else124

land.lhs.true:                                    ; preds = %if.end97
  %73 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  %tobool100 = icmp ne i64 %73, 0
  br i1 %tobool100, label %if.then101, label %if.else124

if.then101:                                       ; preds = %land.lhs.true
  %74 = load i64, ptr %cmd_flags, align 8
  %and102 = and i64 %74, 4
  %tobool103 = icmp ne i64 %and102, 0
  br i1 %tobool103, label %if.then104, label %if.end123

if.then104:                                       ; preds = %if.then101
  %75 = load ptr, ptr %ctx.addr, align 8
  %flags105 = getelementptr inbounds %struct.RedisModuleCtx, ptr %75, i32 0, i32 7
  %76 = load i32, ptr %flags105, align 8
  %and106 = and i32 %76, 16
  %tobool107 = icmp ne i32 %and106, 0
  br i1 %tobool107, label %if.then108, label %if.else111

if.then108:                                       ; preds = %if.then104
  %call109 = call i32 @getMaxmemoryState(ptr noundef null, ptr noundef null, ptr noundef null, ptr noundef null)
  %cmp110 = icmp eq i32 %call109, -1
  %conv = zext i1 %cmp110 to i32
  store i32 %conv, ptr %oom_state, align 4
  br label %if.end112

if.else111:                                       ; preds = %if.then104
  %77 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 386), align 8
  store i32 %77, ptr %oom_state, align 4
  br label %if.end112

if.end112:                                        ; preds = %if.else111, %if.then108
  %78 = load i32, ptr %oom_state, align 4
  %tobool113 = icmp ne i32 %78, 0
  br i1 %tobool113, label %if.then114, label %if.end122

if.then114:                                       ; preds = %if.end112
  %call115 = call ptr @__errno_location() #15
  store i32 28, ptr %call115, align 4
  %79 = load i32, ptr %error_as_call_replies, align 4
  %tobool116 = icmp ne i32 %79, 0
  br i1 %tobool116, label %if.then117, label %if.end121

if.then117:                                       ; preds = %if.then114
  %80 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 30), align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %80, i32 0, i32 2
  %81 = load ptr, ptr %ptr, align 8
  %call119 = call ptr @sdsdup(ptr noundef %81)
  store ptr %call119, ptr %msg118, align 8
  %82 = load ptr, ptr %msg118, align 8
  %83 = load ptr, ptr %ctx.addr, align 8
  %call120 = call ptr @callReplyCreateError(ptr noundef %82, ptr noundef %83)
  store ptr %call120, ptr %reply, align 8
  br label %if.end121

if.end121:                                        ; preds = %if.then117, %if.then114
  br label %cleanup

if.end122:                                        ; preds = %if.end112
  br label %if.end123

if.end123:                                        ; preds = %if.end122, %if.then101
  br label %if.end127

if.else124:                                       ; preds = %land.lhs.true, %if.end97
  %84 = load ptr, ptr %c, align 8
  %flags125 = getelementptr inbounds %struct.client, ptr %84, i32 0, i32 1
  %85 = load i64, ptr %flags125, align 8
  %or126 = or i64 %85, 17592186044416
  store i64 %or126, ptr %flags125, align 8
  br label %if.end127

if.end127:                                        ; preds = %if.else124, %if.end123
  %86 = load i32, ptr %flags, align 4
  %and128 = and i32 %86, 128
  %tobool129 = icmp ne i32 %and128, 0
  br i1 %tobool129, label %if.then130, label %if.end145

if.then130:                                       ; preds = %if.end127
  %87 = load i64, ptr %cmd_flags, align 8
  %and131 = and i64 %87, 1
  %tobool132 = icmp ne i64 %and131, 0
  br i1 %tobool132, label %if.then133, label %if.end144

if.then133:                                       ; preds = %if.then130
  %call134 = call ptr @__errno_location() #15
  store i32 28, ptr %call134, align 4
  %88 = load i32, ptr %error_as_call_replies, align 4
  %tobool135 = icmp ne i32 %88, 0
  br i1 %tobool135, label %if.then136, label %if.end143

if.then136:                                       ; preds = %if.then133
  %call138 = call ptr @sdsempty()
  %89 = load ptr, ptr %c, align 8
  %cmd139 = getelementptr inbounds %struct.client, ptr %89, i32 0, i32 17
  %90 = load ptr, ptr %cmd139, align 8
  %fullname140 = getelementptr inbounds %struct.redisCommand, ptr %90, i32 0, i32 27
  %91 = load ptr, ptr %fullname140, align 8
  %call141 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call138, ptr noundef @.str.48, ptr noundef %91)
  store ptr %call141, ptr %msg137, align 8
  %92 = load ptr, ptr %msg137, align 8
  %93 = load ptr, ptr %ctx.addr, align 8
  %call142 = call ptr @callReplyCreateError(ptr noundef %92, ptr noundef %93)
  store ptr %call142, ptr %reply, align 8
  br label %if.end143

if.end143:                                        ; preds = %if.then136, %if.then133
  br label %cleanup

if.end144:                                        ; preds = %if.then130
  br label %if.end145

if.end145:                                        ; preds = %if.end144, %if.end127
  %94 = load i32, ptr %flags, align 4
  %and146 = and i32 %94, 64
  %tobool147 = icmp ne i32 %and146, 0
  br i1 %tobool147, label %if.then148, label %if.end217

if.then148:                                       ; preds = %if.end145
  %95 = load i64, ptr %cmd_flags, align 8
  %and149 = and i64 %95, 1
  %tobool150 = icmp ne i64 %and149, 0
  br i1 %tobool150, label %if.then151, label %if.end196

if.then151:                                       ; preds = %if.then148
  %call152 = call i32 @checkGoodReplicasStatus()
  %tobool153 = icmp ne i32 %call152, 0
  br i1 %tobool153, label %if.end163, label %if.then154

if.then154:                                       ; preds = %if.then151
  %call155 = call ptr @__errno_location() #15
  store i32 29, ptr %call155, align 4
  %96 = load i32, ptr %error_as_call_replies, align 4
  %tobool156 = icmp ne i32 %96, 0
  br i1 %tobool156, label %if.then157, label %if.end162

if.then157:                                       ; preds = %if.then154
  %97 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 28), align 8
  %ptr159 = getelementptr inbounds %struct.redisObject, ptr %97, i32 0, i32 2
  %98 = load ptr, ptr %ptr159, align 8
  %call160 = call ptr @sdsdup(ptr noundef %98)
  store ptr %call160, ptr %msg158, align 8
  %99 = load ptr, ptr %msg158, align 8
  %100 = load ptr, ptr %ctx.addr, align 8
  %call161 = call ptr @callReplyCreateError(ptr noundef %99, ptr noundef %100)
  store ptr %call161, ptr %reply, align 8
  br label %if.end162

if.end162:                                        ; preds = %if.then157, %if.then154
  br label %cleanup

if.end163:                                        ; preds = %if.then151
  %call164 = call i32 @writeCommandsDeniedByDiskError()
  store i32 %call164, ptr %deny_write_type, align 4
  %101 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %tobool165 = icmp ne ptr %101, null
  br i1 %tobool165, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end163
  %102 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %call166 = call i32 @mustObeyClient(ptr noundef %102)
  %tobool167 = icmp ne i32 %call166, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end163
  %103 = phi i1 [ false, %if.end163 ], [ %tobool167, %land.rhs ]
  %land.ext = zext i1 %103 to i32
  store i32 %land.ext, ptr %obey_client, align 4
  %104 = load i32, ptr %deny_write_type, align 4
  %cmp168 = icmp ne i32 %104, 0
  br i1 %cmp168, label %land.lhs.true170, label %if.end180

land.lhs.true170:                                 ; preds = %land.end
  %105 = load i32, ptr %obey_client, align 4
  %tobool171 = icmp ne i32 %105, 0
  br i1 %tobool171, label %if.end180, label %if.then172

if.then172:                                       ; preds = %land.lhs.true170
  %call173 = call ptr @__errno_location() #15
  store i32 29, ptr %call173, align 4
  %106 = load i32, ptr %error_as_call_replies, align 4
  %tobool174 = icmp ne i32 %106, 0
  br i1 %tobool174, label %if.then175, label %if.end179

if.then175:                                       ; preds = %if.then172
  %107 = load i32, ptr %deny_write_type, align 4
  %call177 = call ptr @writeCommandsGetDiskErrorMessage(i32 noundef %107)
  store ptr %call177, ptr %msg176, align 8
  %108 = load ptr, ptr %msg176, align 8
  %109 = load ptr, ptr %ctx.addr, align 8
  %call178 = call ptr @callReplyCreateError(ptr noundef %108, ptr noundef %109)
  store ptr %call178, ptr %reply, align 8
  br label %if.end179

if.end179:                                        ; preds = %if.then175, %if.then172
  br label %cleanup

if.end180:                                        ; preds = %land.lhs.true170, %land.end
  %110 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool181 = icmp ne ptr %110, null
  br i1 %tobool181, label %land.lhs.true182, label %if.end195

land.lhs.true182:                                 ; preds = %if.end180
  %111 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 298), align 4
  %tobool183 = icmp ne i32 %111, 0
  br i1 %tobool183, label %land.lhs.true184, label %if.end195

land.lhs.true184:                                 ; preds = %land.lhs.true182
  %112 = load i32, ptr %obey_client, align 4
  %tobool185 = icmp ne i32 %112, 0
  br i1 %tobool185, label %if.end195, label %if.then186

if.then186:                                       ; preds = %land.lhs.true184
  %call187 = call ptr @__errno_location() #15
  store i32 29, ptr %call187, align 4
  %113 = load i32, ptr %error_as_call_replies, align 4
  %tobool188 = icmp ne i32 %113, 0
  br i1 %tobool188, label %if.then189, label %if.end194

if.then189:                                       ; preds = %if.then186
  %114 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 25), align 8
  %ptr191 = getelementptr inbounds %struct.redisObject, ptr %114, i32 0, i32 2
  %115 = load ptr, ptr %ptr191, align 8
  %call192 = call ptr @sdsdup(ptr noundef %115)
  store ptr %call192, ptr %msg190, align 8
  %116 = load ptr, ptr %msg190, align 8
  %117 = load ptr, ptr %ctx.addr, align 8
  %call193 = call ptr @callReplyCreateError(ptr noundef %116, ptr noundef %117)
  store ptr %call193, ptr %reply, align 8
  br label %if.end194

if.end194:                                        ; preds = %if.then189, %if.then186
  br label %cleanup

if.end195:                                        ; preds = %land.lhs.true184, %land.lhs.true182, %if.end180
  br label %if.end196

if.end196:                                        ; preds = %if.end195, %if.then148
  %118 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool197 = icmp ne ptr %118, null
  br i1 %tobool197, label %land.lhs.true198, label %if.end216

land.lhs.true198:                                 ; preds = %if.end196
  %119 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp199 = icmp ne i32 %119, 12
  br i1 %cmp199, label %land.lhs.true201, label %if.end216

land.lhs.true201:                                 ; preds = %land.lhs.true198
  %120 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 297), align 8
  %cmp202 = icmp eq i32 %120, 0
  br i1 %cmp202, label %land.lhs.true204, label %if.end216

land.lhs.true204:                                 ; preds = %land.lhs.true201
  %121 = load i64, ptr %cmd_flags, align 8
  %and205 = and i64 %121, 1024
  %tobool206 = icmp ne i64 %and205, 0
  br i1 %tobool206, label %if.end216, label %if.then207

if.then207:                                       ; preds = %land.lhs.true204
  %call208 = call ptr @__errno_location() #15
  store i32 29, ptr %call208, align 4
  %122 = load i32, ptr %error_as_call_replies, align 4
  %tobool209 = icmp ne i32 %122, 0
  br i1 %tobool209, label %if.then210, label %if.end215

if.then210:                                       ; preds = %if.then207
  %123 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 24), align 8
  %ptr212 = getelementptr inbounds %struct.redisObject, ptr %123, i32 0, i32 2
  %124 = load ptr, ptr %ptr212, align 8
  %call213 = call ptr @sdsdup(ptr noundef %124)
  store ptr %call213, ptr %msg211, align 8
  %125 = load ptr, ptr %msg211, align 8
  %126 = load ptr, ptr %ctx.addr, align 8
  %call214 = call ptr @callReplyCreateError(ptr noundef %125, ptr noundef %126)
  store ptr %call214, ptr %reply, align 8
  br label %if.end215

if.end215:                                        ; preds = %if.then210, %if.then207
  br label %cleanup

if.end216:                                        ; preds = %land.lhs.true204, %land.lhs.true201, %land.lhs.true198, %if.end196
  br label %if.end217

if.end217:                                        ; preds = %if.end216, %if.end145
  %127 = load i32, ptr %flags, align 4
  %and218 = and i32 %127, 32
  %tobool219 = icmp ne i32 %and218, 0
  br i1 %tobool219, label %if.then220, label %if.end258

if.then220:                                       ; preds = %if.end217
  %128 = load ptr, ptr %user, align 8
  %129 = load ptr, ptr %c, align 8
  %cmd221 = getelementptr inbounds %struct.client, ptr %129, i32 0, i32 17
  %130 = load ptr, ptr %cmd221, align 8
  %131 = load ptr, ptr %c, align 8
  %argv222 = getelementptr inbounds %struct.client, ptr %131, i32 0, i32 12
  %132 = load ptr, ptr %argv222, align 8
  %133 = load ptr, ptr %c, align 8
  %argc223 = getelementptr inbounds %struct.client, ptr %133, i32 0, i32 11
  %134 = load i32, ptr %argc223, align 8
  %call224 = call i32 @ACLCheckAllUserCommandPerm(ptr noundef %128, ptr noundef %130, ptr noundef %132, i32 noundef %134, ptr noundef %acl_errpos)
  store i32 %call224, ptr %acl_retval, align 4
  %135 = load i32, ptr %acl_retval, align 4
  %cmp225 = icmp ne i32 %135, 0
  br i1 %cmp225, label %if.then227, label %if.end257

if.then227:                                       ; preds = %if.then220
  %136 = load i32, ptr %acl_retval, align 4
  %cmp228 = icmp eq i32 %136, 1
  br i1 %cmp228, label %cond.true230, label %cond.false234

cond.true230:                                     ; preds = %if.then227
  %137 = load ptr, ptr %c, align 8
  %cmd231 = getelementptr inbounds %struct.client, ptr %137, i32 0, i32 17
  %138 = load ptr, ptr %cmd231, align 8
  %fullname232 = getelementptr inbounds %struct.redisCommand, ptr %138, i32 0, i32 27
  %139 = load ptr, ptr %fullname232, align 8
  %call233 = call ptr @sdsdup(ptr noundef %139)
  br label %cond.end238

cond.false234:                                    ; preds = %if.then227
  %140 = load ptr, ptr %c, align 8
  %argv235 = getelementptr inbounds %struct.client, ptr %140, i32 0, i32 12
  %141 = load ptr, ptr %argv235, align 8
  %142 = load i32, ptr %acl_errpos, align 4
  %idxprom = sext i32 %142 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %141, i64 %idxprom
  %143 = load ptr, ptr %arrayidx, align 8
  %ptr236 = getelementptr inbounds %struct.redisObject, ptr %143, i32 0, i32 2
  %144 = load ptr, ptr %ptr236, align 8
  %call237 = call ptr @sdsdup(ptr noundef %144)
  br label %cond.end238

cond.end238:                                      ; preds = %cond.false234, %cond.true230
  %cond239 = phi ptr [ %call233, %cond.true230 ], [ %call237, %cond.false234 ]
  store ptr %cond239, ptr %object, align 8
  %145 = load ptr, ptr %ctx.addr, align 8
  %client240 = getelementptr inbounds %struct.RedisModuleCtx, ptr %145, i32 0, i32 2
  %146 = load ptr, ptr %client240, align 8
  %147 = load i32, ptr %acl_retval, align 4
  %148 = load ptr, ptr %c, align 8
  %user241 = getelementptr inbounds %struct.client, ptr %148, i32 0, i32 20
  %149 = load ptr, ptr %user241, align 8
  %name = getelementptr inbounds %struct.user, ptr %149, i32 0, i32 0
  %150 = load ptr, ptr %name, align 8
  %151 = load ptr, ptr %object, align 8
  call void @addACLLogEntry(ptr noundef %146, i32 noundef %147, i32 noundef 3, i32 noundef -1, ptr noundef %150, ptr noundef %151)
  %152 = load i32, ptr %error_as_call_replies, align 4
  %tobool242 = icmp ne i32 %152, 0
  br i1 %tobool242, label %if.then243, label %if.end255

if.then243:                                       ; preds = %cond.end238
  %153 = load i32, ptr %acl_retval, align 4
  %154 = load ptr, ptr %c, align 8
  %user244 = getelementptr inbounds %struct.client, ptr %154, i32 0, i32 20
  %155 = load ptr, ptr %user244, align 8
  %156 = load ptr, ptr %c, align 8
  %cmd245 = getelementptr inbounds %struct.client, ptr %156, i32 0, i32 17
  %157 = load ptr, ptr %cmd245, align 8
  %158 = load ptr, ptr %c, align 8
  %argv246 = getelementptr inbounds %struct.client, ptr %158, i32 0, i32 12
  %159 = load ptr, ptr %argv246, align 8
  %160 = load i32, ptr %acl_errpos, align 4
  %idxprom247 = sext i32 %160 to i64
  %arrayidx248 = getelementptr inbounds ptr, ptr %159, i64 %idxprom247
  %161 = load ptr, ptr %arrayidx248, align 8
  %ptr249 = getelementptr inbounds %struct.redisObject, ptr %161, i32 0, i32 2
  %162 = load ptr, ptr %ptr249, align 8
  %call250 = call ptr @getAclErrorMessage(i32 noundef %153, ptr noundef %155, ptr noundef %157, ptr noundef %162, i32 noundef 0)
  store ptr %call250, ptr %acl_msg, align 8
  %call252 = call ptr @sdsempty()
  %163 = load ptr, ptr %acl_msg, align 8
  %call253 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call252, ptr noundef @.str.49, ptr noundef %163)
  store ptr %call253, ptr %msg251, align 8
  %164 = load ptr, ptr %acl_msg, align 8
  call void @sdsfree(ptr noundef %164)
  %165 = load ptr, ptr %msg251, align 8
  %166 = load ptr, ptr %ctx.addr, align 8
  %call254 = call ptr @callReplyCreateError(ptr noundef %165, ptr noundef %166)
  store ptr %call254, ptr %reply, align 8
  br label %if.end255

if.end255:                                        ; preds = %if.then243, %cond.end238
  %call256 = call ptr @__errno_location() #15
  store i32 13, ptr %call256, align 4
  br label %cleanup

if.end257:                                        ; preds = %if.then220
  br label %if.end258

if.end258:                                        ; preds = %if.end257, %if.end217
  %167 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool259 = icmp ne i32 %167, 0
  br i1 %tobool259, label %land.lhs.true260, label %if.end317

land.lhs.true260:                                 ; preds = %if.end258
  %168 = load ptr, ptr %ctx.addr, align 8
  %client261 = getelementptr inbounds %struct.RedisModuleCtx, ptr %168, i32 0, i32 2
  %169 = load ptr, ptr %client261, align 8
  %call262 = call i32 @mustObeyClient(ptr noundef %169)
  %tobool263 = icmp ne i32 %call262, 0
  br i1 %tobool263, label %if.end317, label %if.then264

if.then264:                                       ; preds = %land.lhs.true260
  %170 = load ptr, ptr %c, align 8
  %flags265 = getelementptr inbounds %struct.client, ptr %170, i32 0, i32 1
  %171 = load i64, ptr %flags265, align 8
  %and266 = and i64 %171, -131585
  store i64 %and266, ptr %flags265, align 8
  %172 = load ptr, ptr %ctx.addr, align 8
  %client267 = getelementptr inbounds %struct.RedisModuleCtx, ptr %172, i32 0, i32 2
  %173 = load ptr, ptr %client267, align 8
  %flags268 = getelementptr inbounds %struct.client, ptr %173, i32 0, i32 1
  %174 = load i64, ptr %flags268, align 8
  %and269 = and i64 %174, 131584
  %175 = load ptr, ptr %c, align 8
  %flags270 = getelementptr inbounds %struct.client, ptr %175, i32 0, i32 1
  %176 = load i64, ptr %flags270, align 8
  %or271 = or i64 %176, %and269
  store i64 %or271, ptr %flags270, align 8
  %177 = load ptr, ptr %c, align 8
  %178 = load ptr, ptr %c, align 8
  %cmd272 = getelementptr inbounds %struct.client, ptr %178, i32 0, i32 17
  %179 = load ptr, ptr %cmd272, align 8
  %180 = load ptr, ptr %c, align 8
  %argv273 = getelementptr inbounds %struct.client, ptr %180, i32 0, i32 12
  %181 = load ptr, ptr %argv273, align 8
  %182 = load ptr, ptr %c, align 8
  %argc274 = getelementptr inbounds %struct.client, ptr %182, i32 0, i32 11
  %183 = load i32, ptr %argc274, align 8
  %call275 = call ptr @getNodeByQuery(ptr noundef %177, ptr noundef %179, ptr noundef %181, i32 noundef %183, ptr noundef null, ptr noundef %error_code)
  %call276 = call ptr @getMyClusterNode()
  %cmp277 = icmp ne ptr %call275, %call276
  br i1 %cmp277, label %if.then279, label %if.end316

if.then279:                                       ; preds = %if.then264
  store ptr null, ptr %msg280, align 8
  %184 = load i32, ptr %error_code, align 4
  %cmp281 = icmp eq i32 %184, 7
  br i1 %cmp281, label %if.then283, label %if.else292

if.then283:                                       ; preds = %if.then279
  %185 = load i32, ptr %error_as_call_replies, align 4
  %tobool284 = icmp ne i32 %185, 0
  br i1 %tobool284, label %if.then285, label %if.end290

if.then285:                                       ; preds = %if.then283
  %call286 = call ptr @sdsempty()
  %186 = load ptr, ptr %c, align 8
  %cmd287 = getelementptr inbounds %struct.client, ptr %186, i32 0, i32 17
  %187 = load ptr, ptr %cmd287, align 8
  %fullname288 = getelementptr inbounds %struct.redisCommand, ptr %187, i32 0, i32 27
  %188 = load ptr, ptr %fullname288, align 8
  %call289 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call286, ptr noundef @.str.50, ptr noundef %188)
  store ptr %call289, ptr %msg280, align 8
  br label %if.end290

if.end290:                                        ; preds = %if.then285, %if.then283
  %call291 = call ptr @__errno_location() #15
  store i32 30, ptr %call291, align 4
  br label %if.end311

if.else292:                                       ; preds = %if.then279
  %189 = load i32, ptr %error_code, align 4
  %cmp293 = icmp eq i32 %189, 5
  br i1 %cmp293, label %if.then295, label %if.else304

if.then295:                                       ; preds = %if.else292
  %190 = load i32, ptr %error_as_call_replies, align 4
  %tobool296 = icmp ne i32 %190, 0
  br i1 %tobool296, label %if.then297, label %if.end302

if.then297:                                       ; preds = %if.then295
  %call298 = call ptr @sdsempty()
  %191 = load ptr, ptr %c, align 8
  %cmd299 = getelementptr inbounds %struct.client, ptr %191, i32 0, i32 17
  %192 = load ptr, ptr %cmd299, align 8
  %fullname300 = getelementptr inbounds %struct.redisCommand, ptr %192, i32 0, i32 27
  %193 = load ptr, ptr %fullname300, align 8
  %call301 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call298, ptr noundef @.str.51, ptr noundef %193)
  store ptr %call301, ptr %msg280, align 8
  br label %if.end302

if.end302:                                        ; preds = %if.then297, %if.then295
  %call303 = call ptr @__errno_location() #15
  store i32 100, ptr %call303, align 4
  br label %if.end310

if.else304:                                       ; preds = %if.else292
  %194 = load i32, ptr %error_as_call_replies, align 4
  %tobool305 = icmp ne i32 %194, 0
  br i1 %tobool305, label %if.then306, label %if.end308

if.then306:                                       ; preds = %if.else304
  %call307 = call ptr @sdsnew(ptr noundef @.str.52)
  store ptr %call307, ptr %msg280, align 8
  br label %if.end308

if.end308:                                        ; preds = %if.then306, %if.else304
  %call309 = call ptr @__errno_location() #15
  store i32 1, ptr %call309, align 4
  br label %if.end310

if.end310:                                        ; preds = %if.end308, %if.end302
  br label %if.end311

if.end311:                                        ; preds = %if.end310, %if.end290
  %195 = load ptr, ptr %msg280, align 8
  %tobool312 = icmp ne ptr %195, null
  br i1 %tobool312, label %if.then313, label %if.end315

if.then313:                                       ; preds = %if.end311
  %196 = load ptr, ptr %msg280, align 8
  %197 = load ptr, ptr %ctx.addr, align 8
  %call314 = call ptr @callReplyCreateError(ptr noundef %196, ptr noundef %197)
  store ptr %call314, ptr %reply, align 8
  br label %if.end315

if.end315:                                        ; preds = %if.then313, %if.end311
  br label %cleanup

if.end316:                                        ; preds = %if.then264
  br label %if.end317

if.end317:                                        ; preds = %if.end316, %land.lhs.true260, %if.end258
  %198 = load i32, ptr %flags, align 4
  %and318 = and i32 %198, 1024
  %tobool319 = icmp ne i32 %and318, 0
  br i1 %tobool319, label %if.then320, label %if.end321

if.then320:                                       ; preds = %if.end317
  br label %cleanup

if.end321:                                        ; preds = %if.end317
  %199 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 249), align 8
  store i32 %199, ptr %prev_replication_allowed, align 4
  %200 = load i32, ptr %replicate, align 4
  %tobool322 = icmp ne i32 %200, 0
  br i1 %tobool322, label %land.rhs323, label %land.end325

land.rhs323:                                      ; preds = %if.end321
  %201 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 249), align 8
  %tobool324 = icmp ne i32 %201, 0
  br label %land.end325

land.end325:                                      ; preds = %land.rhs323, %if.end321
  %202 = phi i1 [ false, %if.end321 ], [ %tobool324, %land.rhs323 ]
  %land.ext326 = zext i1 %202 to i32
  store i32 %land.ext326, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 249), align 8
  store i32 8, ptr %call_flags, align 4
  %203 = load i32, ptr %replicate, align 4
  %tobool327 = icmp ne i32 %203, 0
  br i1 %tobool327, label %if.then328, label %if.end339

if.then328:                                       ; preds = %land.end325
  %204 = load i32, ptr %flags, align 4
  %and329 = and i32 %204, 2
  %tobool330 = icmp ne i32 %and329, 0
  br i1 %tobool330, label %if.end333, label %if.then331

if.then331:                                       ; preds = %if.then328
  %205 = load i32, ptr %call_flags, align 4
  %or332 = or i32 %205, 1
  store i32 %or332, ptr %call_flags, align 4
  br label %if.end333

if.end333:                                        ; preds = %if.then331, %if.then328
  %206 = load i32, ptr %flags, align 4
  %and334 = and i32 %206, 4
  %tobool335 = icmp ne i32 %and334, 0
  br i1 %tobool335, label %if.end338, label %if.then336

if.then336:                                       ; preds = %if.end333
  %207 = load i32, ptr %call_flags, align 4
  %or337 = or i32 %207, 2
  store i32 %or337, ptr %call_flags, align 4
  br label %if.end338

if.end338:                                        ; preds = %if.then336, %if.end333
  br label %if.end339

if.end339:                                        ; preds = %if.end338, %land.end325
  %208 = load ptr, ptr %c, align 8
  %209 = load i32, ptr %call_flags, align 4
  call void @call(ptr noundef %208, i32 noundef %209)
  %210 = load i32, ptr %prev_replication_allowed, align 4
  store i32 %210, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 249), align 8
  %211 = load ptr, ptr %c, align 8
  %flags340 = getelementptr inbounds %struct.client, ptr %211, i32 0, i32 1
  %212 = load i64, ptr %flags340, align 8
  %and341 = and i64 %212, 16
  %tobool342 = icmp ne i64 %and341, 0
  br i1 %tobool342, label %if.then343, label %if.else388

if.then343:                                       ; preds = %if.end339
  %213 = load i32, ptr %flags, align 4
  %and344 = and i32 %213, 2048
  %tobool345 = icmp ne i32 %and344, 0
  %lnot = xor i1 %tobool345, true
  %lnot346 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot346 to i32
  %conv347 = sext i32 %lnot.ext to i64
  %tobool348 = icmp ne i64 %conv347, 0
  br i1 %tobool348, label %cond.true349, label %cond.false350

cond.true349:                                     ; preds = %if.then343
  br label %cond.end351

cond.false350:                                    ; preds = %if.then343
  call void @_serverAssert(ptr noundef @.str.53, ptr noundef @.str.2, i32 noundef 6520)
  call void @abort() #13
  unreachable

214:                                              ; No predecessors!
  br label %cond.end351

cond.end351:                                      ; preds = %214, %cond.true349
  %215 = load ptr, ptr %ctx.addr, align 8
  %module352 = getelementptr inbounds %struct.RedisModuleCtx, ptr %215, i32 0, i32 1
  %216 = load ptr, ptr %module352, align 8
  %tobool353 = icmp ne ptr %216, null
  %lnot354 = xor i1 %tobool353, true
  %lnot356 = xor i1 %lnot354, true
  %lnot.ext357 = zext i1 %lnot356 to i32
  %conv358 = sext i32 %lnot.ext357 to i64
  %tobool359 = icmp ne i64 %conv358, 0
  br i1 %tobool359, label %cond.true360, label %cond.false361

cond.true360:                                     ; preds = %cond.end351
  br label %cond.end362

cond.false361:                                    ; preds = %cond.end351
  call void @_serverAssert(ptr noundef @.str.54, ptr noundef @.str.2, i32 noundef 6521)
  call void @abort() #13
  unreachable

217:                                              ; No predecessors!
  br label %cond.end362

cond.end362:                                      ; preds = %217, %cond.true360
  %call363 = call noalias ptr @zmalloc(i64 noundef 48) #11
  store ptr %call363, ptr %promise, align 8
  %218 = load ptr, ptr %promise, align 8
  %ref_count = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %.compoundliteral, i32 0, i32 0
  store i64 2, ptr %ref_count, align 8
  %private_data = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %.compoundliteral, i32 0, i32 1
  store ptr null, ptr %private_data, align 8
  %module364 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %.compoundliteral, i32 0, i32 2
  %219 = load ptr, ptr %ctx.addr, align 8
  %module365 = getelementptr inbounds %struct.RedisModuleCtx, ptr %219, i32 0, i32 1
  %220 = load ptr, ptr %module365, align 8
  store ptr %220, ptr %module364, align 8
  %on_unblocked = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %.compoundliteral, i32 0, i32 3
  store ptr null, ptr %on_unblocked, align 8
  %c366 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %.compoundliteral, i32 0, i32 4
  %221 = load ptr, ptr %c, align 8
  store ptr %221, ptr %c366, align 8
  %ctx367 = getelementptr inbounds %struct.RedisModuleAsyncRMCallPromise, ptr %.compoundliteral, i32 0, i32 5
  %222 = load ptr, ptr %ctx.addr, align 8
  %flags368 = getelementptr inbounds %struct.RedisModuleCtx, ptr %222, i32 0, i32 7
  %223 = load i32, ptr %flags368, align 8
  %and369 = and i32 %223, 1
  %tobool370 = icmp ne i32 %and369, 0
  br i1 %tobool370, label %cond.true371, label %cond.false372

cond.true371:                                     ; preds = %cond.end362
  %224 = load ptr, ptr %ctx.addr, align 8
  br label %cond.end373

cond.false372:                                    ; preds = %cond.end362
  br label %cond.end373

cond.end373:                                      ; preds = %cond.false372, %cond.true371
  %cond374 = phi ptr [ %224, %cond.true371 ], [ null, %cond.false372 ]
  store ptr %cond374, ptr %ctx367, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %218, ptr align 8 %.compoundliteral, i64 48, i1 false)
  %225 = load ptr, ptr %promise, align 8
  %call375 = call ptr @callReplyCreatePromise(ptr noundef %225)
  store ptr %call375, ptr %reply, align 8
  %226 = load ptr, ptr %promise, align 8
  %227 = load ptr, ptr %c, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %227, i32 0, i32 55
  %async_rm_call_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 8
  store ptr %226, ptr %async_rm_call_handle, align 8
  %228 = load i32, ptr %call_flags, align 4
  %and376 = and i32 %228, 1
  %tobool377 = icmp ne i32 %and376, 0
  br i1 %tobool377, label %if.end381, label %if.then378

if.then378:                                       ; preds = %cond.end373
  %229 = load ptr, ptr %c, align 8
  %flags379 = getelementptr inbounds %struct.client, ptr %229, i32 0, i32 1
  %230 = load i64, ptr %flags379, align 8
  %or380 = or i64 %230, 281474976710656
  store i64 %or380, ptr %flags379, align 8
  br label %if.end381

if.end381:                                        ; preds = %if.then378, %cond.end373
  %231 = load i32, ptr %call_flags, align 4
  %and382 = and i32 %231, 2
  %tobool383 = icmp ne i32 %and382, 0
  br i1 %tobool383, label %if.end387, label %if.then384

if.then384:                                       ; preds = %if.end381
  %232 = load ptr, ptr %c, align 8
  %flags385 = getelementptr inbounds %struct.client, ptr %232, i32 0, i32 1
  %233 = load i64, ptr %flags385, align 8
  %or386 = or i64 %233, 562949953421312
  store i64 %or386, ptr %flags385, align 8
  br label %if.end387

if.end387:                                        ; preds = %if.then384, %if.end381
  store ptr null, ptr %c, align 8
  br label %if.end397

if.else388:                                       ; preds = %if.end339
  %234 = load ptr, ptr %c, align 8
  %235 = load ptr, ptr %ctx.addr, align 8
  %flags389 = getelementptr inbounds %struct.RedisModuleCtx, ptr %235, i32 0, i32 7
  %236 = load i32, ptr %flags389, align 8
  %and390 = and i32 %236, 1
  %tobool391 = icmp ne i32 %and390, 0
  br i1 %tobool391, label %cond.true392, label %cond.false393

cond.true392:                                     ; preds = %if.else388
  %237 = load ptr, ptr %ctx.addr, align 8
  br label %cond.end394

cond.false393:                                    ; preds = %if.else388
  br label %cond.end394

cond.end394:                                      ; preds = %cond.false393, %cond.true392
  %cond395 = phi ptr [ %237, %cond.true392 ], [ null, %cond.false393 ]
  %call396 = call ptr @moduleParseReply(ptr noundef %234, ptr noundef %cond395)
  store ptr %call396, ptr %reply, align 8
  br label %if.end397

if.end397:                                        ; preds = %cond.end394, %if.end387
  br label %cleanup

cleanup:                                          ; preds = %if.end397, %if.then320, %if.end315, %if.end255, %if.end215, %if.end194, %if.end179, %if.end162, %if.end143, %if.end121, %if.end95, %if.end78, %if.end64, %if.then46, %if.end42
  %238 = load ptr, ptr %reply, align 8
  %tobool398 = icmp ne ptr %238, null
  br i1 %tobool398, label %if.then399, label %if.end400

if.then399:                                       ; preds = %cleanup
  %239 = load ptr, ptr %ctx.addr, align 8
  %240 = load ptr, ptr %reply, align 8
  call void @autoMemoryAdd(ptr noundef %239, i32 noundef 2, ptr noundef %240)
  br label %if.end400

if.end400:                                        ; preds = %if.then399, %cleanup
  %241 = load ptr, ptr %ctx.addr, align 8
  %module401 = getelementptr inbounds %struct.RedisModuleCtx, ptr %241, i32 0, i32 1
  %242 = load ptr, ptr %module401, align 8
  %tobool402 = icmp ne ptr %242, null
  br i1 %tobool402, label %if.then403, label %if.end406

if.then403:                                       ; preds = %if.end400
  %243 = load ptr, ptr %ctx.addr, align 8
  %module404 = getelementptr inbounds %struct.RedisModuleCtx, ptr %243, i32 0, i32 1
  %244 = load ptr, ptr %module404, align 8
  %in_call405 = getelementptr inbounds %struct.RedisModule, ptr %244, i32 0, i32 10
  %245 = load i32, ptr %in_call405, align 4
  %dec = add nsw i32 %245, -1
  store i32 %dec, ptr %in_call405, align 4
  br label %if.end406

if.end406:                                        ; preds = %if.then403, %if.end400
  %246 = load ptr, ptr %c, align 8
  %tobool407 = icmp ne ptr %246, null
  br i1 %tobool407, label %if.then408, label %if.end409

if.then408:                                       ; preds = %if.end406
  %247 = load ptr, ptr %c, align 8
  call void @moduleReleaseTempClient(ptr noundef %247)
  br label %if.end409

if.end409:                                        ; preds = %if.then408, %if.end406
  %248 = load ptr, ptr %reply, align 8
  ret ptr %248
}

declare ptr @callReplyCreateError(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleCallCommandFilters(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %filter = alloca %struct.RedisModuleCommandFilterCtx, align 8
  %f = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr @moduleCommandFilters, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr @moduleCommandFilters, align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  %argv = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i32 0, i32 0
  %3 = load ptr, ptr %c.addr, align 8
  %argv1 = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 12
  %4 = load ptr, ptr %argv1, align 8
  store ptr %4, ptr %argv, align 8
  %argv_len = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i32 0, i32 1
  %5 = load ptr, ptr %c.addr, align 8
  %argv_len2 = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 13
  %6 = load i32, ptr %argv_len2, align 8
  store i32 %6, ptr %argv_len, align 8
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i32 0, i32 2
  %7 = load ptr, ptr %c.addr, align 8
  %argc3 = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 11
  %8 = load i32, ptr %argc3, align 8
  store i32 %8, ptr %argc, align 4
  %c4 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i32 0, i32 3
  %9 = load ptr, ptr %c.addr, align 8
  store ptr %9, ptr %c4, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end8, %if.then7, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %value, align 8
  store ptr %11, ptr %f, align 8
  %12 = load ptr, ptr %f, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %12, i32 0, i32 2
  %13 = load i32, ptr %flags, align 8
  %and = and i32 %13, 1
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %while.body
  %14 = load ptr, ptr %f, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %module, align 8
  %in_call = getelementptr inbounds %struct.RedisModule, ptr %15, i32 0, i32 10
  %16 = load i32, ptr %in_call, align 4
  %tobool6 = icmp ne i32 %16, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %land.lhs.true
  br label %while.cond, !llvm.loop !32

if.end8:                                          ; preds = %land.lhs.true, %while.body
  %17 = load ptr, ptr %f, align 8
  %callback = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %callback, align 8
  call void %18(ptr noundef %filter)
  br label %while.cond, !llvm.loop !32

while.end:                                        ; preds = %while.cond
  %argv9 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i32 0, i32 0
  %19 = load ptr, ptr %argv9, align 8
  %20 = load ptr, ptr %c.addr, align 8
  %argv10 = getelementptr inbounds %struct.client, ptr %20, i32 0, i32 12
  store ptr %19, ptr %argv10, align 8
  %argv_len11 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i32 0, i32 1
  %21 = load i32, ptr %argv_len11, align 8
  %22 = load ptr, ptr %c.addr, align 8
  %argv_len12 = getelementptr inbounds %struct.client, ptr %22, i32 0, i32 13
  store i32 %21, ptr %argv_len12, align 8
  %argc13 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %filter, i32 0, i32 2
  %23 = load i32, ptr %argc13, align 4
  %24 = load ptr, ptr %c.addr, align 8
  %argc14 = getelementptr inbounds %struct.client, ptr %24, i32 0, i32 11
  store i32 %23, ptr %argc14, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

declare ptr @lookupCommand(ptr noundef, i32 noundef) #1

declare i32 @commandCheckExistence(ptr noundef, ptr noundef) #1

declare i32 @commandCheckArity(ptr noundef, ptr noundef) #1

declare i64 @getCommandFlags(ptr noundef) #1

declare ptr @sdscatfmt(ptr noundef, ptr noundef, ...) #1

declare i32 @checkGoodReplicasStatus() #1

declare i32 @writeCommandsDeniedByDiskError() #1

declare i32 @mustObeyClient(ptr noundef) #1

declare ptr @writeCommandsGetDiskErrorMessage(i32 noundef) #1

declare i32 @ACLCheckAllUserCommandPerm(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef) #1

declare void @addACLLogEntry(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) #1

declare ptr @getAclErrorMessage(i32 noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) #1

declare ptr @getNodeByQuery(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

declare ptr @getMyClusterNode() #1

declare void @call(ptr noundef, i32 noundef) #1

declare ptr @callReplyCreatePromise(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CallReplyProto(ptr noundef %reply, ptr noundef %len) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %1 = load ptr, ptr %len.addr, align 8
  %call = call ptr @callReplyGetProto(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @moduleTypeEncodeId(ptr noundef %name, i32 noundef %encver) #0 {
entry:
  %retval = alloca i64, align 8
  %name.addr = alloca ptr, align 8
  %encver.addr = alloca i32, align 4
  %cset = alloca ptr, align 8
  %id = alloca i64, align 8
  %j = alloca i32, align 4
  %p = alloca ptr, align 8
  %pos = alloca i64, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %encver, ptr %encver.addr, align 4
  %0 = load ptr, ptr @ModuleTypeNameCharSet, align 8
  store ptr %0, ptr %cset, align 8
  %1 = load ptr, ptr %name.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #14
  %cmp = icmp ne i64 %call, 9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %encver.addr, align 4
  %cmp1 = icmp slt i32 %2, 0
  br i1 %cmp1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load i32, ptr %encver.addr, align 4
  %cmp2 = icmp sgt i32 %3, 1023
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  store i64 0, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %lor.lhs.false
  store i64 0, ptr %id, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %4 = load i32, ptr %j, align 4
  %cmp5 = icmp slt i32 %4, 9
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %cset, align 8
  %6 = load ptr, ptr %name.addr, align 8
  %7 = load i32, ptr %j, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds i8, ptr %6, i64 %idxprom
  %8 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %8 to i32
  %call6 = call ptr @strchr(ptr noundef %5, i32 noundef %conv) #14
  store ptr %call6, ptr %p, align 8
  %9 = load ptr, ptr %p, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.end8, label %if.then7

if.then7:                                         ; preds = %for.body
  store i64 0, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %for.body
  %10 = load ptr, ptr %p, align 8
  %11 = load ptr, ptr %cset, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %10 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %11 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %pos, align 8
  %12 = load i64, ptr %id, align 8
  %shl = shl i64 %12, 6
  %13 = load i64, ptr %pos, align 8
  %or = or i64 %shl, %13
  store i64 %or, ptr %id, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end8
  %14 = load i32, ptr %j, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %for.cond
  %15 = load i64, ptr %id, align 8
  %shl9 = shl i64 %15, 10
  %16 = load i32, ptr %encver.addr, align 4
  %conv10 = sext i32 %16 to i64
  %or11 = or i64 %shl9, %conv10
  store i64 %or11, ptr %id, align 8
  %17 = load i64, ptr %id, align 8
  store i64 %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then7, %if.then3, %if.then
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strchr(ptr noundef, i32 noundef) #6

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeLookupModuleByNameInternal(ptr noundef %name, i32 noundef %ignore_case) #0 {
entry:
  %retval = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %ignore_case.addr = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %module = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %mt = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %ignore_case, ptr %ignore_case.addr, align 4
  %0 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.end, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end16

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %module, align 8
  %3 = load ptr, ptr %module, align 8
  %types = getelementptr inbounds %struct.RedisModule, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %types, align 8
  call void @listRewind(ptr noundef %4, ptr noundef %li)
  br label %while.cond3

while.cond3:                                      ; preds = %if.end, %while.body
  %call4 = call ptr @listNext(ptr noundef %li)
  store ptr %call4, ptr %ln, align 8
  %tobool = icmp ne ptr %call4, null
  br i1 %tobool, label %while.body5, label %while.end

while.body5:                                      ; preds = %while.cond3
  %5 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %mt, align 8
  %7 = load i32, ptr %ignore_case.addr, align 4
  %tobool6 = icmp ne i32 %7, 0
  br i1 %tobool6, label %lor.lhs.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body5
  %8 = load ptr, ptr %name.addr, align 8
  %9 = load ptr, ptr %mt, align 8
  %name7 = getelementptr inbounds %struct.RedisModuleType, ptr %9, i32 0, i32 20
  %arraydecay = getelementptr inbounds [10 x i8], ptr %name7, i64 0, i64 0
  %call8 = call i32 @memcmp(ptr noundef %8, ptr noundef %arraydecay, i64 noundef 10) #14
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %while.body5
  %10 = load i32, ptr %ignore_case.addr, align 4
  %tobool10 = icmp ne i32 %10, 0
  br i1 %tobool10, label %land.lhs.true11, label %if.end

land.lhs.true11:                                  ; preds = %lor.lhs.false
  %11 = load ptr, ptr %name.addr, align 8
  %12 = load ptr, ptr %mt, align 8
  %name12 = getelementptr inbounds %struct.RedisModuleType, ptr %12, i32 0, i32 20
  %arraydecay13 = getelementptr inbounds [10 x i8], ptr %name12, i64 0, i64 0
  %call14 = call i32 @strcasecmp(ptr noundef %11, ptr noundef %arraydecay13) #14
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true11, %land.lhs.true
  %13 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %13)
  %14 = load ptr, ptr %mt, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true11, %lor.lhs.false
  br label %while.cond3, !llvm.loop !34

while.end:                                        ; preds = %while.cond3
  br label %while.cond, !llvm.loop !35

while.end16:                                      ; preds = %while.cond
  %15 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %15)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end16, %if.then
  %16 = load ptr, ptr %retval, align 8
  ret ptr %16
}

declare ptr @dictGetIterator(ptr noundef) #1

declare ptr @dictNext(ptr noundef) #1

declare void @listRewind(ptr noundef, ptr noundef) #1

declare ptr @listNext(ptr noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #6

declare void @dictReleaseIterator(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeLookupModuleByName(ptr noundef %name) #0 {
entry:
  %name.addr = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %call = call ptr @moduleTypeLookupModuleByNameInternal(ptr noundef %0, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeLookupModuleByNameIgnoreCase(ptr noundef %name) #0 {
entry:
  %name.addr = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %call = call ptr @moduleTypeLookupModuleByNameInternal(ptr noundef %0, i32 noundef 1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeLookupModuleByID(i64 noundef %id) #0 {
entry:
  %retval = alloca ptr, align 8
  %id.addr = alloca i64, align 8
  %j = alloca i32, align 4
  %mt9 = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %module = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %this_mt = alloca ptr, align 8
  store i64 %id, ptr %id.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %0, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %1 = load i32, ptr %j, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %idxprom
  %mt = getelementptr inbounds %struct.anon.15, ptr %arrayidx, i32 0, i32 1
  %2 = load ptr, ptr %mt, align 8
  %cmp1 = icmp ne ptr %2, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %3 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %3, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %4 = load i32, ptr %j, align 4
  %idxprom2 = sext i32 %4 to i64
  %arrayidx3 = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %idxprom2
  %id4 = getelementptr inbounds %struct.anon.15, ptr %arrayidx3, i32 0, i32 0
  %5 = load i64, ptr %id4, align 16
  %6 = load i64, ptr %id.addr, align 8
  %cmp5 = icmp eq i64 %5, %6
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load i32, ptr %j, align 4
  %idxprom6 = sext i32 %7 to i64
  %arrayidx7 = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %idxprom6
  %mt8 = getelementptr inbounds %struct.anon.15, ptr %arrayidx7, i32 0, i32 1
  %8 = load ptr, ptr %mt8, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, ptr %j, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !36

for.end:                                          ; preds = %land.end
  store ptr null, ptr %mt9, align 8
  %10 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %10)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.end, %for.end
  %11 = load ptr, ptr %di, align 8
  %call10 = call ptr @dictNext(ptr noundef %11)
  store ptr %call10, ptr %de, align 8
  %cmp11 = icmp ne ptr %call10, null
  br i1 %cmp11, label %land.rhs12, label %land.end14

land.rhs12:                                       ; preds = %while.cond
  %12 = load ptr, ptr %mt9, align 8
  %cmp13 = icmp eq ptr %12, null
  br label %land.end14

land.end14:                                       ; preds = %land.rhs12, %while.cond
  %13 = phi i1 [ false, %while.cond ], [ %cmp13, %land.rhs12 ]
  br i1 %13, label %while.body, label %while.end24

while.body:                                       ; preds = %land.end14
  %14 = load ptr, ptr %de, align 8
  %call15 = call ptr @dictGetVal(ptr noundef %14)
  store ptr %call15, ptr %module, align 8
  %15 = load ptr, ptr %module, align 8
  %types = getelementptr inbounds %struct.RedisModule, ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %types, align 8
  call void @listRewind(ptr noundef %16, ptr noundef %li)
  br label %while.cond16

while.cond16:                                     ; preds = %if.end23, %while.body
  %call17 = call ptr @listNext(ptr noundef %li)
  store ptr %call17, ptr %ln, align 8
  %tobool = icmp ne ptr %call17, null
  br i1 %tobool, label %while.body18, label %while.end

while.body18:                                     ; preds = %while.cond16
  %17 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %value, align 8
  store ptr %18, ptr %this_mt, align 8
  %19 = load ptr, ptr %this_mt, align 8
  %id19 = getelementptr inbounds %struct.RedisModuleType, ptr %19, i32 0, i32 0
  %20 = load i64, ptr %id19, align 8
  %shr = lshr i64 %20, 10
  %21 = load i64, ptr %id.addr, align 8
  %shr20 = lshr i64 %21, 10
  %cmp21 = icmp eq i64 %shr, %shr20
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %while.body18
  %22 = load ptr, ptr %this_mt, align 8
  store ptr %22, ptr %mt9, align 8
  br label %while.end

if.end23:                                         ; preds = %while.body18
  br label %while.cond16, !llvm.loop !37

while.end:                                        ; preds = %if.then22, %while.cond16
  br label %while.cond, !llvm.loop !38

while.end24:                                      ; preds = %land.end14
  %23 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %23)
  %24 = load ptr, ptr %mt9, align 8
  %tobool25 = icmp ne ptr %24, null
  br i1 %tobool25, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %while.end24
  %25 = load i32, ptr %j, align 4
  %cmp26 = icmp slt i32 %25, 3
  br i1 %cmp26, label %if.then27, label %if.end34

if.then27:                                        ; preds = %land.lhs.true
  %26 = load i64, ptr %id.addr, align 8
  %27 = load i32, ptr %j, align 4
  %idxprom28 = sext i32 %27 to i64
  %arrayidx29 = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %idxprom28
  %id30 = getelementptr inbounds %struct.anon.15, ptr %arrayidx29, i32 0, i32 0
  store i64 %26, ptr %id30, align 16
  %28 = load ptr, ptr %mt9, align 8
  %29 = load i32, ptr %j, align 4
  %idxprom31 = sext i32 %29 to i64
  %arrayidx32 = getelementptr inbounds [3 x %struct.anon.15], ptr @moduleTypeLookupModuleByID.cache, i64 0, i64 %idxprom31
  %mt33 = getelementptr inbounds %struct.anon.15, ptr %arrayidx32, i32 0, i32 1
  store ptr %28, ptr %mt33, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then27, %land.lhs.true, %while.end24
  %30 = load ptr, ptr %mt9, align 8
  store ptr %30, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end34, %if.then
  %31 = load ptr, ptr %retval, align 8
  ret ptr %31
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleTypeNameByID(ptr noundef %name, i64 noundef %moduleid) #0 {
entry:
  %name.addr = alloca ptr, align 8
  %moduleid.addr = alloca i64, align 8
  %cset = alloca ptr, align 8
  %p = alloca ptr, align 8
  %j = alloca i32, align 4
  store ptr %name, ptr %name.addr, align 8
  store i64 %moduleid, ptr %moduleid.addr, align 8
  %0 = load ptr, ptr @ModuleTypeNameCharSet, align 8
  store ptr %0, ptr %cset, align 8
  %1 = load ptr, ptr %name.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %1, i64 9
  store i8 0, ptr %arrayidx, align 1
  %2 = load ptr, ptr %name.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 8
  store ptr %add.ptr, ptr %p, align 8
  %3 = load i64, ptr %moduleid.addr, align 8
  %shr = lshr i64 %3, 10
  store i64 %shr, ptr %moduleid.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %4, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %cset, align 8
  %6 = load i64, ptr %moduleid.addr, align 8
  %and = and i64 %6, 63
  %arrayidx1 = getelementptr inbounds i8, ptr %5, i64 %and
  %7 = load i8, ptr %arrayidx1, align 1
  %8 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %8, i32 -1
  store ptr %incdec.ptr, ptr %p, align 8
  store i8 %7, ptr %8, align 1
  %9 = load i64, ptr %moduleid.addr, align 8
  %shr2 = lshr i64 %9, 6
  store i64 %shr2, ptr %moduleid.addr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, ptr %j, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !39

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeModuleName(ptr noundef %mt) #0 {
entry:
  %retval = alloca ptr, align 8
  %mt.addr = alloca ptr, align 8
  store ptr %mt, ptr %mt.addr, align 8
  %0 = load ptr, ptr %mt.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %mt.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleType, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %mt.addr, align 8
  %module2 = getelementptr inbounds %struct.RedisModuleType, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %module2, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %name, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleNameFromCommand(ptr noundef %cmd) #0 {
entry:
  %cmd.addr = alloca ptr, align 8
  %cp = alloca ptr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %proc, align 8
  %cmp = icmp eq ptr %1, @RedisModuleCommandDispatcher
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.56, ptr noundef @.str.2, i32 noundef 6724)
  call void @abort() #13
  unreachable

2:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %2, %cond.true
  %3 = load ptr, ptr %cmd.addr, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 32
  %4 = load ptr, ptr %module_cmd, align 8
  store ptr %4, ptr %cp, align 8
  %5 = load ptr, ptr %cp, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommand, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %name, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleTypeDupOrReply(ptr noundef %c, ptr noundef %fromkey, ptr noundef %tokey, i32 noundef %todb, ptr noundef %value) #0 {
entry:
  %retval = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %fromkey.addr = alloca ptr, align 8
  %tokey.addr = alloca ptr, align 8
  %todb.addr = alloca i32, align 4
  %value.addr = alloca ptr, align 8
  %mv = alloca ptr, align 8
  %mt = alloca ptr, align 8
  %newval = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleKeyOptCtx, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %fromkey, ptr %fromkey.addr, align 8
  store ptr %tokey, ptr %tokey.addr, align 8
  store i32 %todb, ptr %todb.addr, align 4
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  store ptr %1, ptr %mv, align 8
  %2 = load ptr, ptr %mv, align 8
  %type = getelementptr inbounds %struct.moduleValue, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %type, align 8
  store ptr %3, ptr %mt, align 8
  %4 = load ptr, ptr %mt, align 8
  %copy = getelementptr inbounds %struct.RedisModuleType, ptr %4, i32 0, i32 10
  %5 = load ptr, ptr %copy, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %6 = load ptr, ptr %mt, align 8
  %copy2 = getelementptr inbounds %struct.RedisModuleType, ptr %6, i32 0, i32 17
  %7 = load ptr, ptr %copy2, align 8
  %tobool1 = icmp ne ptr %7, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %8, ptr noundef @.str.57)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store ptr null, ptr %newval, align 8
  %9 = load ptr, ptr %mt, align 8
  %copy22 = getelementptr inbounds %struct.RedisModuleType, ptr %9, i32 0, i32 17
  %10 = load ptr, ptr %copy22, align 8
  %cmp = icmp ne ptr %10, null
  br i1 %cmp, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %from_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 0
  %11 = load ptr, ptr %fromkey.addr, align 8
  store ptr %11, ptr %from_key, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 1
  %12 = load ptr, ptr %tokey.addr, align 8
  store ptr %12, ptr %to_key, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 2
  %13 = load ptr, ptr %c.addr, align 8
  %db = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %14, i32 0, i32 6
  %15 = load i32, ptr %id, align 8
  store i32 %15, ptr %from_dbid, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 3
  %16 = load i32, ptr %todb.addr, align 4
  store i32 %16, ptr %to_dbid, align 4
  %17 = load ptr, ptr %mt, align 8
  %copy24 = getelementptr inbounds %struct.RedisModuleType, ptr %17, i32 0, i32 17
  %18 = load ptr, ptr %copy24, align 8
  %19 = load ptr, ptr %mv, align 8
  %value5 = getelementptr inbounds %struct.moduleValue, ptr %19, i32 0, i32 1
  %20 = load ptr, ptr %value5, align 8
  %call = call ptr %18(ptr noundef %ctx, ptr noundef %20)
  store ptr %call, ptr %newval, align 8
  br label %if.end9

if.else:                                          ; preds = %if.end
  %21 = load ptr, ptr %mt, align 8
  %copy6 = getelementptr inbounds %struct.RedisModuleType, ptr %21, i32 0, i32 10
  %22 = load ptr, ptr %copy6, align 8
  %23 = load ptr, ptr %fromkey.addr, align 8
  %24 = load ptr, ptr %tokey.addr, align 8
  %25 = load ptr, ptr %mv, align 8
  %value7 = getelementptr inbounds %struct.moduleValue, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %value7, align 8
  %call8 = call ptr %22(ptr noundef %23, ptr noundef %24, ptr noundef %26)
  store ptr %call8, ptr %newval, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then3
  %27 = load ptr, ptr %newval, align 8
  %tobool10 = icmp ne ptr %27, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end9
  %28 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %28, ptr noundef @.str.58)
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end9
  %29 = load ptr, ptr %mt, align 8
  %30 = load ptr, ptr %newval, align 8
  %call13 = call ptr @createModuleObject(ptr noundef %29, ptr noundef %30)
  store ptr %call13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then
  %31 = load ptr, ptr %retval, align 8
  ret ptr %31
}

declare void @addReplyError(ptr noundef, ptr noundef) #1

declare ptr @createModuleObject(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateDataType(ptr noundef %ctx, ptr noundef %name, i32 noundef %encver, ptr noundef %typemethods_ptr) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %encver.addr = alloca i32, align 4
  %typemethods_ptr.addr = alloca ptr, align 8
  %id = alloca i64, align 8
  %typemethods_version = alloca i64, align 8
  %tms = alloca ptr, align 8
  %mt = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %encver, ptr %encver.addr, align 4
  store ptr %typemethods_ptr, ptr %typemethods_ptr.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %1, i32 0, i32 18
  %2 = load i32, ptr %onload, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %name.addr, align 8
  %4 = load i32, ptr %encver.addr, align 4
  %call = call i64 @moduleTypeEncodeId(ptr noundef %3, i32 noundef %4)
  store i64 %call, ptr %id, align 8
  %5 = load i64, ptr %id, align 8
  %cmp = icmp eq i64 %5, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %6 = load ptr, ptr %name.addr, align 8
  %call3 = call ptr @moduleTypeLookupModuleByName(ptr noundef %6)
  %cmp4 = icmp ne ptr %call3, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end2
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end2
  %7 = load ptr, ptr %typemethods_ptr.addr, align 8
  %arrayidx = getelementptr inbounds i64, ptr %7, i64 0
  %8 = load i64, ptr %arrayidx, align 8
  store i64 %8, ptr %typemethods_version, align 8
  %9 = load i64, ptr %typemethods_version, align 8
  %cmp7 = icmp eq i64 %9, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  store ptr null, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end6
  %10 = load ptr, ptr %typemethods_ptr.addr, align 8
  store ptr %10, ptr %tms, align 8
  %call10 = call noalias ptr @zcalloc(i64 noundef 168) #11
  store ptr %call10, ptr %mt, align 8
  %11 = load i64, ptr %id, align 8
  %12 = load ptr, ptr %mt, align 8
  %id11 = getelementptr inbounds %struct.RedisModuleType, ptr %12, i32 0, i32 0
  store i64 %11, ptr %id11, align 8
  %13 = load ptr, ptr %ctx.addr, align 8
  %module12 = getelementptr inbounds %struct.RedisModuleCtx, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %module12, align 8
  %15 = load ptr, ptr %mt, align 8
  %module13 = getelementptr inbounds %struct.RedisModuleType, ptr %15, i32 0, i32 1
  store ptr %14, ptr %module13, align 8
  %16 = load ptr, ptr %tms, align 8
  %rdb_load = getelementptr inbounds %struct.typemethods, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %rdb_load, align 8
  %18 = load ptr, ptr %mt, align 8
  %rdb_load14 = getelementptr inbounds %struct.RedisModuleType, ptr %18, i32 0, i32 2
  store ptr %17, ptr %rdb_load14, align 8
  %19 = load ptr, ptr %tms, align 8
  %rdb_save = getelementptr inbounds %struct.typemethods, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %rdb_save, align 8
  %21 = load ptr, ptr %mt, align 8
  %rdb_save15 = getelementptr inbounds %struct.RedisModuleType, ptr %21, i32 0, i32 3
  store ptr %20, ptr %rdb_save15, align 8
  %22 = load ptr, ptr %tms, align 8
  %aof_rewrite = getelementptr inbounds %struct.typemethods, ptr %22, i32 0, i32 3
  %23 = load ptr, ptr %aof_rewrite, align 8
  %24 = load ptr, ptr %mt, align 8
  %aof_rewrite16 = getelementptr inbounds %struct.RedisModuleType, ptr %24, i32 0, i32 4
  store ptr %23, ptr %aof_rewrite16, align 8
  %25 = load ptr, ptr %tms, align 8
  %mem_usage = getelementptr inbounds %struct.typemethods, ptr %25, i32 0, i32 4
  %26 = load ptr, ptr %mem_usage, align 8
  %27 = load ptr, ptr %mt, align 8
  %mem_usage17 = getelementptr inbounds %struct.RedisModuleType, ptr %27, i32 0, i32 5
  store ptr %26, ptr %mem_usage17, align 8
  %28 = load ptr, ptr %tms, align 8
  %digest = getelementptr inbounds %struct.typemethods, ptr %28, i32 0, i32 5
  %29 = load ptr, ptr %digest, align 8
  %30 = load ptr, ptr %mt, align 8
  %digest18 = getelementptr inbounds %struct.RedisModuleType, ptr %30, i32 0, i32 6
  store ptr %29, ptr %digest18, align 8
  %31 = load ptr, ptr %tms, align 8
  %free = getelementptr inbounds %struct.typemethods, ptr %31, i32 0, i32 6
  %32 = load ptr, ptr %free, align 8
  %33 = load ptr, ptr %mt, align 8
  %free19 = getelementptr inbounds %struct.RedisModuleType, ptr %33, i32 0, i32 7
  store ptr %32, ptr %free19, align 8
  %34 = load ptr, ptr %tms, align 8
  %version = getelementptr inbounds %struct.typemethods, ptr %34, i32 0, i32 0
  %35 = load i64, ptr %version, align 8
  %cmp20 = icmp uge i64 %35, 2
  br i1 %cmp20, label %if.then21, label %if.end27

if.then21:                                        ; preds = %if.end9
  %36 = load ptr, ptr %tms, align 8
  %v2 = getelementptr inbounds %struct.typemethods, ptr %36, i32 0, i32 7
  %aux_load = getelementptr inbounds %struct.anon.16, ptr %v2, i32 0, i32 0
  %37 = load ptr, ptr %aux_load, align 8
  %38 = load ptr, ptr %mt, align 8
  %aux_load22 = getelementptr inbounds %struct.RedisModuleType, ptr %38, i32 0, i32 12
  store ptr %37, ptr %aux_load22, align 8
  %39 = load ptr, ptr %tms, align 8
  %v223 = getelementptr inbounds %struct.typemethods, ptr %39, i32 0, i32 7
  %aux_save = getelementptr inbounds %struct.anon.16, ptr %v223, i32 0, i32 1
  %40 = load ptr, ptr %aux_save, align 8
  %41 = load ptr, ptr %mt, align 8
  %aux_save24 = getelementptr inbounds %struct.RedisModuleType, ptr %41, i32 0, i32 13
  store ptr %40, ptr %aux_save24, align 8
  %42 = load ptr, ptr %tms, align 8
  %v225 = getelementptr inbounds %struct.typemethods, ptr %42, i32 0, i32 7
  %aux_save_triggers = getelementptr inbounds %struct.anon.16, ptr %v225, i32 0, i32 2
  %43 = load i32, ptr %aux_save_triggers, align 8
  %44 = load ptr, ptr %mt, align 8
  %aux_save_triggers26 = getelementptr inbounds %struct.RedisModuleType, ptr %44, i32 0, i32 19
  store i32 %43, ptr %aux_save_triggers26, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then21, %if.end9
  %45 = load ptr, ptr %tms, align 8
  %version28 = getelementptr inbounds %struct.typemethods, ptr %45, i32 0, i32 0
  %46 = load i64, ptr %version28, align 8
  %cmp29 = icmp uge i64 %46, 3
  br i1 %cmp29, label %if.then30, label %if.end38

if.then30:                                        ; preds = %if.end27
  %47 = load ptr, ptr %tms, align 8
  %v3 = getelementptr inbounds %struct.typemethods, ptr %47, i32 0, i32 8
  %free_effort = getelementptr inbounds %struct.anon.17, ptr %v3, i32 0, i32 0
  %48 = load ptr, ptr %free_effort, align 8
  %49 = load ptr, ptr %mt, align 8
  %free_effort31 = getelementptr inbounds %struct.RedisModuleType, ptr %49, i32 0, i32 8
  store ptr %48, ptr %free_effort31, align 8
  %50 = load ptr, ptr %tms, align 8
  %v332 = getelementptr inbounds %struct.typemethods, ptr %50, i32 0, i32 8
  %unlink = getelementptr inbounds %struct.anon.17, ptr %v332, i32 0, i32 1
  %51 = load ptr, ptr %unlink, align 8
  %52 = load ptr, ptr %mt, align 8
  %unlink33 = getelementptr inbounds %struct.RedisModuleType, ptr %52, i32 0, i32 9
  store ptr %51, ptr %unlink33, align 8
  %53 = load ptr, ptr %tms, align 8
  %v334 = getelementptr inbounds %struct.typemethods, ptr %53, i32 0, i32 8
  %copy = getelementptr inbounds %struct.anon.17, ptr %v334, i32 0, i32 2
  %54 = load ptr, ptr %copy, align 8
  %55 = load ptr, ptr %mt, align 8
  %copy35 = getelementptr inbounds %struct.RedisModuleType, ptr %55, i32 0, i32 10
  store ptr %54, ptr %copy35, align 8
  %56 = load ptr, ptr %tms, align 8
  %v336 = getelementptr inbounds %struct.typemethods, ptr %56, i32 0, i32 8
  %defrag = getelementptr inbounds %struct.anon.17, ptr %v336, i32 0, i32 3
  %57 = load ptr, ptr %defrag, align 8
  %58 = load ptr, ptr %mt, align 8
  %defrag37 = getelementptr inbounds %struct.RedisModuleType, ptr %58, i32 0, i32 11
  store ptr %57, ptr %defrag37, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.then30, %if.end27
  %59 = load ptr, ptr %tms, align 8
  %version39 = getelementptr inbounds %struct.typemethods, ptr %59, i32 0, i32 0
  %60 = load i64, ptr %version39, align 8
  %cmp40 = icmp uge i64 %60, 4
  br i1 %cmp40, label %if.then41, label %if.end49

if.then41:                                        ; preds = %if.end38
  %61 = load ptr, ptr %tms, align 8
  %v4 = getelementptr inbounds %struct.typemethods, ptr %61, i32 0, i32 9
  %mem_usage2 = getelementptr inbounds %struct.anon.18, ptr %v4, i32 0, i32 0
  %62 = load ptr, ptr %mem_usage2, align 8
  %63 = load ptr, ptr %mt, align 8
  %mem_usage242 = getelementptr inbounds %struct.RedisModuleType, ptr %63, i32 0, i32 14
  store ptr %62, ptr %mem_usage242, align 8
  %64 = load ptr, ptr %tms, align 8
  %v443 = getelementptr inbounds %struct.typemethods, ptr %64, i32 0, i32 9
  %unlink2 = getelementptr inbounds %struct.anon.18, ptr %v443, i32 0, i32 2
  %65 = load ptr, ptr %unlink2, align 8
  %66 = load ptr, ptr %mt, align 8
  %unlink244 = getelementptr inbounds %struct.RedisModuleType, ptr %66, i32 0, i32 16
  store ptr %65, ptr %unlink244, align 8
  %67 = load ptr, ptr %tms, align 8
  %v445 = getelementptr inbounds %struct.typemethods, ptr %67, i32 0, i32 9
  %free_effort2 = getelementptr inbounds %struct.anon.18, ptr %v445, i32 0, i32 1
  %68 = load ptr, ptr %free_effort2, align 8
  %69 = load ptr, ptr %mt, align 8
  %free_effort246 = getelementptr inbounds %struct.RedisModuleType, ptr %69, i32 0, i32 15
  store ptr %68, ptr %free_effort246, align 8
  %70 = load ptr, ptr %tms, align 8
  %v447 = getelementptr inbounds %struct.typemethods, ptr %70, i32 0, i32 9
  %copy2 = getelementptr inbounds %struct.anon.18, ptr %v447, i32 0, i32 3
  %71 = load ptr, ptr %copy2, align 8
  %72 = load ptr, ptr %mt, align 8
  %copy248 = getelementptr inbounds %struct.RedisModuleType, ptr %72, i32 0, i32 17
  store ptr %71, ptr %copy248, align 8
  br label %if.end49

if.end49:                                         ; preds = %if.then41, %if.end38
  %73 = load ptr, ptr %tms, align 8
  %version50 = getelementptr inbounds %struct.typemethods, ptr %73, i32 0, i32 0
  %74 = load i64, ptr %version50, align 8
  %cmp51 = icmp uge i64 %74, 5
  br i1 %cmp51, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.end49
  %75 = load ptr, ptr %tms, align 8
  %v5 = getelementptr inbounds %struct.typemethods, ptr %75, i32 0, i32 10
  %aux_save2 = getelementptr inbounds %struct.anon.19, ptr %v5, i32 0, i32 0
  %76 = load ptr, ptr %aux_save2, align 8
  %77 = load ptr, ptr %mt, align 8
  %aux_save253 = getelementptr inbounds %struct.RedisModuleType, ptr %77, i32 0, i32 18
  store ptr %76, ptr %aux_save253, align 8
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.end49
  %78 = load ptr, ptr %mt, align 8
  %name55 = getelementptr inbounds %struct.RedisModuleType, ptr %78, i32 0, i32 20
  %arraydecay = getelementptr inbounds [10 x i8], ptr %name55, i64 0, i64 0
  %79 = load ptr, ptr %name.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arraydecay, ptr align 1 %79, i64 10, i1 false)
  %80 = load ptr, ptr %ctx.addr, align 8
  %module56 = getelementptr inbounds %struct.RedisModuleCtx, ptr %80, i32 0, i32 1
  %81 = load ptr, ptr %module56, align 8
  %types = getelementptr inbounds %struct.RedisModule, ptr %81, i32 0, i32 4
  %82 = load ptr, ptr %types, align 8
  %83 = load ptr, ptr %mt, align 8
  %call57 = call ptr @listAddNodeTail(ptr noundef %82, ptr noundef %83)
  %84 = load ptr, ptr %mt, align 8
  store ptr %84, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end54, %if.then8, %if.then5, %if.then1, %if.then
  %85 = load ptr, ptr %retval, align 8
  ret ptr %85
}

declare ptr @listAddNodeTail(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ModuleTypeSetValue(ptr noundef %key, ptr noundef %mt, ptr noundef %value) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %mt.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %o = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %mt, ptr %mt.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %iter, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %call = call i32 @RM_DeleteKey(ptr noundef %4)
  %5 = load ptr, ptr %mt.addr, align 8
  %6 = load ptr, ptr %value.addr, align 8
  %call2 = call ptr @createModuleObject(ptr noundef %5, ptr noundef %6)
  store ptr %call2, ptr %o, align 8
  %7 = load ptr, ptr %key.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleKey, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %ctx, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %client, align 8
  %10 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %db, align 8
  %12 = load ptr, ptr %key.addr, align 8
  %key3 = getelementptr inbounds %struct.RedisModuleKey, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %key3, align 8
  %14 = load ptr, ptr %o, align 8
  call void @setKey(ptr noundef %9, ptr noundef %11, ptr noundef %13, ptr noundef %14, i32 noundef 2)
  %15 = load ptr, ptr %o, align 8
  call void @decrRefCount(ptr noundef %15)
  %16 = load ptr, ptr %o, align 8
  %17 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %17, i32 0, i32 3
  store ptr %16, ptr %value4, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ModuleTypeGetType(ptr noundef %key) #0 {
entry:
  %retval = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %mv = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %key.addr, align 8
  %call = call i32 @RM_KeyType(ptr noundef %3)
  %cmp3 = icmp ne i32 %call, 6
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %4 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value4, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ptr, align 8
  store ptr %6, ptr %mv, align 8
  %7 = load ptr, ptr %mv, align 8
  %type = getelementptr inbounds %struct.moduleValue, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %type, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ModuleTypeGetValue(ptr noundef %key) #0 {
entry:
  %retval = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %mv = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %key.addr, align 8
  %call = call i32 @RM_KeyType(ptr noundef %3)
  %cmp3 = icmp ne i32 %call, 6
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %4 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value4, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ptr, align 8
  store ptr %6, ptr %mv, align 8
  %7 = load ptr, ptr %mv, align 8
  %value5 = getelementptr inbounds %struct.moduleValue, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %value5, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleRDBLoadError(ptr noundef %io) #0 {
entry:
  %io.addr = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %type, align 8
  %module = getelementptr inbounds %struct.RedisModuleType, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %options = getelementptr inbounds %struct.RedisModule, ptr %2, i32 0, i32 12
  %3 = load i32, ptr %options, align 4
  %and = and i32 %3, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %4, i32 0, i32 3
  store i32 1, ptr %error, align 8
  ret void

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %io.addr, align 8
  %type1 = getelementptr inbounds %struct.RedisModuleIO, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %type1, align 8
  %module2 = getelementptr inbounds %struct.RedisModuleType, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %module2, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %name, align 8
  %9 = load ptr, ptr %io.addr, align 8
  %type3 = getelementptr inbounds %struct.RedisModuleIO, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %type3, align 8
  %name4 = getelementptr inbounds %struct.RedisModuleType, ptr %10, i32 0, i32 20
  %arraydecay = getelementptr inbounds [10 x i8], ptr %name4, i64 0, i64 0
  %11 = load ptr, ptr %io.addr, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %11, i32 0, i32 0
  %12 = load i64, ptr %bytes, align 8
  %13 = load ptr, ptr %io.addr, align 8
  %key = getelementptr inbounds %struct.RedisModuleIO, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %key, align 8
  %tobool5 = icmp ne ptr %14, null
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %15 = load ptr, ptr %io.addr, align 8
  %key6 = getelementptr inbounds %struct.RedisModuleIO, ptr %15, i32 0, i32 5
  %16 = load ptr, ptr %key6, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %ptr, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %17, %cond.true ], [ @.str.60, %cond.false ]
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.2, i32 noundef 7011, ptr noundef @.str.59, ptr noundef %8, ptr noundef %arraydecay, i64 noundef %12, ptr noundef %cond)
  call void @abort() #13
  unreachable
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleAllDatatypesHandleErrors() #0 {
entry:
  %retval = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %module = alloca ptr, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %module, align 8
  %3 = load ptr, ptr %module, align 8
  %types = getelementptr inbounds %struct.RedisModule, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %types, align 8
  %len = getelementptr inbounds %struct.list, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %len, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %6 = load ptr, ptr %module, align 8
  %options = getelementptr inbounds %struct.RedisModule, ptr %6, i32 0, i32 12
  %7 = load i32, ptr %options, align 4
  %and = and i32 %7, 1
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %8)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %while.body
  br label %while.cond, !llvm.loop !40

while.end:                                        ; preds = %while.cond
  %9 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %9)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleAllModulesHandleReplAsyncLoad() #0 {
entry:
  %retval = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %module = alloca ptr, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %module, align 8
  %3 = load ptr, ptr %module, align 8
  %options = getelementptr inbounds %struct.RedisModule, ptr %3, i32 0, i32 12
  %4 = load i32, ptr %options, align 4
  %and = and i32 %4, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %5 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %5)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %while.body
  br label %while.cond, !llvm.loop !41

while.end:                                        ; preds = %while.cond
  %6 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %6)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_IsIOError(ptr noundef %io) #0 {
entry:
  %io.addr = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveUnsigned(ptr noundef %io, i64 noundef %value) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  %retval = alloca i32, align 4
  store ptr %io, ptr %io.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %call = call i32 @flushRedisModuleIOBuffer(ptr noundef %2)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %saveerr

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %rio, align 8
  %call3 = call i32 @rdbSaveLen(ptr noundef %4, i64 noundef 2)
  store i32 %call3, ptr %retval, align 4
  %5 = load i32, ptr %retval, align 4
  %cmp4 = icmp eq i32 %5, -1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end2
  br label %saveerr

if.end6:                                          ; preds = %if.end2
  %6 = load i32, ptr %retval, align 4
  %conv = sext i32 %6 to i64
  %7 = load ptr, ptr %io.addr, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %bytes, align 8
  %add = add i64 %8, %conv
  store i64 %add, ptr %bytes, align 8
  %9 = load ptr, ptr %io.addr, align 8
  %rio7 = getelementptr inbounds %struct.RedisModuleIO, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %rio7, align 8
  %11 = load i64, ptr %value.addr, align 8
  %call8 = call i32 @rdbSaveLen(ptr noundef %10, i64 noundef %11)
  store i32 %call8, ptr %retval, align 4
  %12 = load i32, ptr %retval, align 4
  %cmp9 = icmp eq i32 %12, -1
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end6
  br label %saveerr

if.end12:                                         ; preds = %if.end6
  %13 = load i32, ptr %retval, align 4
  %conv13 = sext i32 %13 to i64
  %14 = load ptr, ptr %io.addr, align 8
  %bytes14 = getelementptr inbounds %struct.RedisModuleIO, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %bytes14, align 8
  %add15 = add i64 %15, %conv13
  store i64 %add15, ptr %bytes14, align 8
  br label %return

saveerr:                                          ; preds = %if.then11, %if.then5, %if.then1
  %16 = load ptr, ptr %io.addr, align 8
  %error16 = getelementptr inbounds %struct.RedisModuleIO, ptr %16, i32 0, i32 3
  store i32 1, ptr %error16, align 8
  br label %return

return:                                           ; preds = %saveerr, %if.end12, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @flushRedisModuleIOBuffer(ptr noundef %io) #0 {
entry:
  %retval = alloca i32, align 4
  %io.addr = alloca ptr, align 8
  %pre_flush_buffer1 = alloca ptr, align 8
  %retval4 = alloca i64, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %pre_flush_buffer = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 7
  %1 = load ptr, ptr %pre_flush_buffer, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %pre_flush_buffer2 = getelementptr inbounds %struct.RedisModuleIO, ptr %2, i32 0, i32 7
  %3 = load ptr, ptr %pre_flush_buffer2, align 8
  store ptr %3, ptr %pre_flush_buffer1, align 8
  %4 = load ptr, ptr %io.addr, align 8
  %pre_flush_buffer3 = getelementptr inbounds %struct.RedisModuleIO, ptr %4, i32 0, i32 7
  store ptr null, ptr %pre_flush_buffer3, align 8
  %5 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %rio, align 8
  %7 = load ptr, ptr %pre_flush_buffer1, align 8
  %8 = load ptr, ptr %pre_flush_buffer1, align 8
  %call = call i64 @sdslen(ptr noundef %8)
  %call5 = call i64 @rdbWriteRaw(ptr noundef %6, ptr noundef %7, i64 noundef %call)
  store i64 %call5, ptr %retval4, align 8
  %9 = load ptr, ptr %pre_flush_buffer1, align 8
  call void @sdsfree(ptr noundef %9)
  %10 = load i64, ptr %retval4, align 8
  %cmp = icmp sge i64 %10, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %11 = load i64, ptr %retval4, align 8
  %12 = load ptr, ptr %io.addr, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %12, i32 0, i32 0
  %13 = load i64, ptr %bytes, align 8
  %add = add i64 %13, %11
  store i64 %add, ptr %bytes, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %14 = load i64, ptr %retval4, align 8
  %conv = trunc i64 %14 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

declare i32 @rdbSaveLen(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_LoadUnsigned(ptr noundef %io) #0 {
entry:
  %retval = alloca i64, align 8
  %io.addr = alloca ptr, align 8
  %opcode = alloca i64, align 8
  %value = alloca i64, align 8
  %retval3 = alloca i32, align 4
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %rio, align 8
  %call = call i64 @rdbLoadLen(ptr noundef %3, ptr noundef null)
  store i64 %call, ptr %opcode, align 8
  %4 = load i64, ptr %opcode, align 8
  %cmp = icmp ne i64 %4, 2
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %loaderr

if.end2:                                          ; preds = %if.end
  %5 = load ptr, ptr %io.addr, align 8
  %rio4 = getelementptr inbounds %struct.RedisModuleIO, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %rio4, align 8
  %call5 = call i32 @rdbLoadLenByRef(ptr noundef %6, ptr noundef null, ptr noundef %value)
  store i32 %call5, ptr %retval3, align 4
  %7 = load i32, ptr %retval3, align 4
  %cmp6 = icmp eq i32 %7, -1
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end2
  br label %loaderr

if.end8:                                          ; preds = %if.end2
  %8 = load i64, ptr %value, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

loaderr:                                          ; preds = %if.then7, %if.then1
  %9 = load ptr, ptr %io.addr, align 8
  call void @moduleRDBLoadError(ptr noundef %9)
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %loaderr, %if.end8, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

declare i64 @rdbLoadLen(ptr noundef, ptr noundef) #1

declare i32 @rdbLoadLenByRef(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveSigned(ptr noundef %io, i64 noundef %value) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  %conv = alloca %union.anon.20, align 8
  store ptr %io, ptr %io.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %0 = load i64, ptr %value.addr, align 8
  store i64 %0, ptr %conv, align 8
  %1 = load ptr, ptr %io.addr, align 8
  %2 = load i64, ptr %conv, align 8
  call void @RM_SaveUnsigned(ptr noundef %1, i64 noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_LoadSigned(ptr noundef %io) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %conv = alloca %union.anon.21, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %call = call i64 @RM_LoadUnsigned(ptr noundef %0)
  store i64 %call, ptr %conv, align 8
  %1 = load i64, ptr %conv, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveString(ptr noundef %io, ptr noundef %s) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %retval = alloca i64, align 8
  store ptr %io, ptr %io.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %call = call i32 @flushRedisModuleIOBuffer(ptr noundef %2)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %saveerr

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %rio, align 8
  %call3 = call i32 @rdbSaveLen(ptr noundef %4, i64 noundef 5)
  %conv = sext i32 %call3 to i64
  store i64 %conv, ptr %retval, align 8
  %5 = load i64, ptr %retval, align 8
  %cmp4 = icmp eq i64 %5, -1
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end2
  br label %saveerr

if.end7:                                          ; preds = %if.end2
  %6 = load i64, ptr %retval, align 8
  %7 = load ptr, ptr %io.addr, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %bytes, align 8
  %add = add i64 %8, %6
  store i64 %add, ptr %bytes, align 8
  %9 = load ptr, ptr %io.addr, align 8
  %rio8 = getelementptr inbounds %struct.RedisModuleIO, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %rio8, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %call9 = call i64 @rdbSaveStringObject(ptr noundef %10, ptr noundef %11)
  store i64 %call9, ptr %retval, align 8
  %12 = load i64, ptr %retval, align 8
  %cmp10 = icmp eq i64 %12, -1
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  br label %saveerr

if.end13:                                         ; preds = %if.end7
  %13 = load i64, ptr %retval, align 8
  %14 = load ptr, ptr %io.addr, align 8
  %bytes14 = getelementptr inbounds %struct.RedisModuleIO, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %bytes14, align 8
  %add15 = add i64 %15, %13
  store i64 %add15, ptr %bytes14, align 8
  br label %return

saveerr:                                          ; preds = %if.then12, %if.then6, %if.then1
  %16 = load ptr, ptr %io.addr, align 8
  %error16 = getelementptr inbounds %struct.RedisModuleIO, ptr %16, i32 0, i32 3
  store i32 1, ptr %error16, align 8
  br label %return

return:                                           ; preds = %saveerr, %if.end13, %if.then
  ret void
}

declare i64 @rdbSaveStringObject(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveStringBuffer(ptr noundef %io, ptr noundef %str, i64 noundef %len) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %retval = alloca i64, align 8
  store ptr %io, ptr %io.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %call = call i32 @flushRedisModuleIOBuffer(ptr noundef %2)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %saveerr

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %rio, align 8
  %call3 = call i32 @rdbSaveLen(ptr noundef %4, i64 noundef 5)
  %conv = sext i32 %call3 to i64
  store i64 %conv, ptr %retval, align 8
  %5 = load i64, ptr %retval, align 8
  %cmp4 = icmp eq i64 %5, -1
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end2
  br label %saveerr

if.end7:                                          ; preds = %if.end2
  %6 = load i64, ptr %retval, align 8
  %7 = load ptr, ptr %io.addr, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %bytes, align 8
  %add = add i64 %8, %6
  store i64 %add, ptr %bytes, align 8
  %9 = load ptr, ptr %io.addr, align 8
  %rio8 = getelementptr inbounds %struct.RedisModuleIO, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %rio8, align 8
  %11 = load ptr, ptr %str.addr, align 8
  %12 = load i64, ptr %len.addr, align 8
  %call9 = call i64 @rdbSaveRawString(ptr noundef %10, ptr noundef %11, i64 noundef %12)
  store i64 %call9, ptr %retval, align 8
  %13 = load i64, ptr %retval, align 8
  %cmp10 = icmp eq i64 %13, -1
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  br label %saveerr

if.end13:                                         ; preds = %if.end7
  %14 = load i64, ptr %retval, align 8
  %15 = load ptr, ptr %io.addr, align 8
  %bytes14 = getelementptr inbounds %struct.RedisModuleIO, ptr %15, i32 0, i32 0
  %16 = load i64, ptr %bytes14, align 8
  %add15 = add i64 %16, %14
  store i64 %add15, ptr %bytes14, align 8
  br label %return

saveerr:                                          ; preds = %if.then12, %if.then6, %if.then1
  %17 = load ptr, ptr %io.addr, align 8
  %error16 = getelementptr inbounds %struct.RedisModuleIO, ptr %17, i32 0, i32 3
  store i32 1, ptr %error16, align 8
  br label %return

return:                                           ; preds = %saveerr, %if.end13, %if.then
  ret void
}

declare i64 @rdbSaveRawString(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleLoadString(ptr noundef %io, i32 noundef %plain, ptr noundef %lenptr) #0 {
entry:
  %retval = alloca ptr, align 8
  %io.addr = alloca ptr, align 8
  %plain.addr = alloca i32, align 4
  %lenptr.addr = alloca ptr, align 8
  %opcode = alloca i64, align 8
  %s = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  store i32 %plain, ptr %plain.addr, align 4
  store ptr %lenptr, ptr %lenptr.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %rio, align 8
  %call = call i64 @rdbLoadLen(ptr noundef %3, ptr noundef null)
  store i64 %call, ptr %opcode, align 8
  %4 = load i64, ptr %opcode, align 8
  %cmp = icmp ne i64 %4, 5
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %loaderr

if.end2:                                          ; preds = %if.end
  %5 = load ptr, ptr %io.addr, align 8
  %rio3 = getelementptr inbounds %struct.RedisModuleIO, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %rio3, align 8
  %7 = load i32, ptr %plain.addr, align 4
  %tobool4 = icmp ne i32 %7, 0
  %cond = select i1 %tobool4, i32 2, i32 0
  %8 = load ptr, ptr %lenptr.addr, align 8
  %call5 = call ptr @rdbGenericLoadStringObject(ptr noundef %6, i32 noundef %cond, ptr noundef %8)
  store ptr %call5, ptr %s, align 8
  %9 = load ptr, ptr %s, align 8
  %cmp6 = icmp eq ptr %9, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end2
  br label %loaderr

if.end8:                                          ; preds = %if.end2
  %10 = load ptr, ptr %s, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

loaderr:                                          ; preds = %if.then7, %if.then1
  %11 = load ptr, ptr %io.addr, align 8
  call void @moduleRDBLoadError(ptr noundef %11)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %loaderr, %if.end8, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

declare ptr @rdbGenericLoadStringObject(ptr noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_LoadString(ptr noundef %io) #0 {
entry:
  %io.addr = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %call = call ptr @moduleLoadString(ptr noundef %0, i32 noundef 0, ptr noundef null)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_LoadStringBuffer(ptr noundef %io, ptr noundef %lenptr) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %lenptr.addr = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  store ptr %lenptr, ptr %lenptr.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %1 = load ptr, ptr %lenptr.addr, align 8
  %call = call ptr @moduleLoadString(ptr noundef %0, i32 noundef 1, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveDouble(ptr noundef %io, double noundef %value) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %value.addr = alloca double, align 8
  %retval = alloca i32, align 4
  store ptr %io, ptr %io.addr, align 8
  store double %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %call = call i32 @flushRedisModuleIOBuffer(ptr noundef %2)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %saveerr

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %rio, align 8
  %call3 = call i32 @rdbSaveLen(ptr noundef %4, i64 noundef 4)
  store i32 %call3, ptr %retval, align 4
  %5 = load i32, ptr %retval, align 4
  %cmp4 = icmp eq i32 %5, -1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end2
  br label %saveerr

if.end6:                                          ; preds = %if.end2
  %6 = load i32, ptr %retval, align 4
  %conv = sext i32 %6 to i64
  %7 = load ptr, ptr %io.addr, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %bytes, align 8
  %add = add i64 %8, %conv
  store i64 %add, ptr %bytes, align 8
  %9 = load ptr, ptr %io.addr, align 8
  %rio7 = getelementptr inbounds %struct.RedisModuleIO, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %rio7, align 8
  %11 = load double, ptr %value.addr, align 8
  %call8 = call i32 @rdbSaveBinaryDoubleValue(ptr noundef %10, double noundef %11)
  store i32 %call8, ptr %retval, align 4
  %12 = load i32, ptr %retval, align 4
  %cmp9 = icmp eq i32 %12, -1
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end6
  br label %saveerr

if.end12:                                         ; preds = %if.end6
  %13 = load i32, ptr %retval, align 4
  %conv13 = sext i32 %13 to i64
  %14 = load ptr, ptr %io.addr, align 8
  %bytes14 = getelementptr inbounds %struct.RedisModuleIO, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %bytes14, align 8
  %add15 = add i64 %15, %conv13
  store i64 %add15, ptr %bytes14, align 8
  br label %return

saveerr:                                          ; preds = %if.then11, %if.then5, %if.then1
  %16 = load ptr, ptr %io.addr, align 8
  %error16 = getelementptr inbounds %struct.RedisModuleIO, ptr %16, i32 0, i32 3
  store i32 1, ptr %error16, align 8
  br label %return

return:                                           ; preds = %saveerr, %if.end12, %if.then
  ret void
}

declare i32 @rdbSaveBinaryDoubleValue(ptr noundef, double noundef) #1

; Function Attrs: nounwind uwtable
define dso_local double @RM_LoadDouble(ptr noundef %io) #0 {
entry:
  %retval = alloca double, align 8
  %io.addr = alloca ptr, align 8
  %opcode = alloca i64, align 8
  %value = alloca double, align 8
  %retval3 = alloca i32, align 4
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store double 0.000000e+00, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %rio, align 8
  %call = call i64 @rdbLoadLen(ptr noundef %3, ptr noundef null)
  store i64 %call, ptr %opcode, align 8
  %4 = load i64, ptr %opcode, align 8
  %cmp = icmp ne i64 %4, 4
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %loaderr

if.end2:                                          ; preds = %if.end
  %5 = load ptr, ptr %io.addr, align 8
  %rio4 = getelementptr inbounds %struct.RedisModuleIO, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %rio4, align 8
  %call5 = call i32 @rdbLoadBinaryDoubleValue(ptr noundef %6, ptr noundef %value)
  store i32 %call5, ptr %retval3, align 4
  %7 = load i32, ptr %retval3, align 4
  %cmp6 = icmp eq i32 %7, -1
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end2
  br label %loaderr

if.end8:                                          ; preds = %if.end2
  %8 = load double, ptr %value, align 8
  store double %8, ptr %retval, align 8
  br label %return

loaderr:                                          ; preds = %if.then7, %if.then1
  %9 = load ptr, ptr %io.addr, align 8
  call void @moduleRDBLoadError(ptr noundef %9)
  store double 0.000000e+00, ptr %retval, align 8
  br label %return

return:                                           ; preds = %loaderr, %if.end8, %if.then
  %10 = load double, ptr %retval, align 8
  ret double %10
}

declare i32 @rdbLoadBinaryDoubleValue(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveFloat(ptr noundef %io, float noundef %value) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %value.addr = alloca float, align 4
  %retval = alloca i32, align 4
  store ptr %io, ptr %io.addr, align 8
  store float %value, ptr %value.addr, align 4
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %call = call i32 @flushRedisModuleIOBuffer(ptr noundef %2)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %saveerr

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %rio, align 8
  %call3 = call i32 @rdbSaveLen(ptr noundef %4, i64 noundef 3)
  store i32 %call3, ptr %retval, align 4
  %5 = load i32, ptr %retval, align 4
  %cmp4 = icmp eq i32 %5, -1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end2
  br label %saveerr

if.end6:                                          ; preds = %if.end2
  %6 = load i32, ptr %retval, align 4
  %conv = sext i32 %6 to i64
  %7 = load ptr, ptr %io.addr, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %bytes, align 8
  %add = add i64 %8, %conv
  store i64 %add, ptr %bytes, align 8
  %9 = load ptr, ptr %io.addr, align 8
  %rio7 = getelementptr inbounds %struct.RedisModuleIO, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %rio7, align 8
  %11 = load float, ptr %value.addr, align 4
  %call8 = call i32 @rdbSaveBinaryFloatValue(ptr noundef %10, float noundef %11)
  store i32 %call8, ptr %retval, align 4
  %12 = load i32, ptr %retval, align 4
  %cmp9 = icmp eq i32 %12, -1
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end6
  br label %saveerr

if.end12:                                         ; preds = %if.end6
  %13 = load i32, ptr %retval, align 4
  %conv13 = sext i32 %13 to i64
  %14 = load ptr, ptr %io.addr, align 8
  %bytes14 = getelementptr inbounds %struct.RedisModuleIO, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %bytes14, align 8
  %add15 = add i64 %15, %conv13
  store i64 %add15, ptr %bytes14, align 8
  br label %return

saveerr:                                          ; preds = %if.then11, %if.then5, %if.then1
  %16 = load ptr, ptr %io.addr, align 8
  %error16 = getelementptr inbounds %struct.RedisModuleIO, ptr %16, i32 0, i32 3
  store i32 1, ptr %error16, align 8
  br label %return

return:                                           ; preds = %saveerr, %if.end12, %if.then
  ret void
}

declare i32 @rdbSaveBinaryFloatValue(ptr noundef, float noundef) #1

; Function Attrs: nounwind uwtable
define dso_local float @RM_LoadFloat(ptr noundef %io) #0 {
entry:
  %retval = alloca float, align 4
  %io.addr = alloca ptr, align 8
  %opcode = alloca i64, align 8
  %value = alloca float, align 4
  %retval3 = alloca i32, align 4
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store float 0.000000e+00, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %rio, align 8
  %call = call i64 @rdbLoadLen(ptr noundef %3, ptr noundef null)
  store i64 %call, ptr %opcode, align 8
  %4 = load i64, ptr %opcode, align 8
  %cmp = icmp ne i64 %4, 3
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  br label %loaderr

if.end2:                                          ; preds = %if.end
  %5 = load ptr, ptr %io.addr, align 8
  %rio4 = getelementptr inbounds %struct.RedisModuleIO, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %rio4, align 8
  %call5 = call i32 @rdbLoadBinaryFloatValue(ptr noundef %6, ptr noundef %value)
  store i32 %call5, ptr %retval3, align 4
  %7 = load i32, ptr %retval3, align 4
  %cmp6 = icmp eq i32 %7, -1
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end2
  br label %loaderr

if.end8:                                          ; preds = %if.end2
  %8 = load float, ptr %value, align 4
  store float %8, ptr %retval, align 4
  br label %return

loaderr:                                          ; preds = %if.then7, %if.then1
  %9 = load ptr, ptr %io.addr, align 8
  call void @moduleRDBLoadError(ptr noundef %9)
  store float 0.000000e+00, ptr %retval, align 4
  br label %return

return:                                           ; preds = %loaderr, %if.end8, %if.then
  %10 = load float, ptr %retval, align 4
  ret float %10
}

declare i32 @rdbLoadBinaryFloatValue(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SaveLongDouble(ptr noundef %io, x86_fp80 noundef %value) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %value.addr = alloca x86_fp80, align 16
  %buf = alloca [5120 x i8], align 16
  %len = alloca i64, align 8
  store ptr %io, ptr %io.addr, align 8
  store x86_fp80 %value, ptr %value.addr, align 16
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [5120 x i8], ptr %buf, i64 0, i64 0
  %2 = load x86_fp80, ptr %value.addr, align 16
  %call = call i32 @ld2string(ptr noundef %arraydecay, i64 noundef 5120, x86_fp80 noundef %2, i32 noundef 2)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %len, align 8
  %3 = load ptr, ptr %io.addr, align 8
  %arraydecay1 = getelementptr inbounds [5120 x i8], ptr %buf, i64 0, i64 0
  %4 = load i64, ptr %len, align 8
  call void @RM_SaveStringBuffer(ptr noundef %3, ptr noundef %arraydecay1, i64 noundef %4)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local x86_fp80 @RM_LoadLongDouble(ptr noundef %io) #0 {
entry:
  %retval = alloca x86_fp80, align 16
  %io.addr = alloca ptr, align 8
  %value = alloca x86_fp80, align 16
  %len = alloca i64, align 8
  %str = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store x86_fp80 0xK00000000000000000000, ptr %retval, align 16
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %call = call ptr @RM_LoadStringBuffer(ptr noundef %2, ptr noundef %len)
  store ptr %call, ptr %str, align 8
  %3 = load ptr, ptr %str, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store x86_fp80 0xK00000000000000000000, ptr %retval, align 16
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %str, align 8
  %5 = load i64, ptr %len, align 8
  %call4 = call i32 @string2ld(ptr noundef %4, i64 noundef %5, ptr noundef %value)
  %6 = load ptr, ptr %str, align 8
  call void @RM_Free(ptr noundef %6)
  %7 = load x86_fp80, ptr %value, align 16
  store x86_fp80 %7, ptr %retval, align 16
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %8 = load x86_fp80, ptr %retval, align 16
  ret x86_fp80 %8
}

; Function Attrs: nounwind uwtable
define dso_local i64 @rdbSaveModulesAux(ptr noundef %rdb, i32 noundef %when) #0 {
entry:
  %retval = alloca i64, align 8
  %rdb.addr = alloca ptr, align 8
  %when.addr = alloca i32, align 4
  %total_written = alloca i64, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %module = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %mt = alloca ptr, align 8
  %ret = alloca i64, align 8
  store ptr %rdb, ptr %rdb.addr, align 8
  store i32 %when, ptr %when.addr, align 4
  store i64 0, ptr %total_written, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.end, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end13

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %module, align 8
  %3 = load ptr, ptr %module, align 8
  %types = getelementptr inbounds %struct.RedisModule, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %types, align 8
  call void @listRewind(ptr noundef %4, ptr noundef %li)
  br label %while.cond3

while.cond3:                                      ; preds = %if.end12, %if.then, %while.body
  %call4 = call ptr @listNext(ptr noundef %li)
  store ptr %call4, ptr %ln, align 8
  %tobool = icmp ne ptr %call4, null
  br i1 %tobool, label %while.body5, label %while.end

while.body5:                                      ; preds = %while.cond3
  %5 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %mt, align 8
  %7 = load ptr, ptr %mt, align 8
  %aux_save = getelementptr inbounds %struct.RedisModuleType, ptr %7, i32 0, i32 13
  %8 = load ptr, ptr %aux_save, align 8
  %tobool6 = icmp ne ptr %8, null
  br i1 %tobool6, label %lor.lhs.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body5
  %9 = load ptr, ptr %mt, align 8
  %aux_save2 = getelementptr inbounds %struct.RedisModuleType, ptr %9, i32 0, i32 18
  %10 = load ptr, ptr %aux_save2, align 8
  %tobool7 = icmp ne ptr %10, null
  br i1 %tobool7, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %land.lhs.true, %while.body5
  %11 = load ptr, ptr %mt, align 8
  %aux_save_triggers = getelementptr inbounds %struct.RedisModuleType, ptr %11, i32 0, i32 19
  %12 = load i32, ptr %aux_save_triggers, align 8
  %13 = load i32, ptr %when.addr, align 4
  %and = and i32 %12, %13
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  br label %while.cond3, !llvm.loop !42

if.end:                                           ; preds = %lor.lhs.false
  %14 = load ptr, ptr %rdb.addr, align 8
  %15 = load i32, ptr %when.addr, align 4
  %16 = load ptr, ptr %mt, align 8
  %call9 = call i64 @rdbSaveSingleModuleAux(ptr noundef %14, i32 noundef %15, ptr noundef %16)
  store i64 %call9, ptr %ret, align 8
  %17 = load i64, ptr %ret, align 8
  %cmp10 = icmp eq i64 %17, -1
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  %18 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %18)
  store i64 -1, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end
  %19 = load i64, ptr %ret, align 8
  %20 = load i64, ptr %total_written, align 8
  %add = add i64 %20, %19
  store i64 %add, ptr %total_written, align 8
  br label %while.cond3, !llvm.loop !42

while.end:                                        ; preds = %while.cond3
  br label %while.cond, !llvm.loop !43

while.end13:                                      ; preds = %while.cond
  %21 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %21)
  %22 = load i64, ptr %total_written, align 8
  store i64 %22, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end13, %if.then11
  %23 = load i64, ptr %retval, align 8
  ret i64 %23
}

declare i64 @rdbSaveSingleModuleAux(ptr noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_DigestAddStringBuffer(ptr noundef %md, ptr noundef %ele, i64 noundef %len) #0 {
entry:
  %md.addr = alloca ptr, align 8
  %ele.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %md, ptr %md.addr, align 8
  store ptr %ele, ptr %ele.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %md.addr, align 8
  %o = getelementptr inbounds %struct.RedisModuleDigest, ptr %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [20 x i8], ptr %o, i64 0, i64 0
  %1 = load ptr, ptr %ele.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  call void @mixDigest(ptr noundef %arraydecay, ptr noundef %1, i64 noundef %2)
  ret void
}

declare void @mixDigest(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_DigestAddLongLong(ptr noundef %md, i64 noundef %ll) #0 {
entry:
  %md.addr = alloca ptr, align 8
  %ll.addr = alloca i64, align 8
  %buf = alloca [21 x i8], align 16
  %len = alloca i64, align 8
  store ptr %md, ptr %md.addr, align 8
  store i64 %ll, ptr %ll.addr, align 8
  %arraydecay = getelementptr inbounds [21 x i8], ptr %buf, i64 0, i64 0
  %0 = load i64, ptr %ll.addr, align 8
  %call = call i32 @ll2string(ptr noundef %arraydecay, i64 noundef 21, i64 noundef %0)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %len, align 8
  %1 = load ptr, ptr %md.addr, align 8
  %o = getelementptr inbounds %struct.RedisModuleDigest, ptr %1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [20 x i8], ptr %o, i64 0, i64 0
  %arraydecay2 = getelementptr inbounds [21 x i8], ptr %buf, i64 0, i64 0
  %2 = load i64, ptr %len, align 8
  call void @mixDigest(ptr noundef %arraydecay1, ptr noundef %arraydecay2, i64 noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_DigestEndSequence(ptr noundef %md) #0 {
entry:
  %md.addr = alloca ptr, align 8
  store ptr %md, ptr %md.addr, align 8
  %0 = load ptr, ptr %md.addr, align 8
  %x = getelementptr inbounds %struct.RedisModuleDigest, ptr %0, i32 0, i32 1
  %arraydecay = getelementptr inbounds [20 x i8], ptr %x, i64 0, i64 0
  %1 = load ptr, ptr %md.addr, align 8
  %o = getelementptr inbounds %struct.RedisModuleDigest, ptr %1, i32 0, i32 0
  %arraydecay1 = getelementptr inbounds [20 x i8], ptr %o, i64 0, i64 0
  call void @xorDigest(ptr noundef %arraydecay, ptr noundef %arraydecay1, i64 noundef 20)
  %2 = load ptr, ptr %md.addr, align 8
  %o2 = getelementptr inbounds %struct.RedisModuleDigest, ptr %2, i32 0, i32 0
  %arraydecay3 = getelementptr inbounds [20 x i8], ptr %o2, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay3, i8 0, i64 20, i1 false)
  ret void
}

declare void @xorDigest(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_LoadDataTypeFromStringEncver(ptr noundef %str, ptr noundef %mt, i32 noundef %encver) #0 {
entry:
  %str.addr = alloca ptr, align 8
  %mt.addr = alloca ptr, align 8
  %encver.addr = alloca i32, align 4
  %payload = alloca %struct._rio, align 8
  %io = alloca %struct.RedisModuleIO, align 8
  %ret = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  store ptr %mt, ptr %mt.addr, align 8
  store i32 %encver, ptr %encver.addr, align 4
  %0 = load ptr, ptr %str.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  call void @rioInitWithBuffer(ptr noundef %payload, ptr noundef %1)
  br label %do.body

do.body:                                          ; preds = %entry
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 1
  store ptr %payload, ptr %rio, align 8
  %2 = load ptr, ptr %mt.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 2
  store ptr %2, ptr %type, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 0
  store i64 0, ptr %bytes, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 3
  store i32 0, ptr %error, align 8
  %key = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 5
  store ptr null, ptr %key, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 6
  store i32 -1, ptr %dbid, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 4
  store ptr null, ptr %ctx, align 8
  %pre_flush_buffer = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 7
  store ptr null, ptr %pre_flush_buffer, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %mt.addr, align 8
  %rdb_load = getelementptr inbounds %struct.RedisModuleType, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %rdb_load, align 8
  %5 = load i32, ptr %encver.addr, align 4
  %call = call ptr %4(ptr noundef %io, i32 noundef %5)
  store ptr %call, ptr %ret, align 8
  %ctx1 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 4
  %6 = load ptr, ptr %ctx1, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %ctx2 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 4
  %7 = load ptr, ptr %ctx2, align 8
  call void @moduleFreeContext(ptr noundef %7)
  %ctx3 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 4
  %8 = load ptr, ptr %ctx3, align 8
  call void @zfree(ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %do.end
  %9 = load ptr, ptr %ret, align 8
  ret ptr %9
}

declare void @rioInitWithBuffer(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_LoadDataTypeFromString(ptr noundef %str, ptr noundef %mt) #0 {
entry:
  %str.addr = alloca ptr, align 8
  %mt.addr = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  store ptr %mt, ptr %mt.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %1 = load ptr, ptr %mt.addr, align 8
  %call = call ptr @RM_LoadDataTypeFromStringEncver(ptr noundef %0, ptr noundef %1, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_SaveDataTypeToString(ptr noundef %ctx, ptr noundef %data, ptr noundef %mt) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %mt.addr = alloca ptr, align 8
  %payload = alloca %struct._rio, align 8
  %io = alloca %struct.RedisModuleIO, align 8
  %str = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %mt, ptr %mt.addr, align 8
  %call = call ptr @sdsempty()
  call void @rioInitWithBuffer(ptr noundef %payload, ptr noundef %call)
  br label %do.body

do.body:                                          ; preds = %entry
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 1
  store ptr %payload, ptr %rio, align 8
  %0 = load ptr, ptr %mt.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 2
  store ptr %0, ptr %type, align 8
  %bytes = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 0
  store i64 0, ptr %bytes, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 3
  store i32 0, ptr %error, align 8
  %key = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 5
  store ptr null, ptr %key, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 6
  store i32 -1, ptr %dbid, align 8
  %ctx1 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 4
  store ptr null, ptr %ctx1, align 8
  %pre_flush_buffer = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 7
  store ptr null, ptr %pre_flush_buffer, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %1 = load ptr, ptr %mt.addr, align 8
  %rdb_save = getelementptr inbounds %struct.RedisModuleType, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %rdb_save, align 8
  %3 = load ptr, ptr %data.addr, align 8
  call void %2(ptr noundef %io, ptr noundef %3)
  %ctx2 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 4
  %4 = load ptr, ptr %ctx2, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %ctx3 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 4
  %5 = load ptr, ptr %ctx3, align 8
  call void @moduleFreeContext(ptr noundef %5)
  %ctx4 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 4
  %6 = load ptr, ptr %ctx4, align 8
  call void @zfree(ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %do.end
  %error5 = getelementptr inbounds %struct.RedisModuleIO, ptr %io, i32 0, i32 3
  %7 = load i32, ptr %error5, align 8
  %tobool6 = icmp ne i32 %7, 0
  br i1 %tobool6, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end
  %io8 = getelementptr inbounds %struct._rio, ptr %payload, i32 0, i32 9
  %ptr = getelementptr inbounds %struct.anon.23, ptr %io8, i32 0, i32 0
  %8 = load ptr, ptr %ptr, align 8
  %call9 = call ptr @createObject(i32 noundef 0, ptr noundef %8)
  store ptr %call9, ptr %str, align 8
  %9 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %9, null
  br i1 %cmp, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.else
  %10 = load ptr, ptr %ctx.addr, align 8
  %11 = load ptr, ptr %str, align 8
  call void @autoMemoryAdd(ptr noundef %10, i32 noundef 1, ptr noundef %11)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.else
  %12 = load ptr, ptr %str, align 8
  store ptr %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then7
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetKeyNameFromDigest(ptr noundef %dig) #0 {
entry:
  %dig.addr = alloca ptr, align 8
  store ptr %dig, ptr %dig.addr, align 8
  %0 = load ptr, ptr %dig.addr, align 8
  %key = getelementptr inbounds %struct.RedisModuleDigest, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %key, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetDbIdFromDigest(ptr noundef %dig) #0 {
entry:
  %dig.addr = alloca ptr, align 8
  store ptr %dig, ptr %dig.addr, align 8
  %0 = load ptr, ptr %dig.addr, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleDigest, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %dbid, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_EmitAOF(ptr noundef %io, ptr noundef %cmdname, ptr noundef %fmt, ...) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %cmdname.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %argv = alloca ptr, align 8
  %argc = alloca i32, align 4
  %flags = alloca i32, align 4
  %j = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %io, ptr %io.addr, align 8
  store ptr %cmdname, ptr %cmdname.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %error = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %error, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %argv, align 8
  store i32 0, ptr %argc, align 4
  store i32 0, ptr %flags, align 4
  %2 = load ptr, ptr %cmdname.addr, align 8
  %call = call ptr @lookupCommandByCString(ptr noundef %2)
  store ptr %call, ptr %cmd, align 8
  %3 = load ptr, ptr %cmd, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.end7, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then2
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 3, %4
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %do.body
  br label %do.end

if.end4:                                          ; preds = %do.body
  %5 = load ptr, ptr %io.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %type, align 8
  %name = getelementptr inbounds %struct.RedisModuleType, ptr %6, i32 0, i32 20
  %arraydecay = getelementptr inbounds [10 x i8], ptr %name, i64 0, i64 0
  %7 = load ptr, ptr %cmdname.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.61, ptr noundef %arraydecay, ptr noundef %7)
  br label %do.end

do.end:                                           ; preds = %if.end4, %if.then3
  %8 = load ptr, ptr %io.addr, align 8
  %error5 = getelementptr inbounds %struct.RedisModuleIO, ptr %8, i32 0, i32 3
  store i32 1, ptr %error5, align 8
  %call6 = call ptr @__errno_location() #15
  store i32 22, ptr %call6, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %arraydecay8 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay8)
  %9 = load ptr, ptr %cmdname.addr, align 8
  %10 = load ptr, ptr %fmt.addr, align 8
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call10 = call ptr @moduleCreateArgvFromUserFormat(ptr noundef %9, ptr noundef %10, ptr noundef %argc, ptr noundef %flags, ptr noundef %arraydecay9)
  store ptr %call10, ptr %argv, align 8
  %arraydecay11 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay11)
  %11 = load ptr, ptr %argv, align 8
  %cmp12 = icmp eq ptr %11, null
  br i1 %cmp12, label %if.then13, label %if.end24

if.then13:                                        ; preds = %if.end7
  br label %do.body14

do.body14:                                        ; preds = %if.then13
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp15 = icmp slt i32 3, %12
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %do.body14
  br label %do.end21

if.end17:                                         ; preds = %do.body14
  %13 = load ptr, ptr %io.addr, align 8
  %type18 = getelementptr inbounds %struct.RedisModuleIO, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %type18, align 8
  %name19 = getelementptr inbounds %struct.RedisModuleType, ptr %14, i32 0, i32 20
  %arraydecay20 = getelementptr inbounds [10 x i8], ptr %name19, i64 0, i64 0
  %15 = load ptr, ptr %fmt.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.62, ptr noundef %arraydecay20, ptr noundef %15)
  br label %do.end21

do.end21:                                         ; preds = %if.end17, %if.then16
  %16 = load ptr, ptr %io.addr, align 8
  %error22 = getelementptr inbounds %struct.RedisModuleIO, ptr %16, i32 0, i32 3
  store i32 1, ptr %error22, align 8
  %call23 = call ptr @__errno_location() #15
  store i32 22, ptr %call23, align 4
  br label %return

if.end24:                                         ; preds = %if.end7
  %17 = load ptr, ptr %io.addr, align 8
  %error25 = getelementptr inbounds %struct.RedisModuleIO, ptr %17, i32 0, i32 3
  %18 = load i32, ptr %error25, align 8
  %tobool26 = icmp ne i32 %18, 0
  br i1 %tobool26, label %if.end32, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end24
  %19 = load ptr, ptr %io.addr, align 8
  %rio = getelementptr inbounds %struct.RedisModuleIO, ptr %19, i32 0, i32 1
  %20 = load ptr, ptr %rio, align 8
  %21 = load i32, ptr %argc, align 4
  %conv = sext i32 %21 to i64
  %call27 = call i64 @rioWriteBulkCount(ptr noundef %20, i8 noundef signext 42, i64 noundef %conv)
  %cmp28 = icmp eq i64 %call27, 0
  br i1 %cmp28, label %if.then30, label %if.end32

if.then30:                                        ; preds = %land.lhs.true
  %22 = load ptr, ptr %io.addr, align 8
  %error31 = getelementptr inbounds %struct.RedisModuleIO, ptr %22, i32 0, i32 3
  store i32 1, ptr %error31, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %land.lhs.true, %if.end24
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end32
  %23 = load i32, ptr %j, align 4
  %24 = load i32, ptr %argc, align 4
  %cmp33 = icmp slt i32 %23, %24
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load ptr, ptr %io.addr, align 8
  %error35 = getelementptr inbounds %struct.RedisModuleIO, ptr %25, i32 0, i32 3
  %26 = load i32, ptr %error35, align 8
  %tobool36 = icmp ne i32 %26, 0
  br i1 %tobool36, label %if.end44, label %land.lhs.true37

land.lhs.true37:                                  ; preds = %for.body
  %27 = load ptr, ptr %io.addr, align 8
  %rio38 = getelementptr inbounds %struct.RedisModuleIO, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %rio38, align 8
  %29 = load ptr, ptr %argv, align 8
  %30 = load i32, ptr %j, align 4
  %idxprom = sext i32 %30 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %29, i64 %idxprom
  %31 = load ptr, ptr %arrayidx, align 8
  %call39 = call i32 @rioWriteBulkObject(ptr noundef %28, ptr noundef %31)
  %cmp40 = icmp eq i32 %call39, 0
  br i1 %cmp40, label %if.then42, label %if.end44

if.then42:                                        ; preds = %land.lhs.true37
  %32 = load ptr, ptr %io.addr, align 8
  %error43 = getelementptr inbounds %struct.RedisModuleIO, ptr %32, i32 0, i32 3
  store i32 1, ptr %error43, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %land.lhs.true37, %for.body
  %33 = load ptr, ptr %argv, align 8
  %34 = load i32, ptr %j, align 4
  %idxprom45 = sext i32 %34 to i64
  %arrayidx46 = getelementptr inbounds ptr, ptr %33, i64 %idxprom45
  %35 = load ptr, ptr %arrayidx46, align 8
  call void @decrRefCount(ptr noundef %35)
  br label %for.inc

for.inc:                                          ; preds = %if.end44
  %36 = load i32, ptr %j, align 4
  %inc = add nsw i32 %36, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !44

for.end:                                          ; preds = %for.cond
  %37 = load ptr, ptr %argv, align 8
  call void @zfree(ptr noundef %37)
  br label %return

return:                                           ; preds = %for.end, %do.end21, %do.end, %if.then
  ret void
}

declare i64 @rioWriteBulkCount(ptr noundef, i8 noundef signext, i64 noundef) #1

declare i32 @rioWriteBulkObject(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetContextFromIO(ptr noundef %io) #0 {
entry:
  %retval = alloca ptr, align 8
  %io.addr = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %ctx = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %ctx, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %io.addr, align 8
  %ctx1 = getelementptr inbounds %struct.RedisModuleIO, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %ctx1, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call = call noalias ptr @zmalloc(i64 noundef 120) #11
  %4 = load ptr, ptr %io.addr, align 8
  %ctx2 = getelementptr inbounds %struct.RedisModuleIO, ptr %4, i32 0, i32 4
  store ptr %call, ptr %ctx2, align 8
  %5 = load ptr, ptr %io.addr, align 8
  %ctx3 = getelementptr inbounds %struct.RedisModuleIO, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %ctx3, align 8
  %7 = load ptr, ptr %io.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %type, align 8
  %module = getelementptr inbounds %struct.RedisModuleType, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %6, ptr noundef %9, i32 noundef 0)
  %10 = load ptr, ptr %io.addr, align 8
  %ctx4 = getelementptr inbounds %struct.RedisModuleIO, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %ctx4, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetKeyNameFromIO(ptr noundef %io) #0 {
entry:
  %io.addr = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %key = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %key, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetKeyNameFromModuleKey(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %key1 = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %key1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %2, %cond.true ], [ null, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetDbIdFromModuleKey(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %db = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %id, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ -1, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetDbIdFromIO(ptr noundef %io) #0 {
entry:
  %io.addr = alloca ptr, align 8
  store ptr %io, ptr %io.addr, align 8
  %0 = load ptr, ptr %io.addr, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %dbid, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleLogRaw(ptr noundef %module, ptr noundef %levelstr, ptr noundef %fmt, ptr noundef %ap) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %levelstr.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %ap.addr = alloca ptr, align 8
  %msg = alloca [1024 x i8], align 16
  %name_len = alloca i64, align 8
  %level = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %levelstr, ptr %levelstr.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr %ap, ptr %ap.addr, align 8
  %0 = load ptr, ptr %levelstr.addr, align 8
  %call = call i32 @strcasecmp(ptr noundef %0, ptr noundef @.str.63) #14
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %level, align 4
  br label %if.end15

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %levelstr.addr, align 8
  %call1 = call i32 @strcasecmp(ptr noundef %1, ptr noundef @.str.64) #14
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.else4, label %if.then3

if.then3:                                         ; preds = %if.else
  store i32 1, ptr %level, align 4
  br label %if.end14

if.else4:                                         ; preds = %if.else
  %2 = load ptr, ptr %levelstr.addr, align 8
  %call5 = call i32 @strcasecmp(ptr noundef %2, ptr noundef @.str.65) #14
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.else8, label %if.then7

if.then7:                                         ; preds = %if.else4
  store i32 2, ptr %level, align 4
  br label %if.end13

if.else8:                                         ; preds = %if.else4
  %3 = load ptr, ptr %levelstr.addr, align 8
  %call9 = call i32 @strcasecmp(ptr noundef %3, ptr noundef @.str.66) #14
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.else12, label %if.then11

if.then11:                                        ; preds = %if.else8
  store i32 3, ptr %level, align 4
  br label %if.end

if.else12:                                        ; preds = %if.else8
  store i32 1, ptr %level, align 4
  br label %if.end

if.end:                                           ; preds = %if.else12, %if.then11
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then7
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.then3
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then
  %4 = load i32, ptr %level, align 4
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end15
  br label %return

if.end17:                                         ; preds = %if.end15
  %arraydecay = getelementptr inbounds [1024 x i8], ptr %msg, i64 0, i64 0
  %6 = load ptr, ptr %module.addr, align 8
  %tobool18 = icmp ne ptr %6, null
  br i1 %tobool18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end17
  %7 = load ptr, ptr %module.addr, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %name, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end17
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %8, %cond.true ], [ @.str.68, %cond.false ]
  %call19 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 1024, ptr noundef @.str.67, ptr noundef %cond) #16
  %conv = sext i32 %call19 to i64
  store i64 %conv, ptr %name_len, align 8
  %arraydecay20 = getelementptr inbounds [1024 x i8], ptr %msg, i64 0, i64 0
  %9 = load i64, ptr %name_len, align 8
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay20, i64 %9
  %10 = load i64, ptr %name_len, align 8
  %sub = sub i64 1024, %10
  %11 = load ptr, ptr %fmt.addr, align 8
  %12 = load ptr, ptr %ap.addr, align 8
  %call21 = call i32 @vsnprintf(ptr noundef %add.ptr, i64 noundef %sub, ptr noundef %11, ptr noundef %12) #16
  %13 = load i32, ptr %level, align 4
  %arraydecay22 = getelementptr inbounds [1024 x i8], ptr %msg, i64 0, i64 0
  call void @serverLogRaw(i32 noundef %13, ptr noundef %arraydecay22)
  br label %return

return:                                           ; preds = %cond.end, %if.then16
  ret void
}

; Function Attrs: nounwind
declare i32 @vsnprintf(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #10

declare void @serverLogRaw(i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_Log(ptr noundef %ctx, ptr noundef %levelstr, ptr noundef %fmt, ...) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %levelstr.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %levelstr, ptr %levelstr.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %ctx.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %2, %cond.true ], [ null, %cond.false ]
  %3 = load ptr, ptr %levelstr.addr, align 8
  %4 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @moduleLogRaw(ptr noundef %cond, ptr noundef %3, ptr noundef %4, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_LogIOError(ptr noundef %io, ptr noundef %levelstr, ptr noundef %fmt, ...) #0 {
entry:
  %io.addr = alloca ptr, align 8
  %levelstr.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %io, ptr %io.addr, align 8
  store ptr %levelstr, ptr %levelstr.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load ptr, ptr %io.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleIO, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %type, align 8
  %module = getelementptr inbounds %struct.RedisModuleType, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %3 = load ptr, ptr %levelstr.addr, align 8
  %4 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @moduleLogRaw(ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM__Assert(ptr noundef %estr, ptr noundef %file, i32 noundef %line) #0 {
entry:
  %estr.addr = alloca ptr, align 8
  %file.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  store ptr %estr, ptr %estr.addr, align 8
  store ptr %file, ptr %file.addr, align 8
  store i32 %line, ptr %line.addr, align 4
  %0 = load ptr, ptr %estr.addr, align 8
  %1 = load ptr, ptr %file.addr, align 8
  %2 = load i32, ptr %line.addr, align 4
  call void @_serverAssert(ptr noundef %0, ptr noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_LatencyAddSample(ptr noundef %event, i64 noundef %latency) #0 {
entry:
  %event.addr = alloca ptr, align 8
  %latency.addr = alloca i64, align 8
  store ptr %event, ptr %event.addr, align 8
  store i64 %latency, ptr %latency.addr, align 8
  %0 = load i64, ptr %latency.addr, align 8
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %cmp = icmp sge i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %event.addr, align 8
  %3 = load i64, ptr %latency.addr, align 8
  call void @latencyAddSample(ptr noundef %2, i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @latencyAddSample(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @unblockClientFromModule(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %bc = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 55
  %module_blocked_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 7
  %1 = load ptr, ptr %module_blocked_handle, align 8
  store ptr %1, ptr %bc, align 8
  %2 = load ptr, ptr %bc, align 8
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %2, i32 0, i32 5
  %3 = load ptr, ptr %disconnect_callback, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %bc, align 8
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %5, i32 noundef 0)
  %6 = load ptr, ptr %bc, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %6, i32 0, i32 7
  %7 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 10
  store ptr %7, ptr %blocked_privdata, align 8
  %8 = load ptr, ptr %bc, align 8
  %client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %client, align 8
  %client1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %9, ptr %client1, align 8
  %10 = load ptr, ptr %bc, align 8
  %disconnect_callback2 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %10, i32 0, i32 5
  %11 = load ptr, ptr %disconnect_callback2, align 8
  %12 = load ptr, ptr %bc, align 8
  call void %11(ptr noundef %ctx, ptr noundef %12)
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %13 = load ptr, ptr %bc, align 8
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %13, i32 0, i32 11
  %14 = load i32, ptr %blocked_on_keys, align 4
  %tobool3 = icmp ne i32 %14, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %15 = load ptr, ptr %bc, align 8
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %15, i32 0, i32 12
  %16 = load i32, ptr %unblocked, align 8
  %tobool4 = icmp ne i32 %16, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  %17 = load ptr, ptr %c.addr, align 8
  call void @moduleUnblockClient(ptr noundef %17)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %18 = load ptr, ptr %bc, align 8
  %client7 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %18, i32 0, i32 0
  store ptr null, ptr %client7, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnblockClient(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %bc = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 55
  %module_blocked_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 7
  %1 = load ptr, ptr %module_blocked_handle, align 8
  store ptr %1, ptr %bc, align 8
  %2 = load ptr, ptr %bc, align 8
  %call = call i32 @moduleUnblockClientByHandle(ptr noundef %2, ptr noundef null)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @moduleBlockClient(ptr noundef %ctx, ptr noundef %reply_callback, ptr noundef %auth_reply_callback, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef %keys, i32 noundef %numkeys, ptr noundef %privdata, i32 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %reply_callback.addr = alloca ptr, align 8
  %auth_reply_callback.addr = alloca ptr, align 8
  %timeout_callback.addr = alloca ptr, align 8
  %free_privdata.addr = alloca ptr, align 8
  %timeout_ms.addr = alloca i64, align 8
  %keys.addr = alloca ptr, align 8
  %numkeys.addr = alloca i32, align 4
  %privdata.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %c = alloca ptr, align 8
  %islua = alloca i32, align 4
  %ismulti = alloca i32, align 4
  %bc = alloca ptr, align 8
  %now = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %reply_callback, ptr %reply_callback.addr, align 8
  store ptr %auth_reply_callback, ptr %auth_reply_callback.addr, align 8
  store ptr %timeout_callback, ptr %timeout_callback.addr, align 8
  store ptr %free_privdata, ptr %free_privdata.addr, align 8
  store i64 %timeout_ms, ptr %timeout_ms.addr, align 8
  store ptr %keys, ptr %keys.addr, align 8
  store i32 %numkeys, ptr %numkeys.addr, align 4
  store ptr %privdata, ptr %privdata.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  store ptr %1, ptr %c, align 8
  %call = call i32 @scriptIsRunning()
  store i32 %call, ptr %islua, align 4
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 30), align 4
  store i32 %2, ptr %ismulti, align 4
  %call1 = call noalias ptr @zmalloc(i64 noundef 112) #11
  %3 = load ptr, ptr %c, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 55
  %module_blocked_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 7
  store ptr %call1, ptr %module_blocked_handle, align 8
  %4 = load ptr, ptr %c, align 8
  %bstate2 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 55
  %module_blocked_handle3 = getelementptr inbounds %struct.blockingState, ptr %bstate2, i32 0, i32 7
  %5 = load ptr, ptr %module_blocked_handle3, align 8
  store ptr %5, ptr %bc, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %module, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %7, i32 0, i32 13
  %8 = load i32, ptr %blocked_clients, align 8
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %blocked_clients, align 8
  %9 = load i32, ptr %islua, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %10 = load i32, ptr %ismulti, align 4
  %tobool4 = icmp ne i32 %10, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %entry
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %11 = load ptr, ptr %c, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %11, %cond.false ]
  %12 = load ptr, ptr %bc, align 8
  %client5 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %12, i32 0, i32 0
  store ptr %cond, ptr %client5, align 8
  %13 = load ptr, ptr %ctx.addr, align 8
  %module6 = getelementptr inbounds %struct.RedisModuleCtx, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %module6, align 8
  %15 = load ptr, ptr %bc, align 8
  %module7 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %15, i32 0, i32 1
  store ptr %14, ptr %module7, align 8
  %16 = load ptr, ptr %reply_callback.addr, align 8
  %17 = load ptr, ptr %bc, align 8
  %reply_callback8 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %17, i32 0, i32 2
  store ptr %16, ptr %reply_callback8, align 8
  %18 = load ptr, ptr %auth_reply_callback.addr, align 8
  %19 = load ptr, ptr %bc, align 8
  %auth_reply_cb = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %19, i32 0, i32 3
  store ptr %18, ptr %auth_reply_cb, align 8
  %20 = load ptr, ptr %timeout_callback.addr, align 8
  %21 = load ptr, ptr %bc, align 8
  %timeout_callback9 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %21, i32 0, i32 4
  store ptr %20, ptr %timeout_callback9, align 8
  %22 = load ptr, ptr %bc, align 8
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %22, i32 0, i32 5
  store ptr null, ptr %disconnect_callback, align 8
  %23 = load ptr, ptr %free_privdata.addr, align 8
  %24 = load ptr, ptr %bc, align 8
  %free_privdata10 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %24, i32 0, i32 6
  store ptr %23, ptr %free_privdata10, align 8
  %25 = load ptr, ptr %privdata.addr, align 8
  %26 = load ptr, ptr %bc, align 8
  %privdata11 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %26, i32 0, i32 7
  store ptr %25, ptr %privdata11, align 8
  %call12 = call ptr @moduleAllocTempClient()
  %27 = load ptr, ptr %bc, align 8
  %reply_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %27, i32 0, i32 9
  store ptr %call12, ptr %reply_client, align 8
  %call13 = call ptr @moduleAllocTempClient()
  %28 = load ptr, ptr %bc, align 8
  %thread_safe_ctx_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %28, i32 0, i32 8
  store ptr %call13, ptr %thread_safe_ctx_client, align 8
  %29 = load ptr, ptr %bc, align 8
  %client14 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %client14, align 8
  %tobool15 = icmp ne ptr %30, null
  br i1 %tobool15, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %31 = load ptr, ptr %bc, align 8
  %client16 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %client16, align 8
  %resp = getelementptr inbounds %struct.client, ptr %32, i32 0, i32 3
  %33 = load i32, ptr %resp, align 8
  %34 = load ptr, ptr %bc, align 8
  %reply_client17 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %34, i32 0, i32 9
  %35 = load ptr, ptr %reply_client17, align 8
  %resp18 = getelementptr inbounds %struct.client, ptr %35, i32 0, i32 3
  store i32 %33, ptr %resp18, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %36 = load ptr, ptr %c, align 8
  %db = getelementptr inbounds %struct.client, ptr %36, i32 0, i32 4
  %37 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %37, i32 0, i32 6
  %38 = load i32, ptr %id, align 8
  %39 = load ptr, ptr %bc, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %39, i32 0, i32 10
  store i32 %38, ptr %dbid, align 8
  %40 = load ptr, ptr %keys.addr, align 8
  %cmp = icmp ne ptr %40, null
  %conv = zext i1 %cmp to i32
  %41 = load ptr, ptr %bc, align 8
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %41, i32 0, i32 11
  store i32 %conv, ptr %blocked_on_keys, align 4
  %42 = load ptr, ptr %bc, align 8
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %42, i32 0, i32 12
  store i32 0, ptr %unblocked, align 8
  %43 = load ptr, ptr %bc, align 8
  %background_timer = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %43, i32 0, i32 13
  store i64 0, ptr %background_timer, align 8
  %44 = load ptr, ptr %bc, align 8
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %44, i32 0, i32 14
  store i64 0, ptr %background_duration, align 8
  %45 = load ptr, ptr %c, align 8
  %bstate19 = getelementptr inbounds %struct.client, ptr %45, i32 0, i32 55
  %timeout = getelementptr inbounds %struct.blockingState, ptr %bstate19, i32 0, i32 1
  store i64 0, ptr %timeout, align 8
  %46 = load i64, ptr %timeout_ms.addr, align 8
  %tobool20 = icmp ne i64 %46, 0
  br i1 %tobool20, label %if.then21, label %if.end31

if.then21:                                        ; preds = %if.end
  %call22 = call i64 @mstime()
  store i64 %call22, ptr %now, align 8
  %47 = load i64, ptr %timeout_ms.addr, align 8
  %48 = load i64, ptr %now, align 8
  %sub = sub nsw i64 9223372036854775807, %48
  %cmp23 = icmp sgt i64 %47, %sub
  br i1 %cmp23, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.then21
  %49 = load ptr, ptr %c, align 8
  %bstate26 = getelementptr inbounds %struct.client, ptr %49, i32 0, i32 55
  %module_blocked_handle27 = getelementptr inbounds %struct.blockingState, ptr %bstate26, i32 0, i32 7
  store ptr null, ptr %module_blocked_handle27, align 8
  %50 = load ptr, ptr %c, align 8
  call void @addReplyError(ptr noundef %50, ptr noundef @.str.69)
  %51 = load ptr, ptr %bc, align 8
  store ptr %51, ptr %retval, align 8
  br label %return

if.end28:                                         ; preds = %if.then21
  %52 = load i64, ptr %timeout_ms.addr, align 8
  %53 = load i64, ptr %now, align 8
  %add = add nsw i64 %52, %53
  %54 = load ptr, ptr %c, align 8
  %bstate29 = getelementptr inbounds %struct.client, ptr %54, i32 0, i32 55
  %timeout30 = getelementptr inbounds %struct.blockingState, ptr %bstate29, i32 0, i32 1
  store i64 %add, ptr %timeout30, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end28, %if.end
  %55 = load i32, ptr %islua, align 4
  %tobool32 = icmp ne i32 %55, 0
  br i1 %tobool32, label %if.then35, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %if.end31
  %56 = load i32, ptr %ismulti, align 4
  %tobool34 = icmp ne i32 %56, 0
  br i1 %tobool34, label %if.then35, label %if.else

if.then35:                                        ; preds = %lor.lhs.false33, %if.end31
  %57 = load ptr, ptr %c, align 8
  %bstate36 = getelementptr inbounds %struct.client, ptr %57, i32 0, i32 55
  %module_blocked_handle37 = getelementptr inbounds %struct.blockingState, ptr %bstate36, i32 0, i32 7
  store ptr null, ptr %module_blocked_handle37, align 8
  %58 = load ptr, ptr %c, align 8
  %59 = load i32, ptr %islua, align 4
  %tobool38 = icmp ne i32 %59, 0
  %cond39 = select i1 %tobool38, ptr @.str.70, ptr @.str.71
  call void @addReplyError(ptr noundef %58, ptr noundef %cond39)
  br label %if.end62

if.else:                                          ; preds = %lor.lhs.false33
  %60 = load ptr, ptr %ctx.addr, align 8
  %flags40 = getelementptr inbounds %struct.RedisModuleCtx, ptr %60, i32 0, i32 7
  %61 = load i32, ptr %flags40, align 8
  %and = and i32 %61, 4
  %tobool41 = icmp ne i32 %and, 0
  br i1 %tobool41, label %if.then42, label %if.else45

if.then42:                                        ; preds = %if.else
  %62 = load ptr, ptr %c, align 8
  %bstate43 = getelementptr inbounds %struct.client, ptr %62, i32 0, i32 55
  %module_blocked_handle44 = getelementptr inbounds %struct.blockingState, ptr %bstate43, i32 0, i32 7
  store ptr null, ptr %module_blocked_handle44, align 8
  %63 = load ptr, ptr %c, align 8
  call void @addReplyError(ptr noundef %63, ptr noundef @.str.72)
  br label %if.end61

if.else45:                                        ; preds = %if.else
  %64 = load ptr, ptr %auth_reply_callback.addr, align 8
  %tobool46 = icmp ne ptr %64, null
  br i1 %tobool46, label %if.else52, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else45
  %65 = load ptr, ptr %c, align 8
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %65, i32 0, i32 67
  %66 = load ptr, ptr %module_auth_ctx, align 8
  %cmp47 = icmp ne ptr %66, null
  br i1 %cmp47, label %if.then49, label %if.else52

if.then49:                                        ; preds = %land.lhs.true
  %67 = load ptr, ptr %c, align 8
  %bstate50 = getelementptr inbounds %struct.client, ptr %67, i32 0, i32 55
  %module_blocked_handle51 = getelementptr inbounds %struct.blockingState, ptr %bstate50, i32 0, i32 7
  store ptr null, ptr %module_blocked_handle51, align 8
  %68 = load ptr, ptr %c, align 8
  call void @addReplyError(ptr noundef %68, ptr noundef @.str.73)
  br label %if.end60

if.else52:                                        ; preds = %land.lhs.true, %if.else45
  %69 = load ptr, ptr %keys.addr, align 8
  %tobool53 = icmp ne ptr %69, null
  br i1 %tobool53, label %if.then54, label %if.else58

if.then54:                                        ; preds = %if.else52
  %70 = load ptr, ptr %c, align 8
  %71 = load ptr, ptr %keys.addr, align 8
  %72 = load i32, ptr %numkeys.addr, align 4
  %73 = load ptr, ptr %c, align 8
  %bstate55 = getelementptr inbounds %struct.client, ptr %73, i32 0, i32 55
  %timeout56 = getelementptr inbounds %struct.blockingState, ptr %bstate55, i32 0, i32 1
  %74 = load i64, ptr %timeout56, align 8
  %75 = load i32, ptr %flags.addr, align 4
  %and57 = and i32 %75, 1
  call void @blockForKeys(ptr noundef %70, i32 noundef 4, ptr noundef %71, i32 noundef %72, i64 noundef %74, i32 noundef %and57)
  br label %if.end59

if.else58:                                        ; preds = %if.else52
  %76 = load ptr, ptr %c, align 8
  call void @blockClient(ptr noundef %76, i32 noundef 4)
  br label %if.end59

if.end59:                                         ; preds = %if.else58, %if.then54
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.then49
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.then42
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.then35
  %77 = load ptr, ptr %bc, align 8
  store ptr %77, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end62, %if.then25
  %78 = load ptr, ptr %retval, align 8
  ret ptr %78
}

declare void @blockForKeys(ptr noundef, i32 noundef, ptr noundef, i32 noundef, i64 noundef, i32 noundef) #1

declare void @blockClient(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_RegisterAuthCallback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %auth_ctx = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 16) #11
  store ptr %call, ptr %auth_ctx, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %2 = load ptr, ptr %auth_ctx, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleAuthCtx, ptr %2, i32 0, i32 0
  store ptr %1, ptr %module1, align 8
  %3 = load ptr, ptr %cb.addr, align 8
  %4 = load ptr, ptr %auth_ctx, align 8
  %auth_cb = getelementptr inbounds %struct.RedisModuleAuthCtx, ptr %4, i32 0, i32 1
  store ptr %3, ptr %auth_cb, align 8
  %5 = load ptr, ptr @moduleAuthCallbacks, align 8
  %6 = load ptr, ptr %auth_ctx, align 8
  %call2 = call ptr @listAddNodeHead(ptr noundef %5, ptr noundef %6)
  ret void
}

declare ptr @listAddNodeHead(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleInvokeFreePrivDataCallback(ptr noundef %c, ptr noundef %bc) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %bc.addr = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %ctx_flags = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %bc, ptr %bc.addr, align 8
  %0 = load ptr, ptr %bc.addr, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i32 0, i32 7
  %1 = load ptr, ptr %privdata, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %bc.addr, align 8
  %free_privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %free_privdata, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load ptr, ptr %c.addr, align 8
  %cmp = icmp eq ptr %4, null
  %cond = select i1 %cmp, i32 32, i32 0
  store i32 %cond, ptr %ctx_flags, align 4
  %5 = load ptr, ptr %bc.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %module, align 8
  %7 = load i32, ptr %ctx_flags, align 4
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %6, i32 noundef %7)
  %8 = load ptr, ptr %bc.addr, align 8
  %privdata2 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i32 0, i32 7
  %9 = load ptr, ptr %privdata2, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 10
  store ptr %9, ptr %blocked_privdata, align 8
  %10 = load ptr, ptr %bc.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %client, align 8
  %client3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %11, ptr %client3, align 8
  %12 = load ptr, ptr %bc.addr, align 8
  %free_privdata4 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %12, i32 0, i32 6
  %13 = load ptr, ptr %free_privdata4, align 8
  %14 = load ptr, ptr %bc.addr, align 8
  %privdata5 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %14, i32 0, i32 7
  %15 = load ptr, ptr %privdata5, align 8
  call void %13(ptr noundef %ctx, ptr noundef %15)
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnregisterAuthCBs(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr @moduleAuthCallbacks, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %ctx, align 8
  %3 = load ptr, ptr %ctx, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleAuthCtx, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %module1, align 8
  %5 = load ptr, ptr %module.addr, align 8
  %cmp = icmp eq ptr %4, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %6 = load ptr, ptr @moduleAuthCallbacks, align 8
  %7 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %ctx, align 8
  call void @zfree(ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !45

while.end:                                        ; preds = %while.cond
  ret void
}

declare void @listDelNode(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @attemptNextAuthCb(ptr noundef %c, ptr noundef %username, ptr noundef %password, ptr noundef %err) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %username.addr = alloca ptr, align 8
  %password.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %handle_next_callback = alloca i32, align 4
  %cur_auth_ctx = alloca ptr, align 8
  %ln = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %result = alloca i32, align 4
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %username, ptr %username.addr, align 8
  store ptr %password, ptr %password.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 67
  %1 = load ptr, ptr %module_auth_ctx, align 8
  %cmp = icmp eq ptr %1, null
  %conv = zext i1 %cmp to i32
  store i32 %conv, ptr %handle_next_callback, align 4
  store ptr null, ptr %cur_auth_ctx, align 8
  %2 = load ptr, ptr @moduleAuthCallbacks, align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  store i32 1, ptr %result, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end10, %if.then, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %cur_auth_ctx, align 8
  %5 = load i32, ptr %handle_next_callback, align 4
  %tobool1 = icmp ne i32 %5, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %6 = load ptr, ptr %cur_auth_ctx, align 8
  %7 = load ptr, ptr %c.addr, align 8
  %module_auth_ctx2 = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 67
  %8 = load ptr, ptr %module_auth_ctx2, align 8
  %cmp3 = icmp eq ptr %6, %8
  %conv4 = zext i1 %cmp3 to i32
  store i32 %conv4, ptr %handle_next_callback, align 4
  br label %while.cond, !llvm.loop !46

if.end:                                           ; preds = %while.body
  %9 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 1
  %10 = load i64, ptr %flags, align 8
  %and = and i64 %10, -140737488355329
  store i64 %and, ptr %flags, align 8
  %11 = load ptr, ptr %cur_auth_ctx, align 8
  %module = getelementptr inbounds %struct.RedisModuleAuthCtx, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %12, i32 noundef 0)
  %13 = load ptr, ptr %c.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %13, ptr %client, align 8
  %14 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %14, align 8
  %15 = load ptr, ptr %cur_auth_ctx, align 8
  %16 = load ptr, ptr %c.addr, align 8
  %module_auth_ctx5 = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 67
  store ptr %15, ptr %module_auth_ctx5, align 8
  %17 = load ptr, ptr %cur_auth_ctx, align 8
  %auth_cb = getelementptr inbounds %struct.RedisModuleAuthCtx, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %auth_cb, align 8
  %19 = load ptr, ptr %username.addr, align 8
  %20 = load ptr, ptr %password.addr, align 8
  %21 = load ptr, ptr %err.addr, align 8
  %call6 = call i32 %18(ptr noundef %ctx, ptr noundef %19, ptr noundef %20, ptr noundef %21)
  store i32 %call6, ptr %result, align 4
  call void @moduleFreeContext(ptr noundef %ctx)
  %22 = load i32, ptr %result, align 4
  %cmp7 = icmp eq i32 %22, 0
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  br label %while.end

if.end10:                                         ; preds = %if.end
  br label %while.cond, !llvm.loop !46

while.end:                                        ; preds = %if.then9, %while.cond
  %23 = load i32, ptr %result, align 4
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define dso_local i32 @attemptBlockedAuthReplyCallback(ptr noundef %c, ptr noundef %username, ptr noundef %password, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %username.addr = alloca ptr, align 8
  %password.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  %bc = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %username, ptr %username.addr, align 8
  store ptr %password, ptr %password.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  store i32 1, ptr %result, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %module_blocked_client = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 66
  %1 = load ptr, ptr %module_blocked_client, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %result, align 4
  store i32 %2, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %c.addr, align 8
  %module_blocked_client1 = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 66
  %4 = load ptr, ptr %module_blocked_client1, align 8
  store ptr %4, ptr %bc, align 8
  %5 = load ptr, ptr %c.addr, align 8
  %6 = load ptr, ptr %bc, align 8
  %client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %6, i32 0, i32 0
  store ptr %5, ptr %client, align 8
  %7 = load ptr, ptr %bc, align 8
  %auth_reply_cb = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %auth_reply_cb, align 8
  %tobool2 = icmp ne ptr %8, null
  br i1 %tobool2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %9 = load ptr, ptr %bc, align 8
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %10, i32 noundef 4)
  %11 = load ptr, ptr %bc, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %11, i32 0, i32 7
  %12 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 10
  store ptr %12, ptr %blocked_privdata, align 8
  %blocked_ready_key = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 11
  store ptr null, ptr %blocked_ready_key, align 8
  %13 = load ptr, ptr %bc, align 8
  %client4 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %client4, align 8
  %client5 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %14, ptr %client5, align 8
  %15 = load ptr, ptr %bc, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 3
  store ptr %15, ptr %blocked_client, align 8
  %16 = load ptr, ptr %bc, align 8
  %auth_reply_cb6 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %auth_reply_cb6, align 8
  %18 = load ptr, ptr %username.addr, align 8
  %19 = load ptr, ptr %password.addr, align 8
  %20 = load ptr, ptr %err.addr, align 8
  %call = call i32 %17(ptr noundef %ctx, ptr noundef %18, ptr noundef %19, ptr noundef %20)
  store i32 %call, ptr %result, align 4
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %if.end7

if.end7:                                          ; preds = %if.then3, %if.end
  %21 = load ptr, ptr %c.addr, align 8
  %22 = load ptr, ptr %bc, align 8
  call void @moduleInvokeFreePrivDataCallback(ptr noundef %21, ptr noundef %22)
  %23 = load ptr, ptr %c.addr, align 8
  %module_blocked_client8 = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 66
  store ptr null, ptr %module_blocked_client8, align 8
  %24 = load ptr, ptr %bc, align 8
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %24, i32 0, i32 14
  %25 = load i64, ptr %background_duration, align 8
  %26 = load ptr, ptr %c.addr, align 8
  %lastcmd = getelementptr inbounds %struct.client, ptr %26, i32 0, i32 18
  %27 = load ptr, ptr %lastcmd, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %27, i32 0, i32 22
  %28 = load i64, ptr %microseconds, align 8
  %add = add i64 %28, %25
  store i64 %add, ptr %microseconds, align 8
  %29 = load ptr, ptr %bc, align 8
  %module9 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %29, i32 0, i32 1
  %30 = load ptr, ptr %module9, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %30, i32 0, i32 13
  %31 = load i32, ptr %blocked_clients, align 8
  %dec = add nsw i32 %31, -1
  store i32 %dec, ptr %blocked_clients, align 8
  %32 = load ptr, ptr %bc, align 8
  call void @zfree(ptr noundef %32)
  %33 = load i32, ptr %result, align 4
  store i32 %33, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then
  %34 = load i32, ptr %retval, align 4
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define dso_local i32 @checkModuleAuthentication(ptr noundef %c, ptr noundef %username, ptr noundef %password, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %username.addr = alloca ptr, align 8
  %password.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %result = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %username, ptr %username.addr, align 8
  store ptr %password, ptr %password.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr @moduleAuthCallbacks, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 2, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load ptr, ptr %username.addr, align 8
  %4 = load ptr, ptr %password.addr, align 8
  %5 = load ptr, ptr %err.addr, align 8
  %call = call i32 @attemptBlockedAuthReplyCallback(ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5)
  store i32 %call, ptr %result, align 4
  %6 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %6, 1
  br i1 %cmp, label %if.then1, label %if.end3

if.then1:                                         ; preds = %if.end
  %7 = load ptr, ptr %c.addr, align 8
  %8 = load ptr, ptr %username.addr, align 8
  %9 = load ptr, ptr %password.addr, align 8
  %10 = load ptr, ptr %err.addr, align 8
  %call2 = call i32 @attemptNextAuthCb(ptr noundef %7, ptr noundef %8, ptr noundef %9, ptr noundef %10)
  store i32 %call2, ptr %result, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then1, %if.end
  %11 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %flags, align 8
  %and = and i64 %12, 16
  %tobool4 = icmp ne i64 %and, 0
  br i1 %tobool4, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end3
  %13 = load i32, ptr %result, align 4
  %cmp6 = icmp eq i32 %13, 0
  %lnot = xor i1 %cmp6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then5
  br label %cond.end

cond.false:                                       ; preds = %if.then5
  call void @_serverAssert(ptr noundef @.str.74, ptr noundef @.str.2, i32 noundef 7949)
  call void @abort() #13
  unreachable

14:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %14, %cond.true
  store i32 3, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end3
  %15 = load ptr, ptr %c.addr, align 8
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 67
  store ptr null, ptr %module_auth_ctx, align 8
  %16 = load i32, ptr %result, align 4
  %cmp10 = icmp eq i32 %16, 1
  br i1 %cmp10, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end9
  %17 = load ptr, ptr %c.addr, align 8
  %flags13 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 1
  %18 = load i64, ptr %flags13, align 8
  %and14 = and i64 %18, -140737488355329
  store i64 %and14, ptr %flags13, align 8
  store i32 2, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end9
  %19 = load ptr, ptr %c.addr, align 8
  %flags16 = getelementptr inbounds %struct.client, ptr %19, i32 0, i32 1
  %20 = load i64, ptr %flags16, align 8
  %and17 = and i64 %20, 140737488355328
  %tobool18 = icmp ne i64 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.end25

if.then19:                                        ; preds = %if.end15
  %21 = load ptr, ptr %c.addr, align 8
  %flags20 = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 1
  %22 = load i64, ptr %flags20, align 8
  %and21 = and i64 %22, -140737488355329
  store i64 %and21, ptr %flags20, align 8
  %23 = load ptr, ptr %c.addr, align 8
  %authenticated = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 34
  %24 = load i32, ptr %authenticated, align 8
  %tobool22 = icmp ne i32 %24, 0
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then19
  store i32 0, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then19
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end15
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end25, %if.then23, %if.then12, %cond.end, %if.then
  %25 = load i32, ptr %retval, align 4
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleTryServeClientBlockedOnKey(ptr noundef %c, ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %served = alloca i32, align 4
  %bc = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 0, ptr %served, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 55
  %module_blocked_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 7
  %1 = load ptr, ptr %module_blocked_handle, align 8
  store ptr %1, ptr %bc, align 8
  %2 = load ptr, ptr %bc, align 8
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %2, i32 0, i32 12
  %3 = load i32, ptr %unblocked, align 8
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %bc, align 8
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %5, i32 noundef 4)
  %6 = load ptr, ptr %key.addr, align 8
  %blocked_ready_key = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 11
  store ptr %6, ptr %blocked_ready_key, align 8
  %7 = load ptr, ptr %bc, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %7, i32 0, i32 7
  %8 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 10
  store ptr %8, ptr %blocked_privdata, align 8
  %9 = load ptr, ptr %bc, align 8
  %client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %client, align 8
  %client1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %10, ptr %client1, align 8
  %11 = load ptr, ptr %bc, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 3
  store ptr %11, ptr %blocked_client, align 8
  %12 = load ptr, ptr %bc, align 8
  %reply_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %reply_callback, align 8
  %14 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 12
  %15 = load ptr, ptr %argv, align 8
  %16 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 11
  %17 = load i32, ptr %argc, align 8
  %call = call i32 %13(ptr noundef %ctx, ptr noundef %15, i32 noundef %17)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, ptr %served, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  call void @moduleFreeContext(ptr noundef %ctx)
  %18 = load i32, ptr %served, align 4
  store i32 %18, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_BlockClient(ptr noundef %ctx, ptr noundef %reply_callback, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %reply_callback.addr = alloca ptr, align 8
  %timeout_callback.addr = alloca ptr, align 8
  %free_privdata.addr = alloca ptr, align 8
  %timeout_ms.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %reply_callback, ptr %reply_callback.addr, align 8
  store ptr %timeout_callback, ptr %timeout_callback.addr, align 8
  store ptr %free_privdata, ptr %free_privdata.addr, align 8
  store i64 %timeout_ms, ptr %timeout_ms.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %reply_callback.addr, align 8
  %2 = load ptr, ptr %timeout_callback.addr, align 8
  %3 = load ptr, ptr %free_privdata.addr, align 8
  %4 = load i64, ptr %timeout_ms.addr, align 8
  %call = call ptr @moduleBlockClient(ptr noundef %0, ptr noundef %1, ptr noundef null, ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr noundef null, i32 noundef 0, ptr noundef null, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_BlockClientOnAuth(ptr noundef %ctx, ptr noundef %reply_callback, ptr noundef %free_privdata) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %reply_callback.addr = alloca ptr, align 8
  %free_privdata.addr = alloca ptr, align 8
  %bc = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %reply_callback, ptr %reply_callback.addr, align 8
  store ptr %free_privdata, ptr %free_privdata.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 67
  %2 = load ptr, ptr %module_auth_ctx, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %client1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %client1, align 8
  call void @addReplyError(ptr noundef %4, ptr noundef @.str.75)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %ctx.addr, align 8
  %6 = load ptr, ptr %reply_callback.addr, align 8
  %7 = load ptr, ptr %free_privdata.addr, align 8
  %call = call ptr @moduleBlockClient(ptr noundef %5, ptr noundef null, ptr noundef %6, ptr noundef null, ptr noundef %7, i64 noundef 0, ptr noundef null, i32 noundef 0, ptr noundef null, i32 noundef 0)
  store ptr %call, ptr %bc, align 8
  %8 = load ptr, ptr %ctx.addr, align 8
  %client2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %client2, align 8
  %flags = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 1
  %10 = load i64, ptr %flags, align 8
  %and = and i64 %10, 16
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %ctx.addr, align 8
  %client4 = getelementptr inbounds %struct.RedisModuleCtx, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %client4, align 8
  %flags5 = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 1
  %13 = load i64, ptr %flags5, align 8
  %or = or i64 %13, 1073741824
  store i64 %or, ptr %flags5, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %14 = load ptr, ptr %bc, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_BlockClientGetPrivateData(ptr noundef %blocked_client) #0 {
entry:
  %blocked_client.addr = alloca ptr, align 8
  store ptr %blocked_client, ptr %blocked_client.addr, align 8
  %0 = load ptr, ptr %blocked_client.addr, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i32 0, i32 7
  %1 = load ptr, ptr %privdata, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_BlockClientSetPrivateData(ptr noundef %blocked_client, ptr noundef %private_data) #0 {
entry:
  %blocked_client.addr = alloca ptr, align 8
  %private_data.addr = alloca ptr, align 8
  store ptr %blocked_client, ptr %blocked_client.addr, align 8
  store ptr %private_data, ptr %private_data.addr, align 8
  %0 = load ptr, ptr %private_data.addr, align 8
  %1 = load ptr, ptr %blocked_client.addr, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i32 0, i32 7
  store ptr %0, ptr %privdata, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_BlockClientOnKeys(ptr noundef %ctx, ptr noundef %reply_callback, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef %keys, i32 noundef %numkeys, ptr noundef %privdata) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %reply_callback.addr = alloca ptr, align 8
  %timeout_callback.addr = alloca ptr, align 8
  %free_privdata.addr = alloca ptr, align 8
  %timeout_ms.addr = alloca i64, align 8
  %keys.addr = alloca ptr, align 8
  %numkeys.addr = alloca i32, align 4
  %privdata.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %reply_callback, ptr %reply_callback.addr, align 8
  store ptr %timeout_callback, ptr %timeout_callback.addr, align 8
  store ptr %free_privdata, ptr %free_privdata.addr, align 8
  store i64 %timeout_ms, ptr %timeout_ms.addr, align 8
  store ptr %keys, ptr %keys.addr, align 8
  store i32 %numkeys, ptr %numkeys.addr, align 4
  store ptr %privdata, ptr %privdata.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %reply_callback.addr, align 8
  %2 = load ptr, ptr %timeout_callback.addr, align 8
  %3 = load ptr, ptr %free_privdata.addr, align 8
  %4 = load i64, ptr %timeout_ms.addr, align 8
  %5 = load ptr, ptr %keys.addr, align 8
  %6 = load i32, ptr %numkeys.addr, align 4
  %7 = load ptr, ptr %privdata.addr, align 8
  %call = call ptr @moduleBlockClient(ptr noundef %0, ptr noundef %1, ptr noundef null, ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, ptr noundef %7, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_BlockClientOnKeysWithFlags(ptr noundef %ctx, ptr noundef %reply_callback, ptr noundef %timeout_callback, ptr noundef %free_privdata, i64 noundef %timeout_ms, ptr noundef %keys, i32 noundef %numkeys, ptr noundef %privdata, i32 noundef %flags) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %reply_callback.addr = alloca ptr, align 8
  %timeout_callback.addr = alloca ptr, align 8
  %free_privdata.addr = alloca ptr, align 8
  %timeout_ms.addr = alloca i64, align 8
  %keys.addr = alloca ptr, align 8
  %numkeys.addr = alloca i32, align 4
  %privdata.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %reply_callback, ptr %reply_callback.addr, align 8
  store ptr %timeout_callback, ptr %timeout_callback.addr, align 8
  store ptr %free_privdata, ptr %free_privdata.addr, align 8
  store i64 %timeout_ms, ptr %timeout_ms.addr, align 8
  store ptr %keys, ptr %keys.addr, align 8
  store i32 %numkeys, ptr %numkeys.addr, align 4
  store ptr %privdata, ptr %privdata.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %reply_callback.addr, align 8
  %2 = load ptr, ptr %timeout_callback.addr, align 8
  %3 = load ptr, ptr %free_privdata.addr, align 8
  %4 = load i64, ptr %timeout_ms.addr, align 8
  %5 = load ptr, ptr %keys.addr, align 8
  %6 = load i32, ptr %numkeys.addr, align 4
  %7 = load ptr, ptr %privdata.addr, align 8
  %8 = load i32, ptr %flags.addr, align 4
  %call = call ptr @moduleBlockClient(ptr noundef %0, ptr noundef %1, ptr noundef null, ptr noundef %2, ptr noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %6, ptr noundef %7, i32 noundef %8)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SignalKeyAsReady(ptr noundef %ctx, ptr noundef %key) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %db, align 8
  %3 = load ptr, ptr %key.addr, align 8
  call void @signalKeyAsReady(ptr noundef %2, ptr noundef %3, i32 noundef 5)
  ret void
}

declare void @signalKeyAsReady(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleUnblockClientByHandle(ptr noundef %bc, ptr noundef %privdata) #0 {
entry:
  %bc.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  store ptr %bc, ptr %bc.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  %call = call i32 @pthread_mutex_lock(ptr noundef @moduleUnblockedClientsMutex) #16
  %0 = load ptr, ptr %bc.addr, align 8
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %blocked_on_keys, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %privdata.addr, align 8
  %3 = load ptr, ptr %bc.addr, align 8
  %privdata1 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %3, i32 0, i32 7
  store ptr %2, ptr %privdata1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %bc.addr, align 8
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %4, i32 0, i32 12
  store i32 1, ptr %unblocked, align 8
  %5 = load ptr, ptr @moduleUnblockedClients, align 8
  %len = getelementptr inbounds %struct.list, ptr %5, i32 0, i32 5
  %6 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %6, 0
  br i1 %cmp, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.end
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 41, i64 1), align 4
  %call3 = call i64 @write(i32 noundef %7, ptr noundef @.str.76, i64 noundef 1)
  %cmp4 = icmp ne i64 %call3, 1
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then2
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then2
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.end
  %8 = load ptr, ptr @moduleUnblockedClients, align 8
  %9 = load ptr, ptr %bc.addr, align 8
  %call8 = call ptr @listAddNodeTail(ptr noundef %8, ptr noundef %9)
  %call9 = call i32 @pthread_mutex_unlock(ptr noundef @moduleUnblockedClientsMutex) #16
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_lock(ptr noundef) #10

declare i64 @write(i32 noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind
declare i32 @pthread_mutex_unlock(ptr noundef) #10

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleClientIsBlockedOnKeys(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %bc = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 55
  %module_blocked_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 7
  %1 = load ptr, ptr %module_blocked_handle, align 8
  store ptr %1, ptr %bc, align 8
  %2 = load ptr, ptr %bc, align 8
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %2, i32 0, i32 11
  %3 = load i32, ptr %blocked_on_keys, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_UnblockClient(ptr noundef %bc, ptr noundef %privdata) #0 {
entry:
  %retval = alloca i32, align 4
  %bc.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  store ptr %bc, ptr %bc.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  %0 = load ptr, ptr %bc.addr, align 8
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %blocked_on_keys, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end9

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %bc.addr, align 8
  %timeout_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %timeout_callback, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %4 = load ptr, ptr %bc.addr, align 8
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %4, i32 0, i32 12
  %5 = load i32, ptr %unblocked, align 8
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %bc.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %client, align 8
  %tobool5 = icmp ne ptr %7, null
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %8 = load ptr, ptr %bc.addr, align 8
  %client7 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %client7, align 8
  call void @moduleBlockedClientTimedOut(ptr noundef %9)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %entry
  %10 = load ptr, ptr %bc.addr, align 8
  %11 = load ptr, ptr %privdata.addr, align 8
  %call = call i32 @moduleUnblockClientByHandle(ptr noundef %10, ptr noundef %11)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then3, %if.then1
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleBlockedClientTimedOut(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %bc = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %prev_error_replies = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 55
  %module_blocked_handle = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 7
  %1 = load ptr, ptr %module_blocked_handle, align 8
  store ptr %1, ptr %bc, align 8
  %2 = load ptr, ptr %bc, align 8
  %unblocked = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %2, i32 0, i32 12
  %3 = load i32, ptr %unblocked, align 8
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %bc, align 8
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %5, i32 noundef 8)
  %6 = load ptr, ptr %bc, align 8
  %client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %client, align 8
  %client1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %7, ptr %client1, align 8
  %8 = load ptr, ptr %bc, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 3
  store ptr %8, ptr %blocked_client, align 8
  %9 = load ptr, ptr %bc, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %9, i32 0, i32 7
  %10 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 10
  store ptr %10, ptr %blocked_privdata, align 8
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 140), align 8
  store i64 %11, ptr %prev_error_replies, align 8
  %12 = load ptr, ptr %bc, align 8
  %timeout_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %timeout_callback, align 8
  %14 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 12
  %15 = load ptr, ptr %argv, align 8
  %16 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 11
  %17 = load i32, ptr %argc, align 8
  %call = call i32 %13(ptr noundef %ctx, ptr noundef %15, i32 noundef %17)
  call void @moduleFreeContext(ptr noundef %ctx)
  %18 = load ptr, ptr %c.addr, align 8
  %19 = load ptr, ptr %bc, align 8
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %19, i32 0, i32 14
  %20 = load i64, ptr %background_duration, align 8
  %21 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 140), align 8
  %22 = load i64, ptr %prev_error_replies, align 8
  %cmp = icmp ne i64 %21, %22
  %conv = zext i1 %cmp to i32
  call void @updateStatsOnUnblock(ptr noundef %18, i64 noundef %20, i64 noundef 0, i32 noundef %conv)
  %23 = load ptr, ptr %bc, align 8
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %23, i32 0, i32 5
  store ptr null, ptr %disconnect_callback, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_AbortBlock(ptr noundef %bc) #0 {
entry:
  %bc.addr = alloca ptr, align 8
  store ptr %bc, ptr %bc.addr, align 8
  %0 = load ptr, ptr %bc.addr, align 8
  %reply_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %0, i32 0, i32 2
  store ptr null, ptr %reply_callback, align 8
  %1 = load ptr, ptr %bc.addr, align 8
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i32 0, i32 5
  store ptr null, ptr %disconnect_callback, align 8
  %2 = load ptr, ptr %bc.addr, align 8
  %auth_reply_cb = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %2, i32 0, i32 3
  store ptr null, ptr %auth_reply_cb, align 8
  %3 = load ptr, ptr %bc.addr, align 8
  %call = call i32 @RM_UnblockClient(ptr noundef %3, ptr noundef null)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_SetDisconnectCallback(ptr noundef %bc, ptr noundef %callback) #0 {
entry:
  %bc.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  store ptr %bc, ptr %bc.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  %0 = load ptr, ptr %callback.addr, align 8
  %1 = load ptr, ptr %bc.addr, align 8
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i32 0, i32 5
  store ptr %0, ptr %disconnect_callback, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleHandleBlockedClients() #0 {
entry:
  %ln = alloca ptr, align 8
  %bc = alloca ptr, align 8
  %c = alloca ptr, align 8
  %prev_error_replies = alloca i64, align 8
  %reply_us = alloca i64, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %replyTimer = alloca i64, align 8
  %call = call i32 @pthread_mutex_lock(ptr noundef @moduleUnblockedClientsMutex) #16
  br label %while.cond

while.cond:                                       ; preds = %if.end51, %entry
  %0 = load ptr, ptr @moduleUnblockedClients, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr @moduleUnblockedClients, align 8
  %head = getelementptr inbounds %struct.list, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %head, align 8
  store ptr %3, ptr %ln, align 8
  %4 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %value, align 8
  store ptr %5, ptr %bc, align 8
  %6 = load ptr, ptr %bc, align 8
  %client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %client, align 8
  store ptr %7, ptr %c, align 8
  %8 = load ptr, ptr @moduleUnblockedClients, align 8
  %9 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %8, ptr noundef %9)
  %call1 = call i32 @pthread_mutex_unlock(ptr noundef @moduleUnblockedClientsMutex) #16
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 140), align 8
  store i64 %10, ptr %prev_error_replies, align 8
  store i64 0, ptr %reply_us, align 8
  %11 = load ptr, ptr %c, align 8
  %tobool2 = icmp ne ptr %11, null
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %12 = load ptr, ptr %bc, align 8
  %blocked_on_keys = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %12, i32 0, i32 11
  %13 = load i32, ptr %blocked_on_keys, align 4
  %tobool3 = icmp ne i32 %13, 0
  br i1 %tobool3, label %if.end, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %14 = load ptr, ptr %bc, align 8
  %reply_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %reply_callback, align 8
  %tobool5 = icmp ne ptr %15, null
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %16 = load ptr, ptr %bc, align 8
  %module = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %17, i32 noundef 4)
  %18 = load ptr, ptr %bc, align 8
  %privdata = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %18, i32 0, i32 7
  %19 = load ptr, ptr %privdata, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 10
  store ptr %19, ptr %blocked_privdata, align 8
  %blocked_ready_key = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 11
  store ptr null, ptr %blocked_ready_key, align 8
  %20 = load ptr, ptr %bc, align 8
  %client6 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %client6, align 8
  %client7 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %21, ptr %client7, align 8
  %22 = load ptr, ptr %bc, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 3
  store ptr %22, ptr %blocked_client, align 8
  call void @elapsedStart(ptr noundef %replyTimer)
  %23 = load ptr, ptr %bc, align 8
  %reply_callback8 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %23, i32 0, i32 2
  %24 = load ptr, ptr %reply_callback8, align 8
  %25 = load ptr, ptr %c, align 8
  %argv = getelementptr inbounds %struct.client, ptr %25, i32 0, i32 12
  %26 = load ptr, ptr %argv, align 8
  %27 = load ptr, ptr %c, align 8
  %argc = getelementptr inbounds %struct.client, ptr %27, i32 0, i32 11
  %28 = load i32, ptr %argc, align 8
  %call9 = call i32 %24(ptr noundef %ctx, ptr noundef %26, i32 noundef %28)
  %29 = load i64, ptr %replyTimer, align 8
  %call10 = call i64 @elapsedUs(i64 noundef %29)
  store i64 %call10, ptr %reply_us, align 8
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true4, %land.lhs.true, %while.body
  %30 = load ptr, ptr %c, align 8
  %tobool11 = icmp ne ptr %30, null
  br i1 %tobool11, label %land.lhs.true12, label %if.else

land.lhs.true12:                                  ; preds = %if.end
  %31 = load ptr, ptr %c, align 8
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %31, i32 0, i32 67
  %32 = load ptr, ptr %module_auth_ctx, align 8
  %cmp = icmp ne ptr %32, null
  br i1 %cmp, label %if.then13, label %if.else

if.then13:                                        ; preds = %land.lhs.true12
  %33 = load ptr, ptr %bc, align 8
  %34 = load ptr, ptr %c, align 8
  %module_blocked_client = getelementptr inbounds %struct.client, ptr %34, i32 0, i32 66
  store ptr %33, ptr %module_blocked_client, align 8
  br label %if.end14

if.else:                                          ; preds = %land.lhs.true12, %if.end
  %35 = load ptr, ptr %c, align 8
  %36 = load ptr, ptr %bc, align 8
  call void @moduleInvokeFreePrivDataCallback(ptr noundef %35, ptr noundef %36)
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then13
  %37 = load ptr, ptr %c, align 8
  %tobool15 = icmp ne ptr %37, null
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end14
  %38 = load ptr, ptr %c, align 8
  %39 = load ptr, ptr %bc, align 8
  %reply_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %39, i32 0, i32 9
  %40 = load ptr, ptr %reply_client, align 8
  call void @AddReplyFromClient(ptr noundef %38, ptr noundef %40)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end14
  %41 = load ptr, ptr %bc, align 8
  %reply_client18 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %41, i32 0, i32 9
  %42 = load ptr, ptr %reply_client18, align 8
  call void @moduleReleaseTempClient(ptr noundef %42)
  %43 = load ptr, ptr %bc, align 8
  %thread_safe_ctx_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %43, i32 0, i32 8
  %44 = load ptr, ptr %thread_safe_ctx_client, align 8
  call void @moduleReleaseTempClient(ptr noundef %44)
  %45 = load ptr, ptr %c, align 8
  %tobool19 = icmp ne ptr %45, null
  br i1 %tobool19, label %land.lhs.true20, label %if.end28

land.lhs.true20:                                  ; preds = %if.end17
  %46 = load ptr, ptr %c, align 8
  %module_auth_ctx21 = getelementptr inbounds %struct.client, ptr %46, i32 0, i32 67
  %47 = load ptr, ptr %module_auth_ctx21, align 8
  %cmp22 = icmp ne ptr %47, null
  br i1 %cmp22, label %if.end28, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %land.lhs.true20
  %48 = load ptr, ptr %bc, align 8
  %blocked_on_keys24 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %48, i32 0, i32 11
  %49 = load i32, ptr %blocked_on_keys24, align 4
  %tobool25 = icmp ne i32 %49, 0
  br i1 %tobool25, label %if.end28, label %if.then26

if.then26:                                        ; preds = %land.lhs.true23
  %50 = load ptr, ptr %c, align 8
  %51 = load ptr, ptr %bc, align 8
  %background_duration = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %51, i32 0, i32 14
  %52 = load i64, ptr %background_duration, align 8
  %53 = load i64, ptr %reply_us, align 8
  %54 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 140), align 8
  %55 = load i64, ptr %prev_error_replies, align 8
  %cmp27 = icmp ne i64 %54, %55
  %conv = zext i1 %cmp27 to i32
  call void @updateStatsOnUnblock(ptr noundef %50, i64 noundef %52, i64 noundef %53, i32 noundef %conv)
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %land.lhs.true23, %land.lhs.true20, %if.end17
  %56 = load ptr, ptr %c, align 8
  %cmp29 = icmp ne ptr %56, null
  br i1 %cmp29, label %if.then31, label %if.end43

if.then31:                                        ; preds = %if.end28
  %57 = load ptr, ptr %bc, align 8
  %disconnect_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %57, i32 0, i32 5
  store ptr null, ptr %disconnect_callback, align 8
  %58 = load ptr, ptr %c, align 8
  call void @unblockClient(ptr noundef %58, i32 noundef 1)
  %59 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %60 = load ptr, ptr %c, align 8
  %woff = getelementptr inbounds %struct.client, ptr %60, i32 0, i32 56
  store i64 %59, ptr %woff, align 8
  %61 = load ptr, ptr %c, align 8
  %module_auth_ctx32 = getelementptr inbounds %struct.client, ptr %61, i32 0, i32 67
  %62 = load ptr, ptr %module_auth_ctx32, align 8
  %cmp33 = icmp ne ptr %62, null
  br i1 %cmp33, label %if.end42, label %land.lhs.true35

land.lhs.true35:                                  ; preds = %if.then31
  %63 = load ptr, ptr %c, align 8
  %call36 = call i32 @clientHasPendingReplies(ptr noundef %63)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %land.lhs.true38, label %if.end42

land.lhs.true38:                                  ; preds = %land.lhs.true35
  %64 = load ptr, ptr %c, align 8
  %flags = getelementptr inbounds %struct.client, ptr %64, i32 0, i32 1
  %65 = load i64, ptr %flags, align 8
  %and = and i64 %65, 2097152
  %tobool39 = icmp ne i64 %and, 0
  br i1 %tobool39, label %if.end42, label %if.then40

if.then40:                                        ; preds = %land.lhs.true38
  %66 = load ptr, ptr %c, align 8
  %flags41 = getelementptr inbounds %struct.client, ptr %66, i32 0, i32 1
  %67 = load i64, ptr %flags41, align 8
  %or = or i64 %67, 2097152
  store i64 %or, ptr %flags41, align 8
  %68 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 57), align 8
  %69 = load ptr, ptr %c, align 8
  %clients_pending_write_node = getelementptr inbounds %struct.client, ptr %69, i32 0, i32 79
  call void @listLinkNodeHead(ptr noundef %68, ptr noundef %clients_pending_write_node)
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %land.lhs.true38, %land.lhs.true35, %if.then31
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.end28
  %70 = load ptr, ptr %c, align 8
  %tobool44 = icmp ne ptr %70, null
  br i1 %tobool44, label %land.lhs.true45, label %if.then49

land.lhs.true45:                                  ; preds = %if.end43
  %71 = load ptr, ptr %c, align 8
  %module_auth_ctx46 = getelementptr inbounds %struct.client, ptr %71, i32 0, i32 67
  %72 = load ptr, ptr %module_auth_ctx46, align 8
  %cmp47 = icmp ne ptr %72, null
  br i1 %cmp47, label %if.end51, label %if.then49

if.then49:                                        ; preds = %land.lhs.true45, %if.end43
  %73 = load ptr, ptr %bc, align 8
  %module50 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %73, i32 0, i32 1
  %74 = load ptr, ptr %module50, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %74, i32 0, i32 13
  %75 = load i32, ptr %blocked_clients, align 8
  %dec = add nsw i32 %75, -1
  store i32 %dec, ptr %blocked_clients, align 8
  %76 = load ptr, ptr %bc, align 8
  call void @zfree(ptr noundef %76)
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %land.lhs.true45
  %call52 = call i32 @pthread_mutex_lock(ptr noundef @moduleUnblockedClientsMutex) #16
  br label %while.cond, !llvm.loop !47

while.end:                                        ; preds = %while.cond
  %call53 = call i32 @pthread_mutex_unlock(ptr noundef @moduleUnblockedClientsMutex) #16
  ret void
}

declare void @AddReplyFromClient(ptr noundef, ptr noundef) #1

declare void @updateStatsOnUnblock(ptr noundef, i64 noundef, i64 noundef, i32 noundef) #1

declare i32 @clientHasPendingReplies(ptr noundef) #1

declare void @listLinkNodeHead(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleBlockedClientMayTimeout(ptr noundef %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %bc = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %bstate = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 55
  %btype = getelementptr inbounds %struct.blockingState, ptr %bstate, i32 0, i32 0
  %1 = load i32, ptr %btype, align 8
  %cmp = icmp ne i32 %1, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %bstate1 = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 55
  %module_blocked_handle = getelementptr inbounds %struct.blockingState, ptr %bstate1, i32 0, i32 7
  %3 = load ptr, ptr %module_blocked_handle, align 8
  store ptr %3, ptr %bc, align 8
  %4 = load ptr, ptr %bc, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %5 = load ptr, ptr %bc, align 8
  %timeout_callback = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %timeout_callback, align 8
  %cmp2 = icmp ne ptr %6, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %7 = phi i1 [ false, %if.end ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %7 to i32
  store i32 %land.ext, ptr %retval, align 4
  br label %return

return:                                           ; preds = %land.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_IsBlockedReplyRequest(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 4
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_IsBlockedTimeoutRequest(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 8
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetBlockedClientPrivateData(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %blocked_privdata = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 10
  %1 = load ptr, ptr %blocked_privdata, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetBlockedClientReadyKey(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %blocked_ready_key = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 11
  %1 = load ptr, ptr %blocked_ready_key, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetBlockedClientHandle(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %blocked_client, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_BlockedClientDisconnected(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 32
  %cmp = icmp ne i32 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetThreadSafeContext(ptr noundef %bc) #0 {
entry:
  %bc.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %module = alloca ptr, align 8
  %flags = alloca i32, align 4
  store ptr %bc, ptr %bc.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 120) #11
  store ptr %call, ptr %ctx, align 8
  %0 = load ptr, ptr %bc.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %bc.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %2, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %module, align 8
  store i32 16, ptr %flags, align 4
  %3 = load ptr, ptr %bc.addr, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %4 = load i32, ptr %flags, align 4
  %or = or i32 %4, 128
  store i32 %or, ptr %flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %5 = load ptr, ptr %ctx, align 8
  %6 = load ptr, ptr %module, align 8
  %7 = load i32, ptr %flags, align 4
  call void @moduleCreateContext(ptr noundef %5, ptr noundef %6, i32 noundef %7)
  %8 = load ptr, ptr %bc.addr, align 8
  %tobool3 = icmp ne ptr %8, null
  br i1 %tobool3, label %if.then4, label %if.end17

if.then4:                                         ; preds = %if.end
  %9 = load ptr, ptr %bc.addr, align 8
  %10 = load ptr, ptr %ctx, align 8
  %blocked_client = getelementptr inbounds %struct.RedisModuleCtx, ptr %10, i32 0, i32 3
  store ptr %9, ptr %blocked_client, align 8
  %11 = load ptr, ptr %bc.addr, align 8
  %thread_safe_ctx_client = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %11, i32 0, i32 8
  %12 = load ptr, ptr %thread_safe_ctx_client, align 8
  %13 = load ptr, ptr %ctx, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %13, i32 0, i32 2
  store ptr %12, ptr %client, align 8
  %14 = load ptr, ptr %ctx, align 8
  %client5 = getelementptr inbounds %struct.RedisModuleCtx, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %client5, align 8
  %16 = load ptr, ptr %bc.addr, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %16, i32 0, i32 10
  %17 = load i32, ptr %dbid, align 8
  %call6 = call i32 @selectDb(ptr noundef %15, i32 noundef %17)
  %18 = load ptr, ptr %bc.addr, align 8
  %client7 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %client7, align 8
  %tobool8 = icmp ne ptr %19, null
  br i1 %tobool8, label %if.then9, label %if.end16

if.then9:                                         ; preds = %if.then4
  %20 = load ptr, ptr %bc.addr, align 8
  %client10 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %client10, align 8
  %id = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 0
  %22 = load i64, ptr %id, align 8
  %23 = load ptr, ptr %ctx, align 8
  %client11 = getelementptr inbounds %struct.RedisModuleCtx, ptr %23, i32 0, i32 2
  %24 = load ptr, ptr %client11, align 8
  %id12 = getelementptr inbounds %struct.client, ptr %24, i32 0, i32 0
  store i64 %22, ptr %id12, align 8
  %25 = load ptr, ptr %bc.addr, align 8
  %client13 = getelementptr inbounds %struct.RedisModuleBlockedClient, ptr %25, i32 0, i32 0
  %26 = load ptr, ptr %client13, align 8
  %resp = getelementptr inbounds %struct.client, ptr %26, i32 0, i32 3
  %27 = load i32, ptr %resp, align 8
  %28 = load ptr, ptr %ctx, align 8
  %client14 = getelementptr inbounds %struct.RedisModuleCtx, ptr %28, i32 0, i32 2
  %29 = load ptr, ptr %client14, align 8
  %resp15 = getelementptr inbounds %struct.client, ptr %29, i32 0, i32 3
  store i32 %27, ptr %resp15, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then9, %if.then4
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end
  %30 = load ptr, ptr %ctx, align 8
  ret ptr %30
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetDetachedThreadSafeContext(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %new_ctx = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 120) #11
  store ptr %call, ptr %new_ctx, align 8
  %0 = load ptr, ptr %new_ctx, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %0, ptr noundef %2, i32 noundef 144)
  %3 = load ptr, ptr %new_ctx, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeThreadSafeContext(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  call void @moduleFreeContext(ptr noundef %0)
  %1 = load ptr, ptr %ctx.addr, align 8
  call void @zfree(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleGILAfterLock() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %cmp = icmp eq i32 %0, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.77, ptr noundef @.str.2, i32 noundef 8501)
  call void @abort() #13
  unreachable

1:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %1, %cond.true
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef 0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ThreadSafeContextLock(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  call void @moduleAcquireGIL()
  call void @moduleGILAfterLock()
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleAcquireGIL() #0 {
entry:
  %call = call i32 @pthread_mutex_lock(ptr noundef @moduleGIL) #16
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ThreadSafeContextTryLock(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %res = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  %call = call i32 @moduleTryAcquireGIL()
  store i32 %call, ptr %res, align 4
  %0 = load i32, ptr %res, align 4
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %res, align 4
  %call1 = call ptr @__errno_location() #15
  store i32 %1, ptr %call1, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  call void @moduleGILAfterLock()
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleTryAcquireGIL() #0 {
entry:
  %call = call i32 @pthread_mutex_trylock(ptr noundef @moduleGIL) #16
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleGILBeforeUnlock() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %cmp = icmp eq i32 %0, 1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.78, ptr noundef @.str.2, i32 noundef 8538)
  call void @abort() #13
  unreachable

1:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %1, %cond.true
  call void @exitExecutionUnit()
  call void @postExecutionUnitOperations()
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ThreadSafeContextUnlock(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  call void @moduleGILBeforeUnlock()
  call void @moduleReleaseGIL()
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleReleaseGIL() #0 {
entry:
  %call = call i32 @pthread_mutex_unlock(ptr noundef @moduleGIL) #16
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_mutex_trylock(ptr noundef) #10

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SubscribeToKeyspaceEvents(ptr noundef %ctx, i32 noundef %types, ptr noundef %callback) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %types.addr = alloca i32, align 4
  %callback.addr = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %types, ptr %types.addr, align 4
  store ptr %callback, ptr %callback.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 24) #11
  store ptr %call, ptr %sub, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %2 = load ptr, ptr %sub, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %2, i32 0, i32 0
  store ptr %1, ptr %module1, align 8
  %3 = load i32, ptr %types.addr, align 4
  %4 = load ptr, ptr %sub, align 8
  %event_mask = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %4, i32 0, i32 2
  store i32 %3, ptr %event_mask, align 8
  %5 = load ptr, ptr %callback.addr, align 8
  %6 = load ptr, ptr %sub, align 8
  %notify_callback = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %6, i32 0, i32 1
  store ptr %5, ptr %notify_callback, align 8
  %7 = load ptr, ptr %sub, align 8
  %active = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %7, i32 0, i32 3
  store i32 0, ptr %active, align 4
  %8 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  %9 = load ptr, ptr %sub, align 8
  %call2 = call ptr @listAddNodeTail(ptr noundef %8, ptr noundef %9)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local void @firePostExecutionUnitJobs() #0 {
entry:
  %ln = alloca ptr, align 8
  %job = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  call void @enterExecutionUnit(i32 noundef 0, i64 noundef 0)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load ptr, ptr @modulePostExecUnitJobs, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp ugt i64 %1, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr @modulePostExecUnitJobs, align 8
  %head = getelementptr inbounds %struct.list, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %head, align 8
  store ptr %3, ptr %ln, align 8
  %4 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %value, align 8
  store ptr %5, ptr %job, align 8
  %6 = load ptr, ptr @modulePostExecUnitJobs, align 8
  %7 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %job, align 8
  %module = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %9, i32 noundef 64)
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  %10 = load ptr, ptr %client, align 8
  %11 = load ptr, ptr %job, align 8
  %dbid = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %11, i32 0, i32 4
  %12 = load i32, ptr %dbid, align 8
  %call = call i32 @selectDb(ptr noundef %10, i32 noundef %12)
  %13 = load ptr, ptr %job, align 8
  %callback = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %callback, align 8
  %15 = load ptr, ptr %job, align 8
  %pd = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %pd, align 8
  call void %14(ptr noundef %ctx, ptr noundef %16)
  %17 = load ptr, ptr %job, align 8
  %free_pd = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %free_pd, align 8
  %tobool = icmp ne ptr %18, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %19 = load ptr, ptr %job, align 8
  %free_pd1 = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %19, i32 0, i32 3
  %20 = load ptr, ptr %free_pd1, align 8
  %21 = load ptr, ptr %job, align 8
  %pd2 = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %21, i32 0, i32 2
  %22 = load ptr, ptr %pd2, align 8
  call void %20(ptr noundef %22)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  call void @moduleFreeContext(ptr noundef %ctx)
  %23 = load ptr, ptr %job, align 8
  call void @zfree(ptr noundef %23)
  br label %while.cond, !llvm.loop !48

while.end:                                        ; preds = %while.cond
  call void @exitExecutionUnit()
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_AddPostNotificationJob(ptr noundef %ctx, ptr noundef %callback, ptr noundef %privdata, ptr noundef %free_privdata) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %free_privdata.addr = alloca ptr, align 8
  %job = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  store ptr %free_privdata, ptr %free_privdata.addr, align 8
  %0 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 298), align 4
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %call = call noalias ptr @zmalloc(i64 noundef 40) #11
  store ptr %call, ptr %job, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %module, align 8
  %5 = load ptr, ptr %job, align 8
  %module3 = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %5, i32 0, i32 0
  store ptr %4, ptr %module3, align 8
  %6 = load ptr, ptr %callback.addr, align 8
  %7 = load ptr, ptr %job, align 8
  %callback4 = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %7, i32 0, i32 1
  store ptr %6, ptr %callback4, align 8
  %8 = load ptr, ptr %privdata.addr, align 8
  %9 = load ptr, ptr %job, align 8
  %pd = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %9, i32 0, i32 2
  store ptr %8, ptr %pd, align 8
  %10 = load ptr, ptr %free_privdata.addr, align 8
  %11 = load ptr, ptr %job, align 8
  %free_pd = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %11, i32 0, i32 3
  store ptr %10, ptr %free_pd, align 8
  %12 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %14, i32 0, i32 6
  %15 = load i32, ptr %id, align 8
  %16 = load ptr, ptr %job, align 8
  %dbid = getelementptr inbounds %struct.RedisModulePostExecUnitJob, ptr %16, i32 0, i32 4
  store i32 %15, ptr %dbid, align 8
  %17 = load ptr, ptr @modulePostExecUnitJobs, align 8
  %18 = load ptr, ptr %job, align 8
  %call5 = call ptr @listAddNodeTail(ptr noundef %17, ptr noundef %18)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetNotifyKeyspaceEvents() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 359), align 8
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_NotifyKeyspaceEvent(ptr noundef %ctx, i32 noundef %type, ptr noundef %event, ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %event.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store ptr %event, ptr %event.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %client, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i32, ptr %type.addr, align 4
  %4 = load ptr, ptr %event.addr, align 8
  %5 = load ptr, ptr %key.addr, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %client2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %client2, align 8
  %db = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %8, i32 0, i32 6
  %9 = load i32, ptr %id, align 8
  call void @notifyKeyspaceEvent(i32 noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %9)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

declare void @notifyKeyspaceEvent(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleNotifyKeyspaceEvent(i32 noundef %type, ptr noundef %event, ptr noundef %key, i32 noundef %dbid) #0 {
entry:
  %type.addr = alloca i32, align 4
  %event.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %dbid.addr = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %sub = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %prev_active = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  store ptr %event, ptr %event.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %dbid, ptr %dbid.addr, align 4
  %0 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  call void @enterExecutionUnit(i32 noundef 0, i64 noundef 0)
  %2 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  %3 = load i32, ptr %type.addr, align 4
  %and = and i32 %3, -4
  store i32 %and, ptr %type.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end13, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %value, align 8
  store ptr %5, ptr %sub, align 8
  %6 = load ptr, ptr %sub, align 8
  %event_mask = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %6, i32 0, i32 2
  %7 = load i32, ptr %event_mask, align 8
  %8 = load i32, ptr %type.addr, align 4
  %and1 = and i32 %7, %8
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %while.body
  %9 = load ptr, ptr %sub, align 8
  %active = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %active, align 4
  %cmp3 = icmp eq i32 %10, 0
  br i1 %cmp3, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %sub, align 8
  %module = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %module, align 8
  %options = getelementptr inbounds %struct.RedisModule, ptr %12, i32 0, i32 12
  %13 = load i32, ptr %options, align 4
  %and4 = and i32 %13, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end13

if.then6:                                         ; preds = %lor.lhs.false, %land.lhs.true
  %14 = load ptr, ptr %sub, align 8
  %module7 = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %module7, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %15, i32 noundef 64)
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  %16 = load ptr, ptr %client, align 8
  %17 = load i32, ptr %dbid.addr, align 4
  %call8 = call i32 @selectDb(ptr noundef %16, i32 noundef %17)
  %18 = load ptr, ptr %sub, align 8
  %active9 = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %18, i32 0, i32 3
  %19 = load i32, ptr %active9, align 4
  store i32 %19, ptr %prev_active, align 4
  %20 = load ptr, ptr %sub, align 8
  %active10 = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %20, i32 0, i32 3
  store i32 1, ptr %active10, align 4
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  %22 = load ptr, ptr %sub, align 8
  %notify_callback = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %22, i32 0, i32 1
  %23 = load ptr, ptr %notify_callback, align 8
  %24 = load i32, ptr %type.addr, align 4
  %25 = load ptr, ptr %event.addr, align 8
  %26 = load ptr, ptr %key.addr, align 8
  %call11 = call i32 %23(ptr noundef %ctx, i32 noundef %24, ptr noundef %25, ptr noundef %26)
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  %dec = add nsw i32 %27, -1
  store i32 %dec, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  %28 = load i32, ptr %prev_active, align 4
  %29 = load ptr, ptr %sub, align 8
  %active12 = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %29, i32 0, i32 3
  store i32 %28, ptr %active12, align 4
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %if.end13

if.end13:                                         ; preds = %if.then6, %lor.lhs.false, %while.body
  br label %while.cond, !llvm.loop !49

while.end:                                        ; preds = %while.cond
  call void @exitExecutionUnit()
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnsubscribeNotifications(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %sub, align 8
  %3 = load ptr, ptr %sub, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleKeyspaceSubscriber, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %module1, align 8
  %5 = load ptr, ptr %module.addr, align 8
  %cmp = icmp eq ptr %4, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %6 = load ptr, ptr @moduleKeyspaceSubscribers, align 8
  %7 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %sub, align 8
  call void @zfree(ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !50

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleCallClusterReceivers(ptr noundef %sender_id, i64 noundef %module_id, i8 noundef zeroext %type, ptr noundef %payload, i32 noundef %len) #0 {
entry:
  %sender_id.addr = alloca ptr, align 8
  %module_id.addr = alloca i64, align 8
  %type.addr = alloca i8, align 1
  %payload.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %r = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %sender_id, ptr %sender_id.addr, align 8
  store i64 %module_id, ptr %module_id.addr, align 8
  store i8 %type, ptr %type.addr, align 1
  store ptr %payload, ptr %payload.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  %0 = load i8, ptr %type.addr, align 1
  %idxprom = zext i8 %0 to i64
  %arrayidx = getelementptr inbounds [255 x ptr], ptr @clusterReceivers, i64 0, i64 %idxprom
  %1 = load ptr, ptr %arrayidx, align 8
  store ptr %1, ptr %r, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load ptr, ptr %r, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %r, align 8
  %module_id1 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %3, i32 0, i32 0
  %4 = load i64, ptr %module_id1, align 8
  %5 = load i64, ptr %module_id.addr, align 8
  %cmp = icmp eq i64 %4, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %6 = load ptr, ptr %r, align 8
  %module = getelementptr inbounds %struct.moduleClusterReceiver, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %7, i32 noundef 64)
  %8 = load ptr, ptr %r, align 8
  %callback = getelementptr inbounds %struct.moduleClusterReceiver, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %callback, align 8
  %10 = load ptr, ptr %sender_id.addr, align 8
  %11 = load i8, ptr %type.addr, align 1
  %12 = load ptr, ptr %payload.addr, align 8
  %13 = load i32, ptr %len.addr, align 4
  call void %9(ptr noundef %ctx, ptr noundef %10, i8 noundef zeroext %11, ptr noundef %12, i32 noundef %13)
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %while.end

if.end:                                           ; preds = %while.body
  %14 = load ptr, ptr %r, align 8
  %next = getelementptr inbounds %struct.moduleClusterReceiver, ptr %14, i32 0, i32 3
  %15 = load ptr, ptr %next, align 8
  store ptr %15, ptr %r, align 8
  br label %while.cond, !llvm.loop !51

while.end:                                        ; preds = %if.then, %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_RegisterClusterMessageReceiver(ptr noundef %ctx, i8 noundef zeroext %type, ptr noundef %callback) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %type.addr = alloca i8, align 1
  %callback.addr = alloca ptr, align 8
  %module_id = alloca i64, align 8
  %r = alloca ptr, align 8
  %prev = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i8 %type, ptr %type.addr, align 1
  store ptr %callback, ptr %callback.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end31

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %name, align 8
  %call = call i64 @moduleTypeEncodeId(ptr noundef %3, i32 noundef 0)
  store i64 %call, ptr %module_id, align 8
  %4 = load i8, ptr %type.addr, align 1
  %idxprom = zext i8 %4 to i64
  %arrayidx = getelementptr inbounds [255 x ptr], ptr @clusterReceivers, i64 0, i64 %idxprom
  %5 = load ptr, ptr %arrayidx, align 8
  store ptr %5, ptr %r, align 8
  store ptr null, ptr %prev, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end17, %if.end
  %6 = load ptr, ptr %r, align 8
  %tobool1 = icmp ne ptr %6, null
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load ptr, ptr %r, align 8
  %module_id2 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %module_id2, align 8
  %9 = load i64, ptr %module_id, align 8
  %cmp = icmp eq i64 %8, %9
  br i1 %cmp, label %if.then3, label %if.end17

if.then3:                                         ; preds = %while.body
  %10 = load ptr, ptr %callback.addr, align 8
  %tobool4 = icmp ne ptr %10, null
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  %11 = load ptr, ptr %callback.addr, align 8
  %12 = load ptr, ptr %r, align 8
  %callback6 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %12, i32 0, i32 1
  store ptr %11, ptr %callback6, align 8
  br label %if.end16

if.else:                                          ; preds = %if.then3
  %13 = load ptr, ptr %prev, align 8
  %tobool7 = icmp ne ptr %13, null
  br i1 %tobool7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.else
  %14 = load ptr, ptr %r, align 8
  %next = getelementptr inbounds %struct.moduleClusterReceiver, ptr %14, i32 0, i32 3
  %15 = load ptr, ptr %next, align 8
  %16 = load ptr, ptr %prev, align 8
  %next9 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %16, i32 0, i32 3
  store ptr %15, ptr %next9, align 8
  br label %if.end15

if.else10:                                        ; preds = %if.else
  %17 = load ptr, ptr %r, align 8
  %next11 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %next11, align 8
  %19 = load i8, ptr %type.addr, align 1
  %idxprom12 = zext i8 %19 to i64
  %arrayidx13 = getelementptr inbounds [255 x ptr], ptr @clusterReceivers, i64 0, i64 %idxprom12
  %20 = load ptr, ptr %arrayidx13, align 8
  %next14 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %20, i32 0, i32 3
  store ptr %18, ptr %next14, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.else10, %if.then8
  %21 = load ptr, ptr %r, align 8
  call void @zfree(ptr noundef %21)
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.then5
  br label %if.end31

if.end17:                                         ; preds = %while.body
  %22 = load ptr, ptr %r, align 8
  store ptr %22, ptr %prev, align 8
  %23 = load ptr, ptr %r, align 8
  %next18 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %23, i32 0, i32 3
  %24 = load ptr, ptr %next18, align 8
  store ptr %24, ptr %r, align 8
  br label %while.cond, !llvm.loop !52

while.end:                                        ; preds = %while.cond
  %25 = load ptr, ptr %callback.addr, align 8
  %tobool19 = icmp ne ptr %25, null
  br i1 %tobool19, label %if.then20, label %if.end31

if.then20:                                        ; preds = %while.end
  %call21 = call noalias ptr @zmalloc(i64 noundef 32) #11
  store ptr %call21, ptr %r, align 8
  %26 = load i64, ptr %module_id, align 8
  %27 = load ptr, ptr %r, align 8
  %module_id22 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %27, i32 0, i32 0
  store i64 %26, ptr %module_id22, align 8
  %28 = load ptr, ptr %ctx.addr, align 8
  %module23 = getelementptr inbounds %struct.RedisModuleCtx, ptr %28, i32 0, i32 1
  %29 = load ptr, ptr %module23, align 8
  %30 = load ptr, ptr %r, align 8
  %module24 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %30, i32 0, i32 2
  store ptr %29, ptr %module24, align 8
  %31 = load ptr, ptr %callback.addr, align 8
  %32 = load ptr, ptr %r, align 8
  %callback25 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %32, i32 0, i32 1
  store ptr %31, ptr %callback25, align 8
  %33 = load i8, ptr %type.addr, align 1
  %idxprom26 = zext i8 %33 to i64
  %arrayidx27 = getelementptr inbounds [255 x ptr], ptr @clusterReceivers, i64 0, i64 %idxprom26
  %34 = load ptr, ptr %arrayidx27, align 8
  %35 = load ptr, ptr %r, align 8
  %next28 = getelementptr inbounds %struct.moduleClusterReceiver, ptr %35, i32 0, i32 3
  store ptr %34, ptr %next28, align 8
  %36 = load ptr, ptr %r, align 8
  %37 = load i8, ptr %type.addr, align 1
  %idxprom29 = zext i8 %37 to i64
  %arrayidx30 = getelementptr inbounds [255 x ptr], ptr @clusterReceivers, i64 0, i64 %idxprom29
  store ptr %36, ptr %arrayidx30, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then20, %while.end, %if.end16, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SendClusterMessage(ptr noundef %ctx, ptr noundef %target_id, i8 noundef zeroext %type, ptr noundef %msg, i32 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %target_id.addr = alloca ptr, align 8
  %type.addr = alloca i8, align 1
  %msg.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %module_id = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %target_id, ptr %target_id.addr, align 8
  store i8 %type, ptr %type.addr, align 1
  store ptr %msg, ptr %msg.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %name, align 8
  %call = call i64 @moduleTypeEncodeId(ptr noundef %3, i32 noundef 0)
  store i64 %call, ptr %module_id, align 8
  %4 = load ptr, ptr %target_id.addr, align 8
  %5 = load i64, ptr %module_id, align 8
  %6 = load i8, ptr %type.addr, align 1
  %7 = load ptr, ptr %msg.addr, align 8
  %8 = load i32, ptr %len.addr, align 4
  %call1 = call i32 @clusterSendModuleMessageToTarget(ptr noundef %4, i64 noundef %5, i8 noundef zeroext %6, ptr noundef %7, i32 noundef %8)
  %cmp = icmp eq i32 %call1, 0
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then2, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

declare i32 @clusterSendModuleMessageToTarget(ptr noundef, i64 noundef, i8 noundef zeroext, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetClusterNodesList(ptr noundef %ctx, ptr noundef %numnodes) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %numnodes.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %numnodes, ptr %numnodes.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %numnodes.addr, align 8
  %call = call ptr @getClusterNodesList(ptr noundef %1)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load ptr, ptr %retval, align 8
  ret ptr %2
}

declare ptr @getClusterNodesList(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_FreeClusterNodesList(ptr noundef %ids) #0 {
entry:
  %ids.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  store ptr %ids, ptr %ids.addr, align 8
  %0 = load ptr, ptr %ids.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load ptr, ptr %ids.addr, align 8
  %2 = load i32, ptr %j, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %ids.addr, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds ptr, ptr %4, i64 %idxprom1
  %6 = load ptr, ptr %arrayidx2, align 8
  call void @zfree(ptr noundef %6)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, ptr %j, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !53

for.end:                                          ; preds = %for.cond
  %8 = load ptr, ptr %ids.addr, align 8
  call void @zfree(ptr noundef %8)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetMyClusterID() #0 {
entry:
  %retval = alloca ptr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call = call ptr @getMyClusterId()
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

declare ptr @getMyClusterId() #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_GetClusterSize() #0 {
entry:
  %retval = alloca i64, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call = call i32 @getClusterSize()
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load i64, ptr %retval, align 8
  ret i64 %1
}

declare i32 @getClusterSize() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetClusterNodeInfo(ptr noundef %ctx, ptr noundef %id, ptr noundef %ip, ptr noundef %master_id, ptr noundef %port, ptr noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %id.addr = alloca ptr, align 8
  %ip.addr = alloca ptr, align 8
  %master_id.addr = alloca ptr, align 8
  %port.addr = alloca ptr, align 8
  %flags.addr = alloca ptr, align 8
  %node = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %id, ptr %id.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store ptr %master_id, ptr %master_id.addr, align 8
  store ptr %port, ptr %port.addr, align 8
  store ptr %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %id.addr, align 8
  %1 = load ptr, ptr %id.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #14
  %conv = trunc i64 %call to i32
  %call1 = call ptr @clusterLookupNode(ptr noundef %0, i32 noundef %conv)
  store ptr %call1, ptr %node, align 8
  %2 = load ptr, ptr %node, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %node, align 8
  %call3 = call i32 @clusterNodePending(ptr noundef %3)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %ip.addr, align 8
  %tobool4 = icmp ne ptr %4, null
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %5 = load ptr, ptr %ip.addr, align 8
  %6 = load ptr, ptr %node, align 8
  %call6 = call ptr @clusterNodeIp(ptr noundef %6)
  %call7 = call i64 @redis_strlcpy(ptr noundef %5, ptr noundef %call6, i64 noundef 46)
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  %7 = load ptr, ptr %master_id.addr, align 8
  %tobool9 = icmp ne ptr %7, null
  br i1 %tobool9, label %if.then10, label %if.end19

if.then10:                                        ; preds = %if.end8
  %8 = load ptr, ptr %node, align 8
  %call11 = call i32 @clusterNodeIsSlave(ptr noundef %8)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then10
  %9 = load ptr, ptr %node, align 8
  %call13 = call ptr @clusterNodeGetSlaveof(ptr noundef %9)
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.else

if.then15:                                        ; preds = %land.lhs.true
  %10 = load ptr, ptr %master_id.addr, align 8
  %11 = load ptr, ptr %node, align 8
  %call16 = call ptr @clusterNodeGetSlaveof(ptr noundef %11)
  %call17 = call ptr @clusterNodeGetName(ptr noundef %call16)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %10, ptr align 1 %call17, i64 40, i1 false)
  br label %if.end18

if.else:                                          ; preds = %land.lhs.true, %if.then10
  %12 = load ptr, ptr %master_id.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %12, i8 0, i64 40, i1 false)
  br label %if.end18

if.end18:                                         ; preds = %if.else, %if.then15
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.end8
  %13 = load ptr, ptr %port.addr, align 8
  %tobool20 = icmp ne ptr %13, null
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end19
  %14 = load ptr, ptr %node, align 8
  %call22 = call i32 @getNodeDefaultClientPort(ptr noundef %14)
  %15 = load ptr, ptr %port.addr, align 8
  store i32 %call22, ptr %15, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  %16 = load ptr, ptr %flags.addr, align 8
  %tobool24 = icmp ne ptr %16, null
  br i1 %tobool24, label %if.then25, label %if.end55

if.then25:                                        ; preds = %if.end23
  %17 = load ptr, ptr %flags.addr, align 8
  store i32 0, ptr %17, align 4
  %18 = load ptr, ptr %node, align 8
  %call26 = call i32 @clusterNodeIsMyself(ptr noundef %18)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.then25
  %19 = load ptr, ptr %flags.addr, align 8
  %20 = load i32, ptr %19, align 4
  %or = or i32 %20, 1
  store i32 %or, ptr %19, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.then25
  %21 = load ptr, ptr %node, align 8
  %call30 = call i32 @clusterNodeIsMaster(ptr noundef %21)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end29
  %22 = load ptr, ptr %flags.addr, align 8
  %23 = load i32, ptr %22, align 4
  %or33 = or i32 %23, 2
  store i32 %or33, ptr %22, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end29
  %24 = load ptr, ptr %node, align 8
  %call35 = call i32 @clusterNodeIsSlave(ptr noundef %24)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end34
  %25 = load ptr, ptr %flags.addr, align 8
  %26 = load i32, ptr %25, align 4
  %or38 = or i32 %26, 4
  store i32 %or38, ptr %25, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %if.end34
  %27 = load ptr, ptr %node, align 8
  %call40 = call i32 @clusterNodeTimedOut(ptr noundef %27)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then42, label %if.end44

if.then42:                                        ; preds = %if.end39
  %28 = load ptr, ptr %flags.addr, align 8
  %29 = load i32, ptr %28, align 4
  %or43 = or i32 %29, 8
  store i32 %or43, ptr %28, align 4
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %if.end39
  %30 = load ptr, ptr %node, align 8
  %call45 = call i32 @clusterNodeIsFailing(ptr noundef %30)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.then47, label %if.end49

if.then47:                                        ; preds = %if.end44
  %31 = load ptr, ptr %flags.addr, align 8
  %32 = load i32, ptr %31, align 4
  %or48 = or i32 %32, 16
  store i32 %or48, ptr %31, align 4
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %if.end44
  %33 = load ptr, ptr %node, align 8
  %call50 = call i32 @clusterNodeIsNoFailover(ptr noundef %33)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.end49
  %34 = load ptr, ptr %flags.addr, align 8
  %35 = load i32, ptr %34, align 4
  %or53 = or i32 %35, 32
  store i32 %or53, ptr %34, align 4
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.end49
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.end23
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end55, %if.then
  %36 = load i32, ptr %retval, align 4
  ret i32 %36
}

declare ptr @clusterLookupNode(ptr noundef, i32 noundef) #1

declare i32 @clusterNodePending(ptr noundef) #1

declare i64 @redis_strlcpy(ptr noundef, ptr noundef, i64 noundef) #1

declare ptr @clusterNodeIp(ptr noundef) #1

declare i32 @clusterNodeIsSlave(ptr noundef) #1

declare ptr @clusterNodeGetSlaveof(ptr noundef) #1

declare ptr @clusterNodeGetName(ptr noundef) #1

declare i32 @getNodeDefaultClientPort(ptr noundef) #1

declare i32 @clusterNodeIsMyself(ptr noundef) #1

declare i32 @clusterNodeIsMaster(ptr noundef) #1

declare i32 @clusterNodeTimedOut(ptr noundef) #1

declare i32 @clusterNodeIsFailing(ptr noundef) #1

declare i32 @clusterNodeIsNoFailover(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_SetClusterFlags(ptr noundef %ctx, i64 noundef %flags) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load i64, ptr %flags.addr, align 8
  %and = and i64 %0, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  %or = or i32 %1, 2
  store i32 %or, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, ptr %flags.addr, align 8
  %and1 = and i64 %2, 4
  %tobool2 = icmp ne i64 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  %or4 = or i32 %3, 4
  store i32 %or4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleTimerHandler(ptr noundef %eventLoop, i64 noundef %id, ptr noundef %clientData) #0 {
entry:
  %retval = alloca i32, align 4
  %eventLoop.addr = alloca ptr, align 8
  %id.addr = alloca i64, align 8
  %clientData.addr = alloca ptr, align 8
  %ri = alloca %struct.raxIterator, align 8
  %now = alloca i64, align 8
  %next_period = alloca i64, align 8
  %expiretime = alloca i64, align 8
  %timer = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %eventLoop, ptr %eventLoop.addr, align 8
  store i64 %id, ptr %id.addr, align 8
  store ptr %clientData, ptr %clientData.addr, align 8
  %0 = load ptr, ptr @Timers, align 8
  call void @raxStart(ptr noundef %ri, ptr noundef %0)
  %call = call i64 @ustime()
  store i64 %call, ptr %now, align 8
  store i64 0, ptr %next_period, align 8
  br label %while.body

while.body:                                       ; preds = %if.end10, %entry
  %call1 = call i32 @raxSeek(ptr noundef %ri, ptr noundef @.str.79, ptr noundef null, i64 noundef 0)
  %call2 = call i32 @raxNext(ptr noundef %ri)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %key = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 2
  %1 = load ptr, ptr %key, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %expiretime, ptr align 1 %1, i64 8, i1 false)
  %2 = load i64, ptr %expiretime, align 8
  %call3 = call i64 @intrev64(i64 noundef %2)
  store i64 %call3, ptr %expiretime, align 8
  %3 = load i64, ptr %now, align 8
  %4 = load i64, ptr %expiretime, align 8
  %cmp = icmp uge i64 %3, %4
  br i1 %cmp, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %data = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 3
  %5 = load ptr, ptr %data, align 8
  store ptr %5, ptr %timer, align 8
  %6 = load ptr, ptr %timer, align 8
  %module = getelementptr inbounds %struct.RedisModuleTimer, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %7, i32 noundef 64)
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  %8 = load ptr, ptr %client, align 8
  %9 = load ptr, ptr %timer, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleTimer, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %dbid, align 8
  %call5 = call i32 @selectDb(ptr noundef %8, i32 noundef %10)
  %11 = load ptr, ptr %timer, align 8
  %callback = getelementptr inbounds %struct.RedisModuleTimer, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %callback, align 8
  %13 = load ptr, ptr %timer, align 8
  %data6 = getelementptr inbounds %struct.RedisModuleTimer, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %data6, align 8
  call void %12(ptr noundef %ctx, ptr noundef %14)
  call void @moduleFreeContext(ptr noundef %ctx)
  %15 = load ptr, ptr @Timers, align 8
  %key7 = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 2
  %16 = load ptr, ptr %key7, align 8
  %key_len = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 4
  %17 = load i64, ptr %key_len, align 8
  %call8 = call i32 @raxRemove(ptr noundef %15, ptr noundef %16, i64 noundef %17, ptr noundef null)
  %18 = load ptr, ptr %timer, align 8
  call void @zfree(ptr noundef %18)
  br label %if.end10

if.else:                                          ; preds = %if.end
  %19 = load i64, ptr %expiretime, align 8
  %call9 = call i64 @ustime()
  %sub = sub nsw i64 %19, %call9
  %div = sdiv i64 %sub, 1000
  store i64 %div, ptr %next_period, align 8
  br label %while.end

if.end10:                                         ; preds = %if.then4
  br label %while.body

while.end:                                        ; preds = %if.else, %if.then
  call void @raxStop(ptr noundef %ri)
  %20 = load i64, ptr %next_period, align 8
  %cmp11 = icmp sle i64 %20, 0
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %while.end
  store i64 1, ptr %next_period, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %while.end
  %21 = load ptr, ptr @Timers, align 8
  %call14 = call i64 @raxSize(ptr noundef %21)
  %cmp15 = icmp ugt i64 %call14, 0
  br i1 %cmp15, label %if.then16, label %if.else17

if.then16:                                        ; preds = %if.end13
  %22 = load i64, ptr %next_period, align 8
  %conv = trunc i64 %22 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.else17:                                        ; preds = %if.end13
  store i64 -1, ptr @aeTimer, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else17, %if.then16
  %23 = load i32, ptr %retval, align 4
  ret i32 %23
}

declare void @raxStart(ptr noundef, ptr noundef) #1

declare i32 @raxSeek(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #1

declare i32 @raxNext(ptr noundef) #1

declare i64 @intrev64(i64 noundef) #1

declare i32 @raxRemove(ptr noundef, ptr noundef, i64 noundef, ptr noundef) #1

declare void @raxStop(ptr noundef) #1

declare i64 @raxSize(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_CreateTimer(ptr noundef %ctx, i64 noundef %period, ptr noundef %callback, ptr noundef %data) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %period.addr = alloca i64, align 8
  %callback.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %timer = alloca ptr, align 8
  %expiretime = alloca i64, align 8
  %key = alloca i64, align 8
  %ri = alloca %struct.raxIterator, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %period, ptr %period.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 32) #11
  store ptr %call, ptr %timer, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %2 = load ptr, ptr %timer, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleTimer, ptr %2, i32 0, i32 0
  store ptr %1, ptr %module1, align 8
  %3 = load ptr, ptr %callback.addr, align 8
  %4 = load ptr, ptr %timer, align 8
  %callback2 = getelementptr inbounds %struct.RedisModuleTimer, ptr %4, i32 0, i32 1
  store ptr %3, ptr %callback2, align 8
  %5 = load ptr, ptr %data.addr, align 8
  %6 = load ptr, ptr %timer, align 8
  %data3 = getelementptr inbounds %struct.RedisModuleTimer, ptr %6, i32 0, i32 2
  store ptr %5, ptr %data3, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %client, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %9 = load ptr, ptr %ctx.addr, align 8
  %client4 = getelementptr inbounds %struct.RedisModuleCtx, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %client4, align 8
  %db = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %db, align 8
  %id = getelementptr inbounds %struct.redisDb, ptr %11, i32 0, i32 6
  %12 = load i32, ptr %id, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %12, %cond.true ], [ 0, %cond.false ]
  %13 = load ptr, ptr %timer, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleTimer, ptr %13, i32 0, i32 3
  store i32 %cond, ptr %dbid, align 8
  %call5 = call i64 @ustime()
  %14 = load i64, ptr %period.addr, align 8
  %mul = mul nsw i64 %14, 1000
  %add = add nsw i64 %call5, %mul
  store i64 %add, ptr %expiretime, align 8
  br label %while.body

while.body:                                       ; preds = %if.end, %cond.end
  %15 = load i64, ptr %expiretime, align 8
  %call6 = call i64 @intrev64(i64 noundef %15)
  store i64 %call6, ptr %key, align 8
  %16 = load ptr, ptr @Timers, align 8
  %call7 = call i32 @raxFind(ptr noundef %16, ptr noundef %key, i64 noundef 8, ptr noundef null)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.else, label %if.then

if.then:                                          ; preds = %while.body
  %17 = load ptr, ptr @Timers, align 8
  %18 = load ptr, ptr %timer, align 8
  %call9 = call i32 @raxInsert(ptr noundef %17, ptr noundef %key, i64 noundef 8, ptr noundef %18, ptr noundef null)
  br label %while.end

if.else:                                          ; preds = %while.body
  %19 = load i64, ptr %expiretime, align 8
  %inc = add i64 %19, 1
  store i64 %inc, ptr %expiretime, align 8
  br label %if.end

if.end:                                           ; preds = %if.else
  br label %while.body

while.end:                                        ; preds = %if.then
  %20 = load i64, ptr @aeTimer, align 8
  %cmp = icmp ne i64 %20, -1
  br i1 %cmp, label %if.then10, label %if.end19

if.then10:                                        ; preds = %while.end
  %21 = load ptr, ptr @Timers, align 8
  call void @raxStart(ptr noundef %ri, ptr noundef %21)
  %call11 = call i32 @raxSeek(ptr noundef %ri, ptr noundef @.str.79, ptr noundef null, i64 noundef 0)
  %call12 = call i32 @raxNext(ptr noundef %ri)
  %key13 = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 2
  %22 = load ptr, ptr %key13, align 8
  %call14 = call i32 @memcmp(ptr noundef %22, ptr noundef %key, i64 noundef 8) #14
  %cmp15 = icmp eq i32 %call14, 0
  br i1 %cmp15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.then10
  %23 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %24 = load i64, ptr @aeTimer, align 8
  %call17 = call i32 @aeDeleteTimeEvent(ptr noundef %23, i64 noundef %24)
  store i64 -1, ptr @aeTimer, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.then10
  call void @raxStop(ptr noundef %ri)
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %while.end
  %25 = load i64, ptr @aeTimer, align 8
  %cmp20 = icmp eq i64 %25, -1
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.end19
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %27 = load i64, ptr %period.addr, align 8
  %call22 = call i64 @aeCreateTimeEvent(ptr noundef %26, i64 noundef %27, ptr noundef @moduleTimerHandler, ptr noundef null, ptr noundef null)
  store i64 %call22, ptr @aeTimer, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.end19
  %28 = load i64, ptr %key, align 8
  ret i64 %28
}

declare i32 @raxFind(ptr noundef, ptr noundef, i64 noundef, ptr noundef) #1

declare i32 @raxInsert(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef) #1

declare i32 @aeDeleteTimeEvent(ptr noundef, i64 noundef) #1

declare i64 @aeCreateTimeEvent(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_StopTimer(ptr noundef %ctx, i64 noundef %id, ptr noundef %data) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %id.addr = alloca i64, align 8
  %data.addr = alloca ptr, align 8
  %result = alloca ptr, align 8
  %timer = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %id, ptr %id.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr @Timers, align 8
  %call = call i32 @raxFind(ptr noundef %0, ptr noundef %id.addr, i64 noundef 8, ptr noundef %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %result, align 8
  store ptr %1, ptr %timer, align 8
  %2 = load ptr, ptr %timer, align 8
  %module = getelementptr inbounds %struct.RedisModuleTimer, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %module, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %module1, align 8
  %cmp = icmp ne ptr %3, %5
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %6 = load ptr, ptr %data.addr, align 8
  %tobool4 = icmp ne ptr %6, null
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %7 = load ptr, ptr %timer, align 8
  %data6 = getelementptr inbounds %struct.RedisModuleTimer, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %data6, align 8
  %9 = load ptr, ptr %data.addr, align 8
  store ptr %8, ptr %9, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %10 = load ptr, ptr @Timers, align 8
  %call8 = call i32 @raxRemove(ptr noundef %10, ptr noundef %id.addr, i64 noundef 8, ptr noundef null)
  %11 = load ptr, ptr %timer, align 8
  call void @zfree(ptr noundef %11)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then2, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetTimerInfo(ptr noundef %ctx, i64 noundef %id, ptr noundef %remaining, ptr noundef %data) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %id.addr = alloca i64, align 8
  %remaining.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %result = alloca ptr, align 8
  %timer = alloca ptr, align 8
  %rem = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %id, ptr %id.addr, align 8
  store ptr %remaining, ptr %remaining.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr @Timers, align 8
  %call = call i32 @raxFind(ptr noundef %0, ptr noundef %id.addr, i64 noundef 8, ptr noundef %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %result, align 8
  store ptr %1, ptr %timer, align 8
  %2 = load ptr, ptr %timer, align 8
  %module = getelementptr inbounds %struct.RedisModuleTimer, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %module, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %module1, align 8
  %cmp = icmp ne ptr %3, %5
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %6 = load ptr, ptr %remaining.addr, align 8
  %tobool4 = icmp ne ptr %6, null
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end3
  %7 = load i64, ptr %id.addr, align 8
  %call6 = call i64 @intrev64(i64 noundef %7)
  %call7 = call i64 @ustime()
  %sub = sub i64 %call6, %call7
  store i64 %sub, ptr %rem, align 8
  %8 = load i64, ptr %rem, align 8
  %cmp8 = icmp slt i64 %8, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then5
  store i64 0, ptr %rem, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.then5
  %9 = load i64, ptr %rem, align 8
  %div = sdiv i64 %9, 1000
  %10 = load ptr, ptr %remaining.addr, align 8
  store i64 %div, ptr %10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.end3
  %11 = load ptr, ptr %data.addr, align 8
  %tobool12 = icmp ne ptr %11, null
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %12 = load ptr, ptr %timer, align 8
  %data14 = getelementptr inbounds %struct.RedisModuleTimer, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %data14, align 8
  %14 = load ptr, ptr %data.addr, align 8
  store ptr %13, ptr %14, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end11
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then2, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleHoldsTimer(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %iter = alloca %struct.raxIterator, align 8
  %found = alloca i32, align 4
  %timer = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 0, ptr %found, align 4
  %0 = load ptr, ptr @Timers, align 8
  call void @raxStart(ptr noundef %iter, ptr noundef %0)
  %call = call i32 @raxSeek(ptr noundef %iter, ptr noundef @.str.79, ptr noundef null, i64 noundef 0)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call1 = call i32 @raxNext(ptr noundef %iter)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %data = getelementptr inbounds %struct.raxIterator, ptr %iter, i32 0, i32 3
  %1 = load ptr, ptr %data, align 8
  store ptr %1, ptr %timer, align 8
  %2 = load ptr, ptr %timer, align 8
  %module2 = getelementptr inbounds %struct.RedisModuleTimer, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %module2, align 8
  %4 = load ptr, ptr %module.addr, align 8
  %cmp = icmp eq ptr %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  store i32 1, ptr %found, align 4
  br label %while.end

if.end:                                           ; preds = %while.body
  br label %while.cond, !llvm.loop !54

while.end:                                        ; preds = %if.then, %while.cond
  call void @raxStop(ptr noundef %iter)
  %5 = load i32, ptr %found, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_EventLoopAdd(i32 noundef %fd, i32 noundef %mask, ptr noundef %func, ptr noundef %user_data) #0 {
entry:
  %retval = alloca i32, align 4
  %fd.addr = alloca i32, align 4
  %mask.addr = alloca i32, align 4
  %func.addr = alloca ptr, align 8
  %user_data.addr = alloca ptr, align 8
  %data = alloca ptr, align 8
  %aeProc = alloca ptr, align 8
  %aeMask = alloca i32, align 4
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %mask, ptr %mask.addr, align 4
  store ptr %func, ptr %func.addr, align 8
  store ptr %user_data, ptr %user_data.addr, align 8
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %fd.addr, align 4
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %call = call i32 @aeGetSetSize(ptr noundef %2)
  %cmp1 = icmp sge i32 %1, %call
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call2 = call ptr @__errno_location() #15
  store i32 34, ptr %call2, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %func.addr, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %lor.lhs.false3, label %if.then5

lor.lhs.false3:                                   ; preds = %if.end
  %4 = load i32, ptr %mask.addr, align 4
  %and = and i32 %4, -4
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %lor.lhs.false3, %if.end
  %call6 = call ptr @__errno_location() #15
  store i32 22, ptr %call6, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %lor.lhs.false3
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %6 = load i32, ptr %fd.addr, align 4
  %call8 = call ptr @aeGetFileClientData(ptr noundef %5, i32 noundef %6)
  store ptr %call8, ptr %data, align 8
  %7 = load ptr, ptr %data, align 8
  %tobool9 = icmp ne ptr %7, null
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.end7
  %call11 = call noalias ptr @zcalloc(i64 noundef 24) #11
  store ptr %call11, ptr %data, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end7
  %8 = load i32, ptr %mask.addr, align 4
  %and13 = and i32 %8, 1
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.else

if.then15:                                        ; preds = %if.end12
  store ptr @eventLoopCbReadable, ptr %aeProc, align 8
  br label %if.end16

if.else:                                          ; preds = %if.end12
  store ptr @eventLoopCbWritable, ptr %aeProc, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then15
  %9 = load i32, ptr %mask.addr, align 4
  %call17 = call i32 @eventLoopToAeMask(i32 noundef %9)
  store i32 %call17, ptr %aeMask, align 4
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %11 = load i32, ptr %fd.addr, align 4
  %12 = load i32, ptr %aeMask, align 4
  %13 = load ptr, ptr %aeProc, align 8
  %14 = load ptr, ptr %data, align 8
  %call18 = call i32 @aeCreateFileEvent(ptr noundef %10, i32 noundef %11, i32 noundef %12, ptr noundef %13, ptr noundef %14)
  %cmp19 = icmp ne i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.end25

if.then20:                                        ; preds = %if.end16
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %16 = load i32, ptr %fd.addr, align 4
  %call21 = call i32 @aeGetFileEvents(ptr noundef %15, i32 noundef %16)
  %cmp22 = icmp eq i32 %call21, 0
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then20
  %17 = load ptr, ptr %data, align 8
  call void @zfree(ptr noundef %17)
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.then20
  store i32 1, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end16
  %18 = load ptr, ptr %user_data.addr, align 8
  %19 = load ptr, ptr %data, align 8
  %user_data26 = getelementptr inbounds %struct.EventLoopData, ptr %19, i32 0, i32 2
  store ptr %18, ptr %user_data26, align 8
  %20 = load i32, ptr %mask.addr, align 4
  %and27 = and i32 %20, 1
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end25
  %21 = load ptr, ptr %func.addr, align 8
  %22 = load ptr, ptr %data, align 8
  %rFunc = getelementptr inbounds %struct.EventLoopData, ptr %22, i32 0, i32 0
  store ptr %21, ptr %rFunc, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end25
  %23 = load i32, ptr %mask.addr, align 4
  %and31 = and i32 %23, 2
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  %24 = load ptr, ptr %func.addr, align 8
  %25 = load ptr, ptr %data, align 8
  %wFunc = getelementptr inbounds %struct.EventLoopData, ptr %25, i32 0, i32 1
  store ptr %24, ptr %wFunc, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end30
  %call35 = call ptr @__errno_location() #15
  store i32 0, ptr %call35, align 4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end34, %if.end24, %if.then5, %if.then
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

declare i32 @aeGetSetSize(ptr noundef) #1

declare ptr @aeGetFileClientData(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @eventLoopCbReadable(ptr noundef %ae, i32 noundef %fd, ptr noundef %user_data, i32 noundef %ae_mask) #0 {
entry:
  %ae.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %user_data.addr = alloca ptr, align 8
  %ae_mask.addr = alloca i32, align 4
  %data = alloca ptr, align 8
  store ptr %ae, ptr %ae.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %user_data, ptr %user_data.addr, align 8
  store i32 %ae_mask, ptr %ae_mask.addr, align 4
  %0 = load ptr, ptr %user_data.addr, align 8
  store ptr %0, ptr %data, align 8
  %1 = load ptr, ptr %data, align 8
  %rFunc = getelementptr inbounds %struct.EventLoopData, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %rFunc, align 8
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %data, align 8
  %user_data1 = getelementptr inbounds %struct.EventLoopData, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %user_data1, align 8
  %6 = load i32, ptr %ae_mask.addr, align 4
  %call = call i32 @eventLoopFromAeMask(i32 noundef %6)
  call void %2(i32 noundef %3, ptr noundef %5, i32 noundef %call)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @eventLoopCbWritable(ptr noundef %ae, i32 noundef %fd, ptr noundef %user_data, i32 noundef %ae_mask) #0 {
entry:
  %ae.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %user_data.addr = alloca ptr, align 8
  %ae_mask.addr = alloca i32, align 4
  %data = alloca ptr, align 8
  store ptr %ae, ptr %ae.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %user_data, ptr %user_data.addr, align 8
  store i32 %ae_mask, ptr %ae_mask.addr, align 4
  %0 = load ptr, ptr %user_data.addr, align 8
  store ptr %0, ptr %data, align 8
  %1 = load ptr, ptr %data, align 8
  %wFunc = getelementptr inbounds %struct.EventLoopData, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %wFunc, align 8
  %3 = load i32, ptr %fd.addr, align 4
  %4 = load ptr, ptr %data, align 8
  %user_data1 = getelementptr inbounds %struct.EventLoopData, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %user_data1, align 8
  %6 = load i32, ptr %ae_mask.addr, align 4
  %call = call i32 @eventLoopFromAeMask(i32 noundef %6)
  call void %2(i32 noundef %3, ptr noundef %5, i32 noundef %call)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @eventLoopToAeMask(i32 noundef %mask) #0 {
entry:
  %mask.addr = alloca i32, align 4
  %aeMask = alloca i32, align 4
  store i32 %mask, ptr %mask.addr, align 4
  store i32 0, ptr %aeMask, align 4
  %0 = load i32, ptr %mask.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %aeMask, align 4
  %or = or i32 %1, 1
  store i32 %or, ptr %aeMask, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %mask.addr, align 4
  %and1 = and i32 %2, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = load i32, ptr %aeMask, align 4
  %or4 = or i32 %3, 2
  store i32 %or4, ptr %aeMask, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %aeMask, align 4
  ret i32 %4
}

declare i32 @aeCreateFileEvent(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) #1

declare i32 @aeGetFileEvents(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_EventLoopDel(i32 noundef %fd, i32 noundef %mask) #0 {
entry:
  %retval = alloca i32, align 4
  %fd.addr = alloca i32, align 4
  %mask.addr = alloca i32, align 4
  %data = alloca ptr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 %mask, ptr %mask.addr, align 4
  %0 = load i32, ptr %fd.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %fd.addr, align 4
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %call = call i32 @aeGetSetSize(ptr noundef %2)
  %cmp1 = icmp sge i32 %1, %call
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call2 = call ptr @__errno_location() #15
  store i32 34, ptr %call2, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i32, ptr %mask.addr, align 4
  %and = and i32 %3, -4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @__errno_location() #15
  store i32 22, ptr %call4, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %5 = load i32, ptr %fd.addr, align 4
  %call6 = call ptr @aeGetFileClientData(ptr noundef %4, i32 noundef %5)
  store ptr %call6, ptr %data, align 8
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %7 = load i32, ptr %fd.addr, align 4
  %8 = load i32, ptr %mask.addr, align 4
  %call7 = call i32 @eventLoopToAeMask(i32 noundef %8)
  call void @aeDeleteFileEvent(ptr noundef %6, i32 noundef %7, i32 noundef %call7)
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %10 = load i32, ptr %fd.addr, align 4
  %call8 = call i32 @aeGetFileEvents(ptr noundef %9, i32 noundef %10)
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end5
  %11 = load ptr, ptr %data, align 8
  call void @zfree(ptr noundef %11)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end5
  %call12 = call ptr @__errno_location() #15
  store i32 0, ptr %call12, align 4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then3, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

declare void @aeDeleteFileEvent(ptr noundef, i32 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_EventLoopAddOneShot(ptr noundef %func, ptr noundef %user_data) #0 {
entry:
  %retval = alloca i32, align 4
  %func.addr = alloca ptr, align 8
  %user_data.addr = alloca ptr, align 8
  %oneshot = alloca ptr, align 8
  store ptr %func, ptr %func.addr, align 8
  store ptr %user_data, ptr %user_data.addr, align 8
  %0 = load ptr, ptr %func.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call noalias ptr @zmalloc(i64 noundef 16) #11
  store ptr %call1, ptr %oneshot, align 8
  %1 = load ptr, ptr %func.addr, align 8
  %2 = load ptr, ptr %oneshot, align 8
  %func2 = getelementptr inbounds %struct.EventLoopOneShot, ptr %2, i32 0, i32 0
  store ptr %1, ptr %func2, align 8
  %3 = load ptr, ptr %user_data.addr, align 8
  %4 = load ptr, ptr %oneshot, align 8
  %user_data3 = getelementptr inbounds %struct.EventLoopOneShot, ptr %4, i32 0, i32 1
  store ptr %3, ptr %user_data3, align 8
  %call4 = call i32 @pthread_mutex_lock(ptr noundef @moduleEventLoopMutex) #16
  %5 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %tobool5 = icmp ne ptr %5, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end
  %call7 = call ptr @listCreate()
  store ptr %call7, ptr @moduleEventLoopOneShots, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %6 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %7 = load ptr, ptr %oneshot, align 8
  %call9 = call ptr @listAddNodeTail(ptr noundef %6, ptr noundef %7)
  %call10 = call i32 @pthread_mutex_unlock(ptr noundef @moduleEventLoopMutex) #16
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 41, i64 1), align 4
  %call11 = call i64 @write(i32 noundef %8, ptr noundef @.str.76, i64 noundef 1)
  %cmp = icmp ne i64 %call11, 1
  br i1 %cmp, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end8
  %call14 = call ptr @__errno_location() #15
  store i32 0, ptr %call14, align 4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleNotifyUserChanged(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %auth_callback = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 68
  %1 = load ptr, ptr %auth_callback, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %auth_callback1 = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 68
  %3 = load ptr, ptr %auth_callback1, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %id = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 0
  %5 = load i64, ptr %id, align 8
  %6 = load ptr, ptr %c.addr, align 8
  %auth_callback_privdata = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 69
  %7 = load ptr, ptr %auth_callback_privdata, align 8
  call void %3(i64 noundef %5, ptr noundef %7)
  %8 = load ptr, ptr %c.addr, align 8
  %auth_callback2 = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 68
  store ptr null, ptr %auth_callback2, align 8
  %9 = load ptr, ptr %c.addr, align 8
  %auth_callback_privdata3 = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 69
  store ptr null, ptr %auth_callback_privdata3, align 8
  %10 = load ptr, ptr %c.addr, align 8
  %auth_module = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 70
  store ptr null, ptr %auth_module, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @revokeClientAuthentication(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @moduleNotifyUserChanged(ptr noundef %0)
  %1 = load ptr, ptr @DefaultUser, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %user = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 20
  store ptr %1, ptr %user, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %authenticated = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 34
  store i32 0, ptr %authenticated, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %cmp = icmp eq ptr %4, %5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %flags, align 8
  %or = or i64 %7, 1099511627776
  store i64 %or, ptr %flags, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %c.addr, align 8
  call void @freeClientAsync(ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare void @freeClientAsync(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateModuleUser(ptr noundef %name) #0 {
entry:
  %name.addr = alloca ptr, align 8
  %new_user = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 16) #11
  store ptr %call, ptr %new_user, align 8
  %call1 = call ptr @ACLCreateUnlinkedUser()
  %0 = load ptr, ptr %new_user, align 8
  %user = getelementptr inbounds %struct.RedisModuleUser, ptr %0, i32 0, i32 0
  store ptr %call1, ptr %user, align 8
  %1 = load ptr, ptr %new_user, align 8
  %free_user = getelementptr inbounds %struct.RedisModuleUser, ptr %1, i32 0, i32 1
  store i32 1, ptr %free_user, align 8
  %2 = load ptr, ptr %new_user, align 8
  %user2 = getelementptr inbounds %struct.RedisModuleUser, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %user2, align 8
  %name3 = getelementptr inbounds %struct.user, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %name3, align 8
  call void @sdsfree(ptr noundef %4)
  %5 = load ptr, ptr %name.addr, align 8
  %call4 = call ptr @sdsnew(ptr noundef %5)
  %6 = load ptr, ptr %new_user, align 8
  %user5 = getelementptr inbounds %struct.RedisModuleUser, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %user5, align 8
  %name6 = getelementptr inbounds %struct.user, ptr %7, i32 0, i32 0
  store ptr %call4, ptr %name6, align 8
  %8 = load ptr, ptr %new_user, align 8
  ret ptr %8
}

declare ptr @ACLCreateUnlinkedUser() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_FreeModuleUser(ptr noundef %user) #0 {
entry:
  %user.addr = alloca ptr, align 8
  store ptr %user, ptr %user.addr, align 8
  %0 = load ptr, ptr %user.addr, align 8
  %free_user = getelementptr inbounds %struct.RedisModuleUser, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %free_user, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %user.addr, align 8
  %user1 = getelementptr inbounds %struct.RedisModuleUser, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %user1, align 8
  call void @ACLFreeUserAndKillClients(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %user.addr, align 8
  call void @zfree(ptr noundef %4)
  ret i32 0
}

declare void @ACLFreeUserAndKillClients(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetModuleUserACL(ptr noundef %user, ptr noundef %acl) #0 {
entry:
  %user.addr = alloca ptr, align 8
  %acl.addr = alloca ptr, align 8
  store ptr %user, ptr %user.addr, align 8
  store ptr %acl, ptr %acl.addr, align 8
  %0 = load ptr, ptr %user.addr, align 8
  %user1 = getelementptr inbounds %struct.RedisModuleUser, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %user1, align 8
  %2 = load ptr, ptr %acl.addr, align 8
  %call = call i32 @ACLSetUser(ptr noundef %1, ptr noundef %2, i64 noundef -1)
  ret i32 %call
}

declare i32 @ACLSetUser(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetModuleUserACLString(ptr noundef %ctx, ptr noundef %user, ptr noundef %acl, ptr noundef %error) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %user.addr = alloca ptr, align 8
  %acl.addr = alloca ptr, align 8
  %error.addr = alloca ptr, align 8
  %argc = alloca i32, align 4
  %argv = alloca ptr, align 8
  %err = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %user, ptr %user.addr, align 8
  store ptr %acl, ptr %acl.addr, align 8
  store ptr %error, ptr %error.addr, align 8
  %0 = load ptr, ptr %user.addr, align 8
  %cmp = icmp ne ptr %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.80, ptr noundef @.str.2, i32 noundef 9553)
  call void @abort() #13
  unreachable

1:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %1, %cond.true
  %2 = load ptr, ptr %acl.addr, align 8
  %call = call ptr @sdssplitargs(ptr noundef %2, ptr noundef %argc)
  store ptr %call, ptr %argv, align 8
  %3 = load ptr, ptr %user.addr, align 8
  %user2 = getelementptr inbounds %struct.RedisModuleUser, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %user2, align 8
  %5 = load ptr, ptr %argv, align 8
  %6 = load i32, ptr %argc, align 4
  %call3 = call ptr @ACLStringSetUser(ptr noundef %4, ptr noundef null, ptr noundef %5, i32 noundef %6)
  store ptr %call3, ptr %err, align 8
  %7 = load ptr, ptr %argv, align 8
  %8 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %7, i32 noundef %8)
  %9 = load ptr, ptr %err, align 8
  %tobool4 = icmp ne ptr %9, null
  br i1 %tobool4, label %if.then, label %if.end12

if.then:                                          ; preds = %cond.end
  %10 = load ptr, ptr %error.addr, align 8
  %tobool5 = icmp ne ptr %10, null
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then
  %11 = load ptr, ptr %err, align 8
  %call7 = call ptr @createObject(i32 noundef 0, ptr noundef %11)
  %12 = load ptr, ptr %error.addr, align 8
  store ptr %call7, ptr %12, align 8
  %13 = load ptr, ptr %ctx.addr, align 8
  %cmp8 = icmp ne ptr %13, null
  br i1 %cmp8, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then6
  %14 = load ptr, ptr %ctx.addr, align 8
  %15 = load ptr, ptr %error.addr, align 8
  %16 = load ptr, ptr %15, align 8
  call void @autoMemoryAdd(ptr noundef %14, i32 noundef 1, ptr noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then6
  br label %if.end11

if.else:                                          ; preds = %if.then
  %17 = load ptr, ptr %err, align 8
  call void @sdsfree(ptr noundef %17)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %cond.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.end11
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

declare ptr @sdssplitargs(ptr noundef, ptr noundef) #1

declare ptr @ACLStringSetUser(ptr noundef, ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetModuleUserACLString(ptr noundef %user) #0 {
entry:
  %user.addr = alloca ptr, align 8
  store ptr %user, ptr %user.addr, align 8
  %0 = load ptr, ptr %user.addr, align 8
  %cmp = icmp ne ptr %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.80, ptr noundef @.str.2, i32 noundef 9580)
  call void @abort() #13
  unreachable

1:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %1, %cond.true
  %2 = load ptr, ptr %user.addr, align 8
  %user2 = getelementptr inbounds %struct.RedisModuleUser, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %user2, align 8
  %call = call ptr @ACLDescribeUser(ptr noundef %3)
  ret ptr %call
}

declare ptr @ACLDescribeUser(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetCurrentUserName(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %client, align 8
  %user = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 20
  %3 = load ptr, ptr %user, align 8
  %name = getelementptr inbounds %struct.user, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %name, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %client1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %client1, align 8
  %user2 = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 20
  %7 = load ptr, ptr %user2, align 8
  %name3 = getelementptr inbounds %struct.user, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %name3, align 8
  %call = call i64 @sdslen(ptr noundef %8)
  %call4 = call ptr @RM_CreateString(ptr noundef %0, ptr noundef %4, i64 noundef %call)
  ret ptr %call4
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetModuleUserFromUserName(ptr noundef %name) #0 {
entry:
  %retval = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %acl_user = alloca ptr, align 8
  %new_user = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr1, align 8
  %call = call i64 @sdslen(ptr noundef %3)
  %call2 = call ptr @ACLGetUserByName(ptr noundef %1, i64 noundef %call)
  store ptr %call2, ptr %acl_user, align 8
  %4 = load ptr, ptr %acl_user, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call3 = call noalias ptr @zmalloc(i64 noundef 16) #11
  store ptr %call3, ptr %new_user, align 8
  %5 = load ptr, ptr %acl_user, align 8
  %6 = load ptr, ptr %new_user, align 8
  %user = getelementptr inbounds %struct.RedisModuleUser, ptr %6, i32 0, i32 0
  store ptr %5, ptr %user, align 8
  %7 = load ptr, ptr %new_user, align 8
  %free_user = getelementptr inbounds %struct.RedisModuleUser, ptr %7, i32 0, i32 1
  store i32 0, ptr %free_user, align 8
  %8 = load ptr, ptr %new_user, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

declare ptr @ACLGetUserByName(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ACLCheckCommandPermissions(ptr noundef %user, ptr noundef %argv, i32 noundef %argc) #0 {
entry:
  %retval = alloca i32, align 4
  %user.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %keyidxptr = alloca i32, align 4
  %cmd = alloca ptr, align 8
  store ptr %user, ptr %user.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  %0 = load ptr, ptr %argv.addr, align 8
  %1 = load i32, ptr %argc.addr, align 4
  %call = call ptr @lookupCommand(ptr noundef %0, i32 noundef %1)
  store ptr %call, ptr %cmd, align 8
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #15
  store i32 2, ptr %call1, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %user.addr, align 8
  %user2 = getelementptr inbounds %struct.RedisModuleUser, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %user2, align 8
  %4 = load ptr, ptr %cmd, align 8
  %5 = load ptr, ptr %argv.addr, align 8
  %6 = load i32, ptr %argc.addr, align 4
  %call3 = call i32 @ACLCheckAllUserCommandPerm(ptr noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %6, ptr noundef %keyidxptr)
  %cmp4 = icmp ne i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call ptr @__errno_location() #15
  store i32 13, ptr %call6, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then5, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ACLCheckKeyPermissions(ptr noundef %user, ptr noundef %key, i32 noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %user.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %allow_mask = alloca i32, align 4
  %keyspec_flags = alloca i32, align 4
  store ptr %user, ptr %user.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 240, ptr %allow_mask, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 240
  %1 = load i32, ptr %flags.addr, align 4
  %cmp = icmp ne i32 %and, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %flags.addr, align 4
  %conv = sext i32 %2 to i64
  %call1 = call i64 @moduleConvertKeySpecsFlags(i64 noundef %conv, i32 noundef 0)
  %conv2 = trunc i64 %call1 to i32
  store i32 %conv2, ptr %keyspec_flags, align 4
  %3 = load ptr, ptr %user.addr, align 8
  %user3 = getelementptr inbounds %struct.RedisModuleUser, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %user3, align 8
  %5 = load ptr, ptr %key.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ptr, align 8
  %7 = load ptr, ptr %key.addr, align 8
  %ptr4 = getelementptr inbounds %struct.redisObject, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %ptr4, align 8
  %call5 = call i64 @sdslen(ptr noundef %8)
  %conv6 = trunc i64 %call5 to i32
  %9 = load i32, ptr %keyspec_flags, align 4
  %call7 = call i32 @ACLUserCheckKeyPerm(ptr noundef %4, ptr noundef %6, i32 noundef %conv6, i32 noundef %9)
  %cmp8 = icmp ne i32 %call7, 0
  br i1 %cmp8, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end
  %call11 = call ptr @__errno_location() #15
  store i32 13, ptr %call11, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then10, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

declare i32 @ACLUserCheckKeyPerm(ptr noundef, ptr noundef, i32 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ACLCheckChannelPermissions(ptr noundef %user, ptr noundef %ch, i32 noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %user.addr = alloca ptr, align 8
  %ch.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %allow_mask = alloca i32, align 4
  %is_pattern = alloca i32, align 4
  store ptr %user, ptr %user.addr, align 8
  store ptr %ch, ptr %ch.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 15, ptr %allow_mask, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 15
  %1 = load i32, ptr %flags.addr, align 4
  %cmp = icmp ne i32 %and, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %flags.addr, align 4
  %conv = sext i32 %2 to i64
  %and1 = and i64 %conv, 8
  %tobool = icmp ne i64 %and1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load i32, ptr %flags.addr, align 4
  %conv4 = sext i32 %3 to i64
  %and5 = and i64 %conv4, 1
  %conv6 = trunc i64 %and5 to i32
  store i32 %conv6, ptr %is_pattern, align 4
  %4 = load ptr, ptr %user.addr, align 8
  %user7 = getelementptr inbounds %struct.RedisModuleUser, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %user7, align 8
  %6 = load ptr, ptr %ch.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %ptr, align 8
  %8 = load i32, ptr %is_pattern, align 4
  %call8 = call i32 @ACLUserCheckChannelPerm(ptr noundef %5, ptr noundef %7, i32 noundef %8)
  %cmp9 = icmp ne i32 %call8, 0
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end3
  store i32 1, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end3
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then2, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

declare i32 @ACLUserCheckChannelPerm(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleGetACLLogEntryReason(i32 noundef %reason) #0 {
entry:
  %reason.addr = alloca i32, align 4
  %acl_reason = alloca i32, align 4
  store i32 %reason, ptr %reason.addr, align 4
  store i32 0, ptr %acl_reason, align 4
  %0 = load i32, ptr %reason.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 2, label %sw.bb1
    i32 3, label %sw.bb2
    i32 1, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  store i32 3, ptr %acl_reason, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store i32 2, ptr %acl_reason, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  store i32 4, ptr %acl_reason, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  store i32 1, ptr %acl_reason, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load i32, ptr %acl_reason, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ACLAddLogEntry(ptr noundef %ctx, ptr noundef %user, ptr noundef %object, i32 noundef %reason) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %user.addr = alloca ptr, align 8
  %object.addr = alloca ptr, align 8
  %reason.addr = alloca i32, align 4
  %acl_reason = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %user, ptr %user.addr, align 8
  store ptr %object, ptr %object.addr, align 8
  store i32 %reason, ptr %reason.addr, align 4
  %0 = load i32, ptr %reason.addr, align 4
  %call = call i32 @moduleGetACLLogEntryReason(i32 noundef %0)
  store i32 %call, ptr %acl_reason, align 4
  %1 = load i32, ptr %acl_reason, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %client, align 8
  %4 = load i32, ptr %acl_reason, align 4
  %5 = load ptr, ptr %user.addr, align 8
  %user1 = getelementptr inbounds %struct.RedisModuleUser, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %user1, align 8
  %name = getelementptr inbounds %struct.user, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %name, align 8
  %8 = load ptr, ptr %object.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %ptr, align 8
  %call2 = call ptr @sdsdup(ptr noundef %9)
  call void @addACLLogEntry(ptr noundef %3, i32 noundef %4, i32 noundef 3, i32 noundef -1, ptr noundef %7, ptr noundef %call2)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ACLAddLogEntryByUserName(ptr noundef %ctx, ptr noundef %username, ptr noundef %object, i32 noundef %reason) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %username.addr = alloca ptr, align 8
  %object.addr = alloca ptr, align 8
  %reason.addr = alloca i32, align 4
  %acl_reason = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %username, ptr %username.addr, align 8
  store ptr %object, ptr %object.addr, align 8
  store i32 %reason, ptr %reason.addr, align 4
  %0 = load i32, ptr %reason.addr, align 4
  %call = call i32 @moduleGetACLLogEntryReason(i32 noundef %0)
  store i32 %call, ptr %acl_reason, align 4
  %1 = load i32, ptr %acl_reason, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %client, align 8
  %4 = load i32, ptr %acl_reason, align 4
  %5 = load ptr, ptr %username.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ptr, align 8
  %7 = load ptr, ptr %object.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %ptr1, align 8
  %call2 = call ptr @sdsdup(ptr noundef %8)
  call void @addACLLogEntry(ptr noundef %3, i32 noundef %4, i32 noundef 3, i32 noundef -1, ptr noundef %6, ptr noundef %call2)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_AuthenticateClientWithUser(ptr noundef %ctx, ptr noundef %module_user, ptr noundef %callback, ptr noundef %privdata, ptr noundef %client_id) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %module_user.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %client_id.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %module_user, ptr %module_user.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  store ptr %client_id, ptr %client_id.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %module_user.addr, align 8
  %user = getelementptr inbounds %struct.RedisModuleUser, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %user, align 8
  %3 = load ptr, ptr %callback.addr, align 8
  %4 = load ptr, ptr %privdata.addr, align 8
  %5 = load ptr, ptr %client_id.addr, align 8
  %call = call i32 @authenticateClientWithUser(ptr noundef %0, ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @authenticateClientWithUser(ptr noundef %ctx, ptr noundef %user, ptr noundef %callback, ptr noundef %privdata, ptr noundef %client_id) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %user.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %client_id.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %user, ptr %user.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  store ptr %client_id, ptr %client_id.addr, align 8
  %0 = load ptr, ptr %user.addr, align 8
  %flags = getelementptr inbounds %struct.user, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %client, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then6

lor.lhs.false:                                    ; preds = %if.end
  %4 = load ptr, ptr %ctx.addr, align 8
  %client2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %client2, align 8
  %flags3 = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %flags3, align 8
  %and4 = and i64 %6, 134217728
  %tobool5 = icmp ne i64 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %lor.lhs.false
  %7 = load ptr, ptr %ctx.addr, align 8
  %client8 = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %client8, align 8
  call void @moduleNotifyUserChanged(ptr noundef %8)
  %9 = load ptr, ptr %user.addr, align 8
  %10 = load ptr, ptr %ctx.addr, align 8
  %client9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %client9, align 8
  %user10 = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 20
  store ptr %9, ptr %user10, align 8
  %12 = load ptr, ptr %ctx.addr, align 8
  %client11 = getelementptr inbounds %struct.RedisModuleCtx, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %client11, align 8
  %authenticated = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 34
  store i32 1, ptr %authenticated, align 8
  %14 = load ptr, ptr %ctx.addr, align 8
  %client12 = getelementptr inbounds %struct.RedisModuleCtx, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %client12, align 8
  %module_auth_ctx = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 67
  %16 = load ptr, ptr %module_auth_ctx, align 8
  %cmp = icmp ne ptr %16, null
  br i1 %cmp, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end7
  %17 = load ptr, ptr %ctx.addr, align 8
  %client14 = getelementptr inbounds %struct.RedisModuleCtx, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %client14, align 8
  %flags15 = getelementptr inbounds %struct.client, ptr %18, i32 0, i32 1
  %19 = load i64, ptr %flags15, align 8
  %or = or i64 %19, 140737488355328
  store i64 %or, ptr %flags15, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end7
  %20 = load ptr, ptr %callback.addr, align 8
  %tobool17 = icmp ne ptr %20, null
  br i1 %tobool17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %if.end16
  %21 = load ptr, ptr %callback.addr, align 8
  %22 = load ptr, ptr %ctx.addr, align 8
  %client19 = getelementptr inbounds %struct.RedisModuleCtx, ptr %22, i32 0, i32 2
  %23 = load ptr, ptr %client19, align 8
  %auth_callback = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 68
  store ptr %21, ptr %auth_callback, align 8
  %24 = load ptr, ptr %privdata.addr, align 8
  %25 = load ptr, ptr %ctx.addr, align 8
  %client20 = getelementptr inbounds %struct.RedisModuleCtx, ptr %25, i32 0, i32 2
  %26 = load ptr, ptr %client20, align 8
  %auth_callback_privdata = getelementptr inbounds %struct.client, ptr %26, i32 0, i32 69
  store ptr %24, ptr %auth_callback_privdata, align 8
  %27 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %module, align 8
  %29 = load ptr, ptr %ctx.addr, align 8
  %client21 = getelementptr inbounds %struct.RedisModuleCtx, ptr %29, i32 0, i32 2
  %30 = load ptr, ptr %client21, align 8
  %auth_module = getelementptr inbounds %struct.client, ptr %30, i32 0, i32 70
  store ptr %28, ptr %auth_module, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.then18, %if.end16
  %31 = load ptr, ptr %client_id.addr, align 8
  %tobool23 = icmp ne ptr %31, null
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end22
  %32 = load ptr, ptr %ctx.addr, align 8
  %client25 = getelementptr inbounds %struct.RedisModuleCtx, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %client25, align 8
  %id = getelementptr inbounds %struct.client, ptr %33, i32 0, i32 0
  %34 = load i64, ptr %id, align 8
  %35 = load ptr, ptr %client_id.addr, align 8
  store i64 %34, ptr %35, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end22
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end26, %if.then6, %if.then
  %36 = load i32, ptr %retval, align 4
  ret i32 %36
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_AuthenticateClientWithACLUser(ptr noundef %ctx, ptr noundef %name, i64 noundef %len, ptr noundef %callback, ptr noundef %privdata, ptr noundef %client_id) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %callback.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %client_id.addr = alloca ptr, align 8
  %acl_user = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  store ptr %client_id, ptr %client_id.addr, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %call = call ptr @ACLGetUserByName(ptr noundef %0, i64 noundef %1)
  store ptr %call, ptr %acl_user, align 8
  %2 = load ptr, ptr %acl_user, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load ptr, ptr %acl_user, align 8
  %5 = load ptr, ptr %callback.addr, align 8
  %6 = load ptr, ptr %privdata.addr, align 8
  %7 = load ptr, ptr %client_id.addr, align 8
  %call1 = call i32 @authenticateClientWithUser(ptr noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %6, ptr noundef %7)
  store i32 %call1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DeauthenticateAndCloseClient(ptr noundef %ctx, i64 noundef %client_id) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %client_id.addr = alloca i64, align 8
  %c = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %client_id, ptr %client_id.addr, align 8
  %0 = load i64, ptr %client_id.addr, align 8
  %call = call ptr @lookupClientByID(i64 noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  call void @revokeClientAuthentication(ptr noundef %2)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RedactClientCommandArgument(ptr noundef %ctx, i32 noundef %pos) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %client, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false2, label %if.then

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load i32, ptr %pos.addr, align 4
  %cmp = icmp sle i32 %3, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false2
  %4 = load ptr, ptr %ctx.addr, align 8
  %client4 = getelementptr inbounds %struct.RedisModuleCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %client4, align 8
  %argc = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 11
  %6 = load i32, ptr %argc, align 8
  %7 = load i32, ptr %pos.addr, align 4
  %cmp5 = icmp sle i32 %6, %7
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false3, %lor.lhs.false2, %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false3
  %8 = load ptr, ptr %ctx.addr, align 8
  %client6 = getelementptr inbounds %struct.RedisModuleCtx, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %client6, align 8
  %10 = load i32, ptr %pos.addr, align 4
  call void @redactClientCommandArgument(ptr noundef %9, i32 noundef %10)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

declare void @redactClientCommandArgument(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetClientCertificate(ptr noundef %ctx, i64 noundef %client_id) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %client_id.addr = alloca i64, align 8
  %c = alloca ptr, align 8
  %cert = alloca ptr, align 8
  %s = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %client_id, ptr %client_id.addr, align 8
  %0 = load i64, ptr %client_id.addr, align 8
  %call = call ptr @lookupClientByID(i64 noundef %0)
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  %conn = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %conn, align 8
  %call1 = call ptr @connGetPeerCert(ptr noundef %3)
  store ptr %call1, ptr %cert, align 8
  %4 = load ptr, ptr %cert, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load ptr, ptr %cert, align 8
  %call4 = call ptr @createObject(i32 noundef 0, ptr noundef %5)
  store ptr %call4, ptr %s, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %cmp5 = icmp ne ptr %6, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  %7 = load ptr, ptr %ctx.addr, align 8
  %8 = load ptr, ptr %s, align 8
  call void @autoMemoryAdd(ptr noundef %7, i32 noundef 1, ptr noundef %8)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end3
  %9 = load ptr, ptr %s, align 8
  store ptr %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end7, %if.then2, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define internal ptr @connGetPeerCert(ptr noundef %conn) #0 {
entry:
  %retval = alloca ptr, align 8
  %conn.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %type, align 8
  %get_peer_cert = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 27
  %2 = load ptr, ptr %get_peer_cert, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %conn.addr, align 8
  %type1 = getelementptr inbounds %struct.connection, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %type1, align 8
  %get_peer_cert2 = getelementptr inbounds %struct.ConnectionType, ptr %4, i32 0, i32 27
  %5 = load ptr, ptr %get_peer_cert2, align 8
  %6 = load ptr, ptr %conn.addr, align 8
  %call = call ptr %5(ptr noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CreateDict(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %d = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 8) #11
  store ptr %call, ptr %d, align 8
  %call1 = call ptr @raxNew()
  %0 = load ptr, ptr %d, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %0, i32 0, i32 0
  store ptr %call1, ptr %rax, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %d, align 8
  call void @autoMemoryAdd(ptr noundef %2, i32 noundef 4, ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %d, align 8
  ret ptr %4
}

declare ptr @raxNew() #1

declare void @raxFree(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_DictSize(ptr noundef %d) #0 {
entry:
  %d.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %call = call i64 @raxSize(ptr noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictSetC(ptr noundef %d, ptr noundef %key, i64 noundef %keylen, ptr noundef %ptr) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %keylen.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  %retval1 = alloca i32, align 4
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %keylen, ptr %keylen.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %3 = load i64, ptr %keylen.addr, align 8
  %4 = load ptr, ptr %ptr.addr, align 8
  %call = call i32 @raxTryInsert(ptr noundef %1, ptr noundef %2, i64 noundef %3, ptr noundef %4, ptr noundef null)
  store i32 %call, ptr %retval1, align 4
  %5 = load i32, ptr %retval1, align 4
  %cmp = icmp eq i32 %5, 1
  %cond = select i1 %cmp, i32 0, i32 1
  ret i32 %cond
}

declare i32 @raxTryInsert(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictReplaceC(ptr noundef %d, ptr noundef %key, i64 noundef %keylen, ptr noundef %ptr) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %keylen.addr = alloca i64, align 8
  %ptr.addr = alloca ptr, align 8
  %retval1 = alloca i32, align 4
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %keylen, ptr %keylen.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %3 = load i64, ptr %keylen.addr, align 8
  %4 = load ptr, ptr %ptr.addr, align 8
  %call = call i32 @raxInsert(ptr noundef %1, ptr noundef %2, i64 noundef %3, ptr noundef %4, ptr noundef null)
  store i32 %call, ptr %retval1, align 4
  %5 = load i32, ptr %retval1, align 4
  %cmp = icmp eq i32 %5, 1
  %cond = select i1 %cmp, i32 0, i32 1
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictSet(ptr noundef %d, ptr noundef %key, ptr noundef %ptr) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %ptr1, align 8
  %3 = load ptr, ptr %key.addr, align 8
  %ptr2 = getelementptr inbounds %struct.redisObject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ptr2, align 8
  %call = call i64 @sdslen(ptr noundef %4)
  %5 = load ptr, ptr %ptr.addr, align 8
  %call3 = call i32 @RM_DictSetC(ptr noundef %0, ptr noundef %2, i64 noundef %call, ptr noundef %5)
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictReplace(ptr noundef %d, ptr noundef %key, ptr noundef %ptr) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %ptr1, align 8
  %3 = load ptr, ptr %key.addr, align 8
  %ptr2 = getelementptr inbounds %struct.redisObject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ptr2, align 8
  %call = call i64 @sdslen(ptr noundef %4)
  %5 = load ptr, ptr %ptr.addr, align 8
  %call3 = call i32 @RM_DictReplaceC(ptr noundef %0, ptr noundef %2, i64 noundef %call, ptr noundef %5)
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictGetC(ptr noundef %d, ptr noundef %key, i64 noundef %keylen, ptr noundef %nokey) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %keylen.addr = alloca i64, align 8
  %nokey.addr = alloca ptr, align 8
  %res = alloca ptr, align 8
  %found = alloca i32, align 4
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %keylen, ptr %keylen.addr, align 8
  store ptr %nokey, ptr %nokey.addr, align 8
  store ptr null, ptr %res, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %3 = load i64, ptr %keylen.addr, align 8
  %call = call i32 @raxFind(ptr noundef %1, ptr noundef %2, i64 noundef %3, ptr noundef %res)
  store i32 %call, ptr %found, align 4
  %4 = load ptr, ptr %nokey.addr, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, ptr %found, align 4
  %tobool1 = icmp ne i32 %5, 0
  %lnot = xor i1 %tobool1, true
  %lnot.ext = zext i1 %lnot to i32
  %6 = load ptr, ptr %nokey.addr, align 8
  store i32 %lnot.ext, ptr %6, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %res, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictGet(ptr noundef %d, ptr noundef %key, ptr noundef %nokey) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %nokey.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %nokey, ptr %nokey.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %3 = load ptr, ptr %key.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ptr1, align 8
  %call = call i64 @sdslen(ptr noundef %4)
  %5 = load ptr, ptr %nokey.addr, align 8
  %call2 = call ptr @RM_DictGetC(ptr noundef %0, ptr noundef %2, i64 noundef %call, ptr noundef %5)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictDelC(ptr noundef %d, ptr noundef %key, i64 noundef %keylen, ptr noundef %oldval) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %keylen.addr = alloca i64, align 8
  %oldval.addr = alloca ptr, align 8
  %retval1 = alloca i32, align 4
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %keylen, ptr %keylen.addr, align 8
  store ptr %oldval, ptr %oldval.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %3 = load i64, ptr %keylen.addr, align 8
  %4 = load ptr, ptr %oldval.addr, align 8
  %call = call i32 @raxRemove(ptr noundef %1, ptr noundef %2, i64 noundef %3, ptr noundef %4)
  store i32 %call, ptr %retval1, align 4
  %5 = load i32, ptr %retval1, align 4
  %tobool = icmp ne i32 %5, 0
  %cond = select i1 %tobool, i32 0, i32 1
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictDel(ptr noundef %d, ptr noundef %key, ptr noundef %oldval) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %oldval.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %oldval, ptr %oldval.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %3 = load ptr, ptr %key.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ptr1, align 8
  %call = call i64 @sdslen(ptr noundef %4)
  %5 = load ptr, ptr %oldval.addr, align 8
  %call2 = call i32 @RM_DictDelC(ptr noundef %0, ptr noundef %2, i64 noundef %call, ptr noundef %5)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictIteratorStartC(ptr noundef %d, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %keylen.addr = alloca i64, align 8
  %di = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %keylen, ptr %keylen.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 488) #11
  store ptr %call, ptr %di, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %1 = load ptr, ptr %di, align 8
  %dict = getelementptr inbounds %struct.RedisModuleDictIter, ptr %1, i32 0, i32 0
  store ptr %0, ptr %dict, align 8
  %2 = load ptr, ptr %di, align 8
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %d.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %rax, align 8
  call void @raxStart(ptr noundef %ri, ptr noundef %4)
  %5 = load ptr, ptr %di, align 8
  %ri1 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %op.addr, align 8
  %7 = load ptr, ptr %key.addr, align 8
  %8 = load i64, ptr %keylen.addr, align 8
  %call2 = call i32 @raxSeek(ptr noundef %ri1, ptr noundef %6, ptr noundef %7, i64 noundef %8)
  %9 = load ptr, ptr %di, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictIteratorStart(ptr noundef %d, ptr noundef %op, ptr noundef %key) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  %1 = load ptr, ptr %op.addr, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %4 = load ptr, ptr %key.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %ptr1, align 8
  %call = call i64 @sdslen(ptr noundef %5)
  %call2 = call ptr @RM_DictIteratorStartC(ptr noundef %0, ptr noundef %1, ptr noundef %3, i64 noundef %call)
  ret ptr %call2
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_DictIteratorStop(ptr noundef %di) #0 {
entry:
  %di.addr = alloca ptr, align 8
  store ptr %di, ptr %di.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %0, i32 0, i32 1
  call void @raxStop(ptr noundef %ri)
  %1 = load ptr, ptr %di.addr, align 8
  call void @zfree(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictIteratorReseekC(ptr noundef %di, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #0 {
entry:
  %di.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %keylen.addr = alloca i64, align 8
  store ptr %di, ptr %di.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %keylen, ptr %keylen.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %op.addr, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %3 = load i64, ptr %keylen.addr, align 8
  %call = call i32 @raxSeek(ptr noundef %ri, ptr noundef %1, ptr noundef %2, i64 noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictIteratorReseek(ptr noundef %di, ptr noundef %op, ptr noundef %key) #0 {
entry:
  %di.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  store ptr %di, ptr %di.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %1 = load ptr, ptr %op.addr, align 8
  %2 = load ptr, ptr %key.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %4 = load ptr, ptr %key.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %ptr1, align 8
  %call = call i64 @sdslen(ptr noundef %5)
  %call2 = call i32 @RM_DictIteratorReseekC(ptr noundef %0, ptr noundef %1, ptr noundef %3, i64 noundef %call)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictNextC(ptr noundef %di, ptr noundef %keylen, ptr noundef %dataptr) #0 {
entry:
  %retval = alloca ptr, align 8
  %di.addr = alloca ptr, align 8
  %keylen.addr = alloca ptr, align 8
  %dataptr.addr = alloca ptr, align 8
  store ptr %di, ptr %di.addr, align 8
  store ptr %keylen, ptr %keylen.addr, align 8
  store ptr %dataptr, ptr %dataptr.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %0, i32 0, i32 1
  %call = call i32 @raxNext(ptr noundef %ri)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %keylen.addr, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr %di.addr, align 8
  %ri3 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %2, i32 0, i32 1
  %key_len = getelementptr inbounds %struct.raxIterator, ptr %ri3, i32 0, i32 4
  %3 = load i64, ptr %key_len, align 8
  %4 = load ptr, ptr %keylen.addr, align 8
  store i64 %3, ptr %4, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %5 = load ptr, ptr %dataptr.addr, align 8
  %tobool5 = icmp ne ptr %5, null
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %6 = load ptr, ptr %di.addr, align 8
  %ri7 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %6, i32 0, i32 1
  %data = getelementptr inbounds %struct.raxIterator, ptr %ri7, i32 0, i32 3
  %7 = load ptr, ptr %data, align 8
  %8 = load ptr, ptr %dataptr.addr, align 8
  store ptr %7, ptr %8, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %9 = load ptr, ptr %di.addr, align 8
  %ri9 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %9, i32 0, i32 1
  %key = getelementptr inbounds %struct.raxIterator, ptr %ri9, i32 0, i32 2
  %10 = load ptr, ptr %key, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictPrevC(ptr noundef %di, ptr noundef %keylen, ptr noundef %dataptr) #0 {
entry:
  %retval = alloca ptr, align 8
  %di.addr = alloca ptr, align 8
  %keylen.addr = alloca ptr, align 8
  %dataptr.addr = alloca ptr, align 8
  store ptr %di, ptr %di.addr, align 8
  store ptr %keylen, ptr %keylen.addr, align 8
  store ptr %dataptr, ptr %dataptr.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %0, i32 0, i32 1
  %call = call i32 @raxPrev(ptr noundef %ri)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %keylen.addr, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr %di.addr, align 8
  %ri3 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %2, i32 0, i32 1
  %key_len = getelementptr inbounds %struct.raxIterator, ptr %ri3, i32 0, i32 4
  %3 = load i64, ptr %key_len, align 8
  %4 = load ptr, ptr %keylen.addr, align 8
  store i64 %3, ptr %4, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %5 = load ptr, ptr %dataptr.addr, align 8
  %tobool5 = icmp ne ptr %5, null
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %6 = load ptr, ptr %di.addr, align 8
  %ri7 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %6, i32 0, i32 1
  %data = getelementptr inbounds %struct.raxIterator, ptr %ri7, i32 0, i32 3
  %7 = load ptr, ptr %data, align 8
  %8 = load ptr, ptr %dataptr.addr, align 8
  store ptr %7, ptr %8, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %9 = load ptr, ptr %di.addr, align 8
  %ri9 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %9, i32 0, i32 1
  %key = getelementptr inbounds %struct.raxIterator, ptr %ri9, i32 0, i32 2
  %10 = load ptr, ptr %key, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

declare i32 @raxPrev(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictNext(ptr noundef %ctx, ptr noundef %di, ptr noundef %dataptr) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %di.addr = alloca ptr, align 8
  %dataptr.addr = alloca ptr, align 8
  %keylen = alloca i64, align 8
  %key = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %di, ptr %di.addr, align 8
  store ptr %dataptr, ptr %dataptr.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %1 = load ptr, ptr %dataptr.addr, align 8
  %call = call ptr @RM_DictNextC(ptr noundef %0, ptr noundef %keylen, ptr noundef %1)
  store ptr %call, ptr %key, align 8
  %2 = load ptr, ptr %key, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load ptr, ptr %key, align 8
  %5 = load i64, ptr %keylen, align 8
  %call1 = call ptr @RM_CreateString(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DictPrev(ptr noundef %ctx, ptr noundef %di, ptr noundef %dataptr) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %di.addr = alloca ptr, align 8
  %dataptr.addr = alloca ptr, align 8
  %keylen = alloca i64, align 8
  %key = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %di, ptr %di.addr, align 8
  store ptr %dataptr, ptr %dataptr.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %1 = load ptr, ptr %dataptr.addr, align 8
  %call = call ptr @RM_DictPrevC(ptr noundef %0, ptr noundef %keylen, ptr noundef %1)
  store ptr %call, ptr %key, align 8
  %2 = load ptr, ptr %key, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load ptr, ptr %key, align 8
  %5 = load i64, ptr %keylen, align 8
  %call1 = call ptr @RM_CreateString(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictCompareC(ptr noundef %di, ptr noundef %op, ptr noundef %key, i64 noundef %keylen) #0 {
entry:
  %retval = alloca i32, align 4
  %di.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %keylen.addr = alloca i64, align 8
  %res = alloca i32, align 4
  store ptr %di, ptr %di.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %keylen, ptr %keylen.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %0, i32 0, i32 1
  %call = call i32 @raxEOF(ptr noundef %ri)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %di.addr, align 8
  %ri1 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %op.addr, align 8
  %3 = load ptr, ptr %key.addr, align 8
  %4 = load i64, ptr %keylen.addr, align 8
  %call2 = call i32 @raxCompare(ptr noundef %ri1, ptr noundef %2, ptr noundef %3, i64 noundef %4)
  store i32 %call2, ptr %res, align 4
  %5 = load i32, ptr %res, align 4
  %tobool3 = icmp ne i32 %5, 0
  %cond = select i1 %tobool3, i32 0, i32 1
  store i32 %cond, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @raxEOF(ptr noundef) #1

declare i32 @raxCompare(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DictCompare(ptr noundef %di, ptr noundef %op, ptr noundef %key) #0 {
entry:
  %retval = alloca i32, align 4
  %di.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  %res = alloca i32, align 4
  store ptr %di, ptr %di.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %di.addr, align 8
  %ri = getelementptr inbounds %struct.RedisModuleDictIter, ptr %0, i32 0, i32 1
  %call = call i32 @raxEOF(ptr noundef %ri)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %di.addr, align 8
  %ri1 = getelementptr inbounds %struct.RedisModuleDictIter, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %op.addr, align 8
  %3 = load ptr, ptr %key.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ptr, align 8
  %5 = load ptr, ptr %key.addr, align 8
  %ptr2 = getelementptr inbounds %struct.redisObject, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ptr2, align 8
  %call3 = call i64 @sdslen(ptr noundef %6)
  %call4 = call i32 @raxCompare(ptr noundef %ri1, ptr noundef %2, ptr noundef %4, i64 noundef %call3)
  store i32 %call4, ptr %res, align 4
  %7 = load i32, ptr %res, align 4
  %tobool5 = icmp ne i32 %7, 0
  %cond = select i1 %tobool5, i32 0, i32 1
  store i32 %cond, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_InfoAddSection(ptr noundef %ctx, ptr noundef %name) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %full_name = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %module, align 8
  %name1 = getelementptr inbounds %struct.RedisModule, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %name1, align 8
  %call = call ptr @sdsdup(ptr noundef %2)
  store ptr %call, ptr %full_name, align 8
  %3 = load ptr, ptr %name.addr, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %name.addr, align 8
  %call2 = call i64 @strlen(ptr noundef %4) #14
  %cmp3 = icmp ugt i64 %call2, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load ptr, ptr %full_name, align 8
  %6 = load ptr, ptr %name.addr, align 8
  %call4 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %5, ptr noundef @.str.81, ptr noundef %6)
  store ptr %call4, ptr %full_name, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %7 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %7, i32 0, i32 5
  %8 = load i32, ptr %in_dict_field, align 8
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %9 = load ptr, ptr %ctx.addr, align 8
  %call6 = call i32 @RM_InfoEndDictField(ptr noundef %9)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %10 = load ptr, ptr %ctx.addr, align 8
  %requested_sections = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %requested_sections, align 8
  %tobool8 = icmp ne ptr %11, null
  br i1 %tobool8, label %if.then9, label %if.end22

if.then9:                                         ; preds = %if.end7
  %12 = load ptr, ptr %full_name, align 8
  %tobool10 = icmp ne ptr %12, null
  br i1 %tobool10, label %lor.lhs.false, label %land.lhs.true14

lor.lhs.false:                                    ; preds = %if.then9
  %13 = load ptr, ptr %ctx.addr, align 8
  %requested_sections11 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %requested_sections11, align 8
  %15 = load ptr, ptr %full_name, align 8
  %call12 = call ptr @dictFind(ptr noundef %14, ptr noundef %15)
  %tobool13 = icmp ne ptr %call12, null
  br i1 %tobool13, label %if.end21, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %lor.lhs.false, %if.then9
  %16 = load ptr, ptr %ctx.addr, align 8
  %requested_sections15 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %requested_sections15, align 8
  %18 = load ptr, ptr %ctx.addr, align 8
  %module16 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %module16, align 8
  %name17 = getelementptr inbounds %struct.RedisModule, ptr %19, i32 0, i32 1
  %20 = load ptr, ptr %name17, align 8
  %call18 = call ptr @dictFind(ptr noundef %17, ptr noundef %20)
  %tobool19 = icmp ne ptr %call18, null
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %land.lhs.true14
  %21 = load ptr, ptr %full_name, align 8
  call void @sdsfree(ptr noundef %21)
  %22 = load ptr, ptr %ctx.addr, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %22, i32 0, i32 4
  store i32 0, ptr %in_section, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %land.lhs.true14, %lor.lhs.false
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end7
  %23 = load ptr, ptr %ctx.addr, align 8
  %sections = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %23, i32 0, i32 3
  %24 = load i32, ptr %sections, align 8
  %inc = add nsw i32 %24, 1
  store i32 %inc, ptr %sections, align 8
  %tobool23 = icmp ne i32 %24, 0
  br i1 %tobool23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.end22
  %25 = load ptr, ptr %ctx.addr, align 8
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %25, i32 0, i32 2
  %26 = load ptr, ptr %info, align 8
  %call25 = call ptr @sdscat(ptr noundef %26, ptr noundef @.str.36)
  %27 = load ptr, ptr %ctx.addr, align 8
  %info26 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %27, i32 0, i32 2
  store ptr %call25, ptr %info26, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %if.end22
  %28 = load ptr, ptr %ctx.addr, align 8
  %info28 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %28, i32 0, i32 2
  %29 = load ptr, ptr %info28, align 8
  %30 = load ptr, ptr %full_name, align 8
  %call29 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %29, ptr noundef @.str.82, ptr noundef %30)
  %31 = load ptr, ptr %ctx.addr, align 8
  %info30 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %31, i32 0, i32 2
  store ptr %call29, ptr %info30, align 8
  %32 = load ptr, ptr %ctx.addr, align 8
  %in_section31 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %32, i32 0, i32 4
  store i32 1, ptr %in_section31, align 4
  %33 = load ptr, ptr %full_name, align 8
  call void @sdsfree(ptr noundef %33)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then20
  %34 = load i32, ptr %retval, align 4
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_InfoEndDictField(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %in_dict_field, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %info, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %info1 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %info1, align 8
  %call = call i64 @sdslen(ptr noundef %5)
  %sub = sub i64 %call, 1
  %arrayidx = getelementptr inbounds i8, ptr %3, i64 %sub
  %6 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %6 to i32
  %cmp = icmp eq i32 %conv, 44
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %7 = load ptr, ptr %ctx.addr, align 8
  %info4 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %info4, align 8
  call void @sdsIncrLen(ptr noundef %8, i64 noundef -1)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %9 = load ptr, ptr %ctx.addr, align 8
  %info6 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %info6, align 8
  %call7 = call ptr @sdscat(ptr noundef %10, ptr noundef @.str.36)
  %11 = load ptr, ptr %ctx.addr, align 8
  %info8 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %11, i32 0, i32 2
  store ptr %call7, ptr %info8, align 8
  %12 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field9 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %12, i32 0, i32 5
  store i32 0, ptr %in_dict_field9, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

declare ptr @sdscat(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_InfoBeginDictField(ptr noundef %ctx, ptr noundef %name) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %tmpmodname = alloca ptr, align 8
  %tmpname = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %in_section, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %in_dict_field, align 8
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %ctx.addr, align 8
  %call = call i32 @RM_InfoEndDictField(ptr noundef %4)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %5 = load ptr, ptr %ctx.addr, align 8
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %info, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %module, align 8
  %name4 = getelementptr inbounds %struct.RedisModule, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %name4, align 8
  %10 = load ptr, ptr %ctx.addr, align 8
  %module5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %module5, align 8
  %name6 = getelementptr inbounds %struct.RedisModule, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %name6, align 8
  %call7 = call i64 @strlen(ptr noundef %12) #14
  %call8 = call ptr @getSafeInfoString(ptr noundef %9, i64 noundef %call7, ptr noundef %tmpmodname)
  %13 = load ptr, ptr %name.addr, align 8
  %14 = load ptr, ptr %name.addr, align 8
  %call9 = call i64 @strlen(ptr noundef %14) #14
  %call10 = call ptr @getSafeInfoString(ptr noundef %13, i64 noundef %call9, ptr noundef %tmpname)
  %call11 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %6, ptr noundef @.str.83, ptr noundef %call8, ptr noundef %call10)
  %15 = load ptr, ptr %ctx.addr, align 8
  %info12 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %15, i32 0, i32 2
  store ptr %call11, ptr %info12, align 8
  %16 = load ptr, ptr %tmpmodname, align 8
  %cmp = icmp ne ptr %16, null
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end3
  %17 = load ptr, ptr %tmpmodname, align 8
  call void @zfree(ptr noundef %17)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end3
  %18 = load ptr, ptr %tmpname, align 8
  %cmp15 = icmp ne ptr %18, null
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end14
  %19 = load ptr, ptr %tmpname, align 8
  call void @zfree(ptr noundef %19)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end14
  %20 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field18 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %20, i32 0, i32 5
  store i32 1, ptr %in_dict_field18, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end17, %if.then
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

declare ptr @getSafeInfoString(ptr noundef, i64 noundef, ptr noundef) #1

declare void @sdsIncrLen(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_InfoAddFieldString(ptr noundef %ctx, ptr noundef %field, ptr noundef %value) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %in_section, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %in_dict_field, align 8
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %ctx.addr, align 8
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %info, align 8
  %6 = load ptr, ptr %field.addr, align 8
  %7 = load ptr, ptr %value.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %ptr, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %5, ptr noundef @.str.84, ptr noundef %6, ptr noundef %8)
  %9 = load ptr, ptr %ctx.addr, align 8
  %info3 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %9, i32 0, i32 2
  store ptr %call, ptr %info3, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %10 = load ptr, ptr %ctx.addr, align 8
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %info5, align 8
  %12 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %name, align 8
  %15 = load ptr, ptr %field.addr, align 8
  %16 = load ptr, ptr %value.addr, align 8
  %ptr6 = getelementptr inbounds %struct.redisObject, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %ptr6, align 8
  %call7 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %11, ptr noundef @.str.85, ptr noundef %14, ptr noundef %15, ptr noundef %17)
  %18 = load ptr, ptr %ctx.addr, align 8
  %info8 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %18, i32 0, i32 2
  store ptr %call7, ptr %info8, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then2, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_InfoAddFieldCString(ptr noundef %ctx, ptr noundef %field, ptr noundef %value) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %in_section, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %in_dict_field, align 8
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %ctx.addr, align 8
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %info, align 8
  %6 = load ptr, ptr %field.addr, align 8
  %7 = load ptr, ptr %value.addr, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %5, ptr noundef @.str.86, ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %ctx.addr, align 8
  %info3 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %8, i32 0, i32 2
  store ptr %call, ptr %info3, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %9 = load ptr, ptr %ctx.addr, align 8
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %info5, align 8
  %11 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %name, align 8
  %14 = load ptr, ptr %field.addr, align 8
  %15 = load ptr, ptr %value.addr, align 8
  %call6 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %10, ptr noundef @.str.87, ptr noundef %13, ptr noundef %14, ptr noundef %15)
  %16 = load ptr, ptr %ctx.addr, align 8
  %info7 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %16, i32 0, i32 2
  store ptr %call6, ptr %info7, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then2, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_InfoAddFieldDouble(ptr noundef %ctx, ptr noundef %field, double noundef %value) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %value.addr = alloca double, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store double %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %in_section, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %in_dict_field, align 8
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %ctx.addr, align 8
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %info, align 8
  %6 = load ptr, ptr %field.addr, align 8
  %7 = load double, ptr %value.addr, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %5, ptr noundef @.str.88, ptr noundef %6, double noundef %7)
  %8 = load ptr, ptr %ctx.addr, align 8
  %info3 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %8, i32 0, i32 2
  store ptr %call, ptr %info3, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %9 = load ptr, ptr %ctx.addr, align 8
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %info5, align 8
  %11 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %name, align 8
  %14 = load ptr, ptr %field.addr, align 8
  %15 = load double, ptr %value.addr, align 8
  %call6 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %10, ptr noundef @.str.89, ptr noundef %13, ptr noundef %14, double noundef %15)
  %16 = load ptr, ptr %ctx.addr, align 8
  %info7 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %16, i32 0, i32 2
  store ptr %call6, ptr %info7, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then2, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare ptr @sdscatprintf(ptr noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_InfoAddFieldLongLong(ptr noundef %ctx, ptr noundef %field, i64 noundef %value) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %in_section, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %in_dict_field, align 8
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %ctx.addr, align 8
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %info, align 8
  %6 = load ptr, ptr %field.addr, align 8
  %7 = load i64, ptr %value.addr, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %5, ptr noundef @.str.90, ptr noundef %6, i64 noundef %7)
  %8 = load ptr, ptr %ctx.addr, align 8
  %info3 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %8, i32 0, i32 2
  store ptr %call, ptr %info3, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %9 = load ptr, ptr %ctx.addr, align 8
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %info5, align 8
  %11 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %name, align 8
  %14 = load ptr, ptr %field.addr, align 8
  %15 = load i64, ptr %value.addr, align 8
  %call6 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %10, ptr noundef @.str.91, ptr noundef %13, ptr noundef %14, i64 noundef %15)
  %16 = load ptr, ptr %ctx.addr, align 8
  %info7 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %16, i32 0, i32 2
  store ptr %call6, ptr %info7, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then2, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_InfoAddFieldULongLong(ptr noundef %ctx, ptr noundef %field, i64 noundef %value) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %value.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store i64 %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %in_section, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %2, i32 0, i32 5
  %3 = load i32, ptr %in_dict_field, align 8
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %ctx.addr, align 8
  %info = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %info, align 8
  %6 = load ptr, ptr %field.addr, align 8
  %7 = load i64, ptr %value.addr, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %5, ptr noundef @.str.92, ptr noundef %6, i64 noundef %7)
  %8 = load ptr, ptr %ctx.addr, align 8
  %info3 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %8, i32 0, i32 2
  store ptr %call, ptr %info3, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %9 = load ptr, ptr %ctx.addr, align 8
  %info5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %info5, align 8
  %11 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %name, align 8
  %14 = load ptr, ptr %field.addr, align 8
  %15 = load i64, ptr %value.addr, align 8
  %call6 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %10, ptr noundef @.str.93, ptr noundef %13, ptr noundef %14, i64 noundef %15)
  %16 = load ptr, ptr %ctx.addr, align 8
  %info7 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %16, i32 0, i32 2
  store ptr %call6, ptr %info7, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then2, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RegisterInfoFunc(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %info_cb = getelementptr inbounds %struct.RedisModule, ptr %2, i32 0, i32 14
  store ptr %0, ptr %info_cb, align 8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @modulesCollectInfo(ptr noundef %info, ptr noundef %sections_dict, i32 noundef %for_crash_report, i32 noundef %sections) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %sections_dict.addr = alloca ptr, align 8
  %for_crash_report.addr = alloca i32, align 4
  %sections.addr = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %module = alloca ptr, align 8
  %info_ctx = alloca %struct.RedisModuleInfoCtx, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %sections_dict, ptr %sections_dict.addr, align 8
  store i32 %for_crash_report, ptr %for_crash_report.addr, align 4
  store i32 %sections, ptr %sections.addr, align 4
  %0 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.then, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %module, align 8
  %3 = load ptr, ptr %module, align 8
  %info_cb = getelementptr inbounds %struct.RedisModule, ptr %3, i32 0, i32 14
  %4 = load ptr, ptr %info_cb, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !55

if.end:                                           ; preds = %while.body
  %module3 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 0
  %5 = load ptr, ptr %module, align 8
  store ptr %5, ptr %module3, align 8
  %requested_sections = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 1
  %6 = load ptr, ptr %sections_dict.addr, align 8
  store ptr %6, ptr %requested_sections, align 8
  %info4 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 2
  %7 = load ptr, ptr %info.addr, align 8
  store ptr %7, ptr %info4, align 8
  %sections5 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 3
  %8 = load i32, ptr %sections.addr, align 4
  store i32 %8, ptr %sections5, align 8
  %in_section = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 4
  store i32 0, ptr %in_section, align 4
  %in_dict_field = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 5
  store i32 0, ptr %in_dict_field, align 8
  %9 = load ptr, ptr %module, align 8
  %info_cb6 = getelementptr inbounds %struct.RedisModule, ptr %9, i32 0, i32 14
  %10 = load ptr, ptr %info_cb6, align 8
  %11 = load i32, ptr %for_crash_report.addr, align 4
  call void %10(ptr noundef %info_ctx, i32 noundef %11)
  %in_dict_field7 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 5
  %12 = load i32, ptr %in_dict_field7, align 8
  %tobool8 = icmp ne i32 %12, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %call10 = call i32 @RM_InfoEndDictField(ptr noundef %info_ctx)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end
  %info12 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 2
  %13 = load ptr, ptr %info12, align 8
  store ptr %13, ptr %info.addr, align 8
  %sections13 = getelementptr inbounds %struct.RedisModuleInfoCtx, ptr %info_ctx, i32 0, i32 3
  %14 = load i32, ptr %sections13, align 8
  store i32 %14, ptr %sections.addr, align 4
  br label %while.cond, !llvm.loop !55

while.end:                                        ; preds = %while.cond
  %15 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %15)
  %16 = load ptr, ptr %info.addr, align 8
  ret ptr %16
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetServerInfo(ptr noundef %ctx, ptr noundef %section) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %section.addr = alloca ptr, align 8
  %d = alloca ptr, align 8
  %all = alloca i32, align 4
  %everything = alloca i32, align 4
  %argv = alloca [1 x ptr], align 8
  %section_dict = alloca ptr, align 8
  %info = alloca ptr, align 8
  %totlines = alloca i32, align 4
  %i = alloca i32, align 4
  %lines = alloca ptr, align 8
  %line = alloca ptr, align 8
  %sep = alloca ptr, align 8
  %key = alloca ptr, align 8
  %keylen = alloca i64, align 8
  %val = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %section, ptr %section.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 8) #11
  store ptr %call, ptr %d, align 8
  %call1 = call ptr @raxNew()
  %0 = load ptr, ptr %d, align 8
  %rax = getelementptr inbounds %struct.RedisModuleServerInfoData, ptr %0, i32 0, i32 0
  store ptr %call1, ptr %rax, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %d, align 8
  call void @autoMemoryAdd(ptr noundef %2, i32 noundef 5, ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, ptr %all, align 4
  store i32 0, ptr %everything, align 4
  %4 = load ptr, ptr %section.addr, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load ptr, ptr %section.addr, align 8
  %6 = load ptr, ptr %section.addr, align 8
  %call2 = call i64 @strlen(ptr noundef %6) #14
  %call3 = call ptr @createStringObject(ptr noundef %5, i64 noundef %call2)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call3, %cond.true ], [ null, %cond.false ]
  %arrayidx = getelementptr inbounds [1 x ptr], ptr %argv, i64 0, i64 0
  store ptr %cond, ptr %arrayidx, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %argv, i64 0, i64 0
  %7 = load ptr, ptr %section.addr, align 8
  %tobool4 = icmp ne ptr %7, null
  %cond5 = select i1 %tobool4, i32 1, i32 0
  %call6 = call ptr @genInfoSectionDict(ptr noundef %arraydecay, i32 noundef %cond5, ptr noundef null, ptr noundef %all, ptr noundef %everything)
  store ptr %call6, ptr %section_dict, align 8
  %8 = load ptr, ptr %section_dict, align 8
  %9 = load i32, ptr %all, align 4
  %10 = load i32, ptr %everything, align 4
  %call7 = call ptr @genRedisInfoString(ptr noundef %8, i32 noundef %9, i32 noundef %10)
  store ptr %call7, ptr %info, align 8
  %11 = load ptr, ptr %info, align 8
  %12 = load ptr, ptr %info, align 8
  %call8 = call i64 @sdslen(ptr noundef %12)
  %call9 = call ptr @sdssplitlen(ptr noundef %11, i64 noundef %call8, ptr noundef @.str.36, i32 noundef 2, ptr noundef %totlines)
  store ptr %call9, ptr %lines, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %13 = load i32, ptr %i, align 4
  %14 = load i32, ptr %totlines, align 4
  %cmp10 = icmp slt i32 %13, %14
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load ptr, ptr %lines, align 8
  %16 = load i32, ptr %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx11 = getelementptr inbounds ptr, ptr %15, i64 %idxprom
  %17 = load ptr, ptr %arrayidx11, align 8
  store ptr %17, ptr %line, align 8
  %18 = load ptr, ptr %line, align 8
  %arrayidx12 = getelementptr inbounds i8, ptr %18, i64 0
  %19 = load i8, ptr %arrayidx12, align 1
  %conv = sext i8 %19 to i32
  %cmp13 = icmp eq i32 %conv, 35
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body
  br label %for.inc

if.end16:                                         ; preds = %for.body
  %20 = load ptr, ptr %line, align 8
  %call17 = call ptr @strchr(ptr noundef %20, i32 noundef 58) #14
  store ptr %call17, ptr %sep, align 8
  %21 = load ptr, ptr %sep, align 8
  %tobool18 = icmp ne ptr %21, null
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end16
  br label %for.inc

if.end20:                                         ; preds = %if.end16
  %22 = load ptr, ptr %line, align 8
  store ptr %22, ptr %key, align 8
  %23 = load ptr, ptr %sep, align 8
  %24 = ptrtoint ptr %23 to i64
  %25 = load ptr, ptr %line, align 8
  %26 = ptrtoint ptr %25 to i64
  %sub = sub nsw i64 %24, %26
  store i64 %sub, ptr %keylen, align 8
  %27 = load ptr, ptr %sep, align 8
  %add.ptr = getelementptr inbounds i8, ptr %27, i64 1
  %28 = load ptr, ptr %line, align 8
  %call21 = call i64 @sdslen(ptr noundef %28)
  %29 = load ptr, ptr %sep, align 8
  %30 = ptrtoint ptr %29 to i64
  %31 = load ptr, ptr %line, align 8
  %32 = ptrtoint ptr %31 to i64
  %sub22 = sub nsw i64 %30, %32
  %sub23 = sub i64 %call21, %sub22
  %sub24 = sub i64 %sub23, 1
  %call25 = call ptr @sdsnewlen(ptr noundef %add.ptr, i64 noundef %sub24)
  store ptr %call25, ptr %val, align 8
  %33 = load ptr, ptr %d, align 8
  %rax26 = getelementptr inbounds %struct.RedisModuleServerInfoData, ptr %33, i32 0, i32 0
  %34 = load ptr, ptr %rax26, align 8
  %35 = load ptr, ptr %key, align 8
  %36 = load i64, ptr %keylen, align 8
  %37 = load ptr, ptr %val, align 8
  %call27 = call i32 @raxTryInsert(ptr noundef %34, ptr noundef %35, i64 noundef %36, ptr noundef %37, ptr noundef null)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.end20
  %38 = load ptr, ptr %val, align 8
  call void @sdsfree(ptr noundef %38)
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end20
  br label %for.inc

for.inc:                                          ; preds = %if.end30, %if.then19, %if.then15
  %39 = load i32, ptr %i, align 4
  %inc = add nsw i32 %39, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !56

for.end:                                          ; preds = %for.cond
  %40 = load ptr, ptr %info, align 8
  call void @sdsfree(ptr noundef %40)
  %41 = load ptr, ptr %lines, align 8
  %42 = load i32, ptr %totlines, align 4
  call void @sdsfreesplitres(ptr noundef %41, i32 noundef %42)
  %43 = load ptr, ptr %section_dict, align 8
  call void @releaseInfoSectionDict(ptr noundef %43)
  %arrayidx31 = getelementptr inbounds [1 x ptr], ptr %argv, i64 0, i64 0
  %44 = load ptr, ptr %arrayidx31, align 8
  %tobool32 = icmp ne ptr %44, null
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %for.end
  %arrayidx34 = getelementptr inbounds [1 x ptr], ptr %argv, i64 0, i64 0
  %45 = load ptr, ptr %arrayidx34, align 8
  call void @decrRefCount(ptr noundef %45)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %for.end
  %46 = load ptr, ptr %d, align 8
  ret ptr %46
}

declare ptr @genInfoSectionDict(ptr noundef, i32 noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @genRedisInfoString(ptr noundef, i32 noundef, i32 noundef) #1

declare void @releaseInfoSectionDict(ptr noundef) #1

declare void @raxFreeWithCallback(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ServerInfoGetField(ptr noundef %ctx, ptr noundef %data, ptr noundef %field) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %result = alloca ptr, align 8
  %val = alloca ptr, align 8
  %o = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleServerInfoData, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %field.addr, align 8
  %3 = load ptr, ptr %field.addr, align 8
  %call = call i64 @strlen(ptr noundef %3) #14
  %call1 = call i32 @raxFind(ptr noundef %1, ptr noundef %2, i64 noundef %call, ptr noundef %result)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %result, align 8
  store ptr %4, ptr %val, align 8
  %5 = load ptr, ptr %val, align 8
  %6 = load ptr, ptr %val, align 8
  %call2 = call i64 @sdslen(ptr noundef %6)
  %call3 = call ptr @createStringObject(ptr noundef %5, i64 noundef %call2)
  store ptr %call3, ptr %o, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %7, null
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %8 = load ptr, ptr %ctx.addr, align 8
  %9 = load ptr, ptr %o, align 8
  call void @autoMemoryAdd(ptr noundef %8, i32 noundef 1, ptr noundef %9)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %10 = load ptr, ptr %o, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ServerInfoGetFieldC(ptr noundef %data, ptr noundef %field) #0 {
entry:
  %data.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %result = alloca ptr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store ptr null, ptr %result, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleServerInfoData, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %field.addr, align 8
  %3 = load ptr, ptr %field.addr, align 8
  %call = call i64 @strlen(ptr noundef %3) #14
  %call1 = call i32 @raxFind(ptr noundef %1, ptr noundef %2, i64 noundef %call, ptr noundef %result)
  %4 = load ptr, ptr %result, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_ServerInfoGetFieldSigned(ptr noundef %data, ptr noundef %field, ptr noundef %out_err) #0 {
entry:
  %retval = alloca i64, align 8
  %data.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %out_err.addr = alloca ptr, align 8
  %ll = alloca i64, align 8
  %result = alloca ptr, align 8
  %val = alloca ptr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store ptr %out_err, ptr %out_err.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleServerInfoData, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %field.addr, align 8
  %3 = load ptr, ptr %field.addr, align 8
  %call = call i64 @strlen(ptr noundef %3) #14
  %call1 = call i32 @raxFind(ptr noundef %1, ptr noundef %2, i64 noundef %call, ptr noundef %result)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %out_err.addr, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %5 = load ptr, ptr %out_err.addr, align 8
  store i32 1, ptr %5, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  store i64 0, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %entry
  %6 = load ptr, ptr %result, align 8
  store ptr %6, ptr %val, align 8
  %7 = load ptr, ptr %val, align 8
  %8 = load ptr, ptr %val, align 8
  %call5 = call i64 @sdslen(ptr noundef %8)
  %call6 = call i32 @string2ll(ptr noundef %7, i64 noundef %call5, ptr noundef %ll)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end12, label %if.then8

if.then8:                                         ; preds = %if.end4
  %9 = load ptr, ptr %out_err.addr, align 8
  %tobool9 = icmp ne ptr %9, null
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then8
  %10 = load ptr, ptr %out_err.addr, align 8
  store i32 1, ptr %10, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.then8
  store i64 0, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end4
  %11 = load ptr, ptr %out_err.addr, align 8
  %tobool13 = icmp ne ptr %11, null
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  %12 = load ptr, ptr %out_err.addr, align 8
  store i32 0, ptr %12, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end12
  %13 = load i64, ptr %ll, align 8
  store i64 %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.end11, %if.end
  %14 = load i64, ptr %retval, align 8
  ret i64 %14
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_ServerInfoGetFieldUnsigned(ptr noundef %data, ptr noundef %field, ptr noundef %out_err) #0 {
entry:
  %retval = alloca i64, align 8
  %data.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %out_err.addr = alloca ptr, align 8
  %ll = alloca i64, align 8
  %result = alloca ptr, align 8
  %val = alloca ptr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store ptr %out_err, ptr %out_err.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleServerInfoData, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %field.addr, align 8
  %3 = load ptr, ptr %field.addr, align 8
  %call = call i64 @strlen(ptr noundef %3) #14
  %call1 = call i32 @raxFind(ptr noundef %1, ptr noundef %2, i64 noundef %call, ptr noundef %result)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %out_err.addr, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %5 = load ptr, ptr %out_err.addr, align 8
  store i32 1, ptr %5, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  store i64 0, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %entry
  %6 = load ptr, ptr %result, align 8
  store ptr %6, ptr %val, align 8
  %7 = load ptr, ptr %val, align 8
  %call5 = call i32 @string2ull(ptr noundef %7, ptr noundef %ll)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end11, label %if.then7

if.then7:                                         ; preds = %if.end4
  %8 = load ptr, ptr %out_err.addr, align 8
  %tobool8 = icmp ne ptr %8, null
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then7
  %9 = load ptr, ptr %out_err.addr, align 8
  store i32 1, ptr %9, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.then7
  store i64 0, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end4
  %10 = load ptr, ptr %out_err.addr, align 8
  %tobool12 = icmp ne ptr %10, null
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %11 = load ptr, ptr %out_err.addr, align 8
  store i32 0, ptr %11, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end11
  %12 = load i64, ptr %ll, align 8
  store i64 %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.end10, %if.end
  %13 = load i64, ptr %retval, align 8
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define dso_local double @RM_ServerInfoGetFieldDouble(ptr noundef %data, ptr noundef %field, ptr noundef %out_err) #0 {
entry:
  %retval = alloca double, align 8
  %data.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %out_err.addr = alloca ptr, align 8
  %dbl = alloca double, align 8
  %result = alloca ptr, align 8
  %val = alloca ptr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  store ptr %out_err, ptr %out_err.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleServerInfoData, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %2 = load ptr, ptr %field.addr, align 8
  %3 = load ptr, ptr %field.addr, align 8
  %call = call i64 @strlen(ptr noundef %3) #14
  %call1 = call i32 @raxFind(ptr noundef %1, ptr noundef %2, i64 noundef %call, ptr noundef %result)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end4, label %if.then

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %out_err.addr, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %5 = load ptr, ptr %out_err.addr, align 8
  store i32 1, ptr %5, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  store double 0.000000e+00, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %entry
  %6 = load ptr, ptr %result, align 8
  store ptr %6, ptr %val, align 8
  %7 = load ptr, ptr %val, align 8
  %8 = load ptr, ptr %val, align 8
  %call5 = call i64 @sdslen(ptr noundef %8)
  %call6 = call i32 @string2d(ptr noundef %7, i64 noundef %call5, ptr noundef %dbl)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end12, label %if.then8

if.then8:                                         ; preds = %if.end4
  %9 = load ptr, ptr %out_err.addr, align 8
  %tobool9 = icmp ne ptr %9, null
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then8
  %10 = load ptr, ptr %out_err.addr, align 8
  store i32 1, ptr %10, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.then8
  store double 0.000000e+00, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end4
  %11 = load ptr, ptr %out_err.addr, align 8
  %tobool13 = icmp ne ptr %11, null
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  %12 = load ptr, ptr %out_err.addr, align 8
  store i32 0, ptr %12, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end12
  %13 = load double, ptr %dbl, align 8
  store double %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.end11, %if.end
  %14 = load double, ptr %retval, align 8
  ret double %14
}

declare i32 @string2d(ptr noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_GetRandomBytes(ptr noundef %dst, i64 noundef %len) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  call void @getRandomBytes(ptr noundef %0, i64 noundef %1)
  ret void
}

declare void @getRandomBytes(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @RM_GetRandomHexChars(ptr noundef %dst, i64 noundef %len) #0 {
entry:
  %dst.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  call void @getRandomHexChars(ptr noundef %0, i64 noundef %1)
  ret void
}

declare void @getRandomHexChars(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ExportSharedAPI(ptr noundef %ctx, ptr noundef %apiname, ptr noundef %func) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %apiname.addr = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  %sapi = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %apiname, ptr %apiname.addr, align 8
  store ptr %func, ptr %func.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 16) #11
  store ptr %call, ptr %sapi, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %2 = load ptr, ptr %sapi, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %2, i32 0, i32 1
  store ptr %1, ptr %module1, align 8
  %3 = load ptr, ptr %func.addr, align 8
  %4 = load ptr, ptr %sapi, align 8
  %func2 = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %4, i32 0, i32 0
  store ptr %3, ptr %func2, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 38), align 8
  %6 = load ptr, ptr %apiname.addr, align 8
  %7 = load ptr, ptr %sapi, align 8
  %call3 = call i32 @dictAdd(ptr noundef %5, ptr noundef %6, ptr noundef %7)
  %cmp = icmp ne i32 %call3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %sapi, align 8
  call void @zfree(ptr noundef %8)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetSharedAPI(ptr noundef %ctx, ptr noundef %apiname) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %apiname.addr = alloca ptr, align 8
  %de = alloca ptr, align 8
  %sapi = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %apiname, ptr %apiname.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 38), align 8
  %1 = load ptr, ptr %apiname.addr, align 8
  %call = call ptr @dictFind(ptr noundef %0, ptr noundef %1)
  store ptr %call, ptr %de, align 8
  %2 = load ptr, ptr %de, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %de, align 8
  %call1 = call ptr @dictGetVal(ptr noundef %3)
  store ptr %call1, ptr %sapi, align 8
  %4 = load ptr, ptr %sapi, align 8
  %module = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %module, align 8
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %5, i32 0, i32 5
  %6 = load ptr, ptr %usedby, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %module2 = getelementptr inbounds %struct.RedisModuleCtx, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %module2, align 8
  %call3 = call ptr @listSearchKey(ptr noundef %6, ptr noundef %8)
  %cmp4 = icmp eq ptr %call3, null
  br i1 %cmp4, label %if.then5, label %if.end13

if.then5:                                         ; preds = %if.end
  %9 = load ptr, ptr %sapi, align 8
  %module6 = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %module6, align 8
  %usedby7 = getelementptr inbounds %struct.RedisModule, ptr %10, i32 0, i32 5
  %11 = load ptr, ptr %usedby7, align 8
  %12 = load ptr, ptr %ctx.addr, align 8
  %module8 = getelementptr inbounds %struct.RedisModuleCtx, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %module8, align 8
  %call9 = call ptr @listAddNodeTail(ptr noundef %11, ptr noundef %13)
  %14 = load ptr, ptr %ctx.addr, align 8
  %module10 = getelementptr inbounds %struct.RedisModuleCtx, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %module10, align 8
  %using = getelementptr inbounds %struct.RedisModule, ptr %15, i32 0, i32 6
  %16 = load ptr, ptr %using, align 8
  %17 = load ptr, ptr %sapi, align 8
  %module11 = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %module11, align 8
  %call12 = call ptr @listAddNodeTail(ptr noundef %16, ptr noundef %18)
  br label %if.end13

if.end13:                                         ; preds = %if.then5, %if.end
  %19 = load ptr, ptr %sapi, align 8
  %func = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %func, align 8
  store ptr %20, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end13, %if.then
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

declare ptr @listSearchKey(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleUnregisterSharedAPI(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %apiname = alloca ptr, align 8
  %sapi = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 0, ptr %count, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 38), align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetKey(ptr noundef %2)
  store ptr %call2, ptr %apiname, align 8
  %3 = load ptr, ptr %de, align 8
  %call3 = call ptr @dictGetVal(ptr noundef %3)
  store ptr %call3, ptr %sapi, align 8
  %4 = load ptr, ptr %sapi, align 8
  %module4 = getelementptr inbounds %struct.RedisModuleSharedAPI, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %module4, align 8
  %6 = load ptr, ptr %module.addr, align 8
  %cmp5 = icmp eq ptr %5, %6
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 38), align 8
  %8 = load ptr, ptr %apiname, align 8
  %call6 = call i32 @dictDelete(ptr noundef %7, ptr noundef %8)
  %9 = load ptr, ptr %sapi, align 8
  call void @zfree(ptr noundef %9)
  %10 = load i32, ptr %count, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !57

while.end:                                        ; preds = %while.cond
  %11 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %11)
  %12 = load i32, ptr %count, align 4
  ret i32 %12
}

declare ptr @dictGetSafeIterator(ptr noundef) #1

declare ptr @dictGetKey(ptr noundef) #1

declare i32 @dictDelete(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleUnregisterUsedAPI(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %count = alloca i32, align 4
  %used = alloca ptr, align 8
  %ln1 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 0, ptr %count, align 4
  %0 = load ptr, ptr %module.addr, align 8
  %using = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %using, align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %used, align 8
  %4 = load ptr, ptr %used, align 8
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %usedby, align 8
  %6 = load ptr, ptr %module.addr, align 8
  %call2 = call ptr @listSearchKey(ptr noundef %5, ptr noundef %6)
  store ptr %call2, ptr %ln1, align 8
  %7 = load ptr, ptr %ln1, align 8
  %tobool3 = icmp ne ptr %7, null
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %8 = load ptr, ptr %used, align 8
  %usedby4 = getelementptr inbounds %struct.RedisModule, ptr %8, i32 0, i32 5
  %9 = load ptr, ptr %usedby4, align 8
  %10 = load ptr, ptr %ln1, align 8
  call void @listDelNode(ptr noundef %9, ptr noundef %10)
  %11 = load i32, ptr %count, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !58

while.end:                                        ; preds = %while.cond
  %12 = load i32, ptr %count, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleUnregisterFilters(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %count = alloca i32, align 4
  %filter = alloca ptr, align 8
  %ln1 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store i32 0, ptr %count, align 4
  %0 = load ptr, ptr %module.addr, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 7
  %1 = load ptr, ptr %filters, align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %filter, align 8
  %4 = load ptr, ptr @moduleCommandFilters, align 8
  %5 = load ptr, ptr %filter, align 8
  %call2 = call ptr @listSearchKey(ptr noundef %4, ptr noundef %5)
  store ptr %call2, ptr %ln1, align 8
  %6 = load ptr, ptr %ln1, align 8
  %tobool3 = icmp ne ptr %6, null
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %7 = load ptr, ptr @moduleCommandFilters, align 8
  %8 = load ptr, ptr %ln1, align 8
  call void @listDelNode(ptr noundef %7, ptr noundef %8)
  %9 = load i32, ptr %count, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %10 = load ptr, ptr %filter, align 8
  call void @zfree(ptr noundef %10)
  br label %while.cond, !llvm.loop !59

while.end:                                        ; preds = %while.cond
  %11 = load i32, ptr %count, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_RegisterCommandFilter(ptr noundef %ctx, ptr noundef %callback, i32 noundef %flags) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %filter = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %call = call noalias ptr @zmalloc(i64 noundef 24) #11
  store ptr %call, ptr %filter, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module, align 8
  %2 = load ptr, ptr %filter, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %2, i32 0, i32 0
  store ptr %1, ptr %module1, align 8
  %3 = load ptr, ptr %callback.addr, align 8
  %4 = load ptr, ptr %filter, align 8
  %callback2 = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %4, i32 0, i32 1
  store ptr %3, ptr %callback2, align 8
  %5 = load i32, ptr %flags.addr, align 4
  %6 = load ptr, ptr %filter, align 8
  %flags3 = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %6, i32 0, i32 2
  store i32 %5, ptr %flags3, align 8
  %7 = load ptr, ptr @moduleCommandFilters, align 8
  %8 = load ptr, ptr %filter, align 8
  %call4 = call ptr @listAddNodeTail(ptr noundef %7, ptr noundef %8)
  %9 = load ptr, ptr %ctx.addr, align 8
  %module5 = getelementptr inbounds %struct.RedisModuleCtx, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %module5, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %10, i32 0, i32 7
  %11 = load ptr, ptr %filters, align 8
  %12 = load ptr, ptr %filter, align 8
  %call6 = call ptr @listAddNodeTail(ptr noundef %11, ptr noundef %12)
  %13 = load ptr, ptr %filter, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_UnregisterCommandFilter(ptr noundef %ctx, ptr noundef %filter) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %filter.addr = alloca ptr, align 8
  %ln = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %filter, ptr %filter.addr, align 8
  %0 = load ptr, ptr %filter.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCommandFilter, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %module, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %module1, align 8
  %cmp = icmp ne ptr %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr @moduleCommandFilters, align 8
  %5 = load ptr, ptr %filter.addr, align 8
  %call = call ptr @listSearchKey(ptr noundef %4, ptr noundef %5)
  store ptr %call, ptr %ln, align 8
  %6 = load ptr, ptr %ln, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %7 = load ptr, ptr @moduleCommandFilters, align 8
  %8 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %7, ptr noundef %8)
  %9 = load ptr, ptr %ctx.addr, align 8
  %module4 = getelementptr inbounds %struct.RedisModuleCtx, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %module4, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %10, i32 0, i32 7
  %11 = load ptr, ptr %filters, align 8
  %12 = load ptr, ptr %filter.addr, align 8
  %call5 = call ptr @listSearchKey(ptr noundef %11, ptr noundef %12)
  store ptr %call5, ptr %ln, align 8
  %13 = load ptr, ptr %ln, align 8
  %tobool6 = icmp ne ptr %13, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end3
  store i32 1, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end3
  %14 = load ptr, ptr %ctx.addr, align 8
  %module9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %module9, align 8
  %filters10 = getelementptr inbounds %struct.RedisModule, ptr %15, i32 0, i32 7
  %16 = load ptr, ptr %filters10, align 8
  %17 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %16, ptr noundef %17)
  %18 = load ptr, ptr %filter.addr, align 8
  call void @zfree(ptr noundef %18)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then7, %if.then2, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CommandFilterArgsCount(ptr noundef %fctx) #0 {
entry:
  %fctx.addr = alloca ptr, align 8
  store ptr %fctx, ptr %fctx.addr, align 8
  %0 = load ptr, ptr %fctx.addr, align 8
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %argc, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_CommandFilterArgGet(ptr noundef %fctx, i32 noundef %pos) #0 {
entry:
  %retval = alloca ptr, align 8
  %fctx.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  store ptr %fctx, ptr %fctx.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  %0 = load i32, ptr %pos.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %pos.addr, align 4
  %2 = load ptr, ptr %fctx.addr, align 8
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %argc, align 4
  %cmp1 = icmp sge i32 %1, %3
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %fctx.addr, align 8
  %argv = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %argv, align 8
  %6 = load i32, ptr %pos.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CommandFilterArgInsert(ptr noundef %fctx, i32 noundef %pos, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %fctx.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %fctx, ptr %fctx.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load i32, ptr %pos.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %pos.addr, align 4
  %2 = load ptr, ptr %fctx.addr, align 8
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %argc, align 4
  %cmp1 = icmp sgt i32 %1, %3
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %fctx.addr, align 8
  %argv_len = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %4, i32 0, i32 1
  %5 = load i32, ptr %argv_len, align 8
  %6 = load ptr, ptr %fctx.addr, align 8
  %argc2 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %6, i32 0, i32 2
  %7 = load i32, ptr %argc2, align 4
  %add = add nsw i32 %7, 1
  %cmp3 = icmp slt i32 %5, %add
  br i1 %cmp3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.end
  %8 = load ptr, ptr %fctx.addr, align 8
  %argc5 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %8, i32 0, i32 2
  %9 = load i32, ptr %argc5, align 4
  %add6 = add nsw i32 %9, 1
  %10 = load ptr, ptr %fctx.addr, align 8
  %argv_len7 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %10, i32 0, i32 1
  store i32 %add6, ptr %argv_len7, align 8
  %11 = load ptr, ptr %fctx.addr, align 8
  %argv = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %argv, align 8
  %13 = load ptr, ptr %fctx.addr, align 8
  %argv_len8 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %argv_len8, align 8
  %conv = sext i32 %14 to i64
  %mul = mul i64 %conv, 8
  %call = call ptr @zrealloc(ptr noundef %12, i64 noundef %mul) #12
  %15 = load ptr, ptr %fctx.addr, align 8
  %argv9 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %15, i32 0, i32 0
  store ptr %call, ptr %argv9, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then4, %if.end
  %16 = load ptr, ptr %fctx.addr, align 8
  %argc11 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %16, i32 0, i32 2
  %17 = load i32, ptr %argc11, align 4
  store i32 %17, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %18 = load i32, ptr %i, align 4
  %19 = load i32, ptr %pos.addr, align 4
  %cmp12 = icmp sgt i32 %18, %19
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load ptr, ptr %fctx.addr, align 8
  %argv14 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %argv14, align 8
  %22 = load i32, ptr %i, align 4
  %sub = sub nsw i32 %22, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds ptr, ptr %21, i64 %idxprom
  %23 = load ptr, ptr %arrayidx, align 8
  %24 = load ptr, ptr %fctx.addr, align 8
  %argv15 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %24, i32 0, i32 0
  %25 = load ptr, ptr %argv15, align 8
  %26 = load i32, ptr %i, align 4
  %idxprom16 = sext i32 %26 to i64
  %arrayidx17 = getelementptr inbounds ptr, ptr %25, i64 %idxprom16
  store ptr %23, ptr %arrayidx17, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %27 = load i32, ptr %i, align 4
  %dec = add nsw i32 %27, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond, !llvm.loop !60

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %arg.addr, align 8
  %29 = load ptr, ptr %fctx.addr, align 8
  %argv18 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %argv18, align 8
  %31 = load i32, ptr %pos.addr, align 4
  %idxprom19 = sext i32 %31 to i64
  %arrayidx20 = getelementptr inbounds ptr, ptr %30, i64 %idxprom19
  store ptr %28, ptr %arrayidx20, align 8
  %32 = load ptr, ptr %fctx.addr, align 8
  %argc21 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %32, i32 0, i32 2
  %33 = load i32, ptr %argc21, align 4
  %inc = add nsw i32 %33, 1
  store i32 %inc, ptr %argc21, align 4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %34 = load i32, ptr %retval, align 4
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CommandFilterArgReplace(ptr noundef %fctx, i32 noundef %pos, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %fctx.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  store ptr %fctx, ptr %fctx.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load i32, ptr %pos.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %pos.addr, align 4
  %2 = load ptr, ptr %fctx.addr, align 8
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %argc, align 4
  %cmp1 = icmp sge i32 %1, %3
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %fctx.addr, align 8
  %argv = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %argv, align 8
  %6 = load i32, ptr %pos.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  call void @decrRefCount(ptr noundef %7)
  %8 = load ptr, ptr %arg.addr, align 8
  %9 = load ptr, ptr %fctx.addr, align 8
  %argv2 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %argv2, align 8
  %11 = load i32, ptr %pos.addr, align 4
  %idxprom3 = sext i32 %11 to i64
  %arrayidx4 = getelementptr inbounds ptr, ptr %10, i64 %idxprom3
  store ptr %8, ptr %arrayidx4, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_CommandFilterArgDelete(ptr noundef %fctx, i32 noundef %pos) #0 {
entry:
  %retval = alloca i32, align 4
  %fctx.addr = alloca ptr, align 8
  %pos.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %fctx, ptr %fctx.addr, align 8
  store i32 %pos, ptr %pos.addr, align 4
  %0 = load i32, ptr %pos.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %pos.addr, align 4
  %2 = load ptr, ptr %fctx.addr, align 8
  %argc = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %argc, align 4
  %cmp1 = icmp sge i32 %1, %3
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %fctx.addr, align 8
  %argv = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %argv, align 8
  %6 = load i32, ptr %pos.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %idxprom
  %7 = load ptr, ptr %arrayidx, align 8
  call void @decrRefCount(ptr noundef %7)
  %8 = load i32, ptr %pos.addr, align 4
  store i32 %8, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i32, ptr %i, align 4
  %10 = load ptr, ptr %fctx.addr, align 8
  %argc2 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %10, i32 0, i32 2
  %11 = load i32, ptr %argc2, align 4
  %sub = sub nsw i32 %11, 1
  %cmp3 = icmp slt i32 %9, %sub
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load ptr, ptr %fctx.addr, align 8
  %argv4 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %argv4, align 8
  %14 = load i32, ptr %i, align 4
  %add = add nsw i32 %14, 1
  %idxprom5 = sext i32 %add to i64
  %arrayidx6 = getelementptr inbounds ptr, ptr %13, i64 %idxprom5
  %15 = load ptr, ptr %arrayidx6, align 8
  %16 = load ptr, ptr %fctx.addr, align 8
  %argv7 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %argv7, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom8 = sext i32 %18 to i64
  %arrayidx9 = getelementptr inbounds ptr, ptr %17, i64 %idxprom8
  store ptr %15, ptr %arrayidx9, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32, ptr %i, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !61

for.end:                                          ; preds = %for.cond
  %20 = load ptr, ptr %fctx.addr, align 8
  %argc10 = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %20, i32 0, i32 2
  %21 = load i32, ptr %argc10, align 4
  %dec = add nsw i32 %21, -1
  store i32 %dec, ptr %argc10, align 4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %22 = load i32, ptr %retval, align 4
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_CommandFilterGetClientId(ptr noundef %fctx) #0 {
entry:
  %fctx.addr = alloca ptr, align 8
  store ptr %fctx, ptr %fctx.addr, align 8
  %0 = load ptr, ptr %fctx.addr, align 8
  %c = getelementptr inbounds %struct.RedisModuleCommandFilterCtx, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %c, align 8
  %id = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %id, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MallocSize(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call i64 @je_malloc_usable_size(ptr noundef %0) #16
  ret i64 %call
}

; Function Attrs: nounwind
declare i64 @je_malloc_usable_size(ptr noundef) #10

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MallocUsableSize(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call i64 @je_malloc_usable_size(ptr noundef %0) #16
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MallocSizeString(ptr noundef %str) #0 {
entry:
  %str.addr = alloca ptr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp eq i32 %bf.clear, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.94, ptr noundef @.str.2, i32 noundef 10835)
  call void @abort() #13
  unreachable

1:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %1, %cond.true
  %2 = load ptr, ptr %str.addr, align 8
  %call = call i64 @getStringObjectSdsUsedMemory(ptr noundef %2)
  %add = add i64 16, %call
  ret i64 %add
}

declare i64 @getStringObjectSdsUsedMemory(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @RM_MallocSizeDict(ptr noundef %dict) #0 {
entry:
  %dict.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  store ptr %dict, ptr %dict.addr, align 8
  store i64 32, ptr %size, align 8
  %0 = load ptr, ptr %dict.addr, align 8
  %rax = getelementptr inbounds %struct.RedisModuleDict, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %rax, align 8
  %numnodes = getelementptr inbounds %struct.rax, ptr %1, i32 0, i32 2
  %2 = load i64, ptr %numnodes, align 8
  %mul = mul i64 %2, 4
  %3 = load i64, ptr %size, align 8
  %add = add i64 %3, %mul
  store i64 %add, ptr %size, align 8
  %4 = load ptr, ptr %dict.addr, align 8
  %rax1 = getelementptr inbounds %struct.RedisModuleDict, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %rax1, align 8
  %numnodes2 = getelementptr inbounds %struct.rax, ptr %5, i32 0, i32 2
  %6 = load i64, ptr %numnodes2, align 8
  %mul3 = mul i64 %6, 8
  %mul4 = mul i64 %mul3, 30
  %7 = load i64, ptr %size, align 8
  %add5 = add i64 %7, %mul4
  store i64 %add5, ptr %size, align 8
  %8 = load i64, ptr %size, align 8
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define dso_local float @RM_GetUsedMemoryRatio() #0 {
entry:
  %level = alloca float, align 4
  %call = call i32 @getMaxmemoryState(ptr noundef null, ptr noundef null, ptr noundef null, ptr noundef %level)
  %0 = load float, ptr %level, align 4
  ret float %0
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_ScanCursorCreate() #0 {
entry:
  %cursor = alloca ptr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 16) #11
  store ptr %call, ptr %cursor, align 8
  %0 = load ptr, ptr %cursor, align 8
  %cursor1 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %0, i32 0, i32 0
  store i64 0, ptr %cursor1, align 8
  %1 = load ptr, ptr %cursor, align 8
  %done = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %1, i32 0, i32 1
  store i32 0, ptr %done, align 8
  %2 = load ptr, ptr %cursor, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ScanCursorRestart(ptr noundef %cursor) #0 {
entry:
  %cursor.addr = alloca ptr, align 8
  store ptr %cursor, ptr %cursor.addr, align 8
  %0 = load ptr, ptr %cursor.addr, align 8
  %cursor1 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %0, i32 0, i32 0
  store i64 0, ptr %cursor1, align 8
  %1 = load ptr, ptr %cursor.addr, align 8
  %done = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %1, i32 0, i32 1
  store i32 0, ptr %done, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_ScanCursorDestroy(ptr noundef %cursor) #0 {
entry:
  %cursor.addr = alloca ptr, align 8
  store ptr %cursor, ptr %cursor.addr, align 8
  %0 = load ptr, ptr %cursor.addr, align 8
  call void @zfree(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_Scan(ptr noundef %ctx, ptr noundef %cursor, ptr noundef %fn, ptr noundef %privdata) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %cursor.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %data = alloca %struct.ScanCBData, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cursor, ptr %cursor.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  %0 = load ptr, ptr %cursor.addr, align 8
  %done = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %done, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 2, ptr %call, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %ret, align 4
  %ctx1 = getelementptr inbounds %struct.ScanCBData, ptr %data, i32 0, i32 0
  %2 = load ptr, ptr %ctx.addr, align 8
  store ptr %2, ptr %ctx1, align 8
  %user_data = getelementptr inbounds %struct.ScanCBData, ptr %data, i32 0, i32 1
  %3 = load ptr, ptr %privdata.addr, align 8
  store ptr %3, ptr %user_data, align 8
  %fn2 = getelementptr inbounds %struct.ScanCBData, ptr %data, i32 0, i32 2
  %4 = load ptr, ptr %fn.addr, align 8
  store ptr %4, ptr %fn2, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %client, align 8
  %db = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %db, align 8
  %8 = load ptr, ptr %cursor.addr, align 8
  %cursor3 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %8, i32 0, i32 0
  %9 = load i64, ptr %cursor3, align 8
  %call4 = call i64 @dbScan(ptr noundef %7, i32 noundef 0, i64 noundef %9, i32 noundef -1, ptr noundef @moduleScanCallback, ptr noundef null, ptr noundef %data)
  %10 = load ptr, ptr %cursor.addr, align 8
  %cursor5 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %10, i32 0, i32 0
  store i64 %call4, ptr %cursor5, align 8
  %11 = load ptr, ptr %cursor.addr, align 8
  %cursor6 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %11, i32 0, i32 0
  %12 = load i64, ptr %cursor6, align 8
  %cmp = icmp eq i64 %12, 0
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %13 = load ptr, ptr %cursor.addr, align 8
  %done8 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %13, i32 0, i32 1
  store i32 1, ptr %done8, align 8
  store i32 0, ptr %ret, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  %call10 = call ptr @__errno_location() #15
  store i32 0, ptr %call10, align 4
  %14 = load i32, ptr %ret, align 4
  store i32 %14, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

declare i64 @dbScan(ptr noundef, i32 noundef, i64 noundef, i32 noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @moduleScanCallback(ptr noundef %privdata, ptr noundef %de) #0 {
entry:
  %privdata.addr = alloca ptr, align 8
  %de.addr = alloca ptr, align 8
  %data = alloca ptr, align 8
  %key = alloca ptr, align 8
  %val = alloca ptr, align 8
  %keyname = alloca ptr, align 8
  %kp = alloca %struct.RedisModuleKey, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  store ptr %de, ptr %de.addr, align 8
  %0 = load ptr, ptr %privdata.addr, align 8
  store ptr %0, ptr %data, align 8
  %1 = load ptr, ptr %de.addr, align 8
  %call = call ptr @dictGetKey(ptr noundef %1)
  store ptr %call, ptr %key, align 8
  %2 = load ptr, ptr %de.addr, align 8
  %call1 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call1, ptr %val, align 8
  %3 = load ptr, ptr %key, align 8
  %call2 = call ptr @sdsdup(ptr noundef %3)
  %call3 = call ptr @createObject(i32 noundef 0, ptr noundef %call2)
  store ptr %call3, ptr %keyname, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %kp, i8 0, i64 128, i1 false)
  %4 = load ptr, ptr %data, align 8
  %ctx = getelementptr inbounds %struct.ScanCBData, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %ctx, align 8
  %6 = load ptr, ptr %keyname, align 8
  %7 = load ptr, ptr %val, align 8
  call void @moduleInitKey(ptr noundef %kp, ptr noundef %5, ptr noundef %6, ptr noundef %7, i32 noundef 1)
  %8 = load ptr, ptr %data, align 8
  %fn = getelementptr inbounds %struct.ScanCBData, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %fn, align 8
  %10 = load ptr, ptr %data, align 8
  %ctx4 = getelementptr inbounds %struct.ScanCBData, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %ctx4, align 8
  %12 = load ptr, ptr %keyname, align 8
  %13 = load ptr, ptr %data, align 8
  %user_data = getelementptr inbounds %struct.ScanCBData, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %user_data, align 8
  call void %9(ptr noundef %11, ptr noundef %12, ptr noundef %kp, ptr noundef %14)
  call void @moduleCloseKey(ptr noundef %kp)
  %15 = load ptr, ptr %keyname, align 8
  call void @decrRefCount(ptr noundef %15)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ScanKey(ptr noundef %key, ptr noundef %cursor, ptr noundef %fn, ptr noundef %privdata) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %cursor.addr = alloca ptr, align 8
  %fn.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %ht = alloca ptr, align 8
  %o = alloca ptr, align 8
  %ret = alloca i32, align 4
  %data = alloca %struct.ScanKeyCBData, align 8
  %si = alloca ptr, align 8
  %sdsele = alloca ptr, align 8
  %field = alloca ptr, align 8
  %p = alloca ptr, align 8
  %vstr = alloca ptr, align 8
  %vlen = alloca i32, align 4
  %vll = alloca i64, align 8
  %field79 = alloca ptr, align 8
  %value86 = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %cursor, ptr %cursor.addr, align 8
  store ptr %fn, ptr %fn.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store ptr null, ptr %ht, align 8
  %3 = load ptr, ptr %key.addr, align 8
  %value2 = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value2, align 8
  store ptr %4, ptr %o, align 8
  %5 = load ptr, ptr %o, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp3 = icmp eq i32 %bf.clear, 2
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %6 = load ptr, ptr %o, align 8
  %bf.load5 = load i32, ptr %6, align 8
  %bf.lshr = lshr i32 %bf.load5, 4
  %bf.clear6 = and i32 %bf.lshr, 15
  %cmp7 = icmp eq i32 %bf.clear6, 2
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then4
  %7 = load ptr, ptr %o, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %ptr, align 8
  store ptr %8, ptr %ht, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.then4
  br label %if.end37

if.else:                                          ; preds = %if.end
  %9 = load ptr, ptr %o, align 8
  %bf.load10 = load i32, ptr %9, align 8
  %bf.clear11 = and i32 %bf.load10, 15
  %cmp12 = icmp eq i32 %bf.clear11, 4
  br i1 %cmp12, label %if.then13, label %if.else21

if.then13:                                        ; preds = %if.else
  %10 = load ptr, ptr %o, align 8
  %bf.load14 = load i32, ptr %10, align 8
  %bf.lshr15 = lshr i32 %bf.load14, 4
  %bf.clear16 = and i32 %bf.lshr15, 15
  %cmp17 = icmp eq i32 %bf.clear16, 2
  br i1 %cmp17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.then13
  %11 = load ptr, ptr %o, align 8
  %ptr19 = getelementptr inbounds %struct.redisObject, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %ptr19, align 8
  store ptr %12, ptr %ht, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.then13
  br label %if.end36

if.else21:                                        ; preds = %if.else
  %13 = load ptr, ptr %o, align 8
  %bf.load22 = load i32, ptr %13, align 8
  %bf.clear23 = and i32 %bf.load22, 15
  %cmp24 = icmp eq i32 %bf.clear23, 3
  br i1 %cmp24, label %if.then25, label %if.else33

if.then25:                                        ; preds = %if.else21
  %14 = load ptr, ptr %o, align 8
  %bf.load26 = load i32, ptr %14, align 8
  %bf.lshr27 = lshr i32 %bf.load26, 4
  %bf.clear28 = and i32 %bf.lshr27, 15
  %cmp29 = icmp eq i32 %bf.clear28, 7
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.then25
  %15 = load ptr, ptr %o, align 8
  %ptr31 = getelementptr inbounds %struct.redisObject, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %ptr31, align 8
  %dict = getelementptr inbounds %struct.zset, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %dict, align 8
  store ptr %17, ptr %ht, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.then25
  br label %if.end35

if.else33:                                        ; preds = %if.else21
  %call34 = call ptr @__errno_location() #15
  store i32 22, ptr %call34, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.end32
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end20
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end9
  %18 = load ptr, ptr %cursor.addr, align 8
  %done = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %done, align 8
  %tobool = icmp ne i32 %19, 0
  br i1 %tobool, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.end37
  %call39 = call ptr @__errno_location() #15
  store i32 2, ptr %call39, align 4
  store i32 0, ptr %retval, align 4
  br label %return

if.end40:                                         ; preds = %if.end37
  store i32 1, ptr %ret, align 4
  %20 = load ptr, ptr %ht, align 8
  %tobool41 = icmp ne ptr %20, null
  br i1 %tobool41, label %if.then42, label %if.else53

if.then42:                                        ; preds = %if.end40
  %key43 = getelementptr inbounds %struct.ScanKeyCBData, ptr %data, i32 0, i32 0
  %21 = load ptr, ptr %key.addr, align 8
  store ptr %21, ptr %key43, align 8
  %user_data = getelementptr inbounds %struct.ScanKeyCBData, ptr %data, i32 0, i32 1
  %22 = load ptr, ptr %privdata.addr, align 8
  store ptr %22, ptr %user_data, align 8
  %fn44 = getelementptr inbounds %struct.ScanKeyCBData, ptr %data, i32 0, i32 2
  %23 = load ptr, ptr %fn.addr, align 8
  store ptr %23, ptr %fn44, align 8
  %24 = load ptr, ptr %ht, align 8
  %25 = load ptr, ptr %cursor.addr, align 8
  %cursor45 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %25, i32 0, i32 0
  %26 = load i64, ptr %cursor45, align 8
  %call46 = call i64 @dictScan(ptr noundef %24, i64 noundef %26, ptr noundef @moduleScanKeyCallback, ptr noundef %data)
  %27 = load ptr, ptr %cursor.addr, align 8
  %cursor47 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %27, i32 0, i32 0
  store i64 %call46, ptr %cursor47, align 8
  %28 = load ptr, ptr %cursor.addr, align 8
  %cursor48 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %28, i32 0, i32 0
  %29 = load i64, ptr %cursor48, align 8
  %cmp49 = icmp eq i64 %29, 0
  br i1 %cmp49, label %if.then50, label %if.end52

if.then50:                                        ; preds = %if.then42
  %30 = load ptr, ptr %cursor.addr, align 8
  %done51 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %30, i32 0, i32 1
  store i32 1, ptr %done51, align 8
  store i32 0, ptr %ret, align 4
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %if.then42
  br label %if.end103

if.else53:                                        ; preds = %if.end40
  %31 = load ptr, ptr %o, align 8
  %bf.load54 = load i32, ptr %31, align 8
  %bf.clear55 = and i32 %bf.load54, 15
  %cmp56 = icmp eq i32 %bf.clear55, 2
  br i1 %cmp56, label %if.then57, label %if.else64

if.then57:                                        ; preds = %if.else53
  %32 = load ptr, ptr %o, align 8
  %call58 = call ptr @setTypeInitIterator(ptr noundef %32)
  store ptr %call58, ptr %si, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then57
  %33 = load ptr, ptr %si, align 8
  %call59 = call ptr @setTypeNextObject(ptr noundef %33)
  store ptr %call59, ptr %sdsele, align 8
  %cmp60 = icmp ne ptr %call59, null
  br i1 %cmp60, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %34 = load ptr, ptr %sdsele, align 8
  %call61 = call ptr @createObject(i32 noundef 0, ptr noundef %34)
  store ptr %call61, ptr %field, align 8
  %35 = load ptr, ptr %fn.addr, align 8
  %36 = load ptr, ptr %key.addr, align 8
  %37 = load ptr, ptr %field, align 8
  %38 = load ptr, ptr %privdata.addr, align 8
  call void %35(ptr noundef %36, ptr noundef %37, ptr noundef null, ptr noundef %38)
  %39 = load ptr, ptr %field, align 8
  call void @decrRefCount(ptr noundef %39)
  br label %while.cond, !llvm.loop !62

while.end:                                        ; preds = %while.cond
  %40 = load ptr, ptr %si, align 8
  call void @setTypeReleaseIterator(ptr noundef %40)
  %41 = load ptr, ptr %cursor.addr, align 8
  %cursor62 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %41, i32 0, i32 0
  store i64 1, ptr %cursor62, align 8
  %42 = load ptr, ptr %cursor.addr, align 8
  %done63 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %42, i32 0, i32 1
  store i32 1, ptr %done63, align 8
  store i32 0, ptr %ret, align 4
  br label %if.end102

if.else64:                                        ; preds = %if.else53
  %43 = load ptr, ptr %o, align 8
  %bf.load65 = load i32, ptr %43, align 8
  %bf.clear66 = and i32 %bf.load65, 15
  %cmp67 = icmp eq i32 %bf.clear66, 3
  br i1 %cmp67, label %if.then72, label %lor.lhs.false68

lor.lhs.false68:                                  ; preds = %if.else64
  %44 = load ptr, ptr %o, align 8
  %bf.load69 = load i32, ptr %44, align 8
  %bf.clear70 = and i32 %bf.load69, 15
  %cmp71 = icmp eq i32 %bf.clear70, 4
  br i1 %cmp71, label %if.then72, label %if.end101

if.then72:                                        ; preds = %lor.lhs.false68, %if.else64
  %45 = load ptr, ptr %o, align 8
  %ptr73 = getelementptr inbounds %struct.redisObject, ptr %45, i32 0, i32 2
  %46 = load ptr, ptr %ptr73, align 8
  %call74 = call ptr @lpSeek(ptr noundef %46, i64 noundef 0)
  store ptr %call74, ptr %p, align 8
  br label %while.cond75

while.cond75:                                     ; preds = %cond.end94, %if.then72
  %47 = load ptr, ptr %p, align 8
  %tobool76 = icmp ne ptr %47, null
  br i1 %tobool76, label %while.body77, label %while.end98

while.body77:                                     ; preds = %while.cond75
  %48 = load ptr, ptr %p, align 8
  %call78 = call ptr @lpGetValue(ptr noundef %48, ptr noundef %vlen, ptr noundef %vll)
  store ptr %call78, ptr %vstr, align 8
  %49 = load ptr, ptr %vstr, align 8
  %cmp80 = icmp ne ptr %49, null
  br i1 %cmp80, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body77
  %50 = load ptr, ptr %vstr, align 8
  %51 = load i32, ptr %vlen, align 4
  %conv = zext i32 %51 to i64
  %call81 = call ptr @createStringObject(ptr noundef %50, i64 noundef %conv)
  br label %cond.end

cond.false:                                       ; preds = %while.body77
  %52 = load i64, ptr %vll, align 8
  %call82 = call ptr @createStringObjectFromLongLongWithSds(i64 noundef %52)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call81, %cond.true ], [ %call82, %cond.false ]
  store ptr %cond, ptr %field79, align 8
  %53 = load ptr, ptr %o, align 8
  %ptr83 = getelementptr inbounds %struct.redisObject, ptr %53, i32 0, i32 2
  %54 = load ptr, ptr %ptr83, align 8
  %55 = load ptr, ptr %p, align 8
  %call84 = call ptr @lpNext(ptr noundef %54, ptr noundef %55)
  store ptr %call84, ptr %p, align 8
  %56 = load ptr, ptr %p, align 8
  %call85 = call ptr @lpGetValue(ptr noundef %56, ptr noundef %vlen, ptr noundef %vll)
  store ptr %call85, ptr %vstr, align 8
  %57 = load ptr, ptr %vstr, align 8
  %cmp87 = icmp ne ptr %57, null
  br i1 %cmp87, label %cond.true89, label %cond.false92

cond.true89:                                      ; preds = %cond.end
  %58 = load ptr, ptr %vstr, align 8
  %59 = load i32, ptr %vlen, align 4
  %conv90 = zext i32 %59 to i64
  %call91 = call ptr @createStringObject(ptr noundef %58, i64 noundef %conv90)
  br label %cond.end94

cond.false92:                                     ; preds = %cond.end
  %60 = load i64, ptr %vll, align 8
  %call93 = call ptr @createStringObjectFromLongLongWithSds(i64 noundef %60)
  br label %cond.end94

cond.end94:                                       ; preds = %cond.false92, %cond.true89
  %cond95 = phi ptr [ %call91, %cond.true89 ], [ %call93, %cond.false92 ]
  store ptr %cond95, ptr %value86, align 8
  %61 = load ptr, ptr %fn.addr, align 8
  %62 = load ptr, ptr %key.addr, align 8
  %63 = load ptr, ptr %field79, align 8
  %64 = load ptr, ptr %value86, align 8
  %65 = load ptr, ptr %privdata.addr, align 8
  call void %61(ptr noundef %62, ptr noundef %63, ptr noundef %64, ptr noundef %65)
  %66 = load ptr, ptr %o, align 8
  %ptr96 = getelementptr inbounds %struct.redisObject, ptr %66, i32 0, i32 2
  %67 = load ptr, ptr %ptr96, align 8
  %68 = load ptr, ptr %p, align 8
  %call97 = call ptr @lpNext(ptr noundef %67, ptr noundef %68)
  store ptr %call97, ptr %p, align 8
  %69 = load ptr, ptr %field79, align 8
  call void @decrRefCount(ptr noundef %69)
  %70 = load ptr, ptr %value86, align 8
  call void @decrRefCount(ptr noundef %70)
  br label %while.cond75, !llvm.loop !63

while.end98:                                      ; preds = %while.cond75
  %71 = load ptr, ptr %cursor.addr, align 8
  %cursor99 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %71, i32 0, i32 0
  store i64 1, ptr %cursor99, align 8
  %72 = load ptr, ptr %cursor.addr, align 8
  %done100 = getelementptr inbounds %struct.RedisModuleScanCursor, ptr %72, i32 0, i32 1
  store i32 1, ptr %done100, align 8
  store i32 0, ptr %ret, align 4
  br label %if.end101

if.end101:                                        ; preds = %while.end98, %lor.lhs.false68
  br label %if.end102

if.end102:                                        ; preds = %if.end101, %while.end
  br label %if.end103

if.end103:                                        ; preds = %if.end102, %if.end52
  %call104 = call ptr @__errno_location() #15
  store i32 0, ptr %call104, align 4
  %73 = load i32, ptr %ret, align 4
  store i32 %73, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end103, %if.then38, %if.else33, %if.then
  %74 = load i32, ptr %retval, align 4
  ret i32 %74
}

declare i64 @dictScan(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @moduleScanKeyCallback(ptr noundef %privdata, ptr noundef %de) #0 {
entry:
  %privdata.addr = alloca ptr, align 8
  %de.addr = alloca ptr, align 8
  %data = alloca ptr, align 8
  %key = alloca ptr, align 8
  %o = alloca ptr, align 8
  %field = alloca ptr, align 8
  %value4 = alloca ptr, align 8
  %val = alloca ptr, align 8
  %val17 = alloca ptr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  store ptr %de, ptr %de.addr, align 8
  %0 = load ptr, ptr %privdata.addr, align 8
  store ptr %0, ptr %data, align 8
  %1 = load ptr, ptr %de.addr, align 8
  %call = call ptr @dictGetKey(ptr noundef %1)
  store ptr %call, ptr %key, align 8
  %2 = load ptr, ptr %data, align 8
  %key1 = getelementptr inbounds %struct.ScanKeyCBData, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %key1, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %o, align 8
  %5 = load ptr, ptr %key, align 8
  %6 = load ptr, ptr %key, align 8
  %call2 = call i64 @sdslen(ptr noundef %6)
  %call3 = call ptr @createStringObject(ptr noundef %5, i64 noundef %call2)
  store ptr %call3, ptr %field, align 8
  store ptr null, ptr %value4, align 8
  %7 = load ptr, ptr %o, align 8
  %bf.load = load i32, ptr %7, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp eq i32 %bf.clear, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr null, ptr %value4, align 8
  br label %if.end21

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %o, align 8
  %bf.load5 = load i32, ptr %8, align 8
  %bf.clear6 = and i32 %bf.load5, 15
  %cmp7 = icmp eq i32 %bf.clear6, 4
  br i1 %cmp7, label %if.then8, label %if.else12

if.then8:                                         ; preds = %if.else
  %9 = load ptr, ptr %de.addr, align 8
  %call9 = call ptr @dictGetVal(ptr noundef %9)
  store ptr %call9, ptr %val, align 8
  %10 = load ptr, ptr %val, align 8
  %11 = load ptr, ptr %val, align 8
  %call10 = call i64 @sdslen(ptr noundef %11)
  %call11 = call ptr @createStringObject(ptr noundef %10, i64 noundef %call10)
  store ptr %call11, ptr %value4, align 8
  br label %if.end20

if.else12:                                        ; preds = %if.else
  %12 = load ptr, ptr %o, align 8
  %bf.load13 = load i32, ptr %12, align 8
  %bf.clear14 = and i32 %bf.load13, 15
  %cmp15 = icmp eq i32 %bf.clear14, 3
  br i1 %cmp15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else12
  %13 = load ptr, ptr %de.addr, align 8
  %call18 = call ptr @dictGetVal(ptr noundef %13)
  store ptr %call18, ptr %val17, align 8
  %14 = load ptr, ptr %val17, align 8
  %15 = load double, ptr %14, align 8
  %conv = fpext double %15 to x86_fp80
  %call19 = call ptr @createStringObjectFromLongDouble(x86_fp80 noundef %conv, i32 noundef 0)
  store ptr %call19, ptr %value4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else12
  br label %if.end20

if.end20:                                         ; preds = %if.end, %if.then8
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then
  %16 = load ptr, ptr %data, align 8
  %fn = getelementptr inbounds %struct.ScanKeyCBData, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %fn, align 8
  %18 = load ptr, ptr %data, align 8
  %key22 = getelementptr inbounds %struct.ScanKeyCBData, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %key22, align 8
  %20 = load ptr, ptr %field, align 8
  %21 = load ptr, ptr %value4, align 8
  %22 = load ptr, ptr %data, align 8
  %user_data = getelementptr inbounds %struct.ScanKeyCBData, ptr %22, i32 0, i32 1
  %23 = load ptr, ptr %user_data, align 8
  call void %17(ptr noundef %19, ptr noundef %20, ptr noundef %21, ptr noundef %23)
  %24 = load ptr, ptr %field, align 8
  call void @decrRefCount(ptr noundef %24)
  %25 = load ptr, ptr %value4, align 8
  %tobool = icmp ne ptr %25, null
  br i1 %tobool, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end21
  %26 = load ptr, ptr %value4, align 8
  call void @decrRefCount(ptr noundef %26)
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end21
  ret void
}

declare ptr @setTypeInitIterator(ptr noundef) #1

declare ptr @setTypeNextObject(ptr noundef) #1

declare void @setTypeReleaseIterator(ptr noundef) #1

declare ptr @lpSeek(ptr noundef, i64 noundef) #1

declare ptr @lpGetValue(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_Fork(ptr noundef %cb, ptr noundef %user_data) #0 {
entry:
  %cb.addr = alloca ptr, align 8
  %user_data.addr = alloca ptr, align 8
  %childpid = alloca i32, align 4
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %user_data, ptr %user_data.addr, align 8
  %call = call i32 @redisFork(i32 noundef 4)
  store i32 %call, ptr %childpid, align 4
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i32 @redisSetProcTitle(ptr noundef @.str.95)
  br label %if.end15

if.else:                                          ; preds = %entry
  %0 = load i32, ptr %childpid, align 4
  %cmp2 = icmp eq i32 %0, -1
  br i1 %cmp2, label %if.then3, label %if.else8

if.then3:                                         ; preds = %if.else
  br label %do.body

do.body:                                          ; preds = %if.then3
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp4 = icmp slt i32 3, %1
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %call6 = call ptr @__errno_location() #15
  %2 = load i32, ptr %call6, align 4
  %call7 = call ptr @strerror(i32 noundef %2) #16
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.96, ptr noundef %call7)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then5
  br label %if.end14

if.else8:                                         ; preds = %if.else
  %3 = load ptr, ptr %cb.addr, align 8
  store ptr %3, ptr @moduleForkInfo, align 8
  %4 = load ptr, ptr %user_data.addr, align 8
  store ptr %4, ptr getelementptr inbounds (%struct.RedisModuleForkInfo, ptr @moduleForkInfo, i32 0, i32 1), align 8
  br label %do.body9

do.body9:                                         ; preds = %if.else8
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp10 = icmp slt i32 1, %5
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.body9
  br label %do.end13

if.end12:                                         ; preds = %do.body9
  %6 = load i32, ptr %childpid, align 4
  %conv = sext i32 %6 to i64
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.97, i64 noundef %conv)
  br label %do.end13

do.end13:                                         ; preds = %if.end12, %if.then11
  br label %if.end14

if.end14:                                         ; preds = %do.end13, %do.end
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then
  %7 = load i32, ptr %childpid, align 4
  ret i32 %7
}

declare i32 @redisFork(i32 noundef) #1

declare i32 @redisSetProcTitle(ptr noundef) #1

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) #10

; Function Attrs: nounwind uwtable
define dso_local void @RM_SendChildHeartbeat(double noundef %progress) #0 {
entry:
  %progress.addr = alloca double, align 8
  store double %progress, ptr %progress.addr, align 8
  %0 = load double, ptr %progress.addr, align 8
  call void @sendChildInfoGeneric(i32 noundef 0, i64 noundef 0, double noundef %0, ptr noundef @.str.98)
  ret void
}

declare void @sendChildInfoGeneric(i32 noundef, i64 noundef, double noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ExitFromChild(i32 noundef %retcode) #0 {
entry:
  %retcode.addr = alloca i32, align 4
  store i32 %retcode, ptr %retcode.addr, align 4
  call void @sendChildCowInfo(i32 noundef 3, ptr noundef @.str.98)
  %0 = load i32, ptr %retcode.addr, align 4
  call void @exitFromChild(i32 noundef %0)
  ret i32 0
}

declare void @sendChildCowInfo(i32 noundef, ptr noundef) #1

declare void @exitFromChild(i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @TerminateModuleForkChild(i32 noundef %child_pid, i32 noundef %wait) #0 {
entry:
  %retval = alloca i32, align 4
  %child_pid.addr = alloca i32, align 4
  %wait.addr = alloca i32, align 4
  %statloc = alloca i32, align 4
  store i32 %child_pid, ptr %child_pid.addr, align 4
  store i32 %wait, ptr %wait.addr, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp = icmp ne i32 %0, 4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %2 = load i32, ptr %child_pid.addr, align 4
  %cmp1 = icmp ne i32 %1, %2
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  br label %do.body

do.body:                                          ; preds = %if.end
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp2 = icmp slt i32 1, %3
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %do.body
  br label %do.end

if.end4:                                          ; preds = %do.body
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %conv = sext i32 %4 to i64
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.99, i64 noundef %conv)
  br label %do.end

do.end:                                           ; preds = %if.end4, %if.then3
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %call = call i32 @kill(i32 noundef %5, i32 noundef 10) #16
  %cmp5 = icmp ne i32 %call, -1
  br i1 %cmp5, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %do.end
  %6 = load i32, ptr %wait.addr, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then7, label %if.end11

if.then7:                                         ; preds = %land.lhs.true
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then7
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %call8 = call i32 @waitpid(i32 noundef %7, ptr noundef %statloc, i32 noundef 0)
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %cmp9 = icmp ne i32 %call8, %8
  br i1 %cmp9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond, !llvm.loop !64

while.end:                                        ; preds = %while.cond
  br label %if.end11

if.end11:                                         ; preds = %while.end, %land.lhs.true, %do.end
  call void @resetChildState()
  store ptr null, ptr @moduleForkInfo, align 8
  store ptr null, ptr getelementptr inbounds (%struct.RedisModuleForkInfo, ptr @moduleForkInfo, i32 0, i32 1), align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind
declare i32 @kill(i32 noundef, i32 noundef) #10

declare i32 @waitpid(i32 noundef, ptr noundef, i32 noundef) #1

declare void @resetChildState() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_KillForkChild(i32 noundef %child_pid) #0 {
entry:
  %retval = alloca i32, align 4
  %child_pid.addr = alloca i32, align 4
  store i32 %child_pid, ptr %child_pid.addr, align 4
  %0 = load i32, ptr %child_pid.addr, align 4
  %call = call i32 @TerminateModuleForkChild(i32 noundef %0, i32 noundef 1)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %1 = load i32, ptr %retval, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define dso_local void @ModuleForkDoneHandler(i32 noundef %exitcode, i32 noundef %bysignal) #0 {
entry:
  %exitcode.addr = alloca i32, align 4
  %bysignal.addr = alloca i32, align 4
  store i32 %exitcode, ptr %exitcode.addr, align 4
  store i32 %bysignal, ptr %bysignal.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 2, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %conv = sext i32 %1 to i64
  %2 = load i32, ptr %exitcode.addr, align 4
  %3 = load i32, ptr %bysignal.addr, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.100, i64 noundef %conv, i32 noundef %2, i32 noundef %3)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr @moduleForkInfo, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then1, label %if.end2

if.then1:                                         ; preds = %do.end
  %5 = load ptr, ptr @moduleForkInfo, align 8
  %6 = load i32, ptr %exitcode.addr, align 4
  %7 = load i32, ptr %bysignal.addr, align 4
  %8 = load ptr, ptr getelementptr inbounds (%struct.RedisModuleForkInfo, ptr @moduleForkInfo, i32 0, i32 1), align 8
  call void %5(i32 noundef %6, i32 noundef %7, ptr noundef %8)
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %do.end
  store ptr null, ptr @moduleForkInfo, align 8
  store ptr null, ptr getelementptr inbounds (%struct.RedisModuleForkInfo, ptr @moduleForkInfo, i32 0, i32 1), align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SubscribeToServerEvent(ptr noundef %ctx, i64 %event.coerce0, i64 %event.coerce1, ptr noundef %callback) #0 {
entry:
  %retval = alloca i32, align 4
  %event = alloca %struct.RedisModuleEvent, align 8
  %ctx.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %el = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %0 = getelementptr inbounds { i64, i64 }, ptr %event, i32 0, i32 0
  store i64 %event.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { i64, i64 }, ptr %event, i32 0, i32 1
  store i64 %event.coerce1, ptr %1, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %module, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.RedisModuleEvent, ptr %event, i32 0, i32 0
  %4 = load i64, ptr %id, align 8
  %cmp1 = icmp uge i64 %4, 18
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %dataver = getelementptr inbounds %struct.RedisModuleEvent, ptr %event, i32 0, i32 1
  %5 = load i64, ptr %dataver, align 8
  %id4 = getelementptr inbounds %struct.RedisModuleEvent, ptr %event, i32 0, i32 0
  %6 = load i64, ptr %id4, align 8
  %arrayidx = getelementptr inbounds [18 x i64], ptr @moduleEventVersions, i64 0, i64 %6
  %7 = load i64, ptr %arrayidx, align 8
  %cmp5 = icmp ugt i64 %5, %7
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end3
  %8 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listRewind(ptr noundef %8, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end16, %if.end7
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %value, align 8
  store ptr %10, ptr %el, align 8
  %11 = load ptr, ptr %el, align 8
  %module8 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %module8, align 8
  %13 = load ptr, ptr %ctx.addr, align 8
  %module9 = getelementptr inbounds %struct.RedisModuleCtx, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %module9, align 8
  %cmp10 = icmp eq ptr %12, %14
  br i1 %cmp10, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %while.body
  %15 = load ptr, ptr %el, align 8
  %event11 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %15, i32 0, i32 1
  %id12 = getelementptr inbounds %struct.RedisModuleEvent, ptr %event11, i32 0, i32 0
  %16 = load i64, ptr %id12, align 8
  %id13 = getelementptr inbounds %struct.RedisModuleEvent, ptr %event, i32 0, i32 0
  %17 = load i64, ptr %id13, align 8
  %cmp14 = icmp eq i64 %16, %17
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true
  br label %while.end

if.end16:                                         ; preds = %land.lhs.true, %while.body
  br label %while.cond, !llvm.loop !65

while.end:                                        ; preds = %if.then15, %while.cond
  %18 = load ptr, ptr %ln, align 8
  %tobool17 = icmp ne ptr %18, null
  br i1 %tobool17, label %if.then18, label %if.end23

if.then18:                                        ; preds = %while.end
  %19 = load ptr, ptr %callback.addr, align 8
  %cmp19 = icmp eq ptr %19, null
  br i1 %cmp19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.then18
  %20 = load ptr, ptr @RedisModule_EventListeners, align 8
  %21 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %20, ptr noundef %21)
  %22 = load ptr, ptr %el, align 8
  call void @zfree(ptr noundef %22)
  br label %if.end22

if.else:                                          ; preds = %if.then18
  %23 = load ptr, ptr %callback.addr, align 8
  %24 = load ptr, ptr %el, align 8
  %callback21 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %24, i32 0, i32 2
  store ptr %23, ptr %callback21, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then20
  store i32 0, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %while.end
  %call24 = call noalias ptr @zmalloc(i64 noundef 32) #11
  store ptr %call24, ptr %el, align 8
  %25 = load ptr, ptr %ctx.addr, align 8
  %module25 = getelementptr inbounds %struct.RedisModuleCtx, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %module25, align 8
  %27 = load ptr, ptr %el, align 8
  %module26 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %27, i32 0, i32 0
  store ptr %26, ptr %module26, align 8
  %28 = load ptr, ptr %el, align 8
  %event27 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %28, i32 0, i32 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %event27, ptr align 8 %event, i64 16, i1 false)
  %29 = load ptr, ptr %callback.addr, align 8
  %30 = load ptr, ptr %el, align 8
  %callback28 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %30, i32 0, i32 2
  store ptr %29, ptr %callback28, align 8
  %31 = load ptr, ptr @RedisModule_EventListeners, align 8
  %32 = load ptr, ptr %el, align 8
  %call29 = call ptr @listAddNodeTail(ptr noundef %31, ptr noundef %32)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.end22, %if.then6, %if.then2, %if.then
  %33 = load i32, ptr %retval, align 4
  ret i32 %33
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_IsSubEventSupported(i64 %event.coerce0, i64 %event.coerce1, i64 noundef %subevent) #0 {
entry:
  %retval = alloca i32, align 4
  %event = alloca %struct.RedisModuleEvent, align 8
  %subevent.addr = alloca i64, align 8
  %0 = getelementptr inbounds { i64, i64 }, ptr %event, i32 0, i32 0
  store i64 %event.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { i64, i64 }, ptr %event, i32 0, i32 1
  store i64 %event.coerce1, ptr %1, align 8
  store i64 %subevent, ptr %subevent.addr, align 8
  %id = getelementptr inbounds %struct.RedisModuleEvent, ptr %event, i32 0, i32 0
  %2 = load i64, ptr %id, align 8
  switch i64 %2, label %sw.default [
    i64 0, label %sw.bb
    i64 1, label %sw.bb1
    i64 2, label %sw.bb4
    i64 3, label %sw.bb7
    i64 4, label %sw.bb10
    i64 5, label %sw.bb13
    i64 6, label %sw.bb16
    i64 7, label %sw.bb19
    i64 8, label %sw.bb22
    i64 9, label %sw.bb25
    i64 10, label %sw.bb28
    i64 11, label %sw.bb31
    i64 14, label %sw.bb34
    i64 13, label %sw.bb37
    i64 15, label %sw.bb40
    i64 16, label %sw.bb43
    i64 17, label %sw.bb46
  ]

sw.bb:                                            ; preds = %entry
  %3 = load i64, ptr %subevent.addr, align 8
  %cmp = icmp slt i64 %3, 2
  %conv = zext i1 %cmp to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  %4 = load i64, ptr %subevent.addr, align 8
  %cmp2 = icmp slt i64 %4, 6
  %conv3 = zext i1 %cmp2 to i32
  store i32 %conv3, ptr %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %entry
  %5 = load i64, ptr %subevent.addr, align 8
  %cmp5 = icmp slt i64 %5, 2
  %conv6 = zext i1 %cmp5 to i32
  store i32 %conv6, ptr %retval, align 4
  br label %return

sw.bb7:                                           ; preds = %entry
  %6 = load i64, ptr %subevent.addr, align 8
  %cmp8 = icmp slt i64 %6, 5
  %conv9 = zext i1 %cmp8 to i32
  store i32 %conv9, ptr %retval, align 4
  br label %return

sw.bb10:                                          ; preds = %entry
  %7 = load i64, ptr %subevent.addr, align 8
  %cmp11 = icmp slt i64 %7, 2
  %conv12 = zext i1 %cmp11 to i32
  store i32 %conv12, ptr %retval, align 4
  br label %return

sw.bb13:                                          ; preds = %entry
  %8 = load i64, ptr %subevent.addr, align 8
  %cmp14 = icmp slt i64 %8, 0
  %conv15 = zext i1 %cmp14 to i32
  store i32 %conv15, ptr %retval, align 4
  br label %return

sw.bb16:                                          ; preds = %entry
  %9 = load i64, ptr %subevent.addr, align 8
  %cmp17 = icmp slt i64 %9, 2
  %conv18 = zext i1 %cmp17 to i32
  store i32 %conv18, ptr %retval, align 4
  br label %return

sw.bb19:                                          ; preds = %entry
  %10 = load i64, ptr %subevent.addr, align 8
  %cmp20 = icmp slt i64 %10, 2
  %conv21 = zext i1 %cmp20 to i32
  store i32 %conv21, ptr %retval, align 4
  br label %return

sw.bb22:                                          ; preds = %entry
  %11 = load i64, ptr %subevent.addr, align 8
  %cmp23 = icmp slt i64 %11, 0
  %conv24 = zext i1 %cmp23 to i32
  store i32 %conv24, ptr %retval, align 4
  br label %return

sw.bb25:                                          ; preds = %entry
  %12 = load i64, ptr %subevent.addr, align 8
  %cmp26 = icmp slt i64 %12, 2
  %conv27 = zext i1 %cmp26 to i32
  store i32 %conv27, ptr %retval, align 4
  br label %return

sw.bb28:                                          ; preds = %entry
  %13 = load i64, ptr %subevent.addr, align 8
  %cmp29 = icmp slt i64 %13, 2
  %conv30 = zext i1 %cmp29 to i32
  store i32 %conv30, ptr %retval, align 4
  br label %return

sw.bb31:                                          ; preds = %entry
  %14 = load i64, ptr %subevent.addr, align 8
  %cmp32 = icmp slt i64 %14, 0
  %conv33 = zext i1 %cmp32 to i32
  store i32 %conv33, ptr %retval, align 4
  br label %return

sw.bb34:                                          ; preds = %entry
  %15 = load i64, ptr %subevent.addr, align 8
  %cmp35 = icmp slt i64 %15, 3
  %conv36 = zext i1 %cmp35 to i32
  store i32 %conv36, ptr %retval, align 4
  br label %return

sw.bb37:                                          ; preds = %entry
  %16 = load i64, ptr %subevent.addr, align 8
  %cmp38 = icmp slt i64 %16, 2
  %conv39 = zext i1 %cmp38 to i32
  store i32 %conv39, ptr %retval, align 4
  br label %return

sw.bb40:                                          ; preds = %entry
  %17 = load i64, ptr %subevent.addr, align 8
  %cmp41 = icmp slt i64 %17, 2
  %conv42 = zext i1 %cmp41 to i32
  store i32 %conv42, ptr %retval, align 4
  br label %return

sw.bb43:                                          ; preds = %entry
  %18 = load i64, ptr %subevent.addr, align 8
  %cmp44 = icmp slt i64 %18, 1
  %conv45 = zext i1 %cmp44 to i32
  store i32 %conv45, ptr %retval, align 4
  br label %return

sw.bb46:                                          ; preds = %entry
  %19 = load i64, ptr %subevent.addr, align 8
  %cmp47 = icmp slt i64 %19, 4
  %conv48 = zext i1 %cmp47 to i32
  store i32 %conv48, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb46, %sw.bb43, %sw.bb40, %sw.bb37, %sw.bb34, %sw.bb31, %sw.bb28, %sw.bb25, %sw.bb22, %sw.bb19, %sw.bb16, %sw.bb13, %sw.bb10, %sw.bb7, %sw.bb4, %sw.bb1, %sw.bb
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleFireServerEvent(i64 noundef %eid, i32 noundef %subid, ptr noundef %data) #0 {
entry:
  %eid.addr = alloca i64, align 8
  %subid.addr = alloca i32, align 4
  %data.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %el = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %moduledata = alloca ptr, align 8
  %civ1 = alloca %struct.RedisModuleClientInfo, align 8
  %riv1 = alloca %struct.RedisModuleReplicationInfo, align 8
  %mcv1 = alloca %struct.RedisModuleModuleChange, align 8
  %key = alloca %struct.RedisModuleKey, align 8
  %ki = alloca %struct.RedisModuleKeyInfo, align 8
  %fi = alloca ptr, align 8
  %m = alloca ptr, align 8
  %info = alloca ptr, align 8
  store i64 %eid, ptr %eid.addr, align 8
  store i32 %subid, ptr %subid.addr, align 4
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr @RedisModule_EventListeners, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %while.end

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end100, %if.then54, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %el, align 8
  %5 = load ptr, ptr %el, align 8
  %event = getelementptr inbounds %struct.RedisModuleEventListener, ptr %5, i32 0, i32 1
  %id = getelementptr inbounds %struct.RedisModuleEvent, ptr %event, i32 0, i32 0
  %6 = load i64, ptr %id, align 8
  %7 = load i64, ptr %eid.addr, align 8
  %cmp1 = icmp eq i64 %6, %7
  br i1 %cmp1, label %if.then2, label %if.end100

if.then2:                                         ; preds = %while.body
  %8 = load i64, ptr %eid.addr, align 8
  %cmp3 = icmp eq i64 %8, 4
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then2
  %9 = load ptr, ptr %el, align 8
  %module = getelementptr inbounds %struct.RedisModuleEventListener, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %10, i32 noundef 0)
  %11 = load ptr, ptr %data.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  store ptr %11, ptr %client, align 8
  br label %if.end6

if.else:                                          ; preds = %if.then2
  %12 = load ptr, ptr %el, align 8
  %module5 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %module5, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %13, i32 noundef 64)
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then4
  store ptr null, ptr %moduledata, align 8
  %version = getelementptr inbounds %struct.RedisModuleKeyInfo, ptr %ki, i32 0, i32 0
  store i64 1, ptr %version, align 8
  %key7 = getelementptr inbounds %struct.RedisModuleKeyInfo, ptr %ki, i32 0, i32 1
  store ptr %key, ptr %key7, align 8
  %14 = load i64, ptr %eid.addr, align 8
  %cmp8 = icmp eq i64 %14, 4
  br i1 %cmp8, label %if.then9, label %if.else17

if.then9:                                         ; preds = %if.end6
  %15 = load ptr, ptr %data.addr, align 8
  %16 = load ptr, ptr %el, align 8
  %event10 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %16, i32 0, i32 1
  %dataver = getelementptr inbounds %struct.RedisModuleEvent, ptr %event10, i32 0, i32 1
  %17 = load i64, ptr %dataver, align 8
  %conv = trunc i64 %17 to i32
  %call11 = call i32 @modulePopulateClientInfoStructure(ptr noundef %civ1, ptr noundef %15, i32 noundef %conv)
  %cmp12 = icmp eq i32 %call11, 0
  %lnot = xor i1 %cmp12, true
  %lnot14 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot14 to i32
  %conv15 = sext i32 %lnot.ext to i64
  %tobool16 = icmp ne i64 %conv15, 0
  br i1 %tobool16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then9
  br label %cond.end

cond.false:                                       ; preds = %if.then9
  call void @_serverAssert(ptr noundef @.str.101, ptr noundef @.str.2, i32 noundef 11683)
  call void @abort() #13
  unreachable

18:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %18, %cond.true
  store ptr %civ1, ptr %moduledata, align 8
  br label %if.end90

if.else17:                                        ; preds = %if.end6
  %19 = load i64, ptr %eid.addr, align 8
  %cmp18 = icmp eq i64 %19, 0
  br i1 %cmp18, label %if.then20, label %if.else36

if.then20:                                        ; preds = %if.else17
  %20 = load ptr, ptr %el, align 8
  %event21 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %20, i32 0, i32 1
  %dataver22 = getelementptr inbounds %struct.RedisModuleEvent, ptr %event21, i32 0, i32 1
  %21 = load i64, ptr %dataver22, align 8
  %conv23 = trunc i64 %21 to i32
  %call24 = call i32 @modulePopulateReplicationInfoStructure(ptr noundef %riv1, i32 noundef %conv23)
  %cmp25 = icmp eq i32 %call24, 0
  %lnot27 = xor i1 %cmp25, true
  %lnot29 = xor i1 %lnot27, true
  %lnot.ext30 = zext i1 %lnot29 to i32
  %conv31 = sext i32 %lnot.ext30 to i64
  %tobool32 = icmp ne i64 %conv31, 0
  br i1 %tobool32, label %cond.true33, label %cond.false34

cond.true33:                                      ; preds = %if.then20
  br label %cond.end35

cond.false34:                                     ; preds = %if.then20
  call void @_serverAssert(ptr noundef @.str.102, ptr noundef @.str.2, i32 noundef 11686)
  call void @abort() #13
  unreachable

22:                                               ; No predecessors!
  br label %cond.end35

cond.end35:                                       ; preds = %22, %cond.true33
  store ptr %riv1, ptr %moduledata, align 8
  br label %if.end89

if.else36:                                        ; preds = %if.else17
  %23 = load i64, ptr %eid.addr, align 8
  %cmp37 = icmp eq i64 %23, 2
  br i1 %cmp37, label %if.then39, label %if.else47

if.then39:                                        ; preds = %if.else36
  %24 = load ptr, ptr %data.addr, align 8
  store ptr %24, ptr %moduledata, align 8
  %25 = load ptr, ptr %data.addr, align 8
  store ptr %25, ptr %fi, align 8
  %26 = load ptr, ptr %fi, align 8
  %dbnum = getelementptr inbounds %struct.RedisModuleFlushInfo, ptr %26, i32 0, i32 2
  %27 = load i32, ptr %dbnum, align 4
  %cmp40 = icmp ne i32 %27, -1
  br i1 %cmp40, label %if.then42, label %if.end46

if.then42:                                        ; preds = %if.then39
  %client43 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  %28 = load ptr, ptr %client43, align 8
  %29 = load ptr, ptr %fi, align 8
  %dbnum44 = getelementptr inbounds %struct.RedisModuleFlushInfo, ptr %29, i32 0, i32 2
  %30 = load i32, ptr %dbnum44, align 4
  %call45 = call i32 @selectDb(ptr noundef %28, i32 noundef %30)
  br label %if.end46

if.end46:                                         ; preds = %if.then42, %if.then39
  br label %if.end88

if.else47:                                        ; preds = %if.else36
  %31 = load i64, ptr %eid.addr, align 8
  %cmp48 = icmp eq i64 %31, 9
  br i1 %cmp48, label %if.then50, label %if.else57

if.then50:                                        ; preds = %if.else47
  %32 = load ptr, ptr %data.addr, align 8
  store ptr %32, ptr %m, align 8
  %33 = load ptr, ptr %m, align 8
  %34 = load ptr, ptr %el, align 8
  %module51 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %34, i32 0, i32 0
  %35 = load ptr, ptr %module51, align 8
  %cmp52 = icmp eq ptr %33, %35
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.then50
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %while.cond, !llvm.loop !66

if.end55:                                         ; preds = %if.then50
  %version56 = getelementptr inbounds %struct.RedisModuleModuleChange, ptr %mcv1, i32 0, i32 0
  store i64 1, ptr %version56, align 8
  %36 = load ptr, ptr %m, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %36, i32 0, i32 1
  %37 = load ptr, ptr %name, align 8
  %module_name = getelementptr inbounds %struct.RedisModuleModuleChange, ptr %mcv1, i32 0, i32 1
  store ptr %37, ptr %module_name, align 8
  %38 = load ptr, ptr %m, align 8
  %ver = getelementptr inbounds %struct.RedisModule, ptr %38, i32 0, i32 2
  %39 = load i32, ptr %ver, align 8
  %module_version = getelementptr inbounds %struct.RedisModuleModuleChange, ptr %mcv1, i32 0, i32 2
  store i32 %39, ptr %module_version, align 8
  store ptr %mcv1, ptr %moduledata, align 8
  br label %if.end87

if.else57:                                        ; preds = %if.else47
  %40 = load i64, ptr %eid.addr, align 8
  %cmp58 = icmp eq i64 %40, 10
  br i1 %cmp58, label %if.then60, label %if.else61

if.then60:                                        ; preds = %if.else57
  %41 = load ptr, ptr %data.addr, align 8
  store ptr %41, ptr %moduledata, align 8
  br label %if.end86

if.else61:                                        ; preds = %if.else57
  %42 = load i64, ptr %eid.addr, align 8
  %cmp62 = icmp eq i64 %42, 8
  br i1 %cmp62, label %if.then64, label %if.else65

if.then64:                                        ; preds = %if.else61
  %43 = load ptr, ptr %data.addr, align 8
  store ptr %43, ptr %moduledata, align 8
  br label %if.end85

if.else65:                                        ; preds = %if.else61
  %44 = load i64, ptr %eid.addr, align 8
  %cmp66 = icmp eq i64 %44, 11
  br i1 %cmp66, label %if.then68, label %if.else69

if.then68:                                        ; preds = %if.else65
  %45 = load ptr, ptr %data.addr, align 8
  store ptr %45, ptr %moduledata, align 8
  br label %if.end84

if.else69:                                        ; preds = %if.else65
  %46 = load i64, ptr %eid.addr, align 8
  %cmp70 = icmp eq i64 %46, 16
  br i1 %cmp70, label %if.then72, label %if.else73

if.then72:                                        ; preds = %if.else69
  %47 = load ptr, ptr %data.addr, align 8
  store ptr %47, ptr %moduledata, align 8
  br label %if.end83

if.else73:                                        ; preds = %if.else69
  %48 = load i64, ptr %eid.addr, align 8
  %cmp74 = icmp eq i64 %48, 17
  br i1 %cmp74, label %if.then76, label %if.end82

if.then76:                                        ; preds = %if.else73
  %49 = load ptr, ptr %data.addr, align 8
  store ptr %49, ptr %info, align 8
  %client77 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 2
  %50 = load ptr, ptr %client77, align 8
  %51 = load ptr, ptr %info, align 8
  %dbnum78 = getelementptr inbounds %struct.KeyInfo, ptr %51, i32 0, i32 0
  %52 = load i32, ptr %dbnum78, align 8
  %call79 = call i32 @selectDb(ptr noundef %50, i32 noundef %52)
  %53 = load ptr, ptr %info, align 8
  %key80 = getelementptr inbounds %struct.KeyInfo, ptr %53, i32 0, i32 1
  %54 = load ptr, ptr %key80, align 8
  %55 = load ptr, ptr %info, align 8
  %value81 = getelementptr inbounds %struct.KeyInfo, ptr %55, i32 0, i32 2
  %56 = load ptr, ptr %value81, align 8
  %57 = load ptr, ptr %info, align 8
  %mode = getelementptr inbounds %struct.KeyInfo, ptr %57, i32 0, i32 3
  %58 = load i32, ptr %mode, align 8
  call void @moduleInitKey(ptr noundef %key, ptr noundef %ctx, ptr noundef %54, ptr noundef %56, i32 noundef %58)
  store ptr %ki, ptr %moduledata, align 8
  br label %if.end82

if.end82:                                         ; preds = %if.then76, %if.else73
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.then72
  br label %if.end84

if.end84:                                         ; preds = %if.end83, %if.then68
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %if.then64
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.then60
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.end55
  br label %if.end88

if.end88:                                         ; preds = %if.end87, %if.end46
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %cond.end35
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %cond.end
  %59 = load ptr, ptr %el, align 8
  %module91 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %59, i32 0, i32 0
  %60 = load ptr, ptr %module91, align 8
  %in_hook = getelementptr inbounds %struct.RedisModule, ptr %60, i32 0, i32 11
  %61 = load i32, ptr %in_hook, align 8
  %inc = add nsw i32 %61, 1
  store i32 %inc, ptr %in_hook, align 8
  %62 = load ptr, ptr %el, align 8
  %callback = getelementptr inbounds %struct.RedisModuleEventListener, ptr %62, i32 0, i32 2
  %63 = load ptr, ptr %callback, align 8
  %64 = load ptr, ptr %el, align 8
  %event92 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %64, i32 0, i32 1
  %65 = load i32, ptr %subid.addr, align 4
  %conv93 = sext i32 %65 to i64
  %66 = load ptr, ptr %moduledata, align 8
  %67 = getelementptr inbounds { i64, i64 }, ptr %event92, i32 0, i32 0
  %68 = load i64, ptr %67, align 8
  %69 = getelementptr inbounds { i64, i64 }, ptr %event92, i32 0, i32 1
  %70 = load i64, ptr %69, align 8
  call void %63(ptr noundef %ctx, i64 %68, i64 %70, i64 noundef %conv93, ptr noundef %66)
  %71 = load ptr, ptr %el, align 8
  %module94 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %71, i32 0, i32 0
  %72 = load ptr, ptr %module94, align 8
  %in_hook95 = getelementptr inbounds %struct.RedisModule, ptr %72, i32 0, i32 11
  %73 = load i32, ptr %in_hook95, align 8
  %dec = add nsw i32 %73, -1
  store i32 %dec, ptr %in_hook95, align 8
  %74 = load i64, ptr %eid.addr, align 8
  %cmp96 = icmp eq i64 %74, 17
  br i1 %cmp96, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end90
  call void @moduleCloseKey(ptr noundef %key)
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %if.end90
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %if.end100

if.end100:                                        ; preds = %if.end99, %while.body
  br label %while.cond, !llvm.loop !66

while.end:                                        ; preds = %while.cond, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnsubscribeAllServerEvents(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %el = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr @RedisModule_EventListeners, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %el, align 8
  %3 = load ptr, ptr %el, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleEventListener, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %module1, align 8
  %5 = load ptr, ptr %module.addr, align 8
  %cmp = icmp eq ptr %4, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %6 = load ptr, ptr @RedisModule_EventListeners, align 8
  %7 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %el, align 8
  call void @zfree(ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !67

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @processModuleLoadingProgressEvent(i32 noundef %is_aof) #0 {
entry:
  %is_aof.addr = alloca i32, align 4
  %now = alloca i64, align 8
  %progress = alloca i32, align 4
  %fi = alloca %struct.RedisModuleLoadingProgressInfo, align 8
  store i32 %is_aof, ptr %is_aof.addr, align 4
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 353), align 8
  store i64 %0, ptr %now, align 8
  %1 = load i64, ptr %now, align 8
  %2 = load i64, ptr @processModuleLoadingProgressEvent.next_event, align 8
  %cmp = icmp sge i64 %1, %2
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  store i32 -1, ptr %progress, align 4
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 83), align 8
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 85), align 8
  %shl = shl i64 %4, 10
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 83), align 8
  %div = sdiv i64 %shl, %5
  %conv = trunc i64 %div to i32
  store i32 %conv, ptr %progress, align 4
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %version = getelementptr inbounds %struct.RedisModuleLoadingProgressInfo, ptr %fi, i32 0, i32 0
  store i64 1, ptr %version, align 8
  %hz = getelementptr inbounds %struct.RedisModuleLoadingProgressInfo, ptr %fi, i32 0, i32 1
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  store i32 %6, ptr %hz, align 8
  %progress2 = getelementptr inbounds %struct.RedisModuleLoadingProgressInfo, ptr %fi, i32 0, i32 2
  %7 = load i32, ptr %progress, align 4
  store i32 %7, ptr %progress2, align 4
  %8 = load i32, ptr %is_aof.addr, align 4
  %tobool3 = icmp ne i32 %8, 0
  %cond = select i1 %tobool3, i32 1, i32 0
  call void @moduleFireServerEvent(i64 noundef 10, i32 noundef %cond, ptr noundef %fi)
  %9 = load i64, ptr %now, align 8
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div4 = sdiv i32 1000000, %10
  %conv5 = sext i32 %div4 to i64
  %add = add nsw i64 %9, %conv5
  store i64 %add, ptr @processModuleLoadingProgressEvent.next_event, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleNotifyKeyUnlink(ptr noundef %key, ptr noundef %val, i32 noundef %dbid, i32 noundef %flags) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %dbid.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %subevent = alloca i32, align 4
  %info = alloca %struct.KeyInfo, align 8
  %mv = alloca ptr, align 8
  %mt = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleKeyOptCtx, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  store i32 %dbid, ptr %dbid.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  store i32 0, ptr %subevent, align 4
  %1 = load i32, ptr %flags.addr, align 4
  %conv = sext i32 %1 to i64
  %and = and i64 %conv, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, ptr %subevent, align 4
  br label %if.end11

if.else:                                          ; preds = %entry
  %2 = load i32, ptr %flags.addr, align 4
  %conv1 = sext i32 %2 to i64
  %and2 = and i64 %conv1, 4
  %tobool3 = icmp ne i64 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  store i32 2, ptr %subevent, align 4
  br label %if.end10

if.else5:                                         ; preds = %if.else
  %3 = load i32, ptr %flags.addr, align 4
  %conv6 = sext i32 %3 to i64
  %and7 = and i64 %conv6, 8
  %tobool8 = icmp ne i64 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.else5
  store i32 3, ptr %subevent, align 4
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.else5
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then4
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then
  %dbnum = getelementptr inbounds %struct.KeyInfo, ptr %info, i32 0, i32 0
  %4 = load i32, ptr %dbid.addr, align 4
  store i32 %4, ptr %dbnum, align 8
  %key12 = getelementptr inbounds %struct.KeyInfo, ptr %info, i32 0, i32 1
  %5 = load ptr, ptr %key.addr, align 8
  store ptr %5, ptr %key12, align 8
  %value = getelementptr inbounds %struct.KeyInfo, ptr %info, i32 0, i32 2
  %6 = load ptr, ptr %val.addr, align 8
  store ptr %6, ptr %value, align 8
  %mode = getelementptr inbounds %struct.KeyInfo, ptr %info, i32 0, i32 3
  store i32 1, ptr %mode, align 8
  %7 = load i32, ptr %subevent, align 4
  call void @moduleFireServerEvent(i64 noundef 17, i32 noundef %7, ptr noundef %info)
  %8 = load ptr, ptr %val.addr, align 8
  %bf.load = load i32, ptr %8, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp eq i32 %bf.clear, 5
  br i1 %cmp, label %if.then14, label %if.end28

if.then14:                                        ; preds = %if.end11
  %9 = load ptr, ptr %val.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %ptr, align 8
  store ptr %10, ptr %mv, align 8
  %11 = load ptr, ptr %mv, align 8
  %type = getelementptr inbounds %struct.moduleValue, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %type, align 8
  store ptr %12, ptr %mt, align 8
  %13 = load ptr, ptr %mt, align 8
  %unlink2 = getelementptr inbounds %struct.RedisModuleType, ptr %13, i32 0, i32 16
  %14 = load ptr, ptr %unlink2, align 8
  %cmp15 = icmp ne ptr %14, null
  br i1 %cmp15, label %if.then17, label %if.else20

if.then17:                                        ; preds = %if.then14
  %from_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 0
  %15 = load ptr, ptr %key.addr, align 8
  store ptr %15, ptr %from_key, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 1
  store ptr null, ptr %to_key, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 2
  %16 = load i32, ptr %dbid.addr, align 4
  store i32 %16, ptr %from_dbid, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 3
  store i32 -1, ptr %to_dbid, align 4
  %17 = load ptr, ptr %mt, align 8
  %unlink218 = getelementptr inbounds %struct.RedisModuleType, ptr %17, i32 0, i32 16
  %18 = load ptr, ptr %unlink218, align 8
  %19 = load ptr, ptr %mv, align 8
  %value19 = getelementptr inbounds %struct.moduleValue, ptr %19, i32 0, i32 1
  %20 = load ptr, ptr %value19, align 8
  call void %18(ptr noundef %ctx, ptr noundef %20)
  br label %if.end27

if.else20:                                        ; preds = %if.then14
  %21 = load ptr, ptr %mt, align 8
  %unlink = getelementptr inbounds %struct.RedisModuleType, ptr %21, i32 0, i32 9
  %22 = load ptr, ptr %unlink, align 8
  %cmp21 = icmp ne ptr %22, null
  br i1 %cmp21, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else20
  %23 = load ptr, ptr %mt, align 8
  %unlink24 = getelementptr inbounds %struct.RedisModuleType, ptr %23, i32 0, i32 9
  %24 = load ptr, ptr %unlink24, align 8
  %25 = load ptr, ptr %key.addr, align 8
  %26 = load ptr, ptr %mv, align 8
  %value25 = getelementptr inbounds %struct.moduleValue, ptr %26, i32 0, i32 1
  %27 = load ptr, ptr %value25, align 8
  call void %24(ptr noundef %25, ptr noundef %27)
  br label %if.end26

if.end26:                                         ; preds = %if.then23, %if.else20
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.then17
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end11
  %28 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  %dec = add nsw i32 %28, -1
  store i32 %dec, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @moduleGetFreeEffort(ptr noundef %key, ptr noundef %val, i32 noundef %dbid) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %dbid.addr = alloca i32, align 4
  %mv = alloca ptr, align 8
  %mt = alloca ptr, align 8
  %effort = alloca i64, align 8
  %ctx = alloca %struct.RedisModuleKeyOptCtx, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  store i32 %dbid, ptr %dbid.addr, align 4
  %0 = load ptr, ptr %val.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  store ptr %1, ptr %mv, align 8
  %2 = load ptr, ptr %mv, align 8
  %type = getelementptr inbounds %struct.moduleValue, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %type, align 8
  store ptr %3, ptr %mt, align 8
  store i64 1, ptr %effort, align 8
  %4 = load ptr, ptr %mt, align 8
  %free_effort2 = getelementptr inbounds %struct.RedisModuleType, ptr %4, i32 0, i32 15
  %5 = load ptr, ptr %free_effort2, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %from_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 0
  %6 = load ptr, ptr %key.addr, align 8
  store ptr %6, ptr %from_key, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 1
  store ptr null, ptr %to_key, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 2
  %7 = load i32, ptr %dbid.addr, align 4
  store i32 %7, ptr %from_dbid, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 3
  store i32 -1, ptr %to_dbid, align 4
  %8 = load ptr, ptr %mt, align 8
  %free_effort21 = getelementptr inbounds %struct.RedisModuleType, ptr %8, i32 0, i32 15
  %9 = load ptr, ptr %free_effort21, align 8
  %10 = load ptr, ptr %mv, align 8
  %value = getelementptr inbounds %struct.moduleValue, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %value, align 8
  %call = call i64 %9(ptr noundef %ctx, ptr noundef %11)
  store i64 %call, ptr %effort, align 8
  br label %if.end7

if.else:                                          ; preds = %entry
  %12 = load ptr, ptr %mt, align 8
  %free_effort = getelementptr inbounds %struct.RedisModuleType, ptr %12, i32 0, i32 8
  %13 = load ptr, ptr %free_effort, align 8
  %cmp2 = icmp ne ptr %13, null
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  %14 = load ptr, ptr %mt, align 8
  %free_effort4 = getelementptr inbounds %struct.RedisModuleType, ptr %14, i32 0, i32 8
  %15 = load ptr, ptr %free_effort4, align 8
  %16 = load ptr, ptr %key.addr, align 8
  %17 = load ptr, ptr %mv, align 8
  %value5 = getelementptr inbounds %struct.moduleValue, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %value5, align 8
  %call6 = call i64 %15(ptr noundef %16, ptr noundef %18)
  store i64 %call6, ptr %effort, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %19 = load i64, ptr %effort, align 8
  ret i64 %19
}

; Function Attrs: nounwind uwtable
define dso_local i64 @moduleGetMemUsage(ptr noundef %key, ptr noundef %val, i64 noundef %sample_size, i32 noundef %dbid) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %sample_size.addr = alloca i64, align 8
  %dbid.addr = alloca i32, align 4
  %mv = alloca ptr, align 8
  %mt = alloca ptr, align 8
  %size = alloca i64, align 8
  %ctx = alloca %struct.RedisModuleKeyOptCtx, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  store i64 %sample_size, ptr %sample_size.addr, align 8
  store i32 %dbid, ptr %dbid.addr, align 4
  %0 = load ptr, ptr %val.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  store ptr %1, ptr %mv, align 8
  %2 = load ptr, ptr %mv, align 8
  %type = getelementptr inbounds %struct.moduleValue, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %type, align 8
  store ptr %3, ptr %mt, align 8
  store i64 0, ptr %size, align 8
  %4 = load ptr, ptr %mt, align 8
  %mem_usage2 = getelementptr inbounds %struct.RedisModuleType, ptr %4, i32 0, i32 14
  %5 = load ptr, ptr %mem_usage2, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %from_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 0
  %6 = load ptr, ptr %key.addr, align 8
  store ptr %6, ptr %from_key, align 8
  %to_key = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 1
  store ptr null, ptr %to_key, align 8
  %from_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 2
  %7 = load i32, ptr %dbid.addr, align 4
  store i32 %7, ptr %from_dbid, align 8
  %to_dbid = getelementptr inbounds %struct.RedisModuleKeyOptCtx, ptr %ctx, i32 0, i32 3
  store i32 -1, ptr %to_dbid, align 4
  %8 = load ptr, ptr %mt, align 8
  %mem_usage21 = getelementptr inbounds %struct.RedisModuleType, ptr %8, i32 0, i32 14
  %9 = load ptr, ptr %mem_usage21, align 8
  %10 = load ptr, ptr %mv, align 8
  %value = getelementptr inbounds %struct.moduleValue, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %value, align 8
  %12 = load i64, ptr %sample_size.addr, align 8
  %call = call i64 %9(ptr noundef %ctx, ptr noundef %11, i64 noundef %12)
  store i64 %call, ptr %size, align 8
  br label %if.end7

if.else:                                          ; preds = %entry
  %13 = load ptr, ptr %mt, align 8
  %mem_usage = getelementptr inbounds %struct.RedisModuleType, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %mem_usage, align 8
  %cmp2 = icmp ne ptr %14, null
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  %15 = load ptr, ptr %mt, align 8
  %mem_usage4 = getelementptr inbounds %struct.RedisModuleType, ptr %15, i32 0, i32 5
  %16 = load ptr, ptr %mem_usage4, align 8
  %17 = load ptr, ptr %mv, align 8
  %value5 = getelementptr inbounds %struct.moduleValue, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %value5, align 8
  %call6 = call i64 %16(ptr noundef %18)
  store i64 %call6, ptr %size, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %19 = load i64, ptr %size, align 8
  ret i64 %19
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dictCStringKeyHash(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #14
  %call1 = call i64 @dictGenHashFunction(ptr noundef %0, i64 noundef %call)
  ret i64 %call1
}

declare i64 @dictGenHashFunction(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @dictCStringKeyCompare(ptr noundef %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key1.addr = alloca ptr, align 8
  %key2.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key1, ptr %key1.addr, align 8
  store ptr %key2, ptr %key2.addr, align 8
  %0 = load ptr, ptr %key1.addr, align 8
  %1 = load ptr, ptr %key2.addr, align 8
  %call = call i32 @strcmp(ptr noundef %0, ptr noundef %1) #14
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #6

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleRegisterApi(ptr noundef %funcname, ptr noundef %funcptr) #0 {
entry:
  %funcname.addr = alloca ptr, align 8
  %funcptr.addr = alloca ptr, align 8
  store ptr %funcname, ptr %funcname.addr, align 8
  store ptr %funcptr, ptr %funcptr.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 37), align 8
  %1 = load ptr, ptr %funcname.addr, align 8
  %2 = load ptr, ptr %funcptr.addr, align 8
  %call = call i32 @dictAdd(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleInitModulesSystemLast() #0 {
entry:
  ret void
}

declare i64 @dictSdsCaseHash(ptr noundef) #1

declare i32 @dictSdsKeyCaseCompare(ptr noundef, ptr noundef, ptr noundef) #1

declare void @dictSdsDestructor(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleInitModulesSystem() #0 {
entry:
  %call = call ptr @listCreate()
  store ptr %call, ptr @moduleUnblockedClients, align 8
  %call1 = call ptr @listCreate()
  store ptr %call1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 40), align 8
  %call2 = call ptr @dictCreate(ptr noundef @sdsKeyValueHashDictType)
  store ptr %call2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  %call3 = call ptr @dictCreate(ptr noundef @modulesDictType)
  store ptr %call3, ptr @modules, align 8
  %call4 = call ptr @listCreate()
  store ptr %call4, ptr @moduleAuthCallbacks, align 8
  %call5 = call ptr @listCreate()
  store ptr %call5, ptr @moduleKeyspaceSubscribers, align 8
  %call6 = call ptr @listCreate()
  store ptr %call6, ptr @modulePostExecUnitJobs, align 8
  %call7 = call ptr @listCreate()
  store ptr %call7, ptr @moduleCommandFilters, align 8
  call void @moduleRegisterCoreAPI()
  %call8 = call i32 @anetPipe(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 41), i32 noundef 526336, i32 noundef 526336)
  %cmp = icmp eq i32 %call8, -1
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp9 = icmp slt i32 3, %0
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %call11 = call ptr @__errno_location() #15
  %1 = load i32, ptr %call11, align 4
  %call12 = call ptr @strerror(i32 noundef %1) #16
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.103, ptr noundef %call12)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then10
  call void @exit(i32 noundef 1) #13
  unreachable

if.end13:                                         ; preds = %entry
  %call14 = call ptr @raxNew()
  store ptr %call14, ptr @Timers, align 8
  %call15 = call ptr @listCreate()
  store ptr %call15, ptr @RedisModule_EventListeners, align 8
  %call16 = call i32 @pthread_mutex_lock(ptr noundef @moduleGIL) #16
  ret void
}

declare ptr @dictCreate(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleRegisterCoreAPI() #0 {
entry:
  %call = call ptr @dictCreate(ptr noundef @moduleAPIDictType)
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 37), align 8
  %call1 = call ptr @dictCreate(ptr noundef @moduleAPIDictType)
  store ptr %call1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 38), align 8
  %call2 = call i32 @moduleRegisterApi(ptr noundef @.str.170, ptr noundef @RM_Alloc)
  %call3 = call i32 @moduleRegisterApi(ptr noundef @.str.171, ptr noundef @RM_TryAlloc)
  %call4 = call i32 @moduleRegisterApi(ptr noundef @.str.172, ptr noundef @RM_Calloc)
  %call5 = call i32 @moduleRegisterApi(ptr noundef @.str.173, ptr noundef @RM_Realloc)
  %call6 = call i32 @moduleRegisterApi(ptr noundef @.str.174, ptr noundef @RM_Free)
  %call7 = call i32 @moduleRegisterApi(ptr noundef @.str.175, ptr noundef @RM_Strdup)
  %call8 = call i32 @moduleRegisterApi(ptr noundef @.str.176, ptr noundef @RM_CreateCommand)
  %call9 = call i32 @moduleRegisterApi(ptr noundef @.str.177, ptr noundef @RM_GetCommand)
  %call10 = call i32 @moduleRegisterApi(ptr noundef @.str.178, ptr noundef @RM_CreateSubcommand)
  %call11 = call i32 @moduleRegisterApi(ptr noundef @.str.179, ptr noundef @RM_SetCommandInfo)
  %call12 = call i32 @moduleRegisterApi(ptr noundef @.str.180, ptr noundef @RM_SetCommandACLCategories)
  %call13 = call i32 @moduleRegisterApi(ptr noundef @.str.181, ptr noundef @RM_AddACLCategory)
  %call14 = call i32 @moduleRegisterApi(ptr noundef @.str.182, ptr noundef @RM_SetModuleAttribs)
  %call15 = call i32 @moduleRegisterApi(ptr noundef @.str.183, ptr noundef @RM_IsModuleNameBusy)
  %call16 = call i32 @moduleRegisterApi(ptr noundef @.str.184, ptr noundef @RM_WrongArity)
  %call17 = call i32 @moduleRegisterApi(ptr noundef @.str.185, ptr noundef @RM_ReplyWithLongLong)
  %call18 = call i32 @moduleRegisterApi(ptr noundef @.str.186, ptr noundef @RM_ReplyWithError)
  %call19 = call i32 @moduleRegisterApi(ptr noundef @.str.187, ptr noundef @RM_ReplyWithErrorFormat)
  %call20 = call i32 @moduleRegisterApi(ptr noundef @.str.188, ptr noundef @RM_ReplyWithSimpleString)
  %call21 = call i32 @moduleRegisterApi(ptr noundef @.str.189, ptr noundef @RM_ReplyWithArray)
  %call22 = call i32 @moduleRegisterApi(ptr noundef @.str.190, ptr noundef @RM_ReplyWithMap)
  %call23 = call i32 @moduleRegisterApi(ptr noundef @.str.191, ptr noundef @RM_ReplyWithSet)
  %call24 = call i32 @moduleRegisterApi(ptr noundef @.str.192, ptr noundef @RM_ReplyWithAttribute)
  %call25 = call i32 @moduleRegisterApi(ptr noundef @.str.193, ptr noundef @RM_ReplyWithNullArray)
  %call26 = call i32 @moduleRegisterApi(ptr noundef @.str.194, ptr noundef @RM_ReplyWithEmptyArray)
  %call27 = call i32 @moduleRegisterApi(ptr noundef @.str.195, ptr noundef @RM_ReplySetArrayLength)
  %call28 = call i32 @moduleRegisterApi(ptr noundef @.str.196, ptr noundef @RM_ReplySetMapLength)
  %call29 = call i32 @moduleRegisterApi(ptr noundef @.str.197, ptr noundef @RM_ReplySetSetLength)
  %call30 = call i32 @moduleRegisterApi(ptr noundef @.str.198, ptr noundef @RM_ReplySetAttributeLength)
  %call31 = call i32 @moduleRegisterApi(ptr noundef @.str.199, ptr noundef @RM_ReplyWithString)
  %call32 = call i32 @moduleRegisterApi(ptr noundef @.str.200, ptr noundef @RM_ReplyWithEmptyString)
  %call33 = call i32 @moduleRegisterApi(ptr noundef @.str.201, ptr noundef @RM_ReplyWithVerbatimString)
  %call34 = call i32 @moduleRegisterApi(ptr noundef @.str.202, ptr noundef @RM_ReplyWithVerbatimStringType)
  %call35 = call i32 @moduleRegisterApi(ptr noundef @.str.203, ptr noundef @RM_ReplyWithStringBuffer)
  %call36 = call i32 @moduleRegisterApi(ptr noundef @.str.204, ptr noundef @RM_ReplyWithCString)
  %call37 = call i32 @moduleRegisterApi(ptr noundef @.str.205, ptr noundef @RM_ReplyWithNull)
  %call38 = call i32 @moduleRegisterApi(ptr noundef @.str.206, ptr noundef @RM_ReplyWithBool)
  %call39 = call i32 @moduleRegisterApi(ptr noundef @.str.207, ptr noundef @RM_ReplyWithCallReply)
  %call40 = call i32 @moduleRegisterApi(ptr noundef @.str.208, ptr noundef @RM_ReplyWithDouble)
  %call41 = call i32 @moduleRegisterApi(ptr noundef @.str.209, ptr noundef @RM_ReplyWithBigNumber)
  %call42 = call i32 @moduleRegisterApi(ptr noundef @.str.210, ptr noundef @RM_ReplyWithLongDouble)
  %call43 = call i32 @moduleRegisterApi(ptr noundef @.str.211, ptr noundef @RM_GetSelectedDb)
  %call44 = call i32 @moduleRegisterApi(ptr noundef @.str.212, ptr noundef @RM_SelectDb)
  %call45 = call i32 @moduleRegisterApi(ptr noundef @.str.213, ptr noundef @RM_KeyExists)
  %call46 = call i32 @moduleRegisterApi(ptr noundef @.str.214, ptr noundef @RM_OpenKey)
  %call47 = call i32 @moduleRegisterApi(ptr noundef @.str.215, ptr noundef @RM_GetOpenKeyModesAll)
  %call48 = call i32 @moduleRegisterApi(ptr noundef @.str.216, ptr noundef @RM_CloseKey)
  %call49 = call i32 @moduleRegisterApi(ptr noundef @.str.217, ptr noundef @RM_KeyType)
  %call50 = call i32 @moduleRegisterApi(ptr noundef @.str.218, ptr noundef @RM_ValueLength)
  %call51 = call i32 @moduleRegisterApi(ptr noundef @.str.219, ptr noundef @RM_ListPush)
  %call52 = call i32 @moduleRegisterApi(ptr noundef @.str.220, ptr noundef @RM_ListPop)
  %call53 = call i32 @moduleRegisterApi(ptr noundef @.str.221, ptr noundef @RM_ListGet)
  %call54 = call i32 @moduleRegisterApi(ptr noundef @.str.222, ptr noundef @RM_ListSet)
  %call55 = call i32 @moduleRegisterApi(ptr noundef @.str.223, ptr noundef @RM_ListInsert)
  %call56 = call i32 @moduleRegisterApi(ptr noundef @.str.224, ptr noundef @RM_ListDelete)
  %call57 = call i32 @moduleRegisterApi(ptr noundef @.str.225, ptr noundef @RM_StringToLongLong)
  %call58 = call i32 @moduleRegisterApi(ptr noundef @.str.226, ptr noundef @RM_StringToULongLong)
  %call59 = call i32 @moduleRegisterApi(ptr noundef @.str.227, ptr noundef @RM_StringToDouble)
  %call60 = call i32 @moduleRegisterApi(ptr noundef @.str.228, ptr noundef @RM_StringToLongDouble)
  %call61 = call i32 @moduleRegisterApi(ptr noundef @.str.229, ptr noundef @RM_StringToStreamID)
  %call62 = call i32 @moduleRegisterApi(ptr noundef @.str.230, ptr noundef @RM_Call)
  %call63 = call i32 @moduleRegisterApi(ptr noundef @.str.231, ptr noundef @RM_CallReplyProto)
  %call64 = call i32 @moduleRegisterApi(ptr noundef @.str.232, ptr noundef @RM_FreeCallReply)
  %call65 = call i32 @moduleRegisterApi(ptr noundef @.str.233, ptr noundef @RM_CallReplyInteger)
  %call66 = call i32 @moduleRegisterApi(ptr noundef @.str.234, ptr noundef @RM_CallReplyDouble)
  %call67 = call i32 @moduleRegisterApi(ptr noundef @.str.235, ptr noundef @RM_CallReplyBigNumber)
  %call68 = call i32 @moduleRegisterApi(ptr noundef @.str.236, ptr noundef @RM_CallReplyVerbatim)
  %call69 = call i32 @moduleRegisterApi(ptr noundef @.str.237, ptr noundef @RM_CallReplyBool)
  %call70 = call i32 @moduleRegisterApi(ptr noundef @.str.238, ptr noundef @RM_CallReplySetElement)
  %call71 = call i32 @moduleRegisterApi(ptr noundef @.str.239, ptr noundef @RM_CallReplyMapElement)
  %call72 = call i32 @moduleRegisterApi(ptr noundef @.str.240, ptr noundef @RM_CallReplyAttributeElement)
  %call73 = call i32 @moduleRegisterApi(ptr noundef @.str.241, ptr noundef @RM_CallReplyPromiseSetUnblockHandler)
  %call74 = call i32 @moduleRegisterApi(ptr noundef @.str.242, ptr noundef @RM_CallReplyPromiseAbort)
  %call75 = call i32 @moduleRegisterApi(ptr noundef @.str.243, ptr noundef @RM_CallReplyAttribute)
  %call76 = call i32 @moduleRegisterApi(ptr noundef @.str.244, ptr noundef @RM_CallReplyType)
  %call77 = call i32 @moduleRegisterApi(ptr noundef @.str.245, ptr noundef @RM_CallReplyLength)
  %call78 = call i32 @moduleRegisterApi(ptr noundef @.str.246, ptr noundef @RM_CallReplyArrayElement)
  %call79 = call i32 @moduleRegisterApi(ptr noundef @.str.247, ptr noundef @RM_CallReplyStringPtr)
  %call80 = call i32 @moduleRegisterApi(ptr noundef @.str.248, ptr noundef @RM_CreateStringFromCallReply)
  %call81 = call i32 @moduleRegisterApi(ptr noundef @.str.249, ptr noundef @RM_CreateString)
  %call82 = call i32 @moduleRegisterApi(ptr noundef @.str.250, ptr noundef @RM_CreateStringFromLongLong)
  %call83 = call i32 @moduleRegisterApi(ptr noundef @.str.251, ptr noundef @RM_CreateStringFromULongLong)
  %call84 = call i32 @moduleRegisterApi(ptr noundef @.str.252, ptr noundef @RM_CreateStringFromDouble)
  %call85 = call i32 @moduleRegisterApi(ptr noundef @.str.253, ptr noundef @RM_CreateStringFromLongDouble)
  %call86 = call i32 @moduleRegisterApi(ptr noundef @.str.254, ptr noundef @RM_CreateStringFromString)
  %call87 = call i32 @moduleRegisterApi(ptr noundef @.str.255, ptr noundef @RM_CreateStringFromStreamID)
  %call88 = call i32 @moduleRegisterApi(ptr noundef @.str.256, ptr noundef @RM_CreateStringPrintf)
  %call89 = call i32 @moduleRegisterApi(ptr noundef @.str.257, ptr noundef @RM_FreeString)
  %call90 = call i32 @moduleRegisterApi(ptr noundef @.str.258, ptr noundef @RM_StringPtrLen)
  %call91 = call i32 @moduleRegisterApi(ptr noundef @.str.259, ptr noundef @RM_AutoMemory)
  %call92 = call i32 @moduleRegisterApi(ptr noundef @.str.260, ptr noundef @RM_Replicate)
  %call93 = call i32 @moduleRegisterApi(ptr noundef @.str.261, ptr noundef @RM_ReplicateVerbatim)
  %call94 = call i32 @moduleRegisterApi(ptr noundef @.str.262, ptr noundef @RM_DeleteKey)
  %call95 = call i32 @moduleRegisterApi(ptr noundef @.str.263, ptr noundef @RM_UnlinkKey)
  %call96 = call i32 @moduleRegisterApi(ptr noundef @.str.264, ptr noundef @RM_StringSet)
  %call97 = call i32 @moduleRegisterApi(ptr noundef @.str.265, ptr noundef @RM_StringDMA)
  %call98 = call i32 @moduleRegisterApi(ptr noundef @.str.266, ptr noundef @RM_StringTruncate)
  %call99 = call i32 @moduleRegisterApi(ptr noundef @.str.267, ptr noundef @RM_SetExpire)
  %call100 = call i32 @moduleRegisterApi(ptr noundef @.str.268, ptr noundef @RM_GetExpire)
  %call101 = call i32 @moduleRegisterApi(ptr noundef @.str.269, ptr noundef @RM_SetAbsExpire)
  %call102 = call i32 @moduleRegisterApi(ptr noundef @.str.270, ptr noundef @RM_GetAbsExpire)
  %call103 = call i32 @moduleRegisterApi(ptr noundef @.str.271, ptr noundef @RM_ResetDataset)
  %call104 = call i32 @moduleRegisterApi(ptr noundef @.str.272, ptr noundef @RM_DbSize)
  %call105 = call i32 @moduleRegisterApi(ptr noundef @.str.273, ptr noundef @RM_RandomKey)
  %call106 = call i32 @moduleRegisterApi(ptr noundef @.str.274, ptr noundef @RM_ZsetAdd)
  %call107 = call i32 @moduleRegisterApi(ptr noundef @.str.275, ptr noundef @RM_ZsetIncrby)
  %call108 = call i32 @moduleRegisterApi(ptr noundef @.str.276, ptr noundef @RM_ZsetScore)
  %call109 = call i32 @moduleRegisterApi(ptr noundef @.str.277, ptr noundef @RM_ZsetRem)
  %call110 = call i32 @moduleRegisterApi(ptr noundef @.str.278, ptr noundef @RM_ZsetRangeStop)
  %call111 = call i32 @moduleRegisterApi(ptr noundef @.str.279, ptr noundef @RM_ZsetFirstInScoreRange)
  %call112 = call i32 @moduleRegisterApi(ptr noundef @.str.280, ptr noundef @RM_ZsetLastInScoreRange)
  %call113 = call i32 @moduleRegisterApi(ptr noundef @.str.281, ptr noundef @RM_ZsetFirstInLexRange)
  %call114 = call i32 @moduleRegisterApi(ptr noundef @.str.282, ptr noundef @RM_ZsetLastInLexRange)
  %call115 = call i32 @moduleRegisterApi(ptr noundef @.str.283, ptr noundef @RM_ZsetRangeCurrentElement)
  %call116 = call i32 @moduleRegisterApi(ptr noundef @.str.284, ptr noundef @RM_ZsetRangeNext)
  %call117 = call i32 @moduleRegisterApi(ptr noundef @.str.285, ptr noundef @RM_ZsetRangePrev)
  %call118 = call i32 @moduleRegisterApi(ptr noundef @.str.286, ptr noundef @RM_ZsetRangeEndReached)
  %call119 = call i32 @moduleRegisterApi(ptr noundef @.str.287, ptr noundef @RM_HashSet)
  %call120 = call i32 @moduleRegisterApi(ptr noundef @.str.288, ptr noundef @RM_HashGet)
  %call121 = call i32 @moduleRegisterApi(ptr noundef @.str.289, ptr noundef @RM_StreamAdd)
  %call122 = call i32 @moduleRegisterApi(ptr noundef @.str.290, ptr noundef @RM_StreamDelete)
  %call123 = call i32 @moduleRegisterApi(ptr noundef @.str.291, ptr noundef @RM_StreamIteratorStart)
  %call124 = call i32 @moduleRegisterApi(ptr noundef @.str.292, ptr noundef @RM_StreamIteratorStop)
  %call125 = call i32 @moduleRegisterApi(ptr noundef @.str.293, ptr noundef @RM_StreamIteratorNextID)
  %call126 = call i32 @moduleRegisterApi(ptr noundef @.str.294, ptr noundef @RM_StreamIteratorNextField)
  %call127 = call i32 @moduleRegisterApi(ptr noundef @.str.295, ptr noundef @RM_StreamIteratorDelete)
  %call128 = call i32 @moduleRegisterApi(ptr noundef @.str.296, ptr noundef @RM_StreamTrimByLength)
  %call129 = call i32 @moduleRegisterApi(ptr noundef @.str.297, ptr noundef @RM_StreamTrimByID)
  %call130 = call i32 @moduleRegisterApi(ptr noundef @.str.298, ptr noundef @RM_IsKeysPositionRequest)
  %call131 = call i32 @moduleRegisterApi(ptr noundef @.str.299, ptr noundef @RM_KeyAtPos)
  %call132 = call i32 @moduleRegisterApi(ptr noundef @.str.300, ptr noundef @RM_KeyAtPosWithFlags)
  %call133 = call i32 @moduleRegisterApi(ptr noundef @.str.301, ptr noundef @RM_IsChannelsPositionRequest)
  %call134 = call i32 @moduleRegisterApi(ptr noundef @.str.302, ptr noundef @RM_ChannelAtPosWithFlags)
  %call135 = call i32 @moduleRegisterApi(ptr noundef @.str.303, ptr noundef @RM_GetClientId)
  %call136 = call i32 @moduleRegisterApi(ptr noundef @.str.304, ptr noundef @RM_GetClientUserNameById)
  %call137 = call i32 @moduleRegisterApi(ptr noundef @.str.305, ptr noundef @RM_GetContextFlags)
  %call138 = call i32 @moduleRegisterApi(ptr noundef @.str.306, ptr noundef @RM_AvoidReplicaTraffic)
  %call139 = call i32 @moduleRegisterApi(ptr noundef @.str.307, ptr noundef @RM_PoolAlloc)
  %call140 = call i32 @moduleRegisterApi(ptr noundef @.str.308, ptr noundef @RM_CreateDataType)
  %call141 = call i32 @moduleRegisterApi(ptr noundef @.str.309, ptr noundef @RM_ModuleTypeSetValue)
  %call142 = call i32 @moduleRegisterApi(ptr noundef @.str.310, ptr noundef @RM_ModuleTypeReplaceValue)
  %call143 = call i32 @moduleRegisterApi(ptr noundef @.str.311, ptr noundef @RM_ModuleTypeGetType)
  %call144 = call i32 @moduleRegisterApi(ptr noundef @.str.312, ptr noundef @RM_ModuleTypeGetValue)
  %call145 = call i32 @moduleRegisterApi(ptr noundef @.str.313, ptr noundef @RM_IsIOError)
  %call146 = call i32 @moduleRegisterApi(ptr noundef @.str.314, ptr noundef @RM_SetModuleOptions)
  %call147 = call i32 @moduleRegisterApi(ptr noundef @.str.315, ptr noundef @RM_SignalModifiedKey)
  %call148 = call i32 @moduleRegisterApi(ptr noundef @.str.316, ptr noundef @RM_SaveUnsigned)
  %call149 = call i32 @moduleRegisterApi(ptr noundef @.str.317, ptr noundef @RM_LoadUnsigned)
  %call150 = call i32 @moduleRegisterApi(ptr noundef @.str.318, ptr noundef @RM_SaveSigned)
  %call151 = call i32 @moduleRegisterApi(ptr noundef @.str.319, ptr noundef @RM_LoadSigned)
  %call152 = call i32 @moduleRegisterApi(ptr noundef @.str.320, ptr noundef @RM_SaveString)
  %call153 = call i32 @moduleRegisterApi(ptr noundef @.str.321, ptr noundef @RM_SaveStringBuffer)
  %call154 = call i32 @moduleRegisterApi(ptr noundef @.str.322, ptr noundef @RM_LoadString)
  %call155 = call i32 @moduleRegisterApi(ptr noundef @.str.323, ptr noundef @RM_LoadStringBuffer)
  %call156 = call i32 @moduleRegisterApi(ptr noundef @.str.324, ptr noundef @RM_SaveDouble)
  %call157 = call i32 @moduleRegisterApi(ptr noundef @.str.325, ptr noundef @RM_LoadDouble)
  %call158 = call i32 @moduleRegisterApi(ptr noundef @.str.326, ptr noundef @RM_SaveFloat)
  %call159 = call i32 @moduleRegisterApi(ptr noundef @.str.327, ptr noundef @RM_LoadFloat)
  %call160 = call i32 @moduleRegisterApi(ptr noundef @.str.328, ptr noundef @RM_SaveLongDouble)
  %call161 = call i32 @moduleRegisterApi(ptr noundef @.str.329, ptr noundef @RM_LoadLongDouble)
  %call162 = call i32 @moduleRegisterApi(ptr noundef @.str.330, ptr noundef @RM_SaveDataTypeToString)
  %call163 = call i32 @moduleRegisterApi(ptr noundef @.str.331, ptr noundef @RM_LoadDataTypeFromString)
  %call164 = call i32 @moduleRegisterApi(ptr noundef @.str.332, ptr noundef @RM_LoadDataTypeFromStringEncver)
  %call165 = call i32 @moduleRegisterApi(ptr noundef @.str.333, ptr noundef @RM_EmitAOF)
  %call166 = call i32 @moduleRegisterApi(ptr noundef @.str.334, ptr noundef @RM_Log)
  %call167 = call i32 @moduleRegisterApi(ptr noundef @.str.335, ptr noundef @RM_LogIOError)
  %call168 = call i32 @moduleRegisterApi(ptr noundef @.str.336, ptr noundef @RM__Assert)
  %call169 = call i32 @moduleRegisterApi(ptr noundef @.str.337, ptr noundef @RM_LatencyAddSample)
  %call170 = call i32 @moduleRegisterApi(ptr noundef @.str.338, ptr noundef @RM_StringAppendBuffer)
  %call171 = call i32 @moduleRegisterApi(ptr noundef @.str.339, ptr noundef @RM_TrimStringAllocation)
  %call172 = call i32 @moduleRegisterApi(ptr noundef @.str.340, ptr noundef @RM_RetainString)
  %call173 = call i32 @moduleRegisterApi(ptr noundef @.str.341, ptr noundef @RM_HoldString)
  %call174 = call i32 @moduleRegisterApi(ptr noundef @.str.342, ptr noundef @RM_StringCompare)
  %call175 = call i32 @moduleRegisterApi(ptr noundef @.str.343, ptr noundef @RM_GetContextFromIO)
  %call176 = call i32 @moduleRegisterApi(ptr noundef @.str.344, ptr noundef @RM_GetKeyNameFromIO)
  %call177 = call i32 @moduleRegisterApi(ptr noundef @.str.345, ptr noundef @RM_GetKeyNameFromModuleKey)
  %call178 = call i32 @moduleRegisterApi(ptr noundef @.str.346, ptr noundef @RM_GetDbIdFromModuleKey)
  %call179 = call i32 @moduleRegisterApi(ptr noundef @.str.347, ptr noundef @RM_GetDbIdFromIO)
  %call180 = call i32 @moduleRegisterApi(ptr noundef @.str.348, ptr noundef @RM_GetKeyNameFromOptCtx)
  %call181 = call i32 @moduleRegisterApi(ptr noundef @.str.349, ptr noundef @RM_GetToKeyNameFromOptCtx)
  %call182 = call i32 @moduleRegisterApi(ptr noundef @.str.350, ptr noundef @RM_GetDbIdFromOptCtx)
  %call183 = call i32 @moduleRegisterApi(ptr noundef @.str.351, ptr noundef @RM_GetToDbIdFromOptCtx)
  %call184 = call i32 @moduleRegisterApi(ptr noundef @.str.352, ptr noundef @RM_GetKeyNameFromDefragCtx)
  %call185 = call i32 @moduleRegisterApi(ptr noundef @.str.353, ptr noundef @RM_GetDbIdFromDefragCtx)
  %call186 = call i32 @moduleRegisterApi(ptr noundef @.str.354, ptr noundef @RM_GetKeyNameFromDigest)
  %call187 = call i32 @moduleRegisterApi(ptr noundef @.str.355, ptr noundef @RM_GetDbIdFromDigest)
  %call188 = call i32 @moduleRegisterApi(ptr noundef @.str.356, ptr noundef @RM_BlockClient)
  %call189 = call i32 @moduleRegisterApi(ptr noundef @.str.357, ptr noundef @RM_BlockClientGetPrivateData)
  %call190 = call i32 @moduleRegisterApi(ptr noundef @.str.358, ptr noundef @RM_BlockClientSetPrivateData)
  %call191 = call i32 @moduleRegisterApi(ptr noundef @.str.359, ptr noundef @RM_BlockClientOnAuth)
  %call192 = call i32 @moduleRegisterApi(ptr noundef @.str.360, ptr noundef @RM_UnblockClient)
  %call193 = call i32 @moduleRegisterApi(ptr noundef @.str.361, ptr noundef @RM_IsBlockedReplyRequest)
  %call194 = call i32 @moduleRegisterApi(ptr noundef @.str.362, ptr noundef @RM_IsBlockedTimeoutRequest)
  %call195 = call i32 @moduleRegisterApi(ptr noundef @.str.363, ptr noundef @RM_GetBlockedClientPrivateData)
  %call196 = call i32 @moduleRegisterApi(ptr noundef @.str.364, ptr noundef @RM_AbortBlock)
  %call197 = call i32 @moduleRegisterApi(ptr noundef @.str.365, ptr noundef @RM_Milliseconds)
  %call198 = call i32 @moduleRegisterApi(ptr noundef @.str.366, ptr noundef @RM_MonotonicMicroseconds)
  %call199 = call i32 @moduleRegisterApi(ptr noundef @.str.367, ptr noundef @RM_Microseconds)
  %call200 = call i32 @moduleRegisterApi(ptr noundef @.str.368, ptr noundef @RM_CachedMicroseconds)
  %call201 = call i32 @moduleRegisterApi(ptr noundef @.str.369, ptr noundef @RM_BlockedClientMeasureTimeStart)
  %call202 = call i32 @moduleRegisterApi(ptr noundef @.str.370, ptr noundef @RM_BlockedClientMeasureTimeEnd)
  %call203 = call i32 @moduleRegisterApi(ptr noundef @.str.371, ptr noundef @RM_GetThreadSafeContext)
  %call204 = call i32 @moduleRegisterApi(ptr noundef @.str.372, ptr noundef @RM_GetDetachedThreadSafeContext)
  %call205 = call i32 @moduleRegisterApi(ptr noundef @.str.373, ptr noundef @RM_FreeThreadSafeContext)
  %call206 = call i32 @moduleRegisterApi(ptr noundef @.str.374, ptr noundef @RM_ThreadSafeContextLock)
  %call207 = call i32 @moduleRegisterApi(ptr noundef @.str.375, ptr noundef @RM_ThreadSafeContextTryLock)
  %call208 = call i32 @moduleRegisterApi(ptr noundef @.str.376, ptr noundef @RM_ThreadSafeContextUnlock)
  %call209 = call i32 @moduleRegisterApi(ptr noundef @.str.377, ptr noundef @RM_DigestAddStringBuffer)
  %call210 = call i32 @moduleRegisterApi(ptr noundef @.str.378, ptr noundef @RM_DigestAddLongLong)
  %call211 = call i32 @moduleRegisterApi(ptr noundef @.str.379, ptr noundef @RM_DigestEndSequence)
  %call212 = call i32 @moduleRegisterApi(ptr noundef @.str.380, ptr noundef @RM_NotifyKeyspaceEvent)
  %call213 = call i32 @moduleRegisterApi(ptr noundef @.str.381, ptr noundef @RM_GetNotifyKeyspaceEvents)
  %call214 = call i32 @moduleRegisterApi(ptr noundef @.str.382, ptr noundef @RM_SubscribeToKeyspaceEvents)
  %call215 = call i32 @moduleRegisterApi(ptr noundef @.str.383, ptr noundef @RM_AddPostNotificationJob)
  %call216 = call i32 @moduleRegisterApi(ptr noundef @.str.384, ptr noundef @RM_RegisterClusterMessageReceiver)
  %call217 = call i32 @moduleRegisterApi(ptr noundef @.str.385, ptr noundef @RM_SendClusterMessage)
  %call218 = call i32 @moduleRegisterApi(ptr noundef @.str.386, ptr noundef @RM_GetClusterNodeInfo)
  %call219 = call i32 @moduleRegisterApi(ptr noundef @.str.387, ptr noundef @RM_GetClusterNodesList)
  %call220 = call i32 @moduleRegisterApi(ptr noundef @.str.388, ptr noundef @RM_FreeClusterNodesList)
  %call221 = call i32 @moduleRegisterApi(ptr noundef @.str.389, ptr noundef @RM_CreateTimer)
  %call222 = call i32 @moduleRegisterApi(ptr noundef @.str.390, ptr noundef @RM_StopTimer)
  %call223 = call i32 @moduleRegisterApi(ptr noundef @.str.391, ptr noundef @RM_GetTimerInfo)
  %call224 = call i32 @moduleRegisterApi(ptr noundef @.str.392, ptr noundef @RM_GetMyClusterID)
  %call225 = call i32 @moduleRegisterApi(ptr noundef @.str.393, ptr noundef @RM_GetClusterSize)
  %call226 = call i32 @moduleRegisterApi(ptr noundef @.str.394, ptr noundef @RM_GetRandomBytes)
  %call227 = call i32 @moduleRegisterApi(ptr noundef @.str.395, ptr noundef @RM_GetRandomHexChars)
  %call228 = call i32 @moduleRegisterApi(ptr noundef @.str.396, ptr noundef @RM_BlockedClientDisconnected)
  %call229 = call i32 @moduleRegisterApi(ptr noundef @.str.397, ptr noundef @RM_SetDisconnectCallback)
  %call230 = call i32 @moduleRegisterApi(ptr noundef @.str.398, ptr noundef @RM_GetBlockedClientHandle)
  %call231 = call i32 @moduleRegisterApi(ptr noundef @.str.399, ptr noundef @RM_SetClusterFlags)
  %call232 = call i32 @moduleRegisterApi(ptr noundef @.str.400, ptr noundef @RM_CreateDict)
  %call233 = call i32 @moduleRegisterApi(ptr noundef @.str.401, ptr noundef @RM_FreeDict)
  %call234 = call i32 @moduleRegisterApi(ptr noundef @.str.402, ptr noundef @RM_DictSize)
  %call235 = call i32 @moduleRegisterApi(ptr noundef @.str.403, ptr noundef @RM_DictSetC)
  %call236 = call i32 @moduleRegisterApi(ptr noundef @.str.404, ptr noundef @RM_DictReplaceC)
  %call237 = call i32 @moduleRegisterApi(ptr noundef @.str.405, ptr noundef @RM_DictSet)
  %call238 = call i32 @moduleRegisterApi(ptr noundef @.str.406, ptr noundef @RM_DictReplace)
  %call239 = call i32 @moduleRegisterApi(ptr noundef @.str.407, ptr noundef @RM_DictGetC)
  %call240 = call i32 @moduleRegisterApi(ptr noundef @.str.408, ptr noundef @RM_DictGet)
  %call241 = call i32 @moduleRegisterApi(ptr noundef @.str.409, ptr noundef @RM_DictDelC)
  %call242 = call i32 @moduleRegisterApi(ptr noundef @.str.410, ptr noundef @RM_DictDel)
  %call243 = call i32 @moduleRegisterApi(ptr noundef @.str.411, ptr noundef @RM_DictIteratorStartC)
  %call244 = call i32 @moduleRegisterApi(ptr noundef @.str.412, ptr noundef @RM_DictIteratorStart)
  %call245 = call i32 @moduleRegisterApi(ptr noundef @.str.413, ptr noundef @RM_DictIteratorStop)
  %call246 = call i32 @moduleRegisterApi(ptr noundef @.str.414, ptr noundef @RM_DictIteratorReseekC)
  %call247 = call i32 @moduleRegisterApi(ptr noundef @.str.415, ptr noundef @RM_DictIteratorReseek)
  %call248 = call i32 @moduleRegisterApi(ptr noundef @.str.416, ptr noundef @RM_DictNextC)
  %call249 = call i32 @moduleRegisterApi(ptr noundef @.str.417, ptr noundef @RM_DictPrevC)
  %call250 = call i32 @moduleRegisterApi(ptr noundef @.str.418, ptr noundef @RM_DictNext)
  %call251 = call i32 @moduleRegisterApi(ptr noundef @.str.419, ptr noundef @RM_DictPrev)
  %call252 = call i32 @moduleRegisterApi(ptr noundef @.str.420, ptr noundef @RM_DictCompareC)
  %call253 = call i32 @moduleRegisterApi(ptr noundef @.str.421, ptr noundef @RM_DictCompare)
  %call254 = call i32 @moduleRegisterApi(ptr noundef @.str.422, ptr noundef @RM_ExportSharedAPI)
  %call255 = call i32 @moduleRegisterApi(ptr noundef @.str.423, ptr noundef @RM_GetSharedAPI)
  %call256 = call i32 @moduleRegisterApi(ptr noundef @.str.424, ptr noundef @RM_RegisterCommandFilter)
  %call257 = call i32 @moduleRegisterApi(ptr noundef @.str.425, ptr noundef @RM_UnregisterCommandFilter)
  %call258 = call i32 @moduleRegisterApi(ptr noundef @.str.426, ptr noundef @RM_CommandFilterArgsCount)
  %call259 = call i32 @moduleRegisterApi(ptr noundef @.str.427, ptr noundef @RM_CommandFilterArgGet)
  %call260 = call i32 @moduleRegisterApi(ptr noundef @.str.428, ptr noundef @RM_CommandFilterArgInsert)
  %call261 = call i32 @moduleRegisterApi(ptr noundef @.str.429, ptr noundef @RM_CommandFilterArgReplace)
  %call262 = call i32 @moduleRegisterApi(ptr noundef @.str.430, ptr noundef @RM_CommandFilterArgDelete)
  %call263 = call i32 @moduleRegisterApi(ptr noundef @.str.431, ptr noundef @RM_CommandFilterGetClientId)
  %call264 = call i32 @moduleRegisterApi(ptr noundef @.str.432, ptr noundef @RM_Fork)
  %call265 = call i32 @moduleRegisterApi(ptr noundef @.str.433, ptr noundef @RM_SendChildHeartbeat)
  %call266 = call i32 @moduleRegisterApi(ptr noundef @.str.434, ptr noundef @RM_ExitFromChild)
  %call267 = call i32 @moduleRegisterApi(ptr noundef @.str.435, ptr noundef @RM_KillForkChild)
  %call268 = call i32 @moduleRegisterApi(ptr noundef @.str.436, ptr noundef @RM_RegisterInfoFunc)
  %call269 = call i32 @moduleRegisterApi(ptr noundef @.str.437, ptr noundef @RM_InfoAddSection)
  %call270 = call i32 @moduleRegisterApi(ptr noundef @.str.438, ptr noundef @RM_InfoBeginDictField)
  %call271 = call i32 @moduleRegisterApi(ptr noundef @.str.439, ptr noundef @RM_InfoEndDictField)
  %call272 = call i32 @moduleRegisterApi(ptr noundef @.str.440, ptr noundef @RM_InfoAddFieldString)
  %call273 = call i32 @moduleRegisterApi(ptr noundef @.str.441, ptr noundef @RM_InfoAddFieldCString)
  %call274 = call i32 @moduleRegisterApi(ptr noundef @.str.442, ptr noundef @RM_InfoAddFieldDouble)
  %call275 = call i32 @moduleRegisterApi(ptr noundef @.str.443, ptr noundef @RM_InfoAddFieldLongLong)
  %call276 = call i32 @moduleRegisterApi(ptr noundef @.str.444, ptr noundef @RM_InfoAddFieldULongLong)
  %call277 = call i32 @moduleRegisterApi(ptr noundef @.str.445, ptr noundef @RM_GetServerInfo)
  %call278 = call i32 @moduleRegisterApi(ptr noundef @.str.446, ptr noundef @RM_FreeServerInfo)
  %call279 = call i32 @moduleRegisterApi(ptr noundef @.str.447, ptr noundef @RM_ServerInfoGetField)
  %call280 = call i32 @moduleRegisterApi(ptr noundef @.str.448, ptr noundef @RM_ServerInfoGetFieldC)
  %call281 = call i32 @moduleRegisterApi(ptr noundef @.str.449, ptr noundef @RM_ServerInfoGetFieldSigned)
  %call282 = call i32 @moduleRegisterApi(ptr noundef @.str.450, ptr noundef @RM_ServerInfoGetFieldUnsigned)
  %call283 = call i32 @moduleRegisterApi(ptr noundef @.str.451, ptr noundef @RM_ServerInfoGetFieldDouble)
  %call284 = call i32 @moduleRegisterApi(ptr noundef @.str.452, ptr noundef @RM_GetClientInfoById)
  %call285 = call i32 @moduleRegisterApi(ptr noundef @.str.453, ptr noundef @RM_GetClientNameById)
  %call286 = call i32 @moduleRegisterApi(ptr noundef @.str.454, ptr noundef @RM_SetClientNameById)
  %call287 = call i32 @moduleRegisterApi(ptr noundef @.str.455, ptr noundef @RM_PublishMessage)
  %call288 = call i32 @moduleRegisterApi(ptr noundef @.str.456, ptr noundef @RM_PublishMessageShard)
  %call289 = call i32 @moduleRegisterApi(ptr noundef @.str.457, ptr noundef @RM_SubscribeToServerEvent)
  %call290 = call i32 @moduleRegisterApi(ptr noundef @.str.458, ptr noundef @RM_SetLRU)
  %call291 = call i32 @moduleRegisterApi(ptr noundef @.str.459, ptr noundef @RM_GetLRU)
  %call292 = call i32 @moduleRegisterApi(ptr noundef @.str.460, ptr noundef @RM_SetLFU)
  %call293 = call i32 @moduleRegisterApi(ptr noundef @.str.461, ptr noundef @RM_GetLFU)
  %call294 = call i32 @moduleRegisterApi(ptr noundef @.str.462, ptr noundef @RM_BlockClientOnKeys)
  %call295 = call i32 @moduleRegisterApi(ptr noundef @.str.463, ptr noundef @RM_BlockClientOnKeysWithFlags)
  %call296 = call i32 @moduleRegisterApi(ptr noundef @.str.464, ptr noundef @RM_SignalKeyAsReady)
  %call297 = call i32 @moduleRegisterApi(ptr noundef @.str.465, ptr noundef @RM_GetBlockedClientReadyKey)
  %call298 = call i32 @moduleRegisterApi(ptr noundef @.str.466, ptr noundef @RM_GetUsedMemoryRatio)
  %call299 = call i32 @moduleRegisterApi(ptr noundef @.str.467, ptr noundef @RM_MallocSize)
  %call300 = call i32 @moduleRegisterApi(ptr noundef @.str.468, ptr noundef @RM_MallocUsableSize)
  %call301 = call i32 @moduleRegisterApi(ptr noundef @.str.469, ptr noundef @RM_MallocSizeString)
  %call302 = call i32 @moduleRegisterApi(ptr noundef @.str.470, ptr noundef @RM_MallocSizeDict)
  %call303 = call i32 @moduleRegisterApi(ptr noundef @.str.471, ptr noundef @RM_ScanCursorCreate)
  %call304 = call i32 @moduleRegisterApi(ptr noundef @.str.472, ptr noundef @RM_ScanCursorDestroy)
  %call305 = call i32 @moduleRegisterApi(ptr noundef @.str.473, ptr noundef @RM_ScanCursorRestart)
  %call306 = call i32 @moduleRegisterApi(ptr noundef @.str.474, ptr noundef @RM_Scan)
  %call307 = call i32 @moduleRegisterApi(ptr noundef @.str.475, ptr noundef @RM_ScanKey)
  %call308 = call i32 @moduleRegisterApi(ptr noundef @.str.476, ptr noundef @RM_CreateModuleUser)
  %call309 = call i32 @moduleRegisterApi(ptr noundef @.str.477, ptr noundef @RM_SetContextUser)
  %call310 = call i32 @moduleRegisterApi(ptr noundef @.str.478, ptr noundef @RM_SetModuleUserACL)
  %call311 = call i32 @moduleRegisterApi(ptr noundef @.str.479, ptr noundef @RM_SetModuleUserACLString)
  %call312 = call i32 @moduleRegisterApi(ptr noundef @.str.480, ptr noundef @RM_GetModuleUserACLString)
  %call313 = call i32 @moduleRegisterApi(ptr noundef @.str.481, ptr noundef @RM_GetCurrentUserName)
  %call314 = call i32 @moduleRegisterApi(ptr noundef @.str.482, ptr noundef @RM_GetModuleUserFromUserName)
  %call315 = call i32 @moduleRegisterApi(ptr noundef @.str.483, ptr noundef @RM_ACLCheckCommandPermissions)
  %call316 = call i32 @moduleRegisterApi(ptr noundef @.str.484, ptr noundef @RM_ACLCheckKeyPermissions)
  %call317 = call i32 @moduleRegisterApi(ptr noundef @.str.485, ptr noundef @RM_ACLCheckChannelPermissions)
  %call318 = call i32 @moduleRegisterApi(ptr noundef @.str.486, ptr noundef @RM_ACLAddLogEntry)
  %call319 = call i32 @moduleRegisterApi(ptr noundef @.str.487, ptr noundef @RM_ACLAddLogEntryByUserName)
  %call320 = call i32 @moduleRegisterApi(ptr noundef @.str.488, ptr noundef @RM_FreeModuleUser)
  %call321 = call i32 @moduleRegisterApi(ptr noundef @.str.489, ptr noundef @RM_DeauthenticateAndCloseClient)
  %call322 = call i32 @moduleRegisterApi(ptr noundef @.str.490, ptr noundef @RM_AuthenticateClientWithACLUser)
  %call323 = call i32 @moduleRegisterApi(ptr noundef @.str.491, ptr noundef @RM_AuthenticateClientWithUser)
  %call324 = call i32 @moduleRegisterApi(ptr noundef @.str.492, ptr noundef @RM_GetContextFlagsAll)
  %call325 = call i32 @moduleRegisterApi(ptr noundef @.str.493, ptr noundef @RM_GetModuleOptionsAll)
  %call326 = call i32 @moduleRegisterApi(ptr noundef @.str.494, ptr noundef @RM_GetKeyspaceNotificationFlagsAll)
  %call327 = call i32 @moduleRegisterApi(ptr noundef @.str.495, ptr noundef @RM_IsSubEventSupported)
  %call328 = call i32 @moduleRegisterApi(ptr noundef @.str.496, ptr noundef @RM_GetServerVersion)
  %call329 = call i32 @moduleRegisterApi(ptr noundef @.str.497, ptr noundef @RM_GetClientCertificate)
  %call330 = call i32 @moduleRegisterApi(ptr noundef @.str.498, ptr noundef @RM_RedactClientCommandArgument)
  %call331 = call i32 @moduleRegisterApi(ptr noundef @.str.499, ptr noundef @RM_GetCommandKeys)
  %call332 = call i32 @moduleRegisterApi(ptr noundef @.str.500, ptr noundef @RM_GetCommandKeysWithFlags)
  %call333 = call i32 @moduleRegisterApi(ptr noundef @.str.501, ptr noundef @RM_GetCurrentCommandName)
  %call334 = call i32 @moduleRegisterApi(ptr noundef @.str.502, ptr noundef @RM_GetTypeMethodVersion)
  %call335 = call i32 @moduleRegisterApi(ptr noundef @.str.503, ptr noundef @RM_RegisterDefragFunc)
  %call336 = call i32 @moduleRegisterApi(ptr noundef @.str.504, ptr noundef @RM_DefragAlloc)
  %call337 = call i32 @moduleRegisterApi(ptr noundef @.str.505, ptr noundef @RM_DefragRedisModuleString)
  %call338 = call i32 @moduleRegisterApi(ptr noundef @.str.506, ptr noundef @RM_DefragShouldStop)
  %call339 = call i32 @moduleRegisterApi(ptr noundef @.str.507, ptr noundef @RM_DefragCursorSet)
  %call340 = call i32 @moduleRegisterApi(ptr noundef @.str.508, ptr noundef @RM_DefragCursorGet)
  %call341 = call i32 @moduleRegisterApi(ptr noundef @.str.509, ptr noundef @RM_EventLoopAdd)
  %call342 = call i32 @moduleRegisterApi(ptr noundef @.str.510, ptr noundef @RM_EventLoopDel)
  %call343 = call i32 @moduleRegisterApi(ptr noundef @.str.511, ptr noundef @RM_EventLoopAddOneShot)
  %call344 = call i32 @moduleRegisterApi(ptr noundef @.str.512, ptr noundef @RM_Yield)
  %call345 = call i32 @moduleRegisterApi(ptr noundef @.str.513, ptr noundef @RM_RegisterBoolConfig)
  %call346 = call i32 @moduleRegisterApi(ptr noundef @.str.514, ptr noundef @RM_RegisterNumericConfig)
  %call347 = call i32 @moduleRegisterApi(ptr noundef @.str.515, ptr noundef @RM_RegisterStringConfig)
  %call348 = call i32 @moduleRegisterApi(ptr noundef @.str.516, ptr noundef @RM_RegisterEnumConfig)
  %call349 = call i32 @moduleRegisterApi(ptr noundef @.str.517, ptr noundef @RM_LoadConfigs)
  %call350 = call i32 @moduleRegisterApi(ptr noundef @.str.518, ptr noundef @RM_RegisterAuthCallback)
  %call351 = call i32 @moduleRegisterApi(ptr noundef @.str.519, ptr noundef @RM_RdbStreamCreateFromFile)
  %call352 = call i32 @moduleRegisterApi(ptr noundef @.str.520, ptr noundef @RM_RdbStreamFree)
  %call353 = call i32 @moduleRegisterApi(ptr noundef @.str.521, ptr noundef @RM_RdbLoad)
  %call354 = call i32 @moduleRegisterApi(ptr noundef @.str.522, ptr noundef @RM_RdbSave)
  ret void
}

declare i32 @anetPipe(ptr noundef, i32 noundef, i32 noundef) #1

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) #4

; Function Attrs: nounwind uwtable
define dso_local void @modulesCron() #0 {
entry:
  %iteration = alloca i32, align 4
  %min_client = alloca i32, align 4
  %c = alloca ptr, align 8
  store i32 50, ptr %iteration, align 4
  store i32 8, ptr %min_client, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, ptr %iteration, align 4
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %while.cond
  %1 = load i64, ptr @moduleTempClientCount, align 8
  %cmp1 = icmp ugt i64 %1, 0
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %2 = load i64, ptr @moduleTempClientMinCount, align 8
  %cmp2 = icmp ugt i64 %2, 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %while.cond
  %3 = phi i1 [ false, %land.lhs.true ], [ false, %while.cond ], [ %cmp2, %land.rhs ]
  br i1 %3, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %4 = load ptr, ptr @moduleTempClients, align 8
  %5 = load i64, ptr @moduleTempClientCount, align 8
  %dec = add i64 %5, -1
  store i64 %dec, ptr @moduleTempClientCount, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %dec
  %6 = load ptr, ptr %arrayidx, align 8
  store ptr %6, ptr %c, align 8
  %7 = load ptr, ptr %c, align 8
  call void @freeClient(ptr noundef %7)
  %8 = load i32, ptr %iteration, align 4
  %dec3 = add nsw i32 %8, -1
  store i32 %dec3, ptr %iteration, align 4
  %9 = load i64, ptr @moduleTempClientMinCount, align 8
  %dec4 = add i64 %9, -1
  store i64 %dec4, ptr @moduleTempClientMinCount, align 8
  br label %while.cond, !llvm.loop !68

while.end:                                        ; preds = %land.end
  %10 = load i64, ptr @moduleTempClientCount, align 8
  store i64 %10, ptr @moduleTempClientMinCount, align 8
  %11 = load i64, ptr @moduleTempClientCap, align 8
  %cmp5 = icmp ugt i64 %11, 32
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %while.end
  %12 = load i64, ptr @moduleTempClientCap, align 8
  %13 = load i64, ptr @moduleTempClientCount, align 8
  %mul = mul i64 %13, 4
  %cmp7 = icmp ugt i64 %12, %mul
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true6
  %14 = load i64, ptr @moduleTempClientCap, align 8
  %div = udiv i64 %14, 4
  store i64 %div, ptr @moduleTempClientCap, align 8
  %15 = load ptr, ptr @moduleTempClients, align 8
  %16 = load i64, ptr @moduleTempClientCap, align 8
  %mul8 = mul i64 8, %16
  %call = call ptr @zrealloc(ptr noundef %15, i64 noundef %mul8) #12
  store ptr %call, ptr @moduleTempClients, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true6, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleLoadQueueEntryFree(ptr noundef %loadmod) #0 {
entry:
  %loadmod.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %loadmod, ptr %loadmod.addr, align 8
  %0 = load ptr, ptr %loadmod.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %loadmod.addr, align 8
  %path = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %path, align 8
  call void @sdsfree(ptr noundef %2)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, ptr %i, align 4
  %4 = load ptr, ptr %loadmod.addr, align 8
  %argc = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %4, i32 0, i32 1
  %5 = load i32, ptr %argc, align 8
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %loadmod.addr, align 8
  %argv = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %argv, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 %idxprom
  %9 = load ptr, ptr %arrayidx, align 8
  call void @decrRefCount(ptr noundef %9)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, ptr %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !69

for.end:                                          ; preds = %for.cond
  %11 = load ptr, ptr %loadmod.addr, align 8
  %argv1 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %argv1, align 8
  call void @zfree(ptr noundef %12)
  %13 = load ptr, ptr %loadmod.addr, align 8
  call void @zfree(ptr noundef %13)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleRemoveConfigs(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %config = alloca ptr, align 8
  %module_name = alloca ptr, align 8
  %full_name = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %module_configs, align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %config, align 8
  %4 = load ptr, ptr %module.addr, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %name, align 8
  %call1 = call ptr @sdsnew(ptr noundef %5)
  store ptr %call1, ptr %module_name, align 8
  %6 = load ptr, ptr %module_name, align 8
  %call2 = call ptr @sdscat(ptr noundef %6, ptr noundef @.str.104)
  %7 = load ptr, ptr %config, align 8
  %name3 = getelementptr inbounds %struct.ModuleConfig, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %name3, align 8
  %call4 = call ptr @sdscat(ptr noundef %call2, ptr noundef %8)
  store ptr %call4, ptr %full_name, align 8
  %9 = load ptr, ptr %full_name, align 8
  call void @removeConfig(ptr noundef %9)
  %10 = load ptr, ptr %full_name, align 8
  call void @sdsfree(ptr noundef %10)
  br label %while.cond, !llvm.loop !70

while.end:                                        ; preds = %while.cond
  ret void
}

declare void @removeConfig(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleRemoveCateogires(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %num_acl_categories_added = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 19
  %1 = load i64, ptr %num_acl_categories_added, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %module.addr, align 8
  %num_acl_categories_added1 = getelementptr inbounds %struct.RedisModule, ptr %2, i32 0, i32 19
  %3 = load i64, ptr %num_acl_categories_added1, align 8
  call void @ACLCleanupCategoriesOnFailure(i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @ACLCleanupCategoriesOnFailure(i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleLoadFromQueue() #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %loadmod = alloca ptr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 40), align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end5, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %loadmod, align 8
  %3 = load ptr, ptr %loadmod, align 8
  %path = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %path, align 8
  %5 = load ptr, ptr %loadmod, align 8
  %argv = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %argv, align 8
  %7 = load ptr, ptr %loadmod, align 8
  %argc = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %7, i32 0, i32 1
  %8 = load i32, ptr %argc, align 8
  %call1 = call i32 @moduleLoad(ptr noundef %4, ptr noundef %6, i32 noundef %8, i32 noundef 0)
  %cmp = icmp eq i32 %call1, -1
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %while.body
  br label %do.body

do.body:                                          ; preds = %if.then
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp2 = icmp slt i32 3, %9
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %10 = load ptr, ptr %loadmod, align 8
  %path4 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %path4, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.105, ptr noundef %11)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then3
  call void @exit(i32 noundef 1) #13
  unreachable

if.end5:                                          ; preds = %while.body
  %12 = load ptr, ptr %loadmod, align 8
  call void @moduleLoadQueueEntryFree(ptr noundef %12)
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 40), align 8
  %14 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %13, ptr noundef %14)
  br label %while.cond, !llvm.loop !71

while.end:                                        ; preds = %while.cond
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %15, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %16 = load i64, ptr %arrayidx, align 8
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  %ht_used6 = getelementptr inbounds %struct.dict, ptr %17, i32 0, i32 2
  %arrayidx7 = getelementptr inbounds [2 x i64], ptr %ht_used6, i64 0, i64 1
  %18 = load i64, ptr %arrayidx7, align 8
  %add = add i64 %16, %18
  %tobool8 = icmp ne i64 %add, 0
  br i1 %tobool8, label %if.then9, label %if.end15

if.then9:                                         ; preds = %while.end
  br label %do.body10

do.body10:                                        ; preds = %if.then9
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp11 = icmp slt i32 3, %19
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %do.body10
  br label %do.end14

if.end13:                                         ; preds = %do.body10
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.106)
  br label %do.end14

do.end14:                                         ; preds = %if.end13, %if.then12
  call void @exit(i32 noundef 1) #13
  unreachable

if.end15:                                         ; preds = %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleLoad(ptr noundef %path, ptr noundef %module_argv, i32 noundef %module_argc, i32 noundef %is_loadex) #0 {
entry:
  %retval = alloca i32, align 4
  %path.addr = alloca ptr, align 8
  %module_argv.addr = alloca ptr, align 8
  %module_argc.addr = alloca i32, align 4
  %is_loadex.addr = alloca i32, align 4
  %onload = alloca ptr, align 8
  %handle = alloca ptr, align 8
  %st = alloca %struct.stat, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %i = alloca i32, align 4
  %post_load_err = alloca i32, align 4
  store ptr %path, ptr %path.addr, align 8
  store ptr %module_argv, ptr %module_argv.addr, align 8
  store i32 %module_argc, ptr %module_argc.addr, align 4
  store i32 %is_loadex, ptr %is_loadex.addr, align 4
  %0 = load ptr, ptr %path.addr, align 8
  %call = call i32 @stat64(ptr noundef %0, ptr noundef %st) #16
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %st_mode = getelementptr inbounds %struct.stat, ptr %st, i32 0, i32 3
  %1 = load i32, ptr %st_mode, align 8
  %and = and i32 %1, 73
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end4, label %if.then1

if.then1:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then1
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp2 = icmp slt i32 3, %2
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %3 = load ptr, ptr %path.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.114, ptr noundef %3)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then3
  store i32 -1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.then
  br label %if.end5

if.end5:                                          ; preds = %if.end4, %entry
  %4 = load ptr, ptr %path.addr, align 8
  %call6 = call ptr @dlopen(ptr noundef %4, i32 noundef 2) #16
  store ptr %call6, ptr %handle, align 8
  %5 = load ptr, ptr %handle, align 8
  %cmp7 = icmp eq ptr %5, null
  br i1 %cmp7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end5
  br label %do.body9

do.body9:                                         ; preds = %if.then8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp10 = icmp slt i32 3, %6
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.body9
  br label %do.end14

if.end12:                                         ; preds = %do.body9
  %7 = load ptr, ptr %path.addr, align 8
  %call13 = call ptr @dlerror() #16
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.115, ptr noundef %7, ptr noundef %call13)
  br label %do.end14

do.end14:                                         ; preds = %if.end12, %if.then11
  store i32 -1, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end5
  %8 = load ptr, ptr %handle, align 8
  %call16 = call ptr @dlsym(ptr noundef %8, ptr noundef @.str.116) #16
  %9 = ptrtoint ptr %call16 to i64
  %10 = inttoptr i64 %9 to ptr
  store ptr %10, ptr %onload, align 8
  %11 = load ptr, ptr %onload, align 8
  %cmp17 = icmp eq ptr %11, null
  br i1 %cmp17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end15
  %12 = load ptr, ptr %handle, align 8
  %call19 = call i32 @dlclose(ptr noundef %12) #16
  br label %do.body20

do.body20:                                        ; preds = %if.then18
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp21 = icmp slt i32 3, %13
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %do.body20
  br label %do.end24

if.end23:                                         ; preds = %do.body20
  %14 = load ptr, ptr %path.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.117, ptr noundef %14)
  br label %do.end24

do.end24:                                         ; preds = %if.end23, %if.then22
  store i32 -1, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end15
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef null, i32 noundef 64)
  %15 = load ptr, ptr %onload, align 8
  %16 = load ptr, ptr %module_argv.addr, align 8
  %17 = load i32, ptr %module_argc.addr, align 4
  %call26 = call i32 %15(ptr noundef %ctx, ptr noundef %16, i32 noundef %17)
  %cmp27 = icmp eq i32 %call26, 1
  br i1 %cmp27, label %if.then28, label %if.end41

if.then28:                                        ; preds = %if.end25
  br label %do.body29

do.body29:                                        ; preds = %if.then28
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp30 = icmp slt i32 3, %18
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %do.body29
  br label %do.end33

if.end32:                                         ; preds = %do.body29
  %19 = load ptr, ptr %path.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.118, ptr noundef %19)
  br label %do.end33

do.end33:                                         ; preds = %if.end32, %if.then31
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %20 = load ptr, ptr %module, align 8
  %tobool34 = icmp ne ptr %20, null
  br i1 %tobool34, label %if.then35, label %if.end39

if.then35:                                        ; preds = %do.end33
  %module36 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %21 = load ptr, ptr %module36, align 8
  call void @moduleUnregisterCleanup(ptr noundef %21)
  %module37 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %22 = load ptr, ptr %module37, align 8
  call void @moduleRemoveCateogires(ptr noundef %22)
  %module38 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %23 = load ptr, ptr %module38, align 8
  call void @moduleFreeModuleStructure(ptr noundef %23)
  br label %if.end39

if.end39:                                         ; preds = %if.then35, %do.end33
  call void @moduleFreeContext(ptr noundef %ctx)
  %24 = load ptr, ptr %handle, align 8
  %call40 = call i32 @dlclose(ptr noundef %24) #16
  store i32 -1, ptr %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end25
  %25 = load ptr, ptr @modules, align 8
  %module42 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %26 = load ptr, ptr %module42, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %26, i32 0, i32 1
  %27 = load ptr, ptr %name, align 8
  %module43 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %28 = load ptr, ptr %module43, align 8
  %call44 = call i32 @dictAdd(ptr noundef %25, ptr noundef %27, ptr noundef %28)
  %module45 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %29 = load ptr, ptr %module45, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %29, i32 0, i32 13
  store i32 0, ptr %blocked_clients, align 8
  %30 = load ptr, ptr %handle, align 8
  %module46 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %31 = load ptr, ptr %module46, align 8
  %handle47 = getelementptr inbounds %struct.RedisModule, ptr %31, i32 0, i32 0
  store ptr %30, ptr %handle47, align 8
  %call48 = call noalias ptr @zmalloc(i64 noundef 24) #11
  %module49 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %32 = load ptr, ptr %module49, align 8
  %loadmod = getelementptr inbounds %struct.RedisModule, ptr %32, i32 0, i32 16
  store ptr %call48, ptr %loadmod, align 8
  %33 = load ptr, ptr %path.addr, align 8
  %call50 = call ptr @sdsnew(ptr noundef %33)
  %module51 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %34 = load ptr, ptr %module51, align 8
  %loadmod52 = getelementptr inbounds %struct.RedisModule, ptr %34, i32 0, i32 16
  %35 = load ptr, ptr %loadmod52, align 8
  %path53 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %35, i32 0, i32 0
  store ptr %call50, ptr %path53, align 8
  %36 = load i32, ptr %module_argc.addr, align 4
  %tobool54 = icmp ne i32 %36, 0
  br i1 %tobool54, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end41
  %37 = load i32, ptr %module_argc.addr, align 4
  %conv = sext i32 %37 to i64
  %mul = mul i64 8, %conv
  %call55 = call noalias ptr @zmalloc(i64 noundef %mul) #11
  br label %cond.end

cond.false:                                       ; preds = %if.end41
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call55, %cond.true ], [ null, %cond.false ]
  %module56 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %38 = load ptr, ptr %module56, align 8
  %loadmod57 = getelementptr inbounds %struct.RedisModule, ptr %38, i32 0, i32 16
  %39 = load ptr, ptr %loadmod57, align 8
  %argv = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %39, i32 0, i32 2
  store ptr %cond, ptr %argv, align 8
  %40 = load i32, ptr %module_argc.addr, align 4
  %module58 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %41 = load ptr, ptr %module58, align 8
  %loadmod59 = getelementptr inbounds %struct.RedisModule, ptr %41, i32 0, i32 16
  %42 = load ptr, ptr %loadmod59, align 8
  %argc = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %42, i32 0, i32 1
  store i32 %40, ptr %argc, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %43 = load i32, ptr %i, align 4
  %44 = load i32, ptr %module_argc.addr, align 4
  %cmp60 = icmp slt i32 %43, %44
  br i1 %cmp60, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %45 = load ptr, ptr %module_argv.addr, align 8
  %46 = load i32, ptr %i, align 4
  %idxprom = sext i32 %46 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %45, i64 %idxprom
  %47 = load ptr, ptr %arrayidx, align 8
  %module62 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %48 = load ptr, ptr %module62, align 8
  %loadmod63 = getelementptr inbounds %struct.RedisModule, ptr %48, i32 0, i32 16
  %49 = load ptr, ptr %loadmod63, align 8
  %argv64 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %49, i32 0, i32 2
  %50 = load ptr, ptr %argv64, align 8
  %51 = load i32, ptr %i, align 4
  %idxprom65 = sext i32 %51 to i64
  %arrayidx66 = getelementptr inbounds ptr, ptr %50, i64 %idxprom65
  store ptr %47, ptr %arrayidx66, align 8
  %module67 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %52 = load ptr, ptr %module67, align 8
  %loadmod68 = getelementptr inbounds %struct.RedisModule, ptr %52, i32 0, i32 16
  %53 = load ptr, ptr %loadmod68, align 8
  %argv69 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %53, i32 0, i32 2
  %54 = load ptr, ptr %argv69, align 8
  %55 = load i32, ptr %i, align 4
  %idxprom70 = sext i32 %55 to i64
  %arrayidx71 = getelementptr inbounds ptr, ptr %54, i64 %idxprom70
  %56 = load ptr, ptr %arrayidx71, align 8
  call void @incrRefCount(ptr noundef %56)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %57 = load i32, ptr %i, align 4
  %inc = add nsw i32 %57, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !72

for.end:                                          ; preds = %for.cond
  %module72 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %58 = load ptr, ptr %module72, align 8
  %num_commands_with_acl_categories = getelementptr inbounds %struct.RedisModule, ptr %58, i32 0, i32 17
  %59 = load i32, ptr %num_commands_with_acl_categories, align 8
  %tobool73 = icmp ne i32 %59, 0
  br i1 %tobool73, label %if.then74, label %if.end75

if.then74:                                        ; preds = %for.end
  call void @ACLRecomputeCommandBitsFromCommandRulesAllUsers()
  br label %if.end75

if.end75:                                         ; preds = %if.then74, %for.end
  br label %do.body76

do.body76:                                        ; preds = %if.end75
  %60 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp77 = icmp slt i32 2, %60
  br i1 %cmp77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %do.body76
  br label %do.end83

if.end80:                                         ; preds = %do.body76
  %module81 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %61 = load ptr, ptr %module81, align 8
  %name82 = getelementptr inbounds %struct.RedisModule, ptr %61, i32 0, i32 1
  %62 = load ptr, ptr %name82, align 8
  %63 = load ptr, ptr %path.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.119, ptr noundef %62, ptr noundef %63)
  br label %do.end83

do.end83:                                         ; preds = %if.end80, %if.then79
  %module84 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %64 = load ptr, ptr %module84, align 8
  %onload85 = getelementptr inbounds %struct.RedisModule, ptr %64, i32 0, i32 18
  store i32 0, ptr %onload85, align 4
  store i32 0, ptr %post_load_err, align 4
  %module86 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %65 = load ptr, ptr %module86, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %65, i32 0, i32 8
  %66 = load ptr, ptr %module_configs, align 8
  %len = getelementptr inbounds %struct.list, ptr %66, i32 0, i32 5
  %67 = load i64, ptr %len, align 8
  %tobool87 = icmp ne i64 %67, 0
  br i1 %tobool87, label %land.lhs.true, label %if.end91

land.lhs.true:                                    ; preds = %do.end83
  %module88 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %68 = load ptr, ptr %module88, align 8
  %configs_initialized = getelementptr inbounds %struct.RedisModule, ptr %68, i32 0, i32 9
  %69 = load i32, ptr %configs_initialized, align 8
  %tobool89 = icmp ne i32 %69, 0
  br i1 %tobool89, label %if.end91, label %if.then90

if.then90:                                        ; preds = %land.lhs.true
  call void @serverLogRaw(i32 noundef 3, ptr noundef @.str.120)
  store i32 1, ptr %post_load_err, align 4
  br label %if.end91

if.end91:                                         ; preds = %if.then90, %land.lhs.true, %do.end83
  %70 = load i32, ptr %is_loadex.addr, align 4
  %tobool92 = icmp ne i32 %70, 0
  br i1 %tobool92, label %land.lhs.true93, label %if.end99

land.lhs.true93:                                  ; preds = %if.end91
  %71 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %71, i32 0, i32 2
  %arrayidx94 = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %72 = load i64, ptr %arrayidx94, align 8
  %73 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  %ht_used95 = getelementptr inbounds %struct.dict, ptr %73, i32 0, i32 2
  %arrayidx96 = getelementptr inbounds [2 x i64], ptr %ht_used95, i64 0, i64 1
  %74 = load i64, ptr %arrayidx96, align 8
  %add = add i64 %72, %74
  %tobool97 = icmp ne i64 %add, 0
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %land.lhs.true93
  call void @serverLogRaw(i32 noundef 3, ptr noundef @.str.121)
  store i32 1, ptr %post_load_err, align 4
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %land.lhs.true93, %if.end91
  %75 = load i32, ptr %post_load_err, align 4
  %tobool100 = icmp ne i32 %75, 0
  br i1 %tobool100, label %if.then101, label %if.end105

if.then101:                                       ; preds = %if.end99
  %module102 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %76 = load ptr, ptr %module102, align 8
  %name103 = getelementptr inbounds %struct.RedisModule, ptr %76, i32 0, i32 1
  %77 = load ptr, ptr %name103, align 8
  %call104 = call i32 @moduleUnload(ptr noundef %77, ptr noundef null)
  call void @moduleFreeContext(ptr noundef %ctx)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end105:                                        ; preds = %if.end99
  %module106 = getelementptr inbounds %struct.RedisModuleCtx, ptr %ctx, i32 0, i32 1
  %78 = load ptr, ptr %module106, align 8
  call void @moduleFireServerEvent(i64 noundef 9, i32 noundef 0, ptr noundef %78)
  call void @moduleFreeContext(ptr noundef %ctx)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end105, %if.then101, %if.end39, %do.end24, %do.end14, %do.end
  %79 = load i32, ptr %retval, align 4
  ret i32 %79
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleFreeModuleStructure(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %types = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %types, align 8
  call void @listRelease(ptr noundef %1)
  %2 = load ptr, ptr %module.addr, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %2, i32 0, i32 7
  %3 = load ptr, ptr %filters, align 8
  call void @listRelease(ptr noundef %3)
  %4 = load ptr, ptr %module.addr, align 8
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %usedby, align 8
  call void @listRelease(ptr noundef %5)
  %6 = load ptr, ptr %module.addr, align 8
  %using = getelementptr inbounds %struct.RedisModule, ptr %6, i32 0, i32 6
  %7 = load ptr, ptr %using, align 8
  call void @listRelease(ptr noundef %7)
  %8 = load ptr, ptr %module.addr, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %8, i32 0, i32 8
  %9 = load ptr, ptr %module_configs, align 8
  call void @listRelease(ptr noundef %9)
  %10 = load ptr, ptr %module.addr, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %name, align 8
  call void @sdsfree(ptr noundef %11)
  %12 = load ptr, ptr %module.addr, align 8
  %loadmod = getelementptr inbounds %struct.RedisModule, ptr %12, i32 0, i32 16
  %13 = load ptr, ptr %loadmod, align 8
  call void @moduleLoadQueueEntryFree(ptr noundef %13)
  %14 = load ptr, ptr %module.addr, align 8
  call void @zfree(ptr noundef %14)
  ret void
}

declare void @listRelease(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleFreeArgs(ptr noundef %args, i32 noundef %num_args) #0 {
entry:
  %args.addr = alloca ptr, align 8
  %num_args.addr = alloca i32, align 4
  %j = alloca i32, align 4
  store ptr %args, ptr %args.addr, align 8
  store i32 %num_args, ptr %num_args.addr, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %1 = load i32, ptr %num_args.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %args.addr, align 8
  %3 = load i32, ptr %j, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.redisCommandArg, ptr %2, i64 %idxprom
  %name = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx, i32 0, i32 0
  %4 = load ptr, ptr %name, align 8
  call void @zfree(ptr noundef %4)
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i32, ptr %j, align 4
  %idxprom1 = sext i32 %6 to i64
  %arrayidx2 = getelementptr inbounds %struct.redisCommandArg, ptr %5, i64 %idxprom1
  %token = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx2, i32 0, i32 3
  %7 = load ptr, ptr %token, align 8
  call void @zfree(ptr noundef %7)
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i32, ptr %j, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr inbounds %struct.redisCommandArg, ptr %8, i64 %idxprom3
  %summary = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx4, i32 0, i32 4
  %10 = load ptr, ptr %summary, align 8
  call void @zfree(ptr noundef %10)
  %11 = load ptr, ptr %args.addr, align 8
  %12 = load i32, ptr %j, align 4
  %idxprom5 = sext i32 %12 to i64
  %arrayidx6 = getelementptr inbounds %struct.redisCommandArg, ptr %11, i64 %idxprom5
  %since = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx6, i32 0, i32 5
  %13 = load ptr, ptr %since, align 8
  call void @zfree(ptr noundef %13)
  %14 = load ptr, ptr %args.addr, align 8
  %15 = load i32, ptr %j, align 4
  %idxprom7 = sext i32 %15 to i64
  %arrayidx8 = getelementptr inbounds %struct.redisCommandArg, ptr %14, i64 %idxprom7
  %deprecated_since = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx8, i32 0, i32 7
  %16 = load ptr, ptr %deprecated_since, align 8
  call void @zfree(ptr noundef %16)
  %17 = load ptr, ptr %args.addr, align 8
  %18 = load i32, ptr %j, align 4
  %idxprom9 = sext i32 %18 to i64
  %arrayidx10 = getelementptr inbounds %struct.redisCommandArg, ptr %17, i64 %idxprom9
  %display_text = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx10, i32 0, i32 10
  %19 = load ptr, ptr %display_text, align 8
  call void @zfree(ptr noundef %19)
  %20 = load ptr, ptr %args.addr, align 8
  %21 = load i32, ptr %j, align 4
  %idxprom11 = sext i32 %21 to i64
  %arrayidx12 = getelementptr inbounds %struct.redisCommandArg, ptr %20, i64 %idxprom11
  %subargs = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx12, i32 0, i32 9
  %22 = load ptr, ptr %subargs, align 8
  %tobool = icmp ne ptr %22, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %23 = load ptr, ptr %args.addr, align 8
  %24 = load i32, ptr %j, align 4
  %idxprom13 = sext i32 %24 to i64
  %arrayidx14 = getelementptr inbounds %struct.redisCommandArg, ptr %23, i64 %idxprom13
  %subargs15 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx14, i32 0, i32 9
  %25 = load ptr, ptr %subargs15, align 8
  %26 = load ptr, ptr %args.addr, align 8
  %27 = load i32, ptr %j, align 4
  %idxprom16 = sext i32 %27 to i64
  %arrayidx17 = getelementptr inbounds %struct.redisCommandArg, ptr %26, i64 %idxprom16
  %num_args18 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx17, i32 0, i32 8
  %28 = load i32, ptr %num_args18, align 8
  call void @moduleFreeArgs(ptr noundef %25, i32 noundef %28)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %29 = load i32, ptr %j, align 4
  %inc = add nsw i32 %29, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !73

for.end:                                          ; preds = %for.cond
  %30 = load ptr, ptr %args.addr, align 8
  call void @zfree(ptr noundef %30)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleFreeCommand(ptr noundef %module, ptr noundef %cmd) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %cp = alloca ptr, align 8
  %j = alloca i32, align 4
  %j22 = alloca i32, align 4
  %j37 = alloca i32, align 4
  %de = alloca ptr, align 8
  %di = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %proc, align 8
  %cmp = icmp ne ptr %1, @RedisModuleCommandDispatcher
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %cmd.addr, align 8
  %module_cmd = getelementptr inbounds %struct.redisCommand, ptr %2, i32 0, i32 32
  %3 = load ptr, ptr %module_cmd, align 8
  store ptr %3, ptr %cp, align 8
  %4 = load ptr, ptr %cp, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCommand, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %module1, align 8
  %6 = load ptr, ptr %module.addr, align 8
  %cmp2 = icmp ne ptr %5, %6
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %7 = load i32, ptr %j, align 4
  %8 = load ptr, ptr %cmd.addr, align 8
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %8, i32 0, i32 17
  %9 = load i32, ptr %key_specs_num, align 8
  %cmp5 = icmp slt i32 %7, %9
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %cmd.addr, align 8
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 16
  %11 = load ptr, ptr %key_specs, align 8
  %12 = load i32, ptr %j, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds %struct.keySpec, ptr %11, i64 %idxprom
  %notes = getelementptr inbounds %struct.keySpec, ptr %arrayidx, i32 0, i32 0
  %13 = load ptr, ptr %notes, align 8
  %tobool = icmp ne ptr %13, null
  br i1 %tobool, label %if.then6, label %if.end11

if.then6:                                         ; preds = %for.body
  %14 = load ptr, ptr %cmd.addr, align 8
  %key_specs7 = getelementptr inbounds %struct.redisCommand, ptr %14, i32 0, i32 16
  %15 = load ptr, ptr %key_specs7, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr inbounds %struct.keySpec, ptr %15, i64 %idxprom8
  %notes10 = getelementptr inbounds %struct.keySpec, ptr %arrayidx9, i32 0, i32 0
  %17 = load ptr, ptr %notes10, align 8
  call void @zfree(ptr noundef %17)
  br label %if.end11

if.end11:                                         ; preds = %if.then6, %for.body
  %18 = load ptr, ptr %cmd.addr, align 8
  %key_specs12 = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 16
  %19 = load ptr, ptr %key_specs12, align 8
  %20 = load i32, ptr %j, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr inbounds %struct.keySpec, ptr %19, i64 %idxprom13
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx14, i32 0, i32 2
  %21 = load i32, ptr %begin_search_type, align 8
  %cmp15 = icmp eq i32 %21, 3
  br i1 %cmp15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %if.end11
  %22 = load ptr, ptr %cmd.addr, align 8
  %key_specs17 = getelementptr inbounds %struct.redisCommand, ptr %22, i32 0, i32 16
  %23 = load ptr, ptr %key_specs17, align 8
  %24 = load i32, ptr %j, align 4
  %idxprom18 = sext i32 %24 to i64
  %arrayidx19 = getelementptr inbounds %struct.keySpec, ptr %23, i64 %idxprom18
  %bs = getelementptr inbounds %struct.keySpec, ptr %arrayidx19, i32 0, i32 3
  %keyword = getelementptr inbounds %struct.anon.5, ptr %bs, i32 0, i32 0
  %25 = load ptr, ptr %keyword, align 8
  call void @zfree(ptr noundef %25)
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %if.end11
  br label %for.inc

for.inc:                                          ; preds = %if.end20
  %26 = load i32, ptr %j, align 4
  %inc = add nsw i32 %26, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !74

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %cmd.addr, align 8
  %key_specs21 = getelementptr inbounds %struct.redisCommand, ptr %27, i32 0, i32 16
  %28 = load ptr, ptr %key_specs21, align 8
  call void @zfree(ptr noundef %28)
  store i32 0, ptr %j22, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc33, %for.end
  %29 = load ptr, ptr %cmd.addr, align 8
  %tips = getelementptr inbounds %struct.redisCommand, ptr %29, i32 0, i32 10
  %30 = load ptr, ptr %tips, align 8
  %tobool24 = icmp ne ptr %30, null
  br i1 %tobool24, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond23
  %31 = load ptr, ptr %cmd.addr, align 8
  %tips25 = getelementptr inbounds %struct.redisCommand, ptr %31, i32 0, i32 10
  %32 = load ptr, ptr %tips25, align 8
  %33 = load i32, ptr %j22, align 4
  %idxprom26 = sext i32 %33 to i64
  %arrayidx27 = getelementptr inbounds ptr, ptr %32, i64 %idxprom26
  %34 = load ptr, ptr %arrayidx27, align 8
  %tobool28 = icmp ne ptr %34, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond23
  %35 = phi i1 [ false, %for.cond23 ], [ %tobool28, %land.rhs ]
  br i1 %35, label %for.body29, label %for.end35

for.body29:                                       ; preds = %land.end
  %36 = load ptr, ptr %cmd.addr, align 8
  %tips30 = getelementptr inbounds %struct.redisCommand, ptr %36, i32 0, i32 10
  %37 = load ptr, ptr %tips30, align 8
  %38 = load i32, ptr %j22, align 4
  %idxprom31 = sext i32 %38 to i64
  %arrayidx32 = getelementptr inbounds ptr, ptr %37, i64 %idxprom31
  %39 = load ptr, ptr %arrayidx32, align 8
  call void @zfree(ptr noundef %39)
  br label %for.inc33

for.inc33:                                        ; preds = %for.body29
  %40 = load i32, ptr %j22, align 4
  %inc34 = add nsw i32 %40, 1
  store i32 %inc34, ptr %j22, align 4
  br label %for.cond23, !llvm.loop !75

for.end35:                                        ; preds = %land.end
  %41 = load ptr, ptr %cmd.addr, align 8
  %tips36 = getelementptr inbounds %struct.redisCommand, ptr %41, i32 0, i32 10
  %42 = load ptr, ptr %tips36, align 8
  call void @zfree(ptr noundef %42)
  store i32 0, ptr %j37, align 4
  br label %for.cond38

for.cond38:                                       ; preds = %for.inc54, %for.end35
  %43 = load ptr, ptr %cmd.addr, align 8
  %history = getelementptr inbounds %struct.redisCommand, ptr %43, i32 0, i32 8
  %44 = load ptr, ptr %history, align 8
  %tobool39 = icmp ne ptr %44, null
  br i1 %tobool39, label %land.rhs40, label %land.end45

land.rhs40:                                       ; preds = %for.cond38
  %45 = load ptr, ptr %cmd.addr, align 8
  %history41 = getelementptr inbounds %struct.redisCommand, ptr %45, i32 0, i32 8
  %46 = load ptr, ptr %history41, align 8
  %47 = load i32, ptr %j37, align 4
  %idxprom42 = sext i32 %47 to i64
  %arrayidx43 = getelementptr inbounds %struct.commandHistory, ptr %46, i64 %idxprom42
  %since = getelementptr inbounds %struct.commandHistory, ptr %arrayidx43, i32 0, i32 0
  %48 = load ptr, ptr %since, align 8
  %tobool44 = icmp ne ptr %48, null
  br label %land.end45

land.end45:                                       ; preds = %land.rhs40, %for.cond38
  %49 = phi i1 [ false, %for.cond38 ], [ %tobool44, %land.rhs40 ]
  br i1 %49, label %for.body46, label %for.end56

for.body46:                                       ; preds = %land.end45
  %50 = load ptr, ptr %cmd.addr, align 8
  %history47 = getelementptr inbounds %struct.redisCommand, ptr %50, i32 0, i32 8
  %51 = load ptr, ptr %history47, align 8
  %52 = load i32, ptr %j37, align 4
  %idxprom48 = sext i32 %52 to i64
  %arrayidx49 = getelementptr inbounds %struct.commandHistory, ptr %51, i64 %idxprom48
  %since50 = getelementptr inbounds %struct.commandHistory, ptr %arrayidx49, i32 0, i32 0
  %53 = load ptr, ptr %since50, align 8
  call void @zfree(ptr noundef %53)
  %54 = load ptr, ptr %cmd.addr, align 8
  %history51 = getelementptr inbounds %struct.redisCommand, ptr %54, i32 0, i32 8
  %55 = load ptr, ptr %history51, align 8
  %56 = load i32, ptr %j37, align 4
  %idxprom52 = sext i32 %56 to i64
  %arrayidx53 = getelementptr inbounds %struct.commandHistory, ptr %55, i64 %idxprom52
  %changes = getelementptr inbounds %struct.commandHistory, ptr %arrayidx53, i32 0, i32 1
  %57 = load ptr, ptr %changes, align 8
  call void @zfree(ptr noundef %57)
  br label %for.inc54

for.inc54:                                        ; preds = %for.body46
  %58 = load i32, ptr %j37, align 4
  %inc55 = add nsw i32 %58, 1
  store i32 %inc55, ptr %j37, align 4
  br label %for.cond38, !llvm.loop !76

for.end56:                                        ; preds = %land.end45
  %59 = load ptr, ptr %cmd.addr, align 8
  %history57 = getelementptr inbounds %struct.redisCommand, ptr %59, i32 0, i32 8
  %60 = load ptr, ptr %history57, align 8
  call void @zfree(ptr noundef %60)
  %61 = load ptr, ptr %cmd.addr, align 8
  %summary = getelementptr inbounds %struct.redisCommand, ptr %61, i32 0, i32 1
  %62 = load ptr, ptr %summary, align 8
  call void @zfree(ptr noundef %62)
  %63 = load ptr, ptr %cmd.addr, align 8
  %since58 = getelementptr inbounds %struct.redisCommand, ptr %63, i32 0, i32 3
  %64 = load ptr, ptr %since58, align 8
  call void @zfree(ptr noundef %64)
  %65 = load ptr, ptr %cmd.addr, align 8
  %deprecated_since = getelementptr inbounds %struct.redisCommand, ptr %65, i32 0, i32 6
  %66 = load ptr, ptr %deprecated_since, align 8
  call void @zfree(ptr noundef %66)
  %67 = load ptr, ptr %cmd.addr, align 8
  %complexity = getelementptr inbounds %struct.redisCommand, ptr %67, i32 0, i32 2
  %68 = load ptr, ptr %complexity, align 8
  call void @zfree(ptr noundef %68)
  %69 = load ptr, ptr %cmd.addr, align 8
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %69, i32 0, i32 28
  %70 = load ptr, ptr %latency_histogram, align 8
  %tobool59 = icmp ne ptr %70, null
  br i1 %tobool59, label %if.then60, label %if.end63

if.then60:                                        ; preds = %for.end56
  %71 = load ptr, ptr %cmd.addr, align 8
  %latency_histogram61 = getelementptr inbounds %struct.redisCommand, ptr %71, i32 0, i32 28
  %72 = load ptr, ptr %latency_histogram61, align 8
  call void @hdr_close(ptr noundef %72)
  %73 = load ptr, ptr %cmd.addr, align 8
  %latency_histogram62 = getelementptr inbounds %struct.redisCommand, ptr %73, i32 0, i32 28
  store ptr null, ptr %latency_histogram62, align 8
  br label %if.end63

if.end63:                                         ; preds = %if.then60, %for.end56
  %74 = load ptr, ptr %cmd.addr, align 8
  %args = getelementptr inbounds %struct.redisCommand, ptr %74, i32 0, i32 21
  %75 = load ptr, ptr %args, align 8
  %76 = load ptr, ptr %cmd.addr, align 8
  %num_args = getelementptr inbounds %struct.redisCommand, ptr %76, i32 0, i32 19
  %77 = load i32, ptr %num_args, align 8
  call void @moduleFreeArgs(ptr noundef %75, i32 noundef %77)
  %78 = load ptr, ptr %cp, align 8
  call void @zfree(ptr noundef %78)
  %79 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %79, i32 0, i32 30
  %80 = load ptr, ptr %subcommands_dict, align 8
  %tobool64 = icmp ne ptr %80, null
  br i1 %tobool64, label %if.then65, label %if.end81

if.then65:                                        ; preds = %if.end63
  %81 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict66 = getelementptr inbounds %struct.redisCommand, ptr %81, i32 0, i32 30
  %82 = load ptr, ptr %subcommands_dict66, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %82)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %if.then72, %if.then65
  %83 = load ptr, ptr %di, align 8
  %call67 = call ptr @dictNext(ptr noundef %83)
  store ptr %call67, ptr %de, align 8
  %cmp68 = icmp ne ptr %call67, null
  br i1 %cmp68, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %84 = load ptr, ptr %de, align 8
  %call69 = call ptr @dictGetVal(ptr noundef %84)
  store ptr %call69, ptr %sub, align 8
  %85 = load ptr, ptr %module.addr, align 8
  %86 = load ptr, ptr %sub, align 8
  %call70 = call i32 @moduleFreeCommand(ptr noundef %85, ptr noundef %86)
  %cmp71 = icmp ne i32 %call70, 0
  br i1 %cmp71, label %if.then72, label %if.end73

if.then72:                                        ; preds = %while.body
  br label %while.cond, !llvm.loop !77

if.end73:                                         ; preds = %while.body
  %87 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict74 = getelementptr inbounds %struct.redisCommand, ptr %87, i32 0, i32 30
  %88 = load ptr, ptr %subcommands_dict74, align 8
  %89 = load ptr, ptr %sub, align 8
  %declared_name = getelementptr inbounds %struct.redisCommand, ptr %89, i32 0, i32 0
  %90 = load ptr, ptr %declared_name, align 8
  %call75 = call i32 @dictDelete(ptr noundef %88, ptr noundef %90)
  %cmp76 = icmp eq i32 %call75, 0
  %lnot = xor i1 %cmp76, true
  %lnot77 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot77 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool78 = icmp ne i64 %conv, 0
  br i1 %tobool78, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end73
  br label %cond.end

cond.false:                                       ; preds = %if.end73
  call void @_serverAssert(ptr noundef @.str.107, ptr noundef @.str.2, i32 noundef 12095)
  call void @abort() #13
  unreachable

91:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %91, %cond.true
  %92 = load ptr, ptr %sub, align 8
  %declared_name79 = getelementptr inbounds %struct.redisCommand, ptr %92, i32 0, i32 0
  %93 = load ptr, ptr %declared_name79, align 8
  call void @sdsfree(ptr noundef %93)
  %94 = load ptr, ptr %sub, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %94, i32 0, i32 27
  %95 = load ptr, ptr %fullname, align 8
  call void @sdsfree(ptr noundef %95)
  %96 = load ptr, ptr %sub, align 8
  call void @zfree(ptr noundef %96)
  br label %while.cond, !llvm.loop !77

while.end:                                        ; preds = %while.cond
  %97 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %97)
  %98 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict80 = getelementptr inbounds %struct.redisCommand, ptr %98, i32 0, i32 30
  %99 = load ptr, ptr %subcommands_dict80, align 8
  call void @dictRelease(ptr noundef %99)
  br label %if.end81

if.end81:                                         ; preds = %while.end, %if.end63
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end81, %if.then3, %if.then
  %100 = load i32, ptr %retval, align 4
  ret i32 %100
}

declare void @hdr_close(ptr noundef) #1

declare void @dictRelease(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnregisterCommands(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end20, %if.then, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %cmd, align 8
  %3 = load ptr, ptr %module.addr, align 8
  %4 = load ptr, ptr %cmd, align 8
  %call3 = call i32 @moduleFreeCommand(ptr noundef %3, ptr noundef %4)
  %cmp4 = icmp ne i32 %call3, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !78

if.end:                                           ; preds = %while.body
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %6 = load ptr, ptr %cmd, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 27
  %7 = load ptr, ptr %fullname, align 8
  %call5 = call i32 @dictDelete(ptr noundef %5, ptr noundef %7)
  %cmp6 = icmp eq i32 %call5, 0
  %lnot = xor i1 %cmp6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  call void @_serverAssert(ptr noundef @.str.108, ptr noundef @.str.2, i32 noundef 12115)
  call void @abort() #13
  unreachable

8:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %8, %cond.true
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 13), align 8
  %10 = load ptr, ptr %cmd, align 8
  %fullname8 = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 27
  %11 = load ptr, ptr %fullname8, align 8
  %call9 = call i32 @dictDelete(ptr noundef %9, ptr noundef %11)
  %cmp10 = icmp eq i32 %call9, 0
  %lnot12 = xor i1 %cmp10, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %tobool17 = icmp ne i64 %conv16, 0
  br i1 %tobool17, label %cond.true18, label %cond.false19

cond.true18:                                      ; preds = %cond.end
  br label %cond.end20

cond.false19:                                     ; preds = %cond.end
  call void @_serverAssert(ptr noundef @.str.109, ptr noundef @.str.2, i32 noundef 12116)
  call void @abort() #13
  unreachable

12:                                               ; No predecessors!
  br label %cond.end20

cond.end20:                                       ; preds = %12, %cond.true18
  %13 = load ptr, ptr %cmd, align 8
  %declared_name = getelementptr inbounds %struct.redisCommand, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %declared_name, align 8
  call void @sdsfree(ptr noundef %14)
  %15 = load ptr, ptr %cmd, align 8
  %fullname21 = getelementptr inbounds %struct.redisCommand, ptr %15, i32 0, i32 27
  %16 = load ptr, ptr %fullname21, align 8
  call void @sdsfree(ptr noundef %16)
  %17 = load ptr, ptr %cmd, align 8
  call void @zfree(ptr noundef %17)
  br label %while.cond, !llvm.loop !78

while.end:                                        ; preds = %while.cond
  %18 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %18)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @parseLoadexArguments(ptr noundef %module_argv, ptr noundef %module_argc) #0 {
entry:
  %retval = alloca i32, align 4
  %module_argv.addr = alloca ptr, align 8
  %module_argc.addr = alloca ptr, align 8
  %args_specified = alloca i32, align 4
  %argv = alloca ptr, align 8
  %argc = alloca i32, align 4
  %i = alloca i32, align 4
  %arg_val = alloca ptr, align 8
  %name = alloca ptr, align 8
  %value = alloca ptr, align 8
  store ptr %module_argv, ptr %module_argv.addr, align 8
  store ptr %module_argc, ptr %module_argc.addr, align 8
  store i32 0, ptr %args_specified, align 4
  %0 = load ptr, ptr %module_argv.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %argv, align 8
  %2 = load ptr, ptr %module_argc.addr, align 8
  %3 = load i32, ptr %2, align 4
  store i32 %3, ptr %argc, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %i, align 4
  %5 = load i32, ptr %argc, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %argv, align 8
  %7 = load i32, ptr %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %6, i64 %idxprom
  %8 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %ptr, align 8
  store ptr %9, ptr %arg_val, align 8
  %10 = load ptr, ptr %arg_val, align 8
  %call = call i32 @strcasecmp(ptr noundef %10, ptr noundef @.str.110) #14
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %for.body
  %11 = load i32, ptr %i, align 4
  %add = add nsw i32 %11, 2
  %12 = load i32, ptr %argc, align 4
  %cmp1 = icmp sge i32 %add, %12
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then2
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp3 = icmp slt i32 2, %13
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.111)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then4
  store i32 1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.then
  %14 = load ptr, ptr %argv, align 8
  %15 = load i32, ptr %i, align 4
  %add6 = add nsw i32 %15, 1
  %idxprom7 = sext i32 %add6 to i64
  %arrayidx8 = getelementptr inbounds ptr, ptr %14, i64 %idxprom7
  %16 = load ptr, ptr %arrayidx8, align 8
  %ptr9 = getelementptr inbounds %struct.redisObject, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %ptr9, align 8
  %call10 = call ptr @sdsdup(ptr noundef %17)
  store ptr %call10, ptr %name, align 8
  %18 = load ptr, ptr %argv, align 8
  %19 = load i32, ptr %i, align 4
  %add11 = add nsw i32 %19, 2
  %idxprom12 = sext i32 %add11 to i64
  %arrayidx13 = getelementptr inbounds ptr, ptr %18, i64 %idxprom12
  %20 = load ptr, ptr %arrayidx13, align 8
  %ptr14 = getelementptr inbounds %struct.redisObject, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %ptr14, align 8
  %call15 = call ptr @sdsdup(ptr noundef %21)
  store ptr %call15, ptr %value, align 8
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  %23 = load ptr, ptr %name, align 8
  %24 = load ptr, ptr %value, align 8
  %call16 = call i32 @dictReplace(ptr noundef %22, ptr noundef %23, ptr noundef %24)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end5
  %25 = load ptr, ptr %name, align 8
  call void @sdsfree(ptr noundef %25)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end5
  %26 = load i32, ptr %i, align 4
  %add20 = add nsw i32 %26, 2
  store i32 %add20, ptr %i, align 4
  br label %if.end34

if.else:                                          ; preds = %for.body
  %27 = load ptr, ptr %arg_val, align 8
  %call21 = call i32 @strcasecmp(ptr noundef %27, ptr noundef @.str.112) #14
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.else28, label %if.then23

if.then23:                                        ; preds = %if.else
  store i32 1, ptr %args_specified, align 4
  %28 = load i32, ptr %i, align 4
  %inc = add nsw i32 %28, 1
  store i32 %inc, ptr %i, align 4
  %29 = load i32, ptr %i, align 4
  %30 = load i32, ptr %argc, align 4
  %cmp24 = icmp sge i32 %29, %30
  br i1 %cmp24, label %if.then25, label %if.else26

if.then25:                                        ; preds = %if.then23
  %31 = load ptr, ptr %module_argv.addr, align 8
  store ptr null, ptr %31, align 8
  %32 = load ptr, ptr %module_argc.addr, align 8
  store i32 0, ptr %32, align 4
  br label %if.end27

if.else26:                                        ; preds = %if.then23
  %33 = load ptr, ptr %argv, align 8
  %34 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %34 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %33, i64 %idx.ext
  %35 = load ptr, ptr %module_argv.addr, align 8
  store ptr %add.ptr, ptr %35, align 8
  %36 = load i32, ptr %argc, align 4
  %37 = load i32, ptr %i, align 4
  %sub = sub nsw i32 %36, %37
  %38 = load ptr, ptr %module_argc.addr, align 8
  store i32 %sub, ptr %38, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.else26, %if.then25
  br label %for.end

if.else28:                                        ; preds = %if.else
  br label %do.body29

do.body29:                                        ; preds = %if.else28
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp30 = icmp slt i32 2, %39
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %do.body29
  br label %do.end33

if.end32:                                         ; preds = %do.body29
  %40 = load ptr, ptr %arg_val, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.113, ptr noundef %40)
  br label %do.end33

do.end33:                                         ; preds = %if.end32, %if.then31
  store i32 1, ptr %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end19
  br label %for.inc

for.inc:                                          ; preds = %if.end34
  %41 = load i32, ptr %i, align 4
  %inc35 = add nsw i32 %41, 1
  store i32 %inc35, ptr %i, align 4
  br label %for.cond, !llvm.loop !79

for.end:                                          ; preds = %if.end27, %for.cond
  %42 = load i32, ptr %args_specified, align 4
  %tobool36 = icmp ne i32 %42, 0
  br i1 %tobool36, label %if.end38, label %if.then37

if.then37:                                        ; preds = %for.end
  %43 = load ptr, ptr %module_argv.addr, align 8
  store ptr null, ptr %43, align 8
  %44 = load ptr, ptr %module_argc.addr, align 8
  store i32 0, ptr %44, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %for.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end38, %do.end33, %do.end
  %45 = load i32, ptr %retval, align 4
  ret i32 %45
}

declare i32 @dictReplace(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleUnregisterCleanup(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  call void @moduleFreeAuthenticatedClients(ptr noundef %0)
  %1 = load ptr, ptr %module.addr, align 8
  call void @moduleUnregisterCommands(ptr noundef %1)
  %2 = load ptr, ptr %module.addr, align 8
  call void @moduleUnsubscribeNotifications(ptr noundef %2)
  %3 = load ptr, ptr %module.addr, align 8
  %call = call i32 @moduleUnregisterSharedAPI(ptr noundef %3)
  %4 = load ptr, ptr %module.addr, align 8
  %call1 = call i32 @moduleUnregisterUsedAPI(ptr noundef %4)
  %5 = load ptr, ptr %module.addr, align 8
  %call2 = call i32 @moduleUnregisterFilters(ptr noundef %5)
  %6 = load ptr, ptr %module.addr, align 8
  call void @moduleUnsubscribeAllServerEvents(ptr noundef %6)
  %7 = load ptr, ptr %module.addr, align 8
  call void @moduleRemoveConfigs(ptr noundef %7)
  %8 = load ptr, ptr %module.addr, align 8
  call void @moduleUnregisterAuthCBs(ptr noundef %8)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @moduleFreeAuthenticatedClients(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %c = alloca ptr, align 8
  %auth_module1 = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end5, %if.then, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %c, align 8
  %3 = load ptr, ptr %c, align 8
  %auth_module = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 70
  %4 = load ptr, ptr %auth_module, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !80

if.end:                                           ; preds = %while.body
  %5 = load ptr, ptr %c, align 8
  %auth_module2 = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 70
  %6 = load ptr, ptr %auth_module2, align 8
  store ptr %6, ptr %auth_module1, align 8
  %7 = load ptr, ptr %auth_module1, align 8
  %8 = load ptr, ptr %module.addr, align 8
  %cmp3 = icmp eq ptr %7, %8
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %9 = load ptr, ptr %c, align 8
  call void @revokeClientAuthentication(ptr noundef %9)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  br label %while.cond, !llvm.loop !80

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind
declare i32 @stat64(ptr noundef, ptr noundef) #10

; Function Attrs: nounwind
declare ptr @dlopen(ptr noundef, i32 noundef) #10

; Function Attrs: nounwind
declare ptr @dlerror() #10

; Function Attrs: nounwind
declare ptr @dlsym(ptr noundef, ptr noundef) #10

; Function Attrs: nounwind
declare i32 @dlclose(ptr noundef) #10

declare void @ACLRecomputeCommandBitsFromCommandRulesAllUsers() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleUnload(ptr noundef %name, ptr noundef %errmsg) #0 {
entry:
  %retval = alloca i32, align 4
  %name.addr = alloca ptr, align 8
  %errmsg.addr = alloca ptr, align 8
  %module = alloca ptr, align 8
  %onunload = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  %unload_status = alloca i32, align 4
  %error = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %errmsg, ptr %errmsg.addr, align 8
  %0 = load ptr, ptr @modules, align 8
  %1 = load ptr, ptr %name.addr, align 8
  %call = call ptr @dictFetchValue(ptr noundef %0, ptr noundef %1)
  store ptr %call, ptr %module, align 8
  %2 = load ptr, ptr %module, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %errmsg.addr, align 8
  store ptr @.str.122, ptr %3, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %module, align 8
  %types = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %types, align 8
  %len = getelementptr inbounds %struct.list, ptr %5, i32 0, i32 5
  %6 = load i64, ptr %len, align 8
  %tobool = icmp ne i64 %6, 0
  br i1 %tobool, label %if.then1, label %if.else2

if.then1:                                         ; preds = %if.else
  %7 = load ptr, ptr %errmsg.addr, align 8
  store ptr @.str.123, ptr %7, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.else2:                                         ; preds = %if.else
  %8 = load ptr, ptr %module, align 8
  %usedby = getelementptr inbounds %struct.RedisModule, ptr %8, i32 0, i32 5
  %9 = load ptr, ptr %usedby, align 8
  %len3 = getelementptr inbounds %struct.list, ptr %9, i32 0, i32 5
  %10 = load i64, ptr %len3, align 8
  %tobool4 = icmp ne i64 %10, 0
  br i1 %tobool4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else2
  %11 = load ptr, ptr %errmsg.addr, align 8
  store ptr @.str.124, ptr %11, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.else6:                                         ; preds = %if.else2
  %12 = load ptr, ptr %module, align 8
  %blocked_clients = getelementptr inbounds %struct.RedisModule, ptr %12, i32 0, i32 13
  %13 = load i32, ptr %blocked_clients, align 8
  %tobool7 = icmp ne i32 %13, 0
  br i1 %tobool7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else6
  %14 = load ptr, ptr %errmsg.addr, align 8
  store ptr @.str.125, ptr %14, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.else9:                                         ; preds = %if.else6
  %15 = load ptr, ptr %module, align 8
  %call10 = call i32 @moduleHoldsTimer(ptr noundef %15)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.else9
  %16 = load ptr, ptr %errmsg.addr, align 8
  store ptr @.str.126, ptr %16, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else9
  br label %if.end13

if.end13:                                         ; preds = %if.end
  br label %if.end14

if.end14:                                         ; preds = %if.end13
  br label %if.end15

if.end15:                                         ; preds = %if.end14
  br label %if.end16

if.end16:                                         ; preds = %if.end15
  %17 = load ptr, ptr %module, align 8
  %handle = getelementptr inbounds %struct.RedisModule, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %handle, align 8
  %call17 = call ptr @dlsym(ptr noundef %18, ptr noundef @.str.127) #16
  %19 = ptrtoint ptr %call17 to i64
  %20 = inttoptr i64 %19 to ptr
  store ptr %20, ptr %onunload, align 8
  %21 = load ptr, ptr %onunload, align 8
  %tobool18 = icmp ne ptr %21, null
  br i1 %tobool18, label %if.then19, label %if.end28

if.then19:                                        ; preds = %if.end16
  %22 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %22, i32 noundef 64)
  %23 = load ptr, ptr %onunload, align 8
  %call20 = call i32 %23(ptr noundef %ctx)
  store i32 %call20, ptr %unload_status, align 4
  call void @moduleFreeContext(ptr noundef %ctx)
  %24 = load i32, ptr %unload_status, align 4
  %cmp21 = icmp eq i32 %24, 1
  br i1 %cmp21, label %if.then22, label %if.end27

if.then22:                                        ; preds = %if.then19
  br label %do.body

do.body:                                          ; preds = %if.then22
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp23 = icmp slt i32 3, %25
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %do.body
  br label %do.end

if.end25:                                         ; preds = %do.body
  %26 = load ptr, ptr %name.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.128, ptr noundef %26)
  br label %do.end

do.end:                                           ; preds = %if.end25, %if.then24
  %call26 = call ptr @__errno_location() #15
  store i32 125, ptr %call26, align 4
  store i32 -1, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.then19
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end16
  %27 = load ptr, ptr %module, align 8
  call void @moduleUnregisterCleanup(ptr noundef %27)
  %28 = load ptr, ptr %module, align 8
  %handle29 = getelementptr inbounds %struct.RedisModule, ptr %28, i32 0, i32 0
  %29 = load ptr, ptr %handle29, align 8
  %call30 = call i32 @dlclose(ptr noundef %29) #16
  %cmp31 = icmp eq i32 %call30, -1
  br i1 %cmp31, label %if.then32, label %if.end43

if.then32:                                        ; preds = %if.end28
  %call33 = call ptr @dlerror() #16
  store ptr %call33, ptr %error, align 8
  %30 = load ptr, ptr %error, align 8
  %cmp34 = icmp eq ptr %30, null
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then32
  store ptr @.str.129, ptr %error, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.then32
  br label %do.body37

do.body37:                                        ; preds = %if.end36
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp38 = icmp slt i32 3, %31
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %do.body37
  br label %do.end42

if.end40:                                         ; preds = %do.body37
  %32 = load ptr, ptr %module, align 8
  %name41 = getelementptr inbounds %struct.RedisModule, ptr %32, i32 0, i32 1
  %33 = load ptr, ptr %name41, align 8
  %34 = load ptr, ptr %error, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.130, ptr noundef %33, ptr noundef %34)
  br label %do.end42

do.end42:                                         ; preds = %if.end40, %if.then39
  br label %if.end43

if.end43:                                         ; preds = %do.end42, %if.end28
  %35 = load ptr, ptr %module, align 8
  call void @moduleFireServerEvent(i64 noundef 9, i32 noundef 1, ptr noundef %35)
  br label %do.body44

do.body44:                                        ; preds = %if.end43
  %36 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp45 = icmp slt i32 2, %36
  br i1 %cmp45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %do.body44
  br label %do.end49

if.end47:                                         ; preds = %do.body44
  %37 = load ptr, ptr %module, align 8
  %name48 = getelementptr inbounds %struct.RedisModule, ptr %37, i32 0, i32 1
  %38 = load ptr, ptr %name48, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.131, ptr noundef %38)
  br label %do.end49

do.end49:                                         ; preds = %if.end47, %if.then46
  %39 = load ptr, ptr @modules, align 8
  %40 = load ptr, ptr %module, align 8
  %name50 = getelementptr inbounds %struct.RedisModule, ptr %40, i32 0, i32 1
  %41 = load ptr, ptr %name50, align 8
  %call51 = call i32 @dictDelete(ptr noundef %39, ptr noundef %41)
  %42 = load ptr, ptr %module, align 8
  %name52 = getelementptr inbounds %struct.RedisModule, ptr %42, i32 0, i32 1
  store ptr null, ptr %name52, align 8
  %43 = load ptr, ptr %module, align 8
  call void @moduleFreeModuleStructure(ptr noundef %43)
  call void @ACLRecomputeCommandBitsFromCommandRulesAllUsers()
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end49, %do.end, %if.then12, %if.then8, %if.then5, %if.then1, %if.then
  %44 = load i32, ptr %retval, align 4
  ret i32 %44
}

; Function Attrs: nounwind uwtable
define dso_local void @modulePipeReadable(ptr noundef %el, i32 noundef %fd, ptr noundef %privdata, i32 noundef %mask) #0 {
entry:
  %el.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %privdata.addr = alloca ptr, align 8
  %mask.addr = alloca i32, align 4
  %buf = alloca [128 x i8], align 16
  store ptr %el, ptr %el.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store ptr %privdata, ptr %privdata.addr, align 8
  store i32 %mask, ptr %mask.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, ptr %fd.addr, align 4
  %arraydecay = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %call = call i64 @read(i32 noundef %0, ptr noundef %arraydecay, i64 noundef 128)
  %cmp = icmp eq i64 %call, 128
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond, !llvm.loop !81

while.end:                                        ; preds = %while.cond
  call void @eventLoopHandleOneShotEvents()
  ret void
}

declare i64 @read(i32 noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @eventLoopHandleOneShotEvents() #0 {
entry:
  %ln = alloca ptr, align 8
  %oneshot = alloca ptr, align 8
  %call = call i32 @pthread_mutex_lock(ptr noundef @moduleEventLoopMutex) #16
  %0 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %1 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %len = getelementptr inbounds %struct.list, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %len, align 8
  %tobool1 = icmp ne i64 %2, 0
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %head = getelementptr inbounds %struct.list, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %head, align 8
  store ptr %4, ptr %ln, align 8
  %5 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %oneshot, align 8
  %7 = load ptr, ptr @moduleEventLoopOneShots, align 8
  %8 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %7, ptr noundef %8)
  %call2 = call i32 @pthread_mutex_unlock(ptr noundef @moduleEventLoopMutex) #16
  %9 = load ptr, ptr %oneshot, align 8
  %func = getelementptr inbounds %struct.EventLoopOneShot, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %func, align 8
  %11 = load ptr, ptr %oneshot, align 8
  %user_data = getelementptr inbounds %struct.EventLoopOneShot, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %user_data, align 8
  call void %10(ptr noundef %12)
  %13 = load ptr, ptr %oneshot, align 8
  call void @zfree(ptr noundef %13)
  %call3 = call i32 @pthread_mutex_lock(ptr noundef @moduleEventLoopMutex) #16
  br label %while.cond, !llvm.loop !82

while.end:                                        ; preds = %while.cond
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  %call4 = call i32 @pthread_mutex_unlock(ptr noundef @moduleEventLoopMutex) #16
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyLoadedModules(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %name = alloca ptr, align 8
  %module = alloca ptr, align 8
  %path = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  %1 = load ptr, ptr %c.addr, align 8
  %2 = load ptr, ptr @modules, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %2, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %3 = load i64, ptr %arrayidx, align 8
  %4 = load ptr, ptr @modules, align 8
  %ht_used1 = getelementptr inbounds %struct.dict, ptr %4, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [2 x i64], ptr %ht_used1, i64 0, i64 1
  %5 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %3, %5
  call void @addReplyArrayLen(ptr noundef %1, i64 noundef %add)
  br label %while.cond

while.cond:                                       ; preds = %for.end, %entry
  %6 = load ptr, ptr %di, align 8
  %call3 = call ptr @dictNext(ptr noundef %6)
  store ptr %call3, ptr %de, align 8
  %cmp = icmp ne ptr %call3, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load ptr, ptr %de, align 8
  %call4 = call ptr @dictGetKey(ptr noundef %7)
  store ptr %call4, ptr %name, align 8
  %8 = load ptr, ptr %de, align 8
  %call5 = call ptr @dictGetVal(ptr noundef %8)
  store ptr %call5, ptr %module, align 8
  %9 = load ptr, ptr %module, align 8
  %loadmod = getelementptr inbounds %struct.RedisModule, ptr %9, i32 0, i32 16
  %10 = load ptr, ptr %loadmod, align 8
  %path6 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %path6, align 8
  store ptr %11, ptr %path, align 8
  %12 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %12, i64 noundef 4)
  %13 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %13, ptr noundef @.str.132)
  %14 = load ptr, ptr %c.addr, align 8
  %15 = load ptr, ptr %name, align 8
  %16 = load ptr, ptr %name, align 8
  %call7 = call i64 @sdslen(ptr noundef %16)
  call void @addReplyBulkCBuffer(ptr noundef %14, ptr noundef %15, i64 noundef %call7)
  %17 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %17, ptr noundef @.str.133)
  %18 = load ptr, ptr %c.addr, align 8
  %19 = load ptr, ptr %module, align 8
  %ver = getelementptr inbounds %struct.RedisModule, ptr %19, i32 0, i32 2
  %20 = load i32, ptr %ver, align 8
  %conv = sext i32 %20 to i64
  call void @addReplyLongLong(ptr noundef %18, i64 noundef %conv)
  %21 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %21, ptr noundef @.str.134)
  %22 = load ptr, ptr %c.addr, align 8
  %23 = load ptr, ptr %path, align 8
  %24 = load ptr, ptr %path, align 8
  %call8 = call i64 @sdslen(ptr noundef %24)
  call void @addReplyBulkCBuffer(ptr noundef %22, ptr noundef %23, i64 noundef %call8)
  %25 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %25, ptr noundef @.str.135)
  %26 = load ptr, ptr %c.addr, align 8
  %27 = load ptr, ptr %module, align 8
  %loadmod9 = getelementptr inbounds %struct.RedisModule, ptr %27, i32 0, i32 16
  %28 = load ptr, ptr %loadmod9, align 8
  %argc = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %28, i32 0, i32 1
  %29 = load i32, ptr %argc, align 8
  %conv10 = sext i32 %29 to i64
  call void @addReplyArrayLen(ptr noundef %26, i64 noundef %conv10)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %30 = load i32, ptr %i, align 4
  %31 = load ptr, ptr %module, align 8
  %loadmod11 = getelementptr inbounds %struct.RedisModule, ptr %31, i32 0, i32 16
  %32 = load ptr, ptr %loadmod11, align 8
  %argc12 = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %32, i32 0, i32 1
  %33 = load i32, ptr %argc12, align 8
  %cmp13 = icmp slt i32 %30, %33
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %34 = load ptr, ptr %c.addr, align 8
  %35 = load ptr, ptr %module, align 8
  %loadmod15 = getelementptr inbounds %struct.RedisModule, ptr %35, i32 0, i32 16
  %36 = load ptr, ptr %loadmod15, align 8
  %argv = getelementptr inbounds %struct.moduleLoadQueueEntry, ptr %36, i32 0, i32 2
  %37 = load ptr, ptr %argv, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom = sext i32 %38 to i64
  %arrayidx16 = getelementptr inbounds ptr, ptr %37, i64 %idxprom
  %39 = load ptr, ptr %arrayidx16, align 8
  call void @addReplyBulk(ptr noundef %34, ptr noundef %39)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %40 = load i32, ptr %i, align 4
  %inc = add nsw i32 %40, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !83

for.end:                                          ; preds = %for.cond
  br label %while.cond, !llvm.loop !84

while.end:                                        ; preds = %while.cond
  %41 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %41)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genModulesInfoStringRenderModulesList(ptr noundef %l) #0 {
entry:
  %l.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %output = alloca ptr, align 8
  %module = alloca ptr, align 8
  store ptr %l, ptr %l.addr, align 8
  %0 = load ptr, ptr %l.addr, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  %call = call ptr @sdsnew(ptr noundef @.str.136)
  store ptr %call, ptr %output, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call1 = call ptr @listNext(ptr noundef %li)
  store ptr %call1, ptr %ln, align 8
  %tobool = icmp ne ptr %call1, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %module, align 8
  %3 = load ptr, ptr %output, align 8
  %4 = load ptr, ptr %module, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %name, align 8
  %call2 = call ptr @sdscat(ptr noundef %3, ptr noundef %5)
  store ptr %call2, ptr %output, align 8
  %6 = load ptr, ptr %ln, align 8
  %7 = load ptr, ptr %l.addr, align 8
  %tail = getelementptr inbounds %struct.list, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %tail, align 8
  %cmp = icmp ne ptr %6, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %9 = load ptr, ptr %output, align 8
  %call3 = call ptr @sdscat(ptr noundef %9, ptr noundef @.str.137)
  store ptr %call3, ptr %output, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !85

while.end:                                        ; preds = %while.cond
  %10 = load ptr, ptr %output, align 8
  %call4 = call ptr @sdscat(ptr noundef %10, ptr noundef @.str.138)
  store ptr %call4, ptr %output, align 8
  %11 = load ptr, ptr %output, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genModulesInfoStringRenderModuleOptions(ptr noundef %module) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %output = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call ptr @sdsnew(ptr noundef @.str.136)
  store ptr %call, ptr %output, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %options = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 12
  %1 = load i32, ptr %options, align 4
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %output, align 8
  %call1 = call ptr @sdscat(ptr noundef %2, ptr noundef @.str.139)
  store ptr %call1, ptr %output, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %module.addr, align 8
  %options2 = getelementptr inbounds %struct.RedisModule, ptr %3, i32 0, i32 12
  %4 = load i32, ptr %options2, align 4
  %and3 = and i32 %4, 4
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %5 = load ptr, ptr %output, align 8
  %call6 = call ptr @sdscat(ptr noundef %5, ptr noundef @.str.140)
  store ptr %call6, ptr %output, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %6 = load ptr, ptr %module.addr, align 8
  %options8 = getelementptr inbounds %struct.RedisModule, ptr %6, i32 0, i32 12
  %7 = load i32, ptr %options8, align 4
  %and9 = and i32 %7, 2
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end7
  %8 = load ptr, ptr %output, align 8
  %call12 = call ptr @sdscat(ptr noundef %8, ptr noundef @.str.141)
  store ptr %call12, ptr %output, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end7
  %9 = load ptr, ptr %output, align 8
  %call14 = call ptr @sdstrim(ptr noundef %9, ptr noundef @.str.137)
  store ptr %call14, ptr %output, align 8
  %10 = load ptr, ptr %output, align 8
  %call15 = call ptr @sdscat(ptr noundef %10, ptr noundef @.str.138)
  store ptr %call15, ptr %output, align 8
  %11 = load ptr, ptr %output, align 8
  ret ptr %11
}

declare ptr @sdstrim(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @genModulesInfoString(ptr noundef %info) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %name = alloca ptr, align 8
  %module = alloca ptr, align 8
  %usedby = alloca ptr, align 8
  %using = alloca ptr, align 8
  %options = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetKey(ptr noundef %2)
  store ptr %call2, ptr %name, align 8
  %3 = load ptr, ptr %de, align 8
  %call3 = call ptr @dictGetVal(ptr noundef %3)
  store ptr %call3, ptr %module, align 8
  %4 = load ptr, ptr %module, align 8
  %usedby4 = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 5
  %5 = load ptr, ptr %usedby4, align 8
  %call5 = call ptr @genModulesInfoStringRenderModulesList(ptr noundef %5)
  store ptr %call5, ptr %usedby, align 8
  %6 = load ptr, ptr %module, align 8
  %using6 = getelementptr inbounds %struct.RedisModule, ptr %6, i32 0, i32 6
  %7 = load ptr, ptr %using6, align 8
  %call7 = call ptr @genModulesInfoStringRenderModulesList(ptr noundef %7)
  store ptr %call7, ptr %using, align 8
  %8 = load ptr, ptr %module, align 8
  %call8 = call ptr @genModulesInfoStringRenderModuleOptions(ptr noundef %8)
  store ptr %call8, ptr %options, align 8
  %9 = load ptr, ptr %info.addr, align 8
  %10 = load ptr, ptr %name, align 8
  %11 = load ptr, ptr %module, align 8
  %ver = getelementptr inbounds %struct.RedisModule, ptr %11, i32 0, i32 2
  %12 = load i32, ptr %ver, align 8
  %13 = load ptr, ptr %module, align 8
  %apiver = getelementptr inbounds %struct.RedisModule, ptr %13, i32 0, i32 3
  %14 = load i32, ptr %apiver, align 4
  %15 = load ptr, ptr %module, align 8
  %filters = getelementptr inbounds %struct.RedisModule, ptr %15, i32 0, i32 7
  %16 = load ptr, ptr %filters, align 8
  %len = getelementptr inbounds %struct.list, ptr %16, i32 0, i32 5
  %17 = load i64, ptr %len, align 8
  %conv = trunc i64 %17 to i32
  %18 = load ptr, ptr %usedby, align 8
  %19 = load ptr, ptr %using, align 8
  %20 = load ptr, ptr %options, align 8
  %call9 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %9, ptr noundef @.str.142, ptr noundef %10, i32 noundef %12, i32 noundef %14, i32 noundef %conv, ptr noundef %18, ptr noundef %19, ptr noundef %20)
  store ptr %call9, ptr %info.addr, align 8
  %21 = load ptr, ptr %usedby, align 8
  call void @sdsfree(ptr noundef %21)
  %22 = load ptr, ptr %using, align 8
  call void @sdsfree(ptr noundef %22)
  %23 = load ptr, ptr %options, align 8
  call void @sdsfree(ptr noundef %23)
  br label %while.cond, !llvm.loop !86

while.end:                                        ; preds = %while.cond
  %24 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %24)
  %25 = load ptr, ptr %info.addr, align 8
  ret ptr %25
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isModuleConfigNameRegistered(ptr noundef %module, ptr noundef %name) #0 {
entry:
  %module.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %match = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %module_configs, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %call = call ptr @listSearchKey(ptr noundef %1, ptr noundef %2)
  store ptr %call, ptr %match, align 8
  %3 = load ptr, ptr %match, align 8
  %cmp = icmp ne ptr %3, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleVerifyConfigFlags(i32 noundef %flags, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %conv = zext i32 %0 to i64
  %and = and i64 %conv, -500
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @serverLogRaw(i32 noundef 3, ptr noundef @.str.143)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  %cmp = icmp ne i32 %1, 1
  br i1 %cmp, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %2 = load i32, ptr %flags.addr, align 4
  %conv2 = zext i32 %2 to i64
  %and3 = and i64 %conv2, 128
  %tobool4 = icmp ne i64 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  call void @serverLogRaw(i32 noundef 3, ptr noundef @.str.144)
  store i32 1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %land.lhs.true, %if.end
  %3 = load i32, ptr %type.addr, align 4
  %cmp7 = icmp ne i32 %3, 4
  br i1 %cmp7, label %land.lhs.true9, label %if.end14

land.lhs.true9:                                   ; preds = %if.end6
  %4 = load i32, ptr %flags.addr, align 4
  %conv10 = zext i32 %4 to i64
  %and11 = and i64 %conv10, 256
  %tobool12 = icmp ne i64 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %land.lhs.true9
  call void @serverLogRaw(i32 noundef 3, ptr noundef @.str.145)
  store i32 1, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %land.lhs.true9, %if.end6
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then5, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define dso_local i32 @setModuleBoolConfig(ptr noundef %config, i32 noundef %val, ptr noundef %err) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %val.addr = alloca i32, align 4
  %err.addr = alloca ptr, align 8
  %error = alloca ptr, align 8
  %return_code = alloca i32, align 4
  store ptr %config, ptr %config.addr, align 8
  store i32 %val, ptr %val.addr, align 4
  store ptr %err, ptr %err.addr, align 8
  store ptr null, ptr %error, align 8
  %0 = load ptr, ptr %config.addr, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %set_fn, align 8
  %2 = load ptr, ptr %config.addr, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %4 = load i32, ptr %val.addr, align 4
  %5 = load ptr, ptr %config.addr, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %privdata, align 8
  %call = call i32 %1(ptr noundef %3, i32 noundef %4, ptr noundef %6, ptr noundef %error)
  store i32 %call, ptr %return_code, align 4
  %7 = load ptr, ptr %error, align 8
  %8 = load ptr, ptr %err.addr, align 8
  call void @propagateErrorString(ptr noundef %7, ptr noundef %8)
  %9 = load i32, ptr %return_code, align 4
  %cmp = icmp eq i32 %9, 0
  %cond = select i1 %cmp, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal void @propagateErrorString(ptr noundef %err_in, ptr noundef %err) #0 {
entry:
  %err_in.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  store ptr %err_in, ptr %err_in.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %err_in.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %err_in.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %call = call i64 @redis_strlcpy(ptr noundef @configerr, ptr noundef %2, i64 noundef 256)
  %3 = load ptr, ptr %err_in.addr, align 8
  call void @decrRefCount(ptr noundef %3)
  %4 = load ptr, ptr %err.addr, align 8
  store ptr @configerr, ptr %4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @setModuleStringConfig(ptr noundef %config, ptr noundef %strval, ptr noundef %err) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %strval.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %error = alloca ptr, align 8
  %new = alloca ptr, align 8
  %return_code = alloca i32, align 4
  store ptr %config, ptr %config.addr, align 8
  store ptr %strval, ptr %strval.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  store ptr null, ptr %error, align 8
  %0 = load ptr, ptr %strval.addr, align 8
  %1 = load ptr, ptr %strval.addr, align 8
  %call = call i64 @sdslen(ptr noundef %1)
  %call1 = call ptr @createStringObject(ptr noundef %0, i64 noundef %call)
  store ptr %call1, ptr %new, align 8
  %2 = load ptr, ptr %config.addr, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %set_fn, align 8
  %4 = load ptr, ptr %config.addr, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %name, align 8
  %6 = load ptr, ptr %new, align 8
  %7 = load ptr, ptr %config.addr, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %privdata, align 8
  %call2 = call i32 %3(ptr noundef %5, ptr noundef %6, ptr noundef %8, ptr noundef %error)
  store i32 %call2, ptr %return_code, align 4
  %9 = load ptr, ptr %error, align 8
  %10 = load ptr, ptr %err.addr, align 8
  call void @propagateErrorString(ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %new, align 8
  call void @decrRefCount(ptr noundef %11)
  %12 = load i32, ptr %return_code, align 4
  %cmp = icmp eq i32 %12, 0
  %cond = select i1 %cmp, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @setModuleEnumConfig(ptr noundef %config, i32 noundef %val, ptr noundef %err) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %val.addr = alloca i32, align 4
  %err.addr = alloca ptr, align 8
  %error = alloca ptr, align 8
  %return_code = alloca i32, align 4
  store ptr %config, ptr %config.addr, align 8
  store i32 %val, ptr %val.addr, align 4
  store ptr %err, ptr %err.addr, align 8
  store ptr null, ptr %error, align 8
  %0 = load ptr, ptr %config.addr, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %set_fn, align 8
  %2 = load ptr, ptr %config.addr, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %4 = load i32, ptr %val.addr, align 4
  %5 = load ptr, ptr %config.addr, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %privdata, align 8
  %call = call i32 %1(ptr noundef %3, i32 noundef %4, ptr noundef %6, ptr noundef %error)
  store i32 %call, ptr %return_code, align 4
  %7 = load ptr, ptr %error, align 8
  %8 = load ptr, ptr %err.addr, align 8
  call void @propagateErrorString(ptr noundef %7, ptr noundef %8)
  %9 = load i32, ptr %return_code, align 4
  %cmp = icmp eq i32 %9, 0
  %cond = select i1 %cmp, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @setModuleNumericConfig(ptr noundef %config, i64 noundef %val, ptr noundef %err) #0 {
entry:
  %config.addr = alloca ptr, align 8
  %val.addr = alloca i64, align 8
  %err.addr = alloca ptr, align 8
  %error = alloca ptr, align 8
  %return_code = alloca i32, align 4
  store ptr %config, ptr %config.addr, align 8
  store i64 %val, ptr %val.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  store ptr null, ptr %error, align 8
  %0 = load ptr, ptr %config.addr, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %set_fn, align 8
  %2 = load ptr, ptr %config.addr, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %4 = load i64, ptr %val.addr, align 8
  %5 = load ptr, ptr %config.addr, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %privdata, align 8
  %call = call i32 %1(ptr noundef %3, i64 noundef %4, ptr noundef %6, ptr noundef %error)
  store i32 %call, ptr %return_code, align 4
  %7 = load ptr, ptr %error, align 8
  %8 = load ptr, ptr %err.addr, align 8
  call void @propagateErrorString(ptr noundef %7, ptr noundef %8)
  %9 = load i32, ptr %return_code, align 4
  %cmp = icmp eq i32 %9, 0
  %cond = select i1 %cmp, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getModuleBoolConfig(ptr noundef %module_config) #0 {
entry:
  %module_config.addr = alloca ptr, align 8
  store ptr %module_config, ptr %module_config.addr, align 8
  %0 = load ptr, ptr %module_config.addr, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %get_fn, align 8
  %2 = load ptr, ptr %module_config.addr, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %4 = load ptr, ptr %module_config.addr, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %privdata, align 8
  %call = call i32 %1(ptr noundef %3, ptr noundef %5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @getModuleStringConfig(ptr noundef %module_config) #0 {
entry:
  %module_config.addr = alloca ptr, align 8
  %val = alloca ptr, align 8
  store ptr %module_config, ptr %module_config.addr, align 8
  %0 = load ptr, ptr %module_config.addr, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %get_fn, align 8
  %2 = load ptr, ptr %module_config.addr, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %4 = load ptr, ptr %module_config.addr, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %privdata, align 8
  %call = call ptr %1(ptr noundef %3, ptr noundef %5)
  store ptr %call, ptr %val, align 8
  %6 = load ptr, ptr %val, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load ptr, ptr %val, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %ptr, align 8
  %call1 = call ptr @sdsdup(ptr noundef %8)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call1, %cond.true ], [ null, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind uwtable
define dso_local i32 @getModuleEnumConfig(ptr noundef %module_config) #0 {
entry:
  %module_config.addr = alloca ptr, align 8
  store ptr %module_config, ptr %module_config.addr, align 8
  %0 = load ptr, ptr %module_config.addr, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %get_fn, align 8
  %2 = load ptr, ptr %module_config.addr, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %4 = load ptr, ptr %module_config.addr, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %privdata, align 8
  %call = call i32 %1(ptr noundef %3, ptr noundef %5)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @getModuleNumericConfig(ptr noundef %module_config) #0 {
entry:
  %module_config.addr = alloca ptr, align 8
  store ptr %module_config, ptr %module_config.addr, align 8
  %0 = load ptr, ptr %module_config.addr, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %get_fn, align 8
  %2 = load ptr, ptr %module_config.addr, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %4 = load ptr, ptr %module_config.addr, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %privdata, align 8
  %call = call i64 %1(ptr noundef %3, ptr noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @loadModuleConfigs(ptr noundef %module) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %err = alloca ptr, align 8
  %module_config = alloca ptr, align 8
  %config_name = alloca ptr, align 8
  %config_argument = alloca ptr, align 8
  store ptr %module, ptr %module.addr, align 8
  store ptr null, ptr %err, align 8
  %0 = load ptr, ptr %module.addr, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %module_configs, align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end24, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %module_config, align 8
  %call1 = call ptr @sdsempty()
  %4 = load ptr, ptr %module.addr, align 8
  %name = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %name, align 8
  %6 = load ptr, ptr %module_config, align 8
  %name2 = getelementptr inbounds %struct.ModuleConfig, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %name2, align 8
  %call3 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call1, ptr noundef @.str.147, ptr noundef %5, ptr noundef %7)
  store ptr %call3, ptr %config_name, align 8
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  %9 = load ptr, ptr %config_name, align 8
  %call4 = call ptr @dictFind(ptr noundef %8, ptr noundef %9)
  store ptr %call4, ptr %config_argument, align 8
  %10 = load ptr, ptr %config_argument, align 8
  %tobool5 = icmp ne ptr %10, null
  br i1 %tobool5, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %11 = load ptr, ptr %config_argument, align 8
  %call6 = call ptr @dictGetKey(ptr noundef %11)
  %12 = load ptr, ptr %config_argument, align 8
  %call7 = call ptr @dictGetVal(ptr noundef %12)
  %call8 = call i32 @performModuleConfigSetFromName(ptr noundef %call6, ptr noundef %call7, ptr noundef %err)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end13, label %if.then10

if.then10:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then10
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 3, %13
  br i1 %cmp, label %if.then11, label %if.end

if.then11:                                        ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %14 = load ptr, ptr %config_argument, align 8
  %call12 = call ptr @dictGetKey(ptr noundef %14)
  %15 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.148, ptr noundef %call12, ptr noundef %15)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then11
  %16 = load ptr, ptr %config_name, align 8
  call void @sdsfree(ptr noundef %16)
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  call void @dictEmpty(ptr noundef %17, ptr noundef null)
  store i32 1, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.then
  br label %if.end24

if.else:                                          ; preds = %while.body
  %18 = load ptr, ptr %config_name, align 8
  %call14 = call i32 @performModuleConfigSetDefaultFromName(ptr noundef %18, ptr noundef %err)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end23, label %if.then16

if.then16:                                        ; preds = %if.else
  br label %do.body17

do.body17:                                        ; preds = %if.then16
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp18 = icmp slt i32 3, %19
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %do.body17
  br label %do.end22

if.end20:                                         ; preds = %do.body17
  %20 = load ptr, ptr %module_config, align 8
  %name21 = getelementptr inbounds %struct.ModuleConfig, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %name21, align 8
  %22 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.149, ptr noundef %21, ptr noundef %22)
  br label %do.end22

do.end22:                                         ; preds = %if.end20, %if.then19
  %23 = load ptr, ptr %config_name, align 8
  call void @sdsfree(ptr noundef %23)
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  call void @dictEmpty(ptr noundef %24, ptr noundef null)
  store i32 1, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.else
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.end13
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  %26 = load ptr, ptr %config_name, align 8
  %call25 = call i32 @dictDelete(ptr noundef %25, ptr noundef %26)
  %27 = load ptr, ptr %config_name, align 8
  call void @sdsfree(ptr noundef %27)
  br label %while.cond, !llvm.loop !87

while.end:                                        ; preds = %while.cond
  %28 = load ptr, ptr %module.addr, align 8
  %configs_initialized = getelementptr inbounds %struct.RedisModule, ptr %28, i32 0, i32 9
  store i32 1, ptr %configs_initialized, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %do.end22, %do.end
  %29 = load i32, ptr %retval, align 4
  ret i32 %29
}

declare i32 @performModuleConfigSetFromName(ptr noundef, ptr noundef, ptr noundef) #1

declare void @dictEmpty(ptr noundef, ptr noundef) #1

declare i32 @performModuleConfigSetDefaultFromName(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @addModuleConfigApply(ptr noundef %module_configs, ptr noundef %module_config) #0 {
entry:
  %module_configs.addr = alloca ptr, align 8
  %module_config.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %pending_apply = alloca ptr, align 8
  store ptr %module_configs, ptr %module_configs.addr, align 8
  store ptr %module_config, ptr %module_config.addr, align 8
  %0 = load ptr, ptr %module_config.addr, align 8
  %apply_fn = getelementptr inbounds %struct.ModuleConfig, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %apply_fn, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %module_configs.addr, align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end7, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool1 = icmp ne ptr %call, null
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %pending_apply, align 8
  %5 = load ptr, ptr %pending_apply, align 8
  %apply_fn2 = getelementptr inbounds %struct.ModuleConfig, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %apply_fn2, align 8
  %7 = load ptr, ptr %module_config.addr, align 8
  %apply_fn3 = getelementptr inbounds %struct.ModuleConfig, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %apply_fn3, align 8
  %cmp = icmp eq ptr %6, %8
  br i1 %cmp, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %while.body
  %9 = load ptr, ptr %pending_apply, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %privdata, align 8
  %11 = load ptr, ptr %module_config.addr, align 8
  %privdata4 = getelementptr inbounds %struct.ModuleConfig, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %privdata4, align 8
  %cmp5 = icmp eq ptr %10, %12
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %while.body
  br label %while.cond, !llvm.loop !88

while.end:                                        ; preds = %while.cond
  %13 = load ptr, ptr %module_configs.addr, align 8
  %14 = load ptr, ptr %module_config.addr, align 8
  %call8 = call ptr @listAddNodeTail(ptr noundef %13, ptr noundef %14)
  br label %return

return:                                           ; preds = %while.end, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleConfigApplyConfig(ptr noundef %module_configs, ptr noundef %err, ptr noundef %err_arg_name) #0 {
entry:
  %retval = alloca i32, align 4
  %module_configs.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %err_arg_name.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %module_config = alloca ptr, align 8
  %error = alloca ptr, align 8
  %ctx = alloca %struct.RedisModuleCtx, align 8
  store ptr %module_configs, ptr %module_configs.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  store ptr %err_arg_name, ptr %err_arg_name.addr, align 8
  %0 = load ptr, ptr %module_configs.addr, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %error, align 8
  %2 = load ptr, ptr %module_configs.addr, align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end8, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool1 = icmp ne ptr %call, null
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %module_config, align 8
  %5 = load ptr, ptr %module_config, align 8
  %module = getelementptr inbounds %struct.ModuleConfig, ptr %5, i32 0, i32 5
  %6 = load ptr, ptr %module, align 8
  call void @moduleCreateContext(ptr noundef %ctx, ptr noundef %6, i32 noundef 0)
  %7 = load ptr, ptr %module_config, align 8
  %apply_fn = getelementptr inbounds %struct.ModuleConfig, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %apply_fn, align 8
  %9 = load ptr, ptr %module_config, align 8
  %privdata = getelementptr inbounds %struct.ModuleConfig, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %privdata, align 8
  %call2 = call i32 %8(ptr noundef %ctx, ptr noundef %10, ptr noundef %error)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %while.body
  %11 = load ptr, ptr %err_arg_name.addr, align 8
  %tobool5 = icmp ne ptr %11, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then4
  %12 = load ptr, ptr %module_config, align 8
  %name = getelementptr inbounds %struct.ModuleConfig, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %name, align 8
  %14 = load ptr, ptr %err_arg_name.addr, align 8
  store ptr %13, ptr %14, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.then4
  %15 = load ptr, ptr %error, align 8
  %16 = load ptr, ptr %err.addr, align 8
  call void @propagateErrorString(ptr noundef %15, ptr noundef %16)
  call void @moduleFreeContext(ptr noundef %ctx)
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %while.body
  call void @moduleFreeContext(ptr noundef %ctx)
  br label %while.cond, !llvm.loop !89

while.end:                                        ; preds = %while.cond
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.end7, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define dso_local ptr @createModuleConfig(ptr noundef %name, ptr noundef %apply_fn, ptr noundef %privdata, ptr noundef %module) #0 {
entry:
  %name.addr = alloca ptr, align 8
  %apply_fn.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %module.addr = alloca ptr, align 8
  %new_config = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %apply_fn, ptr %apply_fn.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  store ptr %module, ptr %module.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 48) #11
  store ptr %call, ptr %new_config, align 8
  %0 = load ptr, ptr %name.addr, align 8
  %call1 = call ptr @sdsnew(ptr noundef %0)
  %1 = load ptr, ptr %new_config, align 8
  %name2 = getelementptr inbounds %struct.ModuleConfig, ptr %1, i32 0, i32 0
  store ptr %call1, ptr %name2, align 8
  %2 = load ptr, ptr %apply_fn.addr, align 8
  %3 = load ptr, ptr %new_config, align 8
  %apply_fn3 = getelementptr inbounds %struct.ModuleConfig, ptr %3, i32 0, i32 4
  store ptr %2, ptr %apply_fn3, align 8
  %4 = load ptr, ptr %privdata.addr, align 8
  %5 = load ptr, ptr %new_config, align 8
  %privdata4 = getelementptr inbounds %struct.ModuleConfig, ptr %5, i32 0, i32 1
  store ptr %4, ptr %privdata4, align 8
  %6 = load ptr, ptr %module.addr, align 8
  %7 = load ptr, ptr %new_config, align 8
  %module5 = getelementptr inbounds %struct.ModuleConfig, ptr %7, i32 0, i32 5
  store ptr %6, ptr %module5, align 8
  %8 = load ptr, ptr %new_config, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleConfigValidityCheck(ptr noundef %module, ptr noundef %name, i32 noundef %flags, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store ptr %module, ptr %module.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load ptr, ptr %module.addr, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %0, i32 0, i32 18
  %1 = load i32, ptr %onload, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @__errno_location() #15
  store i32 16, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %flags.addr, align 4
  %3 = load i32, ptr %type.addr, align 4
  %call1 = call i32 @moduleVerifyConfigFlags(i32 noundef %2, i32 noundef %3)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %4 = load ptr, ptr %name.addr, align 8
  %call3 = call i32 @moduleVerifyResourceName(ptr noundef %4)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %call6 = call ptr @__errno_location() #15
  store i32 22, ptr %call6, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %lor.lhs.false
  %5 = load ptr, ptr %module.addr, align 8
  %6 = load ptr, ptr %name.addr, align 8
  %call8 = call i32 @isModuleConfigNameRegistered(ptr noundef %5, ptr noundef %6)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end7
  br label %do.body

do.body:                                          ; preds = %if.then10
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 3, %7
  br i1 %cmp, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.body
  br label %do.end

if.end12:                                         ; preds = %do.body
  %8 = load ptr, ptr %name.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.150, ptr noundef %8)
  br label %do.end

do.end:                                           ; preds = %if.end12, %if.then11
  %call13 = call ptr @__errno_location() #15
  store i32 114, ptr %call13, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end7
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %do.end, %if.then5, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define dso_local i32 @maskModuleConfigFlags(i32 noundef %flags) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %new_flags = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %new_flags, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 0
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %new_flags, align 4
  %or = or i32 %1, 0
  store i32 %or, ptr %new_flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %flags.addr, align 4
  %conv = zext i32 %2 to i64
  %and1 = and i64 %conv, 1
  %tobool2 = icmp ne i64 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  %3 = load i32, ptr %new_flags, align 4
  %conv4 = zext i32 %3 to i64
  %or5 = or i64 %conv4, 1
  %conv6 = trunc i64 %or5 to i32
  store i32 %conv6, ptr %new_flags, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %flags.addr, align 4
  %conv8 = zext i32 %4 to i64
  %and9 = and i64 %conv8, 16
  %tobool10 = icmp ne i64 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end15

if.then11:                                        ; preds = %if.end7
  %5 = load i32, ptr %new_flags, align 4
  %conv12 = zext i32 %5 to i64
  %or13 = or i64 %conv12, 16
  %conv14 = trunc i64 %or13 to i32
  store i32 %conv14, ptr %new_flags, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then11, %if.end7
  %6 = load i32, ptr %flags.addr, align 4
  %conv16 = zext i32 %6 to i64
  %and17 = and i64 %conv16, 32
  %tobool18 = icmp ne i64 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.end15
  %7 = load i32, ptr %new_flags, align 4
  %conv20 = zext i32 %7 to i64
  %or21 = or i64 %conv20, 32
  %conv22 = trunc i64 %or21 to i32
  store i32 %conv22, ptr %new_flags, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %if.end15
  %8 = load i32, ptr %flags.addr, align 4
  %conv24 = zext i32 %8 to i64
  %and25 = and i64 %conv24, 64
  %tobool26 = icmp ne i64 %and25, 0
  br i1 %tobool26, label %if.then27, label %if.end31

if.then27:                                        ; preds = %if.end23
  %9 = load i32, ptr %new_flags, align 4
  %conv28 = zext i32 %9 to i64
  %or29 = or i64 %conv28, 64
  %conv30 = trunc i64 %or29 to i32
  store i32 %conv30, ptr %new_flags, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then27, %if.end23
  %10 = load i32, ptr %new_flags, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define dso_local i32 @maskModuleNumericConfigFlags(i32 noundef %flags) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %new_flags = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %new_flags, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %conv = zext i32 %0 to i64
  %and = and i64 %conv, 128
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %new_flags, align 4
  %or = or i32 %1, 1
  store i32 %or, ptr %new_flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %new_flags, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define dso_local i32 @maskModuleEnumConfigFlags(i32 noundef %flags) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %new_flags = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %new_flags, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %conv = zext i32 %0 to i64
  %and = and i64 %conv, 256
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %new_flags, align 4
  %conv1 = zext i32 %1 to i64
  %or = or i64 %conv1, 8
  %conv2 = trunc i64 %or to i32
  store i32 %conv2, ptr %new_flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %new_flags, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RegisterStringConfig(ptr noundef %ctx, ptr noundef %name, ptr noundef %default_val, i32 noundef %flags, ptr noundef %getfn, ptr noundef %setfn, ptr noundef %applyfn, ptr noundef %privdata) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %default_val.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %getfn.addr = alloca ptr, align 8
  %setfn.addr = alloca ptr, align 8
  %applyfn.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %module = alloca ptr, align 8
  %new_config = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %default_val, ptr %default_val.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %getfn, ptr %getfn.addr, align 8
  store ptr %setfn, ptr %setfn.addr, align 8
  store ptr %applyfn, ptr %applyfn.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module1, align 8
  store ptr %1, ptr %module, align 8
  %2 = load ptr, ptr %module, align 8
  %3 = load ptr, ptr %name.addr, align 8
  %4 = load i32, ptr %flags.addr, align 4
  %call = call i32 @moduleConfigValidityCheck(ptr noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %name.addr, align 8
  %6 = load ptr, ptr %applyfn.addr, align 8
  %7 = load ptr, ptr %privdata.addr, align 8
  %8 = load ptr, ptr %module, align 8
  %call2 = call ptr @createModuleConfig(ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8)
  store ptr %call2, ptr %new_config, align 8
  %9 = load ptr, ptr %getfn.addr, align 8
  %10 = load ptr, ptr %new_config, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %10, i32 0, i32 2
  store ptr %9, ptr %get_fn, align 8
  %11 = load ptr, ptr %setfn.addr, align 8
  %12 = load ptr, ptr %new_config, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %12, i32 0, i32 3
  store ptr %11, ptr %set_fn, align 8
  %13 = load ptr, ptr %module, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %13, i32 0, i32 8
  %14 = load ptr, ptr %module_configs, align 8
  %15 = load ptr, ptr %new_config, align 8
  %call3 = call ptr @listAddNodeTail(ptr noundef %14, ptr noundef %15)
  %16 = load i32, ptr %flags.addr, align 4
  %call4 = call i32 @maskModuleConfigFlags(i32 noundef %16)
  store i32 %call4, ptr %flags.addr, align 4
  %17 = load ptr, ptr %module, align 8
  %name5 = getelementptr inbounds %struct.RedisModule, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %name5, align 8
  %19 = load ptr, ptr %name.addr, align 8
  %20 = load i32, ptr %flags.addr, align 4
  %21 = load ptr, ptr %new_config, align 8
  %22 = load ptr, ptr %default_val.addr, align 8
  %tobool6 = icmp ne ptr %22, null
  br i1 %tobool6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %23 = load ptr, ptr %default_val.addr, align 8
  %call7 = call ptr @sdsnew(ptr noundef %23)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call7, %cond.true ], [ null, %cond.false ]
  call void @addModuleStringConfig(ptr noundef %18, ptr noundef %19, i32 noundef %20, ptr noundef %21, ptr noundef %cond)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

declare void @addModuleStringConfig(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RegisterBoolConfig(ptr noundef %ctx, ptr noundef %name, i32 noundef %default_val, i32 noundef %flags, ptr noundef %getfn, ptr noundef %setfn, ptr noundef %applyfn, ptr noundef %privdata) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %default_val.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %getfn.addr = alloca ptr, align 8
  %setfn.addr = alloca ptr, align 8
  %applyfn.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %module = alloca ptr, align 8
  %new_config = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %default_val, ptr %default_val.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %getfn, ptr %getfn.addr, align 8
  store ptr %setfn, ptr %setfn.addr, align 8
  store ptr %applyfn, ptr %applyfn.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module1, align 8
  store ptr %1, ptr %module, align 8
  %2 = load ptr, ptr %module, align 8
  %3 = load ptr, ptr %name.addr, align 8
  %4 = load i32, ptr %flags.addr, align 4
  %call = call i32 @moduleConfigValidityCheck(ptr noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %name.addr, align 8
  %6 = load ptr, ptr %applyfn.addr, align 8
  %7 = load ptr, ptr %privdata.addr, align 8
  %8 = load ptr, ptr %module, align 8
  %call2 = call ptr @createModuleConfig(ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8)
  store ptr %call2, ptr %new_config, align 8
  %9 = load ptr, ptr %getfn.addr, align 8
  %10 = load ptr, ptr %new_config, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %10, i32 0, i32 2
  store ptr %9, ptr %get_fn, align 8
  %11 = load ptr, ptr %setfn.addr, align 8
  %12 = load ptr, ptr %new_config, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %12, i32 0, i32 3
  store ptr %11, ptr %set_fn, align 8
  %13 = load ptr, ptr %module, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %13, i32 0, i32 8
  %14 = load ptr, ptr %module_configs, align 8
  %15 = load ptr, ptr %new_config, align 8
  %call3 = call ptr @listAddNodeTail(ptr noundef %14, ptr noundef %15)
  %16 = load i32, ptr %flags.addr, align 4
  %call4 = call i32 @maskModuleConfigFlags(i32 noundef %16)
  store i32 %call4, ptr %flags.addr, align 4
  %17 = load ptr, ptr %module, align 8
  %name5 = getelementptr inbounds %struct.RedisModule, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %name5, align 8
  %19 = load ptr, ptr %name.addr, align 8
  %20 = load i32, ptr %flags.addr, align 4
  %21 = load ptr, ptr %new_config, align 8
  %22 = load i32, ptr %default_val.addr, align 4
  call void @addModuleBoolConfig(ptr noundef %18, ptr noundef %19, i32 noundef %20, ptr noundef %21, i32 noundef %22)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %23 = load i32, ptr %retval, align 4
  ret i32 %23
}

declare void @addModuleBoolConfig(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RegisterEnumConfig(ptr noundef %ctx, ptr noundef %name, i32 noundef %default_val, i32 noundef %flags, ptr noundef %enum_values, ptr noundef %int_values, i32 noundef %num_enum_vals, ptr noundef %getfn, ptr noundef %setfn, ptr noundef %applyfn, ptr noundef %privdata) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %default_val.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %enum_values.addr = alloca ptr, align 8
  %int_values.addr = alloca ptr, align 8
  %num_enum_vals.addr = alloca i32, align 4
  %getfn.addr = alloca ptr, align 8
  %setfn.addr = alloca ptr, align 8
  %applyfn.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %module = alloca ptr, align 8
  %new_config = alloca ptr, align 8
  %enum_vals = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %default_val, ptr %default_val.addr, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %enum_values, ptr %enum_values.addr, align 8
  store ptr %int_values, ptr %int_values.addr, align 8
  store i32 %num_enum_vals, ptr %num_enum_vals.addr, align 4
  store ptr %getfn, ptr %getfn.addr, align 8
  store ptr %setfn, ptr %setfn.addr, align 8
  store ptr %applyfn, ptr %applyfn.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module1, align 8
  store ptr %1, ptr %module, align 8
  %2 = load ptr, ptr %module, align 8
  %3 = load ptr, ptr %name.addr, align 8
  %4 = load i32, ptr %flags.addr, align 4
  %call = call i32 @moduleConfigValidityCheck(ptr noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %name.addr, align 8
  %6 = load ptr, ptr %applyfn.addr, align 8
  %7 = load ptr, ptr %privdata.addr, align 8
  %8 = load ptr, ptr %module, align 8
  %call2 = call ptr @createModuleConfig(ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8)
  store ptr %call2, ptr %new_config, align 8
  %9 = load ptr, ptr %getfn.addr, align 8
  %10 = load ptr, ptr %new_config, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %10, i32 0, i32 2
  store ptr %9, ptr %get_fn, align 8
  %11 = load ptr, ptr %setfn.addr, align 8
  %12 = load ptr, ptr %new_config, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %12, i32 0, i32 3
  store ptr %11, ptr %set_fn, align 8
  %13 = load i32, ptr %num_enum_vals.addr, align 4
  %add = add nsw i32 %13, 1
  %conv = sext i32 %add to i64
  %mul = mul i64 %conv, 16
  %call3 = call noalias ptr @zmalloc(i64 noundef %mul) #11
  store ptr %call3, ptr %enum_vals, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %num_enum_vals.addr, align 4
  %cmp = icmp slt i32 %14, %15
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load ptr, ptr %enum_values.addr, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %16, i64 %idxprom
  %18 = load ptr, ptr %arrayidx, align 8
  %call5 = call noalias ptr @zstrdup(ptr noundef %18)
  %19 = load ptr, ptr %enum_vals, align 8
  %20 = load i32, ptr %i, align 4
  %idxprom6 = sext i32 %20 to i64
  %arrayidx7 = getelementptr inbounds %struct.configEnum, ptr %19, i64 %idxprom6
  %name8 = getelementptr inbounds %struct.configEnum, ptr %arrayidx7, i32 0, i32 0
  store ptr %call5, ptr %name8, align 8
  %21 = load ptr, ptr %int_values.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %22 to i64
  %arrayidx10 = getelementptr inbounds i32, ptr %21, i64 %idxprom9
  %23 = load i32, ptr %arrayidx10, align 4
  %24 = load ptr, ptr %enum_vals, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom11 = sext i32 %25 to i64
  %arrayidx12 = getelementptr inbounds %struct.configEnum, ptr %24, i64 %idxprom11
  %val = getelementptr inbounds %struct.configEnum, ptr %arrayidx12, i32 0, i32 1
  store i32 %23, ptr %val, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %26 = load i32, ptr %i, align 4
  %inc = add nsw i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !90

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %enum_vals, align 8
  %28 = load i32, ptr %num_enum_vals.addr, align 4
  %idxprom13 = sext i32 %28 to i64
  %arrayidx14 = getelementptr inbounds %struct.configEnum, ptr %27, i64 %idxprom13
  %name15 = getelementptr inbounds %struct.configEnum, ptr %arrayidx14, i32 0, i32 0
  store ptr null, ptr %name15, align 8
  %29 = load ptr, ptr %enum_vals, align 8
  %30 = load i32, ptr %num_enum_vals.addr, align 4
  %idxprom16 = sext i32 %30 to i64
  %arrayidx17 = getelementptr inbounds %struct.configEnum, ptr %29, i64 %idxprom16
  %val18 = getelementptr inbounds %struct.configEnum, ptr %arrayidx17, i32 0, i32 1
  store i32 0, ptr %val18, align 8
  %31 = load ptr, ptr %module, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %31, i32 0, i32 8
  %32 = load ptr, ptr %module_configs, align 8
  %33 = load ptr, ptr %new_config, align 8
  %call19 = call ptr @listAddNodeTail(ptr noundef %32, ptr noundef %33)
  %34 = load i32, ptr %flags.addr, align 4
  %call20 = call i32 @maskModuleConfigFlags(i32 noundef %34)
  %35 = load i32, ptr %flags.addr, align 4
  %call21 = call i32 @maskModuleEnumConfigFlags(i32 noundef %35)
  %or = or i32 %call20, %call21
  store i32 %or, ptr %flags.addr, align 4
  %36 = load ptr, ptr %module, align 8
  %name22 = getelementptr inbounds %struct.RedisModule, ptr %36, i32 0, i32 1
  %37 = load ptr, ptr %name22, align 8
  %38 = load ptr, ptr %name.addr, align 8
  %39 = load i32, ptr %flags.addr, align 4
  %40 = load ptr, ptr %new_config, align 8
  %41 = load i32, ptr %default_val.addr, align 4
  %42 = load ptr, ptr %enum_vals, align 8
  call void @addModuleEnumConfig(ptr noundef %37, ptr noundef %38, i32 noundef %39, ptr noundef %40, i32 noundef %41, ptr noundef %42)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %43 = load i32, ptr %retval, align 4
  ret i32 %43
}

declare void @addModuleEnumConfig(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RegisterNumericConfig(ptr noundef %ctx, ptr noundef %name, i64 noundef %default_val, i32 noundef %flags, i64 noundef %min, i64 noundef %max, ptr noundef %getfn, ptr noundef %setfn, ptr noundef %applyfn, ptr noundef %privdata) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %default_val.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %min.addr = alloca i64, align 8
  %max.addr = alloca i64, align 8
  %getfn.addr = alloca ptr, align 8
  %setfn.addr = alloca ptr, align 8
  %applyfn.addr = alloca ptr, align 8
  %privdata.addr = alloca ptr, align 8
  %module = alloca ptr, align 8
  %new_config = alloca ptr, align 8
  %numeric_flags = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i64 %default_val, ptr %default_val.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i64 %min, ptr %min.addr, align 8
  store i64 %max, ptr %max.addr, align 8
  store ptr %getfn, ptr %getfn.addr, align 8
  store ptr %setfn, ptr %setfn.addr, align 8
  store ptr %applyfn, ptr %applyfn.addr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %module1 = getelementptr inbounds %struct.RedisModuleCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %module1, align 8
  store ptr %1, ptr %module, align 8
  %2 = load ptr, ptr %module, align 8
  %3 = load ptr, ptr %name.addr, align 8
  %4 = load i32, ptr %flags.addr, align 4
  %call = call i32 @moduleConfigValidityCheck(ptr noundef %2, ptr noundef %3, i32 noundef %4, i32 noundef 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %name.addr, align 8
  %6 = load ptr, ptr %applyfn.addr, align 8
  %7 = load ptr, ptr %privdata.addr, align 8
  %8 = load ptr, ptr %module, align 8
  %call2 = call ptr @createModuleConfig(ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8)
  store ptr %call2, ptr %new_config, align 8
  %9 = load ptr, ptr %getfn.addr, align 8
  %10 = load ptr, ptr %new_config, align 8
  %get_fn = getelementptr inbounds %struct.ModuleConfig, ptr %10, i32 0, i32 2
  store ptr %9, ptr %get_fn, align 8
  %11 = load ptr, ptr %setfn.addr, align 8
  %12 = load ptr, ptr %new_config, align 8
  %set_fn = getelementptr inbounds %struct.ModuleConfig, ptr %12, i32 0, i32 3
  store ptr %11, ptr %set_fn, align 8
  %13 = load ptr, ptr %module, align 8
  %module_configs = getelementptr inbounds %struct.RedisModule, ptr %13, i32 0, i32 8
  %14 = load ptr, ptr %module_configs, align 8
  %15 = load ptr, ptr %new_config, align 8
  %call3 = call ptr @listAddNodeTail(ptr noundef %14, ptr noundef %15)
  %16 = load i32, ptr %flags.addr, align 4
  %call4 = call i32 @maskModuleNumericConfigFlags(i32 noundef %16)
  store i32 %call4, ptr %numeric_flags, align 4
  %17 = load i32, ptr %flags.addr, align 4
  %call5 = call i32 @maskModuleConfigFlags(i32 noundef %17)
  store i32 %call5, ptr %flags.addr, align 4
  %18 = load ptr, ptr %module, align 8
  %name6 = getelementptr inbounds %struct.RedisModule, ptr %18, i32 0, i32 1
  %19 = load ptr, ptr %name6, align 8
  %20 = load ptr, ptr %name.addr, align 8
  %21 = load i32, ptr %flags.addr, align 4
  %22 = load ptr, ptr %new_config, align 8
  %23 = load i64, ptr %default_val.addr, align 8
  %24 = load i32, ptr %numeric_flags, align 4
  %25 = load i64, ptr %min.addr, align 8
  %26 = load i64, ptr %max.addr, align 8
  call void @addModuleNumericConfig(ptr noundef %19, ptr noundef %20, i32 noundef %21, ptr noundef %22, i64 noundef %23, i32 noundef %24, i64 noundef %25, i64 noundef %26)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %27 = load i32, ptr %retval, align 4
  ret i32 %27
}

declare void @addModuleNumericConfig(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i64 noundef, i32 noundef, i64 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_LoadConfigs(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %module5 = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false2, label %if.then

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %ctx.addr, align 8
  %module3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %module3, align 8
  %onload = getelementptr inbounds %struct.RedisModule, ptr %4, i32 0, i32 18
  %5 = load i32, ptr %onload, align 4
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %6 = load ptr, ptr %ctx.addr, align 8
  %module6 = getelementptr inbounds %struct.RedisModuleCtx, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %module6, align 8
  store ptr %7, ptr %module5, align 8
  %8 = load ptr, ptr %module5, align 8
  %call = call i32 @loadModuleConfigs(ptr noundef %8)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_RdbStreamCreateFromFile(ptr noundef %filename) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %stream = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 16) #11
  store ptr %call, ptr %stream, align 8
  %0 = load ptr, ptr %stream, align 8
  %type = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %0, i32 0, i32 0
  store i32 1, ptr %type, align 8
  %1 = load ptr, ptr %filename.addr, align 8
  %call1 = call noalias ptr @zstrdup(ptr noundef %1)
  %2 = load ptr, ptr %stream, align 8
  %data = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %2, i32 0, i32 1
  store ptr %call1, ptr %data, align 8
  %3 = load ptr, ptr %stream, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define dso_local void @RM_RdbStreamFree(ptr noundef %stream) #0 {
entry:
  %stream.addr = alloca ptr, align 8
  store ptr %stream, ptr %stream.addr, align 8
  %0 = load ptr, ptr %stream.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  switch i32 %1, label %sw.default [
    i32 1, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %stream.addr, align 8
  %data = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %data, align 8
  call void @zfree(ptr noundef %3)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.151, ptr noundef @.str.2, i32 noundef 12904)
  call void @abort() #13
  unreachable

sw.epilog:                                        ; preds = %sw.bb
  %4 = load ptr, ptr %stream.addr, align 8
  call void @zfree(ptr noundef %4)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RdbLoad(ptr noundef %ctx, ptr noundef %stream, i32 noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %stream.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %stream, ptr %stream.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %stream.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %cmp1 = icmp ne ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call ptr @__errno_location() #15
  store i32 95, ptr %call3, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  call void @disconnectSlaves()
  call void @freeReplicationBacklog()
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp5 = icmp ne i32 %3, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  call void @stopAppendOnly()
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end4
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp8 = icmp eq i32 %4, 1
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  call void @killRDBChild()
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  %call11 = call i64 @emptyData(i32 noundef -1, i32 noundef 0, ptr noundef null)
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %tobool12 = icmp ne ptr %5, null
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  call void @protectClient(ptr noundef %6)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %7 = load ptr, ptr %stream.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type, align 8
  %cmp15 = icmp eq i32 %8, 1
  %lnot = xor i1 %cmp15, true
  %lnot16 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool17 = icmp ne i64 %conv, 0
  br i1 %tobool17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end14
  br label %cond.end

cond.false:                                       ; preds = %if.end14
  call void @_serverAssert(ptr noundef @.str.152, ptr noundef @.str.2, i32 noundef 12956)
  call void @abort() #13
  unreachable

9:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %9, %cond.true
  %10 = load ptr, ptr %stream.addr, align 8
  %data = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %data, align 8
  %call18 = call i32 @rdbLoad(ptr noundef %11, ptr noundef null, i32 noundef 0)
  store i32 %call18, ptr %ret, align 4
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %tobool19 = icmp ne ptr %12, null
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %cond.end
  %13 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  call void @unprotectClient(ptr noundef %13)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %cond.end
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp22 = icmp ne i32 %14, 0
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %call25 = call i32 @startAppendOnly()
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %15 = load i32, ptr %ret, align 4
  %cmp27 = icmp ne i32 %15, 0
  br i1 %cmp27, label %if.then29, label %if.end33

if.then29:                                        ; preds = %if.end26
  %16 = load i32, ptr %ret, align 4
  %cmp30 = icmp eq i32 %16, 1
  %cond = select i1 %cmp30, i32 2, i32 5
  %call32 = call ptr @__errno_location() #15
  store i32 %cond, ptr %call32, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end26
  %call34 = call ptr @__errno_location() #15
  store i32 0, ptr %call34, align 4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end33, %if.then29, %if.then2, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare void @disconnectSlaves() #1

declare void @freeReplicationBacklog() #1

declare void @killRDBChild() #1

declare i64 @emptyData(i32 noundef, i32 noundef, ptr noundef) #1

declare i32 @rdbLoad(ptr noundef, ptr noundef, i32 noundef) #1

declare i32 @startAppendOnly() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RdbSave(ptr noundef %ctx, ptr noundef %stream, i32 noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %stream.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %stream, ptr %stream.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %stream.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call ptr @__errno_location() #15
  store i32 22, ptr %call, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %stream.addr, align 8
  %type = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %3, 1
  %lnot = xor i1 %cmp1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  call void @_serverAssert(ptr noundef @.str.152, ptr noundef @.str.2, i32 noundef 12992)
  call void @abort() #13
  unreachable

4:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load ptr, ptr %stream.addr, align 8
  %data = getelementptr inbounds %struct.RedisModuleRdbStream, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %data, align 8
  %call4 = call i32 @rdbSaveToFile(ptr noundef %6)
  %cmp5 = icmp ne i32 %call4, 0
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %cond.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %cond.end
  %call9 = call ptr @__errno_location() #15
  store i32 0, ptr %call9, align 4
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then7, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @rdbSaveToFile(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @moduleCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %subcmd = alloca ptr, align 8
  %help = alloca [9 x ptr], align 16
  %argv7 = alloca ptr, align 8
  %argc8 = alloca i32, align 4
  %argv30 = alloca ptr, align 8
  %argc31 = alloca i32, align 4
  %errmsg = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 1
  %2 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  store ptr %3, ptr %subcmd, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 11
  %5 = load i32, ptr %argc, align 8
  %cmp = icmp eq i32 %5, 2
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %6 = load ptr, ptr %subcmd, align 8
  %call = call i32 @strcasecmp(ptr noundef %6, ptr noundef @.str.153) #14
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %help, ptr align 16 @__const.moduleCommand.help, i64 72, i1 false)
  %7 = load ptr, ptr %c.addr, align 8
  %arraydecay = getelementptr inbounds [9 x ptr], ptr %help, i64 0, i64 0
  call void @addReplyHelp(ptr noundef %7, ptr noundef %arraydecay)
  br label %if.end87

if.else:                                          ; preds = %land.lhs.true, %entry
  %8 = load ptr, ptr %subcmd, align 8
  %call1 = call i32 @strcasecmp(ptr noundef %8, ptr noundef @.str.162) #14
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.else23, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %if.else
  %9 = load ptr, ptr %c.addr, align 8
  %argc4 = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 11
  %10 = load i32, ptr %argc4, align 8
  %cmp5 = icmp sge i32 %10, 3
  br i1 %cmp5, label %if.then6, label %if.else23

if.then6:                                         ; preds = %land.lhs.true3
  store ptr null, ptr %argv7, align 8
  store i32 0, ptr %argc8, align 4
  %11 = load ptr, ptr %c.addr, align 8
  %argc9 = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 11
  %12 = load i32, ptr %argc9, align 8
  %cmp10 = icmp sgt i32 %12, 3
  br i1 %cmp10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.then6
  %13 = load ptr, ptr %c.addr, align 8
  %argc12 = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 11
  %14 = load i32, ptr %argc12, align 8
  %sub = sub nsw i32 %14, 3
  store i32 %sub, ptr %argc8, align 4
  %15 = load ptr, ptr %c.addr, align 8
  %argv13 = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 12
  %16 = load ptr, ptr %argv13, align 8
  %arrayidx14 = getelementptr inbounds ptr, ptr %16, i64 3
  store ptr %arrayidx14, ptr %argv7, align 8
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.then6
  %17 = load ptr, ptr %c.addr, align 8
  %argv15 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 12
  %18 = load ptr, ptr %argv15, align 8
  %arrayidx16 = getelementptr inbounds ptr, ptr %18, i64 2
  %19 = load ptr, ptr %arrayidx16, align 8
  %ptr17 = getelementptr inbounds %struct.redisObject, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %ptr17, align 8
  %21 = load ptr, ptr %argv7, align 8
  %22 = load i32, ptr %argc8, align 4
  %call18 = call i32 @moduleLoad(ptr noundef %20, ptr noundef %21, i32 noundef %22, i32 noundef 0)
  %cmp19 = icmp eq i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.end
  %23 = load ptr, ptr %c.addr, align 8
  %24 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %23, ptr noundef %24)
  br label %if.end22

if.else21:                                        ; preds = %if.end
  %25 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %25, ptr noundef @.str.163)
  br label %if.end22

if.end22:                                         ; preds = %if.else21, %if.then20
  br label %if.end86

if.else23:                                        ; preds = %land.lhs.true3, %if.else
  %26 = load ptr, ptr %subcmd, align 8
  %call24 = call i32 @strcasecmp(ptr noundef %26, ptr noundef @.str.164) #14
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.else51, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %if.else23
  %27 = load ptr, ptr %c.addr, align 8
  %argc27 = getelementptr inbounds %struct.client, ptr %27, i32 0, i32 11
  %28 = load i32, ptr %argc27, align 8
  %cmp28 = icmp sge i32 %28, 3
  br i1 %cmp28, label %if.then29, label %if.else51

if.then29:                                        ; preds = %land.lhs.true26
  store ptr null, ptr %argv30, align 8
  store i32 0, ptr %argc31, align 4
  %29 = load ptr, ptr %c.addr, align 8
  %argc32 = getelementptr inbounds %struct.client, ptr %29, i32 0, i32 11
  %30 = load i32, ptr %argc32, align 8
  %cmp33 = icmp sgt i32 %30, 3
  br i1 %cmp33, label %if.then34, label %if.end39

if.then34:                                        ; preds = %if.then29
  %31 = load ptr, ptr %c.addr, align 8
  %argc35 = getelementptr inbounds %struct.client, ptr %31, i32 0, i32 11
  %32 = load i32, ptr %argc35, align 8
  %sub36 = sub nsw i32 %32, 3
  store i32 %sub36, ptr %argc31, align 4
  %33 = load ptr, ptr %c.addr, align 8
  %argv37 = getelementptr inbounds %struct.client, ptr %33, i32 0, i32 12
  %34 = load ptr, ptr %argv37, align 8
  %arrayidx38 = getelementptr inbounds ptr, ptr %34, i64 3
  store ptr %arrayidx38, ptr %argv30, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.then34, %if.then29
  %call40 = call i32 @parseLoadexArguments(ptr noundef %argv30, ptr noundef %argc31)
  %cmp41 = icmp eq i32 %call40, 0
  br i1 %cmp41, label %land.lhs.true42, label %if.else49

land.lhs.true42:                                  ; preds = %if.end39
  %35 = load ptr, ptr %c.addr, align 8
  %argv43 = getelementptr inbounds %struct.client, ptr %35, i32 0, i32 12
  %36 = load ptr, ptr %argv43, align 8
  %arrayidx44 = getelementptr inbounds ptr, ptr %36, i64 2
  %37 = load ptr, ptr %arrayidx44, align 8
  %ptr45 = getelementptr inbounds %struct.redisObject, ptr %37, i32 0, i32 2
  %38 = load ptr, ptr %ptr45, align 8
  %39 = load ptr, ptr %argv30, align 8
  %40 = load i32, ptr %argc31, align 4
  %call46 = call i32 @moduleLoad(ptr noundef %38, ptr noundef %39, i32 noundef %40, i32 noundef 1)
  %cmp47 = icmp eq i32 %call46, 0
  br i1 %cmp47, label %if.then48, label %if.else49

if.then48:                                        ; preds = %land.lhs.true42
  %41 = load ptr, ptr %c.addr, align 8
  %42 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %41, ptr noundef %42)
  br label %if.end50

if.else49:                                        ; preds = %land.lhs.true42, %if.end39
  %43 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 39), align 8
  call void @dictEmpty(ptr noundef %43, ptr noundef null)
  %44 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %44, ptr noundef @.str.163)
  br label %if.end50

if.end50:                                         ; preds = %if.else49, %if.then48
  br label %if.end85

if.else51:                                        ; preds = %land.lhs.true26, %if.else23
  %45 = load ptr, ptr %subcmd, align 8
  %call52 = call i32 @strcasecmp(ptr noundef %45, ptr noundef @.str.165) #14
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.else75, label %land.lhs.true54

land.lhs.true54:                                  ; preds = %if.else51
  %46 = load ptr, ptr %c.addr, align 8
  %argc55 = getelementptr inbounds %struct.client, ptr %46, i32 0, i32 11
  %47 = load i32, ptr %argc55, align 8
  %cmp56 = icmp eq i32 %47, 3
  br i1 %cmp56, label %if.then57, label %if.else75

if.then57:                                        ; preds = %land.lhs.true54
  store ptr null, ptr %errmsg, align 8
  %48 = load ptr, ptr %c.addr, align 8
  %argv58 = getelementptr inbounds %struct.client, ptr %48, i32 0, i32 12
  %49 = load ptr, ptr %argv58, align 8
  %arrayidx59 = getelementptr inbounds ptr, ptr %49, i64 2
  %50 = load ptr, ptr %arrayidx59, align 8
  %ptr60 = getelementptr inbounds %struct.redisObject, ptr %50, i32 0, i32 2
  %51 = load ptr, ptr %ptr60, align 8
  %call61 = call i32 @moduleUnload(ptr noundef %51, ptr noundef %errmsg)
  %cmp62 = icmp eq i32 %call61, 0
  br i1 %cmp62, label %if.then63, label %if.else64

if.then63:                                        ; preds = %if.then57
  %52 = load ptr, ptr %c.addr, align 8
  %53 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %52, ptr noundef %53)
  br label %if.end74

if.else64:                                        ; preds = %if.then57
  %54 = load ptr, ptr %errmsg, align 8
  %cmp65 = icmp eq ptr %54, null
  br i1 %cmp65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.else64
  store ptr @.str.166, ptr %errmsg, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then66, %if.else64
  %55 = load ptr, ptr %c.addr, align 8
  %56 = load ptr, ptr %errmsg, align 8
  call void (ptr, ptr, ...) @addReplyErrorFormat(ptr noundef %55, ptr noundef @.str.167, ptr noundef %56)
  br label %do.body

do.body:                                          ; preds = %if.end67
  %57 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp68 = icmp slt i32 3, %57
  br i1 %cmp68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %do.body
  br label %do.end

if.end70:                                         ; preds = %do.body
  %58 = load ptr, ptr %c.addr, align 8
  %argv71 = getelementptr inbounds %struct.client, ptr %58, i32 0, i32 12
  %59 = load ptr, ptr %argv71, align 8
  %arrayidx72 = getelementptr inbounds ptr, ptr %59, i64 2
  %60 = load ptr, ptr %arrayidx72, align 8
  %ptr73 = getelementptr inbounds %struct.redisObject, ptr %60, i32 0, i32 2
  %61 = load ptr, ptr %ptr73, align 8
  %62 = load ptr, ptr %errmsg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.168, ptr noundef %61, ptr noundef %62)
  br label %do.end

do.end:                                           ; preds = %if.end70, %if.then69
  br label %if.end74

if.end74:                                         ; preds = %do.end, %if.then63
  br label %if.end84

if.else75:                                        ; preds = %land.lhs.true54, %if.else51
  %63 = load ptr, ptr %subcmd, align 8
  %call76 = call i32 @strcasecmp(ptr noundef %63, ptr noundef @.str.169) #14
  %tobool77 = icmp ne i32 %call76, 0
  br i1 %tobool77, label %if.else82, label %land.lhs.true78

land.lhs.true78:                                  ; preds = %if.else75
  %64 = load ptr, ptr %c.addr, align 8
  %argc79 = getelementptr inbounds %struct.client, ptr %64, i32 0, i32 11
  %65 = load i32, ptr %argc79, align 8
  %cmp80 = icmp eq i32 %65, 2
  br i1 %cmp80, label %if.then81, label %if.else82

if.then81:                                        ; preds = %land.lhs.true78
  %66 = load ptr, ptr %c.addr, align 8
  call void @addReplyLoadedModules(ptr noundef %66)
  br label %if.end83

if.else82:                                        ; preds = %land.lhs.true78, %if.else75
  %67 = load ptr, ptr %c.addr, align 8
  call void @addReplySubcommandSyntaxError(ptr noundef %67)
  br label %if.end87

if.end83:                                         ; preds = %if.then81
  br label %if.end84

if.end84:                                         ; preds = %if.end83, %if.end74
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %if.end50
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.end22
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.else82, %if.then
  ret void
}

declare void @addReplyHelp(ptr noundef, ptr noundef) #1

declare void @addReplySubcommandSyntaxError(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i64 @moduleCount() #0 {
entry:
  %0 = load ptr, ptr @modules, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %0, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %1 = load i64, ptr %arrayidx, align 8
  %2 = load ptr, ptr @modules, align 8
  %ht_used1 = getelementptr inbounds %struct.dict, ptr %2, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [2 x i64], ptr %ht_used1, i64 0, i64 1
  %3 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %1, %3
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetLRU(ptr noundef %key, i64 noundef %lru_idle) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %lru_idle.addr = alloca i64, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %lru_idle, ptr %lru_idle.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %4 = load i64, ptr %lru_idle.addr, align 8
  %5 = load i64, ptr %lru_idle.addr, align 8
  %cmp = icmp sge i64 %5, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %call = call i32 @LRU_CLOCK()
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call, %cond.true ], [ 0, %cond.false ]
  %conv = zext i32 %cond to i64
  %call2 = call i32 @objectSetLRUOrLFU(ptr noundef %3, i64 noundef -1, i64 noundef %4, i64 noundef %conv, i32 noundef 1)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %cond.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %cond.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @objectSetLRUOrLFU(ptr noundef, i64 noundef, i64 noundef, i64 noundef, i32 noundef) #1

declare i32 @LRU_CLOCK() #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetLRU(ptr noundef %key, ptr noundef %lru_idle) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %lru_idle.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %lru_idle, ptr %lru_idle.addr, align 8
  %0 = load ptr, ptr %lru_idle.addr, align 8
  store i64 -1, ptr %0, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 316), align 8
  %and = and i32 %3, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value4, align 8
  %call = call i64 @estimateObjectIdleTime(ptr noundef %5)
  %6 = load ptr, ptr %lru_idle.addr, align 8
  store i64 %call, ptr %6, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i64 @estimateObjectIdleTime(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_SetLFU(ptr noundef %key, i64 noundef %lfu_freq) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %lfu_freq.addr = alloca i64, align 8
  store ptr %key, ptr %key.addr, align 8
  store i64 %lfu_freq, ptr %lfu_freq.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %value1 = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %value1, align 8
  %4 = load i64, ptr %lfu_freq.addr, align 8
  %call = call i32 @objectSetLRUOrLFU(ptr noundef %3, i64 noundef %4, i64 noundef -1, i64 noundef 0, i32 noundef 1)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetLFU(ptr noundef %key, ptr noundef %lfu_freq) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %lfu_freq.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %lfu_freq, ptr %lfu_freq.addr, align 8
  %0 = load ptr, ptr %lfu_freq.addr, align 8
  store i64 -1, ptr %0, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 316), align 8
  %and = and i32 %3, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %key.addr, align 8
  %value3 = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value3, align 8
  %call = call i64 @LFUDecrAndReturn(ptr noundef %5)
  %6 = load ptr, ptr %lfu_freq.addr, align 8
  store i64 %call, ptr %6, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i64 @LFUDecrAndReturn(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetModuleOptionsAll() #0 {
entry:
  ret i32 15
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetContextFlagsAll() #0 {
entry:
  ret i32 33554431
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetKeyspaceNotificationFlagsAll() #0 {
entry:
  ret i32 32767
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetServerVersion() #0 {
entry:
  ret i32 16777215
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetTypeMethodVersion() #0 {
entry:
  ret i32 5
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_ModuleTypeReplaceValue(ptr noundef %key, ptr noundef %mt, ptr noundef %new_value, ptr noundef %old_value) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %mt.addr = alloca ptr, align 8
  %new_value.addr = alloca ptr, align 8
  %old_value.addr = alloca ptr, align 8
  %mv = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %mt, ptr %mt.addr, align 8
  store ptr %new_value, ptr %new_value.addr, align 8
  store ptr %old_value, ptr %old_value.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %mode = getelementptr inbounds %struct.RedisModuleKey, ptr %0, i32 0, i32 5
  %1 = load i32, ptr %mode, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %key.addr, align 8
  %iter = getelementptr inbounds %struct.RedisModuleKey, ptr %2, i32 0, i32 4
  %3 = load ptr, ptr %iter, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %key.addr, align 8
  %value = getelementptr inbounds %struct.RedisModuleKey, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %value, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %lor.lhs.false3, label %if.then5

lor.lhs.false3:                                   ; preds = %if.end
  %6 = load ptr, ptr %key.addr, align 8
  %value4 = getelementptr inbounds %struct.RedisModuleKey, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %value4, align 8
  %bf.load = load i32, ptr %7, align 8
  %bf.clear = and i32 %bf.load, 15
  %cmp = icmp ne i32 %bf.clear, 5
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false3, %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false3
  %8 = load ptr, ptr %key.addr, align 8
  %value7 = getelementptr inbounds %struct.RedisModuleKey, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %value7, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %ptr, align 8
  store ptr %10, ptr %mv, align 8
  %11 = load ptr, ptr %mv, align 8
  %type = getelementptr inbounds %struct.moduleValue, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %type, align 8
  %13 = load ptr, ptr %mt.addr, align 8
  %cmp8 = icmp ne ptr %12, %13
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  store i32 1, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %14 = load ptr, ptr %old_value.addr, align 8
  %tobool11 = icmp ne ptr %14, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %15 = load ptr, ptr %mv, align 8
  %value13 = getelementptr inbounds %struct.moduleValue, ptr %15, i32 0, i32 1
  %16 = load ptr, ptr %value13, align 8
  %17 = load ptr, ptr %old_value.addr, align 8
  store ptr %16, ptr %17, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %18 = load ptr, ptr %new_value.addr, align 8
  %19 = load ptr, ptr %mv, align 8
  %value15 = getelementptr inbounds %struct.moduleValue, ptr %19, i32 0, i32 1
  store ptr %18, ptr %value15, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then9, %if.then5, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetCommandKeysWithFlags(ptr noundef %ctx, ptr noundef %argv, i32 noundef %argc, ptr noundef %num_keys, ptr noundef %out_flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %num_keys.addr = alloca ptr, align 8
  %out_flags.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %res = alloca ptr, align 8
  %result = alloca %struct.getKeysResult, align 8
  %size = alloca i64, align 8
  %i = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %num_keys, ptr %num_keys.addr, align 8
  store ptr %out_flags, ptr %out_flags.addr, align 8
  store ptr null, ptr %res, align 8
  %0 = load ptr, ptr %argv.addr, align 8
  %1 = load i32, ptr %argc.addr, align 4
  %call = call ptr @lookupCommand(ptr noundef %0, i32 noundef %1)
  store ptr %call, ptr %cmd, align 8
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @__errno_location() #15
  store i32 2, ptr %call1, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %cmd, align 8
  %call2 = call i32 @doesCommandHaveKeys(ptr noundef %2)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %call4 = call ptr @__errno_location() #15
  store i32 0, ptr %call4, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %3 = load ptr, ptr %cmd, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 13
  %4 = load i32, ptr %arity, align 8
  %cmp6 = icmp sgt i32 %4, 0
  br i1 %cmp6, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end5
  %5 = load ptr, ptr %cmd, align 8
  %arity7 = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 13
  %6 = load i32, ptr %arity7, align 8
  %7 = load i32, ptr %argc.addr, align 4
  %cmp8 = icmp ne i32 %6, %7
  br i1 %cmp8, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end5
  %8 = load i32, ptr %argc.addr, align 4
  %9 = load ptr, ptr %cmd, align 8
  %arity9 = getelementptr inbounds %struct.redisCommand, ptr %9, i32 0, i32 13
  %10 = load i32, ptr %arity9, align 8
  %sub = sub nsw i32 0, %10
  %cmp10 = icmp slt i32 %8, %sub
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %call12 = call ptr @__errno_location() #15
  store i32 22, ptr %call12, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %lor.lhs.false
  call void @llvm.memset.p0.i64(ptr align 8 %result, i8 0, i64 2064, i1 false)
  %11 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 3
  store i32 256, ptr %11, align 4
  %12 = load ptr, ptr %cmd, align 8
  %13 = load ptr, ptr %argv.addr, align 8
  %14 = load i32, ptr %argc.addr, align 4
  %call14 = call i32 @getKeysFromCommand(ptr noundef %12, ptr noundef %13, i32 noundef %14, ptr noundef %result)
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 2
  %15 = load i32, ptr %numkeys, align 8
  %16 = load ptr, ptr %num_keys.addr, align 8
  store i32 %15, ptr %16, align 4
  %numkeys15 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 2
  %17 = load i32, ptr %numkeys15, align 8
  %tobool16 = icmp ne i32 %17, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.end13
  %call18 = call ptr @__errno_location() #15
  store i32 0, ptr %call18, align 4
  call void @getKeysFreeResult(ptr noundef %result)
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end13
  %numkeys20 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 2
  %18 = load i32, ptr %numkeys20, align 8
  %conv = sext i32 %18 to i64
  %mul = mul i64 4, %conv
  store i64 %mul, ptr %size, align 8
  %19 = load i64, ptr %size, align 8
  %call21 = call noalias ptr @zmalloc(i64 noundef %19) #11
  store ptr %call21, ptr %res, align 8
  %20 = load ptr, ptr %out_flags.addr, align 8
  %tobool22 = icmp ne ptr %20, null
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end19
  %21 = load i64, ptr %size, align 8
  %call24 = call noalias ptr @zmalloc(i64 noundef %21) #11
  %22 = load ptr, ptr %out_flags.addr, align 8
  store ptr %call24, ptr %22, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end19
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end25
  %23 = load i32, ptr %i, align 4
  %numkeys26 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 2
  %24 = load i32, ptr %numkeys26, align 8
  %cmp27 = icmp slt i32 %23, %24
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %keys = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 1
  %25 = load ptr, ptr %keys, align 8
  %26 = load i32, ptr %i, align 4
  %idxprom = sext i32 %26 to i64
  %arrayidx = getelementptr inbounds %struct.keyReference, ptr %25, i64 %idxprom
  %pos = getelementptr inbounds %struct.keyReference, ptr %arrayidx, i32 0, i32 0
  %27 = load i32, ptr %pos, align 4
  %28 = load ptr, ptr %res, align 8
  %29 = load i32, ptr %i, align 4
  %idxprom29 = sext i32 %29 to i64
  %arrayidx30 = getelementptr inbounds i32, ptr %28, i64 %idxprom29
  store i32 %27, ptr %arrayidx30, align 4
  %30 = load ptr, ptr %out_flags.addr, align 8
  %tobool31 = icmp ne ptr %30, null
  br i1 %tobool31, label %if.then32, label %if.end41

if.then32:                                        ; preds = %for.body
  %keys33 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 1
  %31 = load ptr, ptr %keys33, align 8
  %32 = load i32, ptr %i, align 4
  %idxprom34 = sext i32 %32 to i64
  %arrayidx35 = getelementptr inbounds %struct.keyReference, ptr %31, i64 %idxprom34
  %flags = getelementptr inbounds %struct.keyReference, ptr %arrayidx35, i32 0, i32 1
  %33 = load i32, ptr %flags, align 4
  %conv36 = sext i32 %33 to i64
  %call37 = call i64 @moduleConvertKeySpecsFlags(i64 noundef %conv36, i32 noundef 0)
  %conv38 = trunc i64 %call37 to i32
  %34 = load ptr, ptr %out_flags.addr, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = load i32, ptr %i, align 4
  %idxprom39 = sext i32 %36 to i64
  %arrayidx40 = getelementptr inbounds i32, ptr %35, i64 %idxprom39
  store i32 %conv38, ptr %arrayidx40, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then32, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end41
  %37 = load i32, ptr %i, align 4
  %inc = add nsw i32 %37, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !91

for.end:                                          ; preds = %for.cond
  %38 = load ptr, ptr %res, align 8
  store ptr %38, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then17, %if.then11, %if.then3, %if.then
  %39 = load ptr, ptr %retval, align 8
  ret ptr %39
}

declare i32 @doesCommandHaveKeys(ptr noundef) #1

declare i32 @getKeysFromCommand(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #1

declare void @getKeysFreeResult(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetCommandKeys(ptr noundef %ctx, ptr noundef %argv, i32 noundef %argc, ptr noundef %num_keys) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %num_keys.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %num_keys, ptr %num_keys.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %argv.addr, align 8
  %2 = load i32, ptr %argc.addr, align 4
  %3 = load ptr, ptr %num_keys.addr, align 8
  %call = call ptr @RM_GetCommandKeysWithFlags(ptr noundef %0, ptr noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef null)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetCurrentCommandName(ptr noundef %ctx) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %client = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %client, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false2, label %if.then

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %ctx.addr, align 8
  %client3 = getelementptr inbounds %struct.RedisModuleCtx, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %client3, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 17
  %5 = load ptr, ptr %cmd, align 8
  %tobool4 = icmp ne ptr %5, null
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %6 = load ptr, ptr %ctx.addr, align 8
  %client5 = getelementptr inbounds %struct.RedisModuleCtx, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %client5, align 8
  %cmd6 = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 17
  %8 = load ptr, ptr %cmd6, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %8, i32 0, i32 27
  %9 = load ptr, ptr %fullname, align 8
  store ptr %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_RegisterDefragFunc(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %module = getelementptr inbounds %struct.RedisModuleCtx, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %module, align 8
  %defrag_cb = getelementptr inbounds %struct.RedisModule, ptr %2, i32 0, i32 15
  store ptr %0, ptr %defrag_cb, align 8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DefragShouldStop(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %endtime = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %endtime, align 8
  %cmp = icmp ne i64 %1, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %endtime1 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %2, i32 0, i32 0
  %3 = load i64, ptr %endtime1, align 8
  %call = call i64 @ustime()
  %cmp2 = icmp slt i64 %3, %call
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DefragCursorSet(ptr noundef %ctx, i64 noundef %cursor) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %cursor.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %cursor, ptr %cursor.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cursor1 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %cursor1, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, ptr %cursor.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %cursor2 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %cursor2, align 8
  store i64 %2, ptr %4, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_DefragCursorGet(ptr noundef %ctx, ptr noundef %cursor) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %cursor.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cursor, ptr %cursor.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cursor1 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %cursor1, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %cursor2 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %cursor2, align 8
  %4 = load i64, ptr %3, align 8
  %5 = load ptr, ptr %cursor.addr, align 8
  store i64 %4, ptr %5, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DefragAlloc(ptr noundef %ctx, ptr noundef %ptr) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %call = call ptr @activeDefragAlloc(ptr noundef %0)
  ret ptr %call
}

declare ptr @activeDefragAlloc(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_DefragRedisModuleString(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %call = call ptr @activeDefragStringOb(ptr noundef %0)
  ret ptr %call
}

declare ptr @activeDefragStringOb(ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleLateDefrag(ptr noundef %key, ptr noundef %value, ptr noundef %cursor, i64 noundef %endtime, i32 noundef %dbid) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %cursor.addr = alloca ptr, align 8
  %endtime.addr = alloca i64, align 8
  %dbid.addr = alloca i32, align 4
  %mv = alloca ptr, align 8
  %mt = alloca ptr, align 8
  %defrag_ctx = alloca %struct.RedisModuleDefragCtx, align 8
  %ret = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store ptr %cursor, ptr %cursor.addr, align 8
  store i64 %endtime, ptr %endtime.addr, align 8
  store i32 %dbid, ptr %dbid.addr, align 4
  %0 = load ptr, ptr %value.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  store ptr %1, ptr %mv, align 8
  %2 = load ptr, ptr %mv, align 8
  %type = getelementptr inbounds %struct.moduleValue, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %type, align 8
  store ptr %3, ptr %mt, align 8
  %endtime1 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i32 0, i32 0
  %4 = load i64, ptr %endtime.addr, align 8
  store i64 %4, ptr %endtime1, align 8
  %cursor2 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i32 0, i32 1
  %5 = load ptr, ptr %cursor.addr, align 8
  store ptr %5, ptr %cursor2, align 8
  %key3 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i32 0, i32 2
  %6 = load ptr, ptr %key.addr, align 8
  store ptr %6, ptr %key3, align 8
  %dbid4 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i32 0, i32 3
  %7 = load i32, ptr %dbid.addr, align 4
  store i32 %7, ptr %dbid4, align 8
  store i32 0, ptr %ret, align 4
  %8 = load ptr, ptr %mt, align 8
  %defrag = getelementptr inbounds %struct.RedisModuleType, ptr %8, i32 0, i32 11
  %9 = load ptr, ptr %defrag, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load ptr, ptr %mt, align 8
  %defrag5 = getelementptr inbounds %struct.RedisModuleType, ptr %10, i32 0, i32 11
  %11 = load ptr, ptr %defrag5, align 8
  %12 = load ptr, ptr %key.addr, align 8
  %13 = load ptr, ptr %mv, align 8
  %value6 = getelementptr inbounds %struct.moduleValue, ptr %13, i32 0, i32 1
  %call = call i32 %11(ptr noundef %defrag_ctx, ptr noundef %12, ptr noundef %value6)
  store i32 %call, ptr %ret, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %14 = load i32, ptr %ret, align 4
  %tobool7 = icmp ne i32 %14, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end
  %15 = load ptr, ptr %cursor.addr, align 8
  store i64 0, ptr %15, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then8
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define dso_local i32 @moduleDefragValue(ptr noundef %key, ptr noundef %value, i32 noundef %dbid) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  %dbid.addr = alloca i32, align 4
  %mv = alloca ptr, align 8
  %mt = alloca ptr, align 8
  %newmv = alloca ptr, align 8
  %effort = alloca i64, align 8
  %defrag_ctx = alloca %struct.RedisModuleDefragCtx, align 8
  store ptr %key, ptr %key.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store i32 %dbid, ptr %dbid.addr, align 4
  %0 = load ptr, ptr %value.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %ptr, align 8
  store ptr %1, ptr %mv, align 8
  %2 = load ptr, ptr %mv, align 8
  %type = getelementptr inbounds %struct.moduleValue, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %type, align 8
  store ptr %3, ptr %mt, align 8
  %4 = load ptr, ptr %mv, align 8
  %call = call ptr @activeDefragAlloc(ptr noundef %4)
  store ptr %call, ptr %newmv, align 8
  %5 = load ptr, ptr %newmv, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %newmv, align 8
  store ptr %6, ptr %mv, align 8
  %7 = load ptr, ptr %value.addr, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %7, i32 0, i32 2
  store ptr %6, ptr %ptr1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load ptr, ptr %mt, align 8
  %defrag = getelementptr inbounds %struct.RedisModuleType, ptr %8, i32 0, i32 11
  %9 = load ptr, ptr %defrag, align 8
  %tobool2 = icmp ne ptr %9, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %10 = load ptr, ptr %key.addr, align 8
  %11 = load ptr, ptr %value.addr, align 8
  %12 = load i32, ptr %dbid.addr, align 4
  %call5 = call i64 @moduleGetFreeEffort(ptr noundef %10, ptr noundef %11, i32 noundef %12)
  store i64 %call5, ptr %effort, align 8
  %13 = load i64, ptr %effort, align 8
  %tobool6 = icmp ne i64 %13, 0
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end4
  store i64 -1, ptr %effort, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %14 = load i64, ptr %effort, align 8
  %15 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 171), align 8
  %cmp = icmp ugt i64 %14, %15
  br i1 %cmp, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end8
  store i32 0, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end8
  %endtime = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i32 0, i32 0
  store i64 0, ptr %endtime, align 8
  %cursor = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i32 0, i32 1
  store ptr null, ptr %cursor, align 8
  %key11 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i32 0, i32 2
  %16 = load ptr, ptr %key.addr, align 8
  store ptr %16, ptr %key11, align 8
  %dbid12 = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %defrag_ctx, i32 0, i32 3
  %17 = load i32, ptr %dbid.addr, align 4
  store i32 %17, ptr %dbid12, align 8
  %18 = load ptr, ptr %mt, align 8
  %defrag13 = getelementptr inbounds %struct.RedisModuleType, ptr %18, i32 0, i32 11
  %19 = load ptr, ptr %defrag13, align 8
  %20 = load ptr, ptr %key.addr, align 8
  %21 = load ptr, ptr %mv, align 8
  %value14 = getelementptr inbounds %struct.moduleValue, ptr %21, i32 0, i32 1
  %call15 = call i32 %19(ptr noundef %defrag_ctx, ptr noundef %20, ptr noundef %value14)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.then3
  %22 = load i32, ptr %retval, align 4
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define dso_local void @moduleDefragGlobals() #0 {
entry:
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %module = alloca ptr, align 8
  %defrag_ctx = alloca %struct.RedisModuleDefragCtx, align 8
  %0 = load ptr, ptr @modules, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %module, align 8
  %3 = load ptr, ptr %module, align 8
  %defrag_cb = getelementptr inbounds %struct.RedisModule, ptr %3, i32 0, i32 15
  %4 = load ptr, ptr %defrag_cb, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !92

if.end:                                           ; preds = %while.body
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %defrag_ctx, ptr align 8 @__const.moduleDefragGlobals.defrag_ctx, i64 32, i1 false)
  %5 = load ptr, ptr %module, align 8
  %defrag_cb3 = getelementptr inbounds %struct.RedisModule, ptr %5, i32 0, i32 15
  %6 = load ptr, ptr %defrag_cb3, align 8
  call void %6(ptr noundef %defrag_ctx)
  br label %while.cond, !llvm.loop !92

while.end:                                        ; preds = %while.cond
  %7 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %7)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @RM_GetKeyNameFromDefragCtx(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %key = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %key, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @RM_GetDbIdFromDefragCtx(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %dbid = getelementptr inbounds %struct.RedisModuleDefragCtx, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %dbid, align 8
  ret i32 %1
}

declare void @listTypeReleaseIterator(ptr noundef) #1

declare ptr @callReplyCreate(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @isPowerOfTwo(i64 noundef %v) #0 {
entry:
  %v.addr = alloca i64, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load i64, ptr %v.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i64, ptr %v.addr, align 8
  %2 = load i64, ptr %v.addr, align 8
  %sub = sub i64 %2, 1
  %and = and i64 %1, %sub
  %tobool1 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool1, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal i32 @moduleValidateCommandArgs(ptr noundef %args, ptr noundef %version) #0 {
entry:
  %retval = alloca i32, align 4
  %args.addr = alloca ptr, align 8
  %version.addr = alloca ptr, align 8
  %j = alloca i64, align 8
  %arg = alloca ptr, align 8
  %arg_type_error = alloca i32, align 4
  store ptr %args, ptr %args.addr, align 8
  store ptr %version, ptr %version.addr, align 8
  %0 = load ptr, ptr %args.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, ptr %j, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load ptr, ptr %version.addr, align 8
  %2 = load ptr, ptr %args.addr, align 8
  %3 = load i64, ptr %j, align 8
  %conv = trunc i64 %3 to i32
  %call = call ptr @moduleCmdArgAt(ptr noundef %1, ptr noundef %2, i32 noundef %conv)
  %name = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %call, i32 0, i32 0
  %4 = load ptr, ptr %name, align 8
  %cmp1 = icmp ne ptr %4, null
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %version.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %7 = load i64, ptr %j, align 8
  %conv3 = trunc i64 %7 to i32
  %call4 = call ptr @moduleCmdArgAt(ptr noundef %5, ptr noundef %6, i32 noundef %conv3)
  store ptr %call4, ptr %arg, align 8
  store i32 0, ptr %arg_type_error, align 4
  %8 = load ptr, ptr %arg, align 8
  %type = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %8, i32 0, i32 1
  %9 = load i32, ptr %type, align 8
  %call5 = call i32 @moduleConvertArgType(i32 noundef %9, ptr noundef %arg_type_error)
  %10 = load i32, ptr %arg_type_error, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then6, label %if.end13

if.then6:                                         ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then6
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp7 = icmp slt i32 3, %11
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.body
  br label %do.end

if.end10:                                         ; preds = %do.body
  %12 = load ptr, ptr %arg, align 8
  %name11 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %name11, align 8
  %14 = load ptr, ptr %arg, align 8
  %type12 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %type12, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.532, ptr noundef %13, i32 noundef %15)
  br label %do.end

do.end:                                           ; preds = %if.end10, %if.then9
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %for.body
  %16 = load ptr, ptr %arg, align 8
  %type14 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %16, i32 0, i32 1
  %17 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %17, 6
  br i1 %cmp15, label %land.lhs.true, label %if.end26

land.lhs.true:                                    ; preds = %if.end13
  %18 = load ptr, ptr %arg, align 8
  %token = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %token, align 8
  %tobool17 = icmp ne ptr %19, null
  br i1 %tobool17, label %if.end26, label %if.then18

if.then18:                                        ; preds = %land.lhs.true
  br label %do.body19

do.body19:                                        ; preds = %if.then18
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp20 = icmp slt i32 3, %20
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %do.body19
  br label %do.end25

if.end23:                                         ; preds = %do.body19
  %21 = load ptr, ptr %args.addr, align 8
  %22 = load i64, ptr %j, align 8
  %arrayidx = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %21, i64 %22
  %name24 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %arrayidx, i32 0, i32 0
  %23 = load ptr, ptr %name24, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.533, ptr noundef %23)
  br label %do.end25

do.end25:                                         ; preds = %if.end23, %if.then22
  store i32 0, ptr %retval, align 4
  br label %return

if.end26:                                         ; preds = %land.lhs.true, %if.end13
  %24 = load ptr, ptr %arg, align 8
  %type27 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %24, i32 0, i32 1
  %25 = load i32, ptr %type27, align 8
  %cmp28 = icmp eq i32 %25, 3
  br i1 %cmp28, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.end26
  %26 = load ptr, ptr %arg, align 8
  %key_spec_index = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %26, i32 0, i32 2
  %27 = load i32, ptr %key_spec_index, align 4
  %cmp31 = icmp slt i32 %27, 0
  br i1 %cmp31, label %if.then33, label %if.end41

if.then33:                                        ; preds = %if.then30
  br label %do.body34

do.body34:                                        ; preds = %if.then33
  %28 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp35 = icmp slt i32 3, %28
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %do.body34
  br label %do.end40

if.end38:                                         ; preds = %do.body34
  %29 = load ptr, ptr %arg, align 8
  %name39 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %name39, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.534, ptr noundef %30)
  br label %do.end40

do.end40:                                         ; preds = %if.end38, %if.then37
  store i32 0, ptr %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.then30
  br label %if.end58

if.else:                                          ; preds = %if.end26
  %31 = load ptr, ptr %arg, align 8
  %key_spec_index42 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %31, i32 0, i32 2
  %32 = load i32, ptr %key_spec_index42, align 4
  %cmp43 = icmp ne i32 %32, -1
  br i1 %cmp43, label %land.lhs.true45, label %if.end57

land.lhs.true45:                                  ; preds = %if.else
  %33 = load ptr, ptr %arg, align 8
  %key_spec_index46 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %33, i32 0, i32 2
  %34 = load i32, ptr %key_spec_index46, align 4
  %cmp47 = icmp ne i32 %34, 0
  br i1 %cmp47, label %if.then49, label %if.end57

if.then49:                                        ; preds = %land.lhs.true45
  br label %do.body50

do.body50:                                        ; preds = %if.then49
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp51 = icmp slt i32 3, %35
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %do.body50
  br label %do.end56

if.end54:                                         ; preds = %do.body50
  %36 = load ptr, ptr %arg, align 8
  %name55 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %36, i32 0, i32 0
  %37 = load ptr, ptr %name55, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.535, ptr noundef %37)
  br label %do.end56

do.end56:                                         ; preds = %if.end54, %if.then53
  store i32 0, ptr %retval, align 4
  br label %return

if.end57:                                         ; preds = %land.lhs.true45, %if.else
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end41
  %38 = load ptr, ptr %arg, align 8
  %flags = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %38, i32 0, i32 6
  %39 = load i32, ptr %flags, align 8
  %and = and i32 %39, -8
  %tobool59 = icmp ne i32 %and, 0
  br i1 %tobool59, label %if.then60, label %if.end68

if.then60:                                        ; preds = %if.end58
  br label %do.body61

do.body61:                                        ; preds = %if.then60
  %40 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp62 = icmp slt i32 3, %40
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %do.body61
  br label %do.end67

if.end65:                                         ; preds = %do.body61
  %41 = load ptr, ptr %arg, align 8
  %name66 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %41, i32 0, i32 0
  %42 = load ptr, ptr %name66, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.536, ptr noundef %42)
  br label %do.end67

do.end67:                                         ; preds = %if.end65, %if.then64
  store i32 0, ptr %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.end58
  %43 = load ptr, ptr %arg, align 8
  %type69 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %43, i32 0, i32 1
  %44 = load i32, ptr %type69, align 8
  %cmp70 = icmp eq i32 %44, 7
  br i1 %cmp70, label %if.then75, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end68
  %45 = load ptr, ptr %arg, align 8
  %type72 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %45, i32 0, i32 1
  %46 = load i32, ptr %type72, align 8
  %cmp73 = icmp eq i32 %46, 8
  br i1 %cmp73, label %if.then75, label %if.else92

if.then75:                                        ; preds = %lor.lhs.false, %if.end68
  %47 = load ptr, ptr %arg, align 8
  %subargs = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %47, i32 0, i32 8
  %48 = load ptr, ptr %subargs, align 8
  %cmp76 = icmp eq ptr %48, null
  br i1 %cmp76, label %if.then78, label %if.end86

if.then78:                                        ; preds = %if.then75
  br label %do.body79

do.body79:                                        ; preds = %if.then78
  %49 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp80 = icmp slt i32 3, %49
  br i1 %cmp80, label %if.then82, label %if.end83

if.then82:                                        ; preds = %do.body79
  br label %do.end85

if.end83:                                         ; preds = %do.body79
  %50 = load ptr, ptr %arg, align 8
  %name84 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %50, i32 0, i32 0
  %51 = load ptr, ptr %name84, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.537, ptr noundef %51)
  br label %do.end85

do.end85:                                         ; preds = %if.end83, %if.then82
  store i32 0, ptr %retval, align 4
  br label %return

if.end86:                                         ; preds = %if.then75
  %52 = load ptr, ptr %arg, align 8
  %subargs87 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %52, i32 0, i32 8
  %53 = load ptr, ptr %subargs87, align 8
  %54 = load ptr, ptr %version.addr, align 8
  %call88 = call i32 @moduleValidateCommandArgs(ptr noundef %53, ptr noundef %54)
  %tobool89 = icmp ne i32 %call88, 0
  br i1 %tobool89, label %if.end91, label %if.then90

if.then90:                                        ; preds = %if.end86
  store i32 0, ptr %retval, align 4
  br label %return

if.end91:                                         ; preds = %if.end86
  br label %if.end105

if.else92:                                        ; preds = %lor.lhs.false
  %55 = load ptr, ptr %arg, align 8
  %subargs93 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %55, i32 0, i32 8
  %56 = load ptr, ptr %subargs93, align 8
  %cmp94 = icmp ne ptr %56, null
  br i1 %cmp94, label %if.then96, label %if.end104

if.then96:                                        ; preds = %if.else92
  br label %do.body97

do.body97:                                        ; preds = %if.then96
  %57 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp98 = icmp slt i32 3, %57
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %do.body97
  br label %do.end103

if.end101:                                        ; preds = %do.body97
  %58 = load ptr, ptr %arg, align 8
  %name102 = getelementptr inbounds %struct.RedisModuleCommandArg, ptr %58, i32 0, i32 0
  %59 = load ptr, ptr %name102, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.538, ptr noundef %59)
  br label %do.end103

do.end103:                                        ; preds = %if.end101, %if.then100
  store i32 0, ptr %retval, align 4
  br label %return

if.end104:                                        ; preds = %if.else92
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.end91
  br label %for.inc

for.inc:                                          ; preds = %if.end105
  %60 = load i64, ptr %j, align 8
  %inc = add i64 %60, 1
  store i64 %inc, ptr %j, align 8
  br label %for.cond, !llvm.loop !93

for.end:                                          ; preds = %for.cond
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %do.end103, %if.then90, %do.end85, %do.end67, %do.end56, %do.end40, %do.end25, %do.end, %if.then
  %61 = load i32, ptr %retval, align 4
  ret i32 %61
}

; Function Attrs: nounwind uwtable
define internal ptr @moduleCmdArgAt(ptr noundef %version, ptr noundef %args, i32 noundef %index) #0 {
entry:
  %version.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %index.addr = alloca i32, align 4
  %offset = alloca i64, align 8
  store ptr %version, ptr %version.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i32 %index, ptr %index.addr, align 4
  %0 = load i32, ptr %index.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load ptr, ptr %version.addr, align 8
  %sizeof_arg = getelementptr inbounds %struct.RedisModuleCommandInfoVersion, ptr %1, i32 0, i32 3
  %2 = load i64, ptr %sizeof_arg, align 8
  %mul = mul i64 %conv, %2
  store i64 %mul, ptr %offset, align 8
  %3 = load ptr, ptr %args.addr, align 8
  %4 = load i64, ptr %offset, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 %4
  ret ptr %add.ptr
}

; Function Attrs: nounwind uwtable
define internal i32 @moduleConvertArgType(i32 noundef %type, ptr noundef %error) #0 {
entry:
  %retval = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %error.addr = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store ptr %error, ptr %error.addr, align 8
  %0 = load ptr, ptr %error.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %error.addr, align 8
  store i32 0, ptr %1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %type.addr, align 4
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
    i32 3, label %sw.bb3
    i32 4, label %sw.bb4
    i32 5, label %sw.bb5
    i32 6, label %sw.bb6
    i32 7, label %sw.bb7
    i32 8, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %if.end
  store i32 2, ptr %retval, align 4
  br label %return

sw.bb3:                                           ; preds = %if.end
  store i32 3, ptr %retval, align 4
  br label %return

sw.bb4:                                           ; preds = %if.end
  store i32 4, ptr %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %if.end
  store i32 5, ptr %retval, align 4
  br label %return

sw.bb6:                                           ; preds = %if.end
  store i32 6, ptr %retval, align 4
  br label %return

sw.bb7:                                           ; preds = %if.end
  store i32 7, ptr %retval, align 4
  br label %return

sw.bb8:                                           ; preds = %if.end
  store i32 8, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end
  %3 = load ptr, ptr %error.addr, align 8
  %tobool9 = icmp ne ptr %3, null
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %sw.default
  %4 = load ptr, ptr %error.addr, align 8
  store i32 1, ptr %4, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %sw.default
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal i32 @moduleConvertArgFlags(i32 noundef %flags) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %realflags = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %realflags, align 4
  %0 = load i32, ptr %flags.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %realflags, align 4
  %or = or i32 %1, 1
  store i32 %or, ptr %realflags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %flags.addr, align 4
  %and1 = and i32 %2, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = load i32, ptr %realflags, align 4
  %or4 = or i32 %3, 2
  store i32 %or4, ptr %realflags, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %flags.addr, align 4
  %and6 = and i32 %4, 4
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end5
  %5 = load i32, ptr %realflags, align 4
  %or9 = or i32 %5, 4
  store i32 %or9, ptr %realflags, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end5
  %6 = load i32, ptr %realflags, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @connAddr(ptr noundef %conn, ptr noundef %ip, i64 noundef %ip_len, ptr noundef %port, i32 noundef %remote) #0 {
entry:
  %retval = alloca i32, align 4
  %conn.addr = alloca ptr, align 8
  %ip.addr = alloca ptr, align 8
  %ip_len.addr = alloca i64, align 8
  %port.addr = alloca ptr, align 8
  %remote.addr = alloca i32, align 4
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i64 %ip_len, ptr %ip_len.addr, align 8
  store ptr %port, ptr %port.addr, align 8
  store i32 %remote, ptr %remote.addr, align 4
  %0 = load ptr, ptr %conn.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %type, align 8
  %addr = getelementptr inbounds %struct.ConnectionType, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %addr, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load ptr, ptr %conn.addr, align 8
  %type2 = getelementptr inbounds %struct.connection, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %type2, align 8
  %addr3 = getelementptr inbounds %struct.ConnectionType, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %addr3, align 8
  %7 = load ptr, ptr %conn.addr, align 8
  %8 = load ptr, ptr %ip.addr, align 8
  %9 = load i64, ptr %ip_len.addr, align 8
  %10 = load ptr, ptr %port.addr, align 8
  %11 = load i32, ptr %remote.addr, align 4
  %call = call i32 %6(ptr noundef %7, ptr noundef %8, i64 noundef %9, ptr noundef %10, i32 noundef %11)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

declare i64 @rdbWriteRaw(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @eventLoopFromAeMask(i32 noundef %ae_mask) #0 {
entry:
  %ae_mask.addr = alloca i32, align 4
  %mask = alloca i32, align 4
  store i32 %ae_mask, ptr %ae_mask.addr, align 4
  store i32 0, ptr %mask, align 4
  %0 = load i32, ptr %ae_mask.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %mask, align 4
  %or = or i32 %1, 1
  store i32 %or, ptr %mask, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %ae_mask.addr, align 4
  %and1 = and i32 %2, 2
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %3 = load i32, ptr %mask, align 4
  %or4 = or i32 %3, 2
  store i32 %or4, ptr %mask, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %4 = load i32, ptr %mask, align 4
  ret i32 %4
}

declare ptr @createStringObjectFromLongDouble(x86_fp80 noundef, i32 noundef) #1

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #6 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #9 = { nocallback nofree nosync nounwind willreturn }
attributes #10 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { allocsize(0) }
attributes #12 = { allocsize(1) }
attributes #13 = { noreturn nounwind }
attributes #14 = { nounwind willreturn memory(read) }
attributes #15 = { nounwind willreturn memory(none) }
attributes #16 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
