target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.termios = type { i32, i32, i32, i32, i8, [32 x i8], i32, i32 }
%struct.config = type { %struct.cliConnInfo, ptr, i32, %struct.cliSSLconfig, i64, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, ptr, ptr, i32, i32, i32, i32, i32, i32, ptr, i32, i32, i32, i32, ptr, ptr, [128 x i8], ptr, i32, i32, i32, i32, i32, ptr, i32, i32, %struct.clusterManagerCommand, i32, i32, i32, i32, i32, i32, ptr, ptr, ptr }
%struct.cliConnInfo = type { ptr, i32, i32, ptr, ptr }
%struct.cliSSLconfig = type { ptr, ptr, ptr, i32, ptr, ptr, ptr, ptr }
%struct.clusterManagerCommand = type { ptr, i32, ptr, ptr, i32, i32, ptr, ptr, ptr, i32, ptr, i32, i32, i32, float, ptr, ptr, ptr, i32 }
%struct.pref = type { i32 }
%struct.clusterManagerCommandDef = type { ptr, ptr, i32, ptr, ptr }
%struct.clusterManagerOptionDef = type { ptr, ptr }
%struct.typeinfo = type { ptr, ptr, ptr, i64, i64, i64, ptr }
%struct.clusterManager = type { ptr, ptr, i32 }
%struct.dictType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.commandDocs = type { ptr, ptr, ptr, ptr, i32, ptr, ptr, ptr }
%struct.distsamples = type { i64, i64, i32 }
%struct.helpEntry = type { i32, i32, ptr, ptr, %struct.commandDocs }
%struct.dict = type { ptr, [2 x ptr], [2 x i64], i64, i16, [2 x i8], [0 x ptr] }
%struct.redisReply = type { i32, i64, double, i64, ptr, [4 x i8], i64, ptr }
%struct.listIter = type { ptr, i32 }
%struct.clusterManagerNode = type { ptr, ptr, ptr, i32, i32, i64, i64, i64, i32, ptr, ptr, i32, [16384 x i8], i32, i32, ptr, ptr, ptr, i32, i32, float, i32 }
%struct.list = type { ptr, ptr, ptr, ptr, ptr, i64 }
%struct.listNode = type { ptr, ptr, ptr }
%struct.clusterManagerNodeArray = type { ptr, ptr, i32, i32 }
%struct.clusterManagerReshardTableItem = type { ptr, i32 }
%struct.redisContext = type { ptr, i32, [128 x i8], i32, i32, ptr, ptr, i32, ptr, ptr, %struct.anon, %struct.anon.0, ptr, i64, ptr, ptr, ptr, ptr }
%struct.anon = type { ptr, ptr, i32 }
%struct.anon.0 = type { ptr }
%struct.redisContextFuncs = type { ptr, ptr, ptr, ptr, ptr, ptr }
%struct.hisdshdr8 = type { i8, i8, i8, [0 x i8] }
%struct.hisdshdr16 = type <{ i16, i16, i8, [0 x i8] }>
%struct.hisdshdr32 = type <{ i32, i32, i8, [0 x i8] }>
%struct.hisdshdr64 = type <{ i64, i64, i8, [0 x i8] }>
%struct.timeval = type { i64, i64 }
%struct.cliCommandArg = type { ptr, i32, ptr, ptr, i32, i32, ptr, ptr, i32, i32, i32, i32 }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.clusterManagerLink = type { ptr, ptr, i32, i32 }
%struct.fd_set = type { [16 x i64] }

@spectrum_palette_color_size = dso_local global i32 19, align 4
@spectrum_palette_color = dso_local global [19 x i32] [i32 0, i32 233, i32 234, i32 235, i32 237, i32 239, i32 241, i32 243, i32 245, i32 247, i32 144, i32 143, i32 142, i32 184, i32 226, i32 214, i32 208, i32 202, i32 196], align 16
@spectrum_palette_mono_size = dso_local global i32 13, align 4
@spectrum_palette_mono = dso_local global [13 x i32] [i32 0, i32 233, i32 234, i32 235, i32 237, i32 239, i32 241, i32 243, i32 245, i32 247, i32 249, i32 251, i32 253], align 16
@helpEntriesLen = internal global i32 0, align 4
@helpEntries = internal global ptr null, align 8
@.str = private unnamed_addr constant [4 x i8] c"@%s\00", align 1
@orig_termios_saved = internal global i32 0, align 4
@orig_termios = internal global %struct.termios zeroinitializer, align 4
@config = internal global %struct.config zeroinitializer, align 8
@.str.1 = private unnamed_addr constant [8 x i8] c"message\00", align 1
@.str.2 = private unnamed_addr constant [10 x i8] c"subscribe\00", align 1
@.str.3 = private unnamed_addr constant [5 x i8] c"TERM\00", align 1
@.str.4 = private unnamed_addr constant [6 x i8] c"xterm\00", align 1
@.str.5 = private unnamed_addr constant [5 x i8] c"bold\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"red\00", align 1
@.str.7 = private unnamed_addr constant [6 x i8] c"green\00", align 1
@.str.8 = private unnamed_addr constant [7 x i8] c"yellow\00", align 1
@.str.9 = private unnamed_addr constant [5 x i8] c"blue\00", align 1
@.str.10 = private unnamed_addr constant [8 x i8] c"magenta\00", align 1
@.str.11 = private unnamed_addr constant [5 x i8] c"cyan\00", align 1
@.str.12 = private unnamed_addr constant [6 x i8] c"white\00", align 1
@.str.13 = private unnamed_addr constant [12 x i8] c"\1B[%i;%i;49m\00", align 1
@.str.14 = private unnamed_addr constant [5 x i8] c"\1B[0m\00", align 1
@.str.15 = private unnamed_addr constant [8 x i8] c"<debug>\00", align 1
@.str.16 = private unnamed_addr constant [8 x i8] c"<redis>\00", align 1
@.str.17 = private unnamed_addr constant [8 x i8] c"<reply>\00", align 1
@.str.18 = private unnamed_addr constant [8 x i8] c"<error>\00", align 1
@.str.19 = private unnamed_addr constant [7 x i8] c"<hint>\00", align 1
@.str.20 = private unnamed_addr constant [8 x i8] c"<value>\00", align 1
@.str.21 = private unnamed_addr constant [9 x i8] c"<retval>\00", align 1
@.str.22 = private unnamed_addr constant [5 x i8] c":set\00", align 1
@.str.23 = private unnamed_addr constant [6 x i8] c"hints\00", align 1
@pref = internal global %struct.pref zeroinitializer, align 4
@.str.24 = private unnamed_addr constant [8 x i8] c"nohints\00", align 1
@.str.25 = private unnamed_addr constant [37 x i8] c"%sunknown redis-cli preference '%s'\0A\00", align 1
@.str.26 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.27 = private unnamed_addr constant [14 x i8] c".redisclirc: \00", align 1
@.str.28 = private unnamed_addr constant [43 x i8] c"%sunknown redis-cli internal command '%s'\0A\00", align 1
@.str.29 = private unnamed_addr constant [16 x i8] c"REDISCLI_RCFILE\00", align 1
@.str.30 = private unnamed_addr constant [12 x i8] c".redisclirc\00", align 1
@.str.31 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@clusterManagerUncoveredSlots = dso_local global ptr null, align 8
@.str.32 = private unnamed_addr constant [7 x i8] c"create\00", align 1
@.str.33 = private unnamed_addr constant [28 x i8] c"host1:port1 ... hostN:portN\00", align 1
@.str.34 = private unnamed_addr constant [15 x i8] c"replicas <arg>\00", align 1
@.str.35 = private unnamed_addr constant [6 x i8] c"check\00", align 1
@.str.36 = private unnamed_addr constant [66 x i8] c"<host:port> or <host> <port> - separated by either colon or space\00", align 1
@.str.37 = private unnamed_addr constant [23 x i8] c"search-multiple-owners\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"info\00", align 1
@.str.39 = private unnamed_addr constant [4 x i8] c"fix\00", align 1
@.str.40 = private unnamed_addr constant [52 x i8] c"search-multiple-owners,fix-with-unreachable-masters\00", align 1
@.str.41 = private unnamed_addr constant [8 x i8] c"reshard\00", align 1
@.str.42 = private unnamed_addr constant [73 x i8] c"from <arg>,to <arg>,slots <arg>,yes,timeout <arg>,pipeline <arg>,replace\00", align 1
@.str.43 = private unnamed_addr constant [10 x i8] c"rebalance\00", align 1
@.str.44 = private unnamed_addr constant [109 x i8] c"weight <node1=w1...nodeN=wN>,use-empty-masters,timeout <arg>,simulate,pipeline <arg>,threshold <arg>,replace\00", align 1
@.str.45 = private unnamed_addr constant [9 x i8] c"add-node\00", align 1
@.str.46 = private unnamed_addr constant [46 x i8] c"new_host:new_port existing_host:existing_port\00", align 1
@.str.47 = private unnamed_addr constant [22 x i8] c"slave,master-id <arg>\00", align 1
@.str.48 = private unnamed_addr constant [9 x i8] c"del-node\00", align 1
@.str.49 = private unnamed_addr constant [18 x i8] c"host:port node_id\00", align 1
@.str.50 = private unnamed_addr constant [5 x i8] c"call\00", align 1
@.str.51 = private unnamed_addr constant [33 x i8] c"host:port command arg arg .. arg\00", align 1
@.str.52 = private unnamed_addr constant [27 x i8] c"only-masters,only-replicas\00", align 1
@.str.53 = private unnamed_addr constant [12 x i8] c"set-timeout\00", align 1
@.str.54 = private unnamed_addr constant [23 x i8] c"host:port milliseconds\00", align 1
@.str.55 = private unnamed_addr constant [7 x i8] c"import\00", align 1
@.str.56 = private unnamed_addr constant [10 x i8] c"host:port\00", align 1
@.str.57 = private unnamed_addr constant [69 x i8] c"from <arg>,from-user <arg>,from-pass <arg>,from-askpass,copy,replace\00", align 1
@.str.58 = private unnamed_addr constant [7 x i8] c"backup\00", align 1
@.str.59 = private unnamed_addr constant [27 x i8] c"host:port backup_directory\00", align 1
@.str.60 = private unnamed_addr constant [5 x i8] c"help\00", align 1
@clusterManagerCommands = dso_local global [13 x %struct.clusterManagerCommandDef] [%struct.clusterManagerCommandDef { ptr @.str.32, ptr @clusterManagerCommandCreate, i32 -2, ptr @.str.33, ptr @.str.34 }, %struct.clusterManagerCommandDef { ptr @.str.35, ptr @clusterManagerCommandCheck, i32 -1, ptr @.str.36, ptr @.str.37 }, %struct.clusterManagerCommandDef { ptr @.str.38, ptr @clusterManagerCommandInfo, i32 -1, ptr @.str.36, ptr null }, %struct.clusterManagerCommandDef { ptr @.str.39, ptr @clusterManagerCommandFix, i32 -1, ptr @.str.36, ptr @.str.40 }, %struct.clusterManagerCommandDef { ptr @.str.41, ptr @clusterManagerCommandReshard, i32 -1, ptr @.str.36, ptr @.str.42 }, %struct.clusterManagerCommandDef { ptr @.str.43, ptr @clusterManagerCommandRebalance, i32 -1, ptr @.str.36, ptr @.str.44 }, %struct.clusterManagerCommandDef { ptr @.str.45, ptr @clusterManagerCommandAddNode, i32 2, ptr @.str.46, ptr @.str.47 }, %struct.clusterManagerCommandDef { ptr @.str.48, ptr @clusterManagerCommandDeleteNode, i32 2, ptr @.str.49, ptr null }, %struct.clusterManagerCommandDef { ptr @.str.50, ptr @clusterManagerCommandCall, i32 -2, ptr @.str.51, ptr @.str.52 }, %struct.clusterManagerCommandDef { ptr @.str.53, ptr @clusterManagerCommandSetTimeout, i32 2, ptr @.str.54, ptr null }, %struct.clusterManagerCommandDef { ptr @.str.55, ptr @clusterManagerCommandImport, i32 1, ptr @.str.56, ptr @.str.57 }, %struct.clusterManagerCommandDef { ptr @.str.58, ptr @clusterManagerCommandBackup, i32 2, ptr @.str.59, ptr null }, %struct.clusterManagerCommandDef { ptr @.str.60, ptr @clusterManagerCommandHelp, i32 0, ptr null, ptr null }], align 16
@.str.61 = private unnamed_addr constant [14 x i8] c"--cluster-yes\00", align 1
@.str.62 = private unnamed_addr constant [42 x i8] c"Automatic yes to cluster commands prompts\00", align 1
@clusterManagerOptions = dso_local global [1 x %struct.clusterManagerOptionDef] [%struct.clusterManagerOptionDef { ptr @.str.61, ptr @.str.62 }], align 16
@.str.63 = private unnamed_addr constant [10 x i8] c"\1B[38;5;0m\00", align 1
@spectrum_palette_size = dso_local global i32 0, align 4
@spectrum_palette = dso_local global ptr null, align 8
@.str.64 = private unnamed_addr constant [13 x i8] c"\1B[48;5;%dm%c\00", align 1
@.str.65 = private unnamed_addr constant [6 x i8] c"\1B[0m\0A\00", align 1
@stdout = external global ptr, align 8
@.str.66 = private unnamed_addr constant [47 x i8] c"---------------------------------------------\0A\00", align 1
@.str.67 = private unnamed_addr constant [47 x i8] c". - * #          .01 .125 .25 .5 milliseconds\0A\00", align 1
@.str.68 = private unnamed_addr constant [47 x i8] c"1,2,3,...,9      from 1 to 9     milliseconds\0A\00", align 1
@.str.69 = private unnamed_addr constant [47 x i8] c"A,B,C,D,E        10,20,30,40,50  milliseconds\0A\00", align 1
@.str.70 = private unnamed_addr constant [47 x i8] c"F,G,H,I,J        .1,.2,.3,.4,.5       seconds\0A\00", align 1
@.str.71 = private unnamed_addr constant [47 x i8] c"K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\0A\00", align 1
@.str.72 = private unnamed_addr constant [18 x i8] c"From 0 to 100%%: \00", align 1
@.str.73 = private unnamed_addr constant [12 x i8] c"\1B[48;5;%dm \00", align 1
@stderr = external global ptr, align 8
@.str.74 = private unnamed_addr constant [24 x i8] c"sending REPLCONF %s %s\0A\00", align 1
@context = internal global ptr null, align 8
@.str.75 = private unnamed_addr constant [15 x i8] c"REPLCONF %s %s\00", align 1
@.str.76 = private unnamed_addr constant [12 x i8] c"\0AI/O error\0A\00", align 1
@.str.77 = private unnamed_addr constant [23 x i8] c"REPLCONF %s error: %s\0A\00", align 1
@.str.78 = private unnamed_addr constant [5 x i8] c"capa\00", align 1
@.str.79 = private unnamed_addr constant [4 x i8] c"eof\00", align 1
@.str.80 = private unnamed_addr constant [9 x i8] c"rdb-only\00", align 1
@.str.81 = private unnamed_addr constant [2 x i8] c"1\00", align 1
@.str.82 = private unnamed_addr constant [7 x i8] c"SYNC\0D\0A\00", align 1
@.str.83 = private unnamed_addr constant [25 x i8] c"Error writing to master\0A\00", align 1
@.str.84 = private unnamed_addr constant [41 x i8] c"Error reading bulk length while SYNCing\0A\00", align 1
@.str.85 = private unnamed_addr constant [29 x i8] c"SYNC with master failed: %s\0A\00", align 1
@.str.86 = private unnamed_addr constant [12 x i8] c"+FULLRESYNC\00", align 1
@.str.87 = private unnamed_addr constant [10 x i8] c"+CONTINUE\00", align 1
@.str.88 = private unnamed_addr constant [18 x i8] c"PSYNC replied %s\0A\00", align 1
@.str.89 = private unnamed_addr constant [42 x i8] c"Error reading bulk length while PSYNCing\0A\00", align 1
@.str.90 = private unnamed_addr constant [5 x i8] c"EOF:\00", align 1
@.str.91 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"STRLEN\00", align 1
@.str.93 = private unnamed_addr constant [6 x i8] c"bytes\00", align 1
@type_string = dso_local global %struct.typeinfo { ptr @.str.91, ptr @.str.92, ptr @.str.93, i64 0, i64 0, i64 0, ptr null }, align 8
@.str.94 = private unnamed_addr constant [5 x i8] c"list\00", align 1
@.str.95 = private unnamed_addr constant [5 x i8] c"LLEN\00", align 1
@.str.96 = private unnamed_addr constant [6 x i8] c"items\00", align 1
@type_list = dso_local global %struct.typeinfo { ptr @.str.94, ptr @.str.95, ptr @.str.96, i64 0, i64 0, i64 0, ptr null }, align 8
@.str.97 = private unnamed_addr constant [4 x i8] c"set\00", align 1
@.str.98 = private unnamed_addr constant [6 x i8] c"SCARD\00", align 1
@.str.99 = private unnamed_addr constant [8 x i8] c"members\00", align 1
@type_set = dso_local global %struct.typeinfo { ptr @.str.97, ptr @.str.98, ptr @.str.99, i64 0, i64 0, i64 0, ptr null }, align 8
@.str.100 = private unnamed_addr constant [5 x i8] c"hash\00", align 1
@.str.101 = private unnamed_addr constant [5 x i8] c"HLEN\00", align 1
@.str.102 = private unnamed_addr constant [7 x i8] c"fields\00", align 1
@type_hash = dso_local global %struct.typeinfo { ptr @.str.100, ptr @.str.101, ptr @.str.102, i64 0, i64 0, i64 0, ptr null }, align 8
@.str.103 = private unnamed_addr constant [5 x i8] c"zset\00", align 1
@.str.104 = private unnamed_addr constant [6 x i8] c"ZCARD\00", align 1
@type_zset = dso_local global %struct.typeinfo { ptr @.str.103, ptr @.str.104, ptr @.str.99, i64 0, i64 0, i64 0, ptr null }, align 8
@.str.105 = private unnamed_addr constant [7 x i8] c"stream\00", align 1
@.str.106 = private unnamed_addr constant [5 x i8] c"XLEN\00", align 1
@.str.107 = private unnamed_addr constant [8 x i8] c"entries\00", align 1
@type_stream = dso_local global %struct.typeinfo { ptr @.str.105, ptr @.str.106, ptr @.str.107, i64 0, i64 0, i64 0, ptr null }, align 8
@.str.108 = private unnamed_addr constant [6 x i8] c"other\00", align 1
@.str.109 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@type_other = dso_local global %struct.typeinfo { ptr @.str.108, ptr null, ptr @.str.109, i64 0, i64 0, i64 0, ptr null }, align 8
@.str.110 = private unnamed_addr constant [6 x i8] c"%lldB\00", align 1
@.str.111 = private unnamed_addr constant [6 x i8] c"%.2fK\00", align 1
@.str.112 = private unnamed_addr constant [6 x i8] c"%.2fM\00", align 1
@.str.113 = private unnamed_addr constant [6 x i8] c"%.2fG\00", align 1
@.str.114 = private unnamed_addr constant [9 x i8] c"lru:%lld\00", align 1
@.str.115 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.116 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.117 = private unnamed_addr constant [26 x i8] c"Can't open file '%s': %s\0A\00", align 1
@.str.118 = private unnamed_addr constant [38 x i8] c"Missing expected hint for input '%s'\0A\00", align 1
@.str.119 = private unnamed_addr constant [41 x i8] c"Input: '%s', Expected: '%s', Hint: '%s'\0A\00", align 1
@.str.120 = private unnamed_addr constant [48 x i8] c"Test case '%s' FAILED: expected '%s', got '%s'\0A\00", align 1
@.str.121 = private unnamed_addr constant [18 x i8] c"%s: %d/%d passed\0A\00", align 1
@.str.122 = private unnamed_addr constant [8 x i8] c"SUCCESS\00", align 1
@.str.123 = private unnamed_addr constant [8 x i8] c"FAILURE\00", align 1
@.str.124 = private unnamed_addr constant [10 x i8] c"127.0.0.1\00", align 1
@.str.125 = private unnamed_addr constant [8 x i8] c"FAKETTY\00", align 1
@.str.126 = private unnamed_addr constant [24 x i8] c"Please input password: \00", align 1
@.str.127 = private unnamed_addr constant [43 x i8] c"Please input import source node password: \00", align 1
@.str.128 = private unnamed_addr constant [16 x i8] c"rdb-filter-only\00", align 1
@.str.129 = private unnamed_addr constant [10 x i8] c"functions\00", align 1
@.str.130 = private unnamed_addr constant [60 x i8] c"Failed requesting functions only RDB from server, aborting\0A\00", align 1
@.str.131 = private unnamed_addr constant [8 x i8] c"summary\00", align 1
@.str.132 = private unnamed_addr constant [6 x i8] c"since\00", align 1
@.str.133 = private unnamed_addr constant [6 x i8] c"group\00", align 1
@.str.134 = private unnamed_addr constant [10 x i8] c"arguments\00", align 1
@.str.135 = private unnamed_addr constant [12 x i8] c"subcommands\00", align 1
@.str.136 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.137 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.138 = private unnamed_addr constant [13 x i8] c"display_text\00", align 1
@.str.139 = private unnamed_addr constant [6 x i8] c"token\00", align 1
@.str.140 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.141 = private unnamed_addr constant [8 x i8] c"integer\00", align 1
@.str.142 = private unnamed_addr constant [7 x i8] c"double\00", align 1
@.str.143 = private unnamed_addr constant [4 x i8] c"key\00", align 1
@.str.144 = private unnamed_addr constant [8 x i8] c"pattern\00", align 1
@.str.145 = private unnamed_addr constant [10 x i8] c"unix-time\00", align 1
@.str.146 = private unnamed_addr constant [11 x i8] c"pure-token\00", align 1
@.str.147 = private unnamed_addr constant [6 x i8] c"oneof\00", align 1
@.str.148 = private unnamed_addr constant [6 x i8] c"block\00", align 1
@.str.149 = private unnamed_addr constant [6 x i8] c"flags\00", align 1
@.str.150 = private unnamed_addr constant [9 x i8] c"optional\00", align 1
@.str.151 = private unnamed_addr constant [9 x i8] c"multiple\00", align 1
@.str.152 = private unnamed_addr constant [15 x i8] c"multiple_token\00", align 1
@.str.153 = private unnamed_addr constant [5 x i8] c"%lld\00", align 1
@.str.154 = private unnamed_addr constant [4 x i8] c"%lf\00", align 1
@.str.155 = private unnamed_addr constant [2 x i8] c"[\00", align 1
@.str.156 = private unnamed_addr constant [2 x i8] c"|\00", align 1
@.str.157 = private unnamed_addr constant [2 x i8] c"]\00", align 1
@.str.158 = private unnamed_addr constant [3 x i8] c"\22\22\00", align 1
@.str.159 = private unnamed_addr constant [6 x i8] c" ...]\00", align 1
@.str.160 = private unnamed_addr constant [10 x i8] c"/dev/null\00", align 1
@.str.161 = private unnamed_addr constant [5 x i8] c"HOME\00", align 1
@.str.162 = private unnamed_addr constant [6 x i8] c"%s/%s\00", align 1
@cluster_manager = internal global %struct.clusterManager zeroinitializer, align 8
@.str.163 = private unnamed_addr constant [28 x i8] c"Invalid address format: %s\0A\00", align 1
@.str.164 = private unnamed_addr constant [35 x i8] c"Node %s:%d replied with error:\0A%s\0A\00", align 1
@.str.165 = private unnamed_addr constant [172 x i8] c"*** ERROR: Invalid configuration for cluster creation.\0A*** Redis Cluster requires at least 3 master nodes.\0A*** This is not possible with %d nodes and %d replicas per node.\00", align 1
@.str.166 = private unnamed_addr constant [38 x i8] c"\0A*** At least %d nodes are required.\0A\00", align 1
@.str.167 = private unnamed_addr constant [53 x i8] c">>> Performing hash slots allocation on %d nodes...\0A\00", align 1
@.str.168 = private unnamed_addr constant [31 x i8] c"Master[%d] -> Slots %ld - %ld\0A\00", align 1
@.str.169 = private unnamed_addr constant [31 x i8] c"Adding replica %s:%d to %s:%d\0A\00", align 1
@.str.170 = private unnamed_addr constant [26 x i8] c"Adding extra replicas...\0A\00", align 1
@.str.171 = private unnamed_addr constant [35 x i8] c"Can I set the above configuration?\00", align 1
@.str.172 = private unnamed_addr constant [33 x i8] c">>> Nodes configuration updated\0A\00", align 1
@.str.173 = private unnamed_addr constant [50 x i8] c">>> Assign a different config epoch to each node\0A\00", align 1
@.str.174 = private unnamed_addr constant [28 x i8] c"cluster set-config-epoch %d\00", align 1
@.str.175 = private unnamed_addr constant [55 x i8] c">>> Sending CLUSTER MEET messages to join the cluster\0A\00", align 1
@.str.176 = private unnamed_addr constant [46 x i8] c"Invalid IP address or hostname specified: %s\0A\00", align 1
@.str.177 = private unnamed_addr constant [19 x i8] c"cluster meet %s %d\00", align 1
@.str.178 = private unnamed_addr constant [22 x i8] c"cluster meet %s %d %d\00", align 1
@.str.179 = private unnamed_addr constant [38 x i8] c"Failed to send CLUSTER MEET command.\0A\00", align 1
@.str.180 = private unnamed_addr constant [15 x i8] c"TLS Error: %s\0A\00", align 1
@.str.181 = private unnamed_addr constant [31 x i8] c"Could not connect to Redis at \00", align 1
@.str.182 = private unnamed_addr constant [11 x i8] c"%s:%d: %s\0A\00", align 1
@.str.183 = private unnamed_addr constant [8 x i8] c"AUTH %s\00", align 1
@.str.184 = private unnamed_addr constant [11 x i8] c"AUTH %s %s\00", align 1
@.str.185 = private unnamed_addr constant [16 x i8] c"cluster_enabled\00", align 1
@.str.186 = private unnamed_addr constant [5 x i8] c"INFO\00", align 1
@.str.187 = private unnamed_addr constant [37 x i8] c"is not configured as a cluster node.\00", align 1
@.str.188 = private unnamed_addr constant [21 x i8] c"[ERR] Node %s:%d %s\0A\00", align 1
@.str.189 = private unnamed_addr constant [14 x i8] c"CLUSTER NODES\00", align 1
@.str.190 = private unnamed_addr constant [36 x i8] c"Error: invalid CLUSTER NODES reply\0A\00", align 1
@.str.191 = private unnamed_addr constant [7 x i8] c"myself\00", align 1
@.str.192 = private unnamed_addr constant [4 x i8] c"->-\00", align 1
@.str.193 = private unnamed_addr constant [4 x i8] c"-<-\00", align 1
@.str.194 = private unnamed_addr constant [7 x i8] c"noaddr\00", align 1
@.str.195 = private unnamed_addr constant [13 x i8] c"disconnected\00", align 1
@.str.196 = private unnamed_addr constant [5 x i8] c"fail\00", align 1
@.str.197 = private unnamed_addr constant [6 x i8] c"slave\00", align 1
@.str.198 = private unnamed_addr constant [3 x i8] c"\1B[\00", align 1
@.str.199 = private unnamed_addr constant [6 x i8] c"29;1m\00", align 1
@.str.200 = private unnamed_addr constant [6 x i8] c"33;1m\00", align 1
@.str.201 = private unnamed_addr constant [6 x i8] c"31;1m\00", align 1
@.str.202 = private unnamed_addr constant [6 x i8] c"32;1m\00", align 1
@.str.203 = private unnamed_addr constant [3 x i8] c"0m\00", align 1
@.str.204 = private unnamed_addr constant [5 x i8] c"db0:\00", align 1
@.str.205 = private unnamed_addr constant [13 x i8] c"CLUSTER INFO\00", align 1
@.str.206 = private unnamed_addr constant [20 x i8] c"cluster_known_nodes\00", align 1
@.str.207 = private unnamed_addr constant [119 x i8] c"is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.\00", align 1
@.str.208 = private unnamed_addr constant [60 x i8] c">>> Trying to optimize slaves allocation for anti-affinity\0A\00", align 1
@.str.209 = private unnamed_addr constant [37 x i8] c"[OK] Perfect anti-affinity obtained!\00", align 1
@.str.210 = private unnamed_addr constant [59 x i8] c"[WARNING] Some slaves are in the same host as their master\00", align 1
@.str.211 = private unnamed_addr constant [62 x i8] c"[WARNING] Some slaves of the same master are in the same host\00", align 1
@clusterManagerDictType = internal global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr null, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@.str.212 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@.str.213 = private unnamed_addr constant [2 x i8] c"m\00", align 1
@.str.214 = private unnamed_addr constant [2 x i8] c"M\00", align 1
@.str.215 = private unnamed_addr constant [2 x i8] c"S\00", align 1
@.str.216 = private unnamed_addr constant [12 x i8] c"S: %S %s:%u\00", align 1
@.str.217 = private unnamed_addr constant [41 x i8] c"%s: %S %s:%u\0A%s   slots:%S (%u slots) %S\00", align 1
@.str.218 = private unnamed_addr constant [20 x i8] c"\0A%s   replicates %S\00", align 1
@.str.219 = private unnamed_addr constant [31 x i8] c"\0A%s   %U additional replica(s)\00", align 1
@.str.220 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.221 = private unnamed_addr constant [4 x i8] c"[%u\00", align 1
@.str.222 = private unnamed_addr constant [5 x i8] c"-%u]\00", align 1
@.str.223 = private unnamed_addr constant [3 x i8] c"%S\00", align 1
@.str.224 = private unnamed_addr constant [28 x i8] c"%s (type 'yes' to accept): \00", align 1
@stdin = external global ptr, align 8
@.str.225 = private unnamed_addr constant [4 x i8] c"yes\00", align 1
@.str.226 = private unnamed_addr constant [21 x i8] c"CLUSTER REPLICATE %s\00", align 1
@.str.227 = private unnamed_addr constant [8 x i8] c"CLUSTER\00", align 1
@.str.228 = private unnamed_addr constant [9 x i8] c"ADDSLOTS\00", align 1
@.str.229 = private unnamed_addr constant [33 x i8] c"Waiting for the cluster to join\0A\00", align 1
@.str.230 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.231 = private unnamed_addr constant [40 x i8] c"Warning: %d node(s) may be unreachable\0A\00", align 1
@.str.232 = private unnamed_addr constant [52 x i8] c" - The port %d of node %s may be unreachable from:\0A\00", align 1
@.str.233 = private unnamed_addr constant [37 x i8] c" - Node %s may be unreachable from:\0A\00", align 1
@.str.234 = private unnamed_addr constant [7 x i8] c"   %s\0A\00", align 1
@.str.235 = private unnamed_addr constant [128 x i8] c"Cluster bus ports must be reachable by every node.\0ARemember that cluster bus ports are different from standard instance ports.\0A\00", align 1
@.str.236 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.237 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@clusterManagerLinkDictType = internal global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr @dictListDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@.str.238 = private unnamed_addr constant [6 x i8] c"%s:%u\00", align 1
@.str.239 = private unnamed_addr constant [10 x i8] c"handshake\00", align 1
@.str.240 = private unnamed_addr constant [42 x i8] c"[ERR] Unable to load info for node %s:%d\0A\00", align 1
@.str.241 = private unnamed_addr constant [62 x i8] c"*** WARNING: %s:%d claims to be slave of unknown node ID %s.\0A\00", align 1
@.str.242 = private unnamed_addr constant [49 x i8] c">>> Performing Cluster Check (using node %s:%d)\0A\00", align 1
@.str.243 = private unnamed_addr constant [45 x i8] c"[ERR] Nodes don't agree about configuration!\00", align 1
@.str.244 = private unnamed_addr constant [49 x i8] c"[OK] All nodes agree about slots configuration.\0A\00", align 1
@.str.245 = private unnamed_addr constant [29 x i8] c">>> Check for open slots...\0A\00", align 1
@.str.246 = private unnamed_addr constant [51 x i8] c"[WARNING] Node %s:%d has slots in migrating state \00", align 1
@.str.247 = private unnamed_addr constant [4 x i8] c",%S\00", align 1
@.str.248 = private unnamed_addr constant [51 x i8] c"[WARNING] Node %s:%d has slots in importing state \00", align 1
@.str.249 = private unnamed_addr constant [41 x i8] c"[WARNING] The following slots are open: \00", align 1
@.str.250 = private unnamed_addr constant [5 x i8] c"%s.\0A\00", align 1
@.str.251 = private unnamed_addr constant [29 x i8] c">>> Check slots coverage...\0A\00", align 1
@.str.252 = private unnamed_addr constant [28 x i8] c"[OK] All %d slots covered.\0A\00", align 1
@.str.253 = private unnamed_addr constant [46 x i8] c"[ERR] Not all %d slots are covered by nodes.\0A\00", align 1
@.str.254 = private unnamed_addr constant [39 x i8] c">>> Check for multiple slot owners...\0A\00", align 1
@.str.255 = private unnamed_addr constant [34 x i8] c"[WARNING] Slot %d has %d owners:\0A\00", align 1
@.str.256 = private unnamed_addr constant [11 x i8] c"    %s:%d\0A\00", align 1
@.str.257 = private unnamed_addr constant [43 x i8] c"Failed to fix multiple owners for slot %d\0A\00", align 1
@.str.258 = private unnamed_addr constant [32 x i8] c"[OK] No multiple owners found.\0A\00", align 1
@.str.259 = private unnamed_addr constant [351 x i8] c"*** Fixing open slots with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\0A\00", align 1
@.str.260 = private unnamed_addr constant [25 x i8] c">>> Fixing open slot %d\0A\00", align 1
@.str.261 = private unnamed_addr constant [27 x i8] c"CLUSTER COUNTKEYSINSLOT %d\00", align 1
@.str.262 = private unnamed_addr constant [55 x i8] c"*** Found keys about slot %d in non-owner node %s:%d!\0A\00", align 1
@.str.263 = private unnamed_addr constant [8 x i8] c"%s%s:%u\00", align 1
@.str.264 = private unnamed_addr constant [45 x i8] c"*** Found keys about slot %d in node %s:%d!\0A\00", align 1
@.str.265 = private unnamed_addr constant [25 x i8] c"Set as migrating in: %s\0A\00", align 1
@.str.266 = private unnamed_addr constant [25 x i8] c"Set as importing in: %s\0A\00", align 1
@.str.267 = private unnamed_addr constant [76 x i8] c">>> No single clear owner for the slot, selecting an owner by # of keys...\0A\00", align 1
@.str.268 = private unnamed_addr constant [53 x i8] c"[ERR] Can't select a slot owner. Impossible to fix.\0A\00", align 1
@.str.269 = private unnamed_addr constant [41 x i8] c"*** Configuring %s:%d as the slot owner\0A\00", align 1
@.str.270 = private unnamed_addr constant [5 x i8] c"node\00", align 1
@.str.271 = private unnamed_addr constant [10 x i8] c"importing\00", align 1
@.str.272 = private unnamed_addr constant [48 x i8] c">>> Case 1: Moving slot %d from %s:%d to %s:%d\0A\00", align 1
@.str.273 = private unnamed_addr constant [60 x i8] c">>> Case 2: Moving all the %d slot keys to its owner %s:%d\0A\00", align 1
@.str.274 = private unnamed_addr constant [35 x i8] c">>> Setting %d as STABLE in %s:%d\0A\00", align 1
@.str.275 = private unnamed_addr constant [5 x i8] c"NODE\00", align 1
@.str.276 = private unnamed_addr constant [97 x i8] c">>> Case 3: Moving slot %d from %s:%d to %s:%d and closing it on all the other importing nodes.\0A\00", align 1
@.str.277 = private unnamed_addr constant [68 x i8] c">>> Case 3: Closing slot %d on both migrating and importing nodes.\0A\00", align 1
@.str.278 = private unnamed_addr constant [28 x i8] c"CLUSTER GETKEYSINSLOT %d %d\00", align 1
@.str.279 = private unnamed_addr constant [38 x i8] c">>> Case 4: Closing slot %d on %s:%d\0A\00", align 1
@.str.280 = private unnamed_addr constant [22 x i8] c"CLUSTER SETSLOT %d %s\00", align 1
@.str.281 = private unnamed_addr constant [7 x i8] c"STABLE\00", align 1
@.str.282 = private unnamed_addr constant [135 x i8] c"[ERR] Sorry, redis-cli can't fix this slot yet (work in progress). Slot is set as migrating in %s, as importing in %s, owner is %s:%d\0A\00", align 1
@.str.283 = private unnamed_addr constant [6 x i8] c"MULTI\00", align 1
@.str.284 = private unnamed_addr constant [20 x i8] c"CLUSTER ADDSLOTS %d\00", align 1
@.str.285 = private unnamed_addr constant [18 x i8] c"CLUSTER BUMPEPOCH\00", align 1
@.str.286 = private unnamed_addr constant [5 x i8] c"EXEC\00", align 1
@.str.287 = private unnamed_addr constant [20 x i8] c"CLUSTER DELSLOTS %d\00", align 1
@.str.288 = private unnamed_addr constant [14 x i8] c"CLUSTER SLOTS\00", align 1
@.str.289 = private unnamed_addr constant [25 x i8] c"CLUSTER SETSLOT %d %s %s\00", align 1
@.str.290 = private unnamed_addr constant [30 x i8] c"CLUSTER SETSLOT failed to run\00", align 1
@.str.291 = private unnamed_addr constant [37 x i8] c"Moving slot %d from %s:%d to %s:%d: \00", align 1
@.str.292 = private unnamed_addr constant [10 x i8] c"migrating\00", align 1
@.str.293 = private unnamed_addr constant [42 x i8] c"ERR Please use SETSLOT only with masters.\00", align 1
@.str.294 = private unnamed_addr constant [8 x i8] c"BUSYKEY\00", align 1
@.str.295 = private unnamed_addr constant [55 x i8] c"*** Slot was not served, setting owner to node %s:%d.\0A\00", align 1
@.str.296 = private unnamed_addr constant [24 x i8] c"\0A*** Target key exists\0A\00", align 1
@.str.297 = private unnamed_addr constant [42 x i8] c"*** Checking key values on both nodes...\0A\00", align 1
@.str.298 = private unnamed_addr constant [25 x i8] c"*** Value check failed!\0A\00", align 1
@.str.299 = private unnamed_addr constant [141 x i8] c"*** Found %d key(s) in both source node and target node having different values.\0A    Source node: %s:%d\0A    Target node: %s:%d\0A    Keys(s):\0A\00", align 1
@.str.300 = private unnamed_addr constant [10 x i8] c"    - %s\0A\00", align 1
@.str.301 = private unnamed_addr constant [132 x i8] c"Please fix the above key(s) manually and try again or relaunch the command \0Awith --cluster-replace option to force key overriding.\0A\00", align 1
@.str.302 = private unnamed_addr constant [30 x i8] c"*** Replacing target keys...\0A\00", align 1
@.str.303 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.304 = private unnamed_addr constant [8 x i8] c"MIGRATE\00", align 1
@.str.305 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.306 = private unnamed_addr constant [8 x i8] c"REPLACE\00", align 1
@.str.307 = private unnamed_addr constant [6 x i8] c"AUTH2\00", align 1
@.str.308 = private unnamed_addr constant [5 x i8] c"AUTH\00", align 1
@.str.309 = private unnamed_addr constant [5 x i8] c"KEYS\00", align 1
@clusterManagerCompareKeysValues.hash_zero = internal global ptr @.str.310, align 8
@.str.310 = private unnamed_addr constant [41 x i8] c"0000000000000000000000000000000000000000\00", align 1
@.str.311 = private unnamed_addr constant [6 x i8] c"DEBUG\00", align 1
@.str.312 = private unnamed_addr constant [13 x i8] c"DIGEST-VALUE\00", align 1
@.str.313 = private unnamed_addr constant [355 x i8] c"*** Fixing slots coverage with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\0A\00", align 1
@.str.314 = private unnamed_addr constant [30 x i8] c">>> Fixing slots coverage...\0A\00", align 1
@.str.315 = private unnamed_addr constant [3 x i8] c", \00", align 1
@.str.316 = private unnamed_addr constant [64 x i8] c"The following uncovered slots have no keys across the cluster:\0A\00", align 1
@.str.317 = private unnamed_addr constant [48 x i8] c"Fix these slots by covering with a random node?\00", align 1
@.str.318 = private unnamed_addr constant [33 x i8] c">>> Covering slot %s with %s:%d\0A\00", align 1
@.str.319 = private unnamed_addr constant [59 x i8] c"The following uncovered slots have keys in just one node:\0A\00", align 1
@.str.320 = private unnamed_addr constant [46 x i8] c"Fix these slots by covering with those nodes?\00", align 1
@.str.321 = private unnamed_addr constant [60 x i8] c"The following uncovered slots have keys in multiple nodes:\0A\00", align 1
@.str.322 = private unnamed_addr constant [51 x i8] c"Fix these slots by moving keys into a single node?\00", align 1
@.str.323 = private unnamed_addr constant [43 x i8] c">>> Covering slot %s moving keys to %s:%d\0A\00", align 1
@.str.324 = private unnamed_addr constant [10 x i8] c"IMPORTING\00", align 1
@.str.325 = private unnamed_addr constant [43 x i8] c">>> Fixing multiple owners for slot %d...\0A\00", align 1
@.str.326 = private unnamed_addr constant [34 x i8] c">>> Setting slot %d owner: %s:%d\0A\00", align 1
@.str.327 = private unnamed_addr constant [40 x i8] c">>> Adding node %s:%d to cluster %s:%d\0A\00", align 1
@.str.328 = private unnamed_addr constant [28 x i8] c"[ERR] No such master ID %s\0A\00", align 1
@.str.329 = private unnamed_addr constant [37 x i8] c"Automatically selected master %s:%d\0A\00", align 1
@.str.330 = private unnamed_addr constant [42 x i8] c"[ERR] Sorry, can't connect to node %s:%d\0A\00", align 1
@.str.331 = private unnamed_addr constant [36 x i8] c">>> Getting functions from cluster\0A\00", align 1
@.str.332 = private unnamed_addr constant [14 x i8] c"FUNCTION DUMP\00", align 1
@.str.333 = private unnamed_addr constant [130 x i8] c">>> Failed retrieving Functions from the cluster, skip this step as Redis version do not support function command (error = '%s')\0A\00", align 1
@.str.334 = private unnamed_addr constant [11 x i8] c"NULL reply\00", align 1
@.str.335 = private unnamed_addr constant [71 x i8] c">>> Send FUNCTION LIST to %s:%d to verify there is no functions in it\0A\00", align 1
@.str.336 = private unnamed_addr constant [14 x i8] c"FUNCTION LIST\00", align 1
@.str.337 = private unnamed_addr constant [44 x i8] c">>> Failed on CLUSTER LIST (error = '%s')\0D\0A\00", align 1
@.str.338 = private unnamed_addr constant [113 x i8] c">>> New node already contains functions and can not be added to the cluster. Use FUNCTION FLUSH and try again.\0D\0A\00", align 1
@.str.339 = private unnamed_addr constant [36 x i8] c">>> Send FUNCTION RESTORE to %s:%d\0A\00", align 1
@.str.340 = private unnamed_addr constant [20 x i8] c"FUNCTION RESTORE %b\00", align 1
@.str.341 = private unnamed_addr constant [62 x i8] c">>> Failed loading functions to the new node (error = '%s')\0D\0A\00", align 1
@.str.342 = private unnamed_addr constant [66 x i8] c">>> Send CLUSTER MEET to node %s:%d to make it join the cluster.\0A\00", align 1
@.str.343 = private unnamed_addr constant [19 x i8] c"CLUSTER MEET %s %d\00", align 1
@.str.344 = private unnamed_addr constant [22 x i8] c"CLUSTER MEET %s %d %d\00", align 1
@.str.345 = private unnamed_addr constant [41 x i8] c">>> Configure node as replica of %s:%d.\0A\00", align 1
@.str.346 = private unnamed_addr constant [32 x i8] c"[OK] New node added correctly.\0A\00", align 1
@.str.347 = private unnamed_addr constant [139 x i8] c"[ERR] Invalid arguments: you need to pass either a valid address (ie. 120.0.0.1:7000) or space separated IP and port (ie. 120.0.0.1 7000)\0A\00", align 1
@.str.348 = private unnamed_addr constant [41 x i8] c">>> Removing node %s from cluster %s:%d\0A\00", align 1
@.str.349 = private unnamed_addr constant [26 x i8] c"[ERR] No such node ID %s\0A\00", align 1
@.str.350 = private unnamed_addr constant [65 x i8] c"[ERR] Node %s:%d is not empty! Reshard data away and try again.\0A\00", align 1
@.str.351 = private unnamed_addr constant [55 x i8] c">>> Sending CLUSTER FORGET messages to the cluster...\0A\00", align 1
@.str.352 = private unnamed_addr constant [31 x i8] c">>> %s:%d as replica of %s:%d\0A\00", align 1
@.str.353 = private unnamed_addr constant [18 x i8] c"CLUSTER FORGET %s\00", align 1
@.str.354 = private unnamed_addr constant [53 x i8] c">>> Sending CLUSTER RESET SOFT to the deleted node.\0A\00", align 1
@.str.355 = private unnamed_addr constant [17 x i8] c"CLUSTER RESET %s\00", align 1
@.str.356 = private unnamed_addr constant [5 x i8] c"SOFT\00", align 1
@.str.357 = private unnamed_addr constant [7 x i8] c"DBSIZE\00", align 1
@.str.358 = private unnamed_addr constant [52 x i8] c"%s:%d (%s...) -> %lld keys | %d slots | %d slaves.\0A\00", align 1
@.str.359 = private unnamed_addr constant [31 x i8] c"[OK] %lld keys in %d masters.\0A\00", align 1
@.str.360 = private unnamed_addr constant [32 x i8] c"%.2f keys per slot on average.\0A\00", align 1
@.str.361 = private unnamed_addr constant [56 x i8] c"*** Please fix your cluster problems before resharding\0A\00", align 1
@.str.362 = private unnamed_addr constant [52 x i8] c"How many slots do you want to move (from 1 to %d)? \00", align 1
@.str.363 = private unnamed_addr constant [32 x i8] c"What is the receiving node ID? \00", align 1
@.str.364 = private unnamed_addr constant [39 x i8] c"Please enter all the source node IDs.\0A\00", align 1
@.str.365 = private unnamed_addr constant [71 x i8] c"  Type 'all' to use all the nodes as source nodes for the hash slots.\0A\00", align 1
@.str.366 = private unnamed_addr constant [58 x i8] c"  Type 'done' once you entered all the source nodes IDs.\0A\00", align 1
@.str.367 = private unnamed_addr constant [19 x i8] c"Source node #%lu: \00", align 1
@.str.368 = private unnamed_addr constant [5 x i8] c"done\00", align 1
@.str.369 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.370 = private unnamed_addr constant [47 x i8] c"*** No source nodes given, operation aborted.\0A\00", align 1
@.str.371 = private unnamed_addr constant [26 x i8] c"\0AReady to move %d slots.\0A\00", align 1
@.str.372 = private unnamed_addr constant [17 x i8] c"  Source nodes:\0A\00", align 1
@.str.373 = private unnamed_addr constant [21 x i8] c"  Destination node:\0A\00", align 1
@.str.374 = private unnamed_addr constant [20 x i8] c"  Resharding plan:\0A\00", align 1
@.str.375 = private unnamed_addr constant [65 x i8] c"Do you want to proceed with the proposed reshard plan (yes/no)? \00", align 1
@.str.376 = private unnamed_addr constant [35 x i8] c"clusterManagerMoveSlot failed: %s\0A\00", align 1
@.str.377 = private unnamed_addr constant [73 x i8] c"*** The specified node (%s) is not known or not a master, please retry.\0A\00", align 1
@.str.378 = private unnamed_addr constant [63 x i8] c"*** It is not possible to use the target node as source node.\0A\00", align 1
@.str.379 = private unnamed_addr constant [28 x i8] c"    Moving slot %d from %s\0A\00", align 1
@.str.380 = private unnamed_addr constant [22 x i8] c"*** invalid input %s\0A\00", align 1
@.str.381 = private unnamed_addr constant [28 x i8] c"*** No such master node %s\0A\00", align 1
@.str.382 = private unnamed_addr constant [57 x i8] c"*** Please fix your cluster problems before rebalancing\0A\00", align 1
@.str.383 = private unnamed_addr constant [71 x i8] c"*** No rebalancing needed! All nodes are within the %.2f%% threshold.\0A\00", align 1
@.str.384 = private unnamed_addr constant [54 x i8] c">>> Rebalancing across %d nodes. Total weight = %.2f\0A\00", align 1
@.str.385 = private unnamed_addr constant [27 x i8] c"%s:%d balance is %d slots\0A\00", align 1
@.str.386 = private unnamed_addr constant [37 x i8] c"Moving %d slots from %s:%d to %s:%d\0A\00", align 1
@.str.387 = private unnamed_addr constant [55 x i8] c"*** Assertion failed: Reshard table != number of slots\00", align 1
@.str.388 = private unnamed_addr constant [2 x i8] c"#\00", align 1
@.str.389 = private unnamed_addr constant [32 x i8] c"*** clusterManagerMoveSlot: %s\0A\00", align 1
@.str.390 = private unnamed_addr constant [69 x i8] c"Setting a node timeout of less than 100 milliseconds is a bad idea.\0A\00", align 1
@.str.391 = private unnamed_addr constant [57 x i8] c">>> Reconfiguring node timeout in every cluster node...\0A\00", align 1
@.str.392 = private unnamed_addr constant [16 x i8] c"CONFIG %s %s %d\00", align 1
@.str.393 = private unnamed_addr constant [4 x i8] c"SET\00", align 1
@.str.394 = private unnamed_addr constant [21 x i8] c"cluster-node-timeout\00", align 1
@.str.395 = private unnamed_addr constant [10 x i8] c"CONFIG %s\00", align 1
@.str.396 = private unnamed_addr constant [8 x i8] c"REWRITE\00", align 1
@.str.397 = private unnamed_addr constant [31 x i8] c"*** New timeout set for %s:%d\0A\00", align 1
@.str.398 = private unnamed_addr constant [40 x i8] c"ERR setting node-timeout for %s:%d: %s\0A\00", align 1
@.str.399 = private unnamed_addr constant [42 x i8] c">>> New node timeout set. %d OK, %d ERR.\0A\00", align 1
@.str.400 = private unnamed_addr constant [68 x i8] c"[ERR] Option '--cluster-from' is required for subcommand 'import'.\0A\00", align 1
@.str.401 = private unnamed_addr constant [91 x i8] c"[ERR] Invalid --cluster-from host. You need to pass a valid address (ie. 120.0.0.1:7000).\0A\00", align 1
@.str.402 = private unnamed_addr constant [48 x i8] c">>> Importing data from %s:%d to cluster %s:%d\0A\00", align 1
@.str.403 = private unnamed_addr constant [42 x i8] c"Could not connect to Redis at %s:%d: %s.\0A\00", align 1
@.str.404 = private unnamed_addr constant [53 x i8] c"[ERR] The source node should not be a cluster node.\0A\00", align 1
@.str.405 = private unnamed_addr constant [33 x i8] c"*** Importing %d keys from DB 0\0A\00", align 1
@.str.406 = private unnamed_addr constant [23 x i8] c"MIGRATE %s %d %s %d %d\00", align 1
@.str.407 = private unnamed_addr constant [13 x i8] c" AUTH2 %s %s\00", align 1
@.str.408 = private unnamed_addr constant [9 x i8] c" AUTH %s\00", align 1
@.str.409 = private unnamed_addr constant [6 x i8] c" COPY\00", align 1
@.str.410 = private unnamed_addr constant [9 x i8] c" REPLACE\00", align 1
@.str.411 = private unnamed_addr constant [17 x i8] c"SCAN %d COUNT %d\00", align 1
@.str.412 = private unnamed_addr constant [24 x i8] c"Migrating %s to %s:%d: \00", align 1
@.str.413 = private unnamed_addr constant [37 x i8] c"Source %s:%d replied with error:\0A%s\0A\00", align 1
@.str.414 = private unnamed_addr constant [4 x i8] c"OK\0A\00", align 1
@.str.415 = private unnamed_addr constant [17 x i8] c"AUTH failed: %s\0A\00", align 1
@.str.416 = private unnamed_addr constant [6 x i8] c"\0D\1B[0K\00", align 1
@.str.417 = private unnamed_addr constant [20 x i8] c"Reconnecting... %d\0D\00", align 1
@.str.418 = private unnamed_addr constant [11 x i8] c"Error: %s\0A\00", align 1
@.str.419 = private unnamed_addr constant [12 x i8] c">>> Calling\00", align 1
@.str.420 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@.str.421 = private unnamed_addr constant [16 x i8] c"%s:%d: Failed!\0A\00", align 1
@.str.422 = private unnamed_addr constant [13 x i8] c"<endsession>\00", align 1
@.str.423 = private unnamed_addr constant [7 x i8] c"(true)\00", align 1
@.str.424 = private unnamed_addr constant [8 x i8] c"(false)\00", align 1
@.str.425 = private unnamed_addr constant [24 x i8] c"Unknown reply type: %d\0A\00", align 1
@.str.426 = private unnamed_addr constant [9 x i8] c"redis %s\00", align 1
@.str.427 = private unnamed_addr constant [5 x i8] c"[%i]\00", align 1
@.str.428 = private unnamed_addr constant [5 x i8] c"(TX)\00", align 1
@.str.429 = private unnamed_addr constant [18 x i8] c"(subscribed mode)\00", align 1
@.str.430 = private unnamed_addr constant [3 x i8] c"> \00", align 1
@.str.431 = private unnamed_addr constant [8 x i8] c"[%s]:%d\00", align 1
@.str.432 = private unnamed_addr constant [6 x i8] c"%s:%d\00", align 1
@.str.433 = private unnamed_addr constant [3 x i8] c"[\0A\00", align 1
@.str.434 = private unnamed_addr constant [3 x i8] c",\0A\00", align 1
@.str.435 = private unnamed_addr constant [33 x i8] c">>> Node %s:%d -> Saving RDB...\0A\00", align 1
@.str.436 = private unnamed_addr constant [3 x i8] c"\0A]\00", align 1
@.str.437 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.438 = private unnamed_addr constant [11 x i8] c"nodes.json\00", align 1
@.str.439 = private unnamed_addr constant [37 x i8] c"Saving cluster configuration to: %s\0A\00", align 1
@.str.440 = private unnamed_addr constant [3 x i8] c"w+\00", align 1
@.str.441 = private unnamed_addr constant [29 x i8] c"Could not save nodes to: %s\0A\00", align 1
@.str.442 = private unnamed_addr constant [104 x i8] c"*** Cluster seems to have some problems, please be aware of it if you're going to restore this backup.\0A\00", align 1
@.str.443 = private unnamed_addr constant [30 x i8] c"[OK] Backup created into: %s\0A\00", align 1
@.str.444 = private unnamed_addr constant [31 x i8] c"[ERR] Failed to back cluster!\0A\00", align 1
@.str.445 = private unnamed_addr constant [5 x i8] c"\22%s\22\00", align 1
@.str.446 = private unnamed_addr constant [5 x i8] c"null\00", align 1
@.str.447 = private unnamed_addr constant [164 x i8] c"  {\0A    \22name\22: \22%s\22,\0A    \22host\22: \22%s\22,\0A    \22port\22: %d,\0A    \22replicate\22: %s,\0A    \22slots\22: [%s],\0A    \22slots_count\22: %d,\0A    \22flags\22: \22%s\22,\0A    \22current_epoch\22: %llu\00", align 1
@.str.448 = private unnamed_addr constant [28 x i8] c",\0A    \22cluster_errors\22: %lu\00", align 1
@.str.449 = private unnamed_addr constant [11 x i8] c"\22%S\22: \22%S\22\00", align 1
@.str.450 = private unnamed_addr constant [24 x i8] c",\0A    \22migrating\22: {%S}\00", align 1
@.str.451 = private unnamed_addr constant [24 x i8] c",\0A    \22importing\22: {%S}\00", align 1
@.str.452 = private unnamed_addr constant [5 x i8] c"\0A  }\00", align 1
@.str.453 = private unnamed_addr constant [27 x i8] c"Cluster Manager Commands:\0A\00", align 1
@.str.454 = private unnamed_addr constant [5 x i8] c"  %s\00", align 1
@.str.455 = private unnamed_addr constant [16 x i8] c"  --cluster-%s\0A\00", align 1
@.str.456 = private unnamed_addr constant [158 x i8] c"\0AFor check, fix, reshard, del-node, set-timeout, info, rebalance, call, import, backup you can specify the host and port of any working node in the cluster.\0A\00", align 1
@.str.457 = private unnamed_addr constant [27 x i8] c"\0ACluster Manager Options:\0A\00", align 1
@__const.cliInitHelp.groupsdt = private unnamed_addr constant %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@.str.458 = private unnamed_addr constant [13 x i8] c"COMMAND DOCS\00", align 1
@redisCommandTable = external global [0 x %struct.commandDocs], align 8
@cliGetServerVersion.key = internal global ptr @.str.459, align 8
@.str.459 = private unnamed_addr constant [16 x i8] c"\0Aredis_version:\00", align 1
@.str.460 = private unnamed_addr constant [12 x i8] c"INFO SERVER\00", align 1
@.str.461 = private unnamed_addr constant [8 x i8] c"COMMAND\00", align 1
@.str.462 = private unnamed_addr constant [5 x i8] c"key \00", align 1
@.str.463 = private unnamed_addr constant [5 x i8] c"arg \00", align 1
@.str.464 = private unnamed_addr constant [14 x i8] c"...options...\00", align 1
@.str.465 = private unnamed_addr constant [19 x i8] c"Help not available\00", align 1
@.str.466 = private unnamed_addr constant [10 x i8] c"Not known\00", align 1
@.str.467 = private unnamed_addr constant [8 x i8] c"generic\00", align 1
@.str.468 = private unnamed_addr constant [3 x i8] c"-h\00", align 1
@.str.469 = private unnamed_addr constant [7 x i8] c"--help\00", align 1
@.str.470 = private unnamed_addr constant [3 x i8] c"-x\00", align 1
@.str.471 = private unnamed_addr constant [3 x i8] c"-X\00", align 1
@.str.472 = private unnamed_addr constant [3 x i8] c"-p\00", align 1
@.str.473 = private unnamed_addr constant [22 x i8] c"Invalid server port.\0A\00", align 1
@.str.474 = private unnamed_addr constant [3 x i8] c"-s\00", align 1
@.str.475 = private unnamed_addr constant [3 x i8] c"-r\00", align 1
@.str.476 = private unnamed_addr constant [3 x i8] c"-i\00", align 1
@.str.477 = private unnamed_addr constant [3 x i8] c"-n\00", align 1
@.str.478 = private unnamed_addr constant [18 x i8] c"--no-auth-warning\00", align 1
@.str.479 = private unnamed_addr constant [10 x i8] c"--askpass\00", align 1
@.str.480 = private unnamed_addr constant [3 x i8] c"-a\00", align 1
@.str.481 = private unnamed_addr constant [7 x i8] c"--pass\00", align 1
@.str.482 = private unnamed_addr constant [7 x i8] c"--user\00", align 1
@.str.483 = private unnamed_addr constant [3 x i8] c"-u\00", align 1
@.str.484 = private unnamed_addr constant [10 x i8] c"redis-cli\00", align 1
@.str.485 = private unnamed_addr constant [6 x i8] c"--raw\00", align 1
@.str.486 = private unnamed_addr constant [9 x i8] c"--no-raw\00", align 1
@.str.487 = private unnamed_addr constant [15 x i8] c"--quoted-input\00", align 1
@.str.488 = private unnamed_addr constant [6 x i8] c"--csv\00", align 1
@.str.489 = private unnamed_addr constant [7 x i8] c"--json\00", align 1
@.str.490 = private unnamed_addr constant [14 x i8] c"--quoted-json\00", align 1
@.str.491 = private unnamed_addr constant [10 x i8] c"--latency\00", align 1
@.str.492 = private unnamed_addr constant [15 x i8] c"--latency-dist\00", align 1
@.str.493 = private unnamed_addr constant [7 x i8] c"--mono\00", align 1
@.str.494 = private unnamed_addr constant [18 x i8] c"--latency-history\00", align 1
@.str.495 = private unnamed_addr constant [11 x i8] c"--lru-test\00", align 1
@.str.496 = private unnamed_addr constant [8 x i8] c"--slave\00", align 1
@.str.497 = private unnamed_addr constant [10 x i8] c"--replica\00", align 1
@.str.498 = private unnamed_addr constant [7 x i8] c"--stat\00", align 1
@.str.499 = private unnamed_addr constant [7 x i8] c"--scan\00", align 1
@.str.500 = private unnamed_addr constant [10 x i8] c"--pattern\00", align 1
@.str.501 = private unnamed_addr constant [8 x i8] c"--count\00", align 1
@.str.502 = private unnamed_addr constant [17 x i8] c"--quoted-pattern\00", align 1
@.str.503 = private unnamed_addr constant [55 x i8] c"Invalid quoted string specified for --quoted-pattern.\0A\00", align 1
@.str.504 = private unnamed_addr constant [20 x i8] c"--intrinsic-latency\00", align 1
@.str.505 = private unnamed_addr constant [6 x i8] c"--rdb\00", align 1
@.str.506 = private unnamed_addr constant [16 x i8] c"--functions-rdb\00", align 1
@.str.507 = private unnamed_addr constant [7 x i8] c"--pipe\00", align 1
@.str.508 = private unnamed_addr constant [15 x i8] c"--pipe-timeout\00", align 1
@.str.509 = private unnamed_addr constant [10 x i8] c"--bigkeys\00", align 1
@.str.510 = private unnamed_addr constant [10 x i8] c"--memkeys\00", align 1
@.str.511 = private unnamed_addr constant [18 x i8] c"--memkeys-samples\00", align 1
@.str.512 = private unnamed_addr constant [10 x i8] c"--hotkeys\00", align 1
@.str.513 = private unnamed_addr constant [7 x i8] c"--eval\00", align 1
@.str.514 = private unnamed_addr constant [6 x i8] c"--ldb\00", align 1
@.str.515 = private unnamed_addr constant [16 x i8] c"--ldb-sync-mode\00", align 1
@.str.516 = private unnamed_addr constant [3 x i8] c"-c\00", align 1
@.str.517 = private unnamed_addr constant [3 x i8] c"-d\00", align 1
@.str.518 = private unnamed_addr constant [3 x i8] c"-D\00", align 1
@.str.519 = private unnamed_addr constant [3 x i8] c"-e\00", align 1
@.str.520 = private unnamed_addr constant [10 x i8] c"--verbose\00", align 1
@.str.521 = private unnamed_addr constant [10 x i8] c"--cluster\00", align 1
@.str.522 = private unnamed_addr constant [23 x i8] c"--cluster-only-masters\00", align 1
@.str.523 = private unnamed_addr constant [24 x i8] c"--cluster-only-replicas\00", align 1
@.str.524 = private unnamed_addr constant [19 x i8] c"--cluster-replicas\00", align 1
@.str.525 = private unnamed_addr constant [20 x i8] c"--cluster-master-id\00", align 1
@.str.526 = private unnamed_addr constant [15 x i8] c"--cluster-from\00", align 1
@.str.527 = private unnamed_addr constant [13 x i8] c"--cluster-to\00", align 1
@.str.528 = private unnamed_addr constant [20 x i8] c"--cluster-from-user\00", align 1
@.str.529 = private unnamed_addr constant [20 x i8] c"--cluster-from-pass\00", align 1
@.str.530 = private unnamed_addr constant [23 x i8] c"--cluster-from-askpass\00", align 1
@.str.531 = private unnamed_addr constant [17 x i8] c"--cluster-weight\00", align 1
@.str.532 = private unnamed_addr constant [156 x i8] c"WARNING: you cannot use --cluster-weight more than once.\0AYou can set more weights by adding them as a space-separated list, ie:\0A--cluster-weight n1=w n2=w\0A\00", align 1
@.str.533 = private unnamed_addr constant [3 x i8] c"--\00", align 1
@.str.534 = private unnamed_addr constant [16 x i8] c"--cluster-slots\00", align 1
@.str.535 = private unnamed_addr constant [18 x i8] c"--cluster-timeout\00", align 1
@.str.536 = private unnamed_addr constant [19 x i8] c"--cluster-pipeline\00", align 1
@.str.537 = private unnamed_addr constant [20 x i8] c"--cluster-threshold\00", align 1
@.str.538 = private unnamed_addr constant [19 x i8] c"--cluster-simulate\00", align 1
@.str.539 = private unnamed_addr constant [18 x i8] c"--cluster-replace\00", align 1
@.str.540 = private unnamed_addr constant [15 x i8] c"--cluster-copy\00", align 1
@.str.541 = private unnamed_addr constant [16 x i8] c"--cluster-slave\00", align 1
@.str.542 = private unnamed_addr constant [28 x i8] c"--cluster-use-empty-masters\00", align 1
@.str.543 = private unnamed_addr constant [33 x i8] c"--cluster-search-multiple-owners\00", align 1
@.str.544 = private unnamed_addr constant [39 x i8] c"--cluster-fix-with-unreachable-masters\00", align 1
@.str.545 = private unnamed_addr constant [12 x i8] c"--test_hint\00", align 1
@.str.546 = private unnamed_addr constant [17 x i8] c"--test_hint_file\00", align 1
@.str.547 = private unnamed_addr constant [3 x i8] c"-v\00", align 1
@.str.548 = private unnamed_addr constant [10 x i8] c"--version\00", align 1
@.str.549 = private unnamed_addr constant [14 x i8] c"redis-cli %s\0A\00", align 1
@.str.550 = private unnamed_addr constant [3 x i8] c"-2\00", align 1
@.str.551 = private unnamed_addr constant [3 x i8] c"-3\00", align 1
@.str.552 = private unnamed_addr constant [14 x i8] c"--show-pushes\00", align 1
@.str.553 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.554 = private unnamed_addr constant [2 x i8] c"y\00", align 1
@.str.555 = private unnamed_addr constant [59 x i8] c"Unknown --show-pushes value '%s' (valid: '[y]es', '[n]o')\0A\00", align 1
@.str.556 = private unnamed_addr constant [53 x i8] c"Unrecognized option or bad number of args for: '%s'\0A\00", align 1
@.str.557 = private unnamed_addr constant [43 x i8] c"Options -c and -s are mutually exclusive.\0A\00", align 1
@.str.558 = private unnamed_addr constant [43 x i8] c"Options -2 and -3 are mutually exclusive.\0A\00", align 1
@.str.559 = private unnamed_addr constant [51 x i8] c"Options --ldb and --ldb-sync-mode require --eval.\0A\00", align 1
@.str.560 = private unnamed_addr constant [37 x i8] c"Try %s --help for more information.\0A\00", align 1
@.str.561 = private unnamed_addr constant [99 x i8] c"Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.\0A\00", align 1
@.str.562 = private unnamed_addr constant [58 x i8] c"Option --functions-rdb and --rdb are mutually exclusive.\0A\00", align 1
@.str.563 = private unnamed_addr constant [43 x i8] c"Options -x and -X are mutually exclusive.\0A\00", align 1
@.str.564 = private unnamed_addr constant [2861 x i8] c"redis-cli %s\0A\0AUsage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\0A  -h <hostname>      Server hostname (default: 127.0.0.1).\0A  -p <port>          Server port (default: 6379).\0A  -s <socket>        Server socket (overrides hostname and port).\0A  -a <password>      Password to use when connecting to the server.\0A                     You can also use the REDISCLI_AUTH environment\0A                     variable to pass this password more safely\0A                     (if both are used, this argument takes precedence).\0A  --user <username>  Used to send ACL style 'AUTH username pass'. Needs -a.\0A  --pass <password>  Alias of -a for consistency with the new --user option.\0A  --askpass          Force user to input password with mask from STDIN.\0A                     If this argument is used, '-a' and REDISCLI_AUTH\0A                     environment variable will be ignored.\0A  -u <uri>           Server URI on format redis://user:password@host:port/dbnum\0A                     User, password and dbnum are optional. For authentication\0A                     without a username, use username 'default'. For TLS, use\0A                     the scheme 'rediss'.\0A  -r <repeat>        Execute specified command N times.\0A  -i <interval>      When -r is used, waits <interval> seconds per command.\0A                     It is possible to specify sub-second times like -i 0.1.\0A                     This interval is also used in --scan and --stat per cycle.\0A                     and in --bigkeys, --memkeys, and --hotkeys per 100 cycles.\0A  -n <db>            Database number.\0A  -2                 Start session in RESP2 protocol mode.\0A  -3                 Start session in RESP3 protocol mode.\0A  -x                 Read last argument from STDIN (see example below).\0A  -X                 Read <tag> argument from STDIN (see example below).\0A  -d <delimiter>     Delimiter between response bulks for raw formatting (default: \\n).\0A  -D <delimiter>     Delimiter between responses for raw formatting (default: \\n).\0A  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).\0A  -e                 Return exit error code when command execution fails.\0A%s  --raw              Use raw formatting for replies (default when STDOUT is\0A                     not a tty).\0A  --no-raw           Force formatted output even when STDOUT is not a tty.\0A  --quoted-input     Force input to be handled as quoted strings.\0A  --csv              Output in CSV format.\0A  --json             Output in JSON format (default RESP3, use -2 if you want to use with RESP2).\0A  --quoted-json      Same as --json, but produce ASCII-safe quoted strings, not Unicode.\0A  --show-pushes <yn> Whether to print RESP3 PUSH messages.  Enabled by default when\0A                     STDOUT is a tty but can be overridden with --show-pushes no.\0A  --stat             Print rolling stats about server: mem, clients, ...\0A\00", align 1
@.str.565 = private unnamed_addr constant [1504 x i8] c"  --latency          Enter a special mode continuously sampling latency.\0A                     If you use this mode in an interactive session it runs\0A                     forever displaying real-time stats. Otherwise if --raw or\0A                     --csv is specified, or if you redirect the output to a non\0A                     TTY, it samples the latency for 1 second (you can use\0A                     -i to change the interval), then produces a single output\0A                     and exits.\0A  --latency-history  Like --latency but tracking latency changes over time.\0A                     Default time interval is 15 sec. Change it using -i.\0A  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\0A                     Default time interval is 1 sec. Change it using -i.\0A  --lru-test <keys>  Simulate a cache workload with an 80-20 distribution.\0A  --replica          Simulate a replica showing commands received from the master.\0A  --rdb <filename>   Transfer an RDB dump from remote server to local file.\0A                     Use filename of \22-\22 to write to stdout.\0A  --functions-rdb <filename> Like --rdb but only get the functions (not the keys)\0A                     when getting the RDB dump file.\0A  --pipe             Transfer raw Redis protocol from stdin to server.\0A  --pipe-timeout <n> In --pipe mode, abort with error if after sending all data.\0A                     no reply is received within <n> seconds.\0A                     Default timeout: %d. Use 0 to wait forever.\0A\00", align 1
@.str.566 = private unnamed_addr constant [1754 x i8] c"  --bigkeys          Sample Redis keys looking for keys with many elements (complexity).\0A  --memkeys          Sample Redis keys looking for keys consuming a lot of memory.\0A  --memkeys-samples <n> Sample Redis keys looking for keys consuming a lot of memory.\0A                     And define number of key elements to sample\0A  --hotkeys          Sample Redis keys looking for hot keys.\0A                     only works when maxmemory-policy is *lfu.\0A  --scan             List all keys using the SCAN command.\0A  --pattern <pat>    Keys pattern when using the --scan, --bigkeys or --hotkeys\0A                     options (default: *).\0A  --count <count>    Count option when using the --scan, --bigkeys or --hotkeys (default: 10).\0A  --quoted-pattern <pat> Same as --pattern, but the specified string can be\0A                         quoted, in order to pass an otherwise non binary-safe string.\0A  --intrinsic-latency <sec> Run a test to measure intrinsic system latency.\0A                     The test will run for the specified amount of seconds.\0A  --eval <file>      Send an EVAL command using the Lua script at <file>.\0A  --ldb              Used with --eval enable the Redis Lua debugger.\0A  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\0A                     this mode the server is blocked and script changes are\0A                     not rolled back from the server memory.\0A  --cluster <command> [args...] [opts...]\0A                     Cluster Manager command and arguments (see below).\0A  --verbose          Verbose mode.\0A  --no-auth-warning  Don't show warning message when using password on command\0A                     line interface.\0A  --help             Output this help and exit.\0A  --version          Output version and exit.\0A\0A\00", align 1
@.str.567 = private unnamed_addr constant [847 x i8] c"Cluster Manager Commands:\0A  Use --cluster help to list all available cluster manager commands.\0A\0AExamples:\0A  redis-cli -u redis://default:PASSWORD@localhost:6379/0\0A  cat /etc/passwd | redis-cli -x set mypasswd\0A  redis-cli -D \22\22 --raw dump key > key.dump && redis-cli -X dump_tag restore key2 0 dump_tag replace < key.dump\0A  redis-cli -r 100 lpush mylist x\0A  redis-cli -r 100 -i 1 info | grep used_memory_human:\0A  redis-cli --quoted-input set '\22null-\\x00-separated\22' value\0A  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\0A  redis-cli --scan --pattern '*:12345*'\0A  redis-cli --scan --pattern '*:12345*' --count 100\0A\0A  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\0A\0AWhen no command is given, redis-cli starts in interactive mode.\0AType \22help\22 in interactive mode for information on available commands\0Aand settings.\0A\0A\00", align 1
@.str.568 = private unnamed_addr constant [42 x i8] c"Using -X option but stdin tag not match.\0A\00", align 1
@.str.569 = private unnamed_addr constant [12 x i8] c"255.255.255\00", align 1
@.str.570 = private unnamed_addr constant [9 x i8] c" (git:%s\00", align 1
@.str.571 = private unnamed_addr constant [7 x i8] c"-dirty\00", align 1
@.str.572 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.573 = private unnamed_addr constant [14 x i8] c"REDISCLI_AUTH\00", align 1
@.str.574 = private unnamed_addr constant [21 x i8] c"REDISCLI_CLUSTER_YES\00", align 1
@.str.575 = private unnamed_addr constant [69 x i8] c"[ERR] Wrong number of arguments for specified --cluster sub command\0A\00", align 1
@.str.576 = private unnamed_addr constant [30 x i8] c"Unknown --cluster subcommand\0A\00", align 1
@.str.577 = private unnamed_addr constant [42 x i8] c"Could not negotiate a TLS connection: %s\0A\00", align 1
@.str.578 = private unnamed_addr constant [8 x i8] c"%s: %s\0A\00", align 1
@.str.579 = private unnamed_addr constant [10 x i8] c"SELECT %d\00", align 1
@.str.580 = private unnamed_addr constant [22 x i8] c"SELECT %d failed: %s\0A\00", align 1
@.str.581 = private unnamed_addr constant [8 x i8] c"HELLO 3\00", align 1
@.str.582 = private unnamed_addr constant [20 x i8] c"HELLO 3 failed: %s\0A\00", align 1
@.str.583 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.584 = private unnamed_addr constant [11 x i8] c"invalidate\00", align 1
@.str.585 = private unnamed_addr constant [16 x i8] c"-> invalidate: \00", align 1
@.str.586 = private unnamed_addr constant [5 x i8] c"'%s'\00", align 1
@.str.587 = private unnamed_addr constant [36 x i8] c"Error:  Unknown output encoding %d\0A\00", align 1
@.str.588 = private unnamed_addr constant [12 x i8] c"(error) %s\0A\00", align 1
@.str.589 = private unnamed_addr constant [16 x i8] c"(integer) %lld\0A\00", align 1
@.str.590 = private unnamed_addr constant [13 x i8] c"(double) %s\0A\00", align 1
@.str.591 = private unnamed_addr constant [7 x i8] c"(nil)\0A\00", align 1
@.str.592 = private unnamed_addr constant [8 x i8] c"(true)\0A\00", align 1
@.str.593 = private unnamed_addr constant [9 x i8] c"(false)\0A\00", align 1
@.str.594 = private unnamed_addr constant [15 x i8] c"(empty array)\0A\00", align 1
@.str.595 = private unnamed_addr constant [14 x i8] c"(empty hash)\0A\00", align 1
@.str.596 = private unnamed_addr constant [13 x i8] c"(empty set)\0A\00", align 1
@.str.597 = private unnamed_addr constant [14 x i8] c"(empty push)\0A\00", align 1
@.str.598 = private unnamed_addr constant [24 x i8] c"(empty aggregate type)\0A\00", align 1
@.str.599 = private unnamed_addr constant [12 x i8] c"%%s%%%ud%c \00", align 1
@.str.600 = private unnamed_addr constant [5 x i8] c" => \00", align 1
@.str.601 = private unnamed_addr constant [7 x i8] c"ERROR,\00", align 1
@.str.602 = private unnamed_addr constant [5 x i8] c"NULL\00", align 1
@.str.603 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@.str.604 = private unnamed_addr constant [6 x i8] c"false\00", align 1
@.str.605 = private unnamed_addr constant [7 x i8] c"error:\00", align 1
@.str.606 = private unnamed_addr constant [2 x i8] c"{\00", align 1
@.str.607 = private unnamed_addr constant [5 x i8] c"\22%S\22\00", align 1
@.str.608 = private unnamed_addr constant [2 x i8] c":\00", align 1
@.str.609 = private unnamed_addr constant [2 x i8] c"}\00", align 1
@.str.610 = private unnamed_addr constant [3 x i8] c"\\\\\00", align 1
@.str.611 = private unnamed_addr constant [5 x i8] c"PING\00", align 1
@.str.612 = private unnamed_addr constant [9 x i8] c"\1B[0G\1B[2K\00", align 1
@.str.613 = private unnamed_addr constant [24 x i8] c" -- %.2f seconds range\0A\00", align 1
@.str.614 = private unnamed_addr constant [47 x i8] c"min: %lld, max: %lld, avg: %.2f (%lld samples)\00", align 1
@.str.615 = private unnamed_addr constant [21 x i8] c"%lld,%lld,%.2f,%lld\0A\00", align 1
@.str.616 = private unnamed_addr constant [21 x i8] c"%lld %lld %.2f %lld\0A\00", align 1
@.str.617 = private unnamed_addr constant [56 x i8] c"{\22min\22: %lld, \22max\22: %lld, \22avg\22: %.2f, \22count\22: %lld}\0A\00", align 1
@__const.latencyDistMode.samples = private unnamed_addr constant [31 x %struct.distsamples] [%struct.distsamples { i64 10, i64 0, i32 46 }, %struct.distsamples { i64 125, i64 0, i32 45 }, %struct.distsamples { i64 250, i64 0, i32 42 }, %struct.distsamples { i64 500, i64 0, i32 35 }, %struct.distsamples { i64 1000, i64 0, i32 49 }, %struct.distsamples { i64 2000, i64 0, i32 50 }, %struct.distsamples { i64 3000, i64 0, i32 51 }, %struct.distsamples { i64 4000, i64 0, i32 52 }, %struct.distsamples { i64 5000, i64 0, i32 53 }, %struct.distsamples { i64 6000, i64 0, i32 54 }, %struct.distsamples { i64 7000, i64 0, i32 55 }, %struct.distsamples { i64 8000, i64 0, i32 56 }, %struct.distsamples { i64 9000, i64 0, i32 57 }, %struct.distsamples { i64 10000, i64 0, i32 65 }, %struct.distsamples { i64 20000, i64 0, i32 66 }, %struct.distsamples { i64 30000, i64 0, i32 67 }, %struct.distsamples { i64 40000, i64 0, i32 68 }, %struct.distsamples { i64 50000, i64 0, i32 69 }, %struct.distsamples { i64 100000, i64 0, i32 70 }, %struct.distsamples { i64 200000, i64 0, i32 71 }, %struct.distsamples { i64 300000, i64 0, i32 72 }, %struct.distsamples { i64 400000, i64 0, i32 73 }, %struct.distsamples { i64 500000, i64 0, i32 74 }, %struct.distsamples { i64 1000000, i64 0, i32 75 }, %struct.distsamples { i64 2000000, i64 0, i32 76 }, %struct.distsamples { i64 4000000, i64 0, i32 77 }, %struct.distsamples { i64 8000000, i64 0, i32 78 }, %struct.distsamples { i64 16000000, i64 0, i32 79 }, %struct.distsamples { i64 30000000, i64 0, i32 80 }, %struct.distsamples { i64 60000000, i64 0, i32 81 }, %struct.distsamples { i64 0, i64 0, i32 63 }], align 16
@slaveMode.eofmark = internal global [40 x i8] zeroinitializer, align 16
@slaveMode.lastbytes = internal global [40 x i8] zeroinitializer, align 16
@slaveMode.usemark = internal global i32 0, align 4
@slaveMode.out_full_mode = internal global i32 0, align 4
@.str.618 = private unnamed_addr constant [12 x i8] c"Full resync\00", align 1
@.str.619 = private unnamed_addr constant [15 x i8] c"Partial resync\00", align 1
@.str.620 = private unnamed_addr constant [71 x i8] c"%s with master, discarding bytes of bulk transfer until EOF marker...\0A\00", align 1
@.str.621 = private unnamed_addr constant [59 x i8] c"%s with master, discarding %llu bytes of bulk transfer...\0A\00", align 1
@.str.622 = private unnamed_addr constant [19 x i8] c"%s with master...\0A\00", align 1
@.str.623 = private unnamed_addr constant [39 x i8] c"Error reading RDB payload while %sing\0A\00", align 1
@.str.624 = private unnamed_addr constant [57 x i8] c"%s done after %llu bytes. Logging commands from master.\0A\00", align 1
@.str.625 = private unnamed_addr constant [4 x i8] c"ACK\00", align 1
@.str.626 = private unnamed_addr constant [40 x i8] c"%s done. Logging commands from master.\0A\00", align 1
@.str.627 = private unnamed_addr constant [7 x i8] c"MOVED \00", align 1
@.str.628 = private unnamed_addr constant [5 x i8] c"ASK \00", align 1
@.str.629 = private unnamed_addr constant [45 x i8] c"-> Redirected to slot [%d] located at %s:%d\0A\00", align 1
@getRDB.eofmark = internal global [40 x i8] zeroinitializer, align 16
@getRDB.lastbytes = internal global [40 x i8] zeroinitializer, align 16
@getRDB.usemark = internal global i32 0, align 4
@.str.630 = private unnamed_addr constant [78 x i8] c"SYNC sent to master, writing bytes of bulk transfer until EOF marker to '%s'\0A\00", align 1
@.str.631 = private unnamed_addr constant [49 x i8] c"SYNC sent to master, writing %llu bytes to '%s'\0A\00", align 1
@.str.632 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.633 = private unnamed_addr constant [24 x i8] c"Error opening '%s': %s\0A\00", align 1
@.str.634 = private unnamed_addr constant [43 x i8] c"I/O Error reading RDB payload from socket\0A\00", align 1
@.str.635 = private unnamed_addr constant [32 x i8] c"Error writing data to file: %s\0A\00", align 1
@.str.636 = private unnamed_addr constant [12 x i8] c"short write\00", align 1
@.str.637 = private unnamed_addr constant [23 x i8] c"ftruncate failed: %s.\0A\00", align 1
@.str.638 = private unnamed_addr constant [49 x i8] c"Transfer finished with success after %llu bytes\0A\00", align 1
@.str.639 = private unnamed_addr constant [33 x i8] c"Transfer finished with success.\0A\00", align 1
@.str.640 = private unnamed_addr constant [24 x i8] c"Fail to fsync '%s': %s\0A\00", align 1
@.str.641 = private unnamed_addr constant [24 x i8] c"redis-node-%s-%d-%s.rdb\00", align 1
@.str.642 = private unnamed_addr constant [47 x i8] c"Can't set the socket in non blocking mode: %s\0A\00", align 1
@.str.643 = private unnamed_addr constant [35 x i8] c"Error reading replies from server\0A\00", align 1
@.str.644 = private unnamed_addr constant [34 x i8] c"Last reply received from server.\0A\00", align 1
@.str.645 = private unnamed_addr constant [33 x i8] c"Error writing to the server: %s\0A\00", align 1
@.str.646 = private unnamed_addr constant [22 x i8] c"Server I/O Error: %s\0A\00", align 1
@__const.pipeMode.echo = private unnamed_addr constant [44 x i8] c"\0D\0A*2\0D\0A$4\0D\0AECHO\0D\0A$20\0D\0A01234567890123456789\0D\0A\00", align 16
@.str.647 = private unnamed_addr constant [53 x i8] c"All data transferred. Waiting for the last reply...\0A\00", align 1
@.str.648 = private unnamed_addr constant [30 x i8] c"Error reading from stdin: %s\0A\00", align 1
@.str.649 = private unnamed_addr constant [37 x i8] c"No replies for %d seconds: exiting.\0A\00", align 1
@.str.650 = private unnamed_addr constant [29 x i8] c"errors: %lld, replies: %lld\0A\00", align 1
@typeinfoDictType = internal global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr null, ptr @type_free, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@.str.651 = private unnamed_addr constant [65 x i8] c"\0A# Scanning the entire keyspace to find biggest keys as well as\0A\00", align 1
@.str.652 = private unnamed_addr constant [68 x i8] c"# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\0A\00", align 1
@.str.653 = private unnamed_addr constant [48 x i8] c"# per 100 SCAN commands (not usually needed).\0A\0A\00", align 1
@.str.654 = private unnamed_addr constant [38 x i8] c"Failed to allocate storage for keys!\0A\00", align 1
@.str.655 = private unnamed_addr constant [36 x i8] c"Failed to allocate memory for key!\0A\00", align 1
@.str.656 = private unnamed_addr constant [56 x i8] c"[%05.2f%%] Biggest %-6s found so far '%s' with %llu %s\0A\00", align 1
@.str.657 = private unnamed_addr constant [37 x i8] c"[%05.2f%%] Sampled %llu keys so far\0A\00", align 1
@force_cancel_loop = internal global i32 0, align 4
@.str.658 = private unnamed_addr constant [28 x i8] c"\0A-------- summary -------\0A\0A\00", align 1
@.str.659 = private unnamed_addr constant [12 x i8] c"[%05.2f%%] \00", align 1
@.str.660 = private unnamed_addr constant [36 x i8] c"Sampled %llu keys in the keyspace!\0A\00", align 1
@.str.661 = private unnamed_addr constant [51 x i8] c"Total key length in bytes is %llu (avg len %.2f)\0A\0A\00", align 1
@.str.662 = private unnamed_addr constant [36 x i8] c"Biggest %6s found '%s' has %llu %s\0A\00", align 1
@.str.663 = private unnamed_addr constant [57 x i8] c"%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\0A\00", align 1
@.str.664 = private unnamed_addr constant [31 x i8] c"Couldn't determine DBSIZE: %s\0A\00", align 1
@.str.665 = private unnamed_addr constant [35 x i8] c"Non INTEGER response from DBSIZE!\0A\00", align 1
@.str.666 = private unnamed_addr constant [9 x i8] c"READONLY\00", align 1
@.str.667 = private unnamed_addr constant [47 x i8] c"ERR This instance has cluster support disabled\00", align 1
@.str.668 = private unnamed_addr constant [28 x i8] c"SCAN %llu MATCH %b COUNT %d\00", align 1
@.str.669 = private unnamed_addr constant [10 x i8] c"SCAN %llu\00", align 1
@.str.670 = private unnamed_addr constant [16 x i8] c"SCAN error: %s\0A\00", align 1
@.str.671 = private unnamed_addr constant [31 x i8] c"Non ARRAY response from SCAN!\0A\00", align 1
@.str.672 = private unnamed_addr constant [34 x i8] c"Invalid element count from SCAN!\0A\00", align 1
@.str.673 = private unnamed_addr constant [5 x i8] c"TYPE\00", align 1
@.str.674 = private unnamed_addr constant [42 x i8] c"Error getting type for key '%s' (%d: %s)\0A\00", align 1
@.str.675 = private unnamed_addr constant [28 x i8] c"TYPE returned an error: %s\0A\00", align 1
@.str.676 = private unnamed_addr constant [47 x i8] c"Invalid reply type (%d) for TYPE on key '%s'!\0A\00", align 1
@.str.677 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str.678 = private unnamed_addr constant [7 x i8] c"MEMORY\00", align 1
@.str.679 = private unnamed_addr constant [6 x i8] c"USAGE\00", align 1
@.str.680 = private unnamed_addr constant [8 x i8] c"SAMPLES\00", align 1
@.str.681 = private unnamed_addr constant [42 x i8] c"Error getting size for key '%s' (%d: %s)\0A\00", align 1
@.str.682 = private unnamed_addr constant [53 x i8] c"Warning:  %s on '%s' failed (may have changed type)\0A\00", align 1
@.str.683 = private unnamed_addr constant [13 x i8] c"MEMORY USAGE\00", align 1
@.str.684 = private unnamed_addr constant [61 x i8] c"\0A# Scanning the entire keyspace to find hot keys as well as\0A\00", align 1
@.str.685 = private unnamed_addr constant [56 x i8] c"[%05.2f%%] Hot key '%s' found so far with counter %llu\0A\00", align 1
@.str.686 = private unnamed_addr constant [46 x i8] c"hot key found with counter: %llu\09keyname: %s\0A\00", align 1
@.str.687 = private unnamed_addr constant [7 x i8] c"OBJECT\00", align 1
@.str.688 = private unnamed_addr constant [5 x i8] c"FREQ\00", align 1
@.str.689 = private unnamed_addr constant [42 x i8] c"Error getting freq for key '%s' (%d: %s)\0A\00", align 1
@.str.690 = private unnamed_addr constant [61 x i8] c"Warning: OBJECT freq on '%s' failed (may have been deleted)\0A\00", align 1
@.str.691 = private unnamed_addr constant [11 x i8] c"ERROR: %s\0A\00", align 1
@.str.692 = private unnamed_addr constant [157 x i8] c"------- data ------ --------------------- load -------------------- - child -\0Akeys       mem      clients blocked requests            connections          \0A\00", align 1
@.str.693 = private unnamed_addr constant [10 x i8] c"db%d:keys\00", align 1
@.str.694 = private unnamed_addr constant [4 x i8] c"%ld\00", align 1
@.str.695 = private unnamed_addr constant [6 x i8] c"%-11s\00", align 1
@.str.696 = private unnamed_addr constant [12 x i8] c"used_memory\00", align 1
@.str.697 = private unnamed_addr constant [5 x i8] c"%-8s\00", align 1
@.str.698 = private unnamed_addr constant [18 x i8] c"connected_clients\00", align 1
@.str.699 = private unnamed_addr constant [6 x i8] c" %-8s\00", align 1
@.str.700 = private unnamed_addr constant [16 x i8] c"blocked_clients\00", align 1
@.str.701 = private unnamed_addr constant [25 x i8] c"total_commands_processed\00", align 1
@.str.702 = private unnamed_addr constant [11 x i8] c"%ld (+%ld)\00", align 1
@.str.703 = private unnamed_addr constant [6 x i8] c"%-19s\00", align 1
@.str.704 = private unnamed_addr constant [27 x i8] c"total_connections_received\00", align 1
@.str.705 = private unnamed_addr constant [7 x i8] c" %-12s\00", align 1
@.str.706 = private unnamed_addr constant [19 x i8] c"bgsave_in_progress\00", align 1
@.str.707 = private unnamed_addr constant [24 x i8] c"aof_rewrite_in_progress\00", align 1
@.str.708 = private unnamed_addr constant [8 x i8] c"loading\00", align 1
@.str.709 = private unnamed_addr constant [5 x i8] c"SAVE\00", align 1
@.str.710 = private unnamed_addr constant [4 x i8] c"AOF\00", align 1
@.str.711 = private unnamed_addr constant [9 x i8] c"SAVE+AOF\00", align 1
@.str.712 = private unnamed_addr constant [5 x i8] c"LOAD\00", align 1
@.str.713 = private unnamed_addr constant [21 x i8] c"CONFIG GET databases\00", align 1
@.str.714 = private unnamed_addr constant [62 x i8] c"CONFIG GET databases fails: %s, use default value 16 instead\0A\00", align 1
@.str.715 = private unnamed_addr constant [10 x i8] c"SET %s %s\00", align 1
@.str.716 = private unnamed_addr constant [7 x i8] c"GET %s\00", align 1
@.str.717 = private unnamed_addr constant [27 x i8] c"I/O error during LRU test\0A\00", align 1
@.str.718 = private unnamed_addr constant [61 x i8] c"%lld Gets/sec | Hits: %lld (%.2f%%) | Misses: %lld (%.2f%%)\0A\00", align 1
@.str.719 = private unnamed_addr constant [40 x i8] c"Max latency so far: %lld microseconds.\0A\00", align 1
@.str.720 = private unnamed_addr constant [79 x i8] c"\0A%lld total runs (avg latency: %.4f microseconds / %.2f nanoseconds per run).\0A\00", align 1
@.str.721 = private unnamed_addr constant [55 x i8] c"Worst run took %.0fx longer than the average latency.\0A\00", align 1
@.str.722 = private unnamed_addr constant [18 x i8] c"REDISCLI_HISTFILE\00", align 1
@.str.723 = private unnamed_addr constant [18 x i8] c".rediscli_history\00", align 1
@.str.724 = private unnamed_addr constant [16 x i8] c"not connected> \00", align 1
@.str.725 = private unnamed_addr constant [21 x i8] c"Invalid argument(s)\0A\00", align 1
@.str.726 = private unnamed_addr constant [48 x i8] c"Invalid redis-cli repeat command option value.\0A\00", align 1
@.str.727 = private unnamed_addr constant [5 x i8] c"quit\00", align 1
@.str.728 = private unnamed_addr constant [5 x i8] c"exit\00", align 1
@.str.729 = private unnamed_addr constant [8 x i8] c"restart\00", align 1
@.str.730 = private unnamed_addr constant [43 x i8] c"Use 'restart' only in Lua debugging mode.\0A\00", align 1
@.str.731 = private unnamed_addr constant [8 x i8] c"connect\00", align 1
@.str.732 = private unnamed_addr constant [6 x i8] c"clear\00", align 1
@.str.733 = private unnamed_addr constant [35 x i8] c"\0A(Lua debugging session ended%s)\0A\0A\00", align 1
@.str.734 = private unnamed_addr constant [32 x i8] c" -- dataset changes rolled back\00", align 1
@.str.735 = private unnamed_addr constant [9 x i8] c"(%.2fs)\0A\00", align 1
@.str.736 = private unnamed_addr constant [6 x i8] c"help \00", align 1
@.str.737 = private unnamed_addr constant [6 x i8] c"eval \00", align 1
@.str.738 = private unnamed_addr constant [3 x i8] c"e \00", align 1
@.str.739 = private unnamed_addr constant [5 x i8] c"auth\00", align 1
@.str.740 = private unnamed_addr constant [4 x i8] c"acl\00", align 1
@.str.741 = private unnamed_addr constant [8 x i8] c"deluser\00", align 1
@.str.742 = private unnamed_addr constant [8 x i8] c"setuser\00", align 1
@.str.743 = private unnamed_addr constant [8 x i8] c"getuser\00", align 1
@.str.744 = private unnamed_addr constant [7 x i8] c"config\00", align 1
@.str.745 = private unnamed_addr constant [11 x i8] c"masterauth\00", align 1
@.str.746 = private unnamed_addr constant [11 x i8] c"masteruser\00", align 1
@.str.747 = private unnamed_addr constant [18 x i8] c"tls-key-file-pass\00", align 1
@.str.748 = private unnamed_addr constant [25 x i8] c"tls-client-key-file-pass\00", align 1
@.str.749 = private unnamed_addr constant [12 x i8] c"requirepass\00", align 1
@.str.750 = private unnamed_addr constant [6 x i8] c"hello\00", align 1
@.str.751 = private unnamed_addr constant [8 x i8] c"SETNAME\00", align 1
@.str.752 = private unnamed_addr constant [8 x i8] c"migrate\00", align 1
@.str.753 = private unnamed_addr constant [6 x i8] c"auth2\00", align 1
@.str.754 = private unnamed_addr constant [5 x i8] c"keys\00", align 1
@.str.755 = private unnamed_addr constant [9 x i8] c"sentinel\00", align 1
@.str.756 = private unnamed_addr constant [14 x i8] c"sentinel-pass\00", align 1
@.str.757 = private unnamed_addr constant [14 x i8] c"sentinel-user\00", align 1
@.str.758 = private unnamed_addr constant [10 x i8] c"auth-pass\00", align 1
@.str.759 = private unnamed_addr constant [10 x i8] c"auth-user\00", align 1
@.str.760 = private unnamed_addr constant [3 x i8] c"\0D\0A\00", align 1
@.str.761 = private unnamed_addr constant [385 x i8] c"redis-cli %s\0ATo get help about Redis commands type:\0A      \22help @<group>\22 to get a list of commands in <group>\0A      \22help <command>\22 for help on <command>\0A      \22help <tab>\22 to get a list of possible help topics\0A      \22quit\22 to exit\0A\0ATo set redis-cli preferences:\0A      \22:set hints\22 enable online hints\0A      \22:set nohints\22 disable online hints\0ASet your preferences in ~/.redisclirc\0A\00", align 1
@.str.762 = private unnamed_addr constant [29 x i8] c"\0D\0A  \1B[1m%s\1B[0m \1B[90m%s\1B[0m\0D\0A\00", align 1
@.str.763 = private unnamed_addr constant [25 x i8] c"  \1B[33msummary:\1B[0m %s\0D\0A\00", align 1
@.str.764 = private unnamed_addr constant [23 x i8] c"  \1B[33msince:\1B[0m %s\0D\0A\00", align 1
@.str.765 = private unnamed_addr constant [23 x i8] c"  \1B[33mgroup:\1B[0m %s\0D\0A\00", align 1
@.str.766 = private unnamed_addr constant [7 x i8] c"ASKING\00", align 1
@.str.767 = private unnamed_addr constant [19 x i8] c"ASKING failed: %s\0A\00", align 1
@.str.768 = private unnamed_addr constant [7 x i8] c"lolwut\00", align 1
@.str.769 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.770 = private unnamed_addr constant [8 x i8] c"htstats\00", align 1
@.str.771 = private unnamed_addr constant [12 x i8] c"htstats-key\00", align 1
@.str.772 = private unnamed_addr constant [16 x i8] c"client-eviction\00", align 1
@.str.773 = private unnamed_addr constant [7 x i8] c"memory\00", align 1
@.str.774 = private unnamed_addr constant [13 x i8] c"malloc-stats\00", align 1
@.str.775 = private unnamed_addr constant [7 x i8] c"doctor\00", align 1
@.str.776 = private unnamed_addr constant [8 x i8] c"cluster\00", align 1
@.str.777 = private unnamed_addr constant [6 x i8] c"nodes\00", align 1
@.str.778 = private unnamed_addr constant [7 x i8] c"client\00", align 1
@.str.779 = private unnamed_addr constant [8 x i8] c"latency\00", align 1
@.str.780 = private unnamed_addr constant [6 x i8] c"graph\00", align 1
@.str.781 = private unnamed_addr constant [6 x i8] c"proxy\00", align 1
@.str.782 = private unnamed_addr constant [9 x i8] c"shutdown\00", align 1
@.str.783 = private unnamed_addr constant [8 x i8] c"monitor\00", align 1
@.str.784 = private unnamed_addr constant [11 x i8] c"psubscribe\00", align 1
@.str.785 = private unnamed_addr constant [11 x i8] c"ssubscribe\00", align 1
@.str.786 = private unnamed_addr constant [12 x i8] c"unsubscribe\00", align 1
@.str.787 = private unnamed_addr constant [13 x i8] c"punsubscribe\00", align 1
@.str.788 = private unnamed_addr constant [13 x i8] c"sunsubscribe\00", align 1
@.str.789 = private unnamed_addr constant [5 x i8] c"sync\00", align 1
@.str.790 = private unnamed_addr constant [6 x i8] c"psync\00", align 1
@.str.791 = private unnamed_addr constant [7 x i8] c"script\00", align 1
@.str.792 = private unnamed_addr constant [5 x i8] c"eval\00", align 1
@.str.793 = private unnamed_addr constant [57 x i8] c"Entering replica output mode...  (press Ctrl-C to quit)\0A\00", align 1
@.str.794 = private unnamed_addr constant [7 x i8] c"select\00", align 1
@.str.795 = private unnamed_addr constant [6 x i8] c"multi\00", align 1
@.str.796 = private unnamed_addr constant [5 x i8] c"exec\00", align 1
@.str.797 = private unnamed_addr constant [8 x i8] c"discard\00", align 1
@.str.798 = private unnamed_addr constant [6 x i8] c"reset\00", align 1
@.str.799 = private unnamed_addr constant [8 x i8] c"\1B[1;90m\00", align 1
@.str.800 = private unnamed_addr constant [71 x i8] c"Reading messages... (press Ctrl-C to quit or any key to type command)\0D\00", align 1
@.str.801 = private unnamed_addr constant [4 x i8] c"\1B[K\00", align 1
@.str.802 = private unnamed_addr constant [171 x i8] c"Lua debugging session started, please use:\0Aquit    -- End the session.\0Arestart -- Restart the script in debug mode again.\0Ahelp    -- Show Lua script debugging commands.\0A\0A\00", align 1
@.str.803 = private unnamed_addr constant [18 x i8] c"SCRIPT DEBUG sync\00", align 1
@.str.804 = private unnamed_addr constant [17 x i8] c"SCRIPT DEBUG yes\00", align 1
@.str.805 = private unnamed_addr constant [5 x i8] c"EVAL\00", align 1
@.str.806 = private unnamed_addr constant [37 x i8] c"Eval debugging session can't start:\0A\00", align 1
@.str.807 = private unnamed_addr constant [15 x i8] c"lua debugger> \00", align 1
@.str.808 = private unnamed_addr constant [23 x i8] c"Invalid quoted string\0A\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @helpEntryCompare(ptr noundef %entry1, ptr noundef %entry2) #0 {
entry:
  %entry1.addr = alloca ptr, align 8
  %entry2.addr = alloca ptr, align 8
  %i1 = alloca ptr, align 8
  %i2 = alloca ptr, align 8
  store ptr %entry1, ptr %entry1.addr, align 8
  store ptr %entry2, ptr %entry2.addr, align 8
  %0 = load ptr, ptr %entry1.addr, align 8
  store ptr %0, ptr %i1, align 8
  %1 = load ptr, ptr %entry2.addr, align 8
  store ptr %1, ptr %i2, align 8
  %2 = load ptr, ptr %i1, align 8
  %full = getelementptr inbounds %struct.helpEntry, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %full, align 8
  %4 = load ptr, ptr %i2, align 8
  %full1 = getelementptr inbounds %struct.helpEntry, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %full1, align 8
  %call = call i32 @strcmp(ptr noundef %3, ptr noundef %5) #12
  ret i32 %call
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local void @cliInitGroupHelpEntries(ptr noundef %groups) #0 {
entry:
  %groups.addr = alloca ptr, align 8
  %iter = alloca ptr, align 8
  %entry1 = alloca ptr, align 8
  %tmp = alloca %struct.helpEntry, align 8
  %numGroups = alloca i32, align 4
  %pos = alloca i32, align 4
  store ptr %groups, ptr %groups.addr, align 8
  %0 = load ptr, ptr %groups.addr, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %iter, align 8
  %1 = load ptr, ptr %groups.addr, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %2 = load i64, ptr %arrayidx, align 8
  %3 = load ptr, ptr %groups.addr, align 8
  %ht_used2 = getelementptr inbounds %struct.dict, ptr %3, i32 0, i32 2
  %arrayidx3 = getelementptr inbounds [2 x i64], ptr %ht_used2, i64 0, i64 1
  %4 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %2, %4
  %conv = trunc i64 %add to i32
  store i32 %conv, ptr %numGroups, align 4
  %5 = load i32, ptr @helpEntriesLen, align 4
  store i32 %5, ptr %pos, align 4
  %6 = load i32, ptr %numGroups, align 4
  %7 = load i32, ptr @helpEntriesLen, align 4
  %add4 = add nsw i32 %7, %6
  store i32 %add4, ptr @helpEntriesLen, align 4
  %8 = load ptr, ptr @helpEntries, align 8
  %9 = load i32, ptr @helpEntriesLen, align 4
  %conv5 = sext i32 %9 to i64
  %mul = mul i64 88, %conv5
  %call6 = call ptr @zrealloc(ptr noundef %8, i64 noundef %mul) #13
  store ptr %call6, ptr @helpEntries, align 8
  %10 = load ptr, ptr %iter, align 8
  %call7 = call ptr @dictNext(ptr noundef %10)
  store ptr %call7, ptr %entry1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load ptr, ptr %entry1, align 8
  %cmp = icmp ne ptr %11, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %argc = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 1
  store i32 1, ptr %argc, align 4
  %call9 = call noalias ptr @zmalloc(i64 noundef 8) #14
  %argv = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 2
  store ptr %call9, ptr %argv, align 8
  %call10 = call ptr @hi_sdsempty()
  %12 = load ptr, ptr %entry1, align 8
  %call11 = call ptr @dictGetKey(ptr noundef %12)
  %call12 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %call10, ptr noundef @.str, ptr noundef %call11)
  %argv13 = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 2
  %13 = load ptr, ptr %argv13, align 8
  %arrayidx14 = getelementptr inbounds ptr, ptr %13, i64 0
  store ptr %call12, ptr %arrayidx14, align 8
  %argv15 = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 2
  %14 = load ptr, ptr %argv15, align 8
  %arrayidx16 = getelementptr inbounds ptr, ptr %14, i64 0
  %15 = load ptr, ptr %arrayidx16, align 8
  %full = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 3
  store ptr %15, ptr %full, align 8
  %type = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 0
  store i32 2, ptr %type, align 8
  %docs = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 4
  %name = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 0
  store ptr null, ptr %name, align 8
  %docs17 = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 4
  %params = getelementptr inbounds %struct.commandDocs, ptr %docs17, i32 0, i32 7
  store ptr null, ptr %params, align 8
  %docs18 = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 4
  %args = getelementptr inbounds %struct.commandDocs, ptr %docs18, i32 0, i32 5
  store ptr null, ptr %args, align 8
  %docs19 = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 4
  %numargs = getelementptr inbounds %struct.commandDocs, ptr %docs19, i32 0, i32 4
  store i32 0, ptr %numargs, align 8
  %docs20 = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 4
  %summary = getelementptr inbounds %struct.commandDocs, ptr %docs20, i32 0, i32 1
  store ptr null, ptr %summary, align 8
  %docs21 = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 4
  %since = getelementptr inbounds %struct.commandDocs, ptr %docs21, i32 0, i32 3
  store ptr null, ptr %since, align 8
  %docs22 = getelementptr inbounds %struct.helpEntry, ptr %tmp, i32 0, i32 4
  %group = getelementptr inbounds %struct.commandDocs, ptr %docs22, i32 0, i32 2
  store ptr null, ptr %group, align 8
  %16 = load ptr, ptr @helpEntries, align 8
  %17 = load i32, ptr %pos, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %pos, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx23 = getelementptr inbounds %struct.helpEntry, ptr %16, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx23, ptr align 8 %tmp, i64 88, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load ptr, ptr %iter, align 8
  %call24 = call ptr @dictNext(ptr noundef %18)
  store ptr %call24, ptr %entry1, align 8
  br label %for.cond, !llvm.loop !5

for.end:                                          ; preds = %for.cond
  %19 = load ptr, ptr %iter, align 8
  call void @dictReleaseIterator(ptr noundef %19)
  ret void
}

declare ptr @dictGetIterator(ptr noundef) #2

; Function Attrs: allocsize(1)
declare ptr @zrealloc(ptr noundef, i64 noundef) #3

declare ptr @dictNext(ptr noundef) #2

; Function Attrs: allocsize(0)
declare noalias ptr @zmalloc(i64 noundef) #4

declare ptr @hi_sdscatprintf(ptr noundef, ptr noundef, ...) #2

declare ptr @hi_sdsempty() #2

declare ptr @dictGetKey(ptr noundef) #2

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #5

declare void @dictReleaseIterator(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @cliInitCommandHelpEntries(ptr noundef %commandTable, ptr noundef %groups) #0 {
entry:
  %commandTable.addr = alloca ptr, align 8
  %groups.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  %i = alloca i64, align 8
  %cmdname = alloca ptr, align 8
  %cmdspecs = alloca ptr, align 8
  store ptr %commandTable, ptr %commandTable.addr, align 8
  store ptr %groups, ptr %groups.addr, align 8
  %0 = load ptr, ptr @helpEntries, align 8
  store ptr %0, ptr %next, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8
  %2 = load ptr, ptr %commandTable.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %2, i32 0, i32 6
  %3 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %1, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %commandTable.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %4, i32 0, i32 7
  %5 = load ptr, ptr %element, align 8
  %6 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 %6
  %7 = load ptr, ptr %arrayidx, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %str, align 8
  store ptr %8, ptr %cmdname, align 8
  %9 = load ptr, ptr %commandTable.addr, align 8
  %element1 = getelementptr inbounds %struct.redisReply, ptr %9, i32 0, i32 7
  %10 = load ptr, ptr %element1, align 8
  %11 = load i64, ptr %i, align 8
  %add = add i64 %11, 1
  %arrayidx2 = getelementptr inbounds ptr, ptr %10, i64 %add
  %12 = load ptr, ptr %arrayidx2, align 8
  store ptr %12, ptr %cmdspecs, align 8
  %13 = load ptr, ptr %cmdname, align 8
  %14 = load ptr, ptr %next, align 8
  %15 = load ptr, ptr %cmdspecs, align 8
  %16 = load ptr, ptr %groups.addr, align 8
  %call = call ptr @cliInitCommandHelpEntry(ptr noundef %13, ptr noundef null, ptr noundef %14, ptr noundef %15, ptr noundef %16)
  store ptr %call, ptr %next, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i64, ptr %i, align 8
  %add3 = add i64 %17, 2
  store i64 %add3, ptr %i, align 8
  br label %for.cond, !llvm.loop !7

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @cliInitCommandHelpEntry(ptr noundef %cmdname, ptr noundef %subcommandname, ptr noundef %next, ptr noundef %specs, ptr noundef %groups) #0 {
entry:
  %cmdname.addr = alloca ptr, align 8
  %subcommandname.addr = alloca ptr, align 8
  %next.addr = alloca ptr, align 8
  %specs.addr = alloca ptr, align 8
  %groups.addr = alloca ptr, align 8
  %help = alloca ptr, align 8
  %j = alloca i64, align 8
  %key = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %reply8 = alloca ptr, align 8
  %reply19 = alloca ptr, align 8
  %group26 = alloca ptr, align 8
  %arguments = alloca ptr, align 8
  %subcommands = alloca ptr, align 8
  %i = alloca i64, align 8
  %subcommandname62 = alloca ptr, align 8
  %subcommand = alloca ptr, align 8
  store ptr %cmdname, ptr %cmdname.addr, align 8
  store ptr %subcommandname, ptr %subcommandname.addr, align 8
  store ptr %next, ptr %next.addr, align 8
  store ptr %specs, ptr %specs.addr, align 8
  store ptr %groups, ptr %groups.addr, align 8
  %0 = load ptr, ptr %next.addr, align 8
  %incdec.ptr = getelementptr inbounds %struct.helpEntry, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %next.addr, align 8
  store ptr %0, ptr %help, align 8
  %1 = load ptr, ptr %help, align 8
  %2 = load ptr, ptr %cmdname.addr, align 8
  %3 = load ptr, ptr %subcommandname.addr, align 8
  call void @cliFillInCommandHelpEntry(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  store i64 0, ptr %j, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc76, %entry
  %4 = load i64, ptr %j, align 8
  %5 = load ptr, ptr %specs.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %4, %6
  br i1 %cmp, label %for.body, label %for.end78

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %specs.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 7
  %8 = load ptr, ptr %element, align 8
  %9 = load i64, ptr %j, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %8, i64 %9
  %10 = load ptr, ptr %arrayidx, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %str, align 8
  store ptr %11, ptr %key, align 8
  %12 = load ptr, ptr %key, align 8
  %call = call i32 @strcmp(ptr noundef %12, ptr noundef @.str.131) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %for.body
  %13 = load ptr, ptr %specs.addr, align 8
  %element1 = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 7
  %14 = load ptr, ptr %element1, align 8
  %15 = load i64, ptr %j, align 8
  %add = add i64 %15, 1
  %arrayidx2 = getelementptr inbounds ptr, ptr %14, i64 %add
  %16 = load ptr, ptr %arrayidx2, align 8
  store ptr %16, ptr %reply, align 8
  %17 = load ptr, ptr %reply, align 8
  %str3 = getelementptr inbounds %struct.redisReply, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %str3, align 8
  %call4 = call ptr @hi_sdsnew(ptr noundef %18)
  %19 = load ptr, ptr %help, align 8
  %docs = getelementptr inbounds %struct.helpEntry, ptr %19, i32 0, i32 4
  %summary = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 1
  store ptr %call4, ptr %summary, align 8
  br label %if.end75

if.else:                                          ; preds = %for.body
  %20 = load ptr, ptr %key, align 8
  %call5 = call i32 @strcmp(ptr noundef %20, ptr noundef @.str.132) #12
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.else15, label %if.then7

if.then7:                                         ; preds = %if.else
  %21 = load ptr, ptr %specs.addr, align 8
  %element9 = getelementptr inbounds %struct.redisReply, ptr %21, i32 0, i32 7
  %22 = load ptr, ptr %element9, align 8
  %23 = load i64, ptr %j, align 8
  %add10 = add i64 %23, 1
  %arrayidx11 = getelementptr inbounds ptr, ptr %22, i64 %add10
  %24 = load ptr, ptr %arrayidx11, align 8
  store ptr %24, ptr %reply8, align 8
  %25 = load ptr, ptr %reply8, align 8
  %str12 = getelementptr inbounds %struct.redisReply, ptr %25, i32 0, i32 4
  %26 = load ptr, ptr %str12, align 8
  %call13 = call ptr @hi_sdsnew(ptr noundef %26)
  %27 = load ptr, ptr %help, align 8
  %docs14 = getelementptr inbounds %struct.helpEntry, ptr %27, i32 0, i32 4
  %since = getelementptr inbounds %struct.commandDocs, ptr %docs14, i32 0, i32 3
  store ptr %call13, ptr %since, align 8
  br label %if.end74

if.else15:                                        ; preds = %if.else
  %28 = load ptr, ptr %key, align 8
  %call16 = call i32 @strcmp(ptr noundef %28, ptr noundef @.str.133) #12
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.else33, label %if.then18

if.then18:                                        ; preds = %if.else15
  %29 = load ptr, ptr %specs.addr, align 8
  %element20 = getelementptr inbounds %struct.redisReply, ptr %29, i32 0, i32 7
  %30 = load ptr, ptr %element20, align 8
  %31 = load i64, ptr %j, align 8
  %add21 = add i64 %31, 1
  %arrayidx22 = getelementptr inbounds ptr, ptr %30, i64 %add21
  %32 = load ptr, ptr %arrayidx22, align 8
  store ptr %32, ptr %reply19, align 8
  %33 = load ptr, ptr %reply19, align 8
  %str23 = getelementptr inbounds %struct.redisReply, ptr %33, i32 0, i32 4
  %34 = load ptr, ptr %str23, align 8
  %call24 = call ptr @hi_sdsnew(ptr noundef %34)
  %35 = load ptr, ptr %help, align 8
  %docs25 = getelementptr inbounds %struct.helpEntry, ptr %35, i32 0, i32 4
  %group = getelementptr inbounds %struct.commandDocs, ptr %docs25, i32 0, i32 2
  store ptr %call24, ptr %group, align 8
  %36 = load ptr, ptr %help, align 8
  %docs27 = getelementptr inbounds %struct.helpEntry, ptr %36, i32 0, i32 4
  %group28 = getelementptr inbounds %struct.commandDocs, ptr %docs27, i32 0, i32 2
  %37 = load ptr, ptr %group28, align 8
  %call29 = call ptr @hi_sdsdup(ptr noundef %37)
  store ptr %call29, ptr %group26, align 8
  %38 = load ptr, ptr %groups.addr, align 8
  %39 = load ptr, ptr %group26, align 8
  %call30 = call i32 @dictAdd(ptr noundef %38, ptr noundef %39, ptr noundef null)
  %cmp31 = icmp ne i32 %call30, 0
  br i1 %cmp31, label %if.then32, label %if.end

if.then32:                                        ; preds = %if.then18
  %40 = load ptr, ptr %group26, align 8
  call void @hi_sdsfree(ptr noundef %40)
  br label %if.end

if.end:                                           ; preds = %if.then32, %if.then18
  br label %if.end73

if.else33:                                        ; preds = %if.else15
  %41 = load ptr, ptr %key, align 8
  %call34 = call i32 @strcmp(ptr noundef %41, ptr noundef @.str.134) #12
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.else50, label %if.then36

if.then36:                                        ; preds = %if.else33
  %42 = load ptr, ptr %specs.addr, align 8
  %element37 = getelementptr inbounds %struct.redisReply, ptr %42, i32 0, i32 7
  %43 = load ptr, ptr %element37, align 8
  %44 = load i64, ptr %j, align 8
  %add38 = add i64 %44, 1
  %arrayidx39 = getelementptr inbounds ptr, ptr %43, i64 %add38
  %45 = load ptr, ptr %arrayidx39, align 8
  store ptr %45, ptr %arguments, align 8
  %46 = load ptr, ptr %arguments, align 8
  %elements40 = getelementptr inbounds %struct.redisReply, ptr %46, i32 0, i32 6
  %47 = load i64, ptr %elements40, align 8
  %mul = mul i64 %47, 72
  %call41 = call noalias ptr @zcalloc(i64 noundef %mul) #14
  %48 = load ptr, ptr %help, align 8
  %docs42 = getelementptr inbounds %struct.helpEntry, ptr %48, i32 0, i32 4
  %args = getelementptr inbounds %struct.commandDocs, ptr %docs42, i32 0, i32 5
  store ptr %call41, ptr %args, align 8
  %49 = load ptr, ptr %arguments, align 8
  %elements43 = getelementptr inbounds %struct.redisReply, ptr %49, i32 0, i32 6
  %50 = load i64, ptr %elements43, align 8
  %conv = trunc i64 %50 to i32
  %51 = load ptr, ptr %help, align 8
  %docs44 = getelementptr inbounds %struct.helpEntry, ptr %51, i32 0, i32 4
  %numargs = getelementptr inbounds %struct.commandDocs, ptr %docs44, i32 0, i32 4
  store i32 %conv, ptr %numargs, align 8
  %52 = load ptr, ptr %arguments, align 8
  %53 = load ptr, ptr %help, align 8
  %docs45 = getelementptr inbounds %struct.helpEntry, ptr %53, i32 0, i32 4
  %args46 = getelementptr inbounds %struct.commandDocs, ptr %docs45, i32 0, i32 5
  %54 = load ptr, ptr %args46, align 8
  call void @cliMakeCommandDocArgs(ptr noundef %52, ptr noundef %54)
  %55 = load ptr, ptr %help, align 8
  %docs47 = getelementptr inbounds %struct.helpEntry, ptr %55, i32 0, i32 4
  %call48 = call ptr @makeHint(ptr noundef null, i32 noundef 0, i32 noundef 0, ptr noundef byval(%struct.commandDocs) align 8 %docs47)
  %56 = load ptr, ptr %help, align 8
  %docs49 = getelementptr inbounds %struct.helpEntry, ptr %56, i32 0, i32 4
  %params = getelementptr inbounds %struct.commandDocs, ptr %docs49, i32 0, i32 7
  store ptr %call48, ptr %params, align 8
  br label %if.end72

if.else50:                                        ; preds = %if.else33
  %57 = load ptr, ptr %key, align 8
  %call51 = call i32 @strcmp(ptr noundef %57, ptr noundef @.str.135) #12
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %if.end71, label %if.then53

if.then53:                                        ; preds = %if.else50
  %58 = load ptr, ptr %specs.addr, align 8
  %element54 = getelementptr inbounds %struct.redisReply, ptr %58, i32 0, i32 7
  %59 = load ptr, ptr %element54, align 8
  %60 = load i64, ptr %j, align 8
  %add55 = add i64 %60, 1
  %arrayidx56 = getelementptr inbounds ptr, ptr %59, i64 %add55
  %61 = load ptr, ptr %arrayidx56, align 8
  store ptr %61, ptr %subcommands, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond57

for.cond57:                                       ; preds = %for.inc, %if.then53
  %62 = load i64, ptr %i, align 8
  %63 = load ptr, ptr %subcommands, align 8
  %elements58 = getelementptr inbounds %struct.redisReply, ptr %63, i32 0, i32 6
  %64 = load i64, ptr %elements58, align 8
  %cmp59 = icmp ult i64 %62, %64
  br i1 %cmp59, label %for.body61, label %for.end

for.body61:                                       ; preds = %for.cond57
  %65 = load ptr, ptr %subcommands, align 8
  %element63 = getelementptr inbounds %struct.redisReply, ptr %65, i32 0, i32 7
  %66 = load ptr, ptr %element63, align 8
  %67 = load i64, ptr %i, align 8
  %arrayidx64 = getelementptr inbounds ptr, ptr %66, i64 %67
  %68 = load ptr, ptr %arrayidx64, align 8
  %str65 = getelementptr inbounds %struct.redisReply, ptr %68, i32 0, i32 4
  %69 = load ptr, ptr %str65, align 8
  store ptr %69, ptr %subcommandname62, align 8
  %70 = load ptr, ptr %subcommands, align 8
  %element66 = getelementptr inbounds %struct.redisReply, ptr %70, i32 0, i32 7
  %71 = load ptr, ptr %element66, align 8
  %72 = load i64, ptr %i, align 8
  %add67 = add i64 %72, 1
  %arrayidx68 = getelementptr inbounds ptr, ptr %71, i64 %add67
  %73 = load ptr, ptr %arrayidx68, align 8
  store ptr %73, ptr %subcommand, align 8
  %74 = load ptr, ptr %cmdname.addr, align 8
  %75 = load ptr, ptr %subcommandname62, align 8
  %76 = load ptr, ptr %next.addr, align 8
  %77 = load ptr, ptr %subcommand, align 8
  %78 = load ptr, ptr %groups.addr, align 8
  %call69 = call ptr @cliInitCommandHelpEntry(ptr noundef %74, ptr noundef %75, ptr noundef %76, ptr noundef %77, ptr noundef %78)
  store ptr %call69, ptr %next.addr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body61
  %79 = load i64, ptr %i, align 8
  %add70 = add i64 %79, 2
  store i64 %add70, ptr %i, align 8
  br label %for.cond57, !llvm.loop !8

for.end:                                          ; preds = %for.cond57
  br label %if.end71

if.end71:                                         ; preds = %for.end, %if.else50
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.then36
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %if.end
  br label %if.end74

if.end74:                                         ; preds = %if.end73, %if.then7
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.then
  br label %for.inc76

for.inc76:                                        ; preds = %if.end75
  %80 = load i64, ptr %j, align 8
  %add77 = add i64 %80, 2
  store i64 %add77, ptr %j, align 8
  br label %for.cond, !llvm.loop !9

for.end78:                                        ; preds = %for.cond
  %81 = load ptr, ptr %next.addr, align 8
  ret ptr %81
}

; Function Attrs: nounwind uwtable
define dso_local i32 @cliLegacyInitCommandHelpEntries(ptr noundef %commands, ptr noundef %groups, ptr noundef %version) #0 {
entry:
  %commands.addr = alloca ptr, align 8
  %groups.addr = alloca ptr, align 8
  %version.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store ptr %groups, ptr %groups.addr, align 8
  store ptr %version, ptr %version.addr, align 8
  %0 = load ptr, ptr @helpEntries, align 8
  store ptr %0, ptr %next, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load ptr, ptr %commands.addr, align 8
  %2 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.commandDocs, ptr %1, i64 %2
  %name = getelementptr inbounds %struct.commandDocs, ptr %arrayidx, i32 0, i32 0
  %3 = load ptr, ptr %name, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %version.addr, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %for.body
  %5 = load ptr, ptr %version.addr, align 8
  %6 = load ptr, ptr %commands.addr, align 8
  %7 = load i64, ptr %i, align 8
  %arrayidx1 = getelementptr inbounds %struct.commandDocs, ptr %6, i64 %7
  %since = getelementptr inbounds %struct.commandDocs, ptr %arrayidx1, i32 0, i32 3
  %8 = load ptr, ptr %since, align 8
  %call = call i32 @versionIsSupported(ptr noundef %5, ptr noundef %8)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %9 = load ptr, ptr %commands.addr, align 8
  %10 = load i64, ptr %i, align 8
  %arrayidx3 = getelementptr inbounds %struct.commandDocs, ptr %9, i64 %10
  %name4 = getelementptr inbounds %struct.commandDocs, ptr %arrayidx3, i32 0, i32 0
  %11 = load ptr, ptr %name4, align 8
  %12 = load ptr, ptr %next, align 8
  %13 = load ptr, ptr %commands.addr, align 8
  %14 = load i64, ptr %i, align 8
  %arrayidx5 = getelementptr inbounds %struct.commandDocs, ptr %13, i64 %14
  %15 = load ptr, ptr %groups.addr, align 8
  %16 = load ptr, ptr %version.addr, align 8
  %call6 = call ptr @cliLegacyInitCommandHelpEntry(ptr noundef %11, ptr noundef null, ptr noundef %12, ptr noundef %arrayidx5, ptr noundef %15, ptr noundef %16)
  store ptr %call6, ptr %next, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i64, ptr %i, align 8
  %inc = add i64 %17, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  %18 = load ptr, ptr %next, align 8
  %19 = load ptr, ptr @helpEntries, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %18 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %19 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 88
  %conv = trunc i64 %sub.ptr.div to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @versionIsSupported(ptr noundef %version, ptr noundef %since) #0 {
entry:
  %retval = alloca i32, align 4
  %version.addr = alloca ptr, align 8
  %since.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %versionPos = alloca ptr, align 8
  %sincePos = alloca ptr, align 8
  %versionPart = alloca i32, align 4
  %sincePart = alloca i32, align 4
  store ptr %version, ptr %version.addr, align 8
  store ptr %since, ptr %since.addr, align 8
  %0 = load ptr, ptr %version.addr, align 8
  store ptr %0, ptr %versionPos, align 8
  %1 = load ptr, ptr %since.addr, align 8
  store ptr %1, ptr %sincePos, align 8
  %2 = load ptr, ptr %since.addr, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, ptr %i, align 4
  %cmp = icmp ne i32 %3, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %versionPos, align 8
  %call = call i32 @atoi(ptr noundef %4) #12
  store i32 %call, ptr %versionPart, align 4
  %5 = load ptr, ptr %sincePos, align 8
  %call1 = call i32 @atoi(ptr noundef %5) #12
  store i32 %call1, ptr %sincePart, align 4
  %6 = load i32, ptr %versionPart, align 4
  %7 = load i32, ptr %sincePart, align 4
  %cmp2 = icmp sgt i32 %6, %7
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %for.body
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %for.body
  %8 = load i32, ptr %sincePart, align 4
  %9 = load i32, ptr %versionPart, align 4
  %cmp4 = icmp sgt i32 %8, %9
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end6
  %10 = load ptr, ptr %versionPos, align 8
  %call8 = call ptr @strchr(ptr noundef %10, i32 noundef 46) #12
  store ptr %call8, ptr %versionPos, align 8
  %11 = load ptr, ptr %sincePos, align 8
  %call9 = call ptr @strchr(ptr noundef %11, i32 noundef 46) #12
  store ptr %call9, ptr %sincePos, align 8
  %12 = load ptr, ptr %versionPos, align 8
  %tobool10 = icmp ne ptr %12, null
  br i1 %tobool10, label %lor.lhs.false, label %if.then12

lor.lhs.false:                                    ; preds = %if.end7
  %13 = load ptr, ptr %sincePos, align 8
  %tobool11 = icmp ne ptr %13, null
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %lor.lhs.false, %if.end7
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %lor.lhs.false
  %14 = load ptr, ptr %versionPos, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %14, i32 1
  store ptr %incdec.ptr, ptr %versionPos, align 8
  %15 = load ptr, ptr %sincePos, align 8
  %incdec.ptr14 = getelementptr inbounds i8, ptr %15, i32 1
  store ptr %incdec.ptr14, ptr %sincePos, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %16 = load i32, ptr %i, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !11

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then12, %if.then5, %if.then3, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define internal ptr @cliLegacyInitCommandHelpEntry(ptr noundef %cmdname, ptr noundef %subcommandname, ptr noundef %next, ptr noundef %command, ptr noundef %groups, ptr noundef %version) #0 {
entry:
  %cmdname.addr = alloca ptr, align 8
  %subcommandname.addr = alloca ptr, align 8
  %next.addr = alloca ptr, align 8
  %command.addr = alloca ptr, align 8
  %groups.addr = alloca ptr, align 8
  %version.addr = alloca ptr, align 8
  %help = alloca ptr, align 8
  %group8 = alloca ptr, align 8
  %i = alloca i64, align 8
  %subcommandname41 = alloca ptr, align 8
  store ptr %cmdname, ptr %cmdname.addr, align 8
  store ptr %subcommandname, ptr %subcommandname.addr, align 8
  store ptr %next, ptr %next.addr, align 8
  store ptr %command, ptr %command.addr, align 8
  store ptr %groups, ptr %groups.addr, align 8
  store ptr %version, ptr %version.addr, align 8
  %0 = load ptr, ptr %next.addr, align 8
  %incdec.ptr = getelementptr inbounds %struct.helpEntry, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %next.addr, align 8
  store ptr %0, ptr %help, align 8
  %1 = load ptr, ptr %help, align 8
  %2 = load ptr, ptr %cmdname.addr, align 8
  %3 = load ptr, ptr %subcommandname.addr, align 8
  call void @cliFillInCommandHelpEntry(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %command.addr, align 8
  %summary = getelementptr inbounds %struct.commandDocs, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %summary, align 8
  %call = call ptr @hi_sdsnew(ptr noundef %5)
  %6 = load ptr, ptr %help, align 8
  %docs = getelementptr inbounds %struct.helpEntry, ptr %6, i32 0, i32 4
  %summary1 = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 1
  store ptr %call, ptr %summary1, align 8
  %7 = load ptr, ptr %command.addr, align 8
  %since = getelementptr inbounds %struct.commandDocs, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %since, align 8
  %call2 = call ptr @hi_sdsnew(ptr noundef %8)
  %9 = load ptr, ptr %help, align 8
  %docs3 = getelementptr inbounds %struct.helpEntry, ptr %9, i32 0, i32 4
  %since4 = getelementptr inbounds %struct.commandDocs, ptr %docs3, i32 0, i32 3
  store ptr %call2, ptr %since4, align 8
  %10 = load ptr, ptr %command.addr, align 8
  %group = getelementptr inbounds %struct.commandDocs, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %group, align 8
  %call5 = call ptr @hi_sdsnew(ptr noundef %11)
  %12 = load ptr, ptr %help, align 8
  %docs6 = getelementptr inbounds %struct.helpEntry, ptr %12, i32 0, i32 4
  %group7 = getelementptr inbounds %struct.commandDocs, ptr %docs6, i32 0, i32 2
  store ptr %call5, ptr %group7, align 8
  %13 = load ptr, ptr %help, align 8
  %docs9 = getelementptr inbounds %struct.helpEntry, ptr %13, i32 0, i32 4
  %group10 = getelementptr inbounds %struct.commandDocs, ptr %docs9, i32 0, i32 2
  %14 = load ptr, ptr %group10, align 8
  %call11 = call ptr @hi_sdsdup(ptr noundef %14)
  store ptr %call11, ptr %group8, align 8
  %15 = load ptr, ptr %groups.addr, align 8
  %16 = load ptr, ptr %group8, align 8
  %call12 = call i32 @dictAdd(ptr noundef %15, ptr noundef %16, ptr noundef null)
  %cmp = icmp ne i32 %call12, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %17 = load ptr, ptr %group8, align 8
  call void @hi_sdsfree(ptr noundef %17)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %18 = load ptr, ptr %command.addr, align 8
  %args = getelementptr inbounds %struct.commandDocs, ptr %18, i32 0, i32 5
  %19 = load ptr, ptr %args, align 8
  %cmp13 = icmp ne ptr %19, null
  br i1 %cmp13, label %if.then14, label %if.end29

if.then14:                                        ; preds = %if.end
  %20 = load ptr, ptr %command.addr, align 8
  %args15 = getelementptr inbounds %struct.commandDocs, ptr %20, i32 0, i32 5
  %21 = load ptr, ptr %args15, align 8
  %22 = load ptr, ptr %help, align 8
  %docs16 = getelementptr inbounds %struct.helpEntry, ptr %22, i32 0, i32 4
  %args17 = getelementptr inbounds %struct.commandDocs, ptr %docs16, i32 0, i32 5
  store ptr %21, ptr %args17, align 8
  %23 = load ptr, ptr %command.addr, align 8
  %numargs = getelementptr inbounds %struct.commandDocs, ptr %23, i32 0, i32 4
  %24 = load i32, ptr %numargs, align 8
  %25 = load ptr, ptr %help, align 8
  %docs18 = getelementptr inbounds %struct.helpEntry, ptr %25, i32 0, i32 4
  %numargs19 = getelementptr inbounds %struct.commandDocs, ptr %docs18, i32 0, i32 4
  store i32 %24, ptr %numargs19, align 8
  %26 = load ptr, ptr %version.addr, align 8
  %tobool = icmp ne ptr %26, null
  br i1 %tobool, label %if.then20, label %if.end25

if.then20:                                        ; preds = %if.then14
  %27 = load ptr, ptr %help, align 8
  %docs21 = getelementptr inbounds %struct.helpEntry, ptr %27, i32 0, i32 4
  %args22 = getelementptr inbounds %struct.commandDocs, ptr %docs21, i32 0, i32 5
  %28 = load ptr, ptr %args22, align 8
  %29 = load ptr, ptr %help, align 8
  %docs23 = getelementptr inbounds %struct.helpEntry, ptr %29, i32 0, i32 4
  %numargs24 = getelementptr inbounds %struct.commandDocs, ptr %docs23, i32 0, i32 4
  %30 = load ptr, ptr %version.addr, align 8
  call void @removeUnsupportedArgs(ptr noundef %28, ptr noundef %numargs24, ptr noundef %30)
  br label %if.end25

if.end25:                                         ; preds = %if.then20, %if.then14
  %31 = load ptr, ptr %help, align 8
  %docs26 = getelementptr inbounds %struct.helpEntry, ptr %31, i32 0, i32 4
  %call27 = call ptr @makeHint(ptr noundef null, i32 noundef 0, i32 noundef 0, ptr noundef byval(%struct.commandDocs) align 8 %docs26)
  %32 = load ptr, ptr %help, align 8
  %docs28 = getelementptr inbounds %struct.helpEntry, ptr %32, i32 0, i32 4
  %params = getelementptr inbounds %struct.commandDocs, ptr %docs28, i32 0, i32 7
  store ptr %call27, ptr %params, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.end25, %if.end
  %33 = load ptr, ptr %command.addr, align 8
  %subcommands = getelementptr inbounds %struct.commandDocs, ptr %33, i32 0, i32 6
  %34 = load ptr, ptr %subcommands, align 8
  %cmp30 = icmp ne ptr %34, null
  br i1 %cmp30, label %if.then31, label %if.end49

if.then31:                                        ; preds = %if.end29
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then31
  %35 = load ptr, ptr %command.addr, align 8
  %subcommands32 = getelementptr inbounds %struct.commandDocs, ptr %35, i32 0, i32 6
  %36 = load ptr, ptr %subcommands32, align 8
  %37 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.commandDocs, ptr %36, i64 %37
  %name = getelementptr inbounds %struct.commandDocs, ptr %arrayidx, i32 0, i32 0
  %38 = load ptr, ptr %name, align 8
  %cmp33 = icmp ne ptr %38, null
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %39 = load ptr, ptr %version.addr, align 8
  %tobool34 = icmp ne ptr %39, null
  br i1 %tobool34, label %lor.lhs.false, label %if.then40

lor.lhs.false:                                    ; preds = %for.body
  %40 = load ptr, ptr %version.addr, align 8
  %41 = load ptr, ptr %command.addr, align 8
  %subcommands35 = getelementptr inbounds %struct.commandDocs, ptr %41, i32 0, i32 6
  %42 = load ptr, ptr %subcommands35, align 8
  %43 = load i64, ptr %i, align 8
  %arrayidx36 = getelementptr inbounds %struct.commandDocs, ptr %42, i64 %43
  %since37 = getelementptr inbounds %struct.commandDocs, ptr %arrayidx36, i32 0, i32 3
  %44 = load ptr, ptr %since37, align 8
  %call38 = call i32 @versionIsSupported(ptr noundef %40, ptr noundef %44)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.then40, label %if.end48

if.then40:                                        ; preds = %lor.lhs.false, %for.body
  %45 = load ptr, ptr %command.addr, align 8
  %subcommands42 = getelementptr inbounds %struct.commandDocs, ptr %45, i32 0, i32 6
  %46 = load ptr, ptr %subcommands42, align 8
  %47 = load i64, ptr %i, align 8
  %arrayidx43 = getelementptr inbounds %struct.commandDocs, ptr %46, i64 %47
  %name44 = getelementptr inbounds %struct.commandDocs, ptr %arrayidx43, i32 0, i32 0
  %48 = load ptr, ptr %name44, align 8
  store ptr %48, ptr %subcommandname41, align 8
  %49 = load ptr, ptr %cmdname.addr, align 8
  %50 = load ptr, ptr %subcommandname41, align 8
  %51 = load ptr, ptr %next.addr, align 8
  %52 = load ptr, ptr %command.addr, align 8
  %subcommands45 = getelementptr inbounds %struct.commandDocs, ptr %52, i32 0, i32 6
  %53 = load ptr, ptr %subcommands45, align 8
  %54 = load i64, ptr %i, align 8
  %arrayidx46 = getelementptr inbounds %struct.commandDocs, ptr %53, i64 %54
  %55 = load ptr, ptr %groups.addr, align 8
  %56 = load ptr, ptr %version.addr, align 8
  %call47 = call ptr @cliLegacyInitCommandHelpEntry(ptr noundef %49, ptr noundef %50, ptr noundef %51, ptr noundef %arrayidx46, ptr noundef %55, ptr noundef %56)
  store ptr %call47, ptr %next.addr, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then40, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end48
  %57 = load i64, ptr %i, align 8
  %inc = add i64 %57, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  br label %if.end49

if.end49:                                         ; preds = %for.end, %if.end29
  %58 = load ptr, ptr %next.addr, align 8
  ret ptr %58
}

; Function Attrs: nounwind uwtable
define dso_local void @cliRestoreTTY() #0 {
entry:
  %0 = load i32, ptr @orig_termios_saved, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @tcsetattr(i32 noundef 0, i32 noundef 0, ptr noundef @orig_termios) #15
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind
declare i32 @tcsetattr(i32 noundef, i32 noundef, ptr noundef) #6

; Function Attrs: nounwind uwtable
define dso_local i32 @isPubsubPush(ptr noundef %r) #0 {
entry:
  %retval = alloca i32, align 4
  %r.addr = alloca ptr, align 8
  %str = alloca ptr, align 8
  %len = alloca i64, align 8
  store ptr %r, ptr %r.addr, align 8
  %0 = load ptr, ptr %r.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %r.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %3 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 59), align 4
  %tobool = icmp ne i32 %3, 0
  %cond = select i1 %tobool, i32 12, i32 2
  %cmp1 = icmp ne i32 %2, %cond
  br i1 %cmp1, label %if.then, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %4 = load ptr, ptr %r.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %4, i32 0, i32 6
  %5 = load i64, ptr %elements, align 8
  %cmp3 = icmp ult i64 %5, 3
  br i1 %cmp3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false2
  %6 = load ptr, ptr %r.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 7
  %7 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 0
  %8 = load ptr, ptr %arrayidx, align 8
  %type5 = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type5, align 8
  %cmp6 = icmp ne i32 %9, 1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false4, %lor.lhs.false2, %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false4
  %10 = load ptr, ptr %r.addr, align 8
  %element7 = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 7
  %11 = load ptr, ptr %element7, align 8
  %arrayidx8 = getelementptr inbounds ptr, ptr %11, i64 0
  %12 = load ptr, ptr %arrayidx8, align 8
  %str9 = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %str9, align 8
  store ptr %13, ptr %str, align 8
  %14 = load ptr, ptr %r.addr, align 8
  %element10 = getelementptr inbounds %struct.redisReply, ptr %14, i32 0, i32 7
  %15 = load ptr, ptr %element10, align 8
  %arrayidx11 = getelementptr inbounds ptr, ptr %15, i64 0
  %16 = load ptr, ptr %arrayidx11, align 8
  %len12 = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 3
  %17 = load i64, ptr %len12, align 8
  store i64 %17, ptr %len, align 8
  %18 = load i64, ptr %len, align 8
  %cmp13 = icmp uge i64 %18, 7
  br i1 %cmp13, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %if.end
  %19 = load ptr, ptr %str, align 8
  %20 = load i64, ptr %len, align 8
  %add.ptr = getelementptr inbounds i8, ptr %19, i64 %20
  %add.ptr14 = getelementptr inbounds i8, ptr %add.ptr, i64 -7
  %call = call i32 @strcmp(ptr noundef %add.ptr14, ptr noundef @.str.1) #12
  %tobool15 = icmp ne i32 %call, 0
  br i1 %tobool15, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.lhs.true, %if.end
  %21 = load i64, ptr %len, align 8
  %cmp16 = icmp uge i64 %21, 9
  br i1 %cmp16, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %22 = load ptr, ptr %str, align 8
  %23 = load i64, ptr %len, align 8
  %add.ptr17 = getelementptr inbounds i8, ptr %22, i64 %23
  %add.ptr18 = getelementptr inbounds i8, ptr %add.ptr17, i64 -9
  %call19 = call i32 @strcmp(ptr noundef %add.ptr18, ptr noundef @.str.2) #12
  %tobool20 = icmp ne i32 %call19, 0
  %lnot = xor i1 %tobool20, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %24 = phi i1 [ false, %lor.rhs ], [ %lnot, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true
  %25 = phi i1 [ true, %land.lhs.true ], [ %24, %land.end ]
  %lor.ext = zext i1 %25 to i32
  store i32 %lor.ext, ptr %retval, align 4
  br label %return

return:                                           ; preds = %lor.end, %if.then
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isColorTerm() #0 {
entry:
  %t = alloca ptr, align 8
  %call = call ptr @getenv(ptr noundef @.str.3) #15
  store ptr %call, ptr %t, align 8
  %0 = load ptr, ptr %t, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load ptr, ptr %t, align 8
  %call1 = call ptr @strstr(ptr noundef %1, ptr noundef @.str.4) #12
  %cmp2 = icmp ne ptr %call1, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind
declare ptr @getenv(ptr noundef) #6

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strstr(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define dso_local ptr @sdscatcolor(ptr noundef %o, ptr noundef %s, i64 noundef %len, ptr noundef %color) #0 {
entry:
  %retval = alloca ptr, align 8
  %o.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %color.addr = alloca ptr, align 8
  %bold = alloca i32, align 4
  %ccode = alloca i32, align 4
  store ptr %o, ptr %o.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %color, ptr %color.addr, align 8
  %call = call i32 @isColorTerm()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr %o.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  %call1 = call ptr @hi_sdscatlen(ptr noundef %0, ptr noundef %1, i64 noundef %2)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %color.addr, align 8
  %call2 = call ptr @strstr(ptr noundef %3, ptr noundef @.str.5) #12
  %cmp = icmp ne ptr %call2, null
  %conv = zext i1 %cmp to i32
  store i32 %conv, ptr %bold, align 4
  store i32 37, ptr %ccode, align 4
  %4 = load ptr, ptr %color.addr, align 8
  %call3 = call ptr @strstr(ptr noundef %4, ptr noundef @.str.6) #12
  %tobool4 = icmp ne ptr %call3, null
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  store i32 31, ptr %ccode, align 4
  br label %if.end35

if.else:                                          ; preds = %if.end
  %5 = load ptr, ptr %color.addr, align 8
  %call6 = call ptr @strstr(ptr noundef %5, ptr noundef @.str.7) #12
  %tobool7 = icmp ne ptr %call6, null
  br i1 %tobool7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else
  store i32 32, ptr %ccode, align 4
  br label %if.end34

if.else9:                                         ; preds = %if.else
  %6 = load ptr, ptr %color.addr, align 8
  %call10 = call ptr @strstr(ptr noundef %6, ptr noundef @.str.8) #12
  %tobool11 = icmp ne ptr %call10, null
  br i1 %tobool11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.else9
  store i32 33, ptr %ccode, align 4
  br label %if.end33

if.else13:                                        ; preds = %if.else9
  %7 = load ptr, ptr %color.addr, align 8
  %call14 = call ptr @strstr(ptr noundef %7, ptr noundef @.str.9) #12
  %tobool15 = icmp ne ptr %call14, null
  br i1 %tobool15, label %if.then16, label %if.else17

if.then16:                                        ; preds = %if.else13
  store i32 34, ptr %ccode, align 4
  br label %if.end32

if.else17:                                        ; preds = %if.else13
  %8 = load ptr, ptr %color.addr, align 8
  %call18 = call ptr @strstr(ptr noundef %8, ptr noundef @.str.10) #12
  %tobool19 = icmp ne ptr %call18, null
  br i1 %tobool19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.else17
  store i32 35, ptr %ccode, align 4
  br label %if.end31

if.else21:                                        ; preds = %if.else17
  %9 = load ptr, ptr %color.addr, align 8
  %call22 = call ptr @strstr(ptr noundef %9, ptr noundef @.str.11) #12
  %tobool23 = icmp ne ptr %call22, null
  br i1 %tobool23, label %if.then24, label %if.else25

if.then24:                                        ; preds = %if.else21
  store i32 36, ptr %ccode, align 4
  br label %if.end30

if.else25:                                        ; preds = %if.else21
  %10 = load ptr, ptr %color.addr, align 8
  %call26 = call ptr @strstr(ptr noundef %10, ptr noundef @.str.12) #12
  %tobool27 = icmp ne ptr %call26, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.else25
  store i32 37, ptr %ccode, align 4
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.else25
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.then24
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then20
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then16
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.then12
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.then8
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then5
  %11 = load ptr, ptr %o.addr, align 8
  %12 = load i32, ptr %bold, align 4
  %13 = load i32, ptr %ccode, align 4
  %call36 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %11, ptr noundef @.str.13, i32 noundef %12, i32 noundef %13)
  store ptr %call36, ptr %o.addr, align 8
  %14 = load ptr, ptr %o.addr, align 8
  %15 = load ptr, ptr %s.addr, align 8
  %16 = load i64, ptr %len.addr, align 8
  %call37 = call ptr @hi_sdscatlen(ptr noundef %14, ptr noundef %15, i64 noundef %16)
  store ptr %call37, ptr %o.addr, align 8
  %17 = load ptr, ptr %o.addr, align 8
  %call38 = call ptr @hi_sdscat(ptr noundef %17, ptr noundef @.str.14)
  store ptr %call38, ptr %o.addr, align 8
  %18 = load ptr, ptr %o.addr, align 8
  store ptr %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end35, %if.then
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

declare ptr @hi_sdscatlen(ptr noundef, ptr noundef, i64 noundef) #2

declare ptr @hi_sdscatfmt(ptr noundef, ptr noundef, ...) #2

declare ptr @hi_sdscat(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @sdsCatColorizedLdbReply(ptr noundef %o, ptr noundef %s, i64 noundef %len) #0 {
entry:
  %o.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %color = alloca ptr, align 8
  store ptr %o, ptr %o.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr @.str.12, ptr %color, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @strstr(ptr noundef %0, ptr noundef @.str.15) #12
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr @.str.5, ptr %color, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %s.addr, align 8
  %call1 = call ptr @strstr(ptr noundef %1, ptr noundef @.str.16) #12
  %tobool2 = icmp ne ptr %call1, null
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store ptr @.str.7, ptr %color, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %2 = load ptr, ptr %s.addr, align 8
  %call5 = call ptr @strstr(ptr noundef %2, ptr noundef @.str.17) #12
  %tobool6 = icmp ne ptr %call5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  store ptr @.str.11, ptr %color, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %3 = load ptr, ptr %s.addr, align 8
  %call9 = call ptr @strstr(ptr noundef %3, ptr noundef @.str.18) #12
  %tobool10 = icmp ne ptr %call9, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  store ptr @.str.6, ptr %color, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end8
  %4 = load ptr, ptr %s.addr, align 8
  %call13 = call ptr @strstr(ptr noundef %4, ptr noundef @.str.19) #12
  %tobool14 = icmp ne ptr %call13, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end12
  store ptr @.str.5, ptr %color, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.end12
  %5 = load ptr, ptr %s.addr, align 8
  %call17 = call ptr @strstr(ptr noundef %5, ptr noundef @.str.20) #12
  %tobool18 = icmp ne ptr %call17, null
  br i1 %tobool18, label %if.then21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end16
  %6 = load ptr, ptr %s.addr, align 8
  %call19 = call ptr @strstr(ptr noundef %6, ptr noundef @.str.21) #12
  %tobool20 = icmp ne ptr %call19, null
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %lor.lhs.false, %if.end16
  store ptr @.str.10, ptr %color, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %lor.lhs.false
  %7 = load i64, ptr %len.addr, align 8
  %cmp = icmp ugt i64 %7, 4
  br i1 %cmp, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %if.end22
  %call23 = call ptr @__ctype_b_loc() #16
  %8 = load ptr, ptr %call23, align 8
  %9 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %9, i64 3
  %10 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %idxprom = sext i32 %conv to i64
  %arrayidx24 = getelementptr inbounds i16, ptr %8, i64 %idxprom
  %11 = load i16, ptr %arrayidx24, align 2
  %conv25 = zext i16 %11 to i32
  %and = and i32 %conv25, 2048
  %tobool26 = icmp ne i32 %and, 0
  br i1 %tobool26, label %if.then27, label %if.end40

if.then27:                                        ; preds = %land.lhs.true
  %12 = load ptr, ptr %s.addr, align 8
  %arrayidx28 = getelementptr inbounds i8, ptr %12, i64 1
  %13 = load i8, ptr %arrayidx28, align 1
  %conv29 = sext i8 %13 to i32
  %cmp30 = icmp eq i32 %conv29, 62
  br i1 %cmp30, label %if.then32, label %if.else

if.then32:                                        ; preds = %if.then27
  store ptr @.str.8, ptr %color, align 8
  br label %if.end39

if.else:                                          ; preds = %if.then27
  %14 = load ptr, ptr %s.addr, align 8
  %arrayidx33 = getelementptr inbounds i8, ptr %14, i64 2
  %15 = load i8, ptr %arrayidx33, align 1
  %conv34 = sext i8 %15 to i32
  %cmp35 = icmp eq i32 %conv34, 35
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.else
  store ptr @.str.5, ptr %color, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.else
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then32
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %land.lhs.true, %if.end22
  %16 = load ptr, ptr %o.addr, align 8
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load i64, ptr %len.addr, align 8
  %19 = load ptr, ptr %color, align 8
  %call41 = call ptr @sdscatcolor(ptr noundef %16, ptr noundef %17, i64 noundef %18, ptr noundef %19)
  ret ptr %call41
}

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__ctype_b_loc() #7

; Function Attrs: nounwind uwtable
define dso_local void @cliSetPreferences(ptr noundef %argv, i32 noundef %argc, i32 noundef %interactive) #0 {
entry:
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %interactive.addr = alloca i32, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store i32 %interactive, ptr %interactive.addr, align 4
  %0 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 0
  %1 = load ptr, ptr %arrayidx, align 8
  %call = call i32 @strcasecmp(ptr noundef %1, ptr noundef @.str.22) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else14, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, ptr %argc.addr, align 4
  %cmp = icmp sge i32 %2, 2
  br i1 %cmp, label %if.then, label %if.else14

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %argv.addr, align 8
  %arrayidx1 = getelementptr inbounds ptr, ptr %3, i64 1
  %4 = load ptr, ptr %arrayidx1, align 8
  %call2 = call i32 @strcasecmp(ptr noundef %4, ptr noundef @.str.23) #12
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.else, label %if.then4

if.then4:                                         ; preds = %if.then
  store i32 1, ptr @pref, align 4
  br label %if.end13

if.else:                                          ; preds = %if.then
  %5 = load ptr, ptr %argv.addr, align 8
  %arrayidx5 = getelementptr inbounds ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx5, align 8
  %call6 = call i32 @strcasecmp(ptr noundef %6, ptr noundef @.str.24) #12
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.else9, label %if.then8

if.then8:                                         ; preds = %if.else
  store i32 0, ptr @pref, align 4
  br label %if.end

if.else9:                                         ; preds = %if.else
  %7 = load i32, ptr %interactive.addr, align 4
  %tobool10 = icmp ne i32 %7, 0
  %cond = select i1 %tobool10, ptr @.str.26, ptr @.str.27
  %8 = load ptr, ptr %argv.addr, align 8
  %arrayidx11 = getelementptr inbounds ptr, ptr %8, i64 1
  %9 = load ptr, ptr %arrayidx11, align 8
  %call12 = call i32 (ptr, ...) @printf(ptr noundef @.str.25, ptr noundef %cond, ptr noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.else9, %if.then8
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then4
  br label %if.end19

if.else14:                                        ; preds = %land.lhs.true, %entry
  %10 = load i32, ptr %interactive.addr, align 4
  %tobool15 = icmp ne i32 %10, 0
  %cond16 = select i1 %tobool15, ptr @.str.26, ptr @.str.27
  %11 = load ptr, ptr %argv.addr, align 8
  %arrayidx17 = getelementptr inbounds ptr, ptr %11, i64 0
  %12 = load ptr, ptr %arrayidx17, align 8
  %call18 = call i32 (ptr, ...) @printf(ptr noundef @.str.28, ptr noundef %cond16, ptr noundef %12)
  br label %if.end19

if.end19:                                         ; preds = %if.else14, %if.end13
  ret void
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcasecmp(ptr noundef, ptr noundef) #1

declare i32 @printf(ptr noundef, ...) #2

; Function Attrs: nounwind uwtable
define dso_local void @cliLoadPreferences() #0 {
entry:
  %rcfile = alloca ptr, align 8
  %fp = alloca ptr, align 8
  %buf = alloca [1024 x i8], align 16
  %argv = alloca ptr, align 8
  %argc = alloca i32, align 4
  %call = call ptr @getDotfilePath(ptr noundef @.str.29, ptr noundef @.str.30)
  store ptr %call, ptr %rcfile, align 8
  %0 = load ptr, ptr %rcfile, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %rcfile, align 8
  %call1 = call noalias ptr @fopen64(ptr noundef %1, ptr noundef @.str.31)
  store ptr %call1, ptr %fp, align 8
  %2 = load ptr, ptr %fp, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then2, label %if.end11

if.then2:                                         ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %if.then2
  %arraydecay = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %3 = load ptr, ptr %fp, align 8
  %call3 = call ptr @fgets(ptr noundef %arraydecay, i32 noundef 1024, ptr noundef %3)
  %cmp4 = icmp ne ptr %call3, null
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %arraydecay5 = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %call6 = call ptr @hi_sdssplitargs(ptr noundef %arraydecay5, ptr noundef %argc)
  store ptr %call6, ptr %argv, align 8
  %4 = load i32, ptr %argc, align 4
  %cmp7 = icmp sgt i32 %4, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %while.body
  %5 = load ptr, ptr %argv, align 8
  %6 = load i32, ptr %argc, align 4
  call void @cliSetPreferences(ptr noundef %5, i32 noundef %6, i32 noundef 0)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %while.body
  %7 = load ptr, ptr %argv, align 8
  %8 = load i32, ptr %argc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %7, i32 noundef %8)
  br label %while.cond, !llvm.loop !13

while.end:                                        ; preds = %while.cond
  %9 = load ptr, ptr %fp, align 8
  %call10 = call i32 @fclose(ptr noundef %9)
  br label %if.end11

if.end11:                                         ; preds = %while.end, %if.end
  %10 = load ptr, ptr %rcfile, align 8
  call void @hi_sdsfree(ptr noundef %10)
  br label %return

return:                                           ; preds = %if.end11, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @getDotfilePath(ptr noundef %envoverride, ptr noundef %dotfilename) #0 {
entry:
  %retval = alloca ptr, align 8
  %envoverride.addr = alloca ptr, align 8
  %dotfilename.addr = alloca ptr, align 8
  %path = alloca ptr, align 8
  %dotPath = alloca ptr, align 8
  %home = alloca ptr, align 8
  store ptr %envoverride, ptr %envoverride.addr, align 8
  store ptr %dotfilename, ptr %dotfilename.addr, align 8
  store ptr null, ptr %path, align 8
  store ptr null, ptr %dotPath, align 8
  %0 = load ptr, ptr %envoverride.addr, align 8
  %call = call ptr @getenv(ptr noundef %0) #15
  store ptr %call, ptr %path, align 8
  %1 = load ptr, ptr %path, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %path, align 8
  %3 = load i8, ptr %2, align 1
  %conv = sext i8 %3 to i32
  %cmp1 = icmp ne i32 %conv, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %4 = load ptr, ptr %path, align 8
  %call3 = call i32 @strcmp(ptr noundef @.str.160, ptr noundef %4) #12
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %5 = load ptr, ptr %path, align 8
  %call5 = call ptr @hi_sdsnew(ptr noundef %5)
  store ptr %call5, ptr %dotPath, align 8
  br label %if.end17

if.else:                                          ; preds = %land.lhs.true, %entry
  %call6 = call ptr @getenv(ptr noundef @.str.161) #15
  store ptr %call6, ptr %home, align 8
  %6 = load ptr, ptr %home, align 8
  %cmp7 = icmp ne ptr %6, null
  br i1 %cmp7, label %land.lhs.true9, label %if.end16

land.lhs.true9:                                   ; preds = %if.else
  %7 = load ptr, ptr %home, align 8
  %8 = load i8, ptr %7, align 1
  %conv10 = sext i8 %8 to i32
  %cmp11 = icmp ne i32 %conv10, 0
  br i1 %cmp11, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true9
  %call14 = call ptr @hi_sdsempty()
  %9 = load ptr, ptr %home, align 8
  %10 = load ptr, ptr %dotfilename.addr, align 8
  %call15 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %call14, ptr noundef @.str.162, ptr noundef %9, ptr noundef %10)
  store ptr %call15, ptr %dotPath, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %land.lhs.true9, %if.else
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end
  %11 = load ptr, ptr %dotPath, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then4
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

declare noalias ptr @fopen64(ptr noundef, ptr noundef) #2

declare ptr @fgets(ptr noundef, i32 noundef, ptr noundef) #2

declare ptr @hi_sdssplitargs(ptr noundef, ptr noundef) #2

declare void @hi_sdsfreesplitres(ptr noundef, i32 noundef) #2

declare i32 @fclose(ptr noundef) #2

declare void @hi_sdsfree(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandCreate(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %success = alloca i32, align 4
  %addr = alloca ptr, align 8
  %ip = alloca ptr, align 8
  %port = alloca i32, align 4
  %node = alloca ptr, align 8
  %err = alloca ptr, align 8
  %node_len = alloca i32, align 4
  %replicas = alloca i32, align 4
  %masters_count = alloca i32, align 4
  %interleaved_len = alloca i32, align 4
  %ip_count = alloca i32, align 4
  %interleaved = alloca ptr, align 8
  %ips = alloca ptr, align 8
  %ip_nodes = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %found = alloca i32, align 4
  %ip53 = alloca ptr, align 8
  %node_array = alloca ptr, align 8
  %node_array85 = alloca ptr, align 8
  %n91 = alloca ptr, align 8
  %masters = alloca ptr, align 8
  %slots_per_node = alloca float, align 4
  %first = alloca i64, align 8
  %cursor = alloca float, align 4
  %master = alloca ptr, align 8
  %last = alloca i64, align 8
  %first_node = alloca ptr, align 8
  %assign_unused = alloca i32, align 4
  %available_count = alloca i32, align 4
  %master163 = alloca ptr, align 8
  %assigned_replicas = alloca i32, align 4
  %found174 = alloca ptr, align 8
  %slave = alloca ptr, align 8
  %firstNodeIdx = alloca i32, align 4
  %n179 = alloca ptr, align 8
  %node_array250 = alloca ptr, align 8
  %ignore_force = alloca i32, align 4
  %node264 = alloca ptr, align 8
  %err266 = alloca ptr, align 8
  %flushed = alloca i32, align 4
  %config_epoch = alloca i32, align 4
  %node294 = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %first303 = alloca ptr, align 8
  %first_ip = alloca [46 x i8], align 16
  %node309 = alloca ptr, align 8
  %reply323 = alloca ptr, align 8
  %is_err = alloca i32, align 4
  %node366 = alloca ptr, align 8
  %err372 = alloca ptr, align 8
  %flushed373 = alloca i32, align 4
  %first_node393 = alloca ptr, align 8
  %node399 = alloca ptr, align 8
  %node_array416 = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 1, ptr %success, align 4
  %call = call ptr @listCreate()
  store ptr %call, ptr @cluster_manager, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %argc.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %argv.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 %idxprom
  %4 = load ptr, ptr %arrayidx, align 8
  store ptr %4, ptr %addr, align 8
  store ptr null, ptr %ip, align 8
  store i32 0, ptr %port, align 4
  %5 = load ptr, ptr %addr, align 8
  %call1 = call i32 @parseClusterNodeAddress(ptr noundef %5, ptr noundef %ip, ptr noundef %port, ptr noundef null)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr @stderr, align 8
  %7 = load ptr, ptr %addr, align 8
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.163, ptr noundef %7)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  %8 = load ptr, ptr %ip, align 8
  %9 = load i32, ptr %port, align 4
  %call3 = call ptr @clusterManagerNewNode(ptr noundef %8, i32 noundef %9, i32 noundef 0)
  store ptr %call3, ptr %node, align 8
  %10 = load ptr, ptr %node, align 8
  %call4 = call i32 @clusterManagerNodeConnect(ptr noundef %10)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  %11 = load ptr, ptr %node, align 8
  call void @freeClusterManagerNode(ptr noundef %11)
  store i32 0, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  store ptr null, ptr %err, align 8
  %12 = load ptr, ptr %node, align 8
  %call8 = call i32 @clusterManagerNodeIsCluster(ptr noundef %12, ptr noundef %err)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end14, label %if.then10

if.then10:                                        ; preds = %if.end7
  %13 = load ptr, ptr %node, align 8
  %14 = load ptr, ptr %err, align 8
  call void @clusterManagerPrintNotClusterNodeError(ptr noundef %13, ptr noundef %14)
  %15 = load ptr, ptr %err, align 8
  %tobool11 = icmp ne ptr %15, null
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then10
  %16 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %16)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then10
  %17 = load ptr, ptr %node, align 8
  call void @freeClusterManagerNode(ptr noundef %17)
  store i32 0, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end7
  store ptr null, ptr %err, align 8
  %18 = load ptr, ptr %node, align 8
  %call15 = call i32 @clusterManagerNodeLoadInfo(ptr noundef %18, i32 noundef 0, ptr noundef %err)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end23, label %if.then17

if.then17:                                        ; preds = %if.end14
  %19 = load ptr, ptr %err, align 8
  %tobool18 = icmp ne ptr %19, null
  br i1 %tobool18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.then17
  %20 = load ptr, ptr %node, align 8
  %ip20 = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %ip20, align 8
  %22 = load ptr, ptr %node, align 8
  %port21 = getelementptr inbounds %struct.clusterManagerNode, ptr %22, i32 0, i32 3
  %23 = load i32, ptr %port21, align 8
  %24 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %21, i32 noundef %23, ptr noundef %24)
  %25 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %25)
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.then17
  %26 = load ptr, ptr %node, align 8
  call void @freeClusterManagerNode(ptr noundef %26)
  store i32 0, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.end14
  store ptr null, ptr %err, align 8
  %27 = load ptr, ptr %node, align 8
  %call24 = call i32 @clusterManagerNodeIsEmpty(ptr noundef %27, ptr noundef %err)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.end30, label %if.then26

if.then26:                                        ; preds = %if.end23
  %28 = load ptr, ptr %node, align 8
  %29 = load ptr, ptr %err, align 8
  call void @clusterManagerPrintNotEmptyNodeError(ptr noundef %28, ptr noundef %29)
  %30 = load ptr, ptr %err, align 8
  %tobool27 = icmp ne ptr %30, null
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.then26
  %31 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %31)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.then26
  %32 = load ptr, ptr %node, align 8
  call void @freeClusterManagerNode(ptr noundef %32)
  store i32 0, ptr %retval, align 4
  br label %return

if.end30:                                         ; preds = %if.end23
  %33 = load ptr, ptr @cluster_manager, align 8
  %34 = load ptr, ptr %node, align 8
  %call31 = call ptr @listAddNodeTail(ptr noundef %33, ptr noundef %34)
  br label %for.inc

for.inc:                                          ; preds = %if.end30
  %35 = load i32, ptr %i, align 4
  %inc = add nsw i32 %35, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  %36 = load ptr, ptr @cluster_manager, align 8
  %len = getelementptr inbounds %struct.list, ptr %36, i32 0, i32 5
  %37 = load i64, ptr %len, align 8
  %conv = trunc i64 %37 to i32
  store i32 %conv, ptr %node_len, align 4
  %38 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 5), align 4
  store i32 %38, ptr %replicas, align 4
  %39 = load i32, ptr %node_len, align 4
  %40 = load i32, ptr %replicas, align 4
  %add = add nsw i32 %40, 1
  %div = sdiv i32 %39, %add
  store i32 %div, ptr %masters_count, align 4
  %41 = load i32, ptr %masters_count, align 4
  %cmp32 = icmp slt i32 %41, 3
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %for.end
  %42 = load i32, ptr %node_len, align 4
  %43 = load i32, ptr %replicas, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.165, i32 noundef %42, i32 noundef %43)
  %44 = load i32, ptr %replicas, align 4
  %add35 = add nsw i32 %44, 1
  %mul = mul nsw i32 3, %add35
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.166, i32 noundef %mul)
  store i32 0, ptr %retval, align 4
  br label %return

if.end36:                                         ; preds = %for.end
  %45 = load i32, ptr %node_len, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.167, i32 noundef %45)
  store i32 0, ptr %interleaved_len, align 4
  store i32 0, ptr %ip_count, align 4
  %46 = load i32, ptr %node_len, align 4
  %conv37 = sext i32 %46 to i64
  %mul38 = mul i64 %conv37, 16520
  %call39 = call noalias ptr @zcalloc(i64 noundef %mul38) #14
  store ptr %call39, ptr %interleaved, align 8
  %47 = load i32, ptr %node_len, align 4
  %conv40 = sext i32 %47 to i64
  %mul41 = mul i64 %conv40, 8
  %call42 = call noalias ptr @zcalloc(i64 noundef %mul41) #14
  store ptr %call42, ptr %ips, align 8
  %48 = load i32, ptr %node_len, align 4
  %conv43 = sext i32 %48 to i64
  %mul44 = mul i64 %conv43, 24
  %call45 = call noalias ptr @zcalloc(i64 noundef %mul44) #14
  store ptr %call45, ptr %ip_nodes, align 8
  %49 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %49, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end76, %if.end36
  %call46 = call ptr @listNext(ptr noundef %li)
  store ptr %call46, ptr %ln, align 8
  %cmp47 = icmp ne ptr %call46, null
  br i1 %cmp47, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %50 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %50, i32 0, i32 2
  %51 = load ptr, ptr %value, align 8
  store ptr %51, ptr %n, align 8
  store i32 0, ptr %found, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond49

for.cond49:                                       ; preds = %for.inc61, %while.body
  %52 = load i32, ptr %i, align 4
  %53 = load i32, ptr %ip_count, align 4
  %cmp50 = icmp slt i32 %52, %53
  br i1 %cmp50, label %for.body52, label %for.end63

for.body52:                                       ; preds = %for.cond49
  %54 = load ptr, ptr %ips, align 8
  %55 = load i32, ptr %i, align 4
  %idxprom54 = sext i32 %55 to i64
  %arrayidx55 = getelementptr inbounds ptr, ptr %54, i64 %idxprom54
  %56 = load ptr, ptr %arrayidx55, align 8
  store ptr %56, ptr %ip53, align 8
  %57 = load ptr, ptr %ip53, align 8
  %58 = load ptr, ptr %n, align 8
  %ip56 = getelementptr inbounds %struct.clusterManagerNode, ptr %58, i32 0, i32 2
  %59 = load ptr, ptr %ip56, align 8
  %call57 = call i32 @strcmp(ptr noundef %57, ptr noundef %59) #12
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.end60, label %if.then59

if.then59:                                        ; preds = %for.body52
  store i32 1, ptr %found, align 4
  br label %for.end63

if.end60:                                         ; preds = %for.body52
  br label %for.inc61

for.inc61:                                        ; preds = %if.end60
  %60 = load i32, ptr %i, align 4
  %inc62 = add nsw i32 %60, 1
  store i32 %inc62, ptr %i, align 4
  br label %for.cond49, !llvm.loop !15

for.end63:                                        ; preds = %if.then59, %for.cond49
  %61 = load i32, ptr %found, align 4
  %tobool64 = icmp ne i32 %61, 0
  br i1 %tobool64, label %if.end70, label %if.then65

if.then65:                                        ; preds = %for.end63
  %62 = load ptr, ptr %n, align 8
  %ip66 = getelementptr inbounds %struct.clusterManagerNode, ptr %62, i32 0, i32 2
  %63 = load ptr, ptr %ip66, align 8
  %64 = load ptr, ptr %ips, align 8
  %65 = load i32, ptr %ip_count, align 4
  %inc67 = add nsw i32 %65, 1
  store i32 %inc67, ptr %ip_count, align 4
  %idxprom68 = sext i32 %65 to i64
  %arrayidx69 = getelementptr inbounds ptr, ptr %64, i64 %idxprom68
  store ptr %63, ptr %arrayidx69, align 8
  br label %if.end70

if.end70:                                         ; preds = %if.then65, %for.end63
  %66 = load ptr, ptr %ip_nodes, align 8
  %67 = load i32, ptr %i, align 4
  %idxprom71 = sext i32 %67 to i64
  %arrayidx72 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %66, i64 %idxprom71
  store ptr %arrayidx72, ptr %node_array, align 8
  %68 = load ptr, ptr %node_array, align 8
  %nodes = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %68, i32 0, i32 0
  %69 = load ptr, ptr %nodes, align 8
  %cmp73 = icmp eq ptr %69, null
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %if.end70
  %70 = load ptr, ptr %node_array, align 8
  %71 = load i32, ptr %node_len, align 4
  call void @clusterManagerNodeArrayInit(ptr noundef %70, i32 noundef %71)
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %if.end70
  %72 = load ptr, ptr %node_array, align 8
  %73 = load ptr, ptr %n, align 8
  call void @clusterManagerNodeArrayAdd(ptr noundef %72, ptr noundef %73)
  br label %while.cond, !llvm.loop !16

while.end:                                        ; preds = %while.cond
  br label %while.cond77

while.cond77:                                     ; preds = %for.end98, %while.end
  %74 = load i32, ptr %interleaved_len, align 4
  %75 = load i32, ptr %node_len, align 4
  %cmp78 = icmp slt i32 %74, %75
  br i1 %cmp78, label %while.body80, label %while.end99

while.body80:                                     ; preds = %while.cond77
  store i32 0, ptr %i, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc96, %while.body80
  %76 = load i32, ptr %i, align 4
  %77 = load i32, ptr %ip_count, align 4
  %cmp82 = icmp slt i32 %76, %77
  br i1 %cmp82, label %for.body84, label %for.end98

for.body84:                                       ; preds = %for.cond81
  %78 = load ptr, ptr %ip_nodes, align 8
  %79 = load i32, ptr %i, align 4
  %idxprom86 = sext i32 %79 to i64
  %arrayidx87 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %78, i64 %idxprom86
  store ptr %arrayidx87, ptr %node_array85, align 8
  %80 = load ptr, ptr %node_array85, align 8
  %count = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %80, i32 0, i32 3
  %81 = load i32, ptr %count, align 4
  %cmp88 = icmp sgt i32 %81, 0
  br i1 %cmp88, label %if.then90, label %if.end95

if.then90:                                        ; preds = %for.body84
  store ptr null, ptr %n91, align 8
  %82 = load ptr, ptr %node_array85, align 8
  call void @clusterManagerNodeArrayShift(ptr noundef %82, ptr noundef %n91)
  %83 = load ptr, ptr %n91, align 8
  %84 = load ptr, ptr %interleaved, align 8
  %85 = load i32, ptr %interleaved_len, align 4
  %inc92 = add nsw i32 %85, 1
  store i32 %inc92, ptr %interleaved_len, align 4
  %idxprom93 = sext i32 %85 to i64
  %arrayidx94 = getelementptr inbounds ptr, ptr %84, i64 %idxprom93
  store ptr %83, ptr %arrayidx94, align 8
  br label %if.end95

if.end95:                                         ; preds = %if.then90, %for.body84
  br label %for.inc96

for.inc96:                                        ; preds = %if.end95
  %86 = load i32, ptr %i, align 4
  %inc97 = add nsw i32 %86, 1
  store i32 %inc97, ptr %i, align 4
  br label %for.cond81, !llvm.loop !17

for.end98:                                        ; preds = %for.cond81
  br label %while.cond77, !llvm.loop !18

while.end99:                                      ; preds = %while.cond77
  %87 = load ptr, ptr %interleaved, align 8
  store ptr %87, ptr %masters, align 8
  %88 = load i32, ptr %masters_count, align 4
  %89 = load ptr, ptr %interleaved, align 8
  %idx.ext = sext i32 %88 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %89, i64 %idx.ext
  store ptr %add.ptr, ptr %interleaved, align 8
  %90 = load i32, ptr %masters_count, align 4
  %91 = load i32, ptr %interleaved_len, align 4
  %sub = sub nsw i32 %91, %90
  store i32 %sub, ptr %interleaved_len, align 4
  %92 = load i32, ptr %masters_count, align 4
  %conv100 = sitofp i32 %92 to float
  %div101 = fdiv float 1.638400e+04, %conv100
  store float %div101, ptr %slots_per_node, align 4
  store i64 0, ptr %first, align 8
  store float 0.000000e+00, ptr %cursor, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond102

for.cond102:                                      ; preds = %for.inc139, %while.end99
  %93 = load i32, ptr %i, align 4
  %94 = load i32, ptr %masters_count, align 4
  %cmp103 = icmp slt i32 %93, %94
  br i1 %cmp103, label %for.body105, label %for.end141

for.body105:                                      ; preds = %for.cond102
  %95 = load ptr, ptr %masters, align 8
  %96 = load i32, ptr %i, align 4
  %idxprom106 = sext i32 %96 to i64
  %arrayidx107 = getelementptr inbounds ptr, ptr %95, i64 %idxprom106
  %97 = load ptr, ptr %arrayidx107, align 8
  store ptr %97, ptr %master, align 8
  %98 = load float, ptr %cursor, align 4
  %99 = load float, ptr %slots_per_node, align 4
  %add108 = fadd float %98, %99
  %sub109 = fsub float %add108, 1.000000e+00
  %conv110 = fpext float %sub109 to double
  %call111 = call i64 @lround(double noundef %conv110) #15
  store i64 %call111, ptr %last, align 8
  %100 = load i64, ptr %last, align 8
  %cmp112 = icmp sgt i64 %100, 16384
  br i1 %cmp112, label %if.then117, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body105
  %101 = load i32, ptr %i, align 4
  %102 = load i32, ptr %masters_count, align 4
  %sub114 = sub nsw i32 %102, 1
  %cmp115 = icmp eq i32 %101, %sub114
  br i1 %cmp115, label %if.then117, label %if.end118

if.then117:                                       ; preds = %lor.lhs.false, %for.body105
  store i64 16383, ptr %last, align 8
  br label %if.end118

if.end118:                                        ; preds = %if.then117, %lor.lhs.false
  %103 = load i64, ptr %last, align 8
  %104 = load i64, ptr %first, align 8
  %cmp119 = icmp slt i64 %103, %104
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end118
  %105 = load i64, ptr %first, align 8
  store i64 %105, ptr %last, align 8
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end118
  %106 = load i32, ptr %i, align 4
  %107 = load i64, ptr %first, align 8
  %108 = load i64, ptr %last, align 8
  %call123 = call i32 (ptr, ...) @printf(ptr noundef @.str.168, i32 noundef %106, i64 noundef %107, i64 noundef %108)
  %109 = load ptr, ptr %master, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %109, i32 0, i32 13
  store i32 0, ptr %slots_count, align 4
  %110 = load i64, ptr %first, align 8
  %conv124 = trunc i64 %110 to i32
  store i32 %conv124, ptr %j, align 4
  br label %for.cond125

for.cond125:                                      ; preds = %for.inc134, %if.end122
  %111 = load i32, ptr %j, align 4
  %conv126 = sext i32 %111 to i64
  %112 = load i64, ptr %last, align 8
  %cmp127 = icmp sle i64 %conv126, %112
  br i1 %cmp127, label %for.body129, label %for.end136

for.body129:                                      ; preds = %for.cond125
  %113 = load ptr, ptr %master, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %113, i32 0, i32 12
  %114 = load i32, ptr %j, align 4
  %idxprom130 = sext i32 %114 to i64
  %arrayidx131 = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom130
  store i8 1, ptr %arrayidx131, align 1
  %115 = load ptr, ptr %master, align 8
  %slots_count132 = getelementptr inbounds %struct.clusterManagerNode, ptr %115, i32 0, i32 13
  %116 = load i32, ptr %slots_count132, align 4
  %inc133 = add nsw i32 %116, 1
  store i32 %inc133, ptr %slots_count132, align 4
  br label %for.inc134

for.inc134:                                       ; preds = %for.body129
  %117 = load i32, ptr %j, align 4
  %inc135 = add nsw i32 %117, 1
  store i32 %inc135, ptr %j, align 4
  br label %for.cond125, !llvm.loop !19

for.end136:                                       ; preds = %for.cond125
  %118 = load ptr, ptr %master, align 8
  %dirty = getelementptr inbounds %struct.clusterManagerNode, ptr %118, i32 0, i32 11
  store i32 1, ptr %dirty, align 8
  %119 = load i64, ptr %last, align 8
  %add137 = add nsw i64 %119, 1
  store i64 %add137, ptr %first, align 8
  %120 = load float, ptr %slots_per_node, align 4
  %121 = load float, ptr %cursor, align 4
  %add138 = fadd float %121, %120
  store float %add138, ptr %cursor, align 4
  br label %for.inc139

for.inc139:                                       ; preds = %for.end136
  %122 = load i32, ptr %i, align 4
  %inc140 = add nsw i32 %122, 1
  store i32 %inc140, ptr %i, align 4
  br label %for.cond102, !llvm.loop !20

for.end141:                                       ; preds = %for.cond102
  %123 = load ptr, ptr %interleaved, align 8
  %arrayidx142 = getelementptr inbounds ptr, ptr %123, i64 0
  %124 = load ptr, ptr %arrayidx142, align 8
  store ptr %124, ptr %first_node, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond143

for.cond143:                                      ; preds = %for.inc153, %for.end141
  %125 = load i32, ptr %i, align 4
  %126 = load i32, ptr %interleaved_len, align 4
  %sub144 = sub nsw i32 %126, 1
  %cmp145 = icmp slt i32 %125, %sub144
  br i1 %cmp145, label %for.body147, label %for.end155

for.body147:                                      ; preds = %for.cond143
  %127 = load ptr, ptr %interleaved, align 8
  %128 = load i32, ptr %i, align 4
  %add148 = add nsw i32 %128, 1
  %idxprom149 = sext i32 %add148 to i64
  %arrayidx150 = getelementptr inbounds ptr, ptr %127, i64 %idxprom149
  %129 = load ptr, ptr %arrayidx150, align 8
  %130 = load ptr, ptr %interleaved, align 8
  %131 = load i32, ptr %i, align 4
  %idxprom151 = sext i32 %131 to i64
  %arrayidx152 = getelementptr inbounds ptr, ptr %130, i64 %idxprom151
  store ptr %129, ptr %arrayidx152, align 8
  br label %for.inc153

for.inc153:                                       ; preds = %for.body147
  %132 = load i32, ptr %i, align 4
  %inc154 = add nsw i32 %132, 1
  store i32 %inc154, ptr %i, align 4
  br label %for.cond143, !llvm.loop !21

for.end155:                                       ; preds = %for.cond143
  %133 = load ptr, ptr %first_node, align 8
  %134 = load ptr, ptr %interleaved, align 8
  %135 = load i32, ptr %interleaved_len, align 4
  %sub156 = sub nsw i32 %135, 1
  %idxprom157 = sext i32 %sub156 to i64
  %arrayidx158 = getelementptr inbounds ptr, ptr %134, i64 %idxprom157
  store ptr %133, ptr %arrayidx158, align 8
  store i32 0, ptr %assign_unused, align 4
  %136 = load i32, ptr %interleaved_len, align 4
  store i32 %136, ptr %available_count, align 4
  br label %assign_replicas

assign_replicas:                                  ; preds = %if.then243, %for.end155
  store i32 0, ptr %i, align 4
  br label %for.cond159

for.cond159:                                      ; preds = %for.inc237, %assign_replicas
  %137 = load i32, ptr %i, align 4
  %138 = load i32, ptr %masters_count, align 4
  %cmp160 = icmp slt i32 %137, %138
  br i1 %cmp160, label %for.body162, label %for.end239

for.body162:                                      ; preds = %for.cond159
  %139 = load ptr, ptr %masters, align 8
  %140 = load i32, ptr %i, align 4
  %idxprom164 = sext i32 %140 to i64
  %arrayidx165 = getelementptr inbounds ptr, ptr %139, i64 %idxprom164
  %141 = load ptr, ptr %arrayidx165, align 8
  store ptr %141, ptr %master163, align 8
  store i32 0, ptr %assigned_replicas, align 4
  br label %while.cond166

while.cond166:                                    ; preds = %if.end235, %for.body162
  %142 = load i32, ptr %assigned_replicas, align 4
  %143 = load i32, ptr %replicas, align 4
  %cmp167 = icmp slt i32 %142, %143
  br i1 %cmp167, label %while.body169, label %while.end236

while.body169:                                    ; preds = %while.cond166
  %144 = load i32, ptr %available_count, align 4
  %cmp170 = icmp eq i32 %144, 0
  br i1 %cmp170, label %if.then172, label %if.end173

if.then172:                                       ; preds = %while.body169
  br label %while.end236

if.end173:                                        ; preds = %while.body169
  store ptr null, ptr %found174, align 8
  store ptr null, ptr %slave, align 8
  store i32 -1, ptr %firstNodeIdx, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond175

for.cond175:                                      ; preds = %for.inc198, %if.end173
  %145 = load i32, ptr %j, align 4
  %146 = load i32, ptr %interleaved_len, align 4
  %cmp176 = icmp slt i32 %145, %146
  br i1 %cmp176, label %for.body178, label %for.end200

for.body178:                                      ; preds = %for.cond175
  %147 = load ptr, ptr %interleaved, align 8
  %148 = load i32, ptr %j, align 4
  %idxprom180 = sext i32 %148 to i64
  %arrayidx181 = getelementptr inbounds ptr, ptr %147, i64 %idxprom180
  %149 = load ptr, ptr %arrayidx181, align 8
  store ptr %149, ptr %n179, align 8
  %150 = load ptr, ptr %n179, align 8
  %cmp182 = icmp eq ptr %150, null
  br i1 %cmp182, label %if.then184, label %if.end185

if.then184:                                       ; preds = %for.body178
  br label %for.inc198

if.end185:                                        ; preds = %for.body178
  %151 = load ptr, ptr %n179, align 8
  %ip186 = getelementptr inbounds %struct.clusterManagerNode, ptr %151, i32 0, i32 2
  %152 = load ptr, ptr %ip186, align 8
  %153 = load ptr, ptr %master163, align 8
  %ip187 = getelementptr inbounds %struct.clusterManagerNode, ptr %153, i32 0, i32 2
  %154 = load ptr, ptr %ip187, align 8
  %call188 = call i32 @strcmp(ptr noundef %152, ptr noundef %154) #12
  %tobool189 = icmp ne i32 %call188, 0
  br i1 %tobool189, label %if.then190, label %if.end193

if.then190:                                       ; preds = %if.end185
  %155 = load ptr, ptr %n179, align 8
  store ptr %155, ptr %found174, align 8
  %156 = load ptr, ptr %interleaved, align 8
  %157 = load i32, ptr %j, align 4
  %idxprom191 = sext i32 %157 to i64
  %arrayidx192 = getelementptr inbounds ptr, ptr %156, i64 %idxprom191
  store ptr null, ptr %arrayidx192, align 8
  br label %for.end200

if.end193:                                        ; preds = %if.end185
  %158 = load i32, ptr %firstNodeIdx, align 4
  %cmp194 = icmp slt i32 %158, 0
  br i1 %cmp194, label %if.then196, label %if.end197

if.then196:                                       ; preds = %if.end193
  %159 = load i32, ptr %j, align 4
  store i32 %159, ptr %firstNodeIdx, align 4
  br label %if.end197

if.end197:                                        ; preds = %if.then196, %if.end193
  br label %for.inc198

for.inc198:                                       ; preds = %if.end197, %if.then184
  %160 = load i32, ptr %j, align 4
  %inc199 = add nsw i32 %160, 1
  store i32 %inc199, ptr %j, align 4
  br label %for.cond175, !llvm.loop !22

for.end200:                                       ; preds = %if.then190, %for.cond175
  %161 = load ptr, ptr %found174, align 8
  %tobool201 = icmp ne ptr %161, null
  br i1 %tobool201, label %if.then202, label %if.else

if.then202:                                       ; preds = %for.end200
  %162 = load ptr, ptr %found174, align 8
  store ptr %162, ptr %slave, align 8
  br label %if.end214

if.else:                                          ; preds = %for.end200
  %163 = load i32, ptr %firstNodeIdx, align 4
  %cmp203 = icmp sge i32 %163, 0
  br i1 %cmp203, label %if.then205, label %if.end213

if.then205:                                       ; preds = %if.else
  %164 = load ptr, ptr %interleaved, align 8
  %165 = load i32, ptr %firstNodeIdx, align 4
  %idxprom206 = sext i32 %165 to i64
  %arrayidx207 = getelementptr inbounds ptr, ptr %164, i64 %idxprom206
  %166 = load ptr, ptr %arrayidx207, align 8
  store ptr %166, ptr %slave, align 8
  %167 = load i32, ptr %firstNodeIdx, align 4
  %add208 = add nsw i32 %167, 1
  %168 = load i32, ptr %interleaved_len, align 4
  %sub209 = sub nsw i32 %168, %add208
  store i32 %sub209, ptr %interleaved_len, align 4
  %169 = load i32, ptr %firstNodeIdx, align 4
  %add210 = add nsw i32 %169, 1
  %170 = load ptr, ptr %interleaved, align 8
  %idx.ext211 = sext i32 %add210 to i64
  %add.ptr212 = getelementptr inbounds ptr, ptr %170, i64 %idx.ext211
  store ptr %add.ptr212, ptr %interleaved, align 8
  br label %if.end213

if.end213:                                        ; preds = %if.then205, %if.else
  br label %if.end214

if.end214:                                        ; preds = %if.end213, %if.then202
  %171 = load ptr, ptr %slave, align 8
  %cmp215 = icmp ne ptr %171, null
  br i1 %cmp215, label %if.then217, label %if.else226

if.then217:                                       ; preds = %if.end214
  %172 = load i32, ptr %assigned_replicas, align 4
  %inc218 = add nsw i32 %172, 1
  store i32 %inc218, ptr %assigned_replicas, align 4
  %173 = load i32, ptr %available_count, align 4
  %dec = add nsw i32 %173, -1
  store i32 %dec, ptr %available_count, align 4
  %174 = load ptr, ptr %slave, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %174, i32 0, i32 10
  %175 = load ptr, ptr %replicate, align 8
  %tobool219 = icmp ne ptr %175, null
  br i1 %tobool219, label %if.then220, label %if.end222

if.then220:                                       ; preds = %if.then217
  %176 = load ptr, ptr %slave, align 8
  %replicate221 = getelementptr inbounds %struct.clusterManagerNode, ptr %176, i32 0, i32 10
  %177 = load ptr, ptr %replicate221, align 8
  call void @hi_sdsfree(ptr noundef %177)
  br label %if.end222

if.end222:                                        ; preds = %if.then220, %if.then217
  %178 = load ptr, ptr %master163, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %178, i32 0, i32 1
  %179 = load ptr, ptr %name, align 8
  %call223 = call ptr @hi_sdsnew(ptr noundef %179)
  %180 = load ptr, ptr %slave, align 8
  %replicate224 = getelementptr inbounds %struct.clusterManagerNode, ptr %180, i32 0, i32 10
  store ptr %call223, ptr %replicate224, align 8
  %181 = load ptr, ptr %slave, align 8
  %dirty225 = getelementptr inbounds %struct.clusterManagerNode, ptr %181, i32 0, i32 11
  store i32 1, ptr %dirty225, align 8
  br label %if.end227

if.else226:                                       ; preds = %if.end214
  br label %while.end236

if.end227:                                        ; preds = %if.end222
  %182 = load ptr, ptr %slave, align 8
  %ip228 = getelementptr inbounds %struct.clusterManagerNode, ptr %182, i32 0, i32 2
  %183 = load ptr, ptr %ip228, align 8
  %184 = load ptr, ptr %slave, align 8
  %port229 = getelementptr inbounds %struct.clusterManagerNode, ptr %184, i32 0, i32 3
  %185 = load i32, ptr %port229, align 8
  %186 = load ptr, ptr %master163, align 8
  %ip230 = getelementptr inbounds %struct.clusterManagerNode, ptr %186, i32 0, i32 2
  %187 = load ptr, ptr %ip230, align 8
  %188 = load ptr, ptr %master163, align 8
  %port231 = getelementptr inbounds %struct.clusterManagerNode, ptr %188, i32 0, i32 3
  %189 = load i32, ptr %port231, align 8
  %call232 = call i32 (ptr, ...) @printf(ptr noundef @.str.169, ptr noundef %183, i32 noundef %185, ptr noundef %187, i32 noundef %189)
  %190 = load i32, ptr %assign_unused, align 4
  %tobool233 = icmp ne i32 %190, 0
  br i1 %tobool233, label %if.then234, label %if.end235

if.then234:                                       ; preds = %if.end227
  br label %while.end236

if.end235:                                        ; preds = %if.end227
  br label %while.cond166, !llvm.loop !23

while.end236:                                     ; preds = %if.then234, %if.else226, %if.then172, %while.cond166
  br label %for.inc237

for.inc237:                                       ; preds = %while.end236
  %191 = load i32, ptr %i, align 4
  %inc238 = add nsw i32 %191, 1
  store i32 %inc238, ptr %i, align 4
  br label %for.cond159, !llvm.loop !24

for.end239:                                       ; preds = %for.cond159
  %192 = load i32, ptr %assign_unused, align 4
  %tobool240 = icmp ne i32 %192, 0
  br i1 %tobool240, label %if.end245, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end239
  %193 = load i32, ptr %available_count, align 4
  %cmp241 = icmp sgt i32 %193, 0
  br i1 %cmp241, label %if.then243, label %if.end245

if.then243:                                       ; preds = %land.lhs.true
  store i32 1, ptr %assign_unused, align 4
  %call244 = call i32 (ptr, ...) @printf(ptr noundef @.str.170)
  br label %assign_replicas

if.end245:                                        ; preds = %land.lhs.true, %for.end239
  store i32 0, ptr %i, align 4
  br label %for.cond246

for.cond246:                                      ; preds = %for.inc253, %if.end245
  %194 = load i32, ptr %i, align 4
  %195 = load i32, ptr %ip_count, align 4
  %cmp247 = icmp slt i32 %194, %195
  br i1 %cmp247, label %for.body249, label %for.end255

for.body249:                                      ; preds = %for.cond246
  %196 = load ptr, ptr %ip_nodes, align 8
  %197 = load i32, ptr %i, align 4
  %idx.ext251 = sext i32 %197 to i64
  %add.ptr252 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %196, i64 %idx.ext251
  store ptr %add.ptr252, ptr %node_array250, align 8
  %198 = load ptr, ptr %node_array250, align 8
  call void @clusterManagerNodeArrayReset(ptr noundef %198)
  br label %for.inc253

for.inc253:                                       ; preds = %for.body249
  %199 = load i32, ptr %i, align 4
  %inc254 = add nsw i32 %199, 1
  store i32 %inc254, ptr %i, align 4
  br label %for.cond246, !llvm.loop !25

for.end255:                                       ; preds = %for.cond246
  %200 = load ptr, ptr %ip_nodes, align 8
  %201 = load i32, ptr %ip_count, align 4
  call void @clusterManagerOptimizeAntiAffinity(ptr noundef %200, i32 noundef %201)
  call void @clusterManagerShowNodes()
  store i32 0, ptr %ignore_force, align 4
  %202 = load i32, ptr %ignore_force, align 4
  %call256 = call i32 @confirmWithYes(ptr noundef @.str.171, i32 noundef %202)
  %tobool257 = icmp ne i32 %call256, 0
  br i1 %tobool257, label %if.then258, label %if.end411

if.then258:                                       ; preds = %for.end255
  %203 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %203, ptr noundef %li)
  br label %while.cond259

while.cond259:                                    ; preds = %if.end287, %if.then258
  %call260 = call ptr @listNext(ptr noundef %li)
  store ptr %call260, ptr %ln, align 8
  %cmp261 = icmp ne ptr %call260, null
  br i1 %cmp261, label %while.body263, label %while.end288

while.body263:                                    ; preds = %while.cond259
  %204 = load ptr, ptr %ln, align 8
  %value265 = getelementptr inbounds %struct.listNode, ptr %204, i32 0, i32 2
  %205 = load ptr, ptr %value265, align 8
  store ptr %205, ptr %node264, align 8
  store ptr null, ptr %err266, align 8
  %206 = load ptr, ptr %node264, align 8
  %call267 = call i32 @clusterManagerFlushNodeConfig(ptr noundef %206, ptr noundef %err266)
  store i32 %call267, ptr %flushed, align 4
  %207 = load i32, ptr %flushed, align 4
  %tobool268 = icmp ne i32 %207, 0
  br i1 %tobool268, label %if.else282, label %land.lhs.true269

land.lhs.true269:                                 ; preds = %while.body263
  %208 = load ptr, ptr %node264, align 8
  %dirty270 = getelementptr inbounds %struct.clusterManagerNode, ptr %208, i32 0, i32 11
  %209 = load i32, ptr %dirty270, align 8
  %tobool271 = icmp ne i32 %209, 0
  br i1 %tobool271, label %land.lhs.true272, label %if.else282

land.lhs.true272:                                 ; preds = %land.lhs.true269
  %210 = load ptr, ptr %node264, align 8
  %replicate273 = getelementptr inbounds %struct.clusterManagerNode, ptr %210, i32 0, i32 10
  %211 = load ptr, ptr %replicate273, align 8
  %tobool274 = icmp ne ptr %211, null
  br i1 %tobool274, label %if.else282, label %if.then275

if.then275:                                       ; preds = %land.lhs.true272
  %212 = load ptr, ptr %err266, align 8
  %cmp276 = icmp ne ptr %212, null
  br i1 %cmp276, label %if.then278, label %if.end281

if.then278:                                       ; preds = %if.then275
  %213 = load ptr, ptr %node264, align 8
  %ip279 = getelementptr inbounds %struct.clusterManagerNode, ptr %213, i32 0, i32 2
  %214 = load ptr, ptr %ip279, align 8
  %215 = load ptr, ptr %node264, align 8
  %port280 = getelementptr inbounds %struct.clusterManagerNode, ptr %215, i32 0, i32 3
  %216 = load i32, ptr %port280, align 8
  %217 = load ptr, ptr %err266, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %214, i32 noundef %216, ptr noundef %217)
  %218 = load ptr, ptr %err266, align 8
  call void @zfree(ptr noundef %218)
  br label %if.end281

if.end281:                                        ; preds = %if.then278, %if.then275
  store i32 0, ptr %success, align 4
  br label %cleanup

if.else282:                                       ; preds = %land.lhs.true272, %land.lhs.true269, %while.body263
  %219 = load ptr, ptr %err266, align 8
  %cmp283 = icmp ne ptr %219, null
  br i1 %cmp283, label %if.then285, label %if.end286

if.then285:                                       ; preds = %if.else282
  %220 = load ptr, ptr %err266, align 8
  call void @zfree(ptr noundef %220)
  br label %if.end286

if.end286:                                        ; preds = %if.then285, %if.else282
  br label %if.end287

if.end287:                                        ; preds = %if.end286
  br label %while.cond259, !llvm.loop !26

while.end288:                                     ; preds = %while.cond259
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.172)
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.173)
  store i32 1, ptr %config_epoch, align 4
  %221 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %221, ptr noundef %li)
  br label %while.cond289

while.cond289:                                    ; preds = %if.end301, %while.end288
  %call290 = call ptr @listNext(ptr noundef %li)
  store ptr %call290, ptr %ln, align 8
  %cmp291 = icmp ne ptr %call290, null
  br i1 %cmp291, label %while.body293, label %while.end302

while.body293:                                    ; preds = %while.cond289
  %222 = load ptr, ptr %ln, align 8
  %value295 = getelementptr inbounds %struct.listNode, ptr %222, i32 0, i32 2
  %223 = load ptr, ptr %value295, align 8
  store ptr %223, ptr %node294, align 8
  store ptr null, ptr %reply, align 8
  %224 = load ptr, ptr %node294, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %224, i32 0, i32 0
  %225 = load ptr, ptr %context, align 8
  %226 = load i32, ptr %config_epoch, align 4
  %inc296 = add nsw i32 %226, 1
  store i32 %inc296, ptr %config_epoch, align 4
  %call297 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %225, ptr noundef @.str.174, i32 noundef %226)
  store ptr %call297, ptr %reply, align 8
  %227 = load ptr, ptr %reply, align 8
  %cmp298 = icmp ne ptr %227, null
  br i1 %cmp298, label %if.then300, label %if.end301

if.then300:                                       ; preds = %while.body293
  %228 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %228)
  br label %if.end301

if.end301:                                        ; preds = %if.then300, %while.body293
  br label %while.cond289, !llvm.loop !27

while.end302:                                     ; preds = %while.cond289
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.175)
  store ptr null, ptr %first303, align 8
  %229 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %229, ptr noundef %li)
  br label %while.cond304

while.cond304:                                    ; preds = %if.end358, %if.end321, %while.end302
  %call305 = call ptr @listNext(ptr noundef %li)
  store ptr %call305, ptr %ln, align 8
  %cmp306 = icmp ne ptr %call305, null
  br i1 %cmp306, label %while.body308, label %while.end359

while.body308:                                    ; preds = %while.cond304
  %230 = load ptr, ptr %ln, align 8
  %value310 = getelementptr inbounds %struct.listNode, ptr %230, i32 0, i32 2
  %231 = load ptr, ptr %value310, align 8
  store ptr %231, ptr %node309, align 8
  %232 = load ptr, ptr %first303, align 8
  %cmp311 = icmp eq ptr %232, null
  br i1 %cmp311, label %if.then313, label %if.end322

if.then313:                                       ; preds = %while.body308
  %233 = load ptr, ptr %node309, align 8
  store ptr %233, ptr %first303, align 8
  %234 = load ptr, ptr %first303, align 8
  %ip314 = getelementptr inbounds %struct.clusterManagerNode, ptr %234, i32 0, i32 2
  %235 = load ptr, ptr %ip314, align 8
  %arraydecay = getelementptr inbounds [46 x i8], ptr %first_ip, i64 0, i64 0
  %call315 = call i32 @anetResolve(ptr noundef null, ptr noundef %235, ptr noundef %arraydecay, i64 noundef 46, i32 noundef 0)
  %cmp316 = icmp eq i32 %call315, -1
  br i1 %cmp316, label %if.then318, label %if.end321

if.then318:                                       ; preds = %if.then313
  %236 = load ptr, ptr @stderr, align 8
  %237 = load ptr, ptr %first303, align 8
  %ip319 = getelementptr inbounds %struct.clusterManagerNode, ptr %237, i32 0, i32 2
  %238 = load ptr, ptr %ip319, align 8
  %call320 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %236, ptr noundef @.str.176, ptr noundef %238)
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end321:                                        ; preds = %if.then313
  br label %while.cond304, !llvm.loop !28

if.end322:                                        ; preds = %while.body308
  store ptr null, ptr %reply323, align 8
  %239 = load ptr, ptr %first303, align 8
  %bus_port = getelementptr inbounds %struct.clusterManagerNode, ptr %239, i32 0, i32 4
  %240 = load i32, ptr %bus_port, align 4
  %cmp324 = icmp eq i32 %240, 0
  br i1 %cmp324, label %if.then332, label %lor.lhs.false326

lor.lhs.false326:                                 ; preds = %if.end322
  %241 = load ptr, ptr %first303, align 8
  %bus_port327 = getelementptr inbounds %struct.clusterManagerNode, ptr %241, i32 0, i32 4
  %242 = load i32, ptr %bus_port327, align 4
  %243 = load ptr, ptr %first303, align 8
  %port328 = getelementptr inbounds %struct.clusterManagerNode, ptr %243, i32 0, i32 3
  %244 = load i32, ptr %port328, align 8
  %add329 = add nsw i32 %244, 10000
  %cmp330 = icmp eq i32 %242, %add329
  br i1 %cmp330, label %if.then332, label %if.else337

if.then332:                                       ; preds = %lor.lhs.false326, %if.end322
  %245 = load ptr, ptr %node309, align 8
  %context333 = getelementptr inbounds %struct.clusterManagerNode, ptr %245, i32 0, i32 0
  %246 = load ptr, ptr %context333, align 8
  %arraydecay334 = getelementptr inbounds [46 x i8], ptr %first_ip, i64 0, i64 0
  %247 = load ptr, ptr %first303, align 8
  %port335 = getelementptr inbounds %struct.clusterManagerNode, ptr %247, i32 0, i32 3
  %248 = load i32, ptr %port335, align 8
  %call336 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %246, ptr noundef @.str.177, ptr noundef %arraydecay334, i32 noundef %248)
  store ptr %call336, ptr %reply323, align 8
  br label %if.end343

if.else337:                                       ; preds = %lor.lhs.false326
  %249 = load ptr, ptr %node309, align 8
  %context338 = getelementptr inbounds %struct.clusterManagerNode, ptr %249, i32 0, i32 0
  %250 = load ptr, ptr %context338, align 8
  %arraydecay339 = getelementptr inbounds [46 x i8], ptr %first_ip, i64 0, i64 0
  %251 = load ptr, ptr %first303, align 8
  %port340 = getelementptr inbounds %struct.clusterManagerNode, ptr %251, i32 0, i32 3
  %252 = load i32, ptr %port340, align 8
  %253 = load ptr, ptr %first303, align 8
  %bus_port341 = getelementptr inbounds %struct.clusterManagerNode, ptr %253, i32 0, i32 4
  %254 = load i32, ptr %bus_port341, align 4
  %call342 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %250, ptr noundef @.str.178, ptr noundef %arraydecay339, i32 noundef %252, i32 noundef %254)
  store ptr %call342, ptr %reply323, align 8
  br label %if.end343

if.end343:                                        ; preds = %if.else337, %if.then332
  store i32 0, ptr %is_err, align 4
  %255 = load ptr, ptr %reply323, align 8
  %cmp344 = icmp ne ptr %255, null
  br i1 %cmp344, label %if.then346, label %if.else353

if.then346:                                       ; preds = %if.end343
  %256 = load ptr, ptr %reply323, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %256, i32 0, i32 0
  %257 = load i32, ptr %type, align 8
  %cmp347 = icmp eq i32 %257, 6
  %conv348 = zext i1 %cmp347 to i32
  store i32 %conv348, ptr %is_err, align 4
  br i1 %cmp347, label %if.then349, label %if.end352

if.then349:                                       ; preds = %if.then346
  %258 = load ptr, ptr %node309, align 8
  %ip350 = getelementptr inbounds %struct.clusterManagerNode, ptr %258, i32 0, i32 2
  %259 = load ptr, ptr %ip350, align 8
  %260 = load ptr, ptr %node309, align 8
  %port351 = getelementptr inbounds %struct.clusterManagerNode, ptr %260, i32 0, i32 3
  %261 = load i32, ptr %port351, align 8
  %262 = load ptr, ptr %reply323, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %262, i32 0, i32 4
  %263 = load ptr, ptr %str, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %259, i32 noundef %261, ptr noundef %263)
  br label %if.end352

if.end352:                                        ; preds = %if.then349, %if.then346
  %264 = load ptr, ptr %reply323, align 8
  call void @freeReplyObject(ptr noundef %264)
  br label %if.end355

if.else353:                                       ; preds = %if.end343
  store i32 1, ptr %is_err, align 4
  %265 = load ptr, ptr @stderr, align 8
  %call354 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %265, ptr noundef @.str.179)
  br label %if.end355

if.end355:                                        ; preds = %if.else353, %if.end352
  %266 = load i32, ptr %is_err, align 4
  %tobool356 = icmp ne i32 %266, 0
  br i1 %tobool356, label %if.then357, label %if.end358

if.then357:                                       ; preds = %if.end355
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end358:                                        ; preds = %if.end355
  br label %while.cond304, !llvm.loop !28

while.end359:                                     ; preds = %while.cond304
  %call360 = call i32 @sleep(i32 noundef 1)
  call void @clusterManagerWaitForClusterJoin()
  %267 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %267, ptr noundef %li)
  br label %while.cond361

while.cond361:                                    ; preds = %if.end391, %if.then370, %while.end359
  %call362 = call ptr @listNext(ptr noundef %li)
  store ptr %call362, ptr %ln, align 8
  %cmp363 = icmp ne ptr %call362, null
  br i1 %cmp363, label %while.body365, label %while.end392

while.body365:                                    ; preds = %while.cond361
  %268 = load ptr, ptr %ln, align 8
  %value367 = getelementptr inbounds %struct.listNode, ptr %268, i32 0, i32 2
  %269 = load ptr, ptr %value367, align 8
  store ptr %269, ptr %node366, align 8
  %270 = load ptr, ptr %node366, align 8
  %dirty368 = getelementptr inbounds %struct.clusterManagerNode, ptr %270, i32 0, i32 11
  %271 = load i32, ptr %dirty368, align 8
  %tobool369 = icmp ne i32 %271, 0
  br i1 %tobool369, label %if.end371, label %if.then370

if.then370:                                       ; preds = %while.body365
  br label %while.cond361, !llvm.loop !29

if.end371:                                        ; preds = %while.body365
  store ptr null, ptr %err372, align 8
  %272 = load ptr, ptr %node366, align 8
  %call374 = call i32 @clusterManagerFlushNodeConfig(ptr noundef %272, ptr noundef %err372)
  store i32 %call374, ptr %flushed373, align 4
  %273 = load i32, ptr %flushed373, align 4
  %tobool375 = icmp ne i32 %273, 0
  br i1 %tobool375, label %if.else386, label %land.lhs.true376

land.lhs.true376:                                 ; preds = %if.end371
  %274 = load ptr, ptr %node366, align 8
  %replicate377 = getelementptr inbounds %struct.clusterManagerNode, ptr %274, i32 0, i32 10
  %275 = load ptr, ptr %replicate377, align 8
  %tobool378 = icmp ne ptr %275, null
  br i1 %tobool378, label %if.else386, label %if.then379

if.then379:                                       ; preds = %land.lhs.true376
  %276 = load ptr, ptr %err372, align 8
  %cmp380 = icmp ne ptr %276, null
  br i1 %cmp380, label %if.then382, label %if.end385

if.then382:                                       ; preds = %if.then379
  %277 = load ptr, ptr %node366, align 8
  %ip383 = getelementptr inbounds %struct.clusterManagerNode, ptr %277, i32 0, i32 2
  %278 = load ptr, ptr %ip383, align 8
  %279 = load ptr, ptr %node366, align 8
  %port384 = getelementptr inbounds %struct.clusterManagerNode, ptr %279, i32 0, i32 3
  %280 = load i32, ptr %port384, align 8
  %281 = load ptr, ptr %err372, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %278, i32 noundef %280, ptr noundef %281)
  %282 = load ptr, ptr %err372, align 8
  call void @zfree(ptr noundef %282)
  br label %if.end385

if.end385:                                        ; preds = %if.then382, %if.then379
  store i32 0, ptr %success, align 4
  br label %cleanup

if.else386:                                       ; preds = %land.lhs.true376, %if.end371
  %283 = load ptr, ptr %err372, align 8
  %cmp387 = icmp ne ptr %283, null
  br i1 %cmp387, label %if.then389, label %if.end390

if.then389:                                       ; preds = %if.else386
  %284 = load ptr, ptr %err372, align 8
  call void @zfree(ptr noundef %284)
  br label %if.end390

if.end390:                                        ; preds = %if.then389, %if.else386
  br label %if.end391

if.end391:                                        ; preds = %if.end390
  br label %while.cond361, !llvm.loop !29

while.end392:                                     ; preds = %while.cond361
  %285 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %285, ptr noundef %li)
  store ptr null, ptr %first_node393, align 8
  br label %while.cond394

while.cond394:                                    ; preds = %if.end404, %while.end392
  %call395 = call ptr @listNext(ptr noundef %li)
  store ptr %call395, ptr %ln, align 8
  %cmp396 = icmp ne ptr %call395, null
  br i1 %cmp396, label %while.body398, label %while.end405

while.body398:                                    ; preds = %while.cond394
  %286 = load ptr, ptr %ln, align 8
  %value400 = getelementptr inbounds %struct.listNode, ptr %286, i32 0, i32 2
  %287 = load ptr, ptr %value400, align 8
  store ptr %287, ptr %node399, align 8
  %288 = load ptr, ptr %first_node393, align 8
  %tobool401 = icmp ne ptr %288, null
  br i1 %tobool401, label %if.else403, label %if.then402

if.then402:                                       ; preds = %while.body398
  %289 = load ptr, ptr %node399, align 8
  store ptr %289, ptr %first_node393, align 8
  br label %if.end404

if.else403:                                       ; preds = %while.body398
  %290 = load ptr, ptr %node399, align 8
  call void @freeClusterManagerNode(ptr noundef %290)
  br label %if.end404

if.end404:                                        ; preds = %if.else403, %if.then402
  br label %while.cond394, !llvm.loop !30

while.end405:                                     ; preds = %while.cond394
  %291 = load ptr, ptr @cluster_manager, align 8
  call void @listEmpty(ptr noundef %291)
  %292 = load ptr, ptr %first_node393, align 8
  %call406 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %292)
  %tobool407 = icmp ne i32 %call406, 0
  br i1 %tobool407, label %if.end409, label %if.then408

if.then408:                                       ; preds = %while.end405
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end409:                                        ; preds = %while.end405
  %call410 = call i32 @clusterManagerCheckCluster(i32 noundef 0)
  br label %if.end411

if.end411:                                        ; preds = %if.end409, %for.end255
  br label %cleanup

cleanup:                                          ; preds = %if.end411, %if.then408, %if.end385, %if.then357, %if.then318, %if.end281
  %293 = load ptr, ptr %masters, align 8
  call void @zfree(ptr noundef %293)
  %294 = load ptr, ptr %ips, align 8
  call void @zfree(ptr noundef %294)
  store i32 0, ptr %i, align 4
  br label %for.cond412

for.cond412:                                      ; preds = %for.inc419, %cleanup
  %295 = load i32, ptr %i, align 4
  %296 = load i32, ptr %node_len, align 4
  %cmp413 = icmp slt i32 %295, %296
  br i1 %cmp413, label %for.body415, label %for.end421

for.body415:                                      ; preds = %for.cond412
  %297 = load ptr, ptr %ip_nodes, align 8
  %298 = load i32, ptr %i, align 4
  %idx.ext417 = sext i32 %298 to i64
  %add.ptr418 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %297, i64 %idx.ext417
  store ptr %add.ptr418, ptr %node_array416, align 8
  %299 = load ptr, ptr %node_array416, align 8
  %alloc = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %299, i32 0, i32 1
  %300 = load ptr, ptr %alloc, align 8
  call void @zfree(ptr noundef %300)
  br label %for.inc419

for.inc419:                                       ; preds = %for.body415
  %301 = load i32, ptr %i, align 4
  %inc420 = add nsw i32 %301, 1
  store i32 %inc420, ptr %i, align 4
  br label %for.cond412, !llvm.loop !31

for.end421:                                       ; preds = %for.cond412
  %302 = load ptr, ptr %ip_nodes, align 8
  call void @zfree(ptr noundef %302)
  %303 = load i32, ptr %success, align 4
  store i32 %303, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end421, %if.then34, %if.end29, %if.end22, %if.end13, %if.then6, %if.then
  %304 = load i32, ptr %retval, align 4
  ret i32 %304
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandCheck(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %node = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  %0 = load i32, ptr %argc.addr, align 4
  %1 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef %0, ptr noundef %1, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ip, align 8
  %3 = load i32, ptr %port, align 4
  %call1 = call ptr @clusterManagerNewNode(ptr noundef %2, i32 noundef %3, i32 noundef 0)
  store ptr %call1, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %call2 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %4)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  call void @clusterManagerShowClusterInfo()
  %call6 = call i32 @clusterManagerCheckCluster(i32 noundef 0)
  store i32 %call6, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then
  %5 = load ptr, ptr @stderr, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %if.end5, %if.then4
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandInfo(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %node = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  %0 = load i32, ptr %argc.addr, align 4
  %1 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef %0, ptr noundef %1, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ip, align 8
  %3 = load i32, ptr %port, align 4
  %call1 = call ptr @clusterManagerNewNode(ptr noundef %2, i32 noundef %3, i32 noundef 0)
  store ptr %call1, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %call2 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %4)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  call void @clusterManagerShowClusterInfo()
  store i32 1, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then
  %5 = load ptr, ptr @stderr, align 8
  %call6 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %if.end5, %if.then4
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandFix(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or = or i32 %0, 1
  store i32 %or, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %1 = load i32, ptr %argc.addr, align 4
  %2 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @clusterManagerCommandCheck(i32 noundef %1, ptr noundef %2)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandReshard(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %node = alloca ptr, align 8
  %slots = alloca i32, align 4
  %buf = alloca [6 x i8], align 1
  %nread = alloca i32, align 4
  %last_idx = alloca i32, align 4
  %ch = alloca i32, align 4
  %buf42 = alloca [255 x i8], align 16
  %to = alloca ptr, align 8
  %from = alloca ptr, align 8
  %nread49 = alloca i32, align 4
  %last_idx58 = alloca i32, align 4
  %ch66 = alloca i32, align 4
  %raise_err = alloca i32, align 4
  %target = alloca ptr, align 8
  %sources = alloca ptr, align 8
  %table = alloca ptr, align 8
  %all = alloca i32, align 4
  %result = alloca i32, align 4
  %nread105 = alloca i32, align 4
  %last_idx114 = alloca i32, align 4
  %ch122 = alloca i32, align 4
  %src = alloca ptr, align 8
  %p = alloca ptr, align 8
  %src169 = alloca ptr, align 8
  %src194 = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %src240 = alloca ptr, align 8
  %info = alloca ptr, align 8
  %info246 = alloca ptr, align 8
  %buf256 = alloca [4 x i8], align 1
  %nread257 = alloca i32, align 4
  %opts = alloca i32, align 4
  %item = alloca ptr, align 8
  %err = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  %0 = load i32, ptr %argc.addr, align 4
  %1 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef %0, ptr noundef %1, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ip, align 8
  %3 = load i32, ptr %port, align 4
  %call1 = call ptr @clusterManagerNewNode(ptr noundef %2, i32 noundef %3, i32 noundef 0)
  store ptr %call1, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %call2 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %4)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @clusterManagerCheckCluster(i32 noundef 0)
  %5 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  %tobool7 = icmp ne ptr %5, null
  br i1 %tobool7, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.end5
  %6 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  %len = getelementptr inbounds %struct.list, ptr %6, i32 0, i32 5
  %7 = load i64, ptr %len, align 8
  %cmp = icmp ugt i64 %7, 0
  br i1 %cmp, label %if.then8, label %if.end11

if.then8:                                         ; preds = %land.lhs.true
  %8 = load ptr, ptr @stdout, align 8
  %call9 = call i32 @fflush(ptr noundef %8)
  %9 = load ptr, ptr @stderr, align 8
  %call10 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef @.str.361)
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %land.lhs.true, %if.end5
  %10 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 11), align 8
  store i32 %10, ptr %slots, align 4
  %11 = load i32, ptr %slots, align 4
  %tobool12 = icmp ne i32 %11, 0
  br i1 %tobool12, label %if.end41, label %if.then13

if.then13:                                        ; preds = %if.end11
  br label %while.cond

while.cond:                                       ; preds = %if.end35, %if.then22, %if.then13
  %12 = load i32, ptr %slots, align 4
  %cmp14 = icmp sle i32 %12, 0
  br i1 %cmp14, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %13 = load i32, ptr %slots, align 4
  %cmp15 = icmp sgt i32 %13, 16384
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %while.cond
  %14 = phi i1 [ true, %while.cond ], [ %cmp15, %lor.rhs ]
  br i1 %14, label %while.body, label %while.end40

while.body:                                       ; preds = %lor.end
  %call16 = call i32 (ptr, ...) @printf(ptr noundef @.str.362, i32 noundef 16384)
  %15 = load ptr, ptr @stdout, align 8
  %call17 = call i32 @fflush(ptr noundef %15)
  %16 = load ptr, ptr @stdin, align 8
  %call18 = call i32 @fileno(ptr noundef %16) #15
  %arraydecay = getelementptr inbounds [6 x i8], ptr %buf, i64 0, i64 0
  %call19 = call i64 @read(i32 noundef %call18, ptr noundef %arraydecay, i64 noundef 6)
  %conv = trunc i64 %call19 to i32
  store i32 %conv, ptr %nread, align 4
  %17 = load i32, ptr %nread, align 4
  %cmp20 = icmp sle i32 %17, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %while.body
  br label %while.cond, !llvm.loop !32

if.end23:                                         ; preds = %while.body
  %18 = load i32, ptr %nread, align 4
  %sub = sub nsw i32 %18, 1
  store i32 %sub, ptr %last_idx, align 4
  %19 = load i32, ptr %last_idx, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx = getelementptr inbounds [6 x i8], ptr %buf, i64 0, i64 %idxprom
  %20 = load i8, ptr %arrayidx, align 1
  %conv24 = sext i8 %20 to i32
  %cmp25 = icmp ne i32 %conv24, 10
  br i1 %cmp25, label %if.then27, label %if.end35

if.then27:                                        ; preds = %if.end23
  br label %while.cond28

while.cond28:                                     ; preds = %while.body34, %if.then27
  %call29 = call i32 @getchar()
  store i32 %call29, ptr %ch, align 4
  %cmp30 = icmp ne i32 %call29, 10
  br i1 %cmp30, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond28
  %21 = load i32, ptr %ch, align 4
  %cmp32 = icmp ne i32 %21, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond28
  %22 = phi i1 [ false, %while.cond28 ], [ %cmp32, %land.rhs ]
  br i1 %22, label %while.body34, label %while.end

while.body34:                                     ; preds = %land.end
  br label %while.cond28, !llvm.loop !33

while.end:                                        ; preds = %land.end
  br label %if.end35

if.end35:                                         ; preds = %while.end, %if.end23
  %23 = load i32, ptr %last_idx, align 4
  %idxprom36 = sext i32 %23 to i64
  %arrayidx37 = getelementptr inbounds [6 x i8], ptr %buf, i64 0, i64 %idxprom36
  store i8 0, ptr %arrayidx37, align 1
  %arraydecay38 = getelementptr inbounds [6 x i8], ptr %buf, i64 0, i64 0
  %call39 = call i32 @atoi(ptr noundef %arraydecay38) #12
  store i32 %call39, ptr %slots, align 4
  br label %while.cond, !llvm.loop !32

while.end40:                                      ; preds = %lor.end
  br label %if.end41

if.end41:                                         ; preds = %while.end40, %if.end11
  %24 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 7), align 8
  store ptr %24, ptr %to, align 8
  %25 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 6), align 8
  store ptr %25, ptr %from, align 8
  br label %while.cond43

while.cond43:                                     ; preds = %if.end86, %if.then56, %if.end41
  %26 = load ptr, ptr %to, align 8
  %cmp44 = icmp eq ptr %26, null
  br i1 %cmp44, label %while.body46, label %while.end87

while.body46:                                     ; preds = %while.cond43
  %call47 = call i32 (ptr, ...) @printf(ptr noundef @.str.363)
  %27 = load ptr, ptr @stdout, align 8
  %call48 = call i32 @fflush(ptr noundef %27)
  %28 = load ptr, ptr @stdin, align 8
  %call50 = call i32 @fileno(ptr noundef %28) #15
  %arraydecay51 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 0
  %call52 = call i64 @read(i32 noundef %call50, ptr noundef %arraydecay51, i64 noundef 255)
  %conv53 = trunc i64 %call52 to i32
  store i32 %conv53, ptr %nread49, align 4
  %29 = load i32, ptr %nread49, align 4
  %cmp54 = icmp sle i32 %29, 0
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %while.body46
  br label %while.cond43, !llvm.loop !34

if.end57:                                         ; preds = %while.body46
  %30 = load i32, ptr %nread49, align 4
  %sub59 = sub nsw i32 %30, 1
  store i32 %sub59, ptr %last_idx58, align 4
  %31 = load i32, ptr %last_idx58, align 4
  %idxprom60 = sext i32 %31 to i64
  %arrayidx61 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 %idxprom60
  %32 = load i8, ptr %arrayidx61, align 1
  %conv62 = sext i8 %32 to i32
  %cmp63 = icmp ne i32 %conv62, 10
  br i1 %cmp63, label %if.then65, label %if.end77

if.then65:                                        ; preds = %if.end57
  br label %while.cond67

while.cond67:                                     ; preds = %while.body75, %if.then65
  %call68 = call i32 @getchar()
  store i32 %call68, ptr %ch66, align 4
  %cmp69 = icmp ne i32 %call68, 10
  br i1 %cmp69, label %land.rhs71, label %land.end74

land.rhs71:                                       ; preds = %while.cond67
  %33 = load i32, ptr %ch66, align 4
  %cmp72 = icmp ne i32 %33, -1
  br label %land.end74

land.end74:                                       ; preds = %land.rhs71, %while.cond67
  %34 = phi i1 [ false, %while.cond67 ], [ %cmp72, %land.rhs71 ]
  br i1 %34, label %while.body75, label %while.end76

while.body75:                                     ; preds = %land.end74
  br label %while.cond67, !llvm.loop !35

while.end76:                                      ; preds = %land.end74
  br label %if.end77

if.end77:                                         ; preds = %while.end76, %if.end57
  %35 = load i32, ptr %last_idx58, align 4
  %idxprom78 = sext i32 %35 to i64
  %arrayidx79 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 %idxprom78
  store i8 0, ptr %arrayidx79, align 1
  %arraydecay80 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 0
  %call81 = call i64 @strlen(ptr noundef %arraydecay80) #12
  %cmp82 = icmp ugt i64 %call81, 0
  br i1 %cmp82, label %if.then84, label %if.end86

if.then84:                                        ; preds = %if.end77
  %arraydecay85 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 0
  store ptr %arraydecay85, ptr %to, align 8
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %if.end77
  br label %while.cond43, !llvm.loop !34

while.end87:                                      ; preds = %while.cond43
  store i32 0, ptr %raise_err, align 4
  %36 = load ptr, ptr %to, align 8
  %call88 = call ptr @clusterNodeForResharding(ptr noundef %36, ptr noundef null, ptr noundef %raise_err)
  store ptr %call88, ptr %target, align 8
  %37 = load ptr, ptr %target, align 8
  %cmp89 = icmp eq ptr %37, null
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %while.end87
  store i32 0, ptr %retval, align 4
  br label %return

if.end92:                                         ; preds = %while.end87
  %call93 = call ptr @listCreate()
  store ptr %call93, ptr %sources, align 8
  store ptr null, ptr %table, align 8
  store i32 0, ptr %all, align 4
  store i32 1, ptr %result, align 4
  %38 = load ptr, ptr %from, align 8
  %cmp94 = icmp eq ptr %38, null
  br i1 %cmp94, label %if.then96, label %if.else159

if.then96:                                        ; preds = %if.end92
  %call97 = call i32 (ptr, ...) @printf(ptr noundef @.str.364)
  %call98 = call i32 (ptr, ...) @printf(ptr noundef @.str.365)
  %call99 = call i32 (ptr, ...) @printf(ptr noundef @.str.366)
  br label %while.body101

while.body101:                                    ; preds = %if.end157, %if.then112, %if.then96
  %39 = load ptr, ptr %sources, align 8
  %len102 = getelementptr inbounds %struct.list, ptr %39, i32 0, i32 5
  %40 = load i64, ptr %len102, align 8
  %add = add i64 %40, 1
  %call103 = call i32 (ptr, ...) @printf(ptr noundef @.str.367, i64 noundef %add)
  %41 = load ptr, ptr @stdout, align 8
  %call104 = call i32 @fflush(ptr noundef %41)
  %42 = load ptr, ptr @stdin, align 8
  %call106 = call i32 @fileno(ptr noundef %42) #15
  %arraydecay107 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 0
  %call108 = call i64 @read(i32 noundef %call106, ptr noundef %arraydecay107, i64 noundef 255)
  %conv109 = trunc i64 %call108 to i32
  store i32 %conv109, ptr %nread105, align 4
  %43 = load i32, ptr %nread105, align 4
  %cmp110 = icmp sle i32 %43, 0
  br i1 %cmp110, label %if.then112, label %if.end113

if.then112:                                       ; preds = %while.body101
  br label %while.body101

if.end113:                                        ; preds = %while.body101
  %44 = load i32, ptr %nread105, align 4
  %sub115 = sub nsw i32 %44, 1
  store i32 %sub115, ptr %last_idx114, align 4
  %45 = load i32, ptr %last_idx114, align 4
  %idxprom116 = sext i32 %45 to i64
  %arrayidx117 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 %idxprom116
  %46 = load i8, ptr %arrayidx117, align 1
  %conv118 = sext i8 %46 to i32
  %cmp119 = icmp ne i32 %conv118, 10
  br i1 %cmp119, label %if.then121, label %if.end133

if.then121:                                       ; preds = %if.end113
  br label %while.cond123

while.cond123:                                    ; preds = %while.body131, %if.then121
  %call124 = call i32 @getchar()
  store i32 %call124, ptr %ch122, align 4
  %cmp125 = icmp ne i32 %call124, 10
  br i1 %cmp125, label %land.rhs127, label %land.end130

land.rhs127:                                      ; preds = %while.cond123
  %47 = load i32, ptr %ch122, align 4
  %cmp128 = icmp ne i32 %47, -1
  br label %land.end130

land.end130:                                      ; preds = %land.rhs127, %while.cond123
  %48 = phi i1 [ false, %while.cond123 ], [ %cmp128, %land.rhs127 ]
  br i1 %48, label %while.body131, label %while.end132

while.body131:                                    ; preds = %land.end130
  br label %while.cond123, !llvm.loop !36

while.end132:                                     ; preds = %land.end130
  br label %if.end133

if.end133:                                        ; preds = %while.end132, %if.end113
  %49 = load i32, ptr %last_idx114, align 4
  %idxprom134 = sext i32 %49 to i64
  %arrayidx135 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 %idxprom134
  store i8 0, ptr %arrayidx135, align 1
  %arraydecay136 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 0
  %call137 = call i32 @strcmp(ptr noundef %arraydecay136, ptr noundef @.str.368) #12
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.else, label %if.then139

if.then139:                                       ; preds = %if.end133
  br label %while.end158

if.else:                                          ; preds = %if.end133
  %arraydecay140 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 0
  %call141 = call i32 @strcmp(ptr noundef %arraydecay140, ptr noundef @.str.369) #12
  %tobool142 = icmp ne i32 %call141, 0
  br i1 %tobool142, label %if.else144, label %if.then143

if.then143:                                       ; preds = %if.else
  store i32 1, ptr %all, align 4
  br label %while.end158

if.else144:                                       ; preds = %if.else
  %arraydecay145 = getelementptr inbounds [255 x i8], ptr %buf42, i64 0, i64 0
  %50 = load ptr, ptr %target, align 8
  %call146 = call ptr @clusterNodeForResharding(ptr noundef %arraydecay145, ptr noundef %50, ptr noundef %raise_err)
  store ptr %call146, ptr %src, align 8
  %51 = load ptr, ptr %src, align 8
  %cmp147 = icmp ne ptr %51, null
  br i1 %cmp147, label %if.then149, label %if.else151

if.then149:                                       ; preds = %if.else144
  %52 = load ptr, ptr %sources, align 8
  %53 = load ptr, ptr %src, align 8
  %call150 = call ptr @listAddNodeTail(ptr noundef %52, ptr noundef %53)
  br label %if.end155

if.else151:                                       ; preds = %if.else144
  %54 = load i32, ptr %raise_err, align 4
  %tobool152 = icmp ne i32 %54, 0
  br i1 %tobool152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %if.else151
  store i32 0, ptr %result, align 4
  br label %cleanup

if.end154:                                        ; preds = %if.else151
  br label %if.end155

if.end155:                                        ; preds = %if.end154, %if.then149
  br label %if.end156

if.end156:                                        ; preds = %if.end155
  br label %if.end157

if.end157:                                        ; preds = %if.end156
  br label %while.body101

while.end158:                                     ; preds = %if.then143, %if.then139
  br label %if.end207

if.else159:                                       ; preds = %if.end92
  br label %while.cond160

while.cond160:                                    ; preds = %if.end180, %if.else159
  %55 = load ptr, ptr %from, align 8
  %call161 = call ptr @strchr(ptr noundef %55, i32 noundef 44) #12
  store ptr %call161, ptr %p, align 8
  %cmp162 = icmp ne ptr %call161, null
  br i1 %cmp162, label %while.body164, label %while.end181

while.body164:                                    ; preds = %while.cond160
  %56 = load ptr, ptr %p, align 8
  store i8 0, ptr %56, align 1
  %57 = load ptr, ptr %from, align 8
  %call165 = call i32 @strcmp(ptr noundef %57, ptr noundef @.str.369) #12
  %tobool166 = icmp ne i32 %call165, 0
  br i1 %tobool166, label %if.else168, label %if.then167

if.then167:                                       ; preds = %while.body164
  store i32 1, ptr %all, align 4
  br label %while.end181

if.else168:                                       ; preds = %while.body164
  %58 = load ptr, ptr %from, align 8
  %59 = load ptr, ptr %target, align 8
  %call170 = call ptr @clusterNodeForResharding(ptr noundef %58, ptr noundef %59, ptr noundef %raise_err)
  store ptr %call170, ptr %src169, align 8
  %60 = load ptr, ptr %src169, align 8
  %cmp171 = icmp ne ptr %60, null
  br i1 %cmp171, label %if.then173, label %if.else175

if.then173:                                       ; preds = %if.else168
  %61 = load ptr, ptr %sources, align 8
  %62 = load ptr, ptr %src169, align 8
  %call174 = call ptr @listAddNodeTail(ptr noundef %61, ptr noundef %62)
  br label %if.end179

if.else175:                                       ; preds = %if.else168
  %63 = load i32, ptr %raise_err, align 4
  %tobool176 = icmp ne i32 %63, 0
  br i1 %tobool176, label %if.then177, label %if.end178

if.then177:                                       ; preds = %if.else175
  store i32 0, ptr %result, align 4
  br label %cleanup

if.end178:                                        ; preds = %if.else175
  br label %if.end179

if.end179:                                        ; preds = %if.end178, %if.then173
  br label %if.end180

if.end180:                                        ; preds = %if.end179
  %64 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %64, i64 1
  store ptr %add.ptr, ptr %from, align 8
  br label %while.cond160, !llvm.loop !37

while.end181:                                     ; preds = %if.then167, %while.cond160
  %65 = load i32, ptr %all, align 4
  %tobool182 = icmp ne i32 %65, 0
  br i1 %tobool182, label %if.end206, label %land.lhs.true183

land.lhs.true183:                                 ; preds = %while.end181
  %66 = load ptr, ptr %from, align 8
  %call184 = call i64 @strlen(ptr noundef %66) #12
  %cmp185 = icmp ugt i64 %call184, 0
  br i1 %cmp185, label %if.then187, label %if.end206

if.then187:                                       ; preds = %land.lhs.true183
  %67 = load ptr, ptr %from, align 8
  %call188 = call i32 @strcmp(ptr noundef %67, ptr noundef @.str.369) #12
  %tobool189 = icmp ne i32 %call188, 0
  br i1 %tobool189, label %if.end191, label %if.then190

if.then190:                                       ; preds = %if.then187
  store i32 1, ptr %all, align 4
  br label %if.end191

if.end191:                                        ; preds = %if.then190, %if.then187
  %68 = load i32, ptr %all, align 4
  %tobool192 = icmp ne i32 %68, 0
  br i1 %tobool192, label %if.end205, label %if.then193

if.then193:                                       ; preds = %if.end191
  %69 = load ptr, ptr %from, align 8
  %70 = load ptr, ptr %target, align 8
  %call195 = call ptr @clusterNodeForResharding(ptr noundef %69, ptr noundef %70, ptr noundef %raise_err)
  store ptr %call195, ptr %src194, align 8
  %71 = load ptr, ptr %src194, align 8
  %cmp196 = icmp ne ptr %71, null
  br i1 %cmp196, label %if.then198, label %if.else200

if.then198:                                       ; preds = %if.then193
  %72 = load ptr, ptr %sources, align 8
  %73 = load ptr, ptr %src194, align 8
  %call199 = call ptr @listAddNodeTail(ptr noundef %72, ptr noundef %73)
  br label %if.end204

if.else200:                                       ; preds = %if.then193
  %74 = load i32, ptr %raise_err, align 4
  %tobool201 = icmp ne i32 %74, 0
  br i1 %tobool201, label %if.then202, label %if.end203

if.then202:                                       ; preds = %if.else200
  store i32 0, ptr %result, align 4
  br label %cleanup

if.end203:                                        ; preds = %if.else200
  br label %if.end204

if.end204:                                        ; preds = %if.end203, %if.then198
  br label %if.end205

if.end205:                                        ; preds = %if.end204, %if.end191
  br label %if.end206

if.end206:                                        ; preds = %if.end205, %land.lhs.true183, %while.end181
  br label %if.end207

if.end207:                                        ; preds = %if.end206, %while.end158
  %75 = load i32, ptr %all, align 4
  %tobool208 = icmp ne i32 %75, 0
  br i1 %tobool208, label %if.then209, label %if.end226

if.then209:                                       ; preds = %if.end207
  %76 = load ptr, ptr %sources, align 8
  call void @listEmpty(ptr noundef %76)
  %77 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %77, ptr noundef %li)
  br label %while.cond210

while.cond210:                                    ; preds = %if.end223, %if.then222, %if.then217, %if.then209
  %call211 = call ptr @listNext(ptr noundef %li)
  store ptr %call211, ptr %ln, align 8
  %cmp212 = icmp ne ptr %call211, null
  br i1 %cmp212, label %while.body214, label %while.end225

while.body214:                                    ; preds = %while.cond210
  %78 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %78, i32 0, i32 2
  %79 = load ptr, ptr %value, align 8
  store ptr %79, ptr %n, align 8
  %80 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %80, i32 0, i32 8
  %81 = load i32, ptr %flags, align 8
  %and = and i32 %81, 2
  %tobool215 = icmp ne i32 %and, 0
  br i1 %tobool215, label %if.then217, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body214
  %82 = load ptr, ptr %n, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %82, i32 0, i32 10
  %83 = load ptr, ptr %replicate, align 8
  %tobool216 = icmp ne ptr %83, null
  br i1 %tobool216, label %if.then217, label %if.end218

if.then217:                                       ; preds = %lor.lhs.false, %while.body214
  br label %while.cond210, !llvm.loop !38

if.end218:                                        ; preds = %lor.lhs.false
  %84 = load ptr, ptr %n, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %84, i32 0, i32 1
  %85 = load ptr, ptr %name, align 8
  %86 = load ptr, ptr %target, align 8
  %name219 = getelementptr inbounds %struct.clusterManagerNode, ptr %86, i32 0, i32 1
  %87 = load ptr, ptr %name219, align 8
  %call220 = call i32 @hi_sdscmp(ptr noundef %85, ptr noundef %87)
  %tobool221 = icmp ne i32 %call220, 0
  br i1 %tobool221, label %if.end223, label %if.then222

if.then222:                                       ; preds = %if.end218
  br label %while.cond210, !llvm.loop !38

if.end223:                                        ; preds = %if.end218
  %88 = load ptr, ptr %sources, align 8
  %89 = load ptr, ptr %n, align 8
  %call224 = call ptr @listAddNodeTail(ptr noundef %88, ptr noundef %89)
  br label %while.cond210, !llvm.loop !38

while.end225:                                     ; preds = %while.cond210
  br label %if.end226

if.end226:                                        ; preds = %while.end225, %if.end207
  %90 = load ptr, ptr %sources, align 8
  %len227 = getelementptr inbounds %struct.list, ptr %90, i32 0, i32 5
  %91 = load i64, ptr %len227, align 8
  %cmp228 = icmp eq i64 %91, 0
  br i1 %cmp228, label %if.then230, label %if.end232

if.then230:                                       ; preds = %if.end226
  %92 = load ptr, ptr @stderr, align 8
  %call231 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %92, ptr noundef @.str.370)
  store i32 0, ptr %result, align 4
  br label %cleanup

if.end232:                                        ; preds = %if.end226
  %93 = load i32, ptr %slots, align 4
  %call233 = call i32 (ptr, ...) @printf(ptr noundef @.str.371, i32 noundef %93)
  %call234 = call i32 (ptr, ...) @printf(ptr noundef @.str.372)
  %94 = load ptr, ptr %sources, align 8
  call void @listRewind(ptr noundef %94, ptr noundef %li)
  br label %while.cond235

while.cond235:                                    ; preds = %while.body239, %if.end232
  %call236 = call ptr @listNext(ptr noundef %li)
  store ptr %call236, ptr %ln, align 8
  %cmp237 = icmp ne ptr %call236, null
  br i1 %cmp237, label %while.body239, label %while.end244

while.body239:                                    ; preds = %while.cond235
  %95 = load ptr, ptr %ln, align 8
  %value241 = getelementptr inbounds %struct.listNode, ptr %95, i32 0, i32 2
  %96 = load ptr, ptr %value241, align 8
  store ptr %96, ptr %src240, align 8
  %97 = load ptr, ptr %src240, align 8
  %call242 = call ptr @clusterManagerNodeInfo(ptr noundef %97, i32 noundef 4)
  store ptr %call242, ptr %info, align 8
  %98 = load ptr, ptr %info, align 8
  %call243 = call i32 (ptr, ...) @printf(ptr noundef @.str.115, ptr noundef %98)
  %99 = load ptr, ptr %info, align 8
  call void @hi_sdsfree(ptr noundef %99)
  br label %while.cond235, !llvm.loop !39

while.end244:                                     ; preds = %while.cond235
  %call245 = call i32 (ptr, ...) @printf(ptr noundef @.str.373)
  %100 = load ptr, ptr %target, align 8
  %call247 = call ptr @clusterManagerNodeInfo(ptr noundef %100, i32 noundef 4)
  store ptr %call247, ptr %info246, align 8
  %101 = load ptr, ptr %info246, align 8
  %call248 = call i32 (ptr, ...) @printf(ptr noundef @.str.115, ptr noundef %101)
  %102 = load ptr, ptr %info246, align 8
  call void @hi_sdsfree(ptr noundef %102)
  %103 = load ptr, ptr %sources, align 8
  %104 = load i32, ptr %slots, align 4
  %call249 = call ptr @clusterManagerComputeReshardTable(ptr noundef %103, i32 noundef %104)
  store ptr %call249, ptr %table, align 8
  %call250 = call i32 (ptr, ...) @printf(ptr noundef @.str.374)
  %105 = load ptr, ptr %table, align 8
  call void @clusterManagerShowReshardTable(ptr noundef %105)
  %106 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and251 = and i32 %106, 4
  %tobool252 = icmp ne i32 %and251, 0
  br i1 %tobool252, label %if.end272, label %if.then253

if.then253:                                       ; preds = %while.end244
  %call254 = call i32 (ptr, ...) @printf(ptr noundef @.str.375)
  %107 = load ptr, ptr @stdout, align 8
  %call255 = call i32 @fflush(ptr noundef %107)
  %108 = load ptr, ptr @stdin, align 8
  %call258 = call i32 @fileno(ptr noundef %108) #15
  %arraydecay259 = getelementptr inbounds [4 x i8], ptr %buf256, i64 0, i64 0
  %call260 = call i64 @read(i32 noundef %call258, ptr noundef %arraydecay259, i64 noundef 4)
  %conv261 = trunc i64 %call260 to i32
  store i32 %conv261, ptr %nread257, align 4
  %arrayidx262 = getelementptr inbounds [4 x i8], ptr %buf256, i64 0, i64 3
  store i8 0, ptr %arrayidx262, align 1
  %109 = load i32, ptr %nread257, align 4
  %cmp263 = icmp sle i32 %109, 0
  br i1 %cmp263, label %if.then270, label %lor.lhs.false265

lor.lhs.false265:                                 ; preds = %if.then253
  %arraydecay266 = getelementptr inbounds [4 x i8], ptr %buf256, i64 0, i64 0
  %call267 = call i32 @strcmp(ptr noundef @.str.225, ptr noundef %arraydecay266) #12
  %cmp268 = icmp ne i32 %call267, 0
  br i1 %cmp268, label %if.then270, label %if.end271

if.then270:                                       ; preds = %lor.lhs.false265, %if.then253
  store i32 0, ptr %result, align 4
  br label %cleanup

if.end271:                                        ; preds = %lor.lhs.false265
  br label %if.end272

if.end272:                                        ; preds = %if.end271, %while.end244
  store i32 128, ptr %opts, align 4
  %110 = load ptr, ptr %table, align 8
  call void @listRewind(ptr noundef %110, ptr noundef %li)
  br label %while.cond273

while.cond273:                                    ; preds = %if.end286, %if.end272
  %call274 = call ptr @listNext(ptr noundef %li)
  store ptr %call274, ptr %ln, align 8
  %cmp275 = icmp ne ptr %call274, null
  br i1 %cmp275, label %while.body277, label %while.end287

while.body277:                                    ; preds = %while.cond273
  %111 = load ptr, ptr %ln, align 8
  %value278 = getelementptr inbounds %struct.listNode, ptr %111, i32 0, i32 2
  %112 = load ptr, ptr %value278, align 8
  store ptr %112, ptr %item, align 8
  store ptr null, ptr %err, align 8
  %113 = load ptr, ptr %item, align 8
  %source = getelementptr inbounds %struct.clusterManagerReshardTableItem, ptr %113, i32 0, i32 0
  %114 = load ptr, ptr %source, align 8
  %115 = load ptr, ptr %target, align 8
  %116 = load ptr, ptr %item, align 8
  %slot = getelementptr inbounds %struct.clusterManagerReshardTableItem, ptr %116, i32 0, i32 1
  %117 = load i32, ptr %slot, align 8
  %118 = load i32, ptr %opts, align 4
  %call279 = call i32 @clusterManagerMoveSlot(ptr noundef %114, ptr noundef %115, i32 noundef %117, i32 noundef %118, ptr noundef %err)
  store i32 %call279, ptr %result, align 4
  %119 = load i32, ptr %result, align 4
  %tobool280 = icmp ne i32 %119, 0
  br i1 %tobool280, label %if.end286, label %if.then281

if.then281:                                       ; preds = %while.body277
  %120 = load ptr, ptr %err, align 8
  %cmp282 = icmp ne ptr %120, null
  br i1 %cmp282, label %if.then284, label %if.end285

if.then284:                                       ; preds = %if.then281
  %121 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.376, ptr noundef %121)
  %122 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %122)
  br label %if.end285

if.end285:                                        ; preds = %if.then284, %if.then281
  br label %cleanup

if.end286:                                        ; preds = %while.body277
  br label %while.cond273, !llvm.loop !40

while.end287:                                     ; preds = %while.cond273
  br label %cleanup

cleanup:                                          ; preds = %while.end287, %if.end285, %if.then270, %if.then230, %if.then202, %if.then177, %if.then153
  %123 = load ptr, ptr %sources, align 8
  call void @listRelease(ptr noundef %123)
  %124 = load ptr, ptr %table, align 8
  call void @clusterManagerReleaseReshardTable(ptr noundef %124)
  %125 = load i32, ptr %result, align 4
  store i32 %125, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then
  %126 = load ptr, ptr @stderr, align 8
  %call288 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %126, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %cleanup, %if.then91, %if.then8, %if.then4
  %127 = load i32, ptr %retval, align 4
  ret i32 %127
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandRebalance(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %weightedNodes = alloca ptr, align 8
  %involved = alloca ptr, align 8
  %node = alloca ptr, align 8
  %result = alloca i32, align 4
  %i = alloca i32, align 4
  %name = alloca ptr, align 8
  %p = alloca ptr, align 8
  %w = alloca float, align 4
  %n = alloca ptr, align 8
  %total_weight = alloca float, align 4
  %nodes_involved = alloca i32, align 4
  %use_empty = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n23 = alloca ptr, align 8
  %threshold_reached = alloca i32, align 4
  %total_balance = alloca i32, align 4
  %threshold = alloca float, align 4
  %n56 = alloca ptr, align 8
  %expected = alloca i32, align 4
  %over_threshold = alloca i32, align 4
  %err_perc = alloca float, align 4
  %n108 = alloca ptr, align 8
  %n130 = alloca ptr, align 8
  %dst_idx = alloca i32, align 4
  %src_idx = alloca i32, align 4
  %simulate = alloca i32, align 4
  %dst = alloca ptr, align 8
  %src = alloca ptr, align 8
  %db = alloca i32, align 4
  %sb = alloca i32, align 4
  %numslots = alloca i32, align 4
  %lsrc = alloca ptr, align 8
  %table = alloca ptr, align 8
  %table_len = alloca i32, align 4
  %opts = alloca i32, align 4
  %item = alloca ptr, align 8
  %err = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  store ptr null, ptr %weightedNodes, align 8
  store ptr null, ptr %involved, align 8
  %0 = load i32, ptr %argc.addr, align 4
  %1 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef %0, ptr noundef %1, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %ip, align 8
  %3 = load i32, ptr %port, align 4
  %call1 = call ptr @clusterManagerNewNode(ptr noundef %2, i32 noundef %3, i32 noundef 0)
  store ptr %call1, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %call2 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %4)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  store i32 1, ptr %result, align 4
  %5 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 8), align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %if.then6, label %if.end18

if.then6:                                         ; preds = %if.end5
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then6
  %6 = load i32, ptr %i, align 4
  %7 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 9), align 8
  %cmp7 = icmp slt i32 %6, %7
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 8), align 8
  %9 = load i32, ptr %i, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %8, i64 %idxprom
  %10 = load ptr, ptr %arrayidx, align 8
  store ptr %10, ptr %name, align 8
  %11 = load ptr, ptr %name, align 8
  %call8 = call ptr @strchr(ptr noundef %11, i32 noundef 61) #12
  store ptr %call8, ptr %p, align 8
  %12 = load ptr, ptr %p, align 8
  %cmp9 = icmp eq ptr %12, null
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %for.body
  %13 = load ptr, ptr %name, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.380, ptr noundef %13)
  store i32 0, ptr %result, align 4
  br label %cleanup

if.end11:                                         ; preds = %for.body
  %14 = load ptr, ptr %p, align 8
  store i8 0, ptr %14, align 1
  %15 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %15, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  %call12 = call double @atof(ptr noundef %incdec.ptr) #12
  %conv = fptrunc double %call12 to float
  store float %conv, ptr %w, align 4
  %16 = load ptr, ptr %name, align 8
  %call13 = call ptr @clusterManagerNodeByAbbreviatedName(ptr noundef %16)
  store ptr %call13, ptr %n, align 8
  %17 = load ptr, ptr %n, align 8
  %cmp14 = icmp eq ptr %17, null
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end11
  %18 = load ptr, ptr %name, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.381, ptr noundef %18)
  store i32 0, ptr %result, align 4
  br label %cleanup

if.end17:                                         ; preds = %if.end11
  %19 = load float, ptr %w, align 4
  %20 = load ptr, ptr %n, align 8
  %weight = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 20
  store float %19, ptr %weight, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %21 = load i32, ptr %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %for.cond
  br label %if.end18

if.end18:                                         ; preds = %for.end, %if.end5
  store float 0.000000e+00, ptr %total_weight, align 4
  store i32 0, ptr %nodes_involved, align 4
  %22 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %22, 16
  store i32 %and, ptr %use_empty, align 4
  %call19 = call ptr @listCreate()
  store ptr %call19, ptr %involved, align 8
  %23 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %23, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end34, %if.then32, %if.then27, %if.end18
  %call20 = call ptr @listNext(ptr noundef %li)
  store ptr %call20, ptr %ln, align 8
  %cmp21 = icmp ne ptr %call20, null
  br i1 %cmp21, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %24 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %value, align 8
  store ptr %25, ptr %n23, align 8
  %26 = load ptr, ptr %n23, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 8
  %27 = load i32, ptr %flags, align 8
  %and24 = and i32 %27, 2
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %28 = load ptr, ptr %n23, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %28, i32 0, i32 10
  %29 = load ptr, ptr %replicate, align 8
  %tobool26 = icmp ne ptr %29, null
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %lor.lhs.false, %while.body
  br label %while.cond, !llvm.loop !42

if.end28:                                         ; preds = %lor.lhs.false
  %30 = load i32, ptr %use_empty, align 4
  %tobool29 = icmp ne i32 %30, 0
  br i1 %tobool29, label %if.end34, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end28
  %31 = load ptr, ptr %n23, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %31, i32 0, i32 13
  %32 = load i32, ptr %slots_count, align 4
  %cmp30 = icmp eq i32 %32, 0
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %land.lhs.true
  %33 = load ptr, ptr %n23, align 8
  %weight33 = getelementptr inbounds %struct.clusterManagerNode, ptr %33, i32 0, i32 20
  store float 0.000000e+00, ptr %weight33, align 8
  br label %while.cond, !llvm.loop !42

if.end34:                                         ; preds = %land.lhs.true, %if.end28
  %34 = load ptr, ptr %n23, align 8
  %weight35 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 20
  %35 = load float, ptr %weight35, align 8
  %36 = load float, ptr %total_weight, align 4
  %add = fadd float %36, %35
  store float %add, ptr %total_weight, align 4
  %37 = load i32, ptr %nodes_involved, align 4
  %inc36 = add nsw i32 %37, 1
  store i32 %inc36, ptr %nodes_involved, align 4
  %38 = load ptr, ptr %involved, align 8
  %39 = load ptr, ptr %n23, align 8
  %call37 = call ptr @listAddNodeTail(ptr noundef %38, ptr noundef %39)
  br label %while.cond, !llvm.loop !42

while.end:                                        ; preds = %while.cond
  %40 = load i32, ptr %nodes_involved, align 4
  %conv38 = sext i32 %40 to i64
  %mul = mul i64 %conv38, 8
  %call39 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call39, ptr %weightedNodes, align 8
  %41 = load ptr, ptr %weightedNodes, align 8
  %cmp40 = icmp eq ptr %41, null
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %while.end
  br label %cleanup

if.end43:                                         ; preds = %while.end
  %call44 = call i32 @clusterManagerCheckCluster(i32 noundef 1)
  %42 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  %tobool45 = icmp ne ptr %42, null
  br i1 %tobool45, label %land.lhs.true46, label %if.end50

land.lhs.true46:                                  ; preds = %if.end43
  %43 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  %len = getelementptr inbounds %struct.list, ptr %43, i32 0, i32 5
  %44 = load i64, ptr %len, align 8
  %cmp47 = icmp ugt i64 %44, 0
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %land.lhs.true46
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.382)
  store i32 0, ptr %result, align 4
  br label %cleanup

if.end50:                                         ; preds = %land.lhs.true46, %if.end43
  store i32 0, ptr %threshold_reached, align 4
  store i32 0, ptr %total_balance, align 4
  %45 = load float, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 14), align 4
  store float %45, ptr %threshold, align 4
  store i32 0, ptr %i, align 4
  %46 = load ptr, ptr %involved, align 8
  call void @listRewind(ptr noundef %46, ptr noundef %li)
  br label %while.cond51

while.cond51:                                     ; preds = %if.end93, %if.end50
  %call52 = call ptr @listNext(ptr noundef %li)
  store ptr %call52, ptr %ln, align 8
  %cmp53 = icmp ne ptr %call52, null
  br i1 %cmp53, label %while.body55, label %while.end94

while.body55:                                     ; preds = %while.cond51
  %47 = load ptr, ptr %ln, align 8
  %value57 = getelementptr inbounds %struct.listNode, ptr %47, i32 0, i32 2
  %48 = load ptr, ptr %value57, align 8
  store ptr %48, ptr %n56, align 8
  %49 = load ptr, ptr %n56, align 8
  %50 = load ptr, ptr %weightedNodes, align 8
  %51 = load i32, ptr %i, align 4
  %inc58 = add nsw i32 %51, 1
  store i32 %inc58, ptr %i, align 4
  %idxprom59 = sext i32 %51 to i64
  %arrayidx60 = getelementptr inbounds ptr, ptr %50, i64 %idxprom59
  store ptr %49, ptr %arrayidx60, align 8
  %52 = load float, ptr %total_weight, align 4
  %div = fdiv float 1.638400e+04, %52
  %53 = load ptr, ptr %n56, align 8
  %weight61 = getelementptr inbounds %struct.clusterManagerNode, ptr %53, i32 0, i32 20
  %54 = load float, ptr %weight61, align 8
  %mul62 = fmul float %div, %54
  %conv63 = fptosi float %mul62 to i32
  store i32 %conv63, ptr %expected, align 4
  %55 = load ptr, ptr %n56, align 8
  %slots_count64 = getelementptr inbounds %struct.clusterManagerNode, ptr %55, i32 0, i32 13
  %56 = load i32, ptr %slots_count64, align 4
  %57 = load i32, ptr %expected, align 4
  %sub = sub nsw i32 %56, %57
  %58 = load ptr, ptr %n56, align 8
  %balance = getelementptr inbounds %struct.clusterManagerNode, ptr %58, i32 0, i32 21
  store i32 %sub, ptr %balance, align 4
  %59 = load ptr, ptr %n56, align 8
  %balance65 = getelementptr inbounds %struct.clusterManagerNode, ptr %59, i32 0, i32 21
  %60 = load i32, ptr %balance65, align 4
  %61 = load i32, ptr %total_balance, align 4
  %add66 = add nsw i32 %61, %60
  store i32 %add66, ptr %total_balance, align 4
  store i32 0, ptr %over_threshold, align 4
  %62 = load float, ptr %threshold, align 4
  %cmp67 = fcmp ogt float %62, 0.000000e+00
  br i1 %cmp67, label %if.then69, label %if.end90

if.then69:                                        ; preds = %while.body55
  %63 = load ptr, ptr %n56, align 8
  %slots_count70 = getelementptr inbounds %struct.clusterManagerNode, ptr %63, i32 0, i32 13
  %64 = load i32, ptr %slots_count70, align 4
  %cmp71 = icmp sgt i32 %64, 0
  br i1 %cmp71, label %if.then73, label %if.else

if.then73:                                        ; preds = %if.then69
  %65 = load i32, ptr %expected, align 4
  %conv74 = sitofp i32 %65 to double
  %mul75 = fmul double 1.000000e+02, %conv74
  %66 = load ptr, ptr %n56, align 8
  %slots_count76 = getelementptr inbounds %struct.clusterManagerNode, ptr %66, i32 0, i32 13
  %67 = load i32, ptr %slots_count76, align 4
  %conv77 = sitofp i32 %67 to double
  %div78 = fdiv double %mul75, %conv77
  %sub79 = fsub double 1.000000e+02, %div78
  %68 = call double @llvm.fabs.f64(double %sub79)
  %conv80 = fptrunc double %68 to float
  store float %conv80, ptr %err_perc, align 4
  %69 = load float, ptr %err_perc, align 4
  %70 = load float, ptr %threshold, align 4
  %cmp81 = fcmp ogt float %69, %70
  br i1 %cmp81, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.then73
  store i32 1, ptr %over_threshold, align 4
  br label %if.end84

if.end84:                                         ; preds = %if.then83, %if.then73
  br label %if.end89

if.else:                                          ; preds = %if.then69
  %71 = load i32, ptr %expected, align 4
  %cmp85 = icmp sgt i32 %71, 1
  br i1 %cmp85, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.else
  store i32 1, ptr %over_threshold, align 4
  br label %if.end88

if.end88:                                         ; preds = %if.then87, %if.else
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %if.end84
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %while.body55
  %72 = load i32, ptr %over_threshold, align 4
  %tobool91 = icmp ne i32 %72, 0
  br i1 %tobool91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.end90
  store i32 1, ptr %threshold_reached, align 4
  br label %if.end93

if.end93:                                         ; preds = %if.then92, %if.end90
  br label %while.cond51, !llvm.loop !43

while.end94:                                      ; preds = %while.cond51
  %73 = load i32, ptr %threshold_reached, align 4
  %tobool95 = icmp ne i32 %73, 0
  br i1 %tobool95, label %if.end98, label %if.then96

if.then96:                                        ; preds = %while.end94
  %74 = load float, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 14), align 4
  %conv97 = fpext float %74 to double
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.383, double noundef %conv97)
  br label %cleanup

if.end98:                                         ; preds = %while.end94
  br label %while.cond99

while.cond99:                                     ; preds = %while.end120, %if.end98
  %75 = load i32, ptr %total_balance, align 4
  %cmp100 = icmp sgt i32 %75, 0
  br i1 %cmp100, label %while.body102, label %while.end121

while.body102:                                    ; preds = %while.cond99
  %76 = load ptr, ptr %involved, align 8
  call void @listRewind(ptr noundef %76, ptr noundef %li)
  br label %while.cond103

while.cond103:                                    ; preds = %if.end119, %while.body102
  %call104 = call ptr @listNext(ptr noundef %li)
  store ptr %call104, ptr %ln, align 8
  %cmp105 = icmp ne ptr %call104, null
  br i1 %cmp105, label %while.body107, label %while.end120

while.body107:                                    ; preds = %while.cond103
  %77 = load ptr, ptr %ln, align 8
  %value109 = getelementptr inbounds %struct.listNode, ptr %77, i32 0, i32 2
  %78 = load ptr, ptr %value109, align 8
  store ptr %78, ptr %n108, align 8
  %79 = load ptr, ptr %n108, align 8
  %balance110 = getelementptr inbounds %struct.clusterManagerNode, ptr %79, i32 0, i32 21
  %80 = load i32, ptr %balance110, align 4
  %cmp111 = icmp sle i32 %80, 0
  br i1 %cmp111, label %land.lhs.true113, label %if.end119

land.lhs.true113:                                 ; preds = %while.body107
  %81 = load i32, ptr %total_balance, align 4
  %cmp114 = icmp sgt i32 %81, 0
  br i1 %cmp114, label %if.then116, label %if.end119

if.then116:                                       ; preds = %land.lhs.true113
  %82 = load ptr, ptr %n108, align 8
  %balance117 = getelementptr inbounds %struct.clusterManagerNode, ptr %82, i32 0, i32 21
  %83 = load i32, ptr %balance117, align 4
  %dec = add nsw i32 %83, -1
  store i32 %dec, ptr %balance117, align 4
  %84 = load i32, ptr %total_balance, align 4
  %dec118 = add nsw i32 %84, -1
  store i32 %dec118, ptr %total_balance, align 4
  br label %if.end119

if.end119:                                        ; preds = %if.then116, %land.lhs.true113, %while.body107
  br label %while.cond103, !llvm.loop !44

while.end120:                                     ; preds = %while.cond103
  br label %while.cond99, !llvm.loop !45

while.end121:                                     ; preds = %while.cond99
  %85 = load ptr, ptr %weightedNodes, align 8
  %86 = load i32, ptr %nodes_involved, align 4
  %conv122 = sext i32 %86 to i64
  call void @qsort(ptr noundef %85, i64 noundef %conv122, i64 noundef 8, ptr noundef @clusterManagerCompareNodeBalance)
  %87 = load i32, ptr %nodes_involved, align 4
  %88 = load float, ptr %total_weight, align 4
  %conv123 = fpext float %88 to double
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.384, i32 noundef %87, double noundef %conv123)
  %89 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 53), align 8
  %tobool124 = icmp ne i32 %89, 0
  br i1 %tobool124, label %if.then125, label %if.end140

if.then125:                                       ; preds = %while.end121
  store i32 0, ptr %i, align 4
  br label %for.cond126

for.cond126:                                      ; preds = %for.inc137, %if.then125
  %90 = load i32, ptr %i, align 4
  %91 = load i32, ptr %nodes_involved, align 4
  %cmp127 = icmp slt i32 %90, %91
  br i1 %cmp127, label %for.body129, label %for.end139

for.body129:                                      ; preds = %for.cond126
  %92 = load ptr, ptr %weightedNodes, align 8
  %93 = load i32, ptr %i, align 4
  %idxprom131 = sext i32 %93 to i64
  %arrayidx132 = getelementptr inbounds ptr, ptr %92, i64 %idxprom131
  %94 = load ptr, ptr %arrayidx132, align 8
  store ptr %94, ptr %n130, align 8
  %95 = load ptr, ptr %n130, align 8
  %ip133 = getelementptr inbounds %struct.clusterManagerNode, ptr %95, i32 0, i32 2
  %96 = load ptr, ptr %ip133, align 8
  %97 = load ptr, ptr %n130, align 8
  %port134 = getelementptr inbounds %struct.clusterManagerNode, ptr %97, i32 0, i32 3
  %98 = load i32, ptr %port134, align 8
  %99 = load ptr, ptr %n130, align 8
  %balance135 = getelementptr inbounds %struct.clusterManagerNode, ptr %99, i32 0, i32 21
  %100 = load i32, ptr %balance135, align 4
  %call136 = call i32 (ptr, ...) @printf(ptr noundef @.str.385, ptr noundef %96, i32 noundef %98, i32 noundef %100)
  br label %for.inc137

for.inc137:                                       ; preds = %for.body129
  %101 = load i32, ptr %i, align 4
  %inc138 = add nsw i32 %101, 1
  store i32 %inc138, ptr %i, align 4
  br label %for.cond126, !llvm.loop !46

for.end139:                                       ; preds = %for.cond126
  br label %if.end140

if.end140:                                        ; preds = %for.end139, %while.end121
  store i32 0, ptr %dst_idx, align 4
  %102 = load i32, ptr %nodes_involved, align 4
  %sub141 = sub nsw i32 %102, 1
  store i32 %sub141, ptr %src_idx, align 4
  %103 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and142 = and i32 %103, 32
  store i32 %and142, ptr %simulate, align 4
  br label %while.cond143

while.cond143:                                    ; preds = %if.end219, %if.end140
  %104 = load i32, ptr %dst_idx, align 4
  %105 = load i32, ptr %src_idx, align 4
  %cmp144 = icmp slt i32 %104, %105
  br i1 %cmp144, label %while.body146, label %while.end220

while.body146:                                    ; preds = %while.cond143
  %106 = load ptr, ptr %weightedNodes, align 8
  %107 = load i32, ptr %dst_idx, align 4
  %idxprom147 = sext i32 %107 to i64
  %arrayidx148 = getelementptr inbounds ptr, ptr %106, i64 %idxprom147
  %108 = load ptr, ptr %arrayidx148, align 8
  store ptr %108, ptr %dst, align 8
  %109 = load ptr, ptr %weightedNodes, align 8
  %110 = load i32, ptr %src_idx, align 4
  %idxprom149 = sext i32 %110 to i64
  %arrayidx150 = getelementptr inbounds ptr, ptr %109, i64 %idxprom149
  %111 = load ptr, ptr %arrayidx150, align 8
  store ptr %111, ptr %src, align 8
  %112 = load ptr, ptr %dst, align 8
  %balance151 = getelementptr inbounds %struct.clusterManagerNode, ptr %112, i32 0, i32 21
  %113 = load i32, ptr %balance151, align 4
  %114 = call i32 @llvm.abs.i32(i32 %113, i1 true)
  store i32 %114, ptr %db, align 4
  %115 = load ptr, ptr %src, align 8
  %balance152 = getelementptr inbounds %struct.clusterManagerNode, ptr %115, i32 0, i32 21
  %116 = load i32, ptr %balance152, align 4
  %117 = call i32 @llvm.abs.i32(i32 %116, i1 true)
  store i32 %117, ptr %sb, align 4
  %118 = load i32, ptr %db, align 4
  %119 = load i32, ptr %sb, align 4
  %cmp153 = icmp slt i32 %118, %119
  br i1 %cmp153, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body146
  %120 = load i32, ptr %db, align 4
  br label %cond.end

cond.false:                                       ; preds = %while.body146
  %121 = load i32, ptr %sb, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %120, %cond.true ], [ %121, %cond.false ]
  store i32 %cond, ptr %numslots, align 4
  %122 = load i32, ptr %numslots, align 4
  %cmp155 = icmp sgt i32 %122, 0
  br i1 %cmp155, label %if.then157, label %if.end203

if.then157:                                       ; preds = %cond.end
  %123 = load i32, ptr %numslots, align 4
  %124 = load ptr, ptr %src, align 8
  %ip158 = getelementptr inbounds %struct.clusterManagerNode, ptr %124, i32 0, i32 2
  %125 = load ptr, ptr %ip158, align 8
  %126 = load ptr, ptr %src, align 8
  %port159 = getelementptr inbounds %struct.clusterManagerNode, ptr %126, i32 0, i32 3
  %127 = load i32, ptr %port159, align 8
  %128 = load ptr, ptr %dst, align 8
  %ip160 = getelementptr inbounds %struct.clusterManagerNode, ptr %128, i32 0, i32 2
  %129 = load ptr, ptr %ip160, align 8
  %130 = load ptr, ptr %dst, align 8
  %port161 = getelementptr inbounds %struct.clusterManagerNode, ptr %130, i32 0, i32 3
  %131 = load i32, ptr %port161, align 8
  %call162 = call i32 (ptr, ...) @printf(ptr noundef @.str.386, i32 noundef %123, ptr noundef %125, i32 noundef %127, ptr noundef %129, i32 noundef %131)
  %call163 = call ptr @listCreate()
  store ptr %call163, ptr %lsrc, align 8
  store ptr null, ptr %table, align 8
  %132 = load ptr, ptr %lsrc, align 8
  %133 = load ptr, ptr %src, align 8
  %call164 = call ptr @listAddNodeTail(ptr noundef %132, ptr noundef %133)
  %134 = load ptr, ptr %lsrc, align 8
  %135 = load i32, ptr %numslots, align 4
  %call165 = call ptr @clusterManagerComputeReshardTable(ptr noundef %134, i32 noundef %135)
  store ptr %call165, ptr %table, align 8
  %136 = load ptr, ptr %lsrc, align 8
  call void @listRelease(ptr noundef %136)
  %137 = load ptr, ptr %table, align 8
  %len166 = getelementptr inbounds %struct.list, ptr %137, i32 0, i32 5
  %138 = load i64, ptr %len166, align 8
  %conv167 = trunc i64 %138 to i32
  store i32 %conv167, ptr %table_len, align 4
  %139 = load ptr, ptr %table, align 8
  %tobool168 = icmp ne ptr %139, null
  br i1 %tobool168, label %lor.lhs.false169, label %if.then172

lor.lhs.false169:                                 ; preds = %if.then157
  %140 = load i32, ptr %table_len, align 4
  %141 = load i32, ptr %numslots, align 4
  %cmp170 = icmp ne i32 %140, %141
  br i1 %cmp170, label %if.then172, label %if.end173

if.then172:                                       ; preds = %lor.lhs.false169, %if.then157
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.387)
  store i32 0, ptr %result, align 4
  br label %end_move

if.end173:                                        ; preds = %lor.lhs.false169
  %142 = load i32, ptr %simulate, align 4
  %tobool174 = icmp ne i32 %142, 0
  br i1 %tobool174, label %if.then175, label %if.else184

if.then175:                                       ; preds = %if.end173
  store i32 0, ptr %i, align 4
  br label %for.cond176

for.cond176:                                      ; preds = %for.inc181, %if.then175
  %143 = load i32, ptr %i, align 4
  %144 = load i32, ptr %table_len, align 4
  %cmp177 = icmp slt i32 %143, %144
  br i1 %cmp177, label %for.body179, label %for.end183

for.body179:                                      ; preds = %for.cond176
  %call180 = call i32 (ptr, ...) @printf(ptr noundef @.str.388)
  br label %for.inc181

for.inc181:                                       ; preds = %for.body179
  %145 = load i32, ptr %i, align 4
  %inc182 = add nsw i32 %145, 1
  store i32 %inc182, ptr %i, align 4
  br label %for.cond176, !llvm.loop !47

for.end183:                                       ; preds = %for.cond176
  br label %if.end198

if.else184:                                       ; preds = %if.end173
  store i32 68, ptr %opts, align 4
  %146 = load ptr, ptr %table, align 8
  call void @listRewind(ptr noundef %146, ptr noundef %li)
  br label %while.cond185

while.cond185:                                    ; preds = %if.end194, %if.else184
  %call186 = call ptr @listNext(ptr noundef %li)
  store ptr %call186, ptr %ln, align 8
  %cmp187 = icmp ne ptr %call186, null
  br i1 %cmp187, label %while.body189, label %while.end197

while.body189:                                    ; preds = %while.cond185
  %147 = load ptr, ptr %ln, align 8
  %value190 = getelementptr inbounds %struct.listNode, ptr %147, i32 0, i32 2
  %148 = load ptr, ptr %value190, align 8
  store ptr %148, ptr %item, align 8
  %149 = load ptr, ptr %item, align 8
  %source = getelementptr inbounds %struct.clusterManagerReshardTableItem, ptr %149, i32 0, i32 0
  %150 = load ptr, ptr %source, align 8
  %151 = load ptr, ptr %dst, align 8
  %152 = load ptr, ptr %item, align 8
  %slot = getelementptr inbounds %struct.clusterManagerReshardTableItem, ptr %152, i32 0, i32 1
  %153 = load i32, ptr %slot, align 8
  %154 = load i32, ptr %opts, align 4
  %call191 = call i32 @clusterManagerMoveSlot(ptr noundef %150, ptr noundef %151, i32 noundef %153, i32 noundef %154, ptr noundef %err)
  store i32 %call191, ptr %result, align 4
  %155 = load i32, ptr %result, align 4
  %tobool192 = icmp ne i32 %155, 0
  br i1 %tobool192, label %if.end194, label %if.then193

if.then193:                                       ; preds = %while.body189
  %156 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.389, ptr noundef %156)
  %157 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %157)
  br label %end_move

if.end194:                                        ; preds = %while.body189
  %call195 = call i32 (ptr, ...) @printf(ptr noundef @.str.388)
  %158 = load ptr, ptr @stdout, align 8
  %call196 = call i32 @fflush(ptr noundef %158)
  br label %while.cond185, !llvm.loop !48

while.end197:                                     ; preds = %while.cond185
  br label %if.end198

if.end198:                                        ; preds = %while.end197, %for.end183
  %call199 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  br label %end_move

end_move:                                         ; preds = %if.end198, %if.then193, %if.then172
  %159 = load ptr, ptr %table, align 8
  call void @clusterManagerReleaseReshardTable(ptr noundef %159)
  %160 = load i32, ptr %result, align 4
  %tobool200 = icmp ne i32 %160, 0
  br i1 %tobool200, label %if.end202, label %if.then201

if.then201:                                       ; preds = %end_move
  br label %cleanup

if.end202:                                        ; preds = %end_move
  br label %if.end203

if.end203:                                        ; preds = %if.end202, %cond.end
  %161 = load i32, ptr %numslots, align 4
  %162 = load ptr, ptr %dst, align 8
  %balance204 = getelementptr inbounds %struct.clusterManagerNode, ptr %162, i32 0, i32 21
  %163 = load i32, ptr %balance204, align 4
  %add205 = add nsw i32 %163, %161
  store i32 %add205, ptr %balance204, align 4
  %164 = load i32, ptr %numslots, align 4
  %165 = load ptr, ptr %src, align 8
  %balance206 = getelementptr inbounds %struct.clusterManagerNode, ptr %165, i32 0, i32 21
  %166 = load i32, ptr %balance206, align 4
  %sub207 = sub nsw i32 %166, %164
  store i32 %sub207, ptr %balance206, align 4
  %167 = load ptr, ptr %dst, align 8
  %balance208 = getelementptr inbounds %struct.clusterManagerNode, ptr %167, i32 0, i32 21
  %168 = load i32, ptr %balance208, align 4
  %cmp209 = icmp eq i32 %168, 0
  br i1 %cmp209, label %if.then211, label %if.end213

if.then211:                                       ; preds = %if.end203
  %169 = load i32, ptr %dst_idx, align 4
  %inc212 = add nsw i32 %169, 1
  store i32 %inc212, ptr %dst_idx, align 4
  br label %if.end213

if.end213:                                        ; preds = %if.then211, %if.end203
  %170 = load ptr, ptr %src, align 8
  %balance214 = getelementptr inbounds %struct.clusterManagerNode, ptr %170, i32 0, i32 21
  %171 = load i32, ptr %balance214, align 4
  %cmp215 = icmp eq i32 %171, 0
  br i1 %cmp215, label %if.then217, label %if.end219

if.then217:                                       ; preds = %if.end213
  %172 = load i32, ptr %src_idx, align 4
  %dec218 = add nsw i32 %172, -1
  store i32 %dec218, ptr %src_idx, align 4
  br label %if.end219

if.end219:                                        ; preds = %if.then217, %if.end213
  br label %while.cond143, !llvm.loop !49

while.end220:                                     ; preds = %while.cond143
  br label %cleanup

cleanup:                                          ; preds = %while.end220, %if.then201, %if.then96, %if.then49, %if.then42, %if.then16, %if.then10
  %173 = load ptr, ptr %involved, align 8
  %cmp221 = icmp ne ptr %173, null
  br i1 %cmp221, label %if.then223, label %if.end224

if.then223:                                       ; preds = %cleanup
  %174 = load ptr, ptr %involved, align 8
  call void @listRelease(ptr noundef %174)
  br label %if.end224

if.end224:                                        ; preds = %if.then223, %cleanup
  %175 = load ptr, ptr %weightedNodes, align 8
  %cmp225 = icmp ne ptr %175, null
  br i1 %cmp225, label %if.then227, label %if.end228

if.then227:                                       ; preds = %if.end224
  %176 = load ptr, ptr %weightedNodes, align 8
  call void @zfree(ptr noundef %176)
  br label %if.end228

if.end228:                                        ; preds = %if.then227, %if.end224
  %177 = load i32, ptr %result, align 4
  store i32 %177, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then
  %178 = load ptr, ptr @stderr, align 8
  %call229 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %178, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %if.end228, %if.then4
  %179 = load i32, ptr %retval, align 4
  ret i32 %179
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandAddNode(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %success = alloca i32, align 4
  %reply = alloca ptr, align 8
  %function_restore_reply = alloca ptr, align 8
  %function_list_reply = alloca ptr, align 8
  %ref_ip = alloca ptr, align 8
  %ip = alloca ptr, align 8
  %ref_port = alloca i32, align 4
  %port = alloca i32, align 4
  %refnode = alloca ptr, align 8
  %master_node = alloca ptr, align 8
  %master_id = alloca ptr, align 8
  %new_node = alloca ptr, align 8
  %added = alloca i32, align 4
  %err = alloca ptr, align 8
  %first = alloca ptr, align 8
  %first_ip = alloca [46 x i8], align 16
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 1, ptr %success, align 4
  store ptr null, ptr %reply, align 8
  store ptr null, ptr %function_restore_reply, align 8
  store ptr null, ptr %function_list_reply, align 8
  store ptr null, ptr %ref_ip, align 8
  store ptr null, ptr %ip, align 8
  store i32 0, ptr %ref_port, align 4
  store i32 0, ptr %port, align 4
  %0 = load i32, ptr %argc.addr, align 4
  %sub = sub nsw i32 %0, 1
  %1 = load ptr, ptr %argv.addr, align 8
  %add.ptr = getelementptr inbounds ptr, ptr %1, i64 1
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef %sub, ptr noundef %add.ptr, ptr noundef %ref_ip, ptr noundef %ref_port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %argv.addr, align 8
  %call1 = call i32 @getClusterHostFromCmdArgs(i32 noundef 1, ptr noundef %2, ptr noundef %ip, ptr noundef %port)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  br label %invalid_args

if.end4:                                          ; preds = %if.end
  %3 = load ptr, ptr %ip, align 8
  %4 = load i32, ptr %port, align 4
  %5 = load ptr, ptr %ref_ip, align 8
  %6 = load i32, ptr %ref_port, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.327, ptr noundef %3, i32 noundef %4, ptr noundef %5, i32 noundef %6)
  %7 = load ptr, ptr %ref_ip, align 8
  %8 = load i32, ptr %ref_port, align 4
  %call5 = call ptr @clusterManagerNewNode(ptr noundef %7, i32 noundef %8, i32 noundef 0)
  store ptr %call5, ptr %refnode, align 8
  %9 = load ptr, ptr %refnode, align 8
  %call6 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %9)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end4
  %call10 = call i32 @clusterManagerCheckCluster(i32 noundef 0)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end9
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  store ptr null, ptr %master_node, align 8
  %10 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %10, 2
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.then15, label %if.end26

if.then15:                                        ; preds = %if.end13
  %11 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 10), align 8
  store ptr %11, ptr %master_id, align 8
  %12 = load ptr, ptr %master_id, align 8
  %cmp = icmp ne ptr %12, null
  br i1 %cmp, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then15
  %13 = load ptr, ptr %master_id, align 8
  %call17 = call ptr @clusterManagerNodeByName(ptr noundef %13)
  store ptr %call17, ptr %master_node, align 8
  %14 = load ptr, ptr %master_node, align 8
  %cmp18 = icmp eq ptr %14, null
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then16
  %15 = load ptr, ptr %master_id, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.328, ptr noundef %15)
  store i32 0, ptr %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.then16
  br label %if.end25

if.else:                                          ; preds = %if.then15
  %call21 = call ptr @clusterManagerNodeWithLeastReplicas()
  store ptr %call21, ptr %master_node, align 8
  %16 = load ptr, ptr %master_node, align 8
  %ip22 = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %ip22, align 8
  %18 = load ptr, ptr %master_node, align 8
  %port23 = getelementptr inbounds %struct.clusterManagerNode, ptr %18, i32 0, i32 3
  %19 = load i32, ptr %port23, align 8
  %call24 = call i32 (ptr, ...) @printf(ptr noundef @.str.329, ptr noundef %17, i32 noundef %19)
  br label %if.end25

if.end25:                                         ; preds = %if.else, %if.end20
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end13
  %20 = load ptr, ptr %ip, align 8
  %21 = load i32, ptr %port, align 4
  %call27 = call ptr @clusterManagerNewNode(ptr noundef %20, i32 noundef %21, i32 noundef 0)
  store ptr %call27, ptr %new_node, align 8
  store i32 0, ptr %added, align 4
  %22 = load ptr, ptr %new_node, align 8
  %call28 = call i32 @clusterManagerNodeConnect(ptr noundef %22)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %if.end26
  %23 = load ptr, ptr %ip, align 8
  %24 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.330, ptr noundef %23, i32 noundef %24)
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end31:                                         ; preds = %if.end26
  store ptr null, ptr %err, align 8
  %25 = load ptr, ptr %new_node, align 8
  %call32 = call i32 @clusterManagerNodeIsCluster(ptr noundef %25, ptr noundef %err)
  store i32 %call32, ptr %success, align 4
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.end38, label %if.then34

if.then34:                                        ; preds = %if.end31
  %26 = load ptr, ptr %new_node, align 8
  %27 = load ptr, ptr %err, align 8
  call void @clusterManagerPrintNotClusterNodeError(ptr noundef %26, ptr noundef %27)
  %28 = load ptr, ptr %err, align 8
  %tobool35 = icmp ne ptr %28, null
  br i1 %tobool35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.then34
  %29 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %29)
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.then34
  br label %cleanup

if.end38:                                         ; preds = %if.end31
  %30 = load ptr, ptr %new_node, align 8
  %call39 = call i32 @clusterManagerNodeLoadInfo(ptr noundef %30, i32 noundef 0, ptr noundef %err)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.end47, label %if.then41

if.then41:                                        ; preds = %if.end38
  %31 = load ptr, ptr %err, align 8
  %tobool42 = icmp ne ptr %31, null
  br i1 %tobool42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %if.then41
  %32 = load ptr, ptr %new_node, align 8
  %ip44 = getelementptr inbounds %struct.clusterManagerNode, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %ip44, align 8
  %34 = load ptr, ptr %new_node, align 8
  %port45 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 3
  %35 = load i32, ptr %port45, align 8
  %36 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %33, i32 noundef %35, ptr noundef %36)
  %37 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %37)
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %if.then41
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end47:                                         ; preds = %if.end38
  %38 = load ptr, ptr %new_node, align 8
  %call48 = call i32 @clusterManagerNodeIsEmpty(ptr noundef %38, ptr noundef %err)
  store i32 %call48, ptr %success, align 4
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.end54, label %if.then50

if.then50:                                        ; preds = %if.end47
  %39 = load ptr, ptr %new_node, align 8
  %40 = load ptr, ptr %err, align 8
  call void @clusterManagerPrintNotEmptyNodeError(ptr noundef %39, ptr noundef %40)
  %41 = load ptr, ptr %err, align 8
  %tobool51 = icmp ne ptr %41, null
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then50
  %42 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %42)
  br label %if.end53

if.end53:                                         ; preds = %if.then52, %if.then50
  br label %cleanup

if.end54:                                         ; preds = %if.end47
  %43 = load ptr, ptr @cluster_manager, align 8
  %head = getelementptr inbounds %struct.list, ptr %43, i32 0, i32 0
  %44 = load ptr, ptr %head, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %44, i32 0, i32 2
  %45 = load ptr, ptr %value, align 8
  store ptr %45, ptr %first, align 8
  %46 = load ptr, ptr @cluster_manager, align 8
  %47 = load ptr, ptr %new_node, align 8
  %call55 = call ptr @listAddNodeTail(ptr noundef %46, ptr noundef %47)
  store i32 1, ptr %added, align 4
  %48 = load ptr, ptr %master_node, align 8
  %tobool56 = icmp ne ptr %48, null
  br i1 %tobool56, label %if.end99, label %if.then57

if.then57:                                        ; preds = %if.end54
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.331)
  %49 = load ptr, ptr %refnode, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %49, i32 0, i32 0
  %50 = load ptr, ptr %context, align 8
  %call58 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %50, ptr noundef @.str.332)
  store ptr %call58, ptr %reply, align 8
  %51 = load ptr, ptr %refnode, align 8
  %52 = load ptr, ptr %reply, align 8
  %call59 = call i32 @clusterManagerCheckRedisReply(ptr noundef %51, ptr noundef %52, ptr noundef %err)
  %tobool60 = icmp ne i32 %call59, 0
  br i1 %tobool60, label %if.else66, label %if.then61

if.then61:                                        ; preds = %if.then57
  %53 = load ptr, ptr %err, align 8
  %tobool62 = icmp ne ptr %53, null
  br i1 %tobool62, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then61
  %54 = load ptr, ptr %err, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then61
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %54, %cond.true ], [ @.str.334, %cond.false ]
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.333, ptr noundef %cond)
  %55 = load ptr, ptr %err, align 8
  %tobool63 = icmp ne ptr %55, null
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %cond.end
  %56 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %56)
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %cond.end
  br label %if.end98

if.else66:                                        ; preds = %if.then57
  %57 = load ptr, ptr %ip, align 8
  %58 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.335, ptr noundef %57, i32 noundef %58)
  %59 = load ptr, ptr %new_node, align 8
  %context67 = getelementptr inbounds %struct.clusterManagerNode, ptr %59, i32 0, i32 0
  %60 = load ptr, ptr %context67, align 8
  %call68 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %60, ptr noundef @.str.336)
  store ptr %call68, ptr %function_list_reply, align 8
  %61 = load ptr, ptr %new_node, align 8
  %62 = load ptr, ptr %function_list_reply, align 8
  %call69 = call i32 @clusterManagerCheckRedisReply(ptr noundef %61, ptr noundef %62, ptr noundef %err)
  %tobool70 = icmp ne i32 %call69, 0
  br i1 %tobool70, label %if.end80, label %if.then71

if.then71:                                        ; preds = %if.else66
  %63 = load ptr, ptr %err, align 8
  %tobool72 = icmp ne ptr %63, null
  br i1 %tobool72, label %cond.true73, label %cond.false74

cond.true73:                                      ; preds = %if.then71
  %64 = load ptr, ptr %err, align 8
  br label %cond.end75

cond.false74:                                     ; preds = %if.then71
  br label %cond.end75

cond.end75:                                       ; preds = %cond.false74, %cond.true73
  %cond76 = phi ptr [ %64, %cond.true73 ], [ @.str.334, %cond.false74 ]
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.337, ptr noundef %cond76)
  %65 = load ptr, ptr %err, align 8
  %tobool77 = icmp ne ptr %65, null
  br i1 %tobool77, label %if.then78, label %if.end79

if.then78:                                        ; preds = %cond.end75
  %66 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %66)
  br label %if.end79

if.end79:                                         ; preds = %if.then78, %cond.end75
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end80:                                         ; preds = %if.else66
  %67 = load ptr, ptr %function_list_reply, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %67, i32 0, i32 6
  %68 = load i64, ptr %elements, align 8
  %cmp81 = icmp ugt i64 %68, 0
  br i1 %cmp81, label %if.then82, label %if.end83

if.then82:                                        ; preds = %if.end80
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.338)
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end83:                                         ; preds = %if.end80
  %69 = load ptr, ptr %ip, align 8
  %70 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.339, ptr noundef %69, i32 noundef %70)
  %71 = load ptr, ptr %new_node, align 8
  %context84 = getelementptr inbounds %struct.clusterManagerNode, ptr %71, i32 0, i32 0
  %72 = load ptr, ptr %context84, align 8
  %73 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %73, i32 0, i32 4
  %74 = load ptr, ptr %str, align 8
  %75 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %75, i32 0, i32 3
  %76 = load i64, ptr %len, align 8
  %call85 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %72, ptr noundef @.str.340, ptr noundef %74, i64 noundef %76)
  store ptr %call85, ptr %function_restore_reply, align 8
  %77 = load ptr, ptr %new_node, align 8
  %78 = load ptr, ptr %function_restore_reply, align 8
  %call86 = call i32 @clusterManagerCheckRedisReply(ptr noundef %77, ptr noundef %78, ptr noundef %err)
  %tobool87 = icmp ne i32 %call86, 0
  br i1 %tobool87, label %if.end97, label %if.then88

if.then88:                                        ; preds = %if.end83
  %79 = load ptr, ptr %err, align 8
  %tobool89 = icmp ne ptr %79, null
  br i1 %tobool89, label %cond.true90, label %cond.false91

cond.true90:                                      ; preds = %if.then88
  %80 = load ptr, ptr %err, align 8
  br label %cond.end92

cond.false91:                                     ; preds = %if.then88
  br label %cond.end92

cond.end92:                                       ; preds = %cond.false91, %cond.true90
  %cond93 = phi ptr [ %80, %cond.true90 ], [ @.str.334, %cond.false91 ]
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.341, ptr noundef %cond93)
  %81 = load ptr, ptr %err, align 8
  %tobool94 = icmp ne ptr %81, null
  br i1 %tobool94, label %if.then95, label %if.end96

if.then95:                                        ; preds = %cond.end92
  %82 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %82)
  br label %if.end96

if.end96:                                         ; preds = %if.then95, %cond.end92
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end97:                                         ; preds = %if.end83
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %if.end65
  br label %if.end99

if.end99:                                         ; preds = %if.end98, %if.end54
  %83 = load ptr, ptr %reply, align 8
  %tobool100 = icmp ne ptr %83, null
  br i1 %tobool100, label %if.then101, label %if.end102

if.then101:                                       ; preds = %if.end99
  %84 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %84)
  br label %if.end102

if.end102:                                        ; preds = %if.then101, %if.end99
  %85 = load ptr, ptr %ip, align 8
  %86 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.342, ptr noundef %85, i32 noundef %86)
  %87 = load ptr, ptr %first, align 8
  %ip103 = getelementptr inbounds %struct.clusterManagerNode, ptr %87, i32 0, i32 2
  %88 = load ptr, ptr %ip103, align 8
  %arraydecay = getelementptr inbounds [46 x i8], ptr %first_ip, i64 0, i64 0
  %call104 = call i32 @anetResolve(ptr noundef null, ptr noundef %88, ptr noundef %arraydecay, i64 noundef 46, i32 noundef 0)
  %cmp105 = icmp eq i32 %call104, -1
  br i1 %cmp105, label %if.then106, label %if.end109

if.then106:                                       ; preds = %if.end102
  %89 = load ptr, ptr @stderr, align 8
  %90 = load ptr, ptr %first, align 8
  %ip107 = getelementptr inbounds %struct.clusterManagerNode, ptr %90, i32 0, i32 2
  %91 = load ptr, ptr %ip107, align 8
  %call108 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %89, ptr noundef @.str.176, ptr noundef %91)
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end109:                                        ; preds = %if.end102
  %92 = load ptr, ptr %first, align 8
  %bus_port = getelementptr inbounds %struct.clusterManagerNode, ptr %92, i32 0, i32 4
  %93 = load i32, ptr %bus_port, align 4
  %cmp110 = icmp eq i32 %93, 0
  br i1 %cmp110, label %if.then114, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end109
  %94 = load ptr, ptr %first, align 8
  %bus_port111 = getelementptr inbounds %struct.clusterManagerNode, ptr %94, i32 0, i32 4
  %95 = load i32, ptr %bus_port111, align 4
  %96 = load ptr, ptr %first, align 8
  %port112 = getelementptr inbounds %struct.clusterManagerNode, ptr %96, i32 0, i32 3
  %97 = load i32, ptr %port112, align 8
  %add = add nsw i32 %97, 10000
  %cmp113 = icmp eq i32 %95, %add
  br i1 %cmp113, label %if.then114, label %if.else119

if.then114:                                       ; preds = %lor.lhs.false, %if.end109
  %98 = load ptr, ptr %new_node, align 8
  %context115 = getelementptr inbounds %struct.clusterManagerNode, ptr %98, i32 0, i32 0
  %99 = load ptr, ptr %context115, align 8
  %arraydecay116 = getelementptr inbounds [46 x i8], ptr %first_ip, i64 0, i64 0
  %100 = load ptr, ptr %first, align 8
  %port117 = getelementptr inbounds %struct.clusterManagerNode, ptr %100, i32 0, i32 3
  %101 = load i32, ptr %port117, align 8
  %call118 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %99, ptr noundef @.str.343, ptr noundef %arraydecay116, i32 noundef %101)
  store ptr %call118, ptr %reply, align 8
  br label %if.end125

if.else119:                                       ; preds = %lor.lhs.false
  %102 = load ptr, ptr %new_node, align 8
  %context120 = getelementptr inbounds %struct.clusterManagerNode, ptr %102, i32 0, i32 0
  %103 = load ptr, ptr %context120, align 8
  %arraydecay121 = getelementptr inbounds [46 x i8], ptr %first_ip, i64 0, i64 0
  %104 = load ptr, ptr %first, align 8
  %port122 = getelementptr inbounds %struct.clusterManagerNode, ptr %104, i32 0, i32 3
  %105 = load i32, ptr %port122, align 8
  %106 = load ptr, ptr %first, align 8
  %bus_port123 = getelementptr inbounds %struct.clusterManagerNode, ptr %106, i32 0, i32 4
  %107 = load i32, ptr %bus_port123, align 4
  %call124 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %103, ptr noundef @.str.344, ptr noundef %arraydecay121, i32 noundef %105, i32 noundef %107)
  store ptr %call124, ptr %reply, align 8
  br label %if.end125

if.end125:                                        ; preds = %if.else119, %if.then114
  %108 = load ptr, ptr %new_node, align 8
  %109 = load ptr, ptr %reply, align 8
  %call126 = call i32 @clusterManagerCheckRedisReply(ptr noundef %108, ptr noundef %109, ptr noundef null)
  store i32 %call126, ptr %success, align 4
  %tobool127 = icmp ne i32 %call126, 0
  br i1 %tobool127, label %if.end129, label %if.then128

if.then128:                                       ; preds = %if.end125
  br label %cleanup

if.end129:                                        ; preds = %if.end125
  %110 = load ptr, ptr %master_node, align 8
  %tobool130 = icmp ne ptr %110, null
  br i1 %tobool130, label %if.then131, label %if.end141

if.then131:                                       ; preds = %if.end129
  %call132 = call i32 @sleep(i32 noundef 1)
  call void @clusterManagerWaitForClusterJoin()
  %111 = load ptr, ptr %master_node, align 8
  %ip133 = getelementptr inbounds %struct.clusterManagerNode, ptr %111, i32 0, i32 2
  %112 = load ptr, ptr %ip133, align 8
  %113 = load ptr, ptr %master_node, align 8
  %port134 = getelementptr inbounds %struct.clusterManagerNode, ptr %113, i32 0, i32 3
  %114 = load i32, ptr %port134, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.345, ptr noundef %112, i32 noundef %114)
  %115 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %115)
  %116 = load ptr, ptr %new_node, align 8
  %context135 = getelementptr inbounds %struct.clusterManagerNode, ptr %116, i32 0, i32 0
  %117 = load ptr, ptr %context135, align 8
  %118 = load ptr, ptr %master_node, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %118, i32 0, i32 1
  %119 = load ptr, ptr %name, align 8
  %call136 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %117, ptr noundef @.str.226, ptr noundef %119)
  store ptr %call136, ptr %reply, align 8
  %120 = load ptr, ptr %new_node, align 8
  %121 = load ptr, ptr %reply, align 8
  %call137 = call i32 @clusterManagerCheckRedisReply(ptr noundef %120, ptr noundef %121, ptr noundef null)
  store i32 %call137, ptr %success, align 4
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.end140, label %if.then139

if.then139:                                       ; preds = %if.then131
  br label %cleanup

if.end140:                                        ; preds = %if.then131
  br label %if.end141

if.end141:                                        ; preds = %if.end140, %if.end129
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 4, ptr noundef @.str.346)
  br label %cleanup

cleanup:                                          ; preds = %if.end141, %if.then139, %if.then128, %if.then106, %if.end96, %if.then82, %if.end79, %if.end53, %if.end46, %if.end37, %if.then30
  %122 = load i32, ptr %added, align 4
  %tobool142 = icmp ne i32 %122, 0
  br i1 %tobool142, label %if.end145, label %land.lhs.true

land.lhs.true:                                    ; preds = %cleanup
  %123 = load ptr, ptr %new_node, align 8
  %tobool143 = icmp ne ptr %123, null
  br i1 %tobool143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %land.lhs.true
  %124 = load ptr, ptr %new_node, align 8
  call void @freeClusterManagerNode(ptr noundef %124)
  br label %if.end145

if.end145:                                        ; preds = %if.then144, %land.lhs.true, %cleanup
  %125 = load ptr, ptr %reply, align 8
  %tobool146 = icmp ne ptr %125, null
  br i1 %tobool146, label %if.then147, label %if.end148

if.then147:                                       ; preds = %if.end145
  %126 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %126)
  br label %if.end148

if.end148:                                        ; preds = %if.then147, %if.end145
  %127 = load ptr, ptr %function_restore_reply, align 8
  %tobool149 = icmp ne ptr %127, null
  br i1 %tobool149, label %if.then150, label %if.end151

if.then150:                                       ; preds = %if.end148
  %128 = load ptr, ptr %function_restore_reply, align 8
  call void @freeReplyObject(ptr noundef %128)
  br label %if.end151

if.end151:                                        ; preds = %if.then150, %if.end148
  %129 = load ptr, ptr %function_list_reply, align 8
  %tobool152 = icmp ne ptr %129, null
  br i1 %tobool152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %if.end151
  %130 = load ptr, ptr %function_list_reply, align 8
  call void @freeReplyObject(ptr noundef %130)
  br label %if.end154

if.end154:                                        ; preds = %if.then153, %if.end151
  %131 = load i32, ptr %success, align 4
  store i32 %131, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then3, %if.then
  %132 = load ptr, ptr @stderr, align 8
  %call155 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %132, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %if.end154, %if.then19, %if.then12, %if.then8
  %133 = load i32, ptr %retval, align 4
  ret i32 %133
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandDeleteNode(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %success = alloca i32, align 4
  %port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %node_id = alloca ptr, align 8
  %ref_node = alloca ptr, align 8
  %node = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %master = alloca ptr, align 8
  %r = alloca ptr, align 8
  %r38 = alloca ptr, align 8
  %r48 = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 1, ptr %success, align 4
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  %0 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef 1, ptr noundef %0, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 1
  %2 = load ptr, ptr %arrayidx, align 8
  store ptr %2, ptr %node_id, align 8
  %3 = load ptr, ptr %node_id, align 8
  %4 = load ptr, ptr %ip, align 8
  %5 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.348, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  %6 = load ptr, ptr %ip, align 8
  %7 = load i32, ptr %port, align 4
  %call1 = call ptr @clusterManagerNewNode(ptr noundef %6, i32 noundef %7, i32 noundef 0)
  store ptr %call1, ptr %ref_node, align 8
  store ptr null, ptr %node, align 8
  %8 = load ptr, ptr %ref_node, align 8
  %call2 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %8)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load ptr, ptr %node_id, align 8
  %call6 = call ptr @clusterManagerNodeByName(ptr noundef %9)
  store ptr %call6, ptr %node, align 8
  %10 = load ptr, ptr %node, align 8
  %cmp = icmp eq ptr %10, null
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end5
  %11 = load ptr, ptr %node_id, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.349, ptr noundef %11)
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end5
  %12 = load ptr, ptr %node, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %12, i32 0, i32 13
  %13 = load i32, ptr %slots_count, align 4
  %cmp9 = icmp ne i32 %13, 0
  br i1 %cmp9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end8
  %14 = load ptr, ptr %node, align 8
  %ip11 = getelementptr inbounds %struct.clusterManagerNode, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %ip11, align 8
  %16 = load ptr, ptr %node, align 8
  %port12 = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %port12, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.350, ptr noundef %15, i32 noundef %17)
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.351)
  %18 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %18, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end47, %if.then17, %if.end13
  %call14 = call ptr @listNext(ptr noundef %li)
  store ptr %call14, ptr %ln, align 8
  %cmp15 = icmp ne ptr %call14, null
  br i1 %cmp15, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %19 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %value, align 8
  store ptr %20, ptr %n, align 8
  %21 = load ptr, ptr %n, align 8
  %22 = load ptr, ptr %node, align 8
  %cmp16 = icmp eq ptr %21, %22
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %while.body
  br label %while.cond, !llvm.loop !50

if.end18:                                         ; preds = %while.body
  %23 = load ptr, ptr %n, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %23, i32 0, i32 10
  %24 = load ptr, ptr %replicate, align 8
  %tobool19 = icmp ne ptr %24, null
  br i1 %tobool19, label %land.lhs.true, label %if.end37

land.lhs.true:                                    ; preds = %if.end18
  %25 = load ptr, ptr %n, align 8
  %replicate20 = getelementptr inbounds %struct.clusterManagerNode, ptr %25, i32 0, i32 10
  %26 = load ptr, ptr %replicate20, align 8
  %27 = load ptr, ptr %node_id, align 8
  %call21 = call i32 @strcasecmp(ptr noundef %26, ptr noundef %27) #12
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end37, label %if.then23

if.then23:                                        ; preds = %land.lhs.true
  %call24 = call ptr @clusterManagerNodeWithLeastReplicas()
  store ptr %call24, ptr %master, align 8
  %28 = load ptr, ptr %n, align 8
  %ip25 = getelementptr inbounds %struct.clusterManagerNode, ptr %28, i32 0, i32 2
  %29 = load ptr, ptr %ip25, align 8
  %30 = load ptr, ptr %n, align 8
  %port26 = getelementptr inbounds %struct.clusterManagerNode, ptr %30, i32 0, i32 3
  %31 = load i32, ptr %port26, align 8
  %32 = load ptr, ptr %master, align 8
  %ip27 = getelementptr inbounds %struct.clusterManagerNode, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %ip27, align 8
  %34 = load ptr, ptr %master, align 8
  %port28 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 3
  %35 = load i32, ptr %port28, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.352, ptr noundef %29, i32 noundef %31, ptr noundef %33, i32 noundef %35)
  %36 = load ptr, ptr %n, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %36, i32 0, i32 0
  %37 = load ptr, ptr %context, align 8
  %38 = load ptr, ptr %master, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %38, i32 0, i32 1
  %39 = load ptr, ptr %name, align 8
  %call29 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %37, ptr noundef @.str.226, ptr noundef %39)
  store ptr %call29, ptr %r, align 8
  %40 = load ptr, ptr %n, align 8
  %41 = load ptr, ptr %r, align 8
  %call30 = call i32 @clusterManagerCheckRedisReply(ptr noundef %40, ptr noundef %41, ptr noundef null)
  store i32 %call30, ptr %success, align 4
  %42 = load ptr, ptr %r, align 8
  %tobool31 = icmp ne ptr %42, null
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.then23
  %43 = load ptr, ptr %r, align 8
  call void @freeReplyObject(ptr noundef %43)
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.then23
  %44 = load i32, ptr %success, align 4
  %tobool34 = icmp ne i32 %44, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.end33
  store i32 0, ptr %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end33
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %land.lhs.true, %if.end18
  %45 = load ptr, ptr %n, align 8
  %context39 = getelementptr inbounds %struct.clusterManagerNode, ptr %45, i32 0, i32 0
  %46 = load ptr, ptr %context39, align 8
  %47 = load ptr, ptr %node_id, align 8
  %call40 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %46, ptr noundef @.str.353, ptr noundef %47)
  store ptr %call40, ptr %r38, align 8
  %48 = load ptr, ptr %n, align 8
  %49 = load ptr, ptr %r38, align 8
  %call41 = call i32 @clusterManagerCheckRedisReply(ptr noundef %48, ptr noundef %49, ptr noundef null)
  store i32 %call41, ptr %success, align 4
  %50 = load ptr, ptr %r38, align 8
  %tobool42 = icmp ne ptr %50, null
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end37
  %51 = load ptr, ptr %r38, align 8
  call void @freeReplyObject(ptr noundef %51)
  br label %if.end44

if.end44:                                         ; preds = %if.then43, %if.end37
  %52 = load i32, ptr %success, align 4
  %tobool45 = icmp ne i32 %52, 0
  br i1 %tobool45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.end44
  store i32 0, ptr %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.end44
  br label %while.cond, !llvm.loop !50

while.end:                                        ; preds = %while.cond
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.354)
  %53 = load ptr, ptr %node, align 8
  %context49 = getelementptr inbounds %struct.clusterManagerNode, ptr %53, i32 0, i32 0
  %54 = load ptr, ptr %context49, align 8
  %call50 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %54, ptr noundef @.str.355, ptr noundef @.str.356)
  store ptr %call50, ptr %r48, align 8
  %55 = load ptr, ptr %node, align 8
  %56 = load ptr, ptr %r48, align 8
  %call51 = call i32 @clusterManagerCheckRedisReply(ptr noundef %55, ptr noundef %56, ptr noundef null)
  store i32 %call51, ptr %success, align 4
  %57 = load ptr, ptr %r48, align 8
  %tobool52 = icmp ne ptr %57, null
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %while.end
  %58 = load ptr, ptr %r48, align 8
  call void @freeReplyObject(ptr noundef %58)
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %while.end
  %59 = load i32, ptr %success, align 4
  store i32 %59, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then
  %60 = load ptr, ptr @stderr, align 8
  %call55 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %60, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %if.end54, %if.then46, %if.then35, %if.then10, %if.then7, %if.then4
  %61 = load i32, ptr %retval, align 4
  ret i32 %61
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandCall(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %port = alloca i32, align 4
  %i = alloca i32, align 4
  %ip = alloca ptr, align 8
  %refnode = alloca ptr, align 8
  %argvlen = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %status = alloca i32, align 4
  %formatted_reply = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  %0 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef 1, ptr noundef %0, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ip, align 8
  %2 = load i32, ptr %port, align 4
  %call1 = call ptr @clusterManagerNewNode(ptr noundef %1, i32 noundef %2, i32 noundef 0)
  store ptr %call1, ptr %refnode, align 8
  %3 = load ptr, ptr %refnode, align 8
  %call2 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %3)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %4 = load i32, ptr %argc.addr, align 4
  %dec = add nsw i32 %4, -1
  store i32 %dec, ptr %argc.addr, align 4
  %5 = load ptr, ptr %argv.addr, align 8
  %incdec.ptr = getelementptr inbounds ptr, ptr %5, i32 1
  store ptr %incdec.ptr, ptr %argv.addr, align 8
  %6 = load i32, ptr %argc.addr, align 4
  %conv = sext i32 %6 to i64
  %mul = mul i64 %conv, 8
  %call6 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call6, ptr %argvlen, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.419)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %argc.addr, align 4
  %cmp = icmp slt i32 %7, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %argv.addr, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %9, i64 %idxprom
  %11 = load ptr, ptr %arrayidx, align 8
  %call8 = call i64 @strlen(ptr noundef %11) #12
  %12 = load ptr, ptr %argvlen, align 8
  %13 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %13 to i64
  %arrayidx10 = getelementptr inbounds i64, ptr %12, i64 %idxprom9
  store i64 %call8, ptr %arrayidx10, align 8
  %14 = load ptr, ptr %argv.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom11 = sext i32 %15 to i64
  %arrayidx12 = getelementptr inbounds ptr, ptr %14, i64 %idxprom11
  %16 = load ptr, ptr %arrayidx12, align 8
  %call13 = call i32 (ptr, ...) @printf(ptr noundef @.str.420, ptr noundef %16)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !51

for.end:                                          ; preds = %for.cond
  %call14 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  %18 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %18, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end57, %if.then35, %if.then29, %if.then21, %for.end
  %call15 = call ptr @listNext(ptr noundef %li)
  store ptr %call15, ptr %ln, align 8
  %cmp16 = icmp ne ptr %call15, null
  br i1 %cmp16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %19 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %value, align 8
  store ptr %20, ptr %n, align 8
  %21 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %21, 2048
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %while.body
  %22 = load ptr, ptr %n, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %22, i32 0, i32 10
  %23 = load ptr, ptr %replicate, align 8
  %cmp19 = icmp ne ptr %23, null
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %land.lhs.true
  br label %while.cond, !llvm.loop !52

if.end22:                                         ; preds = %land.lhs.true, %while.body
  %24 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and23 = and i32 %24, 4096
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %land.lhs.true25, label %if.end30

land.lhs.true25:                                  ; preds = %if.end22
  %25 = load ptr, ptr %n, align 8
  %replicate26 = getelementptr inbounds %struct.clusterManagerNode, ptr %25, i32 0, i32 10
  %26 = load ptr, ptr %replicate26, align 8
  %cmp27 = icmp eq ptr %26, null
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %land.lhs.true25
  br label %while.cond, !llvm.loop !52

if.end30:                                         ; preds = %land.lhs.true25, %if.end22
  %27 = load ptr, ptr %n, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %27, i32 0, i32 0
  %28 = load ptr, ptr %context, align 8
  %tobool31 = icmp ne ptr %28, null
  br i1 %tobool31, label %if.end36, label %land.lhs.true32

land.lhs.true32:                                  ; preds = %if.end30
  %29 = load ptr, ptr %n, align 8
  %call33 = call i32 @clusterManagerNodeConnect(ptr noundef %29)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %land.lhs.true32
  br label %while.cond, !llvm.loop !52

if.end36:                                         ; preds = %land.lhs.true32, %if.end30
  store ptr null, ptr %reply, align 8
  %30 = load ptr, ptr %n, align 8
  %context37 = getelementptr inbounds %struct.clusterManagerNode, ptr %30, i32 0, i32 0
  %31 = load ptr, ptr %context37, align 8
  %32 = load i32, ptr %argc.addr, align 4
  %33 = load ptr, ptr %argv.addr, align 8
  %34 = load ptr, ptr %argvlen, align 8
  %call38 = call i32 @redisAppendCommandArgv(ptr noundef %31, i32 noundef %32, ptr noundef %33, ptr noundef %34)
  %35 = load ptr, ptr %n, align 8
  %context39 = getelementptr inbounds %struct.clusterManagerNode, ptr %35, i32 0, i32 0
  %36 = load ptr, ptr %context39, align 8
  %call40 = call i32 @redisGetReply(ptr noundef %36, ptr noundef %reply)
  store i32 %call40, ptr %status, align 4
  %37 = load i32, ptr %status, align 4
  %cmp41 = icmp ne i32 %37, 0
  br i1 %cmp41, label %if.then45, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end36
  %38 = load ptr, ptr %reply, align 8
  %cmp43 = icmp eq ptr %38, null
  br i1 %cmp43, label %if.then45, label %if.else

if.then45:                                        ; preds = %lor.lhs.false, %if.end36
  %39 = load ptr, ptr %n, align 8
  %ip46 = getelementptr inbounds %struct.clusterManagerNode, ptr %39, i32 0, i32 2
  %40 = load ptr, ptr %ip46, align 8
  %41 = load ptr, ptr %n, align 8
  %port47 = getelementptr inbounds %struct.clusterManagerNode, ptr %41, i32 0, i32 3
  %42 = load i32, ptr %port47, align 8
  %call48 = call i32 (ptr, ...) @printf(ptr noundef @.str.421, ptr noundef %40, i32 noundef %42)
  br label %if.end53

if.else:                                          ; preds = %lor.lhs.false
  %43 = load ptr, ptr %reply, align 8
  %call49 = call ptr @cliFormatReplyRaw(ptr noundef %43)
  store ptr %call49, ptr %formatted_reply, align 8
  %44 = load ptr, ptr %n, align 8
  %ip50 = getelementptr inbounds %struct.clusterManagerNode, ptr %44, i32 0, i32 2
  %45 = load ptr, ptr %ip50, align 8
  %46 = load ptr, ptr %n, align 8
  %port51 = getelementptr inbounds %struct.clusterManagerNode, ptr %46, i32 0, i32 3
  %47 = load i32, ptr %port51, align 8
  %48 = load ptr, ptr %formatted_reply, align 8
  %call52 = call i32 (ptr, ...) @printf(ptr noundef @.str.182, ptr noundef %45, i32 noundef %47, ptr noundef %48)
  %49 = load ptr, ptr %formatted_reply, align 8
  call void @hi_sdsfree(ptr noundef %49)
  br label %if.end53

if.end53:                                         ; preds = %if.else, %if.then45
  %50 = load ptr, ptr %reply, align 8
  %cmp54 = icmp ne ptr %50, null
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end53
  %51 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %51)
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.end53
  br label %while.cond, !llvm.loop !52

while.end:                                        ; preds = %while.cond
  %52 = load ptr, ptr %argvlen, align 8
  call void @zfree(ptr noundef %52)
  store i32 1, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then
  %53 = load ptr, ptr @stderr, align 8
  %call58 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %53, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %while.end, %if.then4
  %54 = load i32, ptr %retval, align 4
  ret i32 %54
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandSetTimeout(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %timeout = alloca i32, align 4
  %node = alloca ptr, align 8
  %ok_count = alloca i32, align 4
  %err_count = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %err = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %ok = alloca i32, align 4
  %need_free = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  %0 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef 1, ptr noundef %0, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 1
  %2 = load ptr, ptr %arrayidx, align 8
  %call1 = call i32 @atoi(ptr noundef %2) #12
  store i32 %call1, ptr %timeout, align 4
  %3 = load i32, ptr %timeout, align 4
  %cmp = icmp slt i32 %3, 100
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr @stderr, align 8
  %call3 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %4, ptr noundef @.str.390)
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %5 = load ptr, ptr %ip, align 8
  %6 = load i32, ptr %port, align 4
  %call5 = call ptr @clusterManagerNewNode(ptr noundef %5, i32 noundef %6, i32 noundef 0)
  store ptr %call5, ptr %node, align 8
  %7 = load ptr, ptr %node, align 8
  %call6 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %7)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.end4
  store i32 0, ptr %ok_count, align 4
  store i32 0, ptr %err_count, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.391)
  %8 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %8, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end38, %if.end28, %if.end9
  %call10 = call ptr @listNext(ptr noundef %li)
  store ptr %call10, ptr %ln, align 8
  %cmp11 = icmp ne ptr %call10, null
  br i1 %cmp11, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %value, align 8
  store ptr %10, ptr %n, align 8
  store ptr null, ptr %err, align 8
  %11 = load ptr, ptr %n, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %context, align 8
  %13 = load i32, ptr %timeout, align 4
  %call12 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %12, ptr noundef @.str.392, ptr noundef @.str.393, ptr noundef @.str.394, i32 noundef %13)
  store ptr %call12, ptr %reply, align 8
  %14 = load ptr, ptr %reply, align 8
  %cmp13 = icmp eq ptr %14, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %while.body
  br label %reply_err

if.end15:                                         ; preds = %while.body
  %15 = load ptr, ptr %n, align 8
  %16 = load ptr, ptr %reply, align 8
  %call16 = call i32 @clusterManagerCheckRedisReply(ptr noundef %15, ptr noundef %16, ptr noundef %err)
  store i32 %call16, ptr %ok, align 4
  %17 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %17)
  %18 = load i32, ptr %ok, align 4
  %tobool17 = icmp ne i32 %18, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end15
  br label %reply_err

if.end19:                                         ; preds = %if.end15
  %19 = load ptr, ptr %n, align 8
  %context20 = getelementptr inbounds %struct.clusterManagerNode, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %context20, align 8
  %call21 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %20, ptr noundef @.str.395, ptr noundef @.str.396)
  store ptr %call21, ptr %reply, align 8
  %21 = load ptr, ptr %reply, align 8
  %cmp22 = icmp eq ptr %21, null
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end19
  br label %reply_err

if.end24:                                         ; preds = %if.end19
  %22 = load ptr, ptr %n, align 8
  %23 = load ptr, ptr %reply, align 8
  %call25 = call i32 @clusterManagerCheckRedisReply(ptr noundef %22, ptr noundef %23, ptr noundef %err)
  store i32 %call25, ptr %ok, align 4
  %24 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %24)
  %25 = load i32, ptr %ok, align 4
  %tobool26 = icmp ne i32 %25, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end24
  br label %reply_err

if.end28:                                         ; preds = %if.end24
  %26 = load ptr, ptr %n, align 8
  %ip29 = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %ip29, align 8
  %28 = load ptr, ptr %n, align 8
  %port30 = getelementptr inbounds %struct.clusterManagerNode, ptr %28, i32 0, i32 3
  %29 = load i32, ptr %port30, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.397, ptr noundef %27, i32 noundef %29)
  %30 = load i32, ptr %ok_count, align 4
  %inc = add nsw i32 %30, 1
  store i32 %inc, ptr %ok_count, align 4
  br label %while.cond, !llvm.loop !53

reply_err:                                        ; preds = %if.then27, %if.then23, %if.then18, %if.then14
  store i32 0, ptr %need_free, align 4
  %31 = load ptr, ptr %err, align 8
  %cmp31 = icmp eq ptr %31, null
  br i1 %cmp31, label %if.then32, label %if.else

if.then32:                                        ; preds = %reply_err
  store ptr @.str.26, ptr %err, align 8
  br label %if.end33

if.else:                                          ; preds = %reply_err
  store i32 1, ptr %need_free, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.else, %if.then32
  %32 = load ptr, ptr %n, align 8
  %ip34 = getelementptr inbounds %struct.clusterManagerNode, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %ip34, align 8
  %34 = load ptr, ptr %n, align 8
  %port35 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 3
  %35 = load i32, ptr %port35, align 8
  %36 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.398, ptr noundef %33, i32 noundef %35, ptr noundef %36)
  %37 = load i32, ptr %need_free, align 4
  %tobool36 = icmp ne i32 %37, 0
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.end33
  %38 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %38)
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.end33
  %39 = load i32, ptr %err_count, align 4
  %inc39 = add nsw i32 %39, 1
  store i32 %inc39, ptr %err_count, align 4
  br label %while.cond, !llvm.loop !53

while.end:                                        ; preds = %while.cond
  %40 = load i32, ptr %ok_count, align 4
  %41 = load i32, ptr %err_count, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.399, i32 noundef %40, i32 noundef %41)
  store i32 1, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then
  %42 = load ptr, ptr @stderr, align 8
  %call40 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %42, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %while.end, %if.then8, %if.then2
  %43 = load i32, ptr %retval, align 4
  ret i32 %43
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandImport(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %success = alloca i32, align 4
  %port = alloca i32, align 4
  %src_port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %src_ip = alloca ptr, align 8
  %invalid_args_msg = alloca ptr, align 8
  %cmdfmt = alloca ptr, align 8
  %src_host = alloca [1 x ptr], align 8
  %refnode = alloca ptr, align 8
  %reply_err = alloca ptr, align 8
  %src_reply = alloca ptr, align 8
  %src_ctx = alloca ptr, align 8
  %from_user = alloca ptr, align 8
  %from_pass = alloca ptr, align 8
  %size = alloca i32, align 4
  %i = alloca i32, align 4
  %slots_map = alloca [16384 x ptr], align 16
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %cursor = alloca i32, align 4
  %timeout = alloca i32, align 4
  %keycount = alloca i32, align 4
  %kr = alloca ptr, align 8
  %key = alloca ptr, align 8
  %slot = alloca i16, align 2
  %target = alloca ptr, align 8
  %r = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 1, ptr %success, align 4
  store i32 0, ptr %port, align 4
  store i32 0, ptr %src_port, align 4
  store ptr null, ptr %ip, align 8
  store ptr null, ptr %src_ip, align 8
  store ptr null, ptr %invalid_args_msg, align 8
  store ptr null, ptr %cmdfmt, align 8
  %0 = load i32, ptr %argc.addr, align 4
  %1 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef %0, ptr noundef %1, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr @.str.347, ptr %invalid_args_msg, align 8
  br label %invalid_args

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 6), align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  store ptr @.str.400, ptr %invalid_args_msg, align 8
  br label %invalid_args

if.end2:                                          ; preds = %if.end
  %arrayinit.begin = getelementptr inbounds [1 x ptr], ptr %src_host, i64 0, i64 0
  %3 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 6), align 8
  store ptr %3, ptr %arrayinit.begin, align 8
  %arraydecay = getelementptr inbounds [1 x ptr], ptr %src_host, i64 0, i64 0
  %call3 = call i32 @getClusterHostFromCmdArgs(i32 noundef 1, ptr noundef %arraydecay, ptr noundef %src_ip, ptr noundef %src_port)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end2
  store ptr @.str.401, ptr %invalid_args_msg, align 8
  br label %invalid_args

if.end6:                                          ; preds = %if.end2
  %4 = load ptr, ptr %src_ip, align 8
  %5 = load i32, ptr %src_port, align 4
  %6 = load ptr, ptr %ip, align 8
  %7 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.402, ptr noundef %4, i32 noundef %5, ptr noundef %6, i32 noundef %7)
  %8 = load ptr, ptr %ip, align 8
  %9 = load i32, ptr %port, align 4
  %call7 = call ptr @clusterManagerNewNode(ptr noundef %8, i32 noundef %9, i32 noundef 0)
  store ptr %call7, ptr %refnode, align 8
  %10 = load ptr, ptr %refnode, align 8
  %call8 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %10)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end6
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end6
  %call12 = call i32 @clusterManagerCheckCluster(i32 noundef 0)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end11
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end11
  store ptr null, ptr %reply_err, align 8
  store ptr null, ptr %src_reply, align 8
  %11 = load ptr, ptr %src_ip, align 8
  %12 = load i32, ptr %src_port, align 4
  %call16 = call ptr @redisConnect(ptr noundef %11, i32 noundef %12)
  store ptr %call16, ptr %src_ctx, align 8
  %13 = load ptr, ptr %src_ctx, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %err, align 8
  %tobool17 = icmp ne i32 %14, 0
  br i1 %tobool17, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end15
  store i32 0, ptr %success, align 4
  %15 = load ptr, ptr @stderr, align 8
  %16 = load ptr, ptr %src_ip, align 8
  %17 = load i32, ptr %src_port, align 4
  %18 = load ptr, ptr %src_ctx, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %18, i32 0, i32 2
  %arraydecay19 = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call20 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %15, ptr noundef @.str.403, ptr noundef %16, i32 noundef %17, ptr noundef %arraydecay19)
  br label %cleanup

if.end21:                                         ; preds = %if.end15
  %19 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 16), align 8
  store ptr %19, ptr %from_user, align 8
  %20 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 17), align 8
  store ptr %20, ptr %from_pass, align 8
  %21 = load ptr, ptr %src_ctx, align 8
  %22 = load ptr, ptr %from_user, align 8
  %23 = load ptr, ptr %from_pass, align 8
  %call22 = call i32 @cliAuth(ptr noundef %21, ptr noundef %22, ptr noundef %23)
  %cmp23 = icmp eq i32 %call22, -1
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end21
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end25:                                         ; preds = %if.end21
  %24 = load ptr, ptr %src_ctx, align 8
  %call26 = call ptr (ptr, ptr, ...) @reconnectingRedisCommand(ptr noundef %24, ptr noundef @.str.186)
  store ptr %call26, ptr %src_reply, align 8
  %25 = load ptr, ptr %src_reply, align 8
  %tobool27 = icmp ne ptr %25, null
  br i1 %tobool27, label %lor.lhs.false, label %if.then29

lor.lhs.false:                                    ; preds = %if.end25
  %26 = load ptr, ptr %src_reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %26, i32 0, i32 0
  %27 = load i32, ptr %type, align 8
  %cmp28 = icmp eq i32 %27, 6
  br i1 %cmp28, label %if.then29, label %if.end35

if.then29:                                        ; preds = %lor.lhs.false, %if.end25
  %28 = load ptr, ptr %src_reply, align 8
  %tobool30 = icmp ne ptr %28, null
  br i1 %tobool30, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.then29
  %29 = load ptr, ptr %src_reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %29, i32 0, i32 4
  %30 = load ptr, ptr %str, align 8
  %tobool31 = icmp ne ptr %30, null
  br i1 %tobool31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %land.lhs.true
  %31 = load ptr, ptr %src_reply, align 8
  %str33 = getelementptr inbounds %struct.redisReply, ptr %31, i32 0, i32 4
  %32 = load ptr, ptr %str33, align 8
  store ptr %32, ptr %reply_err, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %land.lhs.true, %if.then29
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end35:                                         ; preds = %lor.lhs.false
  %33 = load ptr, ptr %src_reply, align 8
  %str36 = getelementptr inbounds %struct.redisReply, ptr %33, i32 0, i32 4
  %34 = load ptr, ptr %str36, align 8
  %call37 = call i64 @getLongInfoField(ptr noundef %34, ptr noundef @.str.185)
  %tobool38 = icmp ne i64 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.404)
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end40:                                         ; preds = %if.end35
  %35 = load ptr, ptr %src_reply, align 8
  call void @freeReplyObject(ptr noundef %35)
  %36 = load ptr, ptr %src_ctx, align 8
  %call41 = call ptr (ptr, ptr, ...) @reconnectingRedisCommand(ptr noundef %36, ptr noundef @.str.357)
  store ptr %call41, ptr %src_reply, align 8
  %37 = load ptr, ptr %src_reply, align 8
  %tobool42 = icmp ne ptr %37, null
  br i1 %tobool42, label %lor.lhs.false43, label %if.then46

lor.lhs.false43:                                  ; preds = %if.end40
  %38 = load ptr, ptr %src_reply, align 8
  %type44 = getelementptr inbounds %struct.redisReply, ptr %38, i32 0, i32 0
  %39 = load i32, ptr %type44, align 8
  %cmp45 = icmp eq i32 %39, 6
  br i1 %cmp45, label %if.then46, label %if.end54

if.then46:                                        ; preds = %lor.lhs.false43, %if.end40
  %40 = load ptr, ptr %src_reply, align 8
  %tobool47 = icmp ne ptr %40, null
  br i1 %tobool47, label %land.lhs.true48, label %if.end53

land.lhs.true48:                                  ; preds = %if.then46
  %41 = load ptr, ptr %src_reply, align 8
  %str49 = getelementptr inbounds %struct.redisReply, ptr %41, i32 0, i32 4
  %42 = load ptr, ptr %str49, align 8
  %tobool50 = icmp ne ptr %42, null
  br i1 %tobool50, label %if.then51, label %if.end53

if.then51:                                        ; preds = %land.lhs.true48
  %43 = load ptr, ptr %src_reply, align 8
  %str52 = getelementptr inbounds %struct.redisReply, ptr %43, i32 0, i32 4
  %44 = load ptr, ptr %str52, align 8
  store ptr %44, ptr %reply_err, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.then51, %land.lhs.true48, %if.then46
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end54:                                         ; preds = %lor.lhs.false43
  %45 = load ptr, ptr %src_reply, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %45, i32 0, i32 1
  %46 = load i64, ptr %integer, align 8
  %conv = trunc i64 %46 to i32
  store i32 %conv, ptr %size, align 4
  %47 = load i32, ptr %size, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.405, i32 noundef %47)
  %arraydecay55 = getelementptr inbounds [16384 x ptr], ptr %slots_map, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay55, i8 0, i64 131072, i1 false)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end54
  %48 = load i32, ptr %i, align 4
  %cmp56 = icmp slt i32 %48, 16384
  br i1 %cmp56, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %49 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %49, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end72, %if.then66, %if.then62, %for.body
  %call58 = call ptr @listNext(ptr noundef %li)
  store ptr %call58, ptr %ln, align 8
  %cmp59 = icmp ne ptr %call58, null
  br i1 %cmp59, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %50 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %50, i32 0, i32 2
  %51 = load ptr, ptr %value, align 8
  store ptr %51, ptr %n, align 8
  %52 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %52, i32 0, i32 8
  %53 = load i32, ptr %flags, align 8
  %and = and i32 %53, 2
  %tobool61 = icmp ne i32 %and, 0
  br i1 %tobool61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %while.body
  br label %while.cond, !llvm.loop !54

if.end63:                                         ; preds = %while.body
  %54 = load ptr, ptr %n, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %54, i32 0, i32 13
  %55 = load i32, ptr %slots_count, align 4
  %cmp64 = icmp eq i32 %55, 0
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.end63
  br label %while.cond, !llvm.loop !54

if.end67:                                         ; preds = %if.end63
  %56 = load ptr, ptr %n, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %56, i32 0, i32 12
  %57 = load i32, ptr %i, align 4
  %idxprom = sext i32 %57 to i64
  %arrayidx = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom
  %58 = load i8, ptr %arrayidx, align 1
  %tobool68 = icmp ne i8 %58, 0
  br i1 %tobool68, label %if.then69, label %if.end72

if.then69:                                        ; preds = %if.end67
  %59 = load ptr, ptr %n, align 8
  %60 = load i32, ptr %i, align 4
  %idxprom70 = sext i32 %60 to i64
  %arrayidx71 = getelementptr inbounds [16384 x ptr], ptr %slots_map, i64 0, i64 %idxprom70
  store ptr %59, ptr %arrayidx71, align 8
  br label %while.end

if.end72:                                         ; preds = %if.end67
  br label %while.cond, !llvm.loop !54

while.end:                                        ; preds = %if.then69, %while.cond
  br label %for.inc

for.inc:                                          ; preds = %while.end
  %61 = load i32, ptr %i, align 4
  %inc = add nsw i32 %61, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  %call73 = call ptr @hi_sdsnew(ptr noundef @.str.406)
  store ptr %call73, ptr %cmdfmt, align 8
  %62 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %tobool74 = icmp ne ptr %62, null
  br i1 %tobool74, label %if.then75, label %if.end81

if.then75:                                        ; preds = %for.end
  %63 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %tobool76 = icmp ne ptr %63, null
  br i1 %tobool76, label %if.then77, label %if.else

if.then77:                                        ; preds = %if.then75
  %64 = load ptr, ptr %cmdfmt, align 8
  %65 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %66 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %call78 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %64, ptr noundef @.str.407, ptr noundef %65, ptr noundef %66)
  store ptr %call78, ptr %cmdfmt, align 8
  br label %if.end80

if.else:                                          ; preds = %if.then75
  %67 = load ptr, ptr %cmdfmt, align 8
  %68 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %call79 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %67, ptr noundef @.str.408, ptr noundef %68)
  store ptr %call79, ptr %cmdfmt, align 8
  br label %if.end80

if.end80:                                         ; preds = %if.else, %if.then77
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %for.end
  %69 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and82 = and i32 %69, 128
  %tobool83 = icmp ne i32 %and82, 0
  br i1 %tobool83, label %if.then84, label %if.end86

if.then84:                                        ; preds = %if.end81
  %70 = load ptr, ptr %cmdfmt, align 8
  %call85 = call ptr @hi_sdscat(ptr noundef %70, ptr noundef @.str.409)
  store ptr %call85, ptr %cmdfmt, align 8
  br label %if.end86

if.end86:                                         ; preds = %if.then84, %if.end81
  %71 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and87 = and i32 %71, 64
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %if.then89, label %if.end91

if.then89:                                        ; preds = %if.end86
  %72 = load ptr, ptr %cmdfmt, align 8
  %call90 = call ptr @hi_sdscat(ptr noundef %72, ptr noundef @.str.410)
  store ptr %call90, ptr %cmdfmt, align 8
  br label %if.end91

if.end91:                                         ; preds = %if.then89, %if.end86
  store i32 -999, ptr %cursor, align 4
  %73 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 12), align 4
  store i32 %73, ptr %timeout, align 4
  br label %while.cond92

while.cond92:                                     ; preds = %for.end180, %if.end91
  %74 = load i32, ptr %cursor, align 4
  %cmp93 = icmp ne i32 %74, 0
  br i1 %cmp93, label %while.body95, label %while.end181

while.body95:                                     ; preds = %while.cond92
  %75 = load i32, ptr %cursor, align 4
  %cmp96 = icmp slt i32 %75, 0
  br i1 %cmp96, label %if.then98, label %if.end99

if.then98:                                        ; preds = %while.body95
  store i32 0, ptr %cursor, align 4
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %while.body95
  %76 = load ptr, ptr %src_reply, align 8
  call void @freeReplyObject(ptr noundef %76)
  %77 = load ptr, ptr %src_ctx, align 8
  %78 = load i32, ptr %cursor, align 4
  %call100 = call ptr (ptr, ptr, ...) @reconnectingRedisCommand(ptr noundef %77, ptr noundef @.str.411, i32 noundef %78, i32 noundef 1000)
  store ptr %call100, ptr %src_reply, align 8
  %79 = load ptr, ptr %src_reply, align 8
  %tobool101 = icmp ne ptr %79, null
  br i1 %tobool101, label %lor.lhs.false102, label %if.then106

lor.lhs.false102:                                 ; preds = %if.end99
  %80 = load ptr, ptr %src_reply, align 8
  %type103 = getelementptr inbounds %struct.redisReply, ptr %80, i32 0, i32 0
  %81 = load i32, ptr %type103, align 8
  %cmp104 = icmp eq i32 %81, 6
  br i1 %cmp104, label %if.then106, label %if.end114

if.then106:                                       ; preds = %lor.lhs.false102, %if.end99
  %82 = load ptr, ptr %src_reply, align 8
  %tobool107 = icmp ne ptr %82, null
  br i1 %tobool107, label %land.lhs.true108, label %if.end113

land.lhs.true108:                                 ; preds = %if.then106
  %83 = load ptr, ptr %src_reply, align 8
  %str109 = getelementptr inbounds %struct.redisReply, ptr %83, i32 0, i32 4
  %84 = load ptr, ptr %str109, align 8
  %tobool110 = icmp ne ptr %84, null
  br i1 %tobool110, label %if.then111, label %if.end113

if.then111:                                       ; preds = %land.lhs.true108
  %85 = load ptr, ptr %src_reply, align 8
  %str112 = getelementptr inbounds %struct.redisReply, ptr %85, i32 0, i32 4
  %86 = load ptr, ptr %str112, align 8
  store ptr %86, ptr %reply_err, align 8
  br label %if.end113

if.end113:                                        ; preds = %if.then111, %land.lhs.true108, %if.then106
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end114:                                        ; preds = %lor.lhs.false102
  %87 = load ptr, ptr %src_reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %87, i32 0, i32 7
  %88 = load ptr, ptr %element, align 8
  %arrayidx115 = getelementptr inbounds ptr, ptr %88, i64 0
  %89 = load ptr, ptr %arrayidx115, align 8
  %type116 = getelementptr inbounds %struct.redisReply, ptr %89, i32 0, i32 0
  %90 = load i32, ptr %type116, align 8
  %cmp117 = icmp eq i32 %90, 1
  br i1 %cmp117, label %if.then119, label %if.else124

if.then119:                                       ; preds = %if.end114
  %91 = load ptr, ptr %src_reply, align 8
  %element120 = getelementptr inbounds %struct.redisReply, ptr %91, i32 0, i32 7
  %92 = load ptr, ptr %element120, align 8
  %arrayidx121 = getelementptr inbounds ptr, ptr %92, i64 0
  %93 = load ptr, ptr %arrayidx121, align 8
  %str122 = getelementptr inbounds %struct.redisReply, ptr %93, i32 0, i32 4
  %94 = load ptr, ptr %str122, align 8
  %call123 = call i32 @atoi(ptr noundef %94) #12
  store i32 %call123, ptr %cursor, align 4
  br label %if.end136

if.else124:                                       ; preds = %if.end114
  %95 = load ptr, ptr %src_reply, align 8
  %element125 = getelementptr inbounds %struct.redisReply, ptr %95, i32 0, i32 7
  %96 = load ptr, ptr %element125, align 8
  %arrayidx126 = getelementptr inbounds ptr, ptr %96, i64 0
  %97 = load ptr, ptr %arrayidx126, align 8
  %type127 = getelementptr inbounds %struct.redisReply, ptr %97, i32 0, i32 0
  %98 = load i32, ptr %type127, align 8
  %cmp128 = icmp eq i32 %98, 3
  br i1 %cmp128, label %if.then130, label %if.end135

if.then130:                                       ; preds = %if.else124
  %99 = load ptr, ptr %src_reply, align 8
  %element131 = getelementptr inbounds %struct.redisReply, ptr %99, i32 0, i32 7
  %100 = load ptr, ptr %element131, align 8
  %arrayidx132 = getelementptr inbounds ptr, ptr %100, i64 0
  %101 = load ptr, ptr %arrayidx132, align 8
  %integer133 = getelementptr inbounds %struct.redisReply, ptr %101, i32 0, i32 1
  %102 = load i64, ptr %integer133, align 8
  %conv134 = trunc i64 %102 to i32
  store i32 %conv134, ptr %cursor, align 4
  br label %if.end135

if.end135:                                        ; preds = %if.then130, %if.else124
  br label %if.end136

if.end136:                                        ; preds = %if.end135, %if.then119
  %103 = load ptr, ptr %src_reply, align 8
  %element137 = getelementptr inbounds %struct.redisReply, ptr %103, i32 0, i32 7
  %104 = load ptr, ptr %element137, align 8
  %arrayidx138 = getelementptr inbounds ptr, ptr %104, i64 1
  %105 = load ptr, ptr %arrayidx138, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %105, i32 0, i32 6
  %106 = load i64, ptr %elements, align 8
  %conv139 = trunc i64 %106 to i32
  store i32 %conv139, ptr %keycount, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond140

for.cond140:                                      ; preds = %for.inc178, %if.end136
  %107 = load i32, ptr %i, align 4
  %108 = load i32, ptr %keycount, align 4
  %cmp141 = icmp slt i32 %107, %108
  br i1 %cmp141, label %for.body143, label %for.end180

for.body143:                                      ; preds = %for.cond140
  %109 = load ptr, ptr %src_reply, align 8
  %element144 = getelementptr inbounds %struct.redisReply, ptr %109, i32 0, i32 7
  %110 = load ptr, ptr %element144, align 8
  %arrayidx145 = getelementptr inbounds ptr, ptr %110, i64 1
  %111 = load ptr, ptr %arrayidx145, align 8
  %element146 = getelementptr inbounds %struct.redisReply, ptr %111, i32 0, i32 7
  %112 = load ptr, ptr %element146, align 8
  %113 = load i32, ptr %i, align 4
  %idxprom147 = sext i32 %113 to i64
  %arrayidx148 = getelementptr inbounds ptr, ptr %112, i64 %idxprom147
  %114 = load ptr, ptr %arrayidx148, align 8
  store ptr %114, ptr %kr, align 8
  %115 = load ptr, ptr %kr, align 8
  %str149 = getelementptr inbounds %struct.redisReply, ptr %115, i32 0, i32 4
  %116 = load ptr, ptr %str149, align 8
  store ptr %116, ptr %key, align 8
  %117 = load ptr, ptr %key, align 8
  %118 = load ptr, ptr %kr, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %118, i32 0, i32 3
  %119 = load i64, ptr %len, align 8
  %conv150 = trunc i64 %119 to i32
  %call151 = call i32 @clusterManagerKeyHashSlot(ptr noundef %117, i32 noundef %conv150)
  %conv152 = trunc i32 %call151 to i16
  store i16 %conv152, ptr %slot, align 2
  %120 = load i16, ptr %slot, align 2
  %idxprom153 = zext i16 %120 to i64
  %arrayidx154 = getelementptr inbounds [16384 x ptr], ptr %slots_map, i64 0, i64 %idxprom153
  %121 = load ptr, ptr %arrayidx154, align 8
  store ptr %121, ptr %target, align 8
  %122 = load ptr, ptr %key, align 8
  %123 = load ptr, ptr %target, align 8
  %ip155 = getelementptr inbounds %struct.clusterManagerNode, ptr %123, i32 0, i32 2
  %124 = load ptr, ptr %ip155, align 8
  %125 = load ptr, ptr %target, align 8
  %port156 = getelementptr inbounds %struct.clusterManagerNode, ptr %125, i32 0, i32 3
  %126 = load i32, ptr %port156, align 8
  %call157 = call i32 (ptr, ...) @printf(ptr noundef @.str.412, ptr noundef %122, ptr noundef %124, i32 noundef %126)
  %127 = load ptr, ptr %src_ctx, align 8
  %128 = load ptr, ptr %cmdfmt, align 8
  %129 = load ptr, ptr %target, align 8
  %ip158 = getelementptr inbounds %struct.clusterManagerNode, ptr %129, i32 0, i32 2
  %130 = load ptr, ptr %ip158, align 8
  %131 = load ptr, ptr %target, align 8
  %port159 = getelementptr inbounds %struct.clusterManagerNode, ptr %131, i32 0, i32 3
  %132 = load i32, ptr %port159, align 8
  %133 = load ptr, ptr %key, align 8
  %134 = load i32, ptr %timeout, align 4
  %call160 = call ptr (ptr, ptr, ...) @reconnectingRedisCommand(ptr noundef %127, ptr noundef %128, ptr noundef %130, i32 noundef %132, ptr noundef %133, i32 noundef 0, i32 noundef %134)
  store ptr %call160, ptr %r, align 8
  %135 = load ptr, ptr %r, align 8
  %tobool161 = icmp ne ptr %135, null
  br i1 %tobool161, label %lor.lhs.false162, label %if.then166

lor.lhs.false162:                                 ; preds = %for.body143
  %136 = load ptr, ptr %r, align 8
  %type163 = getelementptr inbounds %struct.redisReply, ptr %136, i32 0, i32 0
  %137 = load i32, ptr %type163, align 8
  %cmp164 = icmp eq i32 %137, 6
  br i1 %cmp164, label %if.then166, label %if.end174

if.then166:                                       ; preds = %lor.lhs.false162, %for.body143
  %138 = load ptr, ptr %r, align 8
  %tobool167 = icmp ne ptr %138, null
  br i1 %tobool167, label %land.lhs.true168, label %if.end173

land.lhs.true168:                                 ; preds = %if.then166
  %139 = load ptr, ptr %r, align 8
  %str169 = getelementptr inbounds %struct.redisReply, ptr %139, i32 0, i32 4
  %140 = load ptr, ptr %str169, align 8
  %tobool170 = icmp ne ptr %140, null
  br i1 %tobool170, label %if.then171, label %if.end173

if.then171:                                       ; preds = %land.lhs.true168
  %141 = load ptr, ptr %src_ip, align 8
  %142 = load i32, ptr %src_port, align 4
  %143 = load ptr, ptr %r, align 8
  %str172 = getelementptr inbounds %struct.redisReply, ptr %143, i32 0, i32 4
  %144 = load ptr, ptr %str172, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.413, ptr noundef %141, i32 noundef %142, ptr noundef %144)
  br label %if.end173

if.end173:                                        ; preds = %if.then171, %land.lhs.true168, %if.then166
  store i32 0, ptr %success, align 4
  br label %if.end174

if.end174:                                        ; preds = %if.end173, %lor.lhs.false162
  %145 = load ptr, ptr %r, align 8
  call void @freeReplyObject(ptr noundef %145)
  %146 = load i32, ptr %success, align 4
  %tobool175 = icmp ne i32 %146, 0
  br i1 %tobool175, label %if.end177, label %if.then176

if.then176:                                       ; preds = %if.end174
  br label %cleanup

if.end177:                                        ; preds = %if.end174
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 4, ptr noundef @.str.414)
  br label %for.inc178

for.inc178:                                       ; preds = %if.end177
  %147 = load i32, ptr %i, align 4
  %inc179 = add nsw i32 %147, 1
  store i32 %inc179, ptr %i, align 4
  br label %for.cond140, !llvm.loop !56

for.end180:                                       ; preds = %for.cond140
  br label %while.cond92, !llvm.loop !57

while.end181:                                     ; preds = %while.cond92
  br label %cleanup

cleanup:                                          ; preds = %while.end181, %if.then176, %if.end113, %if.end53, %if.then39, %if.end34, %if.then24, %if.then18
  %148 = load ptr, ptr %reply_err, align 8
  %tobool182 = icmp ne ptr %148, null
  br i1 %tobool182, label %if.then183, label %if.end184

if.then183:                                       ; preds = %cleanup
  %149 = load ptr, ptr %src_ip, align 8
  %150 = load i32, ptr %src_port, align 4
  %151 = load ptr, ptr %reply_err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.413, ptr noundef %149, i32 noundef %150, ptr noundef %151)
  br label %if.end184

if.end184:                                        ; preds = %if.then183, %cleanup
  %152 = load ptr, ptr %src_ctx, align 8
  %tobool185 = icmp ne ptr %152, null
  br i1 %tobool185, label %if.then186, label %if.end187

if.then186:                                       ; preds = %if.end184
  %153 = load ptr, ptr %src_ctx, align 8
  call void @redisFree(ptr noundef %153)
  br label %if.end187

if.end187:                                        ; preds = %if.then186, %if.end184
  %154 = load ptr, ptr %src_reply, align 8
  %tobool188 = icmp ne ptr %154, null
  br i1 %tobool188, label %if.then189, label %if.end190

if.then189:                                       ; preds = %if.end187
  %155 = load ptr, ptr %src_reply, align 8
  call void @freeReplyObject(ptr noundef %155)
  br label %if.end190

if.end190:                                        ; preds = %if.then189, %if.end187
  %156 = load ptr, ptr %cmdfmt, align 8
  %tobool191 = icmp ne ptr %156, null
  br i1 %tobool191, label %if.then192, label %if.end193

if.then192:                                       ; preds = %if.end190
  %157 = load ptr, ptr %cmdfmt, align 8
  call void @hi_sdsfree(ptr noundef %157)
  br label %if.end193

if.end193:                                        ; preds = %if.then192, %if.end190
  %158 = load i32, ptr %success, align 4
  store i32 %158, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then5, %if.then1, %if.then
  %159 = load ptr, ptr @stderr, align 8
  %160 = load ptr, ptr %invalid_args_msg, align 8
  %call194 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %159, ptr noundef @.str.237, ptr noundef %160)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %if.end193, %if.then14, %if.then10
  %161 = load i32, ptr %retval, align 4
  ret i32 %161
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandBackup(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %success = alloca i32, align 4
  %port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %refnode = alloca ptr, align 8
  %no_issues = alloca i32, align 4
  %cluster_errors_count = alloca i32, align 4
  %json = alloca ptr, align 8
  %first_node = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %node = alloca ptr, align 8
  %node_json = alloca ptr, align 8
  %jsonpath = alloca ptr, align 8
  %out = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 1, ptr %success, align 4
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  %0 = load ptr, ptr %argv.addr, align 8
  %call = call i32 @getClusterHostFromCmdArgs(i32 noundef 1, ptr noundef %0, ptr noundef %ip, ptr noundef %port)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %invalid_args

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ip, align 8
  %2 = load i32, ptr %port, align 4
  %call1 = call ptr @clusterManagerNewNode(ptr noundef %1, i32 noundef %2, i32 noundef 0)
  store ptr %call1, ptr %refnode, align 8
  %3 = load ptr, ptr %refnode, align 8
  %call2 = call i32 @clusterManagerLoadInfoFromNode(ptr noundef %3)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @clusterManagerCheckCluster(i32 noundef 0)
  store i32 %call6, ptr %no_issues, align 4
  %4 = load i32, ptr %no_issues, align 4
  %tobool7 = icmp ne i32 %4, 0
  br i1 %tobool7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end5
  br label %cond.end

cond.false:                                       ; preds = %if.end5
  %5 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  %len = getelementptr inbounds %struct.list, ptr %5, i32 0, i32 5
  %6 = load i64, ptr %len, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %6, %cond.false ]
  %conv = trunc i64 %cond to i32
  store i32 %conv, ptr %cluster_errors_count, align 4
  %7 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 1
  %8 = load ptr, ptr %arrayidx, align 8
  store ptr %8, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 15), align 8
  %call8 = call ptr @hi_sdsnew(ptr noundef @.str.433)
  store ptr %call8, ptr %json, align 8
  store i32 0, ptr %first_node, align 4
  %9 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %9, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end20, %if.then19, %cond.end
  %call9 = call ptr @listNext(ptr noundef %li)
  store ptr %call9, ptr %ln, align 8
  %cmp = icmp ne ptr %call9, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load i32, ptr %first_node, align 4
  %tobool11 = icmp ne i32 %10, 0
  br i1 %tobool11, label %if.else, label %if.then12

if.then12:                                        ; preds = %while.body
  store i32 1, ptr %first_node, align 4
  br label %if.end14

if.else:                                          ; preds = %while.body
  %11 = load ptr, ptr %json, align 8
  %call13 = call ptr @hi_sdscat(ptr noundef %11, ptr noundef @.str.434)
  store ptr %call13, ptr %json, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then12
  %12 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %value, align 8
  store ptr %13, ptr %node, align 8
  %14 = load ptr, ptr %node, align 8
  %15 = load i32, ptr %cluster_errors_count, align 4
  %conv15 = sext i32 %15 to i64
  %call16 = call ptr @clusterManagerNodeGetJSON(ptr noundef %14, i64 noundef %conv15)
  store ptr %call16, ptr %node_json, align 8
  %16 = load ptr, ptr %json, align 8
  %17 = load ptr, ptr %node_json, align 8
  %call17 = call ptr @hi_sdscat(ptr noundef %16, ptr noundef %17)
  store ptr %call17, ptr %json, align 8
  %18 = load ptr, ptr %node_json, align 8
  call void @hi_sdsfree(ptr noundef %18)
  %19 = load ptr, ptr %node, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %19, i32 0, i32 10
  %20 = load ptr, ptr %replicate, align 8
  %tobool18 = icmp ne ptr %20, null
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end14
  br label %while.cond, !llvm.loop !58

if.end20:                                         ; preds = %if.end14
  %21 = load ptr, ptr %node, align 8
  %ip21 = getelementptr inbounds %struct.clusterManagerNode, ptr %21, i32 0, i32 2
  %22 = load ptr, ptr %ip21, align 8
  %23 = load ptr, ptr %node, align 8
  %port22 = getelementptr inbounds %struct.clusterManagerNode, ptr %23, i32 0, i32 3
  %24 = load i32, ptr %port22, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.435, ptr noundef %22, i32 noundef %24)
  %25 = load ptr, ptr @stdout, align 8
  %call23 = call i32 @fflush(ptr noundef %25)
  %26 = load ptr, ptr %node, align 8
  call void @getRDB(ptr noundef %26)
  br label %while.cond, !llvm.loop !58

while.end:                                        ; preds = %while.cond
  %27 = load ptr, ptr %json, align 8
  %call24 = call ptr @hi_sdscat(ptr noundef %27, ptr noundef @.str.436)
  store ptr %call24, ptr %json, align 8
  %28 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 15), align 8
  %call25 = call ptr @hi_sdsnew(ptr noundef %28)
  store ptr %call25, ptr %jsonpath, align 8
  %29 = load ptr, ptr %jsonpath, align 8
  %30 = load ptr, ptr %jsonpath, align 8
  %call26 = call i64 @hi_sdslen(ptr noundef %30)
  %sub = sub i64 %call26, 1
  %arrayidx27 = getelementptr inbounds i8, ptr %29, i64 %sub
  %31 = load i8, ptr %arrayidx27, align 1
  %conv28 = sext i8 %31 to i32
  %cmp29 = icmp ne i32 %conv28, 47
  br i1 %cmp29, label %if.then31, label %if.end33

if.then31:                                        ; preds = %while.end
  %32 = load ptr, ptr %jsonpath, align 8
  %call32 = call ptr @hi_sdscat(ptr noundef %32, ptr noundef @.str.437)
  store ptr %call32, ptr %jsonpath, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %while.end
  %33 = load ptr, ptr %jsonpath, align 8
  %call34 = call ptr @hi_sdscat(ptr noundef %33, ptr noundef @.str.438)
  store ptr %call34, ptr %jsonpath, align 8
  %34 = load ptr, ptr @stdout, align 8
  %call35 = call i32 @fflush(ptr noundef %34)
  %35 = load ptr, ptr %jsonpath, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.439, ptr noundef %35)
  %36 = load ptr, ptr %jsonpath, align 8
  %call36 = call noalias ptr @fopen64(ptr noundef %36, ptr noundef @.str.440)
  store ptr %call36, ptr %out, align 8
  %37 = load ptr, ptr %out, align 8
  %tobool37 = icmp ne ptr %37, null
  br i1 %tobool37, label %if.end39, label %if.then38

if.then38:                                        ; preds = %if.end33
  %38 = load ptr, ptr %jsonpath, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.441, ptr noundef %38)
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end39:                                         ; preds = %if.end33
  %39 = load ptr, ptr %json, align 8
  %40 = load ptr, ptr %out, align 8
  %call40 = call i32 @fputs(ptr noundef %39, ptr noundef %40)
  %41 = load ptr, ptr %out, align 8
  %call41 = call i32 @fclose(ptr noundef %41)
  br label %cleanup

cleanup:                                          ; preds = %if.end39, %if.then38
  %42 = load ptr, ptr %json, align 8
  call void @hi_sdsfree(ptr noundef %42)
  %43 = load ptr, ptr %jsonpath, align 8
  call void @hi_sdsfree(ptr noundef %43)
  %44 = load i32, ptr %success, align 4
  %tobool42 = icmp ne i32 %44, 0
  br i1 %tobool42, label %if.then43, label %if.else47

if.then43:                                        ; preds = %cleanup
  %45 = load i32, ptr %no_issues, align 4
  %tobool44 = icmp ne i32 %45, 0
  br i1 %tobool44, label %if.end46, label %if.then45

if.then45:                                        ; preds = %if.then43
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.442)
  br label %if.end46

if.end46:                                         ; preds = %if.then45, %if.then43
  %46 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 15), align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 4, ptr noundef @.str.443, ptr noundef %46)
  br label %if.end48

if.else47:                                        ; preds = %cleanup
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 4, ptr noundef @.str.444)
  br label %if.end48

if.end48:                                         ; preds = %if.else47, %if.end46
  %47 = load i32, ptr %success, align 4
  store i32 %47, ptr %retval, align 4
  br label %return

invalid_args:                                     ; preds = %if.then
  %48 = load ptr, ptr @stderr, align 8
  %call49 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %48, ptr noundef @.str.347)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %invalid_args, %if.end48, %if.then4
  %49 = load i32, ptr %retval, align 4
  ret i32 %49
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCommandHelp(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %commands_count = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %padding = alloca i32, align 4
  %def = alloca ptr, align 8
  %namelen = alloca i32, align 4
  %padlen = alloca i32, align 4
  %optslen = alloca i32, align 4
  %p = alloca ptr, align 8
  %eos = alloca ptr, align 8
  %comma = alloca ptr, align 8
  %deflen = alloca i32, align 4
  %buf = alloca [255 x i8], align 16
  %options_count = alloca i32, align 4
  %def61 = alloca ptr, align 8
  %namelen64 = alloca i32, align 4
  %padlen68 = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 13, ptr %commands_count, align 4
  store i32 0, ptr %i, align 4
  %0 = load ptr, ptr @stdout, align 8
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str.453)
  store i32 15, ptr %padding, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc52, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %commands_count, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end54

for.body:                                         ; preds = %for.cond
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [13 x %struct.clusterManagerCommandDef], ptr @clusterManagerCommands, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %def, align 8
  %4 = load ptr, ptr %def, align 8
  %name = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %name, align 8
  %call1 = call i64 @strlen(ptr noundef %5) #12
  %conv = trunc i64 %call1 to i32
  store i32 %conv, ptr %namelen, align 4
  %6 = load i32, ptr %padding, align 4
  %7 = load i32, ptr %namelen, align 4
  %sub = sub nsw i32 %6, %7
  store i32 %sub, ptr %padlen, align 4
  %8 = load ptr, ptr @stdout, align 8
  %9 = load ptr, ptr %def, align 8
  %name2 = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %name2, align 8
  %call3 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %8, ptr noundef @.str.454, ptr noundef %10)
  store i32 0, ptr %j, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc, %for.body
  %11 = load i32, ptr %j, align 4
  %12 = load i32, ptr %padlen, align 4
  %cmp5 = icmp slt i32 %11, %12
  br i1 %cmp5, label %for.body7, label %for.end

for.body7:                                        ; preds = %for.cond4
  %13 = load ptr, ptr @stdout, align 8
  %call8 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %13, ptr noundef @.str.136)
  br label %for.inc

for.inc:                                          ; preds = %for.body7
  %14 = load i32, ptr %j, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond4, !llvm.loop !59

for.end:                                          ; preds = %for.cond4
  %15 = load ptr, ptr @stdout, align 8
  %16 = load ptr, ptr %def, align 8
  %args = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %args, align 8
  %tobool = icmp ne ptr %17, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %18 = load ptr, ptr %def, align 8
  %args9 = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %args9, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %19, %cond.true ], [ @.str.26, %cond.false ]
  %call10 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %15, ptr noundef @.str.115, ptr noundef %cond)
  %20 = load ptr, ptr %def, align 8
  %options = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %20, i32 0, i32 4
  %21 = load ptr, ptr %options, align 8
  %cmp11 = icmp ne ptr %21, null
  br i1 %cmp11, label %if.then, label %if.end51

if.then:                                          ; preds = %cond.end
  %22 = load ptr, ptr %def, align 8
  %options13 = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %options13, align 8
  %call14 = call i64 @strlen(ptr noundef %23) #12
  %conv15 = trunc i64 %call14 to i32
  store i32 %conv15, ptr %optslen, align 4
  %24 = load ptr, ptr %def, align 8
  %options16 = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %24, i32 0, i32 4
  %25 = load ptr, ptr %options16, align 8
  store ptr %25, ptr %p, align 8
  %26 = load ptr, ptr %p, align 8
  %27 = load i32, ptr %optslen, align 4
  %idx.ext = sext i32 %27 to i64
  %add.ptr = getelementptr inbounds i8, ptr %26, i64 %idx.ext
  store ptr %add.ptr, ptr %eos, align 8
  store ptr null, ptr %comma, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then
  %28 = load ptr, ptr %p, align 8
  %call17 = call ptr @strchr(ptr noundef %28, i32 noundef 44) #12
  store ptr %call17, ptr %comma, align 8
  %cmp18 = icmp ne ptr %call17, null
  br i1 %cmp18, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %29 = load ptr, ptr %comma, align 8
  %30 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %29 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %30 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv20 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv20, ptr %deflen, align 4
  %arraydecay = getelementptr inbounds [255 x i8], ptr %buf, i64 0, i64 0
  %31 = load ptr, ptr %p, align 8
  %32 = load i32, ptr %deflen, align 4
  %conv21 = sext i32 %32 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arraydecay, ptr align 1 %31, i64 %conv21, i1 false)
  %33 = load i32, ptr %deflen, align 4
  %idxprom22 = sext i32 %33 to i64
  %arrayidx23 = getelementptr inbounds [255 x i8], ptr %buf, i64 0, i64 %idxprom22
  store i8 0, ptr %arrayidx23, align 1
  store i32 0, ptr %j, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc29, %while.body
  %34 = load i32, ptr %j, align 4
  %35 = load i32, ptr %padding, align 4
  %cmp25 = icmp slt i32 %34, %35
  br i1 %cmp25, label %for.body27, label %for.end31

for.body27:                                       ; preds = %for.cond24
  %36 = load ptr, ptr @stdout, align 8
  %call28 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %36, ptr noundef @.str.136)
  br label %for.inc29

for.inc29:                                        ; preds = %for.body27
  %37 = load i32, ptr %j, align 4
  %inc30 = add nsw i32 %37, 1
  store i32 %inc30, ptr %j, align 4
  br label %for.cond24, !llvm.loop !60

for.end31:                                        ; preds = %for.cond24
  %38 = load ptr, ptr @stdout, align 8
  %arraydecay32 = getelementptr inbounds [255 x i8], ptr %buf, i64 0, i64 0
  %call33 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %38, ptr noundef @.str.455, ptr noundef %arraydecay32)
  %39 = load ptr, ptr %comma, align 8
  %add.ptr34 = getelementptr inbounds i8, ptr %39, i64 1
  store ptr %add.ptr34, ptr %p, align 8
  %40 = load ptr, ptr %p, align 8
  %41 = load ptr, ptr %eos, align 8
  %cmp35 = icmp uge ptr %40, %41
  br i1 %cmp35, label %if.then37, label %if.end

if.then37:                                        ; preds = %for.end31
  br label %while.end

if.end:                                           ; preds = %for.end31
  br label %while.cond, !llvm.loop !61

while.end:                                        ; preds = %if.then37, %while.cond
  %42 = load ptr, ptr %p, align 8
  %43 = load ptr, ptr %eos, align 8
  %cmp38 = icmp ult ptr %42, %43
  br i1 %cmp38, label %if.then40, label %if.end50

if.then40:                                        ; preds = %while.end
  store i32 0, ptr %j, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc46, %if.then40
  %44 = load i32, ptr %j, align 4
  %45 = load i32, ptr %padding, align 4
  %cmp42 = icmp slt i32 %44, %45
  br i1 %cmp42, label %for.body44, label %for.end48

for.body44:                                       ; preds = %for.cond41
  %46 = load ptr, ptr @stdout, align 8
  %call45 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %46, ptr noundef @.str.136)
  br label %for.inc46

for.inc46:                                        ; preds = %for.body44
  %47 = load i32, ptr %j, align 4
  %inc47 = add nsw i32 %47, 1
  store i32 %inc47, ptr %j, align 4
  br label %for.cond41, !llvm.loop !62

for.end48:                                        ; preds = %for.cond41
  %48 = load ptr, ptr @stdout, align 8
  %49 = load ptr, ptr %p, align 8
  %call49 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %48, ptr noundef @.str.455, ptr noundef %49)
  br label %if.end50

if.end50:                                         ; preds = %for.end48, %while.end
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %cond.end
  br label %for.inc52

for.inc52:                                        ; preds = %if.end51
  %50 = load i32, ptr %i, align 4
  %inc53 = add nsw i32 %50, 1
  store i32 %inc53, ptr %i, align 4
  br label %for.cond, !llvm.loop !63

for.end54:                                        ; preds = %for.cond
  %51 = load ptr, ptr @stdout, align 8
  %call55 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %51, ptr noundef @.str.456)
  store i32 1, ptr %options_count, align 4
  store i32 0, ptr %i, align 4
  %52 = load ptr, ptr @stdout, align 8
  %call56 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %52, ptr noundef @.str.457)
  br label %for.cond57

for.cond57:                                       ; preds = %for.inc81, %for.end54
  %53 = load i32, ptr %i, align 4
  %54 = load i32, ptr %options_count, align 4
  %cmp58 = icmp slt i32 %53, %54
  br i1 %cmp58, label %for.body60, label %for.end83

for.body60:                                       ; preds = %for.cond57
  %55 = load i32, ptr %i, align 4
  %idxprom62 = sext i32 %55 to i64
  %arrayidx63 = getelementptr inbounds [1 x %struct.clusterManagerOptionDef], ptr @clusterManagerOptions, i64 0, i64 %idxprom62
  store ptr %arrayidx63, ptr %def61, align 8
  %56 = load ptr, ptr %def61, align 8
  %name65 = getelementptr inbounds %struct.clusterManagerOptionDef, ptr %56, i32 0, i32 0
  %57 = load ptr, ptr %name65, align 8
  %call66 = call i64 @strlen(ptr noundef %57) #12
  %conv67 = trunc i64 %call66 to i32
  store i32 %conv67, ptr %namelen64, align 4
  %58 = load i32, ptr %padding, align 4
  %59 = load i32, ptr %namelen64, align 4
  %sub69 = sub nsw i32 %58, %59
  store i32 %sub69, ptr %padlen68, align 4
  %60 = load ptr, ptr @stdout, align 8
  %61 = load ptr, ptr %def61, align 8
  %name70 = getelementptr inbounds %struct.clusterManagerOptionDef, ptr %61, i32 0, i32 0
  %62 = load ptr, ptr %name70, align 8
  %call71 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %60, ptr noundef @.str.454, ptr noundef %62)
  store i32 0, ptr %j, align 4
  br label %for.cond72

for.cond72:                                       ; preds = %for.inc77, %for.body60
  %63 = load i32, ptr %j, align 4
  %64 = load i32, ptr %padlen68, align 4
  %cmp73 = icmp slt i32 %63, %64
  br i1 %cmp73, label %for.body75, label %for.end79

for.body75:                                       ; preds = %for.cond72
  %65 = load ptr, ptr @stdout, align 8
  %call76 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %65, ptr noundef @.str.136)
  br label %for.inc77

for.inc77:                                        ; preds = %for.body75
  %66 = load i32, ptr %j, align 4
  %inc78 = add nsw i32 %66, 1
  store i32 %inc78, ptr %j, align 4
  br label %for.cond72, !llvm.loop !64

for.end79:                                        ; preds = %for.cond72
  %67 = load ptr, ptr @stdout, align 8
  %68 = load ptr, ptr %def61, align 8
  %desc = getelementptr inbounds %struct.clusterManagerOptionDef, ptr %68, i32 0, i32 1
  %69 = load ptr, ptr %desc, align 8
  %call80 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %67, ptr noundef @.str.115, ptr noundef %69)
  br label %for.inc81

for.inc81:                                        ; preds = %for.end79
  %70 = load i32, ptr %i, align 4
  %inc82 = add nsw i32 %70, 1
  store i32 %inc82, ptr %i, align 4
  br label %for.cond57, !llvm.loop !65

for.end83:                                        ; preds = %for.cond57
  %71 = load ptr, ptr @stdout, align 8
  %call84 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %71, ptr noundef @.str.116)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterManagerSlotCompare(ptr noundef %slot1, ptr noundef %slot2) #0 {
entry:
  %slot1.addr = alloca ptr, align 8
  %slot2.addr = alloca ptr, align 8
  %i1 = alloca ptr, align 8
  %i2 = alloca ptr, align 8
  store ptr %slot1, ptr %slot1.addr, align 8
  store ptr %slot2, ptr %slot2.addr, align 8
  %0 = load ptr, ptr %slot1.addr, align 8
  store ptr %0, ptr %i1, align 8
  %1 = load ptr, ptr %slot2.addr, align 8
  store ptr %1, ptr %i2, align 8
  %2 = load ptr, ptr %i1, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %i2, align 8
  %5 = load ptr, ptr %4, align 8
  %call = call i32 @strcmp(ptr noundef %3, ptr noundef %5) #12
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterManagerSlotCountCompareDesc(ptr noundef %n1, ptr noundef %n2) #0 {
entry:
  %n1.addr = alloca ptr, align 8
  %n2.addr = alloca ptr, align 8
  %node1 = alloca ptr, align 8
  %node2 = alloca ptr, align 8
  store ptr %n1, ptr %n1.addr, align 8
  store ptr %n2, ptr %n2.addr, align 8
  %0 = load ptr, ptr %n1.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %node1, align 8
  %2 = load ptr, ptr %n2.addr, align 8
  %3 = load ptr, ptr %2, align 8
  store ptr %3, ptr %node2, align 8
  %4 = load ptr, ptr %node2, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 13
  %5 = load i32, ptr %slots_count, align 4
  %6 = load ptr, ptr %node1, align 8
  %slots_count1 = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 13
  %7 = load i32, ptr %slots_count1, align 4
  %sub = sub nsw i32 %5, %7
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clusterManagerCompareNodeBalance(ptr noundef %n1, ptr noundef %n2) #0 {
entry:
  %n1.addr = alloca ptr, align 8
  %n2.addr = alloca ptr, align 8
  %node1 = alloca ptr, align 8
  %node2 = alloca ptr, align 8
  store ptr %n1, ptr %n1.addr, align 8
  store ptr %n2, ptr %n2.addr, align 8
  %0 = load ptr, ptr %n1.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %node1, align 8
  %2 = load ptr, ptr %n2.addr, align 8
  %3 = load ptr, ptr %2, align 8
  store ptr %3, ptr %node2, align 8
  %4 = load ptr, ptr %node1, align 8
  %balance = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 21
  %5 = load i32, ptr %balance, align 4
  %6 = load ptr, ptr %node2, align 8
  %balance1 = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 21
  %7 = load i32, ptr %balance1, align 4
  %sub = sub nsw i32 %5, %7
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define dso_local void @showLatencyDistSamples(ptr noundef %samples, i64 noundef %tot) #0 {
entry:
  %samples.addr = alloca ptr, align 8
  %tot.addr = alloca i64, align 8
  %j = alloca i32, align 4
  %coloridx = alloca i32, align 4
  %color = alloca i32, align 4
  store ptr %samples, ptr %samples.addr, align 8
  store i64 %tot, ptr %tot.addr, align 8
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.63)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load ptr, ptr %samples.addr, align 8
  %1 = load i32, ptr %j, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.distsamples, ptr %0, i64 %idxprom
  %count = getelementptr inbounds %struct.distsamples, ptr %arrayidx, i32 0, i32 1
  %2 = load i64, ptr %count, align 8
  %conv = sitofp i64 %2 to double
  %3 = load i64, ptr %tot.addr, align 8
  %conv1 = sitofp i64 %3 to double
  %div = fdiv double %conv, %conv1
  %4 = load i32, ptr @spectrum_palette_size, align 4
  %sub = sub nsw i32 %4, 1
  %conv2 = sitofp i32 %sub to double
  %mul = fmul double %div, %conv2
  %5 = call double @llvm.ceil.f64(double %mul)
  %conv3 = fptosi double %5 to i32
  store i32 %conv3, ptr %coloridx, align 4
  %6 = load ptr, ptr @spectrum_palette, align 8
  %7 = load i32, ptr %coloridx, align 4
  %idxprom4 = sext i32 %7 to i64
  %arrayidx5 = getelementptr inbounds i32, ptr %6, i64 %idxprom4
  %8 = load i32, ptr %arrayidx5, align 4
  store i32 %8, ptr %color, align 4
  %9 = load i32, ptr %color, align 4
  %10 = load ptr, ptr %samples.addr, align 8
  %11 = load i32, ptr %j, align 4
  %idxprom6 = sext i32 %11 to i64
  %arrayidx7 = getelementptr inbounds %struct.distsamples, ptr %10, i64 %idxprom6
  %character = getelementptr inbounds %struct.distsamples, ptr %arrayidx7, i32 0, i32 2
  %12 = load i32, ptr %character, align 8
  %call8 = call i32 (ptr, ...) @printf(ptr noundef @.str.64, i32 noundef %9, i32 noundef %12)
  %13 = load ptr, ptr %samples.addr, align 8
  %14 = load i32, ptr %j, align 4
  %idxprom9 = sext i32 %14 to i64
  %arrayidx10 = getelementptr inbounds %struct.distsamples, ptr %13, i64 %idxprom9
  %count11 = getelementptr inbounds %struct.distsamples, ptr %arrayidx10, i32 0, i32 1
  store i64 0, ptr %count11, align 8
  %15 = load ptr, ptr %samples.addr, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom12 = sext i32 %16 to i64
  %arrayidx13 = getelementptr inbounds %struct.distsamples, ptr %15, i64 %idxprom12
  %max = getelementptr inbounds %struct.distsamples, ptr %arrayidx13, i32 0, i32 0
  %17 = load i64, ptr %max, align 8
  %cmp = icmp eq i64 %17, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load i32, ptr %j, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then
  %call15 = call i32 (ptr, ...) @printf(ptr noundef @.str.65)
  %19 = load ptr, ptr @stdout, align 8
  %call16 = call i32 @fflush(ptr noundef %19)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.ceil.f64(double) #8

declare i32 @fflush(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @showLatencyDistLegend() #0 {
entry:
  %j = alloca i32, align 4
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.66)
  %call1 = call i32 (ptr, ...) @printf(ptr noundef @.str.67)
  %call2 = call i32 (ptr, ...) @printf(ptr noundef @.str.68)
  %call3 = call i32 (ptr, ...) @printf(ptr noundef @.str.69)
  %call4 = call i32 (ptr, ...) @printf(ptr noundef @.str.70)
  %call5 = call i32 (ptr, ...) @printf(ptr noundef @.str.71)
  %call6 = call i32 (ptr, ...) @printf(ptr noundef @.str.72)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %1 = load i32, ptr @spectrum_palette_size, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr @spectrum_palette, align 8
  %3 = load i32, ptr %j, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds i32, ptr %2, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %call7 = call i32 (ptr, ...) @printf(ptr noundef @.str.73, i32 noundef %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %j, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %for.cond
  %call8 = call i32 (ptr, ...) @printf(ptr noundef @.str.65)
  %call9 = call i32 (ptr, ...) @printf(ptr noundef @.str.66)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @sendReplconf(ptr noundef %arg1, ptr noundef %arg2) #0 {
entry:
  %arg1.addr = alloca ptr, align 8
  %arg2.addr = alloca ptr, align 8
  %res = alloca i32, align 4
  %reply = alloca ptr, align 8
  store ptr %arg1, ptr %arg1.addr, align 8
  store ptr %arg2, ptr %arg2.addr, align 8
  store i32 1, ptr %res, align 4
  %0 = load ptr, ptr @stderr, align 8
  %1 = load ptr, ptr %arg1.addr, align 8
  %2 = load ptr, ptr %arg2.addr, align 8
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str.74, ptr noundef %1, ptr noundef %2)
  %3 = load ptr, ptr @context, align 8
  %4 = load ptr, ptr %arg1.addr, align 8
  %5 = load ptr, ptr %arg2.addr, align 8
  %call1 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %3, ptr noundef @.str.75, ptr noundef %4, ptr noundef %5)
  store ptr %call1, ptr %reply, align 8
  %6 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %6, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr @stderr, align 8
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef @.str.76)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type, align 8
  %cmp3 = icmp eq i32 %9, 6
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %10 = load ptr, ptr @stderr, align 8
  %11 = load ptr, ptr %arg1.addr, align 8
  %12 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %str, align 8
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef @.str.77, ptr noundef %11, ptr noundef %13)
  store i32 0, ptr %res, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %14 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %14)
  %15 = load i32, ptr %res, align 4
  ret i32 %15
}

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #2

declare ptr @redisCommand(ptr noundef, ptr noundef, ...) #2

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) #9

declare void @freeReplyObject(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @sendCapa() #0 {
entry:
  %call = call i32 @sendReplconf(ptr noundef @.str.78, ptr noundef @.str.79)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @sendRdbOnly() #0 {
entry:
  %call = call i32 @sendReplconf(ptr noundef @.str.80, ptr noundef @.str.81)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @sendSync(ptr noundef %c, i32 noundef %send_sync, ptr noundef %out_eof, ptr noundef %out_full_mode) #0 {
entry:
  %retval = alloca i64, align 8
  %c.addr = alloca ptr, align 8
  %send_sync.addr = alloca i32, align 4
  %out_eof.addr = alloca ptr, align 8
  %out_full_mode.addr = alloca ptr, align 8
  %buf = alloca [4096 x i8], align 16
  %p = alloca ptr, align 8
  %nread = alloca i64, align 8
  %sync_partial = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i32 %send_sync, ptr %send_sync.addr, align 4
  store ptr %out_eof, ptr %out_eof.addr, align 8
  store ptr %out_full_mode, ptr %out_full_mode.addr, align 8
  %0 = load ptr, ptr %out_full_mode.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %out_full_mode.addr, align 8
  store i32 1, ptr %1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %send_sync.addr, align 4
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr %c.addr, align 8
  %call = call i64 @cliWriteConn(ptr noundef %3, ptr noundef @.str.82, i64 noundef 6)
  %cmp = icmp ne i64 %call, 6
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.then2
  %4 = load ptr, ptr @stderr, align 8
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %4, ptr noundef @.str.83)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end5:                                          ; preds = %if.then2
  br label %if.end11

if.else:                                          ; preds = %if.end
  %5 = load ptr, ptr %c.addr, align 8
  %call6 = call i64 @cliWriteConn(ptr noundef %5, ptr noundef @.str.26, i64 noundef 0)
  %cmp7 = icmp ne i64 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.else
  %6 = load ptr, ptr @stderr, align 8
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.83)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end10:                                         ; preds = %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.end5
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  store ptr %arraydecay, ptr %p, align 8
  br label %while.body

while.body:                                       ; preds = %if.end34, %if.end11
  %7 = load ptr, ptr %c.addr, align 8
  %8 = load ptr, ptr %p, align 8
  %call12 = call i64 @readConn(ptr noundef %7, ptr noundef %8, i64 noundef 1)
  store i64 %call12, ptr %nread, align 8
  %9 = load i64, ptr %nread, align 8
  %cmp13 = icmp sle i64 %9, 0
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %while.body
  %10 = load ptr, ptr @stderr, align 8
  %call15 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef @.str.84)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end16:                                         ; preds = %while.body
  %11 = load ptr, ptr %p, align 8
  %12 = load i8, ptr %11, align 1
  %conv = sext i8 %12 to i32
  %cmp17 = icmp eq i32 %conv, 10
  br i1 %cmp17, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %if.end16
  %13 = load ptr, ptr %p, align 8
  %arraydecay19 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %cmp20 = icmp ne ptr %13, %arraydecay19
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true
  br label %while.end

if.end23:                                         ; preds = %land.lhs.true, %if.end16
  %14 = load ptr, ptr %p, align 8
  %15 = load i8, ptr %14, align 1
  %conv24 = sext i8 %15 to i32
  %cmp25 = icmp ne i32 %conv24, 10
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end23
  %16 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %16, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.end23
  %17 = load ptr, ptr %p, align 8
  %arraydecay29 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay29, i64 4096
  %add.ptr30 = getelementptr inbounds i8, ptr %add.ptr, i64 -1
  %cmp31 = icmp uge ptr %17, %add.ptr30
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end28
  br label %while.end

if.end34:                                         ; preds = %if.end28
  br label %while.body

while.end:                                        ; preds = %if.then33, %if.then22
  %18 = load ptr, ptr %p, align 8
  store i8 0, ptr %18, align 1
  %arrayidx = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %19 = load i8, ptr %arrayidx, align 16
  %conv35 = sext i8 %19 to i32
  %cmp36 = icmp eq i32 %conv35, 45
  br i1 %cmp36, label %if.then38, label %if.end41

if.then38:                                        ; preds = %while.end
  %20 = load ptr, ptr @stderr, align 8
  %arraydecay39 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %call40 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %20, ptr noundef @.str.85, ptr noundef %arraydecay39)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end41:                                         ; preds = %while.end
  %arraydecay42 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %call43 = call i32 @strncmp(ptr noundef %arraydecay42, ptr noundef @.str.86, i64 noundef 11) #12
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %lor.lhs.false, label %if.then48

lor.lhs.false:                                    ; preds = %if.end41
  %arraydecay45 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %call46 = call i32 @strncmp(ptr noundef %arraydecay45, ptr noundef @.str.87, i64 noundef 9) #12
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.end91, label %if.then48

if.then48:                                        ; preds = %lor.lhs.false, %if.end41
  %arraydecay49 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %call50 = call i32 @strncmp(ptr noundef %arraydecay49, ptr noundef @.str.87, i64 noundef 9) #12
  %tobool51 = icmp ne i32 %call50, 0
  %lnot = xor i1 %tobool51, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %sync_partial, align 4
  %21 = load ptr, ptr @stderr, align 8
  %arraydecay52 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %call53 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %21, ptr noundef @.str.88, ptr noundef %arraydecay52)
  %arraydecay54 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  store ptr %arraydecay54, ptr %p, align 8
  br label %while.body55

while.body55:                                     ; preds = %if.end83, %if.then48
  %22 = load ptr, ptr %c.addr, align 8
  %23 = load ptr, ptr %p, align 8
  %call56 = call i64 @readConn(ptr noundef %22, ptr noundef %23, i64 noundef 1)
  store i64 %call56, ptr %nread, align 8
  %24 = load i64, ptr %nread, align 8
  %cmp57 = icmp sle i64 %24, 0
  br i1 %cmp57, label %if.then59, label %if.end61

if.then59:                                        ; preds = %while.body55
  %25 = load ptr, ptr @stderr, align 8
  %call60 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %25, ptr noundef @.str.89)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end61:                                         ; preds = %while.body55
  %26 = load ptr, ptr %p, align 8
  %27 = load i8, ptr %26, align 1
  %conv62 = sext i8 %27 to i32
  %cmp63 = icmp eq i32 %conv62, 10
  br i1 %cmp63, label %land.lhs.true65, label %if.end70

land.lhs.true65:                                  ; preds = %if.end61
  %28 = load ptr, ptr %p, align 8
  %arraydecay66 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %cmp67 = icmp ne ptr %28, %arraydecay66
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %land.lhs.true65
  br label %while.end84

if.end70:                                         ; preds = %land.lhs.true65, %if.end61
  %29 = load ptr, ptr %p, align 8
  %30 = load i8, ptr %29, align 1
  %conv71 = sext i8 %30 to i32
  %cmp72 = icmp ne i32 %conv71, 10
  br i1 %cmp72, label %if.then74, label %if.end76

if.then74:                                        ; preds = %if.end70
  %31 = load ptr, ptr %p, align 8
  %incdec.ptr75 = getelementptr inbounds i8, ptr %31, i32 1
  store ptr %incdec.ptr75, ptr %p, align 8
  br label %if.end76

if.end76:                                         ; preds = %if.then74, %if.end70
  %32 = load ptr, ptr %p, align 8
  %arraydecay77 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %add.ptr78 = getelementptr inbounds i8, ptr %arraydecay77, i64 4096
  %add.ptr79 = getelementptr inbounds i8, ptr %add.ptr78, i64 -1
  %cmp80 = icmp uge ptr %32, %add.ptr79
  br i1 %cmp80, label %if.then82, label %if.end83

if.then82:                                        ; preds = %if.end76
  br label %while.end84

if.end83:                                         ; preds = %if.end76
  br label %while.body55

while.end84:                                      ; preds = %if.then82, %if.then69
  %33 = load ptr, ptr %p, align 8
  store i8 0, ptr %33, align 1
  %34 = load i32, ptr %sync_partial, align 4
  %tobool85 = icmp ne i32 %34, 0
  br i1 %tobool85, label %if.then86, label %if.end90

if.then86:                                        ; preds = %while.end84
  %35 = load ptr, ptr %out_full_mode.addr, align 8
  %tobool87 = icmp ne ptr %35, null
  br i1 %tobool87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %if.then86
  %36 = load ptr, ptr %out_full_mode.addr, align 8
  store i32 0, ptr %36, align 4
  br label %if.end89

if.end89:                                         ; preds = %if.then88, %if.then86
  store i64 0, ptr %retval, align 8
  br label %return

if.end90:                                         ; preds = %while.end84
  br label %if.end91

if.end91:                                         ; preds = %if.end90, %lor.lhs.false
  %arraydecay92 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %add.ptr93 = getelementptr inbounds i8, ptr %arraydecay92, i64 1
  %call94 = call i32 @strncmp(ptr noundef %add.ptr93, ptr noundef @.str.90, i64 noundef 4) #12
  %cmp95 = icmp eq i32 %call94, 0
  br i1 %cmp95, label %land.lhs.true97, label %if.end106

land.lhs.true97:                                  ; preds = %if.end91
  %arraydecay98 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %add.ptr99 = getelementptr inbounds i8, ptr %arraydecay98, i64 5
  %call100 = call i64 @strlen(ptr noundef %add.ptr99) #12
  %cmp101 = icmp uge i64 %call100, 40
  br i1 %cmp101, label %if.then103, label %if.end106

if.then103:                                       ; preds = %land.lhs.true97
  %37 = load ptr, ptr %out_eof.addr, align 8
  %arraydecay104 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %add.ptr105 = getelementptr inbounds i8, ptr %arraydecay104, i64 5
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %37, ptr align 1 %add.ptr105, i64 40, i1 false)
  store i64 0, ptr %retval, align 8
  br label %return

if.end106:                                        ; preds = %land.lhs.true97, %if.end91
  %arraydecay107 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %add.ptr108 = getelementptr inbounds i8, ptr %arraydecay107, i64 1
  %call109 = call i64 @strtoull(ptr noundef %add.ptr108, ptr noundef null, i32 noundef 10) #15
  store i64 %call109, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end106, %if.then103, %if.end89
  %38 = load i64, ptr %retval, align 8
  ret i64 %38
}

declare i64 @cliWriteConn(ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define internal i64 @readConn(ptr noundef %c, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %funcs = getelementptr inbounds %struct.redisContext, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %funcs, align 8
  %read = getelementptr inbounds %struct.redisContextFuncs, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %read, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %4 = load ptr, ptr %buf.addr, align 8
  %5 = load i64, ptr %len.addr, align 8
  %call = call i64 %2(ptr noundef %3, ptr noundef %4, i64 noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strncmp(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #1

; Function Attrs: nounwind
declare i64 @strtoull(ptr noundef, ptr noundef, i32 noundef) #6

; Function Attrs: nounwind uwtable
define dso_local void @type_free(ptr noundef %d, ptr noundef %val) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %info = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %val.addr, align 8
  store ptr %0, ptr %info, align 8
  %1 = load ptr, ptr %info, align 8
  %biggest_key = getelementptr inbounds %struct.typeinfo, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %biggest_key, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %info, align 8
  %biggest_key1 = getelementptr inbounds %struct.typeinfo, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %biggest_key1, align 8
  call void @hi_sdsfree(ptr noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %info, align 8
  %name = getelementptr inbounds %struct.typeinfo, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %name, align 8
  call void @hi_sdsfree(ptr noundef %6)
  %7 = load ptr, ptr %info, align 8
  call void @zfree(ptr noundef %7)
  ret void
}

declare void @zfree(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @bytesToHuman(ptr noundef %s, i64 noundef %size, i64 noundef %n) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %n.addr = alloca i64, align 8
  %d = alloca double, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp slt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  store i8 45, ptr %1, align 1
  %2 = load ptr, ptr %s.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %s.addr, align 8
  %3 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %3
  store i64 %sub, ptr %n.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i64, ptr %n.addr, align 8
  %cmp1 = icmp slt i64 %4, 1024
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i64, ptr %size.addr, align 8
  %7 = load i64, ptr %n.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %5, i64 noundef %6, ptr noundef @.str.110, i64 noundef %7) #15
  br label %if.end23

if.else:                                          ; preds = %if.end
  %8 = load i64, ptr %n.addr, align 8
  %cmp3 = icmp slt i64 %8, 1048576
  br i1 %cmp3, label %if.then4, label %if.else6

if.then4:                                         ; preds = %if.else
  %9 = load i64, ptr %n.addr, align 8
  %conv = sitofp i64 %9 to double
  %div = fdiv double %conv, 1.024000e+03
  store double %div, ptr %d, align 8
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i64, ptr %size.addr, align 8
  %12 = load double, ptr %d, align 8
  %call5 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %10, i64 noundef %11, ptr noundef @.str.111, double noundef %12) #15
  br label %if.end22

if.else6:                                         ; preds = %if.else
  %13 = load i64, ptr %n.addr, align 8
  %cmp7 = icmp slt i64 %13, 1073741824
  br i1 %cmp7, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.else6
  %14 = load i64, ptr %n.addr, align 8
  %conv10 = sitofp i64 %14 to double
  %div11 = fdiv double %conv10, 0x4130000000000000
  store double %div11, ptr %d, align 8
  %15 = load ptr, ptr %s.addr, align 8
  %16 = load i64, ptr %size.addr, align 8
  %17 = load double, ptr %d, align 8
  %call12 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %15, i64 noundef %16, ptr noundef @.str.112, double noundef %17) #15
  br label %if.end21

if.else13:                                        ; preds = %if.else6
  %18 = load i64, ptr %n.addr, align 8
  %cmp14 = icmp slt i64 %18, 1099511627776
  br i1 %cmp14, label %if.then16, label %if.end20

if.then16:                                        ; preds = %if.else13
  %19 = load i64, ptr %n.addr, align 8
  %conv17 = sitofp i64 %19 to double
  %div18 = fdiv double %conv17, 0x41D0000000000000
  store double %div18, ptr %d, align 8
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load i64, ptr %size.addr, align 8
  %22 = load double, ptr %d, align 8
  %call19 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %20, i64 noundef %21, ptr noundef @.str.113, double noundef %22) #15
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %if.else13
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then9
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then4
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then2
  ret void
}

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #6

; Function Attrs: nounwind uwtable
define dso_local i64 @powerLawRand(i64 noundef %min, i64 noundef %max, double noundef %alpha) #0 {
entry:
  %min.addr = alloca i64, align 8
  %max.addr = alloca i64, align 8
  %alpha.addr = alloca double, align 8
  %pl = alloca double, align 8
  %r = alloca double, align 8
  store i64 %min, ptr %min.addr, align 8
  store i64 %max, ptr %max.addr, align 8
  store double %alpha, ptr %alpha.addr, align 8
  %0 = load i64, ptr %max.addr, align 8
  %add = add nsw i64 %0, 1
  store i64 %add, ptr %max.addr, align 8
  %call = call i32 @rand() #15
  %conv = sitofp i32 %call to double
  %div = fdiv double %conv, 0x41DFFFFFFFC00000
  store double %div, ptr %r, align 8
  %1 = load i64, ptr %max.addr, align 8
  %conv1 = sitofp i64 %1 to double
  %2 = load double, ptr %alpha.addr, align 8
  %add2 = fadd double %2, 1.000000e+00
  %call3 = call double @pow(double noundef %conv1, double noundef %add2) #15
  %3 = load i64, ptr %min.addr, align 8
  %conv4 = sitofp i64 %3 to double
  %4 = load double, ptr %alpha.addr, align 8
  %add5 = fadd double %4, 1.000000e+00
  %call6 = call double @pow(double noundef %conv4, double noundef %add5) #15
  %sub = fsub double %call3, %call6
  %5 = load double, ptr %r, align 8
  %6 = load i64, ptr %min.addr, align 8
  %conv7 = sitofp i64 %6 to double
  %7 = load double, ptr %alpha.addr, align 8
  %add8 = fadd double %7, 1.000000e+00
  %call9 = call double @pow(double noundef %conv7, double noundef %add8) #15
  %8 = call double @llvm.fmuladd.f64(double %sub, double %5, double %call9)
  %9 = load double, ptr %alpha.addr, align 8
  %add10 = fadd double %9, 1.000000e+00
  %div11 = fdiv double 1.000000e+00, %add10
  %call12 = call double @pow(double noundef %8, double noundef %div11) #15
  store double %call12, ptr %pl, align 8
  %10 = load i64, ptr %max.addr, align 8
  %sub13 = sub nsw i64 %10, 1
  %11 = load double, ptr %pl, align 8
  %conv14 = fptosi double %11 to i64
  %sub15 = sub nsw i64 %sub13, %conv14
  %12 = load i64, ptr %min.addr, align 8
  %add16 = add nsw i64 %sub15, %12
  ret i64 %add16
}

; Function Attrs: nounwind
declare i32 @rand() #6

; Function Attrs: nounwind
declare double @pow(double noundef, double noundef) #6

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #8

; Function Attrs: nounwind uwtable
define dso_local void @LRUTestGenKey(ptr noundef %buf, i64 noundef %buflen) #0 {
entry:
  %buf.addr = alloca ptr, align 8
  %buflen.addr = alloca i64, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %buflen, ptr %buflen.addr, align 8
  %0 = load ptr, ptr %buf.addr, align 8
  %1 = load i64, ptr %buflen.addr, align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 16), align 8
  %call = call i64 @powerLawRand(i64 noundef 1, i64 noundef %2, double noundef 6.200000e+00)
  %call1 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %0, i64 noundef %1, ptr noundef @.str.114, i64 noundef %call) #15
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @compute_something_fast() #0 {
entry:
  %s = alloca [256 x i8], align 16
  %i = alloca i8, align 1
  %j = alloca i8, align 1
  %t = alloca i8, align 1
  %count = alloca i32, align 4
  %k = alloca i32, align 4
  %output = alloca i64, align 8
  store i32 1000, ptr %count, align 4
  store i64 0, ptr %output, align 8
  store i32 0, ptr %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %k, align 4
  %cmp = icmp slt i32 %0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %k, align 4
  %conv = trunc i32 %1 to i8
  %2 = load i32, ptr %k, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom
  store i8 %conv, ptr %arrayidx, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %k, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %k, align 4
  br label %for.cond, !llvm.loop !67

for.end:                                          ; preds = %for.cond
  store i8 0, ptr %i, align 1
  store i8 0, ptr %j, align 1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %4 = load i32, ptr %count, align 4
  %dec = add nsw i32 %4, -1
  store i32 %dec, ptr %count, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i8, ptr %i, align 1
  %inc1 = add i8 %5, 1
  store i8 %inc1, ptr %i, align 1
  %6 = load i8, ptr %j, align 1
  %conv2 = zext i8 %6 to i32
  %7 = load i8, ptr %i, align 1
  %idxprom3 = zext i8 %7 to i64
  %arrayidx4 = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom3
  %8 = load i8, ptr %arrayidx4, align 1
  %conv5 = zext i8 %8 to i32
  %add = add nsw i32 %conv2, %conv5
  %conv6 = trunc i32 %add to i8
  store i8 %conv6, ptr %j, align 1
  %9 = load i8, ptr %i, align 1
  %idxprom7 = zext i8 %9 to i64
  %arrayidx8 = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom7
  %10 = load i8, ptr %arrayidx8, align 1
  store i8 %10, ptr %t, align 1
  %11 = load i8, ptr %j, align 1
  %idxprom9 = zext i8 %11 to i64
  %arrayidx10 = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom9
  %12 = load i8, ptr %arrayidx10, align 1
  %13 = load i8, ptr %i, align 1
  %idxprom11 = zext i8 %13 to i64
  %arrayidx12 = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom11
  store i8 %12, ptr %arrayidx12, align 1
  %14 = load i8, ptr %t, align 1
  %15 = load i8, ptr %j, align 1
  %idxprom13 = zext i8 %15 to i64
  %arrayidx14 = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom13
  store i8 %14, ptr %arrayidx14, align 1
  %16 = load i8, ptr %i, align 1
  %idxprom15 = zext i8 %16 to i64
  %arrayidx16 = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom15
  %17 = load i8, ptr %arrayidx16, align 1
  %conv17 = zext i8 %17 to i32
  %18 = load i8, ptr %j, align 1
  %idxprom18 = zext i8 %18 to i64
  %arrayidx19 = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom18
  %19 = load i8, ptr %arrayidx19, align 1
  %conv20 = zext i8 %19 to i32
  %add21 = add nsw i32 %conv17, %conv20
  %and = and i32 %add21, 255
  %idxprom22 = sext i32 %and to i64
  %arrayidx23 = getelementptr inbounds [256 x i8], ptr %s, i64 0, i64 %idxprom22
  %20 = load i8, ptr %arrayidx23, align 1
  %conv24 = zext i8 %20 to i64
  %21 = load i64, ptr %output, align 8
  %add25 = add i64 %21, %conv24
  store i64 %add25, ptr %output, align 8
  br label %while.cond, !llvm.loop !68

while.end:                                        ; preds = %while.cond
  %22 = load i64, ptr %output, align 8
  ret i64 %22
}

; Function Attrs: nounwind uwtable
define dso_local void @testHint(ptr noundef %input) #0 {
entry:
  %input.addr = alloca ptr, align 8
  %hint = alloca ptr, align 8
  store ptr %input, ptr %input.addr, align 8
  call void @cliInitHelp()
  %0 = load ptr, ptr %input.addr, align 8
  %call = call ptr @getHintForInput(ptr noundef %0)
  store ptr %call, ptr %hint, align 8
  %1 = load ptr, ptr %hint, align 8
  %call1 = call i32 (ptr, ...) @printf(ptr noundef @.str.115, ptr noundef %1)
  call void @exit(i32 noundef 0) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal void @cliInitHelp() #0 {
entry:
  %groupsdt = alloca %struct.dictType, align 8
  %commandTable = alloca ptr, align 8
  %groups = alloca ptr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %groupsdt, ptr align 8 @__const.cliInitHelp.groupsdt, i64 88, i1 false)
  %call = call i32 @cliConnect(i32 noundef 2)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call ptr @dictCreate(ptr noundef %groupsdt)
  store ptr %call1, ptr %groups, align 8
  %0 = load ptr, ptr %groups, align 8
  call void @cliLegacyInitHelp(ptr noundef %0)
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @context, align 8
  %call2 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.458)
  store ptr %call2, ptr %commandTable, align 8
  %2 = load ptr, ptr %commandTable, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load ptr, ptr %commandTable, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type, align 8
  %cmp4 = icmp eq i32 %4, 6
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %5 = load ptr, ptr %commandTable, align 8
  call void @freeReplyObject(ptr noundef %5)
  %call6 = call ptr @dictCreate(ptr noundef %groupsdt)
  store ptr %call6, ptr %groups, align 8
  %6 = load ptr, ptr %groups, align 8
  call void @cliLegacyInitHelp(ptr noundef %6)
  call void @cliLegacyIntegrateHelp()
  br label %return

if.end7:                                          ; preds = %lor.lhs.false
  %7 = load ptr, ptr %commandTable, align 8
  %type8 = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type8, align 8
  %cmp9 = icmp ne i32 %8, 9
  br i1 %cmp9, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end7
  %9 = load ptr, ptr %commandTable, align 8
  %type10 = getelementptr inbounds %struct.redisReply, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type10, align 8
  %cmp11 = icmp ne i32 %10, 2
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %land.lhs.true
  br label %return

if.end13:                                         ; preds = %land.lhs.true, %if.end7
  %11 = load ptr, ptr %commandTable, align 8
  %call14 = call i64 @cliCountCommands(ptr noundef %11)
  %conv = trunc i64 %call14 to i32
  store i32 %conv, ptr @helpEntriesLen, align 4
  %12 = load i32, ptr @helpEntriesLen, align 4
  %conv15 = sext i32 %12 to i64
  %mul = mul i64 88, %conv15
  %call16 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call16, ptr @helpEntries, align 8
  %call17 = call ptr @dictCreate(ptr noundef %groupsdt)
  store ptr %call17, ptr %groups, align 8
  %13 = load ptr, ptr %commandTable, align 8
  %14 = load ptr, ptr %groups, align 8
  call void @cliInitCommandHelpEntries(ptr noundef %13, ptr noundef %14)
  %15 = load ptr, ptr %groups, align 8
  call void @cliInitGroupHelpEntries(ptr noundef %15)
  %16 = load ptr, ptr @helpEntries, align 8
  %17 = load i32, ptr @helpEntriesLen, align 4
  %conv18 = sext i32 %17 to i64
  call void @qsort(ptr noundef %16, i64 noundef %conv18, i64 noundef 88, ptr noundef @helpEntryCompare)
  %18 = load ptr, ptr %commandTable, align 8
  call void @freeReplyObject(ptr noundef %18)
  %19 = load ptr, ptr %groups, align 8
  call void @dictRelease(ptr noundef %19)
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then5, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @getHintForInput(ptr noundef %charinput) #0 {
entry:
  %charinput.addr = alloca ptr, align 8
  %hint = alloca ptr, align 8
  %inputargc = alloca i32, align 4
  %inputlen = alloca i32, align 4
  %inputargv = alloca ptr, align 8
  %endspace = alloca i32, align 4
  %matchargc = alloca i32, align 4
  %entry10 = alloca ptr, align 8
  store ptr %charinput, ptr %charinput.addr, align 8
  store ptr null, ptr %hint, align 8
  %0 = load ptr, ptr %charinput.addr, align 8
  %call = call i64 @strlen(ptr noundef %0) #12
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %inputlen, align 4
  %1 = load ptr, ptr %charinput.addr, align 8
  %call1 = call ptr @hi_sdssplitargs(ptr noundef %1, ptr noundef %inputargc)
  store ptr %call1, ptr %inputargv, align 8
  %2 = load i32, ptr %inputlen, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call2 = call ptr @__ctype_b_loc() #16
  %3 = load ptr, ptr %call2, align 8
  %4 = load ptr, ptr %charinput.addr, align 8
  %5 = load i32, ptr %inputlen, align 4
  %sub = sub nsw i32 %5, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds i8, ptr %4, i64 %idxprom
  %6 = load i8, ptr %arrayidx, align 1
  %conv3 = sext i8 %6 to i32
  %idxprom4 = sext i32 %conv3 to i64
  %arrayidx5 = getelementptr inbounds i16, ptr %3, i64 %idxprom4
  %7 = load i16, ptr %arrayidx5, align 2
  %conv6 = zext i16 %7 to i32
  %and = and i32 %conv6, 8192
  %tobool7 = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool7, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  store i32 %land.ext, ptr %endspace, align 4
  %9 = load i32, ptr %endspace, align 4
  %tobool8 = icmp ne i32 %9, 0
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %10 = load i32, ptr %inputargc, align 4
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %11 = load i32, ptr %inputargc, align 4
  %sub9 = sub nsw i32 %11, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %sub9, %cond.false ]
  store i32 %cond, ptr %matchargc, align 4
  %12 = load i32, ptr %matchargc, align 4
  %13 = load ptr, ptr %inputargv, align 8
  %call11 = call ptr @findHelpEntry(i32 noundef %12, ptr noundef %13)
  store ptr %call11, ptr %entry10, align 8
  %14 = load ptr, ptr %entry10, align 8
  %tobool12 = icmp ne ptr %14, null
  br i1 %tobool12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %15 = load ptr, ptr %inputargv, align 8
  %16 = load i32, ptr %matchargc, align 4
  %17 = load ptr, ptr %entry10, align 8
  %argc = getelementptr inbounds %struct.helpEntry, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %argc, align 4
  %19 = load ptr, ptr %entry10, align 8
  %docs = getelementptr inbounds %struct.helpEntry, ptr %19, i32 0, i32 4
  %call13 = call ptr @makeHint(ptr noundef %15, i32 noundef %16, i32 noundef %18, ptr noundef byval(%struct.commandDocs) align 8 %docs)
  store ptr %call13, ptr %hint, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %20 = load ptr, ptr %inputargv, align 8
  %21 = load i32, ptr %inputargc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %20, i32 noundef %21)
  %22 = load ptr, ptr %hint, align 8
  ret ptr %22
}

; Function Attrs: nounwind uwtable
define dso_local ptr @readHintSuiteLine(ptr noundef %buf, i64 noundef %size, ptr noundef %fp) #0 {
entry:
  %retval = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %fp.addr = alloca ptr, align 8
  %input = alloca ptr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store ptr %fp, ptr %fp.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load ptr, ptr %buf.addr, align 8
  %1 = load i64, ptr %size.addr, align 8
  %conv = trunc i64 %1 to i32
  %2 = load ptr, ptr %fp.addr, align 8
  %call = call ptr @fgets(ptr noundef %0, i32 noundef %conv, ptr noundef %2)
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %buf.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %3, i64 0
  %4 = load i8, ptr %arrayidx, align 1
  %conv2 = sext i8 %4 to i32
  %cmp3 = icmp ne i32 %conv2, 35
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %5 = load ptr, ptr %buf.addr, align 8
  %call5 = call ptr @hi_sdsnew(ptr noundef %5)
  store ptr %call5, ptr %input, align 8
  %6 = load ptr, ptr %input, align 8
  %call6 = call ptr @hi_sdstrim(ptr noundef %6, ptr noundef @.str.116)
  store ptr %call6, ptr %input, align 8
  %7 = load ptr, ptr %input, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %while.body
  br label %while.cond, !llvm.loop !69

while.end:                                        ; preds = %while.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

declare ptr @hi_sdsnew(ptr noundef) #2

declare ptr @hi_sdstrim(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @testHintSuite(ptr noundef %filename) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %fp = alloca ptr, align 8
  %buf = alloca [256 x i8], align 16
  %line = alloca ptr, align 8
  %input = alloca ptr, align 8
  %expected = alloca ptr, align 8
  %hint = alloca ptr, align 8
  %pass = alloca i32, align 4
  %fail = alloca i32, align 4
  %argc = alloca i32, align 4
  %argv = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store i32 0, ptr %pass, align 4
  store i32 0, ptr %fail, align 4
  %0 = load ptr, ptr %filename.addr, align 8
  %call = call noalias ptr @fopen64(ptr noundef %0, ptr noundef @.str.31)
  store ptr %call, ptr %fp, align 8
  %1 = load ptr, ptr %fp, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @stderr, align 8
  %3 = load ptr, ptr %filename.addr, align 8
  %call1 = call ptr @__errno_location() #16
  %4 = load i32, ptr %call1, align 4
  %call2 = call ptr @strerror(i32 noundef %4) #15
  %call3 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef @.str.117, ptr noundef %3, ptr noundef %call2)
  call void @exit(i32 noundef -1) #17
  unreachable

if.end:                                           ; preds = %entry
  call void @cliInitHelp()
  br label %while.body

while.body:                                       ; preds = %if.end43, %if.then9, %if.end
  %arraydecay = getelementptr inbounds [256 x i8], ptr %buf, i64 0, i64 0
  %5 = load ptr, ptr %fp, align 8
  %call4 = call ptr @readHintSuiteLine(ptr noundef %arraydecay, i64 noundef 256, ptr noundef %5)
  store ptr %call4, ptr %line, align 8
  %6 = load ptr, ptr %line, align 8
  %cmp = icmp eq ptr %6, null
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %while.body
  br label %while.end44

if.end6:                                          ; preds = %while.body
  %7 = load ptr, ptr %line, align 8
  %call7 = call ptr @hi_sdssplitargs(ptr noundef %7, ptr noundef %argc)
  store ptr %call7, ptr %argv, align 8
  %8 = load ptr, ptr %line, align 8
  call void @hi_sdsfree(ptr noundef %8)
  %9 = load i32, ptr %argc, align 4
  %cmp8 = icmp eq i32 %9, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  %10 = load ptr, ptr %argv, align 8
  %11 = load i32, ptr %argc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %10, i32 noundef %11)
  br label %while.body

if.end10:                                         ; preds = %if.end6
  %12 = load i32, ptr %argc, align 4
  %cmp11 = icmp eq i32 %12, 1
  br i1 %cmp11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %13 = load ptr, ptr @stderr, align 8
  %14 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %14, i64 0
  %15 = load ptr, ptr %arrayidx, align 8
  %call13 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %13, ptr noundef @.str.118, ptr noundef %15)
  call void @exit(i32 noundef -1) #17
  unreachable

if.end14:                                         ; preds = %if.end10
  %16 = load ptr, ptr %argv, align 8
  %arrayidx15 = getelementptr inbounds ptr, ptr %16, i64 0
  %17 = load ptr, ptr %arrayidx15, align 8
  store ptr %17, ptr %input, align 8
  %18 = load ptr, ptr %argv, align 8
  %arrayidx16 = getelementptr inbounds ptr, ptr %18, i64 1
  %19 = load ptr, ptr %arrayidx16, align 8
  store ptr %19, ptr %expected, align 8
  %20 = load ptr, ptr %input, align 8
  %call17 = call ptr @getHintForInput(ptr noundef %20)
  store ptr %call17, ptr %hint, align 8
  %21 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 53), align 8
  %tobool18 = icmp ne i32 %21, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end14
  %22 = load ptr, ptr %input, align 8
  %23 = load ptr, ptr %expected, align 8
  %24 = load ptr, ptr %hint, align 8
  %call20 = call i32 (ptr, ...) @printf(ptr noundef @.str.119, ptr noundef %22, ptr noundef %23, ptr noundef %24)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end14
  br label %while.cond22

while.cond22:                                     ; preds = %while.body30, %if.end21
  %25 = load ptr, ptr %hint, align 8
  %cmp23 = icmp ne ptr %25, null
  br i1 %cmp23, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %while.cond22
  %26 = load ptr, ptr %hint, align 8
  %call24 = call i64 @hi_sdslen(ptr noundef %26)
  %cmp25 = icmp ugt i64 %call24, 0
  br i1 %cmp25, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %27 = load ptr, ptr %hint, align 8
  %28 = load ptr, ptr %hint, align 8
  %call26 = call i64 @hi_sdslen(ptr noundef %28)
  %sub = sub i64 %call26, 1
  %arrayidx27 = getelementptr inbounds i8, ptr %27, i64 %sub
  %29 = load i8, ptr %arrayidx27, align 1
  %conv = sext i8 %29 to i32
  %cmp28 = icmp eq i32 %conv, 32
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %while.cond22
  %30 = phi i1 [ false, %land.lhs.true ], [ false, %while.cond22 ], [ %cmp28, %land.rhs ]
  br i1 %30, label %while.body30, label %while.end

while.body30:                                     ; preds = %land.end
  %31 = load ptr, ptr %hint, align 8
  %32 = load ptr, ptr %hint, align 8
  %call31 = call i64 @hi_sdslen(ptr noundef %32)
  %sub32 = sub i64 %call31, 1
  call void @hi_sdssetlen(ptr noundef %31, i64 noundef %sub32)
  %33 = load ptr, ptr %hint, align 8
  %34 = load ptr, ptr %hint, align 8
  %call33 = call i64 @hi_sdslen(ptr noundef %34)
  %arrayidx34 = getelementptr inbounds i8, ptr %33, i64 %call33
  store i8 0, ptr %arrayidx34, align 1
  br label %while.cond22, !llvm.loop !70

while.end:                                        ; preds = %land.end
  %35 = load ptr, ptr %hint, align 8
  %cmp35 = icmp eq ptr %35, null
  br i1 %cmp35, label %if.then40, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %36 = load ptr, ptr %hint, align 8
  %37 = load ptr, ptr %expected, align 8
  %call37 = call i32 @strcmp(ptr noundef %36, ptr noundef %37) #12
  %cmp38 = icmp ne i32 %call37, 0
  br i1 %cmp38, label %if.then40, label %if.else

if.then40:                                        ; preds = %lor.lhs.false, %while.end
  %38 = load ptr, ptr @stderr, align 8
  %39 = load ptr, ptr %input, align 8
  %40 = load ptr, ptr %expected, align 8
  %41 = load ptr, ptr %hint, align 8
  %call41 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %38, ptr noundef @.str.120, ptr noundef %39, ptr noundef %40, ptr noundef %41)
  %42 = load i32, ptr %fail, align 4
  %inc = add nsw i32 %42, 1
  store i32 %inc, ptr %fail, align 4
  br label %if.end43

if.else:                                          ; preds = %lor.lhs.false
  %43 = load i32, ptr %pass, align 4
  %inc42 = add nsw i32 %43, 1
  store i32 %inc42, ptr %pass, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.else, %if.then40
  %44 = load ptr, ptr %argv, align 8
  %45 = load i32, ptr %argc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %44, i32 noundef %45)
  %46 = load ptr, ptr %hint, align 8
  call void @hi_sdsfree(ptr noundef %46)
  br label %while.body

while.end44:                                      ; preds = %if.then5
  %47 = load ptr, ptr %fp, align 8
  %call45 = call i32 @fclose(ptr noundef %47)
  %48 = load i32, ptr %fail, align 4
  %cmp46 = icmp eq i32 %48, 0
  %cond = select i1 %cmp46, ptr @.str.122, ptr @.str.123
  %49 = load i32, ptr %pass, align 4
  %50 = load i32, ptr %pass, align 4
  %51 = load i32, ptr %fail, align 4
  %add = add nsw i32 %50, %51
  %call48 = call i32 (ptr, ...) @printf(ptr noundef @.str.121, ptr noundef %cond, i32 noundef %49, i32 noundef %add)
  %52 = load i32, ptr %fail, align 4
  call void @exit(i32 noundef %52) #17
  unreachable
}

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) #6

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #7

; Function Attrs: nounwind uwtable
define internal i64 @hi_sdslen(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %flags = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %flags, align 1
  %2 = load i8, ptr %flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %3 = load i8, ptr %flags, align 1
  %conv1 = zext i8 %3 to i32
  %shr = ashr i32 %conv1, 3
  %conv2 = sext i32 %shr to i64
  store i64 %conv2, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 -3
  %len = getelementptr inbounds %struct.hisdshdr8, ptr %add.ptr, i32 0, i32 0
  %5 = load i8, ptr %len, align 1
  %conv4 = zext i8 %5 to i64
  store i64 %conv4, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  %6 = load ptr, ptr %s.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, ptr %6, i64 -5
  %len7 = getelementptr inbounds %struct.hisdshdr16, ptr %add.ptr6, i32 0, i32 0
  %7 = load i16, ptr %len7, align 1
  %conv8 = zext i16 %7 to i64
  store i64 %conv8, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, ptr %8, i64 -9
  %len11 = getelementptr inbounds %struct.hisdshdr32, ptr %add.ptr10, i32 0, i32 0
  %9 = load i32, ptr %len11, align 1
  %conv12 = zext i32 %9 to i64
  store i64 %conv12, ptr %retval, align 8
  br label %return

sw.bb13:                                          ; preds = %entry
  %10 = load ptr, ptr %s.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, ptr %10, i64 -17
  %len15 = getelementptr inbounds %struct.hisdshdr64, ptr %add.ptr14, i32 0, i32 0
  %11 = load i64, ptr %len15, align 1
  store i64 %11, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define internal void @hi_sdssetlen(ptr noundef %s, i64 noundef %newlen) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %newlen.addr = alloca i64, align 8
  %flags = alloca i8, align 1
  %fp = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %newlen, ptr %newlen.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %flags, align 1
  %2 = load i8, ptr %flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb2
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 -1
  store ptr %add.ptr, ptr %fp, align 8
  %4 = load i64, ptr %newlen.addr, align 8
  %shl = shl i64 %4, 3
  %or = or i64 0, %shl
  %conv1 = trunc i64 %or to i8
  %5 = load ptr, ptr %fp, align 8
  store i8 %conv1, ptr %5, align 1
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %6 = load i64, ptr %newlen.addr, align 8
  %conv3 = trunc i64 %6 to i8
  %7 = load ptr, ptr %s.addr, align 8
  %add.ptr4 = getelementptr inbounds i8, ptr %7, i64 -3
  %len = getelementptr inbounds %struct.hisdshdr8, ptr %add.ptr4, i32 0, i32 0
  store i8 %conv3, ptr %len, align 1
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %8 = load i64, ptr %newlen.addr, align 8
  %conv6 = trunc i64 %8 to i16
  %9 = load ptr, ptr %s.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, ptr %9, i64 -5
  %len8 = getelementptr inbounds %struct.hisdshdr16, ptr %add.ptr7, i32 0, i32 0
  store i16 %conv6, ptr %len8, align 1
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %10 = load i64, ptr %newlen.addr, align 8
  %conv10 = trunc i64 %10 to i32
  %11 = load ptr, ptr %s.addr, align 8
  %add.ptr11 = getelementptr inbounds i8, ptr %11, i64 -9
  %len12 = getelementptr inbounds %struct.hisdshdr32, ptr %add.ptr11, i32 0, i32 0
  store i32 %conv10, ptr %len12, align 1
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  %12 = load i64, ptr %newlen.addr, align 8
  %13 = load ptr, ptr %s.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, ptr %13, i64 -17
  %len15 = getelementptr inbounds %struct.hisdshdr64, ptr %add.ptr14, i32 0, i32 0
  store i64 %12, ptr %len15, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb2, %sw.bb, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @main(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %firstarg = alloca i32, align 4
  %tv = alloca %struct.timeval, align 8
  %proc = alloca ptr, align 8
  store i32 0, ptr %retval, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 3), i8 0, i64 64, i1 false)
  %call = call ptr @hi_sdsnew(ptr noundef @.str.124)
  store ptr %call, ptr @config, align 8
  store i32 6379, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  store i64 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 4), align 8
  store i64 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  store i32 0, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 7), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 8), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 9), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 11), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 12), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 13), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 14), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 15), align 4
  store i64 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 16), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 17), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 19), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 20), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 23), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 24), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 25), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 26), align 4
  store i32 10, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 27), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 28), align 4
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 31), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 21), align 8
  store i32 30, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 22), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 32), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 33), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 35), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 36), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 37), align 4
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 38), align 8
  store ptr null, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 39), align 8
  store ptr null, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 46), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 49), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 48), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 50), align 4
  store i32 -1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 52), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 53), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 54), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 56), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 60), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 62), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 1), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 2), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 3), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 5), align 4
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 6), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 7), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 16), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 17), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 18), align 8
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 8), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 9), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 11), align 8
  store i32 60000, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 12), align 4
  store i32 10, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 13), align 8
  store float 2.000000e+00, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 14), align 4
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 15), align 8
  store i32 1, ptr @pref, align 4
  store ptr @spectrum_palette_color, ptr @spectrum_palette, align 8
  %0 = load i32, ptr @spectrum_palette_color_size, align 4
  store i32 %0, ptr @spectrum_palette_size, align 4
  %1 = load ptr, ptr @stdout, align 8
  %call1 = call i32 @fileno(ptr noundef %1) #15
  %call2 = call i32 @isatty(i32 noundef %call1) #15
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call3 = call ptr @getenv(ptr noundef @.str.125) #15
  %cmp = icmp eq ptr %call3, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 42), align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 42), align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call4 = call ptr @hi_sdsnew(ptr noundef @.str.116)
  store ptr %call4, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 43), align 8
  %call5 = call ptr @hi_sdsnew(ptr noundef @.str.116)
  store ptr %call5, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 44), align 8
  %2 = load i32, ptr %argc.addr, align 4
  %3 = load ptr, ptr %argv.addr, align 8
  %call6 = call i32 @parseOptions(i32 noundef %2, ptr noundef %3)
  store i32 %call6, ptr %firstarg, align 4
  %4 = load i32, ptr %firstarg, align 4
  %5 = load i32, ptr %argc.addr, align 4
  %sub = sub nsw i32 %5, %4
  store i32 %sub, ptr %argc.addr, align 4
  %6 = load i32, ptr %firstarg, align 4
  %7 = load ptr, ptr %argv.addr, align 8
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %7, i64 %idx.ext
  store ptr %add.ptr, ptr %argv.addr, align 8
  call void @parseEnv()
  %8 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 39), align 8
  %tobool7 = icmp ne i32 %8, 0
  br i1 %tobool7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end
  %call9 = call ptr @askPassword(ptr noundef @.str.126)
  store ptr %call9, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end
  %9 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 18), align 8
  %tobool11 = icmp ne i32 %9, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end10
  %call13 = call ptr @askPassword(ptr noundef @.str.127)
  store ptr %call13, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 17), align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end10
  %call15 = call i32 @gettimeofday(ptr noundef %tv, ptr noundef null) #15
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 0
  %10 = load i64, ptr %tv_sec, align 8
  %mul = mul nsw i64 %10, 1000000
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 1
  %11 = load i64, ptr %tv_usec, align 8
  %add = add nsw i64 %mul, %11
  %call16 = call i32 @getpid() #15
  %conv = sext i32 %call16 to i64
  %xor = xor i64 %add, %conv
  call void @init_genrand64(i64 noundef %xor)
  %12 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55), align 8
  %cmp17 = icmp ne ptr %12, null
  br i1 %cmp17, label %if.then19, label %if.end24

if.then19:                                        ; preds = %if.end14
  %call20 = call ptr @validateClusterManagerCommand()
  store ptr %call20, ptr %proc, align 8
  %13 = load ptr, ptr %proc, align 8
  %tobool21 = icmp ne ptr %13, null
  br i1 %tobool21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.then19
  call void @exit(i32 noundef 1) #17
  unreachable

if.end23:                                         ; preds = %if.then19
  %14 = load ptr, ptr %proc, align 8
  call void @clusterManagerMode(ptr noundef %14)
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.end14
  %15 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 12), align 8
  %tobool25 = icmp ne i32 %15, 0
  br i1 %tobool25, label %if.then26, label %if.end32

if.then26:                                        ; preds = %if.end24
  %call27 = call i32 @cliConnect(i32 noundef 0)
  %cmp28 = icmp eq i32 %call27, -1
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.then26
  call void @exit(i32 noundef 1) #17
  unreachable

if.end31:                                         ; preds = %if.then26
  call void @latencyMode()
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.end24
  %16 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 13), align 4
  %tobool33 = icmp ne i32 %16, 0
  br i1 %tobool33, label %if.then34, label %if.end40

if.then34:                                        ; preds = %if.end32
  %call35 = call i32 @cliConnect(i32 noundef 0)
  %cmp36 = icmp eq i32 %call35, -1
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.then34
  call void @exit(i32 noundef 1) #17
  unreachable

if.end39:                                         ; preds = %if.then34
  call void @latencyDistMode()
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.end32
  %17 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 20), align 4
  %tobool41 = icmp ne i32 %17, 0
  br i1 %tobool41, label %if.then42, label %if.end49

if.then42:                                        ; preds = %if.end40
  %call43 = call i32 @cliConnect(i32 noundef 0)
  %cmp44 = icmp eq i32 %call43, -1
  br i1 %cmp44, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.then42
  call void @exit(i32 noundef 1) #17
  unreachable

if.end47:                                         ; preds = %if.then42
  call void @sendCapa()
  %call48 = call i32 @sendReplconf(ptr noundef @.str.128, ptr noundef @.str.26)
  call void @slaveMode(i32 noundef 1)
  br label %if.end49

if.end49:                                         ; preds = %if.end47, %if.end40
  %18 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 23), align 8
  %tobool50 = icmp ne i32 %18, 0
  br i1 %tobool50, label %if.then52, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end49
  %19 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 24), align 4
  %tobool51 = icmp ne i32 %19, 0
  br i1 %tobool51, label %if.then52, label %if.end65

if.then52:                                        ; preds = %lor.lhs.false, %if.end49
  %call53 = call i32 @cliConnect(i32 noundef 0)
  %cmp54 = icmp eq i32 %call53, -1
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.then52
  call void @exit(i32 noundef 1) #17
  unreachable

if.end57:                                         ; preds = %if.then52
  call void @sendCapa()
  call void @sendRdbOnly()
  %20 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 24), align 4
  %tobool58 = icmp ne i32 %20, 0
  br i1 %tobool58, label %land.lhs.true59, label %if.end64

land.lhs.true59:                                  ; preds = %if.end57
  %call60 = call i32 @sendReplconf(ptr noundef @.str.128, ptr noundef @.str.129)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %if.end64, label %if.then62

if.then62:                                        ; preds = %land.lhs.true59
  %21 = load ptr, ptr @stderr, align 8
  %call63 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %21, ptr noundef @.str.130)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end64:                                         ; preds = %land.lhs.true59, %if.end57
  call void @getRDB(ptr noundef null)
  br label %if.end65

if.end65:                                         ; preds = %if.end64, %lor.lhs.false
  %22 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 21), align 8
  %tobool66 = icmp ne i32 %22, 0
  br i1 %tobool66, label %if.then67, label %if.end73

if.then67:                                        ; preds = %if.end65
  %call68 = call i32 @cliConnect(i32 noundef 0)
  %cmp69 = icmp eq i32 %call68, -1
  br i1 %cmp69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %if.then67
  call void @exit(i32 noundef 1) #17
  unreachable

if.end72:                                         ; preds = %if.then67
  call void @pipeMode()
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %if.end65
  %23 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 32), align 8
  %tobool74 = icmp ne i32 %23, 0
  br i1 %tobool74, label %if.then75, label %if.end81

if.then75:                                        ; preds = %if.end73
  %call76 = call i32 @cliConnect(i32 noundef 0)
  %cmp77 = icmp eq i32 %call76, -1
  br i1 %cmp77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %if.then75
  call void @exit(i32 noundef 1) #17
  unreachable

if.end80:                                         ; preds = %if.then75
  call void @findBigKeys(i32 noundef 0, i32 noundef 0)
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %if.end73
  %24 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 33), align 4
  %tobool82 = icmp ne i32 %24, 0
  br i1 %tobool82, label %if.then83, label %if.end89

if.then83:                                        ; preds = %if.end81
  %call84 = call i32 @cliConnect(i32 noundef 0)
  %cmp85 = icmp eq i32 %call84, -1
  br i1 %cmp85, label %if.then87, label %if.end88

if.then87:                                        ; preds = %if.then83
  call void @exit(i32 noundef 1) #17
  unreachable

if.end88:                                         ; preds = %if.then83
  %25 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 34), align 8
  call void @findBigKeys(i32 noundef 1, i32 noundef %25)
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %if.end81
  %26 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 35), align 4
  %tobool90 = icmp ne i32 %26, 0
  br i1 %tobool90, label %if.then91, label %if.end97

if.then91:                                        ; preds = %if.end89
  %call92 = call i32 @cliConnect(i32 noundef 0)
  %cmp93 = icmp eq i32 %call92, -1
  br i1 %cmp93, label %if.then95, label %if.end96

if.then95:                                        ; preds = %if.then91
  call void @exit(i32 noundef 1) #17
  unreachable

if.end96:                                         ; preds = %if.then91
  call void @findHotKeys()
  br label %if.end97

if.end97:                                         ; preds = %if.end96, %if.end89
  %27 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 25), align 8
  %tobool98 = icmp ne i32 %27, 0
  br i1 %tobool98, label %if.then99, label %if.end109

if.then99:                                        ; preds = %if.end97
  %call100 = call i32 @cliConnect(i32 noundef 0)
  %cmp101 = icmp eq i32 %call100, -1
  br i1 %cmp101, label %if.then103, label %if.end104

if.then103:                                       ; preds = %if.then99
  call void @exit(i32 noundef 1) #17
  unreachable

if.end104:                                        ; preds = %if.then99
  %28 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %cmp105 = icmp eq i64 %28, 0
  br i1 %cmp105, label %if.then107, label %if.end108

if.then107:                                       ; preds = %if.end104
  store i64 1000000, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  br label %if.end108

if.end108:                                        ; preds = %if.then107, %if.end104
  call void @statMode()
  br label %if.end109

if.end109:                                        ; preds = %if.end108, %if.end97
  %29 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 26), align 4
  %tobool110 = icmp ne i32 %29, 0
  br i1 %tobool110, label %if.then111, label %if.end117

if.then111:                                       ; preds = %if.end109
  %call112 = call i32 @cliConnect(i32 noundef 0)
  %cmp113 = icmp eq i32 %call112, -1
  br i1 %cmp113, label %if.then115, label %if.end116

if.then115:                                       ; preds = %if.then111
  call void @exit(i32 noundef 1) #17
  unreachable

if.end116:                                        ; preds = %if.then111
  call void @scanMode()
  br label %if.end117

if.end117:                                        ; preds = %if.end116, %if.end109
  %30 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 15), align 4
  %tobool118 = icmp ne i32 %30, 0
  br i1 %tobool118, label %if.then119, label %if.end125

if.then119:                                       ; preds = %if.end117
  %call120 = call i32 @cliConnect(i32 noundef 0)
  %cmp121 = icmp eq i32 %call120, -1
  br i1 %cmp121, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.then119
  call void @exit(i32 noundef 1) #17
  unreachable

if.end124:                                        ; preds = %if.then119
  call void @LRUTestMode()
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %if.end117
  %31 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 28), align 4
  %tobool126 = icmp ne i32 %31, 0
  br i1 %tobool126, label %if.then127, label %if.end128

if.then127:                                       ; preds = %if.end125
  call void @intrinsicLatencyMode()
  br label %if.end128

if.end128:                                        ; preds = %if.then127, %if.end125
  %32 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 63), align 8
  %tobool129 = icmp ne ptr %32, null
  br i1 %tobool129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %if.end128
  %33 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 63), align 8
  call void @testHint(ptr noundef %33)
  br label %if.end131

if.end131:                                        ; preds = %if.then130, %if.end128
  %34 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 64), align 8
  %tobool132 = icmp ne ptr %34, null
  br i1 %tobool132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %if.end131
  %35 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 64), align 8
  call void @testHintSuite(ptr noundef %35)
  br label %if.end134

if.end134:                                        ; preds = %if.then133, %if.end131
  %36 = load i32, ptr %argc.addr, align 4
  %cmp135 = icmp eq i32 %36, 0
  br i1 %cmp135, label %land.lhs.true137, label %if.end143

land.lhs.true137:                                 ; preds = %if.end134
  %37 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 46), align 8
  %tobool138 = icmp ne ptr %37, null
  br i1 %tobool138, label %if.end143, label %if.then139

if.then139:                                       ; preds = %land.lhs.true137
  %call140 = call ptr @signal(i32 noundef 13, ptr noundef inttoptr (i64 1 to ptr)) #15
  %call141 = call ptr @signal(i32 noundef 2, ptr noundef @sigIntHandler) #15
  %call142 = call i32 @cliConnect(i32 noundef 0)
  call void @repl()
  br label %if.end143

if.end143:                                        ; preds = %if.then139, %land.lhs.true137, %if.end134
  %38 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 46), align 8
  %tobool144 = icmp ne ptr %38, null
  br i1 %tobool144, label %if.then145, label %if.else152

if.then145:                                       ; preds = %if.end143
  %call146 = call i32 @cliConnect(i32 noundef 0)
  %cmp147 = icmp ne i32 %call146, 0
  br i1 %cmp147, label %if.then149, label %if.end150

if.then149:                                       ; preds = %if.then145
  call void @exit(i32 noundef 1) #17
  unreachable

if.end150:                                        ; preds = %if.then145
  %39 = load i32, ptr %argc.addr, align 4
  %40 = load ptr, ptr %argv.addr, align 8
  %call151 = call i32 @evalMode(i32 noundef %39, ptr noundef %40)
  store i32 %call151, ptr %retval, align 4
  br label %return

if.else152:                                       ; preds = %if.end143
  %call153 = call i32 @cliConnect(i32 noundef 2)
  %41 = load i32, ptr %argc.addr, align 4
  %42 = load ptr, ptr %argv.addr, align 8
  %call154 = call i32 @noninteractive(i32 noundef %41, ptr noundef %42)
  store i32 %call154, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else152, %if.end150
  %43 = load i32, ptr %retval, align 4
  ret i32 %43
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #10

; Function Attrs: nounwind
declare i32 @isatty(i32 noundef) #6

; Function Attrs: nounwind
declare i32 @fileno(ptr noundef) #6

; Function Attrs: nounwind uwtable
define internal i32 @parseOptions(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %lastarg = alloca i32, align 4
  %seconds = alloca double, align 8
  %cmd = alloca ptr, align 8
  %j = alloca i32, align 4
  %err = alloca i32, align 4
  %widx = alloca i32, align 4
  %weight = alloca ptr, align 8
  %wargc = alloca i32, align 4
  %version = alloca ptr, align 8
  %argval = alloca ptr, align 8
  %j811 = alloca i32, align 4
  %cmd_argc = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc929, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %argc.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end931

for.body:                                         ; preds = %for.cond
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %argc.addr, align 4
  %sub = sub nsw i32 %3, 1
  %cmp1 = icmp eq i32 %2, %sub
  %conv = zext i1 %cmp1 to i32
  store i32 %conv, ptr %lastarg, align 4
  %4 = load ptr, ptr %argv.addr, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %call = call i32 @strcmp(ptr noundef %6, ptr noundef @.str.468) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %7 = load i32, ptr %lastarg, align 4
  %tobool2 = icmp ne i32 %7, 0
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load ptr, ptr @config, align 8
  call void @hi_sdsfree(ptr noundef %8)
  %9 = load ptr, ptr %argv.addr, align 8
  %10 = load i32, ptr %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %i, align 4
  %idxprom3 = sext i32 %inc to i64
  %arrayidx4 = getelementptr inbounds ptr, ptr %9, i64 %idxprom3
  %11 = load ptr, ptr %arrayidx4, align 8
  %call5 = call ptr @hi_sdsnew(ptr noundef %11)
  store ptr %call5, ptr @config, align 8
  br label %if.end928

if.else:                                          ; preds = %land.lhs.true, %for.body
  %12 = load ptr, ptr %argv.addr, align 8
  %13 = load i32, ptr %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr inbounds ptr, ptr %12, i64 %idxprom6
  %14 = load ptr, ptr %arrayidx7, align 8
  %call8 = call i32 @strcmp(ptr noundef %14, ptr noundef @.str.468) #12
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.else13, label %land.lhs.true10

land.lhs.true10:                                  ; preds = %if.else
  %15 = load i32, ptr %lastarg, align 4
  %tobool11 = icmp ne i32 %15, 0
  br i1 %tobool11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %land.lhs.true10
  call void @usage(i32 noundef 0)
  br label %if.end927

if.else13:                                        ; preds = %land.lhs.true10, %if.else
  %16 = load ptr, ptr %argv.addr, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom14 = sext i32 %17 to i64
  %arrayidx15 = getelementptr inbounds ptr, ptr %16, i64 %idxprom14
  %18 = load ptr, ptr %arrayidx15, align 8
  %call16 = call i32 @strcmp(ptr noundef %18, ptr noundef @.str.469) #12
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.else19, label %if.then18

if.then18:                                        ; preds = %if.else13
  call void @usage(i32 noundef 0)
  br label %if.end926

if.else19:                                        ; preds = %if.else13
  %19 = load ptr, ptr %argv.addr, align 8
  %20 = load i32, ptr %i, align 4
  %idxprom20 = sext i32 %20 to i64
  %arrayidx21 = getelementptr inbounds ptr, ptr %19, i64 %idxprom20
  %21 = load ptr, ptr %arrayidx21, align 8
  %call22 = call i32 @strcmp(ptr noundef %21, ptr noundef @.str.470) #12
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.else25, label %if.then24

if.then24:                                        ; preds = %if.else19
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 36), align 8
  br label %if.end925

if.else25:                                        ; preds = %if.else19
  %22 = load ptr, ptr %argv.addr, align 8
  %23 = load i32, ptr %i, align 4
  %idxprom26 = sext i32 %23 to i64
  %arrayidx27 = getelementptr inbounds ptr, ptr %22, i64 %idxprom26
  %24 = load ptr, ptr %arrayidx27, align 8
  %call28 = call i32 @strcmp(ptr noundef %24, ptr noundef @.str.471) #12
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.else36, label %land.lhs.true30

land.lhs.true30:                                  ; preds = %if.else25
  %25 = load i32, ptr %lastarg, align 4
  %tobool31 = icmp ne i32 %25, 0
  br i1 %tobool31, label %if.else36, label %if.then32

if.then32:                                        ; preds = %land.lhs.true30
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 37), align 4
  %26 = load ptr, ptr %argv.addr, align 8
  %27 = load i32, ptr %i, align 4
  %inc33 = add nsw i32 %27, 1
  store i32 %inc33, ptr %i, align 4
  %idxprom34 = sext i32 %inc33 to i64
  %arrayidx35 = getelementptr inbounds ptr, ptr %26, i64 %idxprom34
  %28 = load ptr, ptr %arrayidx35, align 8
  store ptr %28, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 38), align 8
  br label %if.end924

if.else36:                                        ; preds = %land.lhs.true30, %if.else25
  %29 = load ptr, ptr %argv.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idxprom37 = sext i32 %30 to i64
  %arrayidx38 = getelementptr inbounds ptr, ptr %29, i64 %idxprom37
  %31 = load ptr, ptr %arrayidx38, align 8
  %call39 = call i32 @strcmp(ptr noundef %31, ptr noundef @.str.472) #12
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.else54, label %land.lhs.true41

land.lhs.true41:                                  ; preds = %if.else36
  %32 = load i32, ptr %lastarg, align 4
  %tobool42 = icmp ne i32 %32, 0
  br i1 %tobool42, label %if.else54, label %if.then43

if.then43:                                        ; preds = %land.lhs.true41
  %33 = load ptr, ptr %argv.addr, align 8
  %34 = load i32, ptr %i, align 4
  %inc44 = add nsw i32 %34, 1
  store i32 %inc44, ptr %i, align 4
  %idxprom45 = sext i32 %inc44 to i64
  %arrayidx46 = getelementptr inbounds ptr, ptr %33, i64 %idxprom45
  %35 = load ptr, ptr %arrayidx46, align 8
  %call47 = call i32 @atoi(ptr noundef %35) #12
  store i32 %call47, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %36 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %cmp48 = icmp slt i32 %36, 0
  br i1 %cmp48, label %if.then52, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then43
  %37 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %cmp50 = icmp sgt i32 %37, 65535
  br i1 %cmp50, label %if.then52, label %if.end

if.then52:                                        ; preds = %lor.lhs.false, %if.then43
  %38 = load ptr, ptr @stderr, align 8
  %call53 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %38, ptr noundef @.str.473)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  br label %if.end923

if.else54:                                        ; preds = %land.lhs.true41, %if.else36
  %39 = load ptr, ptr %argv.addr, align 8
  %40 = load i32, ptr %i, align 4
  %idxprom55 = sext i32 %40 to i64
  %arrayidx56 = getelementptr inbounds ptr, ptr %39, i64 %idxprom55
  %41 = load ptr, ptr %arrayidx56, align 8
  %call57 = call i32 @strcmp(ptr noundef %41, ptr noundef @.str.474) #12
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.else65, label %land.lhs.true59

land.lhs.true59:                                  ; preds = %if.else54
  %42 = load i32, ptr %lastarg, align 4
  %tobool60 = icmp ne i32 %42, 0
  br i1 %tobool60, label %if.else65, label %if.then61

if.then61:                                        ; preds = %land.lhs.true59
  %43 = load ptr, ptr %argv.addr, align 8
  %44 = load i32, ptr %i, align 4
  %inc62 = add nsw i32 %44, 1
  store i32 %inc62, ptr %i, align 4
  %idxprom63 = sext i32 %inc62 to i64
  %arrayidx64 = getelementptr inbounds ptr, ptr %43, i64 %idxprom63
  %45 = load ptr, ptr %arrayidx64, align 8
  store ptr %45, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  br label %if.end922

if.else65:                                        ; preds = %land.lhs.true59, %if.else54
  %46 = load ptr, ptr %argv.addr, align 8
  %47 = load i32, ptr %i, align 4
  %idxprom66 = sext i32 %47 to i64
  %arrayidx67 = getelementptr inbounds ptr, ptr %46, i64 %idxprom66
  %48 = load ptr, ptr %arrayidx67, align 8
  %call68 = call i32 @strcmp(ptr noundef %48, ptr noundef @.str.475) #12
  %tobool69 = icmp ne i32 %call68, 0
  br i1 %tobool69, label %if.else77, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %if.else65
  %49 = load i32, ptr %lastarg, align 4
  %tobool71 = icmp ne i32 %49, 0
  br i1 %tobool71, label %if.else77, label %if.then72

if.then72:                                        ; preds = %land.lhs.true70
  %50 = load ptr, ptr %argv.addr, align 8
  %51 = load i32, ptr %i, align 4
  %inc73 = add nsw i32 %51, 1
  store i32 %inc73, ptr %i, align 4
  %idxprom74 = sext i32 %inc73 to i64
  %arrayidx75 = getelementptr inbounds ptr, ptr %50, i64 %idxprom74
  %52 = load ptr, ptr %arrayidx75, align 8
  %call76 = call i64 @strtoll(ptr noundef %52, ptr noundef null, i32 noundef 10) #15
  store i64 %call76, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 4), align 8
  br label %if.end921

if.else77:                                        ; preds = %land.lhs.true70, %if.else65
  %53 = load ptr, ptr %argv.addr, align 8
  %54 = load i32, ptr %i, align 4
  %idxprom78 = sext i32 %54 to i64
  %arrayidx79 = getelementptr inbounds ptr, ptr %53, i64 %idxprom78
  %55 = load ptr, ptr %arrayidx79, align 8
  %call80 = call i32 @strcmp(ptr noundef %55, ptr noundef @.str.476) #12
  %tobool81 = icmp ne i32 %call80, 0
  br i1 %tobool81, label %if.else90, label %land.lhs.true82

land.lhs.true82:                                  ; preds = %if.else77
  %56 = load i32, ptr %lastarg, align 4
  %tobool83 = icmp ne i32 %56, 0
  br i1 %tobool83, label %if.else90, label %if.then84

if.then84:                                        ; preds = %land.lhs.true82
  %57 = load ptr, ptr %argv.addr, align 8
  %58 = load i32, ptr %i, align 4
  %inc85 = add nsw i32 %58, 1
  store i32 %inc85, ptr %i, align 4
  %idxprom86 = sext i32 %inc85 to i64
  %arrayidx87 = getelementptr inbounds ptr, ptr %57, i64 %idxprom86
  %59 = load ptr, ptr %arrayidx87, align 8
  %call88 = call double @atof(ptr noundef %59) #12
  store double %call88, ptr %seconds, align 8
  %60 = load double, ptr %seconds, align 8
  %mul = fmul double %60, 1.000000e+06
  %conv89 = fptosi double %mul to i64
  store i64 %conv89, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  br label %if.end920

if.else90:                                        ; preds = %land.lhs.true82, %if.else77
  %61 = load ptr, ptr %argv.addr, align 8
  %62 = load i32, ptr %i, align 4
  %idxprom91 = sext i32 %62 to i64
  %arrayidx92 = getelementptr inbounds ptr, ptr %61, i64 %idxprom91
  %63 = load ptr, ptr %arrayidx92, align 8
  %call93 = call i32 @strcmp(ptr noundef %63, ptr noundef @.str.477) #12
  %tobool94 = icmp ne i32 %call93, 0
  br i1 %tobool94, label %if.else102, label %land.lhs.true95

land.lhs.true95:                                  ; preds = %if.else90
  %64 = load i32, ptr %lastarg, align 4
  %tobool96 = icmp ne i32 %64, 0
  br i1 %tobool96, label %if.else102, label %if.then97

if.then97:                                        ; preds = %land.lhs.true95
  %65 = load ptr, ptr %argv.addr, align 8
  %66 = load i32, ptr %i, align 4
  %inc98 = add nsw i32 %66, 1
  store i32 %inc98, ptr %i, align 4
  %idxprom99 = sext i32 %inc98 to i64
  %arrayidx100 = getelementptr inbounds ptr, ptr %65, i64 %idxprom99
  %67 = load ptr, ptr %arrayidx100, align 8
  %call101 = call i32 @atoi(ptr noundef %67) #12
  store i32 %call101, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  br label %if.end919

if.else102:                                       ; preds = %land.lhs.true95, %if.else90
  %68 = load ptr, ptr %argv.addr, align 8
  %69 = load i32, ptr %i, align 4
  %idxprom103 = sext i32 %69 to i64
  %arrayidx104 = getelementptr inbounds ptr, ptr %68, i64 %idxprom103
  %70 = load ptr, ptr %arrayidx104, align 8
  %call105 = call i32 @strcmp(ptr noundef %70, ptr noundef @.str.478) #12
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.else108, label %if.then107

if.then107:                                       ; preds = %if.else102
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 56), align 8
  br label %if.end918

if.else108:                                       ; preds = %if.else102
  %71 = load ptr, ptr %argv.addr, align 8
  %72 = load i32, ptr %i, align 4
  %idxprom109 = sext i32 %72 to i64
  %arrayidx110 = getelementptr inbounds ptr, ptr %71, i64 %idxprom109
  %73 = load ptr, ptr %arrayidx110, align 8
  %call111 = call i32 @strcmp(ptr noundef %73, ptr noundef @.str.479) #12
  %tobool112 = icmp ne i32 %call111, 0
  br i1 %tobool112, label %if.else114, label %if.then113

if.then113:                                       ; preds = %if.else108
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 39), align 8
  br label %if.end917

if.else114:                                       ; preds = %if.else108
  %74 = load ptr, ptr %argv.addr, align 8
  %75 = load i32, ptr %i, align 4
  %idxprom115 = sext i32 %75 to i64
  %arrayidx116 = getelementptr inbounds ptr, ptr %74, i64 %idxprom115
  %76 = load ptr, ptr %arrayidx116, align 8
  %call117 = call i32 @strcmp(ptr noundef %76, ptr noundef @.str.480) #12
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %lor.lhs.false119, label %land.lhs.true124

lor.lhs.false119:                                 ; preds = %if.else114
  %77 = load ptr, ptr %argv.addr, align 8
  %78 = load i32, ptr %i, align 4
  %idxprom120 = sext i32 %78 to i64
  %arrayidx121 = getelementptr inbounds ptr, ptr %77, i64 %idxprom120
  %79 = load ptr, ptr %arrayidx121, align 8
  %call122 = call i32 @strcmp(ptr noundef %79, ptr noundef @.str.481) #12
  %tobool123 = icmp ne i32 %call122, 0
  br i1 %tobool123, label %if.else131, label %land.lhs.true124

land.lhs.true124:                                 ; preds = %lor.lhs.false119, %if.else114
  %80 = load i32, ptr %lastarg, align 4
  %tobool125 = icmp ne i32 %80, 0
  br i1 %tobool125, label %if.else131, label %if.then126

if.then126:                                       ; preds = %land.lhs.true124
  %81 = load ptr, ptr %argv.addr, align 8
  %82 = load i32, ptr %i, align 4
  %inc127 = add nsw i32 %82, 1
  store i32 %inc127, ptr %i, align 4
  %idxprom128 = sext i32 %inc127 to i64
  %arrayidx129 = getelementptr inbounds ptr, ptr %81, i64 %idxprom128
  %83 = load ptr, ptr %arrayidx129, align 8
  %call130 = call ptr @hi_sdsnew(ptr noundef %83)
  store ptr %call130, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  br label %if.end916

if.else131:                                       ; preds = %land.lhs.true124, %lor.lhs.false119
  %84 = load ptr, ptr %argv.addr, align 8
  %85 = load i32, ptr %i, align 4
  %idxprom132 = sext i32 %85 to i64
  %arrayidx133 = getelementptr inbounds ptr, ptr %84, i64 %idxprom132
  %86 = load ptr, ptr %arrayidx133, align 8
  %call134 = call i32 @strcmp(ptr noundef %86, ptr noundef @.str.482) #12
  %tobool135 = icmp ne i32 %call134, 0
  br i1 %tobool135, label %if.else143, label %land.lhs.true136

land.lhs.true136:                                 ; preds = %if.else131
  %87 = load i32, ptr %lastarg, align 4
  %tobool137 = icmp ne i32 %87, 0
  br i1 %tobool137, label %if.else143, label %if.then138

if.then138:                                       ; preds = %land.lhs.true136
  %88 = load ptr, ptr %argv.addr, align 8
  %89 = load i32, ptr %i, align 4
  %inc139 = add nsw i32 %89, 1
  store i32 %inc139, ptr %i, align 4
  %idxprom140 = sext i32 %inc139 to i64
  %arrayidx141 = getelementptr inbounds ptr, ptr %88, i64 %idxprom140
  %90 = load ptr, ptr %arrayidx141, align 8
  %call142 = call ptr @hi_sdsnew(ptr noundef %90)
  store ptr %call142, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  br label %if.end915

if.else143:                                       ; preds = %land.lhs.true136, %if.else131
  %91 = load ptr, ptr %argv.addr, align 8
  %92 = load i32, ptr %i, align 4
  %idxprom144 = sext i32 %92 to i64
  %arrayidx145 = getelementptr inbounds ptr, ptr %91, i64 %idxprom144
  %93 = load ptr, ptr %arrayidx145, align 8
  %call146 = call i32 @strcmp(ptr noundef %93, ptr noundef @.str.483) #12
  %tobool147 = icmp ne i32 %call146, 0
  br i1 %tobool147, label %if.else162, label %land.lhs.true148

land.lhs.true148:                                 ; preds = %if.else143
  %94 = load i32, ptr %lastarg, align 4
  %tobool149 = icmp ne i32 %94, 0
  br i1 %tobool149, label %if.else162, label %if.then150

if.then150:                                       ; preds = %land.lhs.true148
  %95 = load ptr, ptr %argv.addr, align 8
  %96 = load i32, ptr %i, align 4
  %inc151 = add nsw i32 %96, 1
  store i32 %inc151, ptr %i, align 4
  %idxprom152 = sext i32 %inc151 to i64
  %arrayidx153 = getelementptr inbounds ptr, ptr %95, i64 %idxprom152
  %97 = load ptr, ptr %arrayidx153, align 8
  call void @parseRedisUri(ptr noundef %97, ptr noundef @.str.484, ptr noundef @config, ptr noundef getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 2))
  %98 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %cmp154 = icmp slt i32 %98, 0
  br i1 %cmp154, label %if.then159, label %lor.lhs.false156

lor.lhs.false156:                                 ; preds = %if.then150
  %99 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %cmp157 = icmp sgt i32 %99, 65535
  br i1 %cmp157, label %if.then159, label %if.end161

if.then159:                                       ; preds = %lor.lhs.false156, %if.then150
  %100 = load ptr, ptr @stderr, align 8
  %call160 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %100, ptr noundef @.str.473)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end161:                                        ; preds = %lor.lhs.false156
  br label %if.end914

if.else162:                                       ; preds = %land.lhs.true148, %if.else143
  %101 = load ptr, ptr %argv.addr, align 8
  %102 = load i32, ptr %i, align 4
  %idxprom163 = sext i32 %102 to i64
  %arrayidx164 = getelementptr inbounds ptr, ptr %101, i64 %idxprom163
  %103 = load ptr, ptr %arrayidx164, align 8
  %call165 = call i32 @strcmp(ptr noundef %103, ptr noundef @.str.485) #12
  %tobool166 = icmp ne i32 %call165, 0
  br i1 %tobool166, label %if.else168, label %if.then167

if.then167:                                       ; preds = %if.else162
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %if.end913

if.else168:                                       ; preds = %if.else162
  %104 = load ptr, ptr %argv.addr, align 8
  %105 = load i32, ptr %i, align 4
  %idxprom169 = sext i32 %105 to i64
  %arrayidx170 = getelementptr inbounds ptr, ptr %104, i64 %idxprom169
  %106 = load ptr, ptr %arrayidx170, align 8
  %call171 = call i32 @strcmp(ptr noundef %106, ptr noundef @.str.486) #12
  %tobool172 = icmp ne i32 %call171, 0
  br i1 %tobool172, label %if.else174, label %if.then173

if.then173:                                       ; preds = %if.else168
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %if.end912

if.else174:                                       ; preds = %if.else168
  %107 = load ptr, ptr %argv.addr, align 8
  %108 = load i32, ptr %i, align 4
  %idxprom175 = sext i32 %108 to i64
  %arrayidx176 = getelementptr inbounds ptr, ptr %107, i64 %idxprom175
  %109 = load ptr, ptr %arrayidx176, align 8
  %call177 = call i32 @strcmp(ptr noundef %109, ptr noundef @.str.487) #12
  %tobool178 = icmp ne i32 %call177, 0
  br i1 %tobool178, label %if.else180, label %if.then179

if.then179:                                       ; preds = %if.else174
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 40), align 4
  br label %if.end911

if.else180:                                       ; preds = %if.else174
  %110 = load ptr, ptr %argv.addr, align 8
  %111 = load i32, ptr %i, align 4
  %idxprom181 = sext i32 %111 to i64
  %arrayidx182 = getelementptr inbounds ptr, ptr %110, i64 %idxprom181
  %112 = load ptr, ptr %arrayidx182, align 8
  %call183 = call i32 @strcmp(ptr noundef %112, ptr noundef @.str.488) #12
  %tobool184 = icmp ne i32 %call183, 0
  br i1 %tobool184, label %if.else186, label %if.then185

if.then185:                                       ; preds = %if.else180
  store i32 2, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %if.end910

if.else186:                                       ; preds = %if.else180
  %113 = load ptr, ptr %argv.addr, align 8
  %114 = load i32, ptr %i, align 4
  %idxprom187 = sext i32 %114 to i64
  %arrayidx188 = getelementptr inbounds ptr, ptr %113, i64 %idxprom187
  %115 = load ptr, ptr %arrayidx188, align 8
  %call189 = call i32 @strcmp(ptr noundef %115, ptr noundef @.str.489) #12
  %tobool190 = icmp ne i32 %call189, 0
  br i1 %tobool190, label %if.else196, label %if.then191

if.then191:                                       ; preds = %if.else186
  %116 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  %cmp192 = icmp eq i32 %116, 0
  br i1 %cmp192, label %if.then194, label %if.end195

if.then194:                                       ; preds = %if.then191
  store i32 2, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  br label %if.end195

if.end195:                                        ; preds = %if.then194, %if.then191
  store i32 3, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %if.end909

if.else196:                                       ; preds = %if.else186
  %117 = load ptr, ptr %argv.addr, align 8
  %118 = load i32, ptr %i, align 4
  %idxprom197 = sext i32 %118 to i64
  %arrayidx198 = getelementptr inbounds ptr, ptr %117, i64 %idxprom197
  %119 = load ptr, ptr %arrayidx198, align 8
  %call199 = call i32 @strcmp(ptr noundef %119, ptr noundef @.str.490) #12
  %tobool200 = icmp ne i32 %call199, 0
  br i1 %tobool200, label %if.else206, label %if.then201

if.then201:                                       ; preds = %if.else196
  %120 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  %cmp202 = icmp eq i32 %120, 0
  br i1 %cmp202, label %if.then204, label %if.end205

if.then204:                                       ; preds = %if.then201
  store i32 2, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  br label %if.end205

if.end205:                                        ; preds = %if.then204, %if.then201
  store i32 4, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %if.end908

if.else206:                                       ; preds = %if.else196
  %121 = load ptr, ptr %argv.addr, align 8
  %122 = load i32, ptr %i, align 4
  %idxprom207 = sext i32 %122 to i64
  %arrayidx208 = getelementptr inbounds ptr, ptr %121, i64 %idxprom207
  %123 = load ptr, ptr %arrayidx208, align 8
  %call209 = call i32 @strcmp(ptr noundef %123, ptr noundef @.str.491) #12
  %tobool210 = icmp ne i32 %call209, 0
  br i1 %tobool210, label %if.else212, label %if.then211

if.then211:                                       ; preds = %if.else206
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 12), align 8
  br label %if.end907

if.else212:                                       ; preds = %if.else206
  %124 = load ptr, ptr %argv.addr, align 8
  %125 = load i32, ptr %i, align 4
  %idxprom213 = sext i32 %125 to i64
  %arrayidx214 = getelementptr inbounds ptr, ptr %124, i64 %idxprom213
  %126 = load ptr, ptr %arrayidx214, align 8
  %call215 = call i32 @strcmp(ptr noundef %126, ptr noundef @.str.492) #12
  %tobool216 = icmp ne i32 %call215, 0
  br i1 %tobool216, label %if.else218, label %if.then217

if.then217:                                       ; preds = %if.else212
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 13), align 4
  br label %if.end906

if.else218:                                       ; preds = %if.else212
  %127 = load ptr, ptr %argv.addr, align 8
  %128 = load i32, ptr %i, align 4
  %idxprom219 = sext i32 %128 to i64
  %arrayidx220 = getelementptr inbounds ptr, ptr %127, i64 %idxprom219
  %129 = load ptr, ptr %arrayidx220, align 8
  %call221 = call i32 @strcmp(ptr noundef %129, ptr noundef @.str.493) #12
  %tobool222 = icmp ne i32 %call221, 0
  br i1 %tobool222, label %if.else224, label %if.then223

if.then223:                                       ; preds = %if.else218
  store ptr @spectrum_palette_mono, ptr @spectrum_palette, align 8
  %130 = load i32, ptr @spectrum_palette_mono_size, align 4
  store i32 %130, ptr @spectrum_palette_size, align 4
  br label %if.end905

if.else224:                                       ; preds = %if.else218
  %131 = load ptr, ptr %argv.addr, align 8
  %132 = load i32, ptr %i, align 4
  %idxprom225 = sext i32 %132 to i64
  %arrayidx226 = getelementptr inbounds ptr, ptr %131, i64 %idxprom225
  %133 = load ptr, ptr %arrayidx226, align 8
  %call227 = call i32 @strcmp(ptr noundef %133, ptr noundef @.str.494) #12
  %tobool228 = icmp ne i32 %call227, 0
  br i1 %tobool228, label %if.else230, label %if.then229

if.then229:                                       ; preds = %if.else224
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 12), align 8
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 14), align 8
  br label %if.end904

if.else230:                                       ; preds = %if.else224
  %134 = load ptr, ptr %argv.addr, align 8
  %135 = load i32, ptr %i, align 4
  %idxprom231 = sext i32 %135 to i64
  %arrayidx232 = getelementptr inbounds ptr, ptr %134, i64 %idxprom231
  %136 = load ptr, ptr %arrayidx232, align 8
  %call233 = call i32 @strcmp(ptr noundef %136, ptr noundef @.str.495) #12
  %tobool234 = icmp ne i32 %call233, 0
  br i1 %tobool234, label %if.else242, label %land.lhs.true235

land.lhs.true235:                                 ; preds = %if.else230
  %137 = load i32, ptr %lastarg, align 4
  %tobool236 = icmp ne i32 %137, 0
  br i1 %tobool236, label %if.else242, label %if.then237

if.then237:                                       ; preds = %land.lhs.true235
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 15), align 4
  %138 = load ptr, ptr %argv.addr, align 8
  %139 = load i32, ptr %i, align 4
  %inc238 = add nsw i32 %139, 1
  store i32 %inc238, ptr %i, align 4
  %idxprom239 = sext i32 %inc238 to i64
  %arrayidx240 = getelementptr inbounds ptr, ptr %138, i64 %idxprom239
  %140 = load ptr, ptr %arrayidx240, align 8
  %call241 = call i64 @strtoll(ptr noundef %140, ptr noundef null, i32 noundef 10) #15
  store i64 %call241, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 16), align 8
  br label %if.end903

if.else242:                                       ; preds = %land.lhs.true235, %if.else230
  %141 = load ptr, ptr %argv.addr, align 8
  %142 = load i32, ptr %i, align 4
  %idxprom243 = sext i32 %142 to i64
  %arrayidx244 = getelementptr inbounds ptr, ptr %141, i64 %idxprom243
  %143 = load ptr, ptr %arrayidx244, align 8
  %call245 = call i32 @strcmp(ptr noundef %143, ptr noundef @.str.496) #12
  %tobool246 = icmp ne i32 %call245, 0
  br i1 %tobool246, label %if.else248, label %if.then247

if.then247:                                       ; preds = %if.else242
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 20), align 4
  br label %if.end902

if.else248:                                       ; preds = %if.else242
  %144 = load ptr, ptr %argv.addr, align 8
  %145 = load i32, ptr %i, align 4
  %idxprom249 = sext i32 %145 to i64
  %arrayidx250 = getelementptr inbounds ptr, ptr %144, i64 %idxprom249
  %146 = load ptr, ptr %arrayidx250, align 8
  %call251 = call i32 @strcmp(ptr noundef %146, ptr noundef @.str.497) #12
  %tobool252 = icmp ne i32 %call251, 0
  br i1 %tobool252, label %if.else254, label %if.then253

if.then253:                                       ; preds = %if.else248
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 20), align 4
  br label %if.end901

if.else254:                                       ; preds = %if.else248
  %147 = load ptr, ptr %argv.addr, align 8
  %148 = load i32, ptr %i, align 4
  %idxprom255 = sext i32 %148 to i64
  %arrayidx256 = getelementptr inbounds ptr, ptr %147, i64 %idxprom255
  %149 = load ptr, ptr %arrayidx256, align 8
  %call257 = call i32 @strcmp(ptr noundef %149, ptr noundef @.str.498) #12
  %tobool258 = icmp ne i32 %call257, 0
  br i1 %tobool258, label %if.else260, label %if.then259

if.then259:                                       ; preds = %if.else254
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 25), align 8
  br label %if.end900

if.else260:                                       ; preds = %if.else254
  %150 = load ptr, ptr %argv.addr, align 8
  %151 = load i32, ptr %i, align 4
  %idxprom261 = sext i32 %151 to i64
  %arrayidx262 = getelementptr inbounds ptr, ptr %150, i64 %idxprom261
  %152 = load ptr, ptr %arrayidx262, align 8
  %call263 = call i32 @strcmp(ptr noundef %152, ptr noundef @.str.499) #12
  %tobool264 = icmp ne i32 %call263, 0
  br i1 %tobool264, label %if.else266, label %if.then265

if.then265:                                       ; preds = %if.else260
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 26), align 4
  br label %if.end899

if.else266:                                       ; preds = %if.else260
  %153 = load ptr, ptr %argv.addr, align 8
  %154 = load i32, ptr %i, align 4
  %idxprom267 = sext i32 %154 to i64
  %arrayidx268 = getelementptr inbounds ptr, ptr %153, i64 %idxprom267
  %155 = load ptr, ptr %arrayidx268, align 8
  %call269 = call i32 @strcmp(ptr noundef %155, ptr noundef @.str.500) #12
  %tobool270 = icmp ne i32 %call269, 0
  br i1 %tobool270, label %if.else278, label %land.lhs.true271

land.lhs.true271:                                 ; preds = %if.else266
  %156 = load i32, ptr %lastarg, align 4
  %tobool272 = icmp ne i32 %156, 0
  br i1 %tobool272, label %if.else278, label %if.then273

if.then273:                                       ; preds = %land.lhs.true271
  %157 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  call void @hi_sdsfree(ptr noundef %157)
  %158 = load ptr, ptr %argv.addr, align 8
  %159 = load i32, ptr %i, align 4
  %inc274 = add nsw i32 %159, 1
  store i32 %inc274, ptr %i, align 4
  %idxprom275 = sext i32 %inc274 to i64
  %arrayidx276 = getelementptr inbounds ptr, ptr %158, i64 %idxprom275
  %160 = load ptr, ptr %arrayidx276, align 8
  %call277 = call ptr @hi_sdsnew(ptr noundef %160)
  store ptr %call277, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  br label %if.end898

if.else278:                                       ; preds = %land.lhs.true271, %if.else266
  %161 = load ptr, ptr %argv.addr, align 8
  %162 = load i32, ptr %i, align 4
  %idxprom279 = sext i32 %162 to i64
  %arrayidx280 = getelementptr inbounds ptr, ptr %161, i64 %idxprom279
  %163 = load ptr, ptr %arrayidx280, align 8
  %call281 = call i32 @strcmp(ptr noundef %163, ptr noundef @.str.501) #12
  %tobool282 = icmp ne i32 %call281, 0
  br i1 %tobool282, label %if.else290, label %land.lhs.true283

land.lhs.true283:                                 ; preds = %if.else278
  %164 = load i32, ptr %lastarg, align 4
  %tobool284 = icmp ne i32 %164, 0
  br i1 %tobool284, label %if.else290, label %if.then285

if.then285:                                       ; preds = %land.lhs.true283
  %165 = load ptr, ptr %argv.addr, align 8
  %166 = load i32, ptr %i, align 4
  %inc286 = add nsw i32 %166, 1
  store i32 %inc286, ptr %i, align 4
  %idxprom287 = sext i32 %inc286 to i64
  %arrayidx288 = getelementptr inbounds ptr, ptr %165, i64 %idxprom287
  %167 = load ptr, ptr %arrayidx288, align 8
  %call289 = call i32 @atoi(ptr noundef %167) #12
  store i32 %call289, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 27), align 8
  br label %if.end897

if.else290:                                       ; preds = %land.lhs.true283, %if.else278
  %168 = load ptr, ptr %argv.addr, align 8
  %169 = load i32, ptr %i, align 4
  %idxprom291 = sext i32 %169 to i64
  %arrayidx292 = getelementptr inbounds ptr, ptr %168, i64 %idxprom291
  %170 = load ptr, ptr %arrayidx292, align 8
  %call293 = call i32 @strcmp(ptr noundef %170, ptr noundef @.str.502) #12
  %tobool294 = icmp ne i32 %call293, 0
  br i1 %tobool294, label %if.else306, label %land.lhs.true295

land.lhs.true295:                                 ; preds = %if.else290
  %171 = load i32, ptr %lastarg, align 4
  %tobool296 = icmp ne i32 %171, 0
  br i1 %tobool296, label %if.else306, label %if.then297

if.then297:                                       ; preds = %land.lhs.true295
  %172 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  call void @hi_sdsfree(ptr noundef %172)
  %173 = load ptr, ptr %argv.addr, align 8
  %174 = load i32, ptr %i, align 4
  %inc298 = add nsw i32 %174, 1
  store i32 %inc298, ptr %i, align 4
  %idxprom299 = sext i32 %inc298 to i64
  %arrayidx300 = getelementptr inbounds ptr, ptr %173, i64 %idxprom299
  %175 = load ptr, ptr %arrayidx300, align 8
  %call301 = call ptr @unquoteCString(ptr noundef %175)
  store ptr %call301, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  %176 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  %tobool302 = icmp ne ptr %176, null
  br i1 %tobool302, label %if.end305, label %if.then303

if.then303:                                       ; preds = %if.then297
  %177 = load ptr, ptr @stderr, align 8
  %call304 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %177, ptr noundef @.str.503)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end305:                                        ; preds = %if.then297
  br label %if.end896

if.else306:                                       ; preds = %land.lhs.true295, %if.else290
  %178 = load ptr, ptr %argv.addr, align 8
  %179 = load i32, ptr %i, align 4
  %idxprom307 = sext i32 %179 to i64
  %arrayidx308 = getelementptr inbounds ptr, ptr %178, i64 %idxprom307
  %180 = load ptr, ptr %arrayidx308, align 8
  %call309 = call i32 @strcmp(ptr noundef %180, ptr noundef @.str.504) #12
  %tobool310 = icmp ne i32 %call309, 0
  br i1 %tobool310, label %if.else318, label %land.lhs.true311

land.lhs.true311:                                 ; preds = %if.else306
  %181 = load i32, ptr %lastarg, align 4
  %tobool312 = icmp ne i32 %181, 0
  br i1 %tobool312, label %if.else318, label %if.then313

if.then313:                                       ; preds = %land.lhs.true311
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 28), align 4
  %182 = load ptr, ptr %argv.addr, align 8
  %183 = load i32, ptr %i, align 4
  %inc314 = add nsw i32 %183, 1
  store i32 %inc314, ptr %i, align 4
  %idxprom315 = sext i32 %inc314 to i64
  %arrayidx316 = getelementptr inbounds ptr, ptr %182, i64 %idxprom315
  %184 = load ptr, ptr %arrayidx316, align 8
  %call317 = call i32 @atoi(ptr noundef %184) #12
  store i32 %call317, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 29), align 8
  br label %if.end895

if.else318:                                       ; preds = %land.lhs.true311, %if.else306
  %185 = load ptr, ptr %argv.addr, align 8
  %186 = load i32, ptr %i, align 4
  %idxprom319 = sext i32 %186 to i64
  %arrayidx320 = getelementptr inbounds ptr, ptr %185, i64 %idxprom319
  %187 = load ptr, ptr %arrayidx320, align 8
  %call321 = call i32 @strcmp(ptr noundef %187, ptr noundef @.str.505) #12
  %tobool322 = icmp ne i32 %call321, 0
  br i1 %tobool322, label %if.else329, label %land.lhs.true323

land.lhs.true323:                                 ; preds = %if.else318
  %188 = load i32, ptr %lastarg, align 4
  %tobool324 = icmp ne i32 %188, 0
  br i1 %tobool324, label %if.else329, label %if.then325

if.then325:                                       ; preds = %land.lhs.true323
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 23), align 8
  %189 = load ptr, ptr %argv.addr, align 8
  %190 = load i32, ptr %i, align 4
  %inc326 = add nsw i32 %190, 1
  store i32 %inc326, ptr %i, align 4
  %idxprom327 = sext i32 %inc326 to i64
  %arrayidx328 = getelementptr inbounds ptr, ptr %189, i64 %idxprom327
  %191 = load ptr, ptr %arrayidx328, align 8
  store ptr %191, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 31), align 8
  br label %if.end894

if.else329:                                       ; preds = %land.lhs.true323, %if.else318
  %192 = load ptr, ptr %argv.addr, align 8
  %193 = load i32, ptr %i, align 4
  %idxprom330 = sext i32 %193 to i64
  %arrayidx331 = getelementptr inbounds ptr, ptr %192, i64 %idxprom330
  %194 = load ptr, ptr %arrayidx331, align 8
  %call332 = call i32 @strcmp(ptr noundef %194, ptr noundef @.str.506) #12
  %tobool333 = icmp ne i32 %call332, 0
  br i1 %tobool333, label %if.else340, label %land.lhs.true334

land.lhs.true334:                                 ; preds = %if.else329
  %195 = load i32, ptr %lastarg, align 4
  %tobool335 = icmp ne i32 %195, 0
  br i1 %tobool335, label %if.else340, label %if.then336

if.then336:                                       ; preds = %land.lhs.true334
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 24), align 4
  %196 = load ptr, ptr %argv.addr, align 8
  %197 = load i32, ptr %i, align 4
  %inc337 = add nsw i32 %197, 1
  store i32 %inc337, ptr %i, align 4
  %idxprom338 = sext i32 %inc337 to i64
  %arrayidx339 = getelementptr inbounds ptr, ptr %196, i64 %idxprom338
  %198 = load ptr, ptr %arrayidx339, align 8
  store ptr %198, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 31), align 8
  br label %if.end893

if.else340:                                       ; preds = %land.lhs.true334, %if.else329
  %199 = load ptr, ptr %argv.addr, align 8
  %200 = load i32, ptr %i, align 4
  %idxprom341 = sext i32 %200 to i64
  %arrayidx342 = getelementptr inbounds ptr, ptr %199, i64 %idxprom341
  %201 = load ptr, ptr %arrayidx342, align 8
  %call343 = call i32 @strcmp(ptr noundef %201, ptr noundef @.str.507) #12
  %tobool344 = icmp ne i32 %call343, 0
  br i1 %tobool344, label %if.else346, label %if.then345

if.then345:                                       ; preds = %if.else340
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 21), align 8
  br label %if.end892

if.else346:                                       ; preds = %if.else340
  %202 = load ptr, ptr %argv.addr, align 8
  %203 = load i32, ptr %i, align 4
  %idxprom347 = sext i32 %203 to i64
  %arrayidx348 = getelementptr inbounds ptr, ptr %202, i64 %idxprom347
  %204 = load ptr, ptr %arrayidx348, align 8
  %call349 = call i32 @strcmp(ptr noundef %204, ptr noundef @.str.508) #12
  %tobool350 = icmp ne i32 %call349, 0
  br i1 %tobool350, label %if.else358, label %land.lhs.true351

land.lhs.true351:                                 ; preds = %if.else346
  %205 = load i32, ptr %lastarg, align 4
  %tobool352 = icmp ne i32 %205, 0
  br i1 %tobool352, label %if.else358, label %if.then353

if.then353:                                       ; preds = %land.lhs.true351
  %206 = load ptr, ptr %argv.addr, align 8
  %207 = load i32, ptr %i, align 4
  %inc354 = add nsw i32 %207, 1
  store i32 %inc354, ptr %i, align 4
  %idxprom355 = sext i32 %inc354 to i64
  %arrayidx356 = getelementptr inbounds ptr, ptr %206, i64 %idxprom355
  %208 = load ptr, ptr %arrayidx356, align 8
  %call357 = call i32 @atoi(ptr noundef %208) #12
  store i32 %call357, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 22), align 4
  br label %if.end891

if.else358:                                       ; preds = %land.lhs.true351, %if.else346
  %209 = load ptr, ptr %argv.addr, align 8
  %210 = load i32, ptr %i, align 4
  %idxprom359 = sext i32 %210 to i64
  %arrayidx360 = getelementptr inbounds ptr, ptr %209, i64 %idxprom359
  %211 = load ptr, ptr %arrayidx360, align 8
  %call361 = call i32 @strcmp(ptr noundef %211, ptr noundef @.str.509) #12
  %tobool362 = icmp ne i32 %call361, 0
  br i1 %tobool362, label %if.else364, label %if.then363

if.then363:                                       ; preds = %if.else358
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 32), align 8
  br label %if.end890

if.else364:                                       ; preds = %if.else358
  %212 = load ptr, ptr %argv.addr, align 8
  %213 = load i32, ptr %i, align 4
  %idxprom365 = sext i32 %213 to i64
  %arrayidx366 = getelementptr inbounds ptr, ptr %212, i64 %idxprom365
  %214 = load ptr, ptr %arrayidx366, align 8
  %call367 = call i32 @strcmp(ptr noundef %214, ptr noundef @.str.510) #12
  %tobool368 = icmp ne i32 %call367, 0
  br i1 %tobool368, label %if.else370, label %if.then369

if.then369:                                       ; preds = %if.else364
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 33), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 34), align 8
  br label %if.end889

if.else370:                                       ; preds = %if.else364
  %215 = load ptr, ptr %argv.addr, align 8
  %216 = load i32, ptr %i, align 4
  %idxprom371 = sext i32 %216 to i64
  %arrayidx372 = getelementptr inbounds ptr, ptr %215, i64 %idxprom371
  %217 = load ptr, ptr %arrayidx372, align 8
  %call373 = call i32 @strcmp(ptr noundef %217, ptr noundef @.str.511) #12
  %tobool374 = icmp ne i32 %call373, 0
  br i1 %tobool374, label %if.else382, label %land.lhs.true375

land.lhs.true375:                                 ; preds = %if.else370
  %218 = load i32, ptr %lastarg, align 4
  %tobool376 = icmp ne i32 %218, 0
  br i1 %tobool376, label %if.else382, label %if.then377

if.then377:                                       ; preds = %land.lhs.true375
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 33), align 4
  %219 = load ptr, ptr %argv.addr, align 8
  %220 = load i32, ptr %i, align 4
  %inc378 = add nsw i32 %220, 1
  store i32 %inc378, ptr %i, align 4
  %idxprom379 = sext i32 %inc378 to i64
  %arrayidx380 = getelementptr inbounds ptr, ptr %219, i64 %idxprom379
  %221 = load ptr, ptr %arrayidx380, align 8
  %call381 = call i32 @atoi(ptr noundef %221) #12
  store i32 %call381, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 34), align 8
  br label %if.end888

if.else382:                                       ; preds = %land.lhs.true375, %if.else370
  %222 = load ptr, ptr %argv.addr, align 8
  %223 = load i32, ptr %i, align 4
  %idxprom383 = sext i32 %223 to i64
  %arrayidx384 = getelementptr inbounds ptr, ptr %222, i64 %idxprom383
  %224 = load ptr, ptr %arrayidx384, align 8
  %call385 = call i32 @strcmp(ptr noundef %224, ptr noundef @.str.512) #12
  %tobool386 = icmp ne i32 %call385, 0
  br i1 %tobool386, label %if.else388, label %if.then387

if.then387:                                       ; preds = %if.else382
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 35), align 4
  br label %if.end887

if.else388:                                       ; preds = %if.else382
  %225 = load ptr, ptr %argv.addr, align 8
  %226 = load i32, ptr %i, align 4
  %idxprom389 = sext i32 %226 to i64
  %arrayidx390 = getelementptr inbounds ptr, ptr %225, i64 %idxprom389
  %227 = load ptr, ptr %arrayidx390, align 8
  %call391 = call i32 @strcmp(ptr noundef %227, ptr noundef @.str.513) #12
  %tobool392 = icmp ne i32 %call391, 0
  br i1 %tobool392, label %if.else399, label %land.lhs.true393

land.lhs.true393:                                 ; preds = %if.else388
  %228 = load i32, ptr %lastarg, align 4
  %tobool394 = icmp ne i32 %228, 0
  br i1 %tobool394, label %if.else399, label %if.then395

if.then395:                                       ; preds = %land.lhs.true393
  %229 = load ptr, ptr %argv.addr, align 8
  %230 = load i32, ptr %i, align 4
  %inc396 = add nsw i32 %230, 1
  store i32 %inc396, ptr %i, align 4
  %idxprom397 = sext i32 %inc396 to i64
  %arrayidx398 = getelementptr inbounds ptr, ptr %229, i64 %idxprom397
  %231 = load ptr, ptr %arrayidx398, align 8
  store ptr %231, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 46), align 8
  br label %if.end886

if.else399:                                       ; preds = %land.lhs.true393, %if.else388
  %232 = load ptr, ptr %argv.addr, align 8
  %233 = load i32, ptr %i, align 4
  %idxprom400 = sext i32 %233 to i64
  %arrayidx401 = getelementptr inbounds ptr, ptr %232, i64 %idxprom400
  %234 = load ptr, ptr %arrayidx401, align 8
  %call402 = call i32 @strcmp(ptr noundef %234, ptr noundef @.str.514) #12
  %tobool403 = icmp ne i32 %call402, 0
  br i1 %tobool403, label %if.else405, label %if.then404

if.then404:                                       ; preds = %if.else399
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %if.end885

if.else405:                                       ; preds = %if.else399
  %235 = load ptr, ptr %argv.addr, align 8
  %236 = load i32, ptr %i, align 4
  %idxprom406 = sext i32 %236 to i64
  %arrayidx407 = getelementptr inbounds ptr, ptr %235, i64 %idxprom406
  %237 = load ptr, ptr %arrayidx407, align 8
  %call408 = call i32 @strcmp(ptr noundef %237, ptr noundef @.str.515) #12
  %tobool409 = icmp ne i32 %call408, 0
  br i1 %tobool409, label %if.else411, label %if.then410

if.then410:                                       ; preds = %if.else405
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 48), align 4
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %if.end884

if.else411:                                       ; preds = %if.else405
  %238 = load ptr, ptr %argv.addr, align 8
  %239 = load i32, ptr %i, align 4
  %idxprom412 = sext i32 %239 to i64
  %arrayidx413 = getelementptr inbounds ptr, ptr %238, i64 %idxprom412
  %240 = load ptr, ptr %arrayidx413, align 8
  %call414 = call i32 @strcmp(ptr noundef %240, ptr noundef @.str.516) #12
  %tobool415 = icmp ne i32 %call414, 0
  br i1 %tobool415, label %if.else417, label %if.then416

if.then416:                                       ; preds = %if.else411
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 17), align 8
  br label %if.end883

if.else417:                                       ; preds = %if.else411
  %241 = load ptr, ptr %argv.addr, align 8
  %242 = load i32, ptr %i, align 4
  %idxprom418 = sext i32 %242 to i64
  %arrayidx419 = getelementptr inbounds ptr, ptr %241, i64 %idxprom418
  %243 = load ptr, ptr %arrayidx419, align 8
  %call420 = call i32 @strcmp(ptr noundef %243, ptr noundef @.str.517) #12
  %tobool421 = icmp ne i32 %call420, 0
  br i1 %tobool421, label %if.else429, label %land.lhs.true422

land.lhs.true422:                                 ; preds = %if.else417
  %244 = load i32, ptr %lastarg, align 4
  %tobool423 = icmp ne i32 %244, 0
  br i1 %tobool423, label %if.else429, label %if.then424

if.then424:                                       ; preds = %land.lhs.true422
  %245 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 43), align 8
  call void @hi_sdsfree(ptr noundef %245)
  %246 = load ptr, ptr %argv.addr, align 8
  %247 = load i32, ptr %i, align 4
  %inc425 = add nsw i32 %247, 1
  store i32 %inc425, ptr %i, align 4
  %idxprom426 = sext i32 %inc425 to i64
  %arrayidx427 = getelementptr inbounds ptr, ptr %246, i64 %idxprom426
  %248 = load ptr, ptr %arrayidx427, align 8
  %call428 = call ptr @hi_sdsnew(ptr noundef %248)
  store ptr %call428, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 43), align 8
  br label %if.end882

if.else429:                                       ; preds = %land.lhs.true422, %if.else417
  %249 = load ptr, ptr %argv.addr, align 8
  %250 = load i32, ptr %i, align 4
  %idxprom430 = sext i32 %250 to i64
  %arrayidx431 = getelementptr inbounds ptr, ptr %249, i64 %idxprom430
  %251 = load ptr, ptr %arrayidx431, align 8
  %call432 = call i32 @strcmp(ptr noundef %251, ptr noundef @.str.518) #12
  %tobool433 = icmp ne i32 %call432, 0
  br i1 %tobool433, label %if.else441, label %land.lhs.true434

land.lhs.true434:                                 ; preds = %if.else429
  %252 = load i32, ptr %lastarg, align 4
  %tobool435 = icmp ne i32 %252, 0
  br i1 %tobool435, label %if.else441, label %if.then436

if.then436:                                       ; preds = %land.lhs.true434
  %253 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 44), align 8
  call void @hi_sdsfree(ptr noundef %253)
  %254 = load ptr, ptr %argv.addr, align 8
  %255 = load i32, ptr %i, align 4
  %inc437 = add nsw i32 %255, 1
  store i32 %inc437, ptr %i, align 4
  %idxprom438 = sext i32 %inc437 to i64
  %arrayidx439 = getelementptr inbounds ptr, ptr %254, i64 %idxprom438
  %256 = load ptr, ptr %arrayidx439, align 8
  %call440 = call ptr @hi_sdsnew(ptr noundef %256)
  store ptr %call440, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 44), align 8
  br label %if.end881

if.else441:                                       ; preds = %land.lhs.true434, %if.else429
  %257 = load ptr, ptr %argv.addr, align 8
  %258 = load i32, ptr %i, align 4
  %idxprom442 = sext i32 %258 to i64
  %arrayidx443 = getelementptr inbounds ptr, ptr %257, i64 %idxprom442
  %259 = load ptr, ptr %arrayidx443, align 8
  %call444 = call i32 @strcmp(ptr noundef %259, ptr noundef @.str.519) #12
  %tobool445 = icmp ne i32 %call444, 0
  br i1 %tobool445, label %if.else447, label %if.then446

if.then446:                                       ; preds = %if.else441
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 54), align 4
  br label %if.end880

if.else447:                                       ; preds = %if.else441
  %260 = load ptr, ptr %argv.addr, align 8
  %261 = load i32, ptr %i, align 4
  %idxprom448 = sext i32 %261 to i64
  %arrayidx449 = getelementptr inbounds ptr, ptr %260, i64 %idxprom448
  %262 = load ptr, ptr %arrayidx449, align 8
  %call450 = call i32 @strcmp(ptr noundef %262, ptr noundef @.str.520) #12
  %tobool451 = icmp ne i32 %call450, 0
  br i1 %tobool451, label %if.else453, label %if.then452

if.then452:                                       ; preds = %if.else447
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 53), align 8
  br label %if.end879

if.else453:                                       ; preds = %if.else447
  %263 = load ptr, ptr %argv.addr, align 8
  %264 = load i32, ptr %i, align 4
  %idxprom454 = sext i32 %264 to i64
  %arrayidx455 = getelementptr inbounds ptr, ptr %263, i64 %idxprom454
  %265 = load ptr, ptr %arrayidx455, align 8
  %call456 = call i32 @strcmp(ptr noundef %265, ptr noundef @.str.521) #12
  %tobool457 = icmp ne i32 %call456, 0
  br i1 %tobool457, label %if.else487, label %land.lhs.true458

land.lhs.true458:                                 ; preds = %if.else453
  %266 = load i32, ptr %lastarg, align 4
  %tobool459 = icmp ne i32 %266, 0
  br i1 %tobool459, label %if.else487, label %if.then460

if.then460:                                       ; preds = %land.lhs.true458
  %267 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55), align 8
  %cmp461 = icmp ne ptr %267, null
  br i1 %cmp461, label %if.then463, label %if.end464

if.then463:                                       ; preds = %if.then460
  call void @usage(i32 noundef 1)
  br label %if.end464

if.end464:                                        ; preds = %if.then463, %if.then460
  %268 = load ptr, ptr %argv.addr, align 8
  %269 = load i32, ptr %i, align 4
  %inc465 = add nsw i32 %269, 1
  store i32 %inc465, ptr %i, align 4
  %idxprom466 = sext i32 %inc465 to i64
  %arrayidx467 = getelementptr inbounds ptr, ptr %268, i64 %idxprom466
  %270 = load ptr, ptr %arrayidx467, align 8
  store ptr %270, ptr %cmd, align 8
  %271 = load i32, ptr %i, align 4
  store i32 %271, ptr %j, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end464
  %272 = load i32, ptr %j, align 4
  %273 = load i32, ptr %argc.addr, align 4
  %cmp468 = icmp slt i32 %272, %273
  br i1 %cmp468, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %274 = load ptr, ptr %argv.addr, align 8
  %275 = load i32, ptr %j, align 4
  %idxprom470 = sext i32 %275 to i64
  %arrayidx471 = getelementptr inbounds ptr, ptr %274, i64 %idxprom470
  %276 = load ptr, ptr %arrayidx471, align 8
  %arrayidx472 = getelementptr inbounds i8, ptr %276, i64 0
  %277 = load i8, ptr %arrayidx472, align 1
  %conv473 = sext i8 %277 to i32
  %cmp474 = icmp ne i32 %conv473, 45
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %278 = phi i1 [ false, %while.cond ], [ %cmp474, %land.rhs ]
  br i1 %278, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %279 = load i32, ptr %j, align 4
  %inc476 = add nsw i32 %279, 1
  store i32 %inc476, ptr %j, align 4
  br label %while.cond, !llvm.loop !71

while.end:                                        ; preds = %land.end
  %280 = load i32, ptr %j, align 4
  %281 = load i32, ptr %i, align 4
  %cmp477 = icmp sgt i32 %280, %281
  br i1 %cmp477, label %if.then479, label %if.end480

if.then479:                                       ; preds = %while.end
  %282 = load i32, ptr %j, align 4
  %dec = add nsw i32 %282, -1
  store i32 %dec, ptr %j, align 4
  br label %if.end480

if.end480:                                        ; preds = %if.then479, %while.end
  %283 = load ptr, ptr %cmd, align 8
  %284 = load i32, ptr %j, align 4
  %285 = load i32, ptr %i, align 4
  %sub481 = sub nsw i32 %284, %285
  %286 = load ptr, ptr %argv.addr, align 8
  %287 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %287 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %286, i64 %idx.ext
  %add.ptr482 = getelementptr inbounds ptr, ptr %add.ptr, i64 1
  %call483 = call i32 @createClusterManagerCommand(ptr noundef %283, i32 noundef %sub481, ptr noundef %add.ptr482)
  store i32 %call483, ptr %err, align 4
  %288 = load i32, ptr %err, align 4
  %tobool484 = icmp ne i32 %288, 0
  br i1 %tobool484, label %if.then485, label %if.end486

if.then485:                                       ; preds = %if.end480
  %289 = load i32, ptr %err, align 4
  call void @exit(i32 noundef %289) #17
  unreachable

if.end486:                                        ; preds = %if.end480
  %290 = load i32, ptr %j, align 4
  store i32 %290, ptr %i, align 4
  br label %if.end878

if.else487:                                       ; preds = %land.lhs.true458, %if.else453
  %291 = load ptr, ptr %argv.addr, align 8
  %292 = load i32, ptr %i, align 4
  %idxprom488 = sext i32 %292 to i64
  %arrayidx489 = getelementptr inbounds ptr, ptr %291, i64 %idxprom488
  %293 = load ptr, ptr %arrayidx489, align 8
  %call490 = call i32 @strcmp(ptr noundef %293, ptr noundef @.str.521) #12
  %tobool491 = icmp ne i32 %call490, 0
  br i1 %tobool491, label %if.else495, label %land.lhs.true492

land.lhs.true492:                                 ; preds = %if.else487
  %294 = load i32, ptr %lastarg, align 4
  %tobool493 = icmp ne i32 %294, 0
  br i1 %tobool493, label %if.then494, label %if.else495

if.then494:                                       ; preds = %land.lhs.true492
  call void @usage(i32 noundef 1)
  br label %if.end877

if.else495:                                       ; preds = %land.lhs.true492, %if.else487
  %295 = load ptr, ptr %argv.addr, align 8
  %296 = load i32, ptr %i, align 4
  %idxprom496 = sext i32 %296 to i64
  %arrayidx497 = getelementptr inbounds ptr, ptr %295, i64 %idxprom496
  %297 = load ptr, ptr %arrayidx497, align 8
  %call498 = call i32 @strcmp(ptr noundef %297, ptr noundef @.str.522) #12
  %tobool499 = icmp ne i32 %call498, 0
  br i1 %tobool499, label %if.else501, label %if.then500

if.then500:                                       ; preds = %if.else495
  %298 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or = or i32 %298, 2048
  store i32 %or, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end876

if.else501:                                       ; preds = %if.else495
  %299 = load ptr, ptr %argv.addr, align 8
  %300 = load i32, ptr %i, align 4
  %idxprom502 = sext i32 %300 to i64
  %arrayidx503 = getelementptr inbounds ptr, ptr %299, i64 %idxprom502
  %301 = load ptr, ptr %arrayidx503, align 8
  %call504 = call i32 @strcmp(ptr noundef %301, ptr noundef @.str.523) #12
  %tobool505 = icmp ne i32 %call504, 0
  br i1 %tobool505, label %if.else508, label %if.then506

if.then506:                                       ; preds = %if.else501
  %302 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or507 = or i32 %302, 4096
  store i32 %or507, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end875

if.else508:                                       ; preds = %if.else501
  %303 = load ptr, ptr %argv.addr, align 8
  %304 = load i32, ptr %i, align 4
  %idxprom509 = sext i32 %304 to i64
  %arrayidx510 = getelementptr inbounds ptr, ptr %303, i64 %idxprom509
  %305 = load ptr, ptr %arrayidx510, align 8
  %call511 = call i32 @strcmp(ptr noundef %305, ptr noundef @.str.524) #12
  %tobool512 = icmp ne i32 %call511, 0
  br i1 %tobool512, label %if.else520, label %land.lhs.true513

land.lhs.true513:                                 ; preds = %if.else508
  %306 = load i32, ptr %lastarg, align 4
  %tobool514 = icmp ne i32 %306, 0
  br i1 %tobool514, label %if.else520, label %if.then515

if.then515:                                       ; preds = %land.lhs.true513
  %307 = load ptr, ptr %argv.addr, align 8
  %308 = load i32, ptr %i, align 4
  %inc516 = add nsw i32 %308, 1
  store i32 %inc516, ptr %i, align 4
  %idxprom517 = sext i32 %inc516 to i64
  %arrayidx518 = getelementptr inbounds ptr, ptr %307, i64 %idxprom517
  %309 = load ptr, ptr %arrayidx518, align 8
  %call519 = call i32 @atoi(ptr noundef %309) #12
  store i32 %call519, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 5), align 4
  br label %if.end874

if.else520:                                       ; preds = %land.lhs.true513, %if.else508
  %310 = load ptr, ptr %argv.addr, align 8
  %311 = load i32, ptr %i, align 4
  %idxprom521 = sext i32 %311 to i64
  %arrayidx522 = getelementptr inbounds ptr, ptr %310, i64 %idxprom521
  %312 = load ptr, ptr %arrayidx522, align 8
  %call523 = call i32 @strcmp(ptr noundef %312, ptr noundef @.str.525) #12
  %tobool524 = icmp ne i32 %call523, 0
  br i1 %tobool524, label %if.else531, label %land.lhs.true525

land.lhs.true525:                                 ; preds = %if.else520
  %313 = load i32, ptr %lastarg, align 4
  %tobool526 = icmp ne i32 %313, 0
  br i1 %tobool526, label %if.else531, label %if.then527

if.then527:                                       ; preds = %land.lhs.true525
  %314 = load ptr, ptr %argv.addr, align 8
  %315 = load i32, ptr %i, align 4
  %inc528 = add nsw i32 %315, 1
  store i32 %inc528, ptr %i, align 4
  %idxprom529 = sext i32 %inc528 to i64
  %arrayidx530 = getelementptr inbounds ptr, ptr %314, i64 %idxprom529
  %316 = load ptr, ptr %arrayidx530, align 8
  store ptr %316, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 10), align 8
  br label %if.end873

if.else531:                                       ; preds = %land.lhs.true525, %if.else520
  %317 = load ptr, ptr %argv.addr, align 8
  %318 = load i32, ptr %i, align 4
  %idxprom532 = sext i32 %318 to i64
  %arrayidx533 = getelementptr inbounds ptr, ptr %317, i64 %idxprom532
  %319 = load ptr, ptr %arrayidx533, align 8
  %call534 = call i32 @strcmp(ptr noundef %319, ptr noundef @.str.526) #12
  %tobool535 = icmp ne i32 %call534, 0
  br i1 %tobool535, label %if.else542, label %land.lhs.true536

land.lhs.true536:                                 ; preds = %if.else531
  %320 = load i32, ptr %lastarg, align 4
  %tobool537 = icmp ne i32 %320, 0
  br i1 %tobool537, label %if.else542, label %if.then538

if.then538:                                       ; preds = %land.lhs.true536
  %321 = load ptr, ptr %argv.addr, align 8
  %322 = load i32, ptr %i, align 4
  %inc539 = add nsw i32 %322, 1
  store i32 %inc539, ptr %i, align 4
  %idxprom540 = sext i32 %inc539 to i64
  %arrayidx541 = getelementptr inbounds ptr, ptr %321, i64 %idxprom540
  %323 = load ptr, ptr %arrayidx541, align 8
  store ptr %323, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 6), align 8
  br label %if.end872

if.else542:                                       ; preds = %land.lhs.true536, %if.else531
  %324 = load ptr, ptr %argv.addr, align 8
  %325 = load i32, ptr %i, align 4
  %idxprom543 = sext i32 %325 to i64
  %arrayidx544 = getelementptr inbounds ptr, ptr %324, i64 %idxprom543
  %326 = load ptr, ptr %arrayidx544, align 8
  %call545 = call i32 @strcmp(ptr noundef %326, ptr noundef @.str.527) #12
  %tobool546 = icmp ne i32 %call545, 0
  br i1 %tobool546, label %if.else553, label %land.lhs.true547

land.lhs.true547:                                 ; preds = %if.else542
  %327 = load i32, ptr %lastarg, align 4
  %tobool548 = icmp ne i32 %327, 0
  br i1 %tobool548, label %if.else553, label %if.then549

if.then549:                                       ; preds = %land.lhs.true547
  %328 = load ptr, ptr %argv.addr, align 8
  %329 = load i32, ptr %i, align 4
  %inc550 = add nsw i32 %329, 1
  store i32 %inc550, ptr %i, align 4
  %idxprom551 = sext i32 %inc550 to i64
  %arrayidx552 = getelementptr inbounds ptr, ptr %328, i64 %idxprom551
  %330 = load ptr, ptr %arrayidx552, align 8
  store ptr %330, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 7), align 8
  br label %if.end871

if.else553:                                       ; preds = %land.lhs.true547, %if.else542
  %331 = load ptr, ptr %argv.addr, align 8
  %332 = load i32, ptr %i, align 4
  %idxprom554 = sext i32 %332 to i64
  %arrayidx555 = getelementptr inbounds ptr, ptr %331, i64 %idxprom554
  %333 = load ptr, ptr %arrayidx555, align 8
  %call556 = call i32 @strcmp(ptr noundef %333, ptr noundef @.str.528) #12
  %tobool557 = icmp ne i32 %call556, 0
  br i1 %tobool557, label %if.else564, label %land.lhs.true558

land.lhs.true558:                                 ; preds = %if.else553
  %334 = load i32, ptr %lastarg, align 4
  %tobool559 = icmp ne i32 %334, 0
  br i1 %tobool559, label %if.else564, label %if.then560

if.then560:                                       ; preds = %land.lhs.true558
  %335 = load ptr, ptr %argv.addr, align 8
  %336 = load i32, ptr %i, align 4
  %inc561 = add nsw i32 %336, 1
  store i32 %inc561, ptr %i, align 4
  %idxprom562 = sext i32 %inc561 to i64
  %arrayidx563 = getelementptr inbounds ptr, ptr %335, i64 %idxprom562
  %337 = load ptr, ptr %arrayidx563, align 8
  store ptr %337, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 16), align 8
  br label %if.end870

if.else564:                                       ; preds = %land.lhs.true558, %if.else553
  %338 = load ptr, ptr %argv.addr, align 8
  %339 = load i32, ptr %i, align 4
  %idxprom565 = sext i32 %339 to i64
  %arrayidx566 = getelementptr inbounds ptr, ptr %338, i64 %idxprom565
  %340 = load ptr, ptr %arrayidx566, align 8
  %call567 = call i32 @strcmp(ptr noundef %340, ptr noundef @.str.529) #12
  %tobool568 = icmp ne i32 %call567, 0
  br i1 %tobool568, label %if.else575, label %land.lhs.true569

land.lhs.true569:                                 ; preds = %if.else564
  %341 = load i32, ptr %lastarg, align 4
  %tobool570 = icmp ne i32 %341, 0
  br i1 %tobool570, label %if.else575, label %if.then571

if.then571:                                       ; preds = %land.lhs.true569
  %342 = load ptr, ptr %argv.addr, align 8
  %343 = load i32, ptr %i, align 4
  %inc572 = add nsw i32 %343, 1
  store i32 %inc572, ptr %i, align 4
  %idxprom573 = sext i32 %inc572 to i64
  %arrayidx574 = getelementptr inbounds ptr, ptr %342, i64 %idxprom573
  %344 = load ptr, ptr %arrayidx574, align 8
  store ptr %344, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 17), align 8
  br label %if.end869

if.else575:                                       ; preds = %land.lhs.true569, %if.else564
  %345 = load ptr, ptr %argv.addr, align 8
  %346 = load i32, ptr %i, align 4
  %idxprom576 = sext i32 %346 to i64
  %arrayidx577 = getelementptr inbounds ptr, ptr %345, i64 %idxprom576
  %347 = load ptr, ptr %arrayidx577, align 8
  %call578 = call i32 @strcmp(ptr noundef %347, ptr noundef @.str.530) #12
  %tobool579 = icmp ne i32 %call578, 0
  br i1 %tobool579, label %if.else581, label %if.then580

if.then580:                                       ; preds = %if.else575
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 18), align 8
  br label %if.end868

if.else581:                                       ; preds = %if.else575
  %348 = load ptr, ptr %argv.addr, align 8
  %349 = load i32, ptr %i, align 4
  %idxprom582 = sext i32 %349 to i64
  %arrayidx583 = getelementptr inbounds ptr, ptr %348, i64 %idxprom582
  %350 = load ptr, ptr %arrayidx583, align 8
  %call584 = call i32 @strcmp(ptr noundef %350, ptr noundef @.str.531) #12
  %tobool585 = icmp ne i32 %call584, 0
  br i1 %tobool585, label %if.else623, label %land.lhs.true586

land.lhs.true586:                                 ; preds = %if.else581
  %351 = load i32, ptr %lastarg, align 4
  %tobool587 = icmp ne i32 %351, 0
  br i1 %tobool587, label %if.else623, label %if.then588

if.then588:                                       ; preds = %land.lhs.true586
  %352 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 8), align 8
  %cmp589 = icmp ne ptr %352, null
  br i1 %cmp589, label %if.then591, label %if.end593

if.then591:                                       ; preds = %if.then588
  %353 = load ptr, ptr @stderr, align 8
  %call592 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %353, ptr noundef @.str.532)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end593:                                        ; preds = %if.then588
  %354 = load i32, ptr %i, align 4
  %add = add nsw i32 %354, 1
  store i32 %add, ptr %widx, align 4
  %355 = load ptr, ptr %argv.addr, align 8
  %356 = load i32, ptr %widx, align 4
  %idx.ext594 = sext i32 %356 to i64
  %add.ptr595 = getelementptr inbounds ptr, ptr %355, i64 %idx.ext594
  store ptr %add.ptr595, ptr %weight, align 8
  store i32 0, ptr %wargc, align 4
  br label %for.cond596

for.cond596:                                      ; preds = %for.inc, %if.end593
  %357 = load i32, ptr %widx, align 4
  %358 = load i32, ptr %argc.addr, align 4
  %cmp597 = icmp slt i32 %357, %358
  br i1 %cmp597, label %for.body599, label %for.end

for.body599:                                      ; preds = %for.cond596
  %359 = load ptr, ptr %argv.addr, align 8
  %360 = load i32, ptr %widx, align 4
  %idxprom600 = sext i32 %360 to i64
  %arrayidx601 = getelementptr inbounds ptr, ptr %359, i64 %idxprom600
  %361 = load ptr, ptr %arrayidx601, align 8
  %call602 = call ptr @strstr(ptr noundef %361, ptr noundef @.str.533) #12
  %362 = load ptr, ptr %argv.addr, align 8
  %363 = load i32, ptr %widx, align 4
  %idxprom603 = sext i32 %363 to i64
  %arrayidx604 = getelementptr inbounds ptr, ptr %362, i64 %idxprom603
  %364 = load ptr, ptr %arrayidx604, align 8
  %cmp605 = icmp eq ptr %call602, %364
  br i1 %cmp605, label %if.then607, label %if.end608

if.then607:                                       ; preds = %for.body599
  br label %for.end

if.end608:                                        ; preds = %for.body599
  %365 = load ptr, ptr %argv.addr, align 8
  %366 = load i32, ptr %widx, align 4
  %idxprom609 = sext i32 %366 to i64
  %arrayidx610 = getelementptr inbounds ptr, ptr %365, i64 %idxprom609
  %367 = load ptr, ptr %arrayidx610, align 8
  %call611 = call ptr @strchr(ptr noundef %367, i32 noundef 61) #12
  %cmp612 = icmp eq ptr %call611, null
  br i1 %cmp612, label %if.then614, label %if.end615

if.then614:                                       ; preds = %if.end608
  br label %for.end

if.end615:                                        ; preds = %if.end608
  %368 = load i32, ptr %wargc, align 4
  %inc616 = add nsw i32 %368, 1
  store i32 %inc616, ptr %wargc, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end615
  %369 = load i32, ptr %widx, align 4
  %inc617 = add nsw i32 %369, 1
  store i32 %inc617, ptr %widx, align 4
  br label %for.cond596, !llvm.loop !72

for.end:                                          ; preds = %if.then614, %if.then607, %for.cond596
  %370 = load i32, ptr %wargc, align 4
  %cmp618 = icmp sgt i32 %370, 0
  br i1 %cmp618, label %if.then620, label %if.end622

if.then620:                                       ; preds = %for.end
  %371 = load ptr, ptr %weight, align 8
  store ptr %371, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 8), align 8
  %372 = load i32, ptr %wargc, align 4
  store i32 %372, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 9), align 8
  %373 = load i32, ptr %wargc, align 4
  %374 = load i32, ptr %i, align 4
  %add621 = add nsw i32 %374, %373
  store i32 %add621, ptr %i, align 4
  br label %if.end622

if.end622:                                        ; preds = %if.then620, %for.end
  br label %if.end867

if.else623:                                       ; preds = %land.lhs.true586, %if.else581
  %375 = load ptr, ptr %argv.addr, align 8
  %376 = load i32, ptr %i, align 4
  %idxprom624 = sext i32 %376 to i64
  %arrayidx625 = getelementptr inbounds ptr, ptr %375, i64 %idxprom624
  %377 = load ptr, ptr %arrayidx625, align 8
  %call626 = call i32 @strcmp(ptr noundef %377, ptr noundef @.str.534) #12
  %tobool627 = icmp ne i32 %call626, 0
  br i1 %tobool627, label %if.else635, label %land.lhs.true628

land.lhs.true628:                                 ; preds = %if.else623
  %378 = load i32, ptr %lastarg, align 4
  %tobool629 = icmp ne i32 %378, 0
  br i1 %tobool629, label %if.else635, label %if.then630

if.then630:                                       ; preds = %land.lhs.true628
  %379 = load ptr, ptr %argv.addr, align 8
  %380 = load i32, ptr %i, align 4
  %inc631 = add nsw i32 %380, 1
  store i32 %inc631, ptr %i, align 4
  %idxprom632 = sext i32 %inc631 to i64
  %arrayidx633 = getelementptr inbounds ptr, ptr %379, i64 %idxprom632
  %381 = load ptr, ptr %arrayidx633, align 8
  %call634 = call i32 @atoi(ptr noundef %381) #12
  store i32 %call634, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 11), align 8
  br label %if.end866

if.else635:                                       ; preds = %land.lhs.true628, %if.else623
  %382 = load ptr, ptr %argv.addr, align 8
  %383 = load i32, ptr %i, align 4
  %idxprom636 = sext i32 %383 to i64
  %arrayidx637 = getelementptr inbounds ptr, ptr %382, i64 %idxprom636
  %384 = load ptr, ptr %arrayidx637, align 8
  %call638 = call i32 @strcmp(ptr noundef %384, ptr noundef @.str.535) #12
  %tobool639 = icmp ne i32 %call638, 0
  br i1 %tobool639, label %if.else647, label %land.lhs.true640

land.lhs.true640:                                 ; preds = %if.else635
  %385 = load i32, ptr %lastarg, align 4
  %tobool641 = icmp ne i32 %385, 0
  br i1 %tobool641, label %if.else647, label %if.then642

if.then642:                                       ; preds = %land.lhs.true640
  %386 = load ptr, ptr %argv.addr, align 8
  %387 = load i32, ptr %i, align 4
  %inc643 = add nsw i32 %387, 1
  store i32 %inc643, ptr %i, align 4
  %idxprom644 = sext i32 %inc643 to i64
  %arrayidx645 = getelementptr inbounds ptr, ptr %386, i64 %idxprom644
  %388 = load ptr, ptr %arrayidx645, align 8
  %call646 = call i32 @atoi(ptr noundef %388) #12
  store i32 %call646, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 12), align 4
  br label %if.end865

if.else647:                                       ; preds = %land.lhs.true640, %if.else635
  %389 = load ptr, ptr %argv.addr, align 8
  %390 = load i32, ptr %i, align 4
  %idxprom648 = sext i32 %390 to i64
  %arrayidx649 = getelementptr inbounds ptr, ptr %389, i64 %idxprom648
  %391 = load ptr, ptr %arrayidx649, align 8
  %call650 = call i32 @strcmp(ptr noundef %391, ptr noundef @.str.536) #12
  %tobool651 = icmp ne i32 %call650, 0
  br i1 %tobool651, label %if.else659, label %land.lhs.true652

land.lhs.true652:                                 ; preds = %if.else647
  %392 = load i32, ptr %lastarg, align 4
  %tobool653 = icmp ne i32 %392, 0
  br i1 %tobool653, label %if.else659, label %if.then654

if.then654:                                       ; preds = %land.lhs.true652
  %393 = load ptr, ptr %argv.addr, align 8
  %394 = load i32, ptr %i, align 4
  %inc655 = add nsw i32 %394, 1
  store i32 %inc655, ptr %i, align 4
  %idxprom656 = sext i32 %inc655 to i64
  %arrayidx657 = getelementptr inbounds ptr, ptr %393, i64 %idxprom656
  %395 = load ptr, ptr %arrayidx657, align 8
  %call658 = call i32 @atoi(ptr noundef %395) #12
  store i32 %call658, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 13), align 8
  br label %if.end864

if.else659:                                       ; preds = %land.lhs.true652, %if.else647
  %396 = load ptr, ptr %argv.addr, align 8
  %397 = load i32, ptr %i, align 4
  %idxprom660 = sext i32 %397 to i64
  %arrayidx661 = getelementptr inbounds ptr, ptr %396, i64 %idxprom660
  %398 = load ptr, ptr %arrayidx661, align 8
  %call662 = call i32 @strcmp(ptr noundef %398, ptr noundef @.str.537) #12
  %tobool663 = icmp ne i32 %call662, 0
  br i1 %tobool663, label %if.else672, label %land.lhs.true664

land.lhs.true664:                                 ; preds = %if.else659
  %399 = load i32, ptr %lastarg, align 4
  %tobool665 = icmp ne i32 %399, 0
  br i1 %tobool665, label %if.else672, label %if.then666

if.then666:                                       ; preds = %land.lhs.true664
  %400 = load ptr, ptr %argv.addr, align 8
  %401 = load i32, ptr %i, align 4
  %inc667 = add nsw i32 %401, 1
  store i32 %inc667, ptr %i, align 4
  %idxprom668 = sext i32 %inc667 to i64
  %arrayidx669 = getelementptr inbounds ptr, ptr %400, i64 %idxprom668
  %402 = load ptr, ptr %arrayidx669, align 8
  %call670 = call double @atof(ptr noundef %402) #12
  %conv671 = fptrunc double %call670 to float
  store float %conv671, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 14), align 4
  br label %if.end863

if.else672:                                       ; preds = %land.lhs.true664, %if.else659
  %403 = load ptr, ptr %argv.addr, align 8
  %404 = load i32, ptr %i, align 4
  %idxprom673 = sext i32 %404 to i64
  %arrayidx674 = getelementptr inbounds ptr, ptr %403, i64 %idxprom673
  %405 = load ptr, ptr %arrayidx674, align 8
  %call675 = call i32 @strcmp(ptr noundef %405, ptr noundef @.str.61) #12
  %tobool676 = icmp ne i32 %call675, 0
  br i1 %tobool676, label %if.else679, label %if.then677

if.then677:                                       ; preds = %if.else672
  %406 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or678 = or i32 %406, 4
  store i32 %or678, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end862

if.else679:                                       ; preds = %if.else672
  %407 = load ptr, ptr %argv.addr, align 8
  %408 = load i32, ptr %i, align 4
  %idxprom680 = sext i32 %408 to i64
  %arrayidx681 = getelementptr inbounds ptr, ptr %407, i64 %idxprom680
  %409 = load ptr, ptr %arrayidx681, align 8
  %call682 = call i32 @strcmp(ptr noundef %409, ptr noundef @.str.538) #12
  %tobool683 = icmp ne i32 %call682, 0
  br i1 %tobool683, label %if.else686, label %if.then684

if.then684:                                       ; preds = %if.else679
  %410 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or685 = or i32 %410, 32
  store i32 %or685, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end861

if.else686:                                       ; preds = %if.else679
  %411 = load ptr, ptr %argv.addr, align 8
  %412 = load i32, ptr %i, align 4
  %idxprom687 = sext i32 %412 to i64
  %arrayidx688 = getelementptr inbounds ptr, ptr %411, i64 %idxprom687
  %413 = load ptr, ptr %arrayidx688, align 8
  %call689 = call i32 @strcmp(ptr noundef %413, ptr noundef @.str.539) #12
  %tobool690 = icmp ne i32 %call689, 0
  br i1 %tobool690, label %if.else693, label %if.then691

if.then691:                                       ; preds = %if.else686
  %414 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or692 = or i32 %414, 64
  store i32 %or692, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end860

if.else693:                                       ; preds = %if.else686
  %415 = load ptr, ptr %argv.addr, align 8
  %416 = load i32, ptr %i, align 4
  %idxprom694 = sext i32 %416 to i64
  %arrayidx695 = getelementptr inbounds ptr, ptr %415, i64 %idxprom694
  %417 = load ptr, ptr %arrayidx695, align 8
  %call696 = call i32 @strcmp(ptr noundef %417, ptr noundef @.str.540) #12
  %tobool697 = icmp ne i32 %call696, 0
  br i1 %tobool697, label %if.else700, label %if.then698

if.then698:                                       ; preds = %if.else693
  %418 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or699 = or i32 %418, 128
  store i32 %or699, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end859

if.else700:                                       ; preds = %if.else693
  %419 = load ptr, ptr %argv.addr, align 8
  %420 = load i32, ptr %i, align 4
  %idxprom701 = sext i32 %420 to i64
  %arrayidx702 = getelementptr inbounds ptr, ptr %419, i64 %idxprom701
  %421 = load ptr, ptr %arrayidx702, align 8
  %call703 = call i32 @strcmp(ptr noundef %421, ptr noundef @.str.541) #12
  %tobool704 = icmp ne i32 %call703, 0
  br i1 %tobool704, label %if.else707, label %if.then705

if.then705:                                       ; preds = %if.else700
  %422 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or706 = or i32 %422, 2
  store i32 %or706, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end858

if.else707:                                       ; preds = %if.else700
  %423 = load ptr, ptr %argv.addr, align 8
  %424 = load i32, ptr %i, align 4
  %idxprom708 = sext i32 %424 to i64
  %arrayidx709 = getelementptr inbounds ptr, ptr %423, i64 %idxprom708
  %425 = load ptr, ptr %arrayidx709, align 8
  %call710 = call i32 @strcmp(ptr noundef %425, ptr noundef @.str.542) #12
  %tobool711 = icmp ne i32 %call710, 0
  br i1 %tobool711, label %if.else714, label %if.then712

if.then712:                                       ; preds = %if.else707
  %426 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or713 = or i32 %426, 16
  store i32 %or713, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end857

if.else714:                                       ; preds = %if.else707
  %427 = load ptr, ptr %argv.addr, align 8
  %428 = load i32, ptr %i, align 4
  %idxprom715 = sext i32 %428 to i64
  %arrayidx716 = getelementptr inbounds ptr, ptr %427, i64 %idxprom715
  %429 = load ptr, ptr %arrayidx716, align 8
  %call717 = call i32 @strcmp(ptr noundef %429, ptr noundef @.str.543) #12
  %tobool718 = icmp ne i32 %call717, 0
  br i1 %tobool718, label %if.else721, label %if.then719

if.then719:                                       ; preds = %if.else714
  %430 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or720 = or i32 %430, 512
  store i32 %or720, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end856

if.else721:                                       ; preds = %if.else714
  %431 = load ptr, ptr %argv.addr, align 8
  %432 = load i32, ptr %i, align 4
  %idxprom722 = sext i32 %432 to i64
  %arrayidx723 = getelementptr inbounds ptr, ptr %431, i64 %idxprom722
  %433 = load ptr, ptr %arrayidx723, align 8
  %call724 = call i32 @strcmp(ptr noundef %433, ptr noundef @.str.544) #12
  %tobool725 = icmp ne i32 %call724, 0
  br i1 %tobool725, label %if.else728, label %if.then726

if.then726:                                       ; preds = %if.else721
  %434 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or727 = or i32 %434, 1024
  store i32 %or727, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end855

if.else728:                                       ; preds = %if.else721
  %435 = load ptr, ptr %argv.addr, align 8
  %436 = load i32, ptr %i, align 4
  %idxprom729 = sext i32 %436 to i64
  %arrayidx730 = getelementptr inbounds ptr, ptr %435, i64 %idxprom729
  %437 = load ptr, ptr %arrayidx730, align 8
  %call731 = call i32 @strcmp(ptr noundef %437, ptr noundef @.str.545) #12
  %tobool732 = icmp ne i32 %call731, 0
  br i1 %tobool732, label %if.else739, label %land.lhs.true733

land.lhs.true733:                                 ; preds = %if.else728
  %438 = load i32, ptr %lastarg, align 4
  %tobool734 = icmp ne i32 %438, 0
  br i1 %tobool734, label %if.else739, label %if.then735

if.then735:                                       ; preds = %land.lhs.true733
  %439 = load ptr, ptr %argv.addr, align 8
  %440 = load i32, ptr %i, align 4
  %inc736 = add nsw i32 %440, 1
  store i32 %inc736, ptr %i, align 4
  %idxprom737 = sext i32 %inc736 to i64
  %arrayidx738 = getelementptr inbounds ptr, ptr %439, i64 %idxprom737
  %441 = load ptr, ptr %arrayidx738, align 8
  store ptr %441, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 63), align 8
  br label %if.end854

if.else739:                                       ; preds = %land.lhs.true733, %if.else728
  %442 = load ptr, ptr %argv.addr, align 8
  %443 = load i32, ptr %i, align 4
  %idxprom740 = sext i32 %443 to i64
  %arrayidx741 = getelementptr inbounds ptr, ptr %442, i64 %idxprom740
  %444 = load ptr, ptr %arrayidx741, align 8
  %call742 = call i32 @strcmp(ptr noundef %444, ptr noundef @.str.546) #12
  %tobool743 = icmp ne i32 %call742, 0
  br i1 %tobool743, label %if.else750, label %land.lhs.true744

land.lhs.true744:                                 ; preds = %if.else739
  %445 = load i32, ptr %lastarg, align 4
  %tobool745 = icmp ne i32 %445, 0
  br i1 %tobool745, label %if.else750, label %if.then746

if.then746:                                       ; preds = %land.lhs.true744
  %446 = load ptr, ptr %argv.addr, align 8
  %447 = load i32, ptr %i, align 4
  %inc747 = add nsw i32 %447, 1
  store i32 %inc747, ptr %i, align 4
  %idxprom748 = sext i32 %inc747 to i64
  %arrayidx749 = getelementptr inbounds ptr, ptr %446, i64 %idxprom748
  %448 = load ptr, ptr %arrayidx749, align 8
  store ptr %448, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 64), align 8
  br label %if.end853

if.else750:                                       ; preds = %land.lhs.true744, %if.else739
  %449 = load ptr, ptr %argv.addr, align 8
  %450 = load i32, ptr %i, align 4
  %idxprom751 = sext i32 %450 to i64
  %arrayidx752 = getelementptr inbounds ptr, ptr %449, i64 %idxprom751
  %451 = load ptr, ptr %arrayidx752, align 8
  %call753 = call i32 @strcmp(ptr noundef %451, ptr noundef @.str.547) #12
  %tobool754 = icmp ne i32 %call753, 0
  br i1 %tobool754, label %lor.lhs.false755, label %if.then760

lor.lhs.false755:                                 ; preds = %if.else750
  %452 = load ptr, ptr %argv.addr, align 8
  %453 = load i32, ptr %i, align 4
  %idxprom756 = sext i32 %453 to i64
  %arrayidx757 = getelementptr inbounds ptr, ptr %452, i64 %idxprom756
  %454 = load ptr, ptr %arrayidx757, align 8
  %call758 = call i32 @strcmp(ptr noundef %454, ptr noundef @.str.548) #12
  %tobool759 = icmp ne i32 %call758, 0
  br i1 %tobool759, label %if.else763, label %if.then760

if.then760:                                       ; preds = %lor.lhs.false755, %if.else750
  %call761 = call ptr @cliVersion()
  store ptr %call761, ptr %version, align 8
  %455 = load ptr, ptr %version, align 8
  %call762 = call i32 (ptr, ...) @printf(ptr noundef @.str.549, ptr noundef %455)
  %456 = load ptr, ptr %version, align 8
  call void @hi_sdsfree(ptr noundef %456)
  call void @exit(i32 noundef 0) #17
  unreachable

if.else763:                                       ; preds = %lor.lhs.false755
  %457 = load ptr, ptr %argv.addr, align 8
  %458 = load i32, ptr %i, align 4
  %idxprom764 = sext i32 %458 to i64
  %arrayidx765 = getelementptr inbounds ptr, ptr %457, i64 %idxprom764
  %459 = load ptr, ptr %arrayidx765, align 8
  %call766 = call i32 @strcmp(ptr noundef %459, ptr noundef @.str.550) #12
  %tobool767 = icmp ne i32 %call766, 0
  br i1 %tobool767, label %if.else769, label %if.then768

if.then768:                                       ; preds = %if.else763
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 57), align 4
  br label %if.end851

if.else769:                                       ; preds = %if.else763
  %460 = load ptr, ptr %argv.addr, align 8
  %461 = load i32, ptr %i, align 4
  %idxprom770 = sext i32 %461 to i64
  %arrayidx771 = getelementptr inbounds ptr, ptr %460, i64 %idxprom770
  %462 = load ptr, ptr %arrayidx771, align 8
  %call772 = call i32 @strcmp(ptr noundef %462, ptr noundef @.str.551) #12
  %tobool773 = icmp ne i32 %call772, 0
  br i1 %tobool773, label %if.else775, label %if.then774

if.then774:                                       ; preds = %if.else769
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  br label %if.end850

if.else775:                                       ; preds = %if.else769
  %463 = load ptr, ptr %argv.addr, align 8
  %464 = load i32, ptr %i, align 4
  %idxprom776 = sext i32 %464 to i64
  %arrayidx777 = getelementptr inbounds ptr, ptr %463, i64 %idxprom776
  %465 = load ptr, ptr %arrayidx777, align 8
  %call778 = call i32 @strcmp(ptr noundef %465, ptr noundef @.str.552) #12
  %tobool779 = icmp ne i32 %call778, 0
  br i1 %tobool779, label %if.else797, label %land.lhs.true780

land.lhs.true780:                                 ; preds = %if.else775
  %466 = load i32, ptr %lastarg, align 4
  %tobool781 = icmp ne i32 %466, 0
  br i1 %tobool781, label %if.else797, label %if.then782

if.then782:                                       ; preds = %land.lhs.true780
  %467 = load ptr, ptr %argv.addr, align 8
  %468 = load i32, ptr %i, align 4
  %inc783 = add nsw i32 %468, 1
  store i32 %inc783, ptr %i, align 4
  %idxprom784 = sext i32 %inc783 to i64
  %arrayidx785 = getelementptr inbounds ptr, ptr %467, i64 %idxprom784
  %469 = load ptr, ptr %arrayidx785, align 8
  store ptr %469, ptr %argval, align 8
  %470 = load ptr, ptr %argval, align 8
  %call786 = call i32 @strncasecmp(ptr noundef %470, ptr noundef @.str.553, i64 noundef 1) #12
  %tobool787 = icmp ne i32 %call786, 0
  br i1 %tobool787, label %if.else789, label %if.then788

if.then788:                                       ; preds = %if.then782
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 42), align 4
  br label %if.end796

if.else789:                                       ; preds = %if.then782
  %471 = load ptr, ptr %argval, align 8
  %call790 = call i32 @strncasecmp(ptr noundef %471, ptr noundef @.str.554, i64 noundef 1) #12
  %tobool791 = icmp ne i32 %call790, 0
  br i1 %tobool791, label %if.else793, label %if.then792

if.then792:                                       ; preds = %if.else789
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 42), align 4
  br label %if.end795

if.else793:                                       ; preds = %if.else789
  %472 = load ptr, ptr @stderr, align 8
  %473 = load ptr, ptr %argval, align 8
  %call794 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %472, ptr noundef @.str.555, ptr noundef %473)
  br label %if.end795

if.end795:                                        ; preds = %if.else793, %if.then792
  br label %if.end796

if.end796:                                        ; preds = %if.end795, %if.then788
  br label %if.end849

if.else797:                                       ; preds = %land.lhs.true780, %if.else775
  %474 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55), align 8
  %cmp798 = icmp ne ptr %474, null
  br i1 %cmp798, label %land.lhs.true800, label %if.else836

land.lhs.true800:                                 ; preds = %if.else797
  %475 = load ptr, ptr %argv.addr, align 8
  %476 = load i32, ptr %i, align 4
  %idxprom801 = sext i32 %476 to i64
  %arrayidx802 = getelementptr inbounds ptr, ptr %475, i64 %idxprom801
  %477 = load ptr, ptr %arrayidx802, align 8
  %arrayidx803 = getelementptr inbounds i8, ptr %477, i64 0
  %478 = load i8, ptr %arrayidx803, align 1
  %conv804 = sext i8 %478 to i32
  %cmp805 = icmp ne i32 %conv804, 45
  br i1 %cmp805, label %if.then807, label %if.else836

if.then807:                                       ; preds = %land.lhs.true800
  %479 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 1), align 8
  %cmp808 = icmp eq i32 %479, 0
  br i1 %cmp808, label %if.then810, label %if.end835

if.then810:                                       ; preds = %if.then807
  %480 = load i32, ptr %i, align 4
  %add812 = add nsw i32 %480, 1
  store i32 %add812, ptr %j811, align 4
  br label %while.cond813

while.cond813:                                    ; preds = %while.body824, %if.then810
  %481 = load i32, ptr %j811, align 4
  %482 = load i32, ptr %argc.addr, align 4
  %cmp814 = icmp slt i32 %481, %482
  br i1 %cmp814, label %land.rhs816, label %land.end823

land.rhs816:                                      ; preds = %while.cond813
  %483 = load ptr, ptr %argv.addr, align 8
  %484 = load i32, ptr %j811, align 4
  %idxprom817 = sext i32 %484 to i64
  %arrayidx818 = getelementptr inbounds ptr, ptr %483, i64 %idxprom817
  %485 = load ptr, ptr %arrayidx818, align 8
  %arrayidx819 = getelementptr inbounds i8, ptr %485, i64 0
  %486 = load i8, ptr %arrayidx819, align 1
  %conv820 = sext i8 %486 to i32
  %cmp821 = icmp ne i32 %conv820, 45
  br label %land.end823

land.end823:                                      ; preds = %land.rhs816, %while.cond813
  %487 = phi i1 [ false, %while.cond813 ], [ %cmp821, %land.rhs816 ]
  br i1 %487, label %while.body824, label %while.end826

while.body824:                                    ; preds = %land.end823
  %488 = load i32, ptr %j811, align 4
  %inc825 = add nsw i32 %488, 1
  store i32 %inc825, ptr %j811, align 4
  br label %while.cond813, !llvm.loop !73

while.end826:                                     ; preds = %land.end823
  %489 = load i32, ptr %j811, align 4
  %490 = load i32, ptr %i, align 4
  %sub827 = sub nsw i32 %489, %490
  store i32 %sub827, ptr %cmd_argc, align 4
  %491 = load i32, ptr %cmd_argc, align 4
  store i32 %491, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 1), align 8
  %492 = load ptr, ptr %argv.addr, align 8
  %493 = load i32, ptr %i, align 4
  %idx.ext828 = sext i32 %493 to i64
  %add.ptr829 = getelementptr inbounds ptr, ptr %492, i64 %idx.ext828
  store ptr %add.ptr829, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 2), align 8
  %494 = load i32, ptr %cmd_argc, align 4
  %cmp830 = icmp sgt i32 %494, 1
  br i1 %cmp830, label %if.then832, label %if.end834

if.then832:                                       ; preds = %while.end826
  %495 = load i32, ptr %j811, align 4
  %sub833 = sub nsw i32 %495, 1
  store i32 %sub833, ptr %i, align 4
  br label %if.end834

if.end834:                                        ; preds = %if.then832, %while.end826
  br label %if.end835

if.end835:                                        ; preds = %if.end834, %if.then807
  br label %if.end848

if.else836:                                       ; preds = %land.lhs.true800, %if.else797
  %496 = load ptr, ptr %argv.addr, align 8
  %497 = load i32, ptr %i, align 4
  %idxprom837 = sext i32 %497 to i64
  %arrayidx838 = getelementptr inbounds ptr, ptr %496, i64 %idxprom837
  %498 = load ptr, ptr %arrayidx838, align 8
  %arrayidx839 = getelementptr inbounds i8, ptr %498, i64 0
  %499 = load i8, ptr %arrayidx839, align 1
  %conv840 = sext i8 %499 to i32
  %cmp841 = icmp eq i32 %conv840, 45
  br i1 %cmp841, label %if.then843, label %if.else847

if.then843:                                       ; preds = %if.else836
  %500 = load ptr, ptr @stderr, align 8
  %501 = load ptr, ptr %argv.addr, align 8
  %502 = load i32, ptr %i, align 4
  %idxprom844 = sext i32 %502 to i64
  %arrayidx845 = getelementptr inbounds ptr, ptr %501, i64 %idxprom844
  %503 = load ptr, ptr %arrayidx845, align 8
  %call846 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %500, ptr noundef @.str.556, ptr noundef %503)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else847:                                       ; preds = %if.else836
  br label %for.end931

if.end848:                                        ; preds = %if.end835
  br label %if.end849

if.end849:                                        ; preds = %if.end848, %if.end796
  br label %if.end850

if.end850:                                        ; preds = %if.end849, %if.then774
  br label %if.end851

if.end851:                                        ; preds = %if.end850, %if.then768
  br label %if.end852

if.end852:                                        ; preds = %if.end851
  br label %if.end853

if.end853:                                        ; preds = %if.end852, %if.then746
  br label %if.end854

if.end854:                                        ; preds = %if.end853, %if.then735
  br label %if.end855

if.end855:                                        ; preds = %if.end854, %if.then726
  br label %if.end856

if.end856:                                        ; preds = %if.end855, %if.then719
  br label %if.end857

if.end857:                                        ; preds = %if.end856, %if.then712
  br label %if.end858

if.end858:                                        ; preds = %if.end857, %if.then705
  br label %if.end859

if.end859:                                        ; preds = %if.end858, %if.then698
  br label %if.end860

if.end860:                                        ; preds = %if.end859, %if.then691
  br label %if.end861

if.end861:                                        ; preds = %if.end860, %if.then684
  br label %if.end862

if.end862:                                        ; preds = %if.end861, %if.then677
  br label %if.end863

if.end863:                                        ; preds = %if.end862, %if.then666
  br label %if.end864

if.end864:                                        ; preds = %if.end863, %if.then654
  br label %if.end865

if.end865:                                        ; preds = %if.end864, %if.then642
  br label %if.end866

if.end866:                                        ; preds = %if.end865, %if.then630
  br label %if.end867

if.end867:                                        ; preds = %if.end866, %if.end622
  br label %if.end868

if.end868:                                        ; preds = %if.end867, %if.then580
  br label %if.end869

if.end869:                                        ; preds = %if.end868, %if.then571
  br label %if.end870

if.end870:                                        ; preds = %if.end869, %if.then560
  br label %if.end871

if.end871:                                        ; preds = %if.end870, %if.then549
  br label %if.end872

if.end872:                                        ; preds = %if.end871, %if.then538
  br label %if.end873

if.end873:                                        ; preds = %if.end872, %if.then527
  br label %if.end874

if.end874:                                        ; preds = %if.end873, %if.then515
  br label %if.end875

if.end875:                                        ; preds = %if.end874, %if.then506
  br label %if.end876

if.end876:                                        ; preds = %if.end875, %if.then500
  br label %if.end877

if.end877:                                        ; preds = %if.end876, %if.then494
  br label %if.end878

if.end878:                                        ; preds = %if.end877, %if.end486
  br label %if.end879

if.end879:                                        ; preds = %if.end878, %if.then452
  br label %if.end880

if.end880:                                        ; preds = %if.end879, %if.then446
  br label %if.end881

if.end881:                                        ; preds = %if.end880, %if.then436
  br label %if.end882

if.end882:                                        ; preds = %if.end881, %if.then424
  br label %if.end883

if.end883:                                        ; preds = %if.end882, %if.then416
  br label %if.end884

if.end884:                                        ; preds = %if.end883, %if.then410
  br label %if.end885

if.end885:                                        ; preds = %if.end884, %if.then404
  br label %if.end886

if.end886:                                        ; preds = %if.end885, %if.then395
  br label %if.end887

if.end887:                                        ; preds = %if.end886, %if.then387
  br label %if.end888

if.end888:                                        ; preds = %if.end887, %if.then377
  br label %if.end889

if.end889:                                        ; preds = %if.end888, %if.then369
  br label %if.end890

if.end890:                                        ; preds = %if.end889, %if.then363
  br label %if.end891

if.end891:                                        ; preds = %if.end890, %if.then353
  br label %if.end892

if.end892:                                        ; preds = %if.end891, %if.then345
  br label %if.end893

if.end893:                                        ; preds = %if.end892, %if.then336
  br label %if.end894

if.end894:                                        ; preds = %if.end893, %if.then325
  br label %if.end895

if.end895:                                        ; preds = %if.end894, %if.then313
  br label %if.end896

if.end896:                                        ; preds = %if.end895, %if.end305
  br label %if.end897

if.end897:                                        ; preds = %if.end896, %if.then285
  br label %if.end898

if.end898:                                        ; preds = %if.end897, %if.then273
  br label %if.end899

if.end899:                                        ; preds = %if.end898, %if.then265
  br label %if.end900

if.end900:                                        ; preds = %if.end899, %if.then259
  br label %if.end901

if.end901:                                        ; preds = %if.end900, %if.then253
  br label %if.end902

if.end902:                                        ; preds = %if.end901, %if.then247
  br label %if.end903

if.end903:                                        ; preds = %if.end902, %if.then237
  br label %if.end904

if.end904:                                        ; preds = %if.end903, %if.then229
  br label %if.end905

if.end905:                                        ; preds = %if.end904, %if.then223
  br label %if.end906

if.end906:                                        ; preds = %if.end905, %if.then217
  br label %if.end907

if.end907:                                        ; preds = %if.end906, %if.then211
  br label %if.end908

if.end908:                                        ; preds = %if.end907, %if.end205
  br label %if.end909

if.end909:                                        ; preds = %if.end908, %if.end195
  br label %if.end910

if.end910:                                        ; preds = %if.end909, %if.then185
  br label %if.end911

if.end911:                                        ; preds = %if.end910, %if.then179
  br label %if.end912

if.end912:                                        ; preds = %if.end911, %if.then173
  br label %if.end913

if.end913:                                        ; preds = %if.end912, %if.then167
  br label %if.end914

if.end914:                                        ; preds = %if.end913, %if.end161
  br label %if.end915

if.end915:                                        ; preds = %if.end914, %if.then138
  br label %if.end916

if.end916:                                        ; preds = %if.end915, %if.then126
  br label %if.end917

if.end917:                                        ; preds = %if.end916, %if.then113
  br label %if.end918

if.end918:                                        ; preds = %if.end917, %if.then107
  br label %if.end919

if.end919:                                        ; preds = %if.end918, %if.then97
  br label %if.end920

if.end920:                                        ; preds = %if.end919, %if.then84
  br label %if.end921

if.end921:                                        ; preds = %if.end920, %if.then72
  br label %if.end922

if.end922:                                        ; preds = %if.end921, %if.then61
  br label %if.end923

if.end923:                                        ; preds = %if.end922, %if.end
  br label %if.end924

if.end924:                                        ; preds = %if.end923, %if.then32
  br label %if.end925

if.end925:                                        ; preds = %if.end924, %if.then24
  br label %if.end926

if.end926:                                        ; preds = %if.end925, %if.then18
  br label %if.end927

if.end927:                                        ; preds = %if.end926, %if.then12
  br label %if.end928

if.end928:                                        ; preds = %if.end927, %if.then
  br label %for.inc929

for.inc929:                                       ; preds = %if.end928
  %504 = load i32, ptr %i, align 4
  %inc930 = add nsw i32 %504, 1
  store i32 %inc930, ptr %i, align 4
  br label %for.cond, !llvm.loop !74

for.end931:                                       ; preds = %if.else847, %for.cond
  %505 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  %tobool932 = icmp ne ptr %505, null
  br i1 %tobool932, label %land.lhs.true933, label %if.end937

land.lhs.true933:                                 ; preds = %for.end931
  %506 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 17), align 8
  %tobool934 = icmp ne i32 %506, 0
  br i1 %tobool934, label %if.then935, label %if.end937

if.then935:                                       ; preds = %land.lhs.true933
  %507 = load ptr, ptr @stderr, align 8
  %call936 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %507, ptr noundef @.str.557)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end937:                                        ; preds = %land.lhs.true933, %for.end931
  %508 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 57), align 4
  %tobool938 = icmp ne i32 %508, 0
  br i1 %tobool938, label %land.lhs.true939, label %if.end944

land.lhs.true939:                                 ; preds = %if.end937
  %509 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  %cmp940 = icmp eq i32 %509, 1
  br i1 %cmp940, label %if.then942, label %if.end944

if.then942:                                       ; preds = %land.lhs.true939
  %510 = load ptr, ptr @stderr, align 8
  %call943 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %510, ptr noundef @.str.558)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end944:                                        ; preds = %land.lhs.true939, %if.end937
  %511 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool945 = icmp ne i32 %511, 0
  br i1 %tobool945, label %land.lhs.true946, label %if.end953

land.lhs.true946:                                 ; preds = %if.end944
  %512 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 46), align 8
  %cmp947 = icmp eq ptr %512, null
  br i1 %cmp947, label %if.then949, label %if.end953

if.then949:                                       ; preds = %land.lhs.true946
  %513 = load ptr, ptr @stderr, align 8
  %call950 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %513, ptr noundef @.str.559)
  %514 = load ptr, ptr @stderr, align 8
  %515 = load ptr, ptr %argv.addr, align 8
  %arrayidx951 = getelementptr inbounds ptr, ptr %515, i64 0
  %516 = load ptr, ptr %arrayidx951, align 8
  %call952 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %514, ptr noundef @.str.560, ptr noundef %516)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end953:                                        ; preds = %land.lhs.true946, %if.end944
  %517 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 56), align 8
  %tobool954 = icmp ne i32 %517, 0
  br i1 %tobool954, label %if.end960, label %land.lhs.true955

land.lhs.true955:                                 ; preds = %if.end953
  %518 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %cmp956 = icmp ne ptr %518, null
  br i1 %cmp956, label %if.then958, label %if.end960

if.then958:                                       ; preds = %land.lhs.true955
  %519 = load ptr, ptr @stderr, align 8
  %call959 = call i32 @fputs(ptr noundef @.str.561, ptr noundef %519)
  br label %if.end960

if.end960:                                        ; preds = %if.then958, %land.lhs.true955, %if.end953
  %520 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 24), align 4
  %tobool961 = icmp ne i32 %520, 0
  br i1 %tobool961, label %land.lhs.true962, label %if.end966

land.lhs.true962:                                 ; preds = %if.end960
  %521 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 23), align 8
  %tobool963 = icmp ne i32 %521, 0
  br i1 %tobool963, label %if.then964, label %if.end966

if.then964:                                       ; preds = %land.lhs.true962
  %522 = load ptr, ptr @stderr, align 8
  %call965 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %522, ptr noundef @.str.562)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end966:                                        ; preds = %land.lhs.true962, %if.end960
  %523 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 36), align 8
  %tobool967 = icmp ne i32 %523, 0
  br i1 %tobool967, label %land.lhs.true968, label %if.end972

land.lhs.true968:                                 ; preds = %if.end966
  %524 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 37), align 4
  %tobool969 = icmp ne i32 %524, 0
  br i1 %tobool969, label %if.then970, label %if.end972

if.then970:                                       ; preds = %land.lhs.true968
  %525 = load ptr, ptr @stderr, align 8
  %call971 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %525, ptr noundef @.str.563)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end972:                                        ; preds = %land.lhs.true968, %if.end966
  %526 = load i32, ptr %i, align 4
  ret i32 %526
}

; Function Attrs: nounwind uwtable
define internal void @parseEnv() #0 {
entry:
  %auth = alloca ptr, align 8
  %cluster_yes = alloca ptr, align 8
  %call = call ptr @getenv(ptr noundef @.str.573) #15
  store ptr %call, ptr %auth, align 8
  %0 = load ptr, ptr %auth, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr %auth, align 8
  store ptr %2, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %call2 = call ptr @getenv(ptr noundef @.str.574) #15
  store ptr %call2, ptr %cluster_yes, align 8
  %3 = load ptr, ptr %cluster_yes, align 8
  %cmp3 = icmp ne ptr %3, null
  br i1 %cmp3, label %land.lhs.true4, label %if.end7

land.lhs.true4:                                   ; preds = %if.end
  %4 = load ptr, ptr %cluster_yes, align 8
  %call5 = call i32 @strcmp(ptr noundef %4, ptr noundef @.str.81) #12
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true4
  %5 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %or = or i32 %5, 4
  store i32 %or, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %land.lhs.true4, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @askPassword(ptr noundef %msg) #0 {
entry:
  %msg.addr = alloca ptr, align 8
  %auth = alloca ptr, align 8
  store ptr %msg, ptr %msg.addr, align 8
  call void @linenoiseMaskModeEnable()
  %0 = load ptr, ptr %msg.addr, align 8
  %call = call ptr @linenoise(ptr noundef %0)
  store ptr %call, ptr %auth, align 8
  call void @linenoiseMaskModeDisable()
  %1 = load ptr, ptr %auth, align 8
  ret ptr %1
}

; Function Attrs: nounwind
declare i32 @gettimeofday(ptr noundef, ptr noundef) #6

declare void @init_genrand64(i64 noundef) #2

; Function Attrs: nounwind
declare i32 @getpid() #6

; Function Attrs: nounwind uwtable
define internal ptr @validateClusterManagerCommand() #0 {
entry:
  %retval = alloca ptr, align 8
  %i = alloca i32, align 4
  %commands_count = alloca i32, align 4
  %proc = alloca ptr, align 8
  %cmdname = alloca ptr, align 8
  %argc = alloca i32, align 4
  %cmddef = alloca %struct.clusterManagerCommandDef, align 8
  store i32 13, ptr %commands_count, align 4
  store ptr null, ptr %proc, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55), align 8
  store ptr %0, ptr %cmdname, align 8
  %1 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 1), align 8
  store i32 %1, ptr %argc, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %commands_count, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [13 x %struct.clusterManagerCommandDef], ptr @clusterManagerCommands, i64 0, i64 %idxprom
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %cmddef, ptr align 8 %arrayidx, i64 40, i1 false)
  %name = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %cmddef, i32 0, i32 0
  %5 = load ptr, ptr %name, align 8
  %6 = load ptr, ptr %cmdname, align 8
  %call = call i32 @strcmp(ptr noundef %5, ptr noundef %6) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end12, label %if.then

if.then:                                          ; preds = %for.body
  %arity = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %cmddef, i32 0, i32 2
  %7 = load i32, ptr %arity, align 8
  %cmp1 = icmp sgt i32 %7, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.then
  %8 = load i32, ptr %argc, align 4
  %arity2 = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %cmddef, i32 0, i32 2
  %9 = load i32, ptr %arity2, align 8
  %cmp3 = icmp ne i32 %8, %9
  br i1 %cmp3, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.then
  %arity4 = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %cmddef, i32 0, i32 2
  %10 = load i32, ptr %arity4, align 8
  %cmp5 = icmp slt i32 %10, 0
  br i1 %cmp5, label %land.lhs.true6, label %if.end

land.lhs.true6:                                   ; preds = %lor.lhs.false
  %11 = load i32, ptr %argc, align 4
  %arity7 = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %cmddef, i32 0, i32 2
  %12 = load i32, ptr %arity7, align 8
  %mul = mul nsw i32 %12, -1
  %cmp8 = icmp slt i32 %11, %mul
  br i1 %cmp8, label %if.then9, label %if.end

if.then9:                                         ; preds = %land.lhs.true6, %land.lhs.true
  %13 = load ptr, ptr @stderr, align 8
  %call10 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %13, ptr noundef @.str.575)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true6, %lor.lhs.false
  %proc11 = getelementptr inbounds %struct.clusterManagerCommandDef, ptr %cmddef, i32 0, i32 1
  %14 = load ptr, ptr %proc11, align 8
  store ptr %14, ptr %proc, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %15 = load i32, ptr %i, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !75

for.end:                                          ; preds = %for.cond
  %16 = load ptr, ptr %proc, align 8
  %tobool13 = icmp ne ptr %16, null
  br i1 %tobool13, label %if.end16, label %if.then14

if.then14:                                        ; preds = %for.end
  %17 = load ptr, ptr @stderr, align 8
  %call15 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %17, ptr noundef @.str.576)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %for.end
  %18 = load ptr, ptr %proc, align 8
  store ptr %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end16, %if.then9
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerMode(ptr noundef %proc) #0 {
entry:
  %proc.addr = alloca ptr, align 8
  %argc = alloca i32, align 4
  %argv = alloca ptr, align 8
  %success = alloca i32, align 4
  store ptr %proc, ptr %proc.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 1), align 8
  store i32 %0, ptr %argc, align 4
  %1 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 2), align 8
  store ptr %1, ptr %argv, align 8
  store ptr null, ptr @cluster_manager, align 8
  %2 = load ptr, ptr %proc.addr, align 8
  %3 = load i32, ptr %argc, align 4
  %4 = load ptr, ptr %argv, align 8
  %call = call i32 %2(i32 noundef %3, ptr noundef %4)
  store i32 %call, ptr %success, align 4
  %5 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 36), align 8
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 2), align 8
  call void @zfree(ptr noundef %6)
  %7 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 3), align 8
  call void @hi_sdsfree(ptr noundef %7)
  br label %if.end3

if.else:                                          ; preds = %entry
  %8 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 37), align 4
  %tobool1 = icmp ne i32 %8, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.else
  %9 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 3), align 8
  call void @hi_sdsfree(ptr noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.else
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then
  call void @freeClusterManager()
  %10 = load i32, ptr %success, align 4
  %tobool4 = icmp ne i32 %10, 0
  %cond = select i1 %tobool4, i32 0, i32 1
  call void @exit(i32 noundef %cond) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @cliConnect(i32 noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %err14 = alloca ptr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr @context, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end57

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load ptr, ptr @context, align 8
  %cmp1 = icmp ne ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %3 = load ptr, ptr @context, align 8
  call void @redisFree(ptr noundef %3)
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 60), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  call void @cliRefreshPrompt()
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %4 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  %cmp3 = icmp eq ptr %4, null
  br i1 %cmp3, label %if.then7, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %if.end
  %5 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 17), align 8
  %tobool5 = icmp ne i32 %5, 0
  br i1 %tobool5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false4
  %6 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 18), align 4
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %if.then7, label %if.else

if.then7:                                         ; preds = %land.lhs.true, %if.end
  %7 = load ptr, ptr @config, align 8
  %8 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %call = call ptr @redisConnect(ptr noundef %7, i32 noundef %8)
  store ptr %call, ptr @context, align 8
  br label %if.end9

if.else:                                          ; preds = %land.lhs.true, %lor.lhs.false4
  %9 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  %call8 = call ptr @redisConnectUnix(ptr noundef %9)
  store ptr %call8, ptr @context, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then7
  %10 = load ptr, ptr @context, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %10, i32 0, i32 1
  %11 = load i32, ptr %err, align 8
  %tobool10 = icmp ne i32 %11, 0
  br i1 %tobool10, label %if.end22, label %land.lhs.true11

land.lhs.true11:                                  ; preds = %if.end9
  %12 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 2), align 8
  %tobool12 = icmp ne i32 %12, 0
  br i1 %tobool12, label %if.then13, label %if.end22

if.then13:                                        ; preds = %land.lhs.true11
  store ptr null, ptr %err14, align 8
  %13 = load ptr, ptr @context, align 8
  %call15 = call i32 @cliSecureConnection(ptr noundef %13, ptr noundef byval(%struct.cliSSLconfig) align 8 getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 3), ptr noundef %err14)
  %cmp16 = icmp eq i32 %call15, -1
  br i1 %cmp16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.then13
  %14 = load ptr, ptr %err14, align 8
  %tobool18 = icmp ne ptr %14, null
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %land.lhs.true17
  %15 = load ptr, ptr @stderr, align 8
  %16 = load ptr, ptr %err14, align 8
  %call20 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %15, ptr noundef @.str.577, ptr noundef %16)
  %17 = load ptr, ptr @context, align 8
  call void @redisFree(ptr noundef %17)
  store ptr null, ptr @context, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %land.lhs.true17, %if.then13
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %land.lhs.true11, %if.end9
  %18 = load ptr, ptr @context, align 8
  %err23 = getelementptr inbounds %struct.redisContext, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %err23, align 8
  %tobool24 = icmp ne i32 %19, 0
  br i1 %tobool24, label %if.then25, label %if.end43

if.then25:                                        ; preds = %if.end22
  %20 = load i32, ptr %flags.addr, align 4
  %and26 = and i32 %20, 2
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.end42, label %if.then28

if.then28:                                        ; preds = %if.then25
  %21 = load ptr, ptr @stderr, align 8
  %call29 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %21, ptr noundef @.str.181)
  %22 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  %cmp30 = icmp eq ptr %22, null
  br i1 %cmp30, label %if.then35, label %lor.lhs.false31

lor.lhs.false31:                                  ; preds = %if.then28
  %23 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 17), align 8
  %tobool32 = icmp ne i32 %23, 0
  br i1 %tobool32, label %land.lhs.true33, label %if.else37

land.lhs.true33:                                  ; preds = %lor.lhs.false31
  %24 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 18), align 4
  %tobool34 = icmp ne i32 %24, 0
  br i1 %tobool34, label %if.then35, label %if.else37

if.then35:                                        ; preds = %land.lhs.true33, %if.then28
  %25 = load ptr, ptr @stderr, align 8
  %26 = load ptr, ptr @config, align 8
  %27 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %28 = load ptr, ptr @context, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %28, i32 0, i32 2
  %arraydecay = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call36 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %25, ptr noundef @.str.182, ptr noundef %26, i32 noundef %27, ptr noundef %arraydecay)
  br label %if.end41

if.else37:                                        ; preds = %land.lhs.true33, %lor.lhs.false31
  %29 = load ptr, ptr @stderr, align 8
  %30 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  %31 = load ptr, ptr @context, align 8
  %errstr38 = getelementptr inbounds %struct.redisContext, ptr %31, i32 0, i32 2
  %arraydecay39 = getelementptr inbounds [128 x i8], ptr %errstr38, i64 0, i64 0
  %call40 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %29, ptr noundef @.str.578, ptr noundef %30, ptr noundef %arraydecay39)
  br label %if.end41

if.end41:                                         ; preds = %if.else37, %if.then35
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then25
  %32 = load ptr, ptr @context, align 8
  call void @redisFree(ptr noundef %32)
  store ptr null, ptr @context, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.end22
  %33 = load ptr, ptr @context, align 8
  %fd = getelementptr inbounds %struct.redisContext, ptr %33, i32 0, i32 3
  %34 = load i32, ptr %fd, align 4
  %call44 = call i32 @anetKeepAlive(ptr noundef null, i32 noundef %34, i32 noundef 15)
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 59), align 4
  %35 = load ptr, ptr @context, align 8
  %36 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %37 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %call45 = call i32 @cliAuth(ptr noundef %35, ptr noundef %36, ptr noundef %37)
  %cmp46 = icmp ne i32 %call45, 0
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end43
  store i32 -1, ptr %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end43
  %call49 = call i32 @cliSelect()
  %cmp50 = icmp ne i32 %call49, 0
  br i1 %cmp50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end48
  store i32 -1, ptr %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end48
  %call53 = call i32 @cliSwitchProto()
  %cmp54 = icmp ne i32 %call53, 0
  br i1 %cmp54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end52
  store i32 -1, ptr %retval, align 4
  br label %return

if.end56:                                         ; preds = %if.end52
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %lor.lhs.false
  %38 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 42), align 4
  %tobool58 = icmp ne i32 %38, 0
  br i1 %tobool58, label %if.then59, label %if.end61

if.then59:                                        ; preds = %if.end57
  %39 = load ptr, ptr @context, align 8
  %call60 = call ptr @redisSetPushCallback(ptr noundef %39, ptr noundef @cliPushHandler)
  br label %if.end61

if.end61:                                         ; preds = %if.then59, %if.end57
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end61, %if.then55, %if.then51, %if.then47, %if.end42, %if.then19
  %40 = load i32, ptr %retval, align 4
  ret i32 %40
}

; Function Attrs: nounwind uwtable
define internal void @latencyMode() #0 {
entry:
  %reply = alloca ptr, align 8
  %start = alloca i64, align 8
  %latency = alloca i64, align 8
  %min = alloca i64, align 8
  %max = alloca i64, align 8
  %tot = alloca i64, align 8
  %count = alloca i64, align 8
  %history_interval = alloca i64, align 8
  %avg = alloca double, align 8
  %history_start = alloca i64, align 8
  store i64 0, ptr %min, align 8
  store i64 0, ptr %max, align 8
  store i64 0, ptr %tot, align 8
  store i64 0, ptr %count, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %div = sdiv i64 %1, 1000
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %div, %cond.true ], [ 15000, %cond.false ]
  store i64 %cond, ptr %history_interval, align 8
  %call = call i64 @mstime()
  store i64 %call, ptr %history_start, align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  store i64 1000, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  br label %if.end

if.else:                                          ; preds = %cond.end
  %3 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %div1 = sdiv i64 %3, 1000
  store i64 %div1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr @context, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  call void @exit(i32 noundef 1) #17
  unreachable

if.end4:                                          ; preds = %if.end
  br label %while.body

while.body:                                       ; preds = %if.end56, %if.end4
  %call5 = call i64 @mstime()
  store i64 %call5, ptr %start, align 8
  %5 = load ptr, ptr @context, align 8
  %call6 = call ptr (ptr, ptr, ...) @reconnectingRedisCommand(ptr noundef %5, ptr noundef @.str.611)
  store ptr %call6, ptr %reply, align 8
  %6 = load ptr, ptr %reply, align 8
  %cmp7 = icmp eq ptr %6, null
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %while.body
  %7 = load ptr, ptr @stderr, align 8
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef @.str.76)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end10:                                         ; preds = %while.body
  %call11 = call i64 @mstime()
  %8 = load i64, ptr %start, align 8
  %sub = sub nsw i64 %call11, %8
  store i64 %sub, ptr %latency, align 8
  %9 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %9)
  %10 = load i64, ptr %count, align 8
  %inc = add nsw i64 %10, 1
  store i64 %inc, ptr %count, align 8
  %11 = load i64, ptr %count, align 8
  %cmp12 = icmp eq i64 %11, 1
  br i1 %cmp12, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.end10
  %12 = load i64, ptr %latency, align 8
  store i64 %12, ptr %tot, align 8
  store i64 %12, ptr %max, align 8
  store i64 %12, ptr %min, align 8
  %13 = load i64, ptr %latency, align 8
  %conv = sitofp i64 %13 to double
  store double %conv, ptr %avg, align 8
  br label %if.end26

if.else14:                                        ; preds = %if.end10
  %14 = load i64, ptr %latency, align 8
  %15 = load i64, ptr %min, align 8
  %cmp15 = icmp slt i64 %14, %15
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.else14
  %16 = load i64, ptr %latency, align 8
  store i64 %16, ptr %min, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.else14
  %17 = load i64, ptr %latency, align 8
  %18 = load i64, ptr %max, align 8
  %cmp19 = icmp sgt i64 %17, %18
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %19 = load i64, ptr %latency, align 8
  store i64 %19, ptr %max, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end18
  %20 = load i64, ptr %latency, align 8
  %21 = load i64, ptr %tot, align 8
  %add = add nsw i64 %21, %20
  store i64 %add, ptr %tot, align 8
  %22 = load i64, ptr %tot, align 8
  %conv23 = sitofp i64 %22 to double
  %23 = load i64, ptr %count, align 8
  %conv24 = sitofp i64 %23 to double
  %div25 = fdiv double %conv23, %conv24
  store double %div25, ptr %avg, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.end22, %if.then13
  %24 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp27 = icmp eq i32 %24, 0
  br i1 %cmp27, label %if.then29, label %if.else31

if.then29:                                        ; preds = %if.end26
  %call30 = call i32 (ptr, ...) @printf(ptr noundef @.str.612)
  %25 = load i64, ptr %min, align 8
  %26 = load i64, ptr %max, align 8
  %27 = load double, ptr %avg, align 8
  %28 = load i64, ptr %count, align 8
  call void @latencyModePrint(i64 noundef %25, i64 noundef %26, double noundef %27, i64 noundef %28)
  br label %if.end42

if.else31:                                        ; preds = %if.end26
  %29 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 14), align 8
  %tobool32 = icmp ne i32 %29, 0
  br i1 %tobool32, label %if.then33, label %if.else34

if.then33:                                        ; preds = %if.else31
  %30 = load i64, ptr %min, align 8
  %31 = load i64, ptr %max, align 8
  %32 = load double, ptr %avg, align 8
  %33 = load i64, ptr %count, align 8
  call void @latencyModePrint(i64 noundef %30, i64 noundef %31, double noundef %32, i64 noundef %33)
  br label %if.end41

if.else34:                                        ; preds = %if.else31
  %call35 = call i64 @mstime()
  %34 = load i64, ptr %history_start, align 8
  %sub36 = sub nsw i64 %call35, %34
  %35 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %cmp37 = icmp sgt i64 %sub36, %35
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.else34
  %36 = load i64, ptr %min, align 8
  %37 = load i64, ptr %max, align 8
  %38 = load double, ptr %avg, align 8
  %39 = load i64, ptr %count, align 8
  call void @latencyModePrint(i64 noundef %36, i64 noundef %37, double noundef %38, i64 noundef %39)
  call void @exit(i32 noundef 0) #17
  unreachable

if.end40:                                         ; preds = %if.else34
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then33
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.then29
  %40 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 14), align 8
  %tobool43 = icmp ne i32 %40, 0
  br i1 %tobool43, label %land.lhs.true, label %if.end56

land.lhs.true:                                    ; preds = %if.end42
  %call44 = call i64 @mstime()
  %41 = load i64, ptr %history_start, align 8
  %sub45 = sub nsw i64 %call44, %41
  %42 = load i64, ptr %history_interval, align 8
  %cmp46 = icmp sgt i64 %sub45, %42
  br i1 %cmp46, label %if.then48, label %if.end56

if.then48:                                        ; preds = %land.lhs.true
  %call49 = call i64 @mstime()
  %43 = load i64, ptr %history_start, align 8
  %sub50 = sub nsw i64 %call49, %43
  %conv51 = sitofp i64 %sub50 to float
  %div52 = fdiv float %conv51, 1.000000e+03
  %conv53 = fpext float %div52 to double
  %call54 = call i32 (ptr, ...) @printf(ptr noundef @.str.613, double noundef %conv53)
  %call55 = call i64 @mstime()
  store i64 %call55, ptr %history_start, align 8
  store i64 0, ptr %count, align 8
  store i64 0, ptr %tot, align 8
  store i64 0, ptr %max, align 8
  store i64 0, ptr %min, align 8
  br label %if.end56

if.end56:                                         ; preds = %if.then48, %land.lhs.true, %if.end42
  %call57 = call i32 @usleep(i32 noundef 10000)
  br label %while.body
}

; Function Attrs: nounwind uwtable
define internal void @latencyDistMode() #0 {
entry:
  %reply = alloca ptr, align 8
  %start = alloca i64, align 8
  %latency = alloca i64, align 8
  %count = alloca i64, align 8
  %history_interval = alloca i64, align 8
  %history_start = alloca i64, align 8
  %j = alloca i32, align 4
  %outputs = alloca i32, align 4
  %samples = alloca [31 x %struct.distsamples], align 16
  store i64 0, ptr %count, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %div = sdiv i64 %1, 1000
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %div, %cond.true ], [ 1000, %cond.false ]
  store i64 %cond, ptr %history_interval, align 8
  %call = call i64 @ustime()
  store i64 %call, ptr %history_start, align 8
  store i32 0, ptr %outputs, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %samples, ptr align 16 @__const.latencyDistMode.samples, i64 744, i1 false)
  %2 = load ptr, ptr @context, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %cond.end
  br label %while.body

while.body:                                       ; preds = %if.end31, %if.end
  %call2 = call i64 @ustime()
  store i64 %call2, ptr %start, align 8
  %3 = load ptr, ptr @context, align 8
  %call3 = call ptr (ptr, ptr, ...) @reconnectingRedisCommand(ptr noundef %3, ptr noundef @.str.611)
  store ptr %call3, ptr %reply, align 8
  %4 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.then4, label %if.end6

if.then4:                                         ; preds = %while.body
  %5 = load ptr, ptr @stderr, align 8
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.76)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end6:                                          ; preds = %while.body
  %call7 = call i64 @ustime()
  %6 = load i64, ptr %start, align 8
  %sub = sub nsw i64 %call7, %6
  store i64 %sub, ptr %latency, align 8
  %7 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %7)
  %8 = load i64, ptr %count, align 8
  %inc = add nsw i64 %8, 1
  store i64 %inc, ptr %count, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %9 = load i32, ptr %j, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds [31 x %struct.distsamples], ptr %samples, i64 0, i64 %idxprom
  %max = getelementptr inbounds %struct.distsamples, ptr %arrayidx, i32 0, i32 0
  %10 = load i64, ptr %max, align 8
  %cmp8 = icmp eq i64 %10, 0
  br i1 %cmp8, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %11 = load i64, ptr %latency, align 8
  %12 = load i32, ptr %j, align 4
  %idxprom9 = sext i32 %12 to i64
  %arrayidx10 = getelementptr inbounds [31 x %struct.distsamples], ptr %samples, i64 0, i64 %idxprom9
  %max11 = getelementptr inbounds %struct.distsamples, ptr %arrayidx10, i32 0, i32 0
  %13 = load i64, ptr %max11, align 8
  %cmp12 = icmp sle i64 %11, %13
  br i1 %cmp12, label %if.then13, label %if.end18

if.then13:                                        ; preds = %lor.lhs.false, %for.cond
  %14 = load i32, ptr %j, align 4
  %idxprom14 = sext i32 %14 to i64
  %arrayidx15 = getelementptr inbounds [31 x %struct.distsamples], ptr %samples, i64 0, i64 %idxprom14
  %count16 = getelementptr inbounds %struct.distsamples, ptr %arrayidx15, i32 0, i32 1
  %15 = load i64, ptr %count16, align 8
  %inc17 = add nsw i64 %15, 1
  store i64 %inc17, ptr %count16, align 8
  br label %for.end

if.end18:                                         ; preds = %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end18
  %16 = load i32, ptr %j, align 4
  %inc19 = add nsw i32 %16, 1
  store i32 %inc19, ptr %j, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then13
  %17 = load i64, ptr %count, align 8
  %tobool20 = icmp ne i64 %17, 0
  br i1 %tobool20, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %for.end
  %call21 = call i64 @ustime()
  %18 = load i64, ptr %history_start, align 8
  %sub22 = sub nsw i64 %call21, %18
  %div23 = sdiv i64 %sub22, 1000
  %19 = load i64, ptr %history_interval, align 8
  %cmp24 = icmp sgt i64 %div23, %19
  br i1 %cmp24, label %if.then25, label %if.end31

if.then25:                                        ; preds = %land.lhs.true
  %20 = load i32, ptr %outputs, align 4
  %inc26 = add nsw i32 %20, 1
  store i32 %inc26, ptr %outputs, align 4
  %rem = srem i32 %20, 20
  %cmp27 = icmp eq i32 %rem, 0
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.then25
  call void @showLatencyDistLegend()
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.then25
  %arraydecay = getelementptr inbounds [31 x %struct.distsamples], ptr %samples, i64 0, i64 0
  %21 = load i64, ptr %count, align 8
  call void @showLatencyDistSamples(ptr noundef %arraydecay, i64 noundef %21)
  %call30 = call i64 @ustime()
  store i64 %call30, ptr %history_start, align 8
  store i64 0, ptr %count, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end29, %land.lhs.true, %for.end
  %call32 = call i32 @usleep(i32 noundef 10000)
  br label %while.body
}

; Function Attrs: nounwind uwtable
define internal void @slaveMode(i32 noundef %send_sync) #0 {
entry:
  %send_sync.addr = alloca i32, align 4
  %payload = alloca i64, align 8
  %buf = alloca [1024 x i8], align 16
  %original_output = alloca i32, align 4
  %info = alloca ptr, align 8
  %nread = alloca i64, align 8
  %rem = alloca i32, align 4
  %offset = alloca i64, align 8
  store i32 %send_sync, ptr %send_sync.addr, align 4
  %0 = load ptr, ptr @context, align 8
  %1 = load i32, ptr %send_sync.addr, align 4
  %call = call i64 @sendSync(ptr noundef %0, i32 noundef %1, ptr noundef @slaveMode.eofmark, ptr noundef @slaveMode.out_full_mode)
  store i64 %call, ptr %payload, align 8
  %2 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  store i32 %2, ptr %original_output, align 4
  %3 = load i32, ptr @slaveMode.out_full_mode, align 4
  %tobool = icmp ne i32 %3, 0
  %cond = select i1 %tobool, ptr @.str.618, ptr @.str.619
  store ptr %cond, ptr %info, align 8
  %4 = load i32, ptr @slaveMode.out_full_mode, align 4
  %cmp = icmp eq i32 %4, 1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %5 = load i64, ptr %payload, align 8
  %cmp1 = icmp eq i64 %5, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i64 -1, ptr %payload, align 8
  call void @llvm.memset.p0.i64(ptr align 16 @slaveMode.lastbytes, i8 0, i64 40, i1 false)
  store i32 1, ptr @slaveMode.usemark, align 4
  %6 = load ptr, ptr @stderr, align 8
  %7 = load ptr, ptr %info, align 8
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.620, ptr noundef %7)
  br label %if.end15

if.else:                                          ; preds = %land.lhs.true, %entry
  %8 = load i32, ptr @slaveMode.out_full_mode, align 4
  %cmp3 = icmp eq i32 %8, 1
  br i1 %cmp3, label %land.lhs.true4, label %if.else8

land.lhs.true4:                                   ; preds = %if.else
  %9 = load i64, ptr %payload, align 8
  %cmp5 = icmp ne i64 %9, 0
  br i1 %cmp5, label %if.then6, label %if.else8

if.then6:                                         ; preds = %land.lhs.true4
  %10 = load ptr, ptr @stderr, align 8
  %11 = load ptr, ptr %info, align 8
  %12 = load i64, ptr %payload, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef @.str.621, ptr noundef %11, i64 noundef %12)
  br label %if.end14

if.else8:                                         ; preds = %land.lhs.true4, %if.else
  %13 = load i32, ptr @slaveMode.out_full_mode, align 4
  %cmp9 = icmp eq i32 %13, 0
  br i1 %cmp9, label %land.lhs.true10, label %if.end

land.lhs.true10:                                  ; preds = %if.else8
  %14 = load i64, ptr %payload, align 8
  %cmp11 = icmp eq i64 %14, 0
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %land.lhs.true10
  %15 = load ptr, ptr @stderr, align 8
  %16 = load ptr, ptr %info, align 8
  %call13 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %15, ptr noundef @.str.622, ptr noundef %16)
  br label %if.end

if.end:                                           ; preds = %if.then12, %land.lhs.true10, %if.else8
  br label %if.end14

if.end14:                                         ; preds = %if.end, %if.then6
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then
  br label %while.cond

while.cond:                                       ; preds = %if.end42, %if.end15
  %17 = load i64, ptr %payload, align 8
  %tobool16 = icmp ne i64 %17, 0
  br i1 %tobool16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %18 = load ptr, ptr @context, align 8
  %arraydecay = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %19 = load i64, ptr %payload, align 8
  %cmp17 = icmp ugt i64 %19, 1024
  br i1 %cmp17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %20 = load i64, ptr %payload, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond18 = phi i64 [ 1024, %cond.true ], [ %20, %cond.false ]
  %call19 = call i64 @readConn(ptr noundef %18, ptr noundef %arraydecay, i64 noundef %cond18)
  store i64 %call19, ptr %nread, align 8
  %21 = load i64, ptr %nread, align 8
  %cmp20 = icmp sle i64 %21, 0
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %cond.end
  %22 = load ptr, ptr @stderr, align 8
  %23 = load ptr, ptr %info, align 8
  %call22 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %22, ptr noundef @.str.623, ptr noundef %23)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end23:                                         ; preds = %cond.end
  %24 = load i64, ptr %nread, align 8
  %25 = load i64, ptr %payload, align 8
  %sub = sub i64 %25, %24
  store i64 %sub, ptr %payload, align 8
  %26 = load i32, ptr @slaveMode.usemark, align 4
  %tobool24 = icmp ne i32 %26, 0
  br i1 %tobool24, label %if.then25, label %if.end42

if.then25:                                        ; preds = %if.end23
  %27 = load i64, ptr %nread, align 8
  %cmp26 = icmp sge i64 %27, 40
  br i1 %cmp26, label %if.then27, label %if.else30

if.then27:                                        ; preds = %if.then25
  %arraydecay28 = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %28 = load i64, ptr %nread, align 8
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay28, i64 %28
  %add.ptr29 = getelementptr inbounds i8, ptr %add.ptr, i64 -40
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 @slaveMode.lastbytes, ptr align 1 %add.ptr29, i64 40, i1 false)
  br label %if.end36

if.else30:                                        ; preds = %if.then25
  %29 = load i64, ptr %nread, align 8
  %sub31 = sub nsw i64 40, %29
  %conv = trunc i64 %sub31 to i32
  store i32 %conv, ptr %rem, align 4
  %30 = load i64, ptr %nread, align 8
  %add.ptr32 = getelementptr inbounds i8, ptr @slaveMode.lastbytes, i64 %30
  %31 = load i32, ptr %rem, align 4
  %conv33 = sext i32 %31 to i64
  call void @llvm.memmove.p0.p0.i64(ptr align 16 @slaveMode.lastbytes, ptr align 1 %add.ptr32, i64 %conv33, i1 false)
  %32 = load i32, ptr %rem, align 4
  %idx.ext = sext i32 %32 to i64
  %add.ptr34 = getelementptr inbounds i8, ptr @slaveMode.lastbytes, i64 %idx.ext
  %arraydecay35 = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %33 = load i64, ptr %nread, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr34, ptr align 16 %arraydecay35, i64 %33, i1 false)
  br label %if.end36

if.end36:                                         ; preds = %if.else30, %if.then27
  %call37 = call i32 @memcmp(ptr noundef @slaveMode.lastbytes, ptr noundef @slaveMode.eofmark, i64 noundef 40) #12
  %cmp38 = icmp eq i32 %call37, 0
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end36
  br label %while.end

if.end41:                                         ; preds = %if.end36
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.end23
  br label %while.cond, !llvm.loop !76

while.end:                                        ; preds = %if.then40, %while.cond
  %34 = load i32, ptr @slaveMode.usemark, align 4
  %tobool43 = icmp ne i32 %34, 0
  br i1 %tobool43, label %if.then44, label %if.else49

if.then44:                                        ; preds = %while.end
  %35 = load i64, ptr %payload, align 8
  %sub45 = sub i64 -1, %35
  store i64 %sub45, ptr %offset, align 8
  %36 = load ptr, ptr @stderr, align 8
  %37 = load ptr, ptr %info, align 8
  %38 = load i64, ptr %offset, align 8
  %call46 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %36, ptr noundef @.str.624, ptr noundef %37, i64 noundef %38)
  %call47 = call i32 @sleep(i32 noundef 1)
  %call48 = call i32 @sendReplconf(ptr noundef @.str.625, ptr noundef @.str.305)
  br label %if.end51

if.else49:                                        ; preds = %while.end
  %39 = load ptr, ptr @stderr, align 8
  %40 = load ptr, ptr %info, align 8
  %call50 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %39, ptr noundef @.str.626, ptr noundef %40)
  br label %if.end51

if.end51:                                         ; preds = %if.else49, %if.then44
  store i32 2, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %while.cond52

while.cond52:                                     ; preds = %while.body56, %if.end51
  %call53 = call i32 @cliReadReply(i32 noundef 0)
  %cmp54 = icmp eq i32 %call53, 0
  br i1 %cmp54, label %while.body56, label %while.end57

while.body56:                                     ; preds = %while.cond52
  br label %while.cond52, !llvm.loop !77

while.end57:                                      ; preds = %while.cond52
  %41 = load i32, ptr %original_output, align 4
  store i32 %41, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @getRDB(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %fd = alloca i32, align 4
  %s = alloca ptr, align 8
  %filename = alloca ptr, align 8
  %payload = alloca i64, align 8
  %buf = alloca [4096 x i8], align 16
  %write_to_stdout = alloca i32, align 4
  %nread = alloca i64, align 8
  %nwritten = alloca i64, align 8
  %rem = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %context, align 8
  store ptr %2, ptr %s, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %call = call ptr @clusterManagerGetNodeRDBFilename(ptr noundef %3)
  store ptr %call, ptr %filename, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr @context, align 8
  store ptr %4, ptr %s, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 31), align 8
  store ptr %5, ptr %filename, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load ptr, ptr %s, align 8
  %call1 = call i64 @sendSync(ptr noundef %6, i32 noundef 1, ptr noundef @getRDB.eofmark, ptr noundef null)
  store i64 %call1, ptr %payload, align 8
  %7 = load i64, ptr %payload, align 8
  %cmp2 = icmp eq i64 %7, 0
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.end
  store i64 -1, ptr %payload, align 8
  call void @llvm.memset.p0.i64(ptr align 16 @getRDB.lastbytes, i8 0, i64 40, i1 false)
  store i32 1, ptr @getRDB.usemark, align 4
  %8 = load ptr, ptr @stderr, align 8
  %9 = load ptr, ptr %filename, align 8
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %8, ptr noundef @.str.630, ptr noundef %9)
  br label %if.end7

if.else5:                                         ; preds = %if.end
  %10 = load ptr, ptr @stderr, align 8
  %11 = load i64, ptr %payload, align 8
  %12 = load ptr, ptr %filename, align 8
  %call6 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef @.str.631, i64 noundef %11, ptr noundef %12)
  br label %if.end7

if.end7:                                          ; preds = %if.else5, %if.then3
  %13 = load ptr, ptr %filename, align 8
  %call8 = call i32 @strcmp(ptr noundef %13, ptr noundef @.str.632) #12
  %tobool = icmp ne i32 %call8, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %write_to_stdout, align 4
  %14 = load i32, ptr %write_to_stdout, align 4
  %tobool9 = icmp ne i32 %14, 0
  br i1 %tobool9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.end7
  store i32 1, ptr %fd, align 4
  br label %if.end19

if.else11:                                        ; preds = %if.end7
  %15 = load ptr, ptr %filename, align 8
  %call12 = call i32 (ptr, i32, ...) @open64(ptr noundef %15, i32 noundef 65, i32 noundef 420)
  store i32 %call12, ptr %fd, align 4
  %16 = load i32, ptr %fd, align 4
  %cmp13 = icmp eq i32 %16, -1
  br i1 %cmp13, label %if.then14, label %if.end18

if.then14:                                        ; preds = %if.else11
  %17 = load ptr, ptr @stderr, align 8
  %18 = load ptr, ptr %filename, align 8
  %call15 = call ptr @__errno_location() #16
  %19 = load i32, ptr %call15, align 4
  %call16 = call ptr @strerror(i32 noundef %19) #15
  %call17 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %17, ptr noundef @.str.633, ptr noundef %18, ptr noundef %call16)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end18:                                         ; preds = %if.else11
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.then10
  br label %while.cond

while.cond:                                       ; preds = %if.end58, %if.end19
  %20 = load i64, ptr %payload, align 8
  %tobool20 = icmp ne i64 %20, 0
  br i1 %tobool20, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %s, align 8
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %22 = load i64, ptr %payload, align 8
  %cmp21 = icmp ugt i64 %22, 4096
  br i1 %cmp21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %23 = load i64, ptr %payload, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 4096, %cond.true ], [ %23, %cond.false ]
  %call22 = call i64 @readConn(ptr noundef %21, ptr noundef %arraydecay, i64 noundef %cond)
  store i64 %call22, ptr %nread, align 8
  %24 = load i64, ptr %nread, align 8
  %cmp23 = icmp sle i64 %24, 0
  br i1 %cmp23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %cond.end
  %25 = load ptr, ptr @stderr, align 8
  %call25 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %25, ptr noundef @.str.634)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end26:                                         ; preds = %cond.end
  %26 = load i32, ptr %fd, align 4
  %arraydecay27 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %27 = load i64, ptr %nread, align 8
  %call28 = call i64 @write(i32 noundef %26, ptr noundef %arraydecay27, i64 noundef %27)
  store i64 %call28, ptr %nwritten, align 8
  %28 = load i64, ptr %nwritten, align 8
  %29 = load i64, ptr %nread, align 8
  %cmp29 = icmp ne i64 %28, %29
  br i1 %cmp29, label %if.then30, label %if.end39

if.then30:                                        ; preds = %if.end26
  %30 = load ptr, ptr @stderr, align 8
  %31 = load i64, ptr %nwritten, align 8
  %cmp31 = icmp eq i64 %31, -1
  br i1 %cmp31, label %cond.true32, label %cond.false35

cond.true32:                                      ; preds = %if.then30
  %call33 = call ptr @__errno_location() #16
  %32 = load i32, ptr %call33, align 4
  %call34 = call ptr @strerror(i32 noundef %32) #15
  br label %cond.end36

cond.false35:                                     ; preds = %if.then30
  br label %cond.end36

cond.end36:                                       ; preds = %cond.false35, %cond.true32
  %cond37 = phi ptr [ %call34, %cond.true32 ], [ @.str.636, %cond.false35 ]
  %call38 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %30, ptr noundef @.str.635, ptr noundef %cond37)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end39:                                         ; preds = %if.end26
  %33 = load i64, ptr %nread, align 8
  %34 = load i64, ptr %payload, align 8
  %sub = sub i64 %34, %33
  store i64 %sub, ptr %payload, align 8
  %35 = load i32, ptr @getRDB.usemark, align 4
  %tobool40 = icmp ne i32 %35, 0
  br i1 %tobool40, label %if.then41, label %if.end58

if.then41:                                        ; preds = %if.end39
  %36 = load i64, ptr %nread, align 8
  %cmp42 = icmp sge i64 %36, 40
  br i1 %cmp42, label %if.then43, label %if.else46

if.then43:                                        ; preds = %if.then41
  %arraydecay44 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %37 = load i64, ptr %nread, align 8
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay44, i64 %37
  %add.ptr45 = getelementptr inbounds i8, ptr %add.ptr, i64 -40
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 @getRDB.lastbytes, ptr align 1 %add.ptr45, i64 40, i1 false)
  br label %if.end52

if.else46:                                        ; preds = %if.then41
  %38 = load i64, ptr %nread, align 8
  %sub47 = sub nsw i64 40, %38
  %conv = trunc i64 %sub47 to i32
  store i32 %conv, ptr %rem, align 4
  %39 = load i64, ptr %nread, align 8
  %add.ptr48 = getelementptr inbounds i8, ptr @getRDB.lastbytes, i64 %39
  %40 = load i32, ptr %rem, align 4
  %conv49 = sext i32 %40 to i64
  call void @llvm.memmove.p0.p0.i64(ptr align 16 @getRDB.lastbytes, ptr align 1 %add.ptr48, i64 %conv49, i1 false)
  %41 = load i32, ptr %rem, align 4
  %idx.ext = sext i32 %41 to i64
  %add.ptr50 = getelementptr inbounds i8, ptr @getRDB.lastbytes, i64 %idx.ext
  %arraydecay51 = getelementptr inbounds [4096 x i8], ptr %buf, i64 0, i64 0
  %42 = load i64, ptr %nread, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr50, ptr align 16 %arraydecay51, i64 %42, i1 false)
  br label %if.end52

if.end52:                                         ; preds = %if.else46, %if.then43
  %call53 = call i32 @memcmp(ptr noundef @getRDB.lastbytes, ptr noundef @getRDB.eofmark, i64 noundef 40) #12
  %cmp54 = icmp eq i32 %call53, 0
  br i1 %cmp54, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end52
  br label %while.end

if.end57:                                         ; preds = %if.end52
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end39
  br label %while.cond, !llvm.loop !78

while.end:                                        ; preds = %if.then56, %while.cond
  %43 = load i32, ptr @getRDB.usemark, align 4
  %tobool59 = icmp ne i32 %43, 0
  br i1 %tobool59, label %if.then60, label %if.else73

if.then60:                                        ; preds = %while.end
  %44 = load i64, ptr %payload, align 8
  %sub61 = sub i64 -1, %44
  %sub62 = sub i64 %sub61, 40
  store i64 %sub62, ptr %payload, align 8
  %45 = load i32, ptr %write_to_stdout, align 4
  %tobool63 = icmp ne i32 %45, 0
  br i1 %tobool63, label %if.end71, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then60
  %46 = load i32, ptr %fd, align 4
  %47 = load i64, ptr %payload, align 8
  %call64 = call i32 @ftruncate64(i32 noundef %46, i64 noundef %47) #15
  %cmp65 = icmp eq i32 %call64, -1
  br i1 %cmp65, label %if.then67, label %if.end71

if.then67:                                        ; preds = %land.lhs.true
  %48 = load ptr, ptr @stderr, align 8
  %call68 = call ptr @__errno_location() #16
  %49 = load i32, ptr %call68, align 4
  %call69 = call ptr @strerror(i32 noundef %49) #15
  %call70 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %48, ptr noundef @.str.637, ptr noundef %call69)
  br label %if.end71

if.end71:                                         ; preds = %if.then67, %land.lhs.true, %if.then60
  %50 = load ptr, ptr @stderr, align 8
  %51 = load i64, ptr %payload, align 8
  %call72 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %50, ptr noundef @.str.638, i64 noundef %51)
  br label %if.end75

if.else73:                                        ; preds = %while.end
  %52 = load ptr, ptr @stderr, align 8
  %call74 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %52, ptr noundef @.str.639)
  br label %if.end75

if.end75:                                         ; preds = %if.else73, %if.end71
  %53 = load ptr, ptr %s, align 8
  call void @redisFree(ptr noundef %53)
  %54 = load ptr, ptr %node.addr, align 8
  %tobool76 = icmp ne ptr %54, null
  br i1 %tobool76, label %if.then77, label %if.end79

if.then77:                                        ; preds = %if.end75
  %55 = load ptr, ptr %node.addr, align 8
  %context78 = getelementptr inbounds %struct.clusterManagerNode, ptr %55, i32 0, i32 0
  store ptr null, ptr %context78, align 8
  br label %if.end79

if.end79:                                         ; preds = %if.then77, %if.end75
  %56 = load i32, ptr %write_to_stdout, align 4
  %tobool80 = icmp ne i32 %56, 0
  br i1 %tobool80, label %if.end89, label %land.lhs.true81

land.lhs.true81:                                  ; preds = %if.end79
  %57 = load i32, ptr %fd, align 4
  %call82 = call i32 @fsync(i32 noundef %57)
  %cmp83 = icmp eq i32 %call82, -1
  br i1 %cmp83, label %if.then85, label %if.end89

if.then85:                                        ; preds = %land.lhs.true81
  %58 = load ptr, ptr @stderr, align 8
  %59 = load ptr, ptr %filename, align 8
  %call86 = call ptr @__errno_location() #16
  %60 = load i32, ptr %call86, align 4
  %call87 = call ptr @strerror(i32 noundef %60) #15
  %call88 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %58, ptr noundef @.str.640, ptr noundef %59, ptr noundef %call87)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end89:                                         ; preds = %land.lhs.true81, %if.end79
  %61 = load i32, ptr %fd, align 4
  %call90 = call i32 @close(i32 noundef %61)
  %62 = load ptr, ptr %node.addr, align 8
  %tobool91 = icmp ne ptr %62, null
  br i1 %tobool91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.end89
  %63 = load ptr, ptr %filename, align 8
  call void @hi_sdsfree(ptr noundef %63)
  ret void

if.end93:                                         ; preds = %if.end89
  call void @exit(i32 noundef 0) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal void @pipeMode() #0 {
entry:
  %errors = alloca i64, align 8
  %replies = alloca i64, align 8
  %obuf_len = alloca i64, align 8
  %obuf_pos = alloca i64, align 8
  %obuf = alloca [16384 x i8], align 16
  %aneterr = alloca [256 x i8], align 16
  %reply = alloca ptr, align 8
  %eof = alloca i32, align 4
  %done = alloca i32, align 4
  %magic = alloca [20 x i8], align 16
  %last_read_time = alloca i64, align 8
  %mask = alloca i32, align 4
  %read_error = alloca i32, align 4
  %loop_nwritten = alloca i64, align 8
  %nwritten = alloca i64, align 8
  %nread = alloca i64, align 8
  %echo = alloca [44 x i8], align 16
  %j = alloca i32, align 4
  store i64 0, ptr %errors, align 8
  store i64 0, ptr %replies, align 8
  store i64 0, ptr %obuf_len, align 8
  store i64 0, ptr %obuf_pos, align 8
  store i32 0, ptr %eof, align 4
  store i32 0, ptr %done, align 4
  %call = call i64 @time(ptr noundef null) #15
  store i64 %call, ptr %last_read_time, align 8
  %call1 = call i64 @time(ptr noundef null) #15
  %conv = trunc i64 %call1 to i32
  call void @srand(i32 noundef %conv) #15
  %arraydecay = getelementptr inbounds [256 x i8], ptr %aneterr, i64 0, i64 0
  %0 = load ptr, ptr @context, align 8
  %fd = getelementptr inbounds %struct.redisContext, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %fd, align 4
  %call2 = call i32 @anetNonBlock(ptr noundef %arraydecay, i32 noundef %1)
  %cmp = icmp eq i32 %call2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @stderr, align 8
  %arraydecay4 = getelementptr inbounds [256 x i8], ptr %aneterr, i64 0, i64 0
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef @.str.642, ptr noundef %arraydecay4)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr @context, align 8
  %flags = getelementptr inbounds %struct.redisContext, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, -2
  store i32 %and, ptr %flags, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end155, %if.end
  %5 = load i32, ptr %done, align 4
  %tobool = icmp ne i32 %5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end156

while.body:                                       ; preds = %while.cond
  store i32 1, ptr %mask, align 4
  %6 = load i32, ptr %eof, align 4
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %lor.lhs.false, label %if.then9

lor.lhs.false:                                    ; preds = %while.body
  %7 = load i64, ptr %obuf_len, align 8
  %cmp7 = icmp ne i64 %7, 0
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %lor.lhs.false, %while.body
  %8 = load i32, ptr %mask, align 4
  %or = or i32 %8, 2
  store i32 %or, ptr %mask, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %lor.lhs.false
  %9 = load ptr, ptr @context, align 8
  %fd11 = getelementptr inbounds %struct.redisContext, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %fd11, align 4
  %11 = load i32, ptr %mask, align 4
  %call12 = call i32 @aeWait(i32 noundef %10, i32 noundef %11, i64 noundef 1000)
  store i32 %call12, ptr %mask, align 4
  %12 = load i32, ptr %mask, align 4
  %and13 = and i32 %12, 1
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end60

if.then15:                                        ; preds = %if.end10
  store i32 0, ptr %read_error, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then15
  %13 = load i32, ptr %read_error, align 4
  %tobool16 = icmp ne i32 %13, 0
  br i1 %tobool16, label %if.end21, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %14 = load ptr, ptr @context, align 8
  %call17 = call i32 @redisBufferRead(ptr noundef %14)
  %cmp18 = icmp eq i32 %call17, -1
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true
  store i32 1, ptr %read_error, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %land.lhs.true, %do.body
  store ptr null, ptr %reply, align 8
  %15 = load ptr, ptr @context, align 8
  %call22 = call i32 @redisGetReply(ptr noundef %15, ptr noundef %reply)
  %cmp23 = icmp eq i32 %call22, -1
  br i1 %cmp23, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.end21
  %16 = load ptr, ptr @stderr, align 8
  %call26 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %16, ptr noundef @.str.643)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end27:                                         ; preds = %if.end21
  %17 = load ptr, ptr %reply, align 8
  %tobool28 = icmp ne ptr %17, null
  br i1 %tobool28, label %if.then29, label %if.end55

if.then29:                                        ; preds = %if.end27
  %call30 = call i64 @time(ptr noundef null) #15
  store i64 %call30, ptr %last_read_time, align 8
  %18 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 0
  %19 = load i32, ptr %type, align 8
  %cmp31 = icmp eq i32 %19, 6
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %if.then29
  %20 = load ptr, ptr @stderr, align 8
  %21 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %21, i32 0, i32 4
  %22 = load ptr, ptr %str, align 8
  %call34 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %20, ptr noundef @.str.115, ptr noundef %22)
  %23 = load i64, ptr %errors, align 8
  %inc = add nsw i64 %23, 1
  store i64 %inc, ptr %errors, align 8
  br label %if.end53

if.else:                                          ; preds = %if.then29
  %24 = load i32, ptr %eof, align 4
  %tobool35 = icmp ne i32 %24, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.end52

land.lhs.true36:                                  ; preds = %if.else
  %25 = load ptr, ptr %reply, align 8
  %type37 = getelementptr inbounds %struct.redisReply, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %type37, align 8
  %cmp38 = icmp eq i32 %26, 1
  br i1 %cmp38, label %land.lhs.true40, label %if.end52

land.lhs.true40:                                  ; preds = %land.lhs.true36
  %27 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %27, i32 0, i32 3
  %28 = load i64, ptr %len, align 8
  %cmp41 = icmp eq i64 %28, 20
  br i1 %cmp41, label %if.then43, label %if.end52

if.then43:                                        ; preds = %land.lhs.true40
  %29 = load ptr, ptr %reply, align 8
  %str44 = getelementptr inbounds %struct.redisReply, ptr %29, i32 0, i32 4
  %30 = load ptr, ptr %str44, align 8
  %arraydecay45 = getelementptr inbounds [20 x i8], ptr %magic, i64 0, i64 0
  %call46 = call i32 @memcmp(ptr noundef %30, ptr noundef %arraydecay45, i64 noundef 20) #12
  %cmp47 = icmp eq i32 %call46, 0
  br i1 %cmp47, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.then43
  %call50 = call i32 (ptr, ...) @printf(ptr noundef @.str.644)
  store i32 1, ptr %done, align 4
  %31 = load i64, ptr %replies, align 8
  %dec = add nsw i64 %31, -1
  store i64 %dec, ptr %replies, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %if.then43
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %land.lhs.true40, %land.lhs.true36, %if.else
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.then33
  %32 = load i64, ptr %replies, align 8
  %inc54 = add nsw i64 %32, 1
  store i64 %inc54, ptr %replies, align 8
  %33 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %33)
  br label %if.end55

if.end55:                                         ; preds = %if.end53, %if.end27
  br label %do.cond

do.cond:                                          ; preds = %if.end55
  %34 = load ptr, ptr %reply, align 8
  %tobool56 = icmp ne ptr %34, null
  br i1 %tobool56, label %do.body, label %do.end, !llvm.loop !79

do.end:                                           ; preds = %do.cond
  %35 = load i32, ptr %read_error, align 4
  %tobool57 = icmp ne i32 %35, 0
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %do.end
  call void @exit(i32 noundef 1) #17
  unreachable

if.end59:                                         ; preds = %do.end
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end10
  %36 = load i32, ptr %mask, align 4
  %and61 = and i32 %36, 2
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then63, label %if.end141

if.then63:                                        ; preds = %if.end60
  store i64 0, ptr %loop_nwritten, align 8
  br label %while.body65

while.body65:                                     ; preds = %if.end140, %if.then63
  %37 = load i64, ptr %obuf_len, align 8
  %cmp66 = icmp ne i64 %37, 0
  br i1 %cmp66, label %if.then68, label %if.end93

if.then68:                                        ; preds = %while.body65
  %38 = load ptr, ptr @context, align 8
  %arraydecay69 = getelementptr inbounds [16384 x i8], ptr %obuf, i64 0, i64 0
  %39 = load i64, ptr %obuf_pos, align 8
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay69, i64 %39
  %40 = load i64, ptr %obuf_len, align 8
  %call70 = call i64 @cliWriteConn(ptr noundef %38, ptr noundef %add.ptr, i64 noundef %40)
  store i64 %call70, ptr %nwritten, align 8
  %41 = load i64, ptr %nwritten, align 8
  %cmp71 = icmp eq i64 %41, -1
  br i1 %cmp71, label %if.then73, label %if.end87

if.then73:                                        ; preds = %if.then68
  %call74 = call ptr @__errno_location() #16
  %42 = load i32, ptr %call74, align 4
  %cmp75 = icmp ne i32 %42, 11
  br i1 %cmp75, label %land.lhs.true77, label %if.else85

land.lhs.true77:                                  ; preds = %if.then73
  %call78 = call ptr @__errno_location() #16
  %43 = load i32, ptr %call78, align 4
  %cmp79 = icmp ne i32 %43, 4
  br i1 %cmp79, label %if.then81, label %if.else85

if.then81:                                        ; preds = %land.lhs.true77
  %44 = load ptr, ptr @stderr, align 8
  %call82 = call ptr @__errno_location() #16
  %45 = load i32, ptr %call82, align 4
  %call83 = call ptr @strerror(i32 noundef %45) #15
  %call84 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %44, ptr noundef @.str.645, ptr noundef %call83)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else85:                                        ; preds = %land.lhs.true77, %if.then73
  store i64 0, ptr %nwritten, align 8
  br label %if.end86

if.end86:                                         ; preds = %if.else85
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.then68
  %46 = load i64, ptr %nwritten, align 8
  %47 = load i64, ptr %obuf_len, align 8
  %sub = sub nsw i64 %47, %46
  store i64 %sub, ptr %obuf_len, align 8
  %48 = load i64, ptr %nwritten, align 8
  %49 = load i64, ptr %obuf_pos, align 8
  %add = add nsw i64 %49, %48
  store i64 %add, ptr %obuf_pos, align 8
  %50 = load i64, ptr %nwritten, align 8
  %51 = load i64, ptr %loop_nwritten, align 8
  %add88 = add nsw i64 %51, %50
  store i64 %add88, ptr %loop_nwritten, align 8
  %52 = load i64, ptr %obuf_len, align 8
  %cmp89 = icmp ne i64 %52, 0
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %if.end87
  br label %while.end

if.end92:                                         ; preds = %if.end87
  br label %if.end93

if.end93:                                         ; preds = %if.end92, %while.body65
  %53 = load ptr, ptr @context, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %53, i32 0, i32 1
  %54 = load i32, ptr %err, align 8
  %tobool94 = icmp ne i32 %54, 0
  br i1 %tobool94, label %if.then95, label %if.end98

if.then95:                                        ; preds = %if.end93
  %55 = load ptr, ptr @stderr, align 8
  %56 = load ptr, ptr @context, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %56, i32 0, i32 2
  %arraydecay96 = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call97 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %55, ptr noundef @.str.646, ptr noundef %arraydecay96)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end98:                                         ; preds = %if.end93
  %57 = load i64, ptr %obuf_len, align 8
  %cmp99 = icmp eq i64 %57, 0
  br i1 %cmp99, label %land.lhs.true101, label %if.end131

land.lhs.true101:                                 ; preds = %if.end98
  %58 = load i32, ptr %eof, align 4
  %tobool102 = icmp ne i32 %58, 0
  br i1 %tobool102, label %if.end131, label %if.then103

if.then103:                                       ; preds = %land.lhs.true101
  %arraydecay104 = getelementptr inbounds [16384 x i8], ptr %obuf, i64 0, i64 0
  %call105 = call i64 @read(i32 noundef 0, ptr noundef %arraydecay104, i64 noundef 16384)
  store i64 %call105, ptr %nread, align 8
  %59 = load i64, ptr %nread, align 8
  %cmp106 = icmp eq i64 %59, 0
  br i1 %cmp106, label %if.then108, label %if.else121

if.then108:                                       ; preds = %if.then103
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %echo, ptr align 16 @__const.pipeMode.echo, i64 44, i1 false)
  store i32 1, ptr %eof, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then108
  %60 = load i32, ptr %j, align 4
  %cmp109 = icmp slt i32 %60, 20
  br i1 %cmp109, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call111 = call i32 @rand() #15
  %and112 = and i32 %call111, 255
  %conv113 = trunc i32 %and112 to i8
  %61 = load i32, ptr %j, align 4
  %idxprom = sext i32 %61 to i64
  %arrayidx = getelementptr inbounds [20 x i8], ptr %magic, i64 0, i64 %idxprom
  store i8 %conv113, ptr %arrayidx, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %62 = load i32, ptr %j, align 4
  %inc114 = add nsw i32 %62, 1
  store i32 %inc114, ptr %j, align 4
  br label %for.cond, !llvm.loop !80

for.end:                                          ; preds = %for.cond
  %arraydecay115 = getelementptr inbounds [44 x i8], ptr %echo, i64 0, i64 0
  %add.ptr116 = getelementptr inbounds i8, ptr %arraydecay115, i64 21
  %arraydecay117 = getelementptr inbounds [20 x i8], ptr %magic, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %add.ptr116, ptr align 16 %arraydecay117, i64 20, i1 false)
  %arraydecay118 = getelementptr inbounds [16384 x i8], ptr %obuf, i64 0, i64 0
  %arraydecay119 = getelementptr inbounds [44 x i8], ptr %echo, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arraydecay118, ptr align 16 %arraydecay119, i64 43, i1 false)
  store i64 43, ptr %obuf_len, align 8
  store i64 0, ptr %obuf_pos, align 8
  %call120 = call i32 (ptr, ...) @printf(ptr noundef @.str.647)
  br label %if.end130

if.else121:                                       ; preds = %if.then103
  %63 = load i64, ptr %nread, align 8
  %cmp122 = icmp eq i64 %63, -1
  br i1 %cmp122, label %if.then124, label %if.else128

if.then124:                                       ; preds = %if.else121
  %64 = load ptr, ptr @stderr, align 8
  %call125 = call ptr @__errno_location() #16
  %65 = load i32, ptr %call125, align 4
  %call126 = call ptr @strerror(i32 noundef %65) #15
  %call127 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %64, ptr noundef @.str.648, ptr noundef %call126)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else128:                                       ; preds = %if.else121
  %66 = load i64, ptr %nread, align 8
  store i64 %66, ptr %obuf_len, align 8
  store i64 0, ptr %obuf_pos, align 8
  br label %if.end129

if.end129:                                        ; preds = %if.else128
  br label %if.end130

if.end130:                                        ; preds = %if.end129, %for.end
  br label %if.end131

if.end131:                                        ; preds = %if.end130, %land.lhs.true101, %if.end98
  %67 = load i64, ptr %obuf_len, align 8
  %cmp132 = icmp eq i64 %67, 0
  br i1 %cmp132, label %land.lhs.true134, label %lor.lhs.false136

land.lhs.true134:                                 ; preds = %if.end131
  %68 = load i32, ptr %eof, align 4
  %tobool135 = icmp ne i32 %68, 0
  br i1 %tobool135, label %if.then139, label %lor.lhs.false136

lor.lhs.false136:                                 ; preds = %land.lhs.true134, %if.end131
  %69 = load i64, ptr %loop_nwritten, align 8
  %cmp137 = icmp sgt i64 %69, 131072
  br i1 %cmp137, label %if.then139, label %if.end140

if.then139:                                       ; preds = %lor.lhs.false136, %land.lhs.true134
  br label %while.end

if.end140:                                        ; preds = %lor.lhs.false136
  br label %while.body65

while.end:                                        ; preds = %if.then139, %if.then91
  br label %if.end141

if.end141:                                        ; preds = %while.end, %if.end60
  %70 = load i32, ptr %eof, align 4
  %tobool142 = icmp ne i32 %70, 0
  br i1 %tobool142, label %land.lhs.true143, label %if.end155

land.lhs.true143:                                 ; preds = %if.end141
  %71 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 22), align 4
  %cmp144 = icmp sgt i32 %71, 0
  br i1 %cmp144, label %land.lhs.true146, label %if.end155

land.lhs.true146:                                 ; preds = %land.lhs.true143
  %call147 = call i64 @time(ptr noundef null) #15
  %72 = load i64, ptr %last_read_time, align 8
  %sub148 = sub nsw i64 %call147, %72
  %73 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 22), align 4
  %conv149 = sext i32 %73 to i64
  %cmp150 = icmp sgt i64 %sub148, %conv149
  br i1 %cmp150, label %if.then152, label %if.end155

if.then152:                                       ; preds = %land.lhs.true146
  %74 = load ptr, ptr @stderr, align 8
  %75 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 22), align 4
  %call153 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %74, ptr noundef @.str.649, i32 noundef %75)
  %76 = load i64, ptr %errors, align 8
  %inc154 = add nsw i64 %76, 1
  store i64 %inc154, ptr %errors, align 8
  br label %while.end156

if.end155:                                        ; preds = %land.lhs.true146, %land.lhs.true143, %if.end141
  br label %while.cond, !llvm.loop !81

while.end156:                                     ; preds = %if.then152, %while.cond
  %77 = load i64, ptr %errors, align 8
  %78 = load i64, ptr %replies, align 8
  %call157 = call i32 (ptr, ...) @printf(ptr noundef @.str.650, i64 noundef %77, i64 noundef %78)
  %79 = load i64, ptr %errors, align 8
  %tobool158 = icmp ne i64 %79, 0
  br i1 %tobool158, label %if.then159, label %if.else160

if.then159:                                       ; preds = %while.end156
  call void @exit(i32 noundef 1) #17
  unreachable

if.else160:                                       ; preds = %while.end156
  call void @exit(i32 noundef 0) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal void @findBigKeys(i32 noundef %memkeys, i32 noundef %memkeys_samples) #0 {
entry:
  %memkeys.addr = alloca i32, align 4
  %memkeys_samples.addr = alloca i32, align 4
  %sampled = alloca i64, align 8
  %total_keys = alloca i64, align 8
  %totlen = alloca i64, align 8
  %sizes = alloca ptr, align 8
  %it = alloca i64, align 8
  %scan_loops = alloca i64, align 8
  %reply = alloca ptr, align 8
  %keys = alloca ptr, align 8
  %arrsize = alloca i32, align 4
  %i = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %types = alloca ptr, align 8
  %pct = alloca double, align 8
  %types_dict = alloca ptr, align 8
  %type = alloca ptr, align 8
  %type120 = alloca ptr, align 8
  %type142 = alloca ptr, align 8
  store i32 %memkeys, ptr %memkeys.addr, align 4
  store i32 %memkeys_samples, ptr %memkeys_samples.addr, align 4
  store i64 0, ptr %sampled, align 8
  store i64 0, ptr %totlen, align 8
  store ptr null, ptr %sizes, align 8
  store i64 0, ptr %it, align 8
  store i64 0, ptr %scan_loops, align 8
  store i32 0, ptr %arrsize, align 4
  store ptr null, ptr %types, align 8
  %call = call ptr @dictCreate(ptr noundef @typeinfoDictType)
  store ptr %call, ptr %types_dict, align 8
  %0 = load ptr, ptr %types_dict, align 8
  %call1 = call ptr @typeinfo_add(ptr noundef %0, ptr noundef @.str.91, ptr noundef @type_string)
  %1 = load ptr, ptr %types_dict, align 8
  %call2 = call ptr @typeinfo_add(ptr noundef %1, ptr noundef @.str.94, ptr noundef @type_list)
  %2 = load ptr, ptr %types_dict, align 8
  %call3 = call ptr @typeinfo_add(ptr noundef %2, ptr noundef @.str.97, ptr noundef @type_set)
  %3 = load ptr, ptr %types_dict, align 8
  %call4 = call ptr @typeinfo_add(ptr noundef %3, ptr noundef @.str.100, ptr noundef @type_hash)
  %4 = load ptr, ptr %types_dict, align 8
  %call5 = call ptr @typeinfo_add(ptr noundef %4, ptr noundef @.str.103, ptr noundef @type_zset)
  %5 = load ptr, ptr %types_dict, align 8
  %call6 = call ptr @typeinfo_add(ptr noundef %5, ptr noundef @.str.105, ptr noundef @type_stream)
  %call7 = call ptr @signal(i32 noundef 2, ptr noundef @longStatLoopModeStop) #15
  %call8 = call i32 @getDbSize()
  %conv = sext i32 %call8 to i64
  store i64 %conv, ptr %total_keys, align 8
  %call9 = call i32 (ptr, ...) @printf(ptr noundef @.str.651)
  %call10 = call i32 (ptr, ...) @printf(ptr noundef @.str.652)
  %call11 = call i32 (ptr, ...) @printf(ptr noundef @.str.653)
  call void @sendReadOnly()
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %6 = load i64, ptr %sampled, align 8
  %conv12 = uitofp i64 %6 to double
  %mul = fmul double 1.000000e+02, %conv12
  %7 = load i64, ptr %total_keys, align 8
  %conv13 = uitofp i64 %7 to double
  %div = fdiv double %mul, %conv13
  store double %div, ptr %pct, align 8
  %call14 = call ptr @sendScan(ptr noundef %it)
  store ptr %call14, ptr %reply, align 8
  %8 = load i64, ptr %scan_loops, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %scan_loops, align 8
  %9 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %9, i32 0, i32 7
  %10 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %10, i64 1
  %11 = load ptr, ptr %arrayidx, align 8
  store ptr %11, ptr %keys, align 8
  %12 = load ptr, ptr %keys, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 6
  %13 = load i64, ptr %elements, align 8
  %14 = load i32, ptr %arrsize, align 4
  %conv15 = zext i32 %14 to i64
  %cmp = icmp ugt i64 %13, %conv15
  br i1 %cmp, label %if.then, label %if.end28

if.then:                                          ; preds = %do.body
  %15 = load ptr, ptr %types, align 8
  %16 = load ptr, ptr %keys, align 8
  %elements17 = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 6
  %17 = load i64, ptr %elements17, align 8
  %mul18 = mul i64 8, %17
  %call19 = call ptr @zrealloc(ptr noundef %15, i64 noundef %mul18) #13
  store ptr %call19, ptr %types, align 8
  %18 = load ptr, ptr %sizes, align 8
  %19 = load ptr, ptr %keys, align 8
  %elements20 = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 6
  %20 = load i64, ptr %elements20, align 8
  %mul21 = mul i64 8, %20
  %call22 = call ptr @zrealloc(ptr noundef %18, i64 noundef %mul21) #13
  store ptr %call22, ptr %sizes, align 8
  %21 = load ptr, ptr %types, align 8
  %tobool = icmp ne ptr %21, null
  br i1 %tobool, label %lor.lhs.false, label %if.then24

lor.lhs.false:                                    ; preds = %if.then
  %22 = load ptr, ptr %sizes, align 8
  %tobool23 = icmp ne ptr %22, null
  br i1 %tobool23, label %if.end, label %if.then24

if.then24:                                        ; preds = %lor.lhs.false, %if.then
  %23 = load ptr, ptr @stderr, align 8
  %call25 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %23, ptr noundef @.str.654)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  %24 = load ptr, ptr %keys, align 8
  %elements26 = getelementptr inbounds %struct.redisReply, ptr %24, i32 0, i32 6
  %25 = load i64, ptr %elements26, align 8
  %conv27 = trunc i64 %25 to i32
  store i32 %conv27, ptr %arrsize, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.end, %do.body
  %26 = load ptr, ptr %types_dict, align 8
  %27 = load ptr, ptr %keys, align 8
  %28 = load ptr, ptr %types, align 8
  call void @getKeyTypes(ptr noundef %26, ptr noundef %27, ptr noundef %28)
  %29 = load ptr, ptr %keys, align 8
  %30 = load ptr, ptr %types, align 8
  %31 = load ptr, ptr %sizes, align 8
  %32 = load i32, ptr %memkeys.addr, align 4
  %33 = load i32, ptr %memkeys_samples.addr, align 4
  call void @getKeySizes(ptr noundef %29, ptr noundef %30, ptr noundef %31, i32 noundef %32, i32 noundef %33)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end28
  %34 = load i32, ptr %i, align 4
  %conv29 = zext i32 %34 to i64
  %35 = load ptr, ptr %keys, align 8
  %elements30 = getelementptr inbounds %struct.redisReply, ptr %35, i32 0, i32 6
  %36 = load i64, ptr %elements30, align 8
  %cmp31 = icmp ult i64 %conv29, %36
  br i1 %cmp31, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %37 = load ptr, ptr %types, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom = zext i32 %38 to i64
  %arrayidx33 = getelementptr inbounds ptr, ptr %37, i64 %idxprom
  %39 = load ptr, ptr %arrayidx33, align 8
  store ptr %39, ptr %type, align 8
  %40 = load ptr, ptr %type, align 8
  %tobool34 = icmp ne ptr %40, null
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %for.body
  br label %for.inc

if.end36:                                         ; preds = %for.body
  %41 = load ptr, ptr %sizes, align 8
  %42 = load i32, ptr %i, align 4
  %idxprom37 = zext i32 %42 to i64
  %arrayidx38 = getelementptr inbounds i64, ptr %41, i64 %idxprom37
  %43 = load i64, ptr %arrayidx38, align 8
  %44 = load ptr, ptr %type, align 8
  %totalsize = getelementptr inbounds %struct.typeinfo, ptr %44, i32 0, i32 5
  %45 = load i64, ptr %totalsize, align 8
  %add = add i64 %45, %43
  store i64 %add, ptr %totalsize, align 8
  %46 = load ptr, ptr %type, align 8
  %count = getelementptr inbounds %struct.typeinfo, ptr %46, i32 0, i32 4
  %47 = load i64, ptr %count, align 8
  %inc39 = add i64 %47, 1
  store i64 %inc39, ptr %count, align 8
  %48 = load ptr, ptr %keys, align 8
  %element40 = getelementptr inbounds %struct.redisReply, ptr %48, i32 0, i32 7
  %49 = load ptr, ptr %element40, align 8
  %50 = load i32, ptr %i, align 4
  %idxprom41 = zext i32 %50 to i64
  %arrayidx42 = getelementptr inbounds ptr, ptr %49, i64 %idxprom41
  %51 = load ptr, ptr %arrayidx42, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %51, i32 0, i32 3
  %52 = load i64, ptr %len, align 8
  %53 = load i64, ptr %totlen, align 8
  %add43 = add i64 %53, %52
  store i64 %add43, ptr %totlen, align 8
  %54 = load i64, ptr %sampled, align 8
  %inc44 = add i64 %54, 1
  store i64 %inc44, ptr %sampled, align 8
  %55 = load ptr, ptr %type, align 8
  %biggest = getelementptr inbounds %struct.typeinfo, ptr %55, i32 0, i32 3
  %56 = load i64, ptr %biggest, align 8
  %57 = load ptr, ptr %sizes, align 8
  %58 = load i32, ptr %i, align 4
  %idxprom45 = zext i32 %58 to i64
  %arrayidx46 = getelementptr inbounds i64, ptr %57, i64 %idxprom45
  %59 = load i64, ptr %arrayidx46, align 8
  %cmp47 = icmp ult i64 %56, %59
  br i1 %cmp47, label %if.then49, label %if.end77

if.then49:                                        ; preds = %if.end36
  %60 = load ptr, ptr %type, align 8
  %biggest_key = getelementptr inbounds %struct.typeinfo, ptr %60, i32 0, i32 6
  %61 = load ptr, ptr %biggest_key, align 8
  %tobool50 = icmp ne ptr %61, null
  br i1 %tobool50, label %if.then51, label %if.end53

if.then51:                                        ; preds = %if.then49
  %62 = load ptr, ptr %type, align 8
  %biggest_key52 = getelementptr inbounds %struct.typeinfo, ptr %62, i32 0, i32 6
  %63 = load ptr, ptr %biggest_key52, align 8
  call void @hi_sdsfree(ptr noundef %63)
  br label %if.end53

if.end53:                                         ; preds = %if.then51, %if.then49
  %call54 = call ptr @hi_sdsempty()
  %64 = load ptr, ptr %keys, align 8
  %element55 = getelementptr inbounds %struct.redisReply, ptr %64, i32 0, i32 7
  %65 = load ptr, ptr %element55, align 8
  %66 = load i32, ptr %i, align 4
  %idxprom56 = zext i32 %66 to i64
  %arrayidx57 = getelementptr inbounds ptr, ptr %65, i64 %idxprom56
  %67 = load ptr, ptr %arrayidx57, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %67, i32 0, i32 4
  %68 = load ptr, ptr %str, align 8
  %69 = load ptr, ptr %keys, align 8
  %element58 = getelementptr inbounds %struct.redisReply, ptr %69, i32 0, i32 7
  %70 = load ptr, ptr %element58, align 8
  %71 = load i32, ptr %i, align 4
  %idxprom59 = zext i32 %71 to i64
  %arrayidx60 = getelementptr inbounds ptr, ptr %70, i64 %idxprom59
  %72 = load ptr, ptr %arrayidx60, align 8
  %len61 = getelementptr inbounds %struct.redisReply, ptr %72, i32 0, i32 3
  %73 = load i64, ptr %len61, align 8
  %call62 = call ptr @hi_sdscatrepr(ptr noundef %call54, ptr noundef %68, i64 noundef %73)
  %74 = load ptr, ptr %type, align 8
  %biggest_key63 = getelementptr inbounds %struct.typeinfo, ptr %74, i32 0, i32 6
  store ptr %call62, ptr %biggest_key63, align 8
  %75 = load ptr, ptr %type, align 8
  %biggest_key64 = getelementptr inbounds %struct.typeinfo, ptr %75, i32 0, i32 6
  %76 = load ptr, ptr %biggest_key64, align 8
  %tobool65 = icmp ne ptr %76, null
  br i1 %tobool65, label %if.end68, label %if.then66

if.then66:                                        ; preds = %if.end53
  %77 = load ptr, ptr @stderr, align 8
  %call67 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %77, ptr noundef @.str.655)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end68:                                         ; preds = %if.end53
  %78 = load double, ptr %pct, align 8
  %79 = load ptr, ptr %type, align 8
  %name = getelementptr inbounds %struct.typeinfo, ptr %79, i32 0, i32 0
  %80 = load ptr, ptr %name, align 8
  %81 = load ptr, ptr %type, align 8
  %biggest_key69 = getelementptr inbounds %struct.typeinfo, ptr %81, i32 0, i32 6
  %82 = load ptr, ptr %biggest_key69, align 8
  %83 = load ptr, ptr %sizes, align 8
  %84 = load i32, ptr %i, align 4
  %idxprom70 = zext i32 %84 to i64
  %arrayidx71 = getelementptr inbounds i64, ptr %83, i64 %idxprom70
  %85 = load i64, ptr %arrayidx71, align 8
  %86 = load i32, ptr %memkeys.addr, align 4
  %tobool72 = icmp ne i32 %86, 0
  br i1 %tobool72, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end68
  %87 = load ptr, ptr %type, align 8
  %sizeunit = getelementptr inbounds %struct.typeinfo, ptr %87, i32 0, i32 2
  %88 = load ptr, ptr %sizeunit, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end68
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %88, %cond.true ], [ @.str.93, %cond.false ]
  %call73 = call i32 (ptr, ...) @printf(ptr noundef @.str.656, double noundef %78, ptr noundef %80, ptr noundef %82, i64 noundef %85, ptr noundef %cond)
  %89 = load ptr, ptr %sizes, align 8
  %90 = load i32, ptr %i, align 4
  %idxprom74 = zext i32 %90 to i64
  %arrayidx75 = getelementptr inbounds i64, ptr %89, i64 %idxprom74
  %91 = load i64, ptr %arrayidx75, align 8
  %92 = load ptr, ptr %type, align 8
  %biggest76 = getelementptr inbounds %struct.typeinfo, ptr %92, i32 0, i32 3
  store i64 %91, ptr %biggest76, align 8
  br label %if.end77

if.end77:                                         ; preds = %cond.end, %if.end36
  %93 = load i64, ptr %sampled, align 8
  %rem = urem i64 %93, 1000000
  %cmp78 = icmp eq i64 %rem, 0
  br i1 %cmp78, label %if.then80, label %if.end82

if.then80:                                        ; preds = %if.end77
  %94 = load double, ptr %pct, align 8
  %95 = load i64, ptr %sampled, align 8
  %call81 = call i32 (ptr, ...) @printf(ptr noundef @.str.657, double noundef %94, i64 noundef %95)
  br label %if.end82

if.end82:                                         ; preds = %if.then80, %if.end77
  br label %for.inc

for.inc:                                          ; preds = %if.end82, %if.then35
  %96 = load i32, ptr %i, align 4
  %inc83 = add i32 %96, 1
  store i32 %inc83, ptr %i, align 4
  br label %for.cond, !llvm.loop !82

for.end:                                          ; preds = %for.cond
  %97 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %tobool84 = icmp ne i64 %97, 0
  br i1 %tobool84, label %land.lhs.true, label %if.end91

land.lhs.true:                                    ; preds = %for.end
  %98 = load i64, ptr %scan_loops, align 8
  %rem85 = urem i64 %98, 100
  %cmp86 = icmp eq i64 %rem85, 0
  br i1 %cmp86, label %if.then88, label %if.end91

if.then88:                                        ; preds = %land.lhs.true
  %99 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %conv89 = trunc i64 %99 to i32
  %call90 = call i32 @usleep(i32 noundef %conv89)
  br label %if.end91

if.end91:                                         ; preds = %if.then88, %land.lhs.true, %for.end
  %100 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %100)
  br label %do.cond

do.cond:                                          ; preds = %if.end91
  %101 = load volatile i32, ptr @force_cancel_loop, align 4
  %cmp92 = icmp eq i32 %101, 0
  br i1 %cmp92, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %102 = load i64, ptr %it, align 8
  %cmp94 = icmp ne i64 %102, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %103 = phi i1 [ false, %do.cond ], [ %cmp94, %land.rhs ]
  br i1 %103, label %do.body, label %do.end, !llvm.loop !83

do.end:                                           ; preds = %land.end
  %104 = load ptr, ptr %types, align 8
  %tobool96 = icmp ne ptr %104, null
  br i1 %tobool96, label %if.then97, label %if.end98

if.then97:                                        ; preds = %do.end
  %105 = load ptr, ptr %types, align 8
  call void @zfree(ptr noundef %105)
  br label %if.end98

if.end98:                                         ; preds = %if.then97, %do.end
  %106 = load ptr, ptr %sizes, align 8
  %tobool99 = icmp ne ptr %106, null
  br i1 %tobool99, label %if.then100, label %if.end101

if.then100:                                       ; preds = %if.end98
  %107 = load ptr, ptr %sizes, align 8
  call void @zfree(ptr noundef %107)
  br label %if.end101

if.end101:                                        ; preds = %if.then100, %if.end98
  %call102 = call i32 (ptr, ...) @printf(ptr noundef @.str.658)
  %108 = load volatile i32, ptr @force_cancel_loop, align 4
  %tobool103 = icmp ne i32 %108, 0
  br i1 %tobool103, label %if.then104, label %if.end106

if.then104:                                       ; preds = %if.end101
  %109 = load double, ptr %pct, align 8
  %call105 = call i32 (ptr, ...) @printf(ptr noundef @.str.659, double noundef %109)
  br label %if.end106

if.end106:                                        ; preds = %if.then104, %if.end101
  %110 = load i64, ptr %sampled, align 8
  %call107 = call i32 (ptr, ...) @printf(ptr noundef @.str.660, i64 noundef %110)
  %111 = load i64, ptr %totlen, align 8
  %112 = load i64, ptr %totlen, align 8
  %tobool108 = icmp ne i64 %112, 0
  br i1 %tobool108, label %cond.true109, label %cond.false113

cond.true109:                                     ; preds = %if.end106
  %113 = load i64, ptr %totlen, align 8
  %conv110 = uitofp i64 %113 to double
  %114 = load i64, ptr %sampled, align 8
  %conv111 = uitofp i64 %114 to double
  %div112 = fdiv double %conv110, %conv111
  br label %cond.end114

cond.false113:                                    ; preds = %if.end106
  br label %cond.end114

cond.end114:                                      ; preds = %cond.false113, %cond.true109
  %cond115 = phi double [ %div112, %cond.true109 ], [ 0.000000e+00, %cond.false113 ]
  %call116 = call i32 (ptr, ...) @printf(ptr noundef @.str.661, i64 noundef %111, double noundef %cond115)
  %115 = load ptr, ptr %types_dict, align 8
  %call117 = call ptr @dictGetIterator(ptr noundef %115)
  store ptr %call117, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end135, %cond.end114
  %116 = load ptr, ptr %di, align 8
  %call118 = call ptr @dictNext(ptr noundef %116)
  store ptr %call118, ptr %de, align 8
  %tobool119 = icmp ne ptr %call118, null
  br i1 %tobool119, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %117 = load ptr, ptr %de, align 8
  %call121 = call ptr @dictGetVal(ptr noundef %117)
  store ptr %call121, ptr %type120, align 8
  %118 = load ptr, ptr %type120, align 8
  %biggest_key122 = getelementptr inbounds %struct.typeinfo, ptr %118, i32 0, i32 6
  %119 = load ptr, ptr %biggest_key122, align 8
  %tobool123 = icmp ne ptr %119, null
  br i1 %tobool123, label %if.then124, label %if.end135

if.then124:                                       ; preds = %while.body
  %120 = load ptr, ptr %type120, align 8
  %name125 = getelementptr inbounds %struct.typeinfo, ptr %120, i32 0, i32 0
  %121 = load ptr, ptr %name125, align 8
  %122 = load ptr, ptr %type120, align 8
  %biggest_key126 = getelementptr inbounds %struct.typeinfo, ptr %122, i32 0, i32 6
  %123 = load ptr, ptr %biggest_key126, align 8
  %124 = load ptr, ptr %type120, align 8
  %biggest127 = getelementptr inbounds %struct.typeinfo, ptr %124, i32 0, i32 3
  %125 = load i64, ptr %biggest127, align 8
  %126 = load i32, ptr %memkeys.addr, align 4
  %tobool128 = icmp ne i32 %126, 0
  br i1 %tobool128, label %cond.false131, label %cond.true129

cond.true129:                                     ; preds = %if.then124
  %127 = load ptr, ptr %type120, align 8
  %sizeunit130 = getelementptr inbounds %struct.typeinfo, ptr %127, i32 0, i32 2
  %128 = load ptr, ptr %sizeunit130, align 8
  br label %cond.end132

cond.false131:                                    ; preds = %if.then124
  br label %cond.end132

cond.end132:                                      ; preds = %cond.false131, %cond.true129
  %cond133 = phi ptr [ %128, %cond.true129 ], [ @.str.93, %cond.false131 ]
  %call134 = call i32 (ptr, ...) @printf(ptr noundef @.str.662, ptr noundef %121, ptr noundef %123, i64 noundef %125, ptr noundef %cond133)
  br label %if.end135

if.end135:                                        ; preds = %cond.end132, %while.body
  br label %while.cond, !llvm.loop !84

while.end:                                        ; preds = %while.cond
  %129 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %129)
  %call136 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  %130 = load ptr, ptr %types_dict, align 8
  %call137 = call ptr @dictGetIterator(ptr noundef %130)
  store ptr %call137, ptr %di, align 8
  br label %while.cond138

while.cond138:                                    ; preds = %cond.end172, %while.end
  %131 = load ptr, ptr %di, align 8
  %call139 = call ptr @dictNext(ptr noundef %131)
  store ptr %call139, ptr %de, align 8
  %tobool140 = icmp ne ptr %call139, null
  br i1 %tobool140, label %while.body141, label %while.end175

while.body141:                                    ; preds = %while.cond138
  %132 = load ptr, ptr %de, align 8
  %call143 = call ptr @dictGetVal(ptr noundef %132)
  store ptr %call143, ptr %type142, align 8
  %133 = load ptr, ptr %type142, align 8
  %count144 = getelementptr inbounds %struct.typeinfo, ptr %133, i32 0, i32 4
  %134 = load i64, ptr %count144, align 8
  %135 = load ptr, ptr %type142, align 8
  %name145 = getelementptr inbounds %struct.typeinfo, ptr %135, i32 0, i32 0
  %136 = load ptr, ptr %name145, align 8
  %137 = load ptr, ptr %type142, align 8
  %totalsize146 = getelementptr inbounds %struct.typeinfo, ptr %137, i32 0, i32 5
  %138 = load i64, ptr %totalsize146, align 8
  %139 = load i32, ptr %memkeys.addr, align 4
  %tobool147 = icmp ne i32 %139, 0
  br i1 %tobool147, label %cond.false150, label %cond.true148

cond.true148:                                     ; preds = %while.body141
  %140 = load ptr, ptr %type142, align 8
  %sizeunit149 = getelementptr inbounds %struct.typeinfo, ptr %140, i32 0, i32 2
  %141 = load ptr, ptr %sizeunit149, align 8
  br label %cond.end151

cond.false150:                                    ; preds = %while.body141
  br label %cond.end151

cond.end151:                                      ; preds = %cond.false150, %cond.true148
  %cond152 = phi ptr [ %141, %cond.true148 ], [ @.str.93, %cond.false150 ]
  %142 = load i64, ptr %sampled, align 8
  %tobool153 = icmp ne i64 %142, 0
  br i1 %tobool153, label %cond.true154, label %cond.false160

cond.true154:                                     ; preds = %cond.end151
  %143 = load ptr, ptr %type142, align 8
  %count155 = getelementptr inbounds %struct.typeinfo, ptr %143, i32 0, i32 4
  %144 = load i64, ptr %count155, align 8
  %conv156 = uitofp i64 %144 to double
  %mul157 = fmul double 1.000000e+02, %conv156
  %145 = load i64, ptr %sampled, align 8
  %conv158 = uitofp i64 %145 to double
  %div159 = fdiv double %mul157, %conv158
  br label %cond.end161

cond.false160:                                    ; preds = %cond.end151
  br label %cond.end161

cond.end161:                                      ; preds = %cond.false160, %cond.true154
  %cond162 = phi double [ %div159, %cond.true154 ], [ 0.000000e+00, %cond.false160 ]
  %146 = load ptr, ptr %type142, align 8
  %count163 = getelementptr inbounds %struct.typeinfo, ptr %146, i32 0, i32 4
  %147 = load i64, ptr %count163, align 8
  %tobool164 = icmp ne i64 %147, 0
  br i1 %tobool164, label %cond.true165, label %cond.false171

cond.true165:                                     ; preds = %cond.end161
  %148 = load ptr, ptr %type142, align 8
  %totalsize166 = getelementptr inbounds %struct.typeinfo, ptr %148, i32 0, i32 5
  %149 = load i64, ptr %totalsize166, align 8
  %conv167 = uitofp i64 %149 to double
  %150 = load ptr, ptr %type142, align 8
  %count168 = getelementptr inbounds %struct.typeinfo, ptr %150, i32 0, i32 4
  %151 = load i64, ptr %count168, align 8
  %conv169 = uitofp i64 %151 to double
  %div170 = fdiv double %conv167, %conv169
  br label %cond.end172

cond.false171:                                    ; preds = %cond.end161
  br label %cond.end172

cond.end172:                                      ; preds = %cond.false171, %cond.true165
  %cond173 = phi double [ %div170, %cond.true165 ], [ 0.000000e+00, %cond.false171 ]
  %call174 = call i32 (ptr, ...) @printf(ptr noundef @.str.663, i64 noundef %134, ptr noundef %136, i64 noundef %138, ptr noundef %cond152, double noundef %cond162, double noundef %cond173)
  br label %while.cond138, !llvm.loop !85

while.end175:                                     ; preds = %while.cond138
  %152 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %152)
  %153 = load ptr, ptr %types_dict, align 8
  call void @dictRelease(ptr noundef %153)
  call void @exit(i32 noundef 0) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal void @findHotKeys() #0 {
entry:
  %keys = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %counters = alloca [16 x i64], align 16
  %hotkeys = alloca [16 x ptr], align 16
  %sampled = alloca i64, align 8
  %total_keys = alloca i64, align 8
  %freqs = alloca ptr, align 8
  %it = alloca i64, align 8
  %scan_loops = alloca i64, align 8
  %arrsize = alloca i32, align 4
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %pct = alloca double, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %counters, i8 0, i64 128, i1 false)
  call void @llvm.memset.p0.i64(ptr align 16 %hotkeys, i8 0, i64 128, i1 false)
  store i64 0, ptr %sampled, align 8
  store ptr null, ptr %freqs, align 8
  store i64 0, ptr %it, align 8
  store i64 0, ptr %scan_loops, align 8
  store i32 0, ptr %arrsize, align 4
  %call = call ptr @signal(i32 noundef 2, ptr noundef @longStatLoopModeStop) #15
  %call1 = call i32 @getDbSize()
  %conv = sext i32 %call1 to i64
  store i64 %conv, ptr %total_keys, align 8
  %call2 = call i32 (ptr, ...) @printf(ptr noundef @.str.684)
  %call3 = call i32 (ptr, ...) @printf(ptr noundef @.str.652)
  %call4 = call i32 (ptr, ...) @printf(ptr noundef @.str.653)
  call void @sendReadOnly()
  br label %do.body

do.body:                                          ; preds = %land.end92, %entry
  %0 = load i64, ptr %sampled, align 8
  %conv5 = uitofp i64 %0 to double
  %mul = fmul double 1.000000e+02, %conv5
  %1 = load i64, ptr %total_keys, align 8
  %conv6 = uitofp i64 %1 to double
  %div = fdiv double %mul, %conv6
  store double %div, ptr %pct, align 8
  %call7 = call ptr @sendScan(ptr noundef %it)
  store ptr %call7, ptr %reply, align 8
  %2 = load i64, ptr %scan_loops, align 8
  %inc = add i64 %2, 1
  store i64 %inc, ptr %scan_loops, align 8
  %3 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 7
  %4 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 1
  %5 = load ptr, ptr %arrayidx, align 8
  store ptr %5, ptr %keys, align 8
  %6 = load ptr, ptr %keys, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %elements, align 8
  %8 = load i32, ptr %arrsize, align 4
  %conv8 = zext i32 %8 to i64
  %cmp = icmp ugt i64 %7, %conv8
  br i1 %cmp, label %if.then, label %if.end17

if.then:                                          ; preds = %do.body
  %9 = load ptr, ptr %freqs, align 8
  %10 = load ptr, ptr %keys, align 8
  %elements10 = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 6
  %11 = load i64, ptr %elements10, align 8
  %mul11 = mul i64 8, %11
  %call12 = call ptr @zrealloc(ptr noundef %9, i64 noundef %mul11) #13
  store ptr %call12, ptr %freqs, align 8
  %12 = load ptr, ptr %freqs, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.end, label %if.then13

if.then13:                                        ; preds = %if.then
  %13 = load ptr, ptr @stderr, align 8
  %call14 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %13, ptr noundef @.str.654)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %if.then
  %14 = load ptr, ptr %keys, align 8
  %elements15 = getelementptr inbounds %struct.redisReply, ptr %14, i32 0, i32 6
  %15 = load i64, ptr %elements15, align 8
  %conv16 = trunc i64 %15 to i32
  store i32 %conv16, ptr %arrsize, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.end, %do.body
  %16 = load ptr, ptr %keys, align 8
  %17 = load ptr, ptr %freqs, align 8
  call void @getKeyFreqs(ptr noundef %16, ptr noundef %17)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end17
  %18 = load i32, ptr %i, align 4
  %conv18 = zext i32 %18 to i64
  %19 = load ptr, ptr %keys, align 8
  %elements19 = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 6
  %20 = load i64, ptr %elements19, align 8
  %cmp20 = icmp ult i64 %conv18, %20
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load i64, ptr %sampled, align 8
  %inc22 = add i64 %21, 1
  store i64 %inc22, ptr %sampled, align 8
  %22 = load i64, ptr %sampled, align 8
  %rem = urem i64 %22, 1000000
  %cmp23 = icmp eq i64 %rem, 0
  br i1 %cmp23, label %if.then25, label %if.end27

if.then25:                                        ; preds = %for.body
  %23 = load double, ptr %pct, align 8
  %24 = load i64, ptr %sampled, align 8
  %call26 = call i32 (ptr, ...) @printf(ptr noundef @.str.657, double noundef %23, i64 noundef %24)
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %for.body
  store i32 0, ptr %k, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end27
  %25 = load i32, ptr %k, align 4
  %cmp28 = icmp ult i32 %25, 16
  br i1 %cmp28, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %26 = load ptr, ptr %freqs, align 8
  %27 = load i32, ptr %i, align 4
  %idxprom = zext i32 %27 to i64
  %arrayidx30 = getelementptr inbounds i64, ptr %26, i64 %idxprom
  %28 = load i64, ptr %arrayidx30, align 8
  %29 = load i32, ptr %k, align 4
  %idxprom31 = zext i32 %29 to i64
  %arrayidx32 = getelementptr inbounds [16 x i64], ptr %counters, i64 0, i64 %idxprom31
  %30 = load i64, ptr %arrayidx32, align 8
  %cmp33 = icmp ugt i64 %28, %30
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %31 = phi i1 [ false, %while.cond ], [ %cmp33, %land.rhs ]
  br i1 %31, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %32 = load i32, ptr %k, align 4
  %inc35 = add i32 %32, 1
  store i32 %inc35, ptr %k, align 4
  br label %while.cond, !llvm.loop !86

while.end:                                        ; preds = %land.end
  %33 = load i32, ptr %k, align 4
  %cmp36 = icmp eq i32 %33, 0
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %while.end
  br label %for.inc

if.end39:                                         ; preds = %while.end
  %34 = load i32, ptr %k, align 4
  %dec = add i32 %34, -1
  store i32 %dec, ptr %k, align 4
  %35 = load i32, ptr %k, align 4
  %cmp40 = icmp eq i32 %35, 0
  br i1 %cmp40, label %if.then46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end39
  %36 = load i32, ptr %k, align 4
  %idxprom42 = zext i32 %36 to i64
  %arrayidx43 = getelementptr inbounds [16 x i64], ptr %counters, i64 0, i64 %idxprom42
  %37 = load i64, ptr %arrayidx43, align 8
  %cmp44 = icmp eq i64 %37, 0
  br i1 %cmp44, label %if.then46, label %if.else

if.then46:                                        ; preds = %lor.lhs.false, %if.end39
  %38 = load i32, ptr %k, align 4
  %idxprom47 = zext i32 %38 to i64
  %arrayidx48 = getelementptr inbounds [16 x ptr], ptr %hotkeys, i64 0, i64 %idxprom47
  %39 = load ptr, ptr %arrayidx48, align 8
  call void @hi_sdsfree(ptr noundef %39)
  br label %if.end58

if.else:                                          ; preds = %lor.lhs.false
  %arrayidx49 = getelementptr inbounds [16 x ptr], ptr %hotkeys, i64 0, i64 0
  %40 = load ptr, ptr %arrayidx49, align 16
  call void @hi_sdsfree(ptr noundef %40)
  %arraydecay = getelementptr inbounds [16 x i64], ptr %counters, i64 0, i64 0
  %arraydecay50 = getelementptr inbounds [16 x i64], ptr %counters, i64 0, i64 0
  %add.ptr = getelementptr inbounds i64, ptr %arraydecay50, i64 1
  %41 = load i32, ptr %k, align 4
  %conv51 = zext i32 %41 to i64
  %mul52 = mul i64 8, %conv51
  call void @llvm.memmove.p0.p0.i64(ptr align 16 %arraydecay, ptr align 8 %add.ptr, i64 %mul52, i1 false)
  %arraydecay53 = getelementptr inbounds [16 x ptr], ptr %hotkeys, i64 0, i64 0
  %arraydecay54 = getelementptr inbounds [16 x ptr], ptr %hotkeys, i64 0, i64 0
  %add.ptr55 = getelementptr inbounds ptr, ptr %arraydecay54, i64 1
  %42 = load i32, ptr %k, align 4
  %conv56 = zext i32 %42 to i64
  %mul57 = mul i64 8, %conv56
  call void @llvm.memmove.p0.p0.i64(ptr align 16 %arraydecay53, ptr align 8 %add.ptr55, i64 %mul57, i1 false)
  br label %if.end58

if.end58:                                         ; preds = %if.else, %if.then46
  %43 = load ptr, ptr %freqs, align 8
  %44 = load i32, ptr %i, align 4
  %idxprom59 = zext i32 %44 to i64
  %arrayidx60 = getelementptr inbounds i64, ptr %43, i64 %idxprom59
  %45 = load i64, ptr %arrayidx60, align 8
  %46 = load i32, ptr %k, align 4
  %idxprom61 = zext i32 %46 to i64
  %arrayidx62 = getelementptr inbounds [16 x i64], ptr %counters, i64 0, i64 %idxprom61
  store i64 %45, ptr %arrayidx62, align 8
  %call63 = call ptr @hi_sdsempty()
  %47 = load ptr, ptr %keys, align 8
  %element64 = getelementptr inbounds %struct.redisReply, ptr %47, i32 0, i32 7
  %48 = load ptr, ptr %element64, align 8
  %49 = load i32, ptr %i, align 4
  %idxprom65 = zext i32 %49 to i64
  %arrayidx66 = getelementptr inbounds ptr, ptr %48, i64 %idxprom65
  %50 = load ptr, ptr %arrayidx66, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %50, i32 0, i32 4
  %51 = load ptr, ptr %str, align 8
  %52 = load ptr, ptr %keys, align 8
  %element67 = getelementptr inbounds %struct.redisReply, ptr %52, i32 0, i32 7
  %53 = load ptr, ptr %element67, align 8
  %54 = load i32, ptr %i, align 4
  %idxprom68 = zext i32 %54 to i64
  %arrayidx69 = getelementptr inbounds ptr, ptr %53, i64 %idxprom68
  %55 = load ptr, ptr %arrayidx69, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %55, i32 0, i32 3
  %56 = load i64, ptr %len, align 8
  %call70 = call ptr @hi_sdscatrepr(ptr noundef %call63, ptr noundef %51, i64 noundef %56)
  %57 = load i32, ptr %k, align 4
  %idxprom71 = zext i32 %57 to i64
  %arrayidx72 = getelementptr inbounds [16 x ptr], ptr %hotkeys, i64 0, i64 %idxprom71
  store ptr %call70, ptr %arrayidx72, align 8
  %58 = load double, ptr %pct, align 8
  %59 = load i32, ptr %k, align 4
  %idxprom73 = zext i32 %59 to i64
  %arrayidx74 = getelementptr inbounds [16 x ptr], ptr %hotkeys, i64 0, i64 %idxprom73
  %60 = load ptr, ptr %arrayidx74, align 8
  %61 = load ptr, ptr %freqs, align 8
  %62 = load i32, ptr %i, align 4
  %idxprom75 = zext i32 %62 to i64
  %arrayidx76 = getelementptr inbounds i64, ptr %61, i64 %idxprom75
  %63 = load i64, ptr %arrayidx76, align 8
  %call77 = call i32 (ptr, ...) @printf(ptr noundef @.str.685, double noundef %58, ptr noundef %60, i64 noundef %63)
  br label %for.inc

for.inc:                                          ; preds = %if.end58, %if.then38
  %64 = load i32, ptr %i, align 4
  %inc78 = add i32 %64, 1
  store i32 %inc78, ptr %i, align 4
  br label %for.cond, !llvm.loop !87

for.end:                                          ; preds = %for.cond
  %65 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %tobool79 = icmp ne i64 %65, 0
  br i1 %tobool79, label %land.lhs.true, label %if.end86

land.lhs.true:                                    ; preds = %for.end
  %66 = load i64, ptr %scan_loops, align 8
  %rem80 = urem i64 %66, 100
  %cmp81 = icmp eq i64 %rem80, 0
  br i1 %cmp81, label %if.then83, label %if.end86

if.then83:                                        ; preds = %land.lhs.true
  %67 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %conv84 = trunc i64 %67 to i32
  %call85 = call i32 @usleep(i32 noundef %conv84)
  br label %if.end86

if.end86:                                         ; preds = %if.then83, %land.lhs.true, %for.end
  %68 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %68)
  br label %do.cond

do.cond:                                          ; preds = %if.end86
  %69 = load volatile i32, ptr @force_cancel_loop, align 4
  %cmp87 = icmp eq i32 %69, 0
  br i1 %cmp87, label %land.rhs89, label %land.end92

land.rhs89:                                       ; preds = %do.cond
  %70 = load i64, ptr %it, align 8
  %cmp90 = icmp ne i64 %70, 0
  br label %land.end92

land.end92:                                       ; preds = %land.rhs89, %do.cond
  %71 = phi i1 [ false, %do.cond ], [ %cmp90, %land.rhs89 ]
  br i1 %71, label %do.body, label %do.end, !llvm.loop !88

do.end:                                           ; preds = %land.end92
  %72 = load ptr, ptr %freqs, align 8
  %tobool93 = icmp ne ptr %72, null
  br i1 %tobool93, label %if.then94, label %if.end95

if.then94:                                        ; preds = %do.end
  %73 = load ptr, ptr %freqs, align 8
  call void @zfree(ptr noundef %73)
  br label %if.end95

if.end95:                                         ; preds = %if.then94, %do.end
  %call96 = call i32 (ptr, ...) @printf(ptr noundef @.str.658)
  %74 = load volatile i32, ptr @force_cancel_loop, align 4
  %tobool97 = icmp ne i32 %74, 0
  br i1 %tobool97, label %if.then98, label %if.end100

if.then98:                                        ; preds = %if.end95
  %75 = load double, ptr %pct, align 8
  %call99 = call i32 (ptr, ...) @printf(ptr noundef @.str.659, double noundef %75)
  br label %if.end100

if.end100:                                        ; preds = %if.then98, %if.end95
  %76 = load i64, ptr %sampled, align 8
  %call101 = call i32 (ptr, ...) @printf(ptr noundef @.str.660, i64 noundef %76)
  store i32 1, ptr %i, align 4
  br label %for.cond102

for.cond102:                                      ; preds = %for.inc119, %if.end100
  %77 = load i32, ptr %i, align 4
  %cmp103 = icmp ule i32 %77, 16
  br i1 %cmp103, label %for.body105, label %for.end121

for.body105:                                      ; preds = %for.cond102
  %78 = load i32, ptr %i, align 4
  %sub = sub i32 16, %78
  store i32 %sub, ptr %k, align 4
  %79 = load i32, ptr %k, align 4
  %idxprom106 = zext i32 %79 to i64
  %arrayidx107 = getelementptr inbounds [16 x i64], ptr %counters, i64 0, i64 %idxprom106
  %80 = load i64, ptr %arrayidx107, align 8
  %cmp108 = icmp ugt i64 %80, 0
  br i1 %cmp108, label %if.then110, label %if.end118

if.then110:                                       ; preds = %for.body105
  %81 = load i32, ptr %k, align 4
  %idxprom111 = zext i32 %81 to i64
  %arrayidx112 = getelementptr inbounds [16 x i64], ptr %counters, i64 0, i64 %idxprom111
  %82 = load i64, ptr %arrayidx112, align 8
  %83 = load i32, ptr %k, align 4
  %idxprom113 = zext i32 %83 to i64
  %arrayidx114 = getelementptr inbounds [16 x ptr], ptr %hotkeys, i64 0, i64 %idxprom113
  %84 = load ptr, ptr %arrayidx114, align 8
  %call115 = call i32 (ptr, ...) @printf(ptr noundef @.str.686, i64 noundef %82, ptr noundef %84)
  %85 = load i32, ptr %k, align 4
  %idxprom116 = zext i32 %85 to i64
  %arrayidx117 = getelementptr inbounds [16 x ptr], ptr %hotkeys, i64 0, i64 %idxprom116
  %86 = load ptr, ptr %arrayidx117, align 8
  call void @hi_sdsfree(ptr noundef %86)
  br label %if.end118

if.end118:                                        ; preds = %if.then110, %for.body105
  br label %for.inc119

for.inc119:                                       ; preds = %if.end118
  %87 = load i32, ptr %i, align 4
  %inc120 = add i32 %87, 1
  store i32 %inc120, ptr %i, align 4
  br label %for.cond102, !llvm.loop !89

for.end121:                                       ; preds = %for.cond102
  call void @exit(i32 noundef 0) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal void @statMode() #0 {
entry:
  %reply = alloca ptr, align 8
  %aux = alloca i64, align 8
  %requests = alloca i64, align 8
  %dbnum = alloca i32, align 4
  %i = alloca i32, align 4
  %buf = alloca [64 x i8], align 16
  %j = alloca i32, align 4
  %k = alloca i64, align 8
  store i64 0, ptr %requests, align 8
  %call = call i32 @getDatabases()
  store i32 %call, ptr %dbnum, align 4
  store i32 0, ptr %i, align 4
  br label %while.body

while.body:                                       ; preds = %sw.epilog, %entry
  %0 = load ptr, ptr @context, align 8
  %call1 = call ptr (ptr, ptr, ...) @reconnectingRedisCommand(ptr noundef %0, ptr noundef @.str.186)
  store ptr %call1, ptr %reply, align 8
  %1 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %2 = load ptr, ptr @stderr, align 8
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef @.str.76)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else:                                          ; preds = %while.body
  %3 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type, align 8
  %cmp3 = icmp eq i32 %4, 6
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %5 = load ptr, ptr @stderr, align 8
  %6 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %str, align 8
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.691, ptr noundef %7)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end
  %8 = load i32, ptr %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %i, align 4
  %rem = srem i32 %8, 20
  %cmp7 = icmp eq i32 %rem, 0
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end6
  %call9 = call i32 (ptr, ...) @printf(ptr noundef @.str.692)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end6
  store i64 0, ptr %aux, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %9 = load i32, ptr %j, align 4
  %10 = load i32, ptr %dbnum, align 4
  %cmp11 = icmp slt i32 %9, %10
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %11 = load i32, ptr %j, align 4
  %call12 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 64, ptr noundef @.str.693, i32 noundef %11) #15
  %12 = load ptr, ptr %reply, align 8
  %str13 = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %str13, align 8
  %arraydecay14 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call15 = call i64 @getLongInfoField(ptr noundef %13, ptr noundef %arraydecay14)
  store i64 %call15, ptr %k, align 8
  %14 = load i64, ptr %k, align 8
  %cmp16 = icmp eq i64 %14, -9223372036854775808
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body
  br label %for.inc

if.end18:                                         ; preds = %for.body
  %15 = load i64, ptr %k, align 8
  %16 = load i64, ptr %aux, align 8
  %add = add nsw i64 %16, %15
  store i64 %add, ptr %aux, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end18, %if.then17
  %17 = load i32, ptr %j, align 4
  %inc19 = add nsw i32 %17, 1
  store i32 %inc19, ptr %j, align 4
  br label %for.cond, !llvm.loop !90

for.end:                                          ; preds = %for.cond
  %arraydecay20 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %18 = load i64, ptr %aux, align 8
  %call21 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay20, i64 noundef 64, ptr noundef @.str.694, i64 noundef %18) #15
  %arraydecay22 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call23 = call i32 (ptr, ...) @printf(ptr noundef @.str.695, ptr noundef %arraydecay22)
  %19 = load ptr, ptr %reply, align 8
  %str24 = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 4
  %20 = load ptr, ptr %str24, align 8
  %call25 = call i64 @getLongInfoField(ptr noundef %20, ptr noundef @.str.696)
  store i64 %call25, ptr %aux, align 8
  %arraydecay26 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %21 = load i64, ptr %aux, align 8
  call void @bytesToHuman(ptr noundef %arraydecay26, i64 noundef 64, i64 noundef %21)
  %arraydecay27 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call28 = call i32 (ptr, ...) @printf(ptr noundef @.str.697, ptr noundef %arraydecay27)
  %22 = load ptr, ptr %reply, align 8
  %str29 = getelementptr inbounds %struct.redisReply, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %str29, align 8
  %call30 = call i64 @getLongInfoField(ptr noundef %23, ptr noundef @.str.698)
  store i64 %call30, ptr %aux, align 8
  %arraydecay31 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %24 = load i64, ptr %aux, align 8
  %call32 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay31, i64 noundef 64, ptr noundef @.str.694, i64 noundef %24) #15
  %arraydecay33 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call34 = call i32 (ptr, ...) @printf(ptr noundef @.str.699, ptr noundef %arraydecay33)
  %25 = load ptr, ptr %reply, align 8
  %str35 = getelementptr inbounds %struct.redisReply, ptr %25, i32 0, i32 4
  %26 = load ptr, ptr %str35, align 8
  %call36 = call i64 @getLongInfoField(ptr noundef %26, ptr noundef @.str.700)
  store i64 %call36, ptr %aux, align 8
  %arraydecay37 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %27 = load i64, ptr %aux, align 8
  %call38 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay37, i64 noundef 64, ptr noundef @.str.694, i64 noundef %27) #15
  %arraydecay39 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call40 = call i32 (ptr, ...) @printf(ptr noundef @.str.697, ptr noundef %arraydecay39)
  %28 = load ptr, ptr %reply, align 8
  %str41 = getelementptr inbounds %struct.redisReply, ptr %28, i32 0, i32 4
  %29 = load ptr, ptr %str41, align 8
  %call42 = call i64 @getLongInfoField(ptr noundef %29, ptr noundef @.str.701)
  store i64 %call42, ptr %aux, align 8
  %arraydecay43 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %30 = load i64, ptr %aux, align 8
  %31 = load i64, ptr %requests, align 8
  %cmp44 = icmp eq i64 %31, 0
  br i1 %cmp44, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %32 = load i64, ptr %aux, align 8
  %33 = load i64, ptr %requests, align 8
  %sub = sub nsw i64 %32, %33
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %sub, %cond.false ]
  %call45 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay43, i64 noundef 64, ptr noundef @.str.702, i64 noundef %30, i64 noundef %cond) #15
  %arraydecay46 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call47 = call i32 (ptr, ...) @printf(ptr noundef @.str.703, ptr noundef %arraydecay46)
  %34 = load i64, ptr %aux, align 8
  store i64 %34, ptr %requests, align 8
  %35 = load ptr, ptr %reply, align 8
  %str48 = getelementptr inbounds %struct.redisReply, ptr %35, i32 0, i32 4
  %36 = load ptr, ptr %str48, align 8
  %call49 = call i64 @getLongInfoField(ptr noundef %36, ptr noundef @.str.704)
  store i64 %call49, ptr %aux, align 8
  %arraydecay50 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %37 = load i64, ptr %aux, align 8
  %call51 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay50, i64 noundef 64, ptr noundef @.str.694, i64 noundef %37) #15
  %arraydecay52 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call53 = call i32 (ptr, ...) @printf(ptr noundef @.str.705, ptr noundef %arraydecay52)
  %38 = load ptr, ptr %reply, align 8
  %str54 = getelementptr inbounds %struct.redisReply, ptr %38, i32 0, i32 4
  %39 = load ptr, ptr %str54, align 8
  %call55 = call i64 @getLongInfoField(ptr noundef %39, ptr noundef @.str.706)
  store i64 %call55, ptr %aux, align 8
  %40 = load ptr, ptr %reply, align 8
  %str56 = getelementptr inbounds %struct.redisReply, ptr %40, i32 0, i32 4
  %41 = load ptr, ptr %str56, align 8
  %call57 = call i64 @getLongInfoField(ptr noundef %41, ptr noundef @.str.707)
  %shl = shl i64 %call57, 1
  %42 = load i64, ptr %aux, align 8
  %or = or i64 %42, %shl
  store i64 %or, ptr %aux, align 8
  %43 = load ptr, ptr %reply, align 8
  %str58 = getelementptr inbounds %struct.redisReply, ptr %43, i32 0, i32 4
  %44 = load ptr, ptr %str58, align 8
  %call59 = call i64 @getLongInfoField(ptr noundef %44, ptr noundef @.str.708)
  %shl60 = shl i64 %call59, 2
  %45 = load i64, ptr %aux, align 8
  %or61 = or i64 %45, %shl60
  store i64 %or61, ptr %aux, align 8
  %46 = load i64, ptr %aux, align 8
  switch i64 %46, label %sw.epilog [
    i64 0, label %sw.bb
    i64 1, label %sw.bb62
    i64 2, label %sw.bb64
    i64 3, label %sw.bb66
    i64 4, label %sw.bb68
  ]

sw.bb:                                            ; preds = %cond.end
  br label %sw.epilog

sw.bb62:                                          ; preds = %cond.end
  %call63 = call i32 (ptr, ...) @printf(ptr noundef @.str.709)
  br label %sw.epilog

sw.bb64:                                          ; preds = %cond.end
  %call65 = call i32 (ptr, ...) @printf(ptr noundef @.str.710)
  br label %sw.epilog

sw.bb66:                                          ; preds = %cond.end
  %call67 = call i32 (ptr, ...) @printf(ptr noundef @.str.711)
  br label %sw.epilog

sw.bb68:                                          ; preds = %cond.end
  %call69 = call i32 (ptr, ...) @printf(ptr noundef @.str.712)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb68, %sw.bb66, %sw.bb64, %sw.bb62, %sw.bb, %cond.end
  %call70 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  %47 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %47)
  %48 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %conv = trunc i64 %48 to i32
  %call71 = call i32 @usleep(i32 noundef %conv)
  br label %while.body
}

; Function Attrs: nounwind uwtable
define internal void @scanMode() #0 {
entry:
  %reply = alloca ptr, align 8
  %cur = alloca i64, align 8
  %j = alloca i32, align 4
  %out = alloca ptr, align 8
  store i64 0, ptr %cur, align 8
  %call = call ptr @signal(i32 noundef 2, ptr noundef @longStatLoopModeStop) #15
  br label %do.body

do.body:                                          ; preds = %land.end, %entry
  %call1 = call ptr @sendScan(ptr noundef %cur)
  store ptr %call1, ptr %reply, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %0 = load i32, ptr %j, align 4
  %conv = zext i32 %0 to i64
  %1 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %1, i32 0, i32 7
  %2 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 1
  %3 = load ptr, ptr %arrayidx, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 6
  %4 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %conv, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp3 = icmp eq i32 %5, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %call5 = call ptr @hi_sdsempty()
  %6 = load ptr, ptr %reply, align 8
  %element6 = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 7
  %7 = load ptr, ptr %element6, align 8
  %arrayidx7 = getelementptr inbounds ptr, ptr %7, i64 1
  %8 = load ptr, ptr %arrayidx7, align 8
  %element8 = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 7
  %9 = load ptr, ptr %element8, align 8
  %10 = load i32, ptr %j, align 4
  %idxprom = zext i32 %10 to i64
  %arrayidx9 = getelementptr inbounds ptr, ptr %9, i64 %idxprom
  %11 = load ptr, ptr %arrayidx9, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 4
  %12 = load ptr, ptr %str, align 8
  %13 = load ptr, ptr %reply, align 8
  %element10 = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 7
  %14 = load ptr, ptr %element10, align 8
  %arrayidx11 = getelementptr inbounds ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx11, align 8
  %element12 = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 7
  %16 = load ptr, ptr %element12, align 8
  %17 = load i32, ptr %j, align 4
  %idxprom13 = zext i32 %17 to i64
  %arrayidx14 = getelementptr inbounds ptr, ptr %16, i64 %idxprom13
  %18 = load ptr, ptr %arrayidx14, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 3
  %19 = load i64, ptr %len, align 8
  %call15 = call ptr @hi_sdscatrepr(ptr noundef %call5, ptr noundef %12, i64 noundef %19)
  store ptr %call15, ptr %out, align 8
  %20 = load ptr, ptr %out, align 8
  %call16 = call i32 (ptr, ...) @printf(ptr noundef @.str.115, ptr noundef %20)
  %21 = load ptr, ptr %out, align 8
  call void @hi_sdsfree(ptr noundef %21)
  br label %if.end

if.else:                                          ; preds = %for.body
  %22 = load ptr, ptr %reply, align 8
  %element17 = getelementptr inbounds %struct.redisReply, ptr %22, i32 0, i32 7
  %23 = load ptr, ptr %element17, align 8
  %arrayidx18 = getelementptr inbounds ptr, ptr %23, i64 1
  %24 = load ptr, ptr %arrayidx18, align 8
  %element19 = getelementptr inbounds %struct.redisReply, ptr %24, i32 0, i32 7
  %25 = load ptr, ptr %element19, align 8
  %26 = load i32, ptr %j, align 4
  %idxprom20 = zext i32 %26 to i64
  %arrayidx21 = getelementptr inbounds ptr, ptr %25, i64 %idxprom20
  %27 = load ptr, ptr %arrayidx21, align 8
  %str22 = getelementptr inbounds %struct.redisReply, ptr %27, i32 0, i32 4
  %28 = load ptr, ptr %str22, align 8
  %call23 = call i32 (ptr, ...) @printf(ptr noundef @.str.115, ptr noundef %28)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %29 = load i32, ptr %j, align 4
  %inc = add i32 %29, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !91

for.end:                                          ; preds = %for.cond
  %30 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %30)
  %31 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %tobool = icmp ne i64 %31, 0
  br i1 %tobool, label %if.then24, label %if.end27

if.then24:                                        ; preds = %for.end
  %32 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %conv25 = trunc i64 %32 to i32
  %call26 = call i32 @usleep(i32 noundef %conv25)
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %for.end
  br label %do.cond

do.cond:                                          ; preds = %if.end27
  %33 = load volatile i32, ptr @force_cancel_loop, align 4
  %cmp28 = icmp eq i32 %33, 0
  br i1 %cmp28, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %34 = load i64, ptr %cur, align 8
  %cmp30 = icmp ne i64 %34, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %35 = phi i1 [ false, %do.cond ], [ %cmp30, %land.rhs ]
  br i1 %35, label %do.body, label %do.end, !llvm.loop !92

do.end:                                           ; preds = %land.end
  call void @exit(i32 noundef 0) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal void @LRUTestMode() #0 {
entry:
  %reply = alloca ptr, align 8
  %key = alloca [128 x i8], align 16
  %start_cycle = alloca i64, align 8
  %j = alloca i32, align 4
  %hits = alloca i64, align 8
  %misses = alloca i64, align 8
  %val = alloca [6 x i8], align 1
  %i = alloca i32, align 4
  %call = call i64 @time(ptr noundef null) #15
  %call1 = call i32 @getpid() #15
  %conv = sext i32 %call1 to i64
  %xor = xor i64 %call, %conv
  %conv2 = trunc i64 %xor to i32
  call void @srand(i32 noundef %conv2) #15
  br label %while.body

while.body:                                       ; preds = %while.end, %entry
  %call3 = call i64 @mstime()
  store i64 %call3, ptr %start_cycle, align 8
  store i64 0, ptr %hits, align 8
  store i64 0, ptr %misses, align 8
  br label %while.cond4

while.cond4:                                      ; preds = %if.end57, %while.body
  %call5 = call i64 @mstime()
  %0 = load i64, ptr %start_cycle, align 8
  %sub = sub nsw i64 %call5, %0
  %cmp = icmp slt i64 %sub, 1000
  br i1 %cmp, label %while.body7, label %while.end

while.body7:                                      ; preds = %while.cond4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc20, %while.body7
  %1 = load i32, ptr %j, align 4
  %cmp8 = icmp slt i32 %1, 250
  br i1 %cmp8, label %for.body, label %for.end22

for.body:                                         ; preds = %for.cond
  %arrayidx = getelementptr inbounds [6 x i8], ptr %val, i64 0, i64 5
  store i8 0, ptr %arrayidx, align 1
  store i32 0, ptr %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc, %for.body
  %2 = load i32, ptr %i, align 4
  %cmp11 = icmp slt i32 %2, 5
  br i1 %cmp11, label %for.body13, label %for.end

for.body13:                                       ; preds = %for.cond10
  %call14 = call i32 @rand() #15
  %rem = srem i32 %call14, 57
  %add = add nsw i32 65, %rem
  %conv15 = trunc i32 %add to i8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx16 = getelementptr inbounds [6 x i8], ptr %val, i64 0, i64 %idxprom
  store i8 %conv15, ptr %arrayidx16, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body13
  %4 = load i32, ptr %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond10, !llvm.loop !93

for.end:                                          ; preds = %for.cond10
  %arraydecay = getelementptr inbounds [128 x i8], ptr %key, i64 0, i64 0
  call void @LRUTestGenKey(ptr noundef %arraydecay, i64 noundef 128)
  %5 = load ptr, ptr @context, align 8
  %arraydecay17 = getelementptr inbounds [128 x i8], ptr %key, i64 0, i64 0
  %arraydecay18 = getelementptr inbounds [6 x i8], ptr %val, i64 0, i64 0
  %call19 = call i32 (ptr, ptr, ...) @redisAppendCommand(ptr noundef %5, ptr noundef @.str.715, ptr noundef %arraydecay17, ptr noundef %arraydecay18)
  br label %for.inc20

for.inc20:                                        ; preds = %for.end
  %6 = load i32, ptr %j, align 4
  %inc21 = add nsw i32 %6, 1
  store i32 %inc21, ptr %j, align 4
  br label %for.cond, !llvm.loop !94

for.end22:                                        ; preds = %for.cond
  store i32 0, ptr %j, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc28, %for.end22
  %7 = load i32, ptr %j, align 4
  %cmp24 = icmp slt i32 %7, 250
  br i1 %cmp24, label %for.body26, label %for.end30

for.body26:                                       ; preds = %for.cond23
  %8 = load ptr, ptr @context, align 8
  %call27 = call i32 @redisGetReply(ptr noundef %8, ptr noundef %reply)
  br label %for.inc28

for.inc28:                                        ; preds = %for.body26
  %9 = load i32, ptr %j, align 4
  %inc29 = add nsw i32 %9, 1
  store i32 %inc29, ptr %j, align 4
  br label %for.cond23, !llvm.loop !95

for.end30:                                        ; preds = %for.cond23
  store i32 0, ptr %j, align 4
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc38, %for.end30
  %10 = load i32, ptr %j, align 4
  %cmp32 = icmp slt i32 %10, 250
  br i1 %cmp32, label %for.body34, label %for.end40

for.body34:                                       ; preds = %for.cond31
  %arraydecay35 = getelementptr inbounds [128 x i8], ptr %key, i64 0, i64 0
  call void @LRUTestGenKey(ptr noundef %arraydecay35, i64 noundef 128)
  %11 = load ptr, ptr @context, align 8
  %arraydecay36 = getelementptr inbounds [128 x i8], ptr %key, i64 0, i64 0
  %call37 = call i32 (ptr, ptr, ...) @redisAppendCommand(ptr noundef %11, ptr noundef @.str.716, ptr noundef %arraydecay36)
  br label %for.inc38

for.inc38:                                        ; preds = %for.body34
  %12 = load i32, ptr %j, align 4
  %inc39 = add nsw i32 %12, 1
  store i32 %inc39, ptr %j, align 4
  br label %for.cond31, !llvm.loop !96

for.end40:                                        ; preds = %for.cond31
  store i32 0, ptr %j, align 4
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc52, %for.end40
  %13 = load i32, ptr %j, align 4
  %cmp42 = icmp slt i32 %13, 250
  br i1 %cmp42, label %for.body44, label %for.end54

for.body44:                                       ; preds = %for.cond41
  %14 = load ptr, ptr @context, align 8
  %call45 = call i32 @redisGetReply(ptr noundef %14, ptr noundef %reply)
  %cmp46 = icmp eq i32 %call45, 0
  br i1 %cmp46, label %if.then, label %if.end

if.then:                                          ; preds = %for.body44
  %15 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 0
  %16 = load i32, ptr %type, align 8
  switch i32 %16, label %sw.default [
    i32 6, label %sw.bb
    i32 4, label %sw.bb49
  ]

sw.bb:                                            ; preds = %if.then
  %17 = load ptr, ptr @stderr, align 8
  %18 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 4
  %19 = load ptr, ptr %str, align 8
  %call48 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %17, ptr noundef @.str.115, ptr noundef %19)
  br label %sw.epilog

sw.bb49:                                          ; preds = %if.then
  %20 = load i64, ptr %misses, align 8
  %inc50 = add nsw i64 %20, 1
  store i64 %inc50, ptr %misses, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  %21 = load i64, ptr %hits, align 8
  %inc51 = add nsw i64 %21, 1
  store i64 %inc51, ptr %hits, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb49, %sw.bb
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %for.body44
  br label %for.inc52

for.inc52:                                        ; preds = %if.end
  %22 = load i32, ptr %j, align 4
  %inc53 = add nsw i32 %22, 1
  store i32 %inc53, ptr %j, align 4
  br label %for.cond41, !llvm.loop !97

for.end54:                                        ; preds = %for.cond41
  %23 = load ptr, ptr @context, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %23, i32 0, i32 1
  %24 = load i32, ptr %err, align 8
  %tobool = icmp ne i32 %24, 0
  br i1 %tobool, label %if.then55, label %if.end57

if.then55:                                        ; preds = %for.end54
  %25 = load ptr, ptr @stderr, align 8
  %call56 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %25, ptr noundef @.str.717)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end57:                                         ; preds = %for.end54
  br label %while.cond4, !llvm.loop !98

while.end:                                        ; preds = %while.cond4
  %26 = load i64, ptr %hits, align 8
  %27 = load i64, ptr %misses, align 8
  %add58 = add nsw i64 %26, %27
  %28 = load i64, ptr %hits, align 8
  %29 = load i64, ptr %hits, align 8
  %conv59 = sitofp i64 %29 to double
  %30 = load i64, ptr %hits, align 8
  %31 = load i64, ptr %misses, align 8
  %add60 = add nsw i64 %30, %31
  %conv61 = sitofp i64 %add60 to double
  %div = fdiv double %conv59, %conv61
  %mul = fmul double %div, 1.000000e+02
  %32 = load i64, ptr %misses, align 8
  %33 = load i64, ptr %misses, align 8
  %conv62 = sitofp i64 %33 to double
  %34 = load i64, ptr %hits, align 8
  %35 = load i64, ptr %misses, align 8
  %add63 = add nsw i64 %34, %35
  %conv64 = sitofp i64 %add63 to double
  %div65 = fdiv double %conv62, %conv64
  %mul66 = fmul double %div65, 1.000000e+02
  %call67 = call i32 (ptr, ...) @printf(ptr noundef @.str.718, i64 noundef %add58, i64 noundef %28, double noundef %mul, i64 noundef %32, double noundef %mul66)
  br label %while.body
}

; Function Attrs: nounwind uwtable
define internal void @intrinsicLatencyMode() #0 {
entry:
  %test_end = alloca i64, align 8
  %run_time = alloca i64, align 8
  %max_latency = alloca i64, align 8
  %runs = alloca i64, align 8
  %start = alloca i64, align 8
  %end = alloca i64, align 8
  %latency = alloca i64, align 8
  %avg_us = alloca double, align 8
  %avg_ns = alloca double, align 8
  store i64 0, ptr %max_latency, align 8
  store i64 0, ptr %runs, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 29), align 8
  %conv = sext i32 %0 to i64
  %mul = mul nsw i64 %conv, 1000000
  store i64 %mul, ptr %run_time, align 8
  %call = call i64 @ustime()
  %1 = load i64, ptr %run_time, align 8
  %add = add nsw i64 %call, %1
  store i64 %add, ptr %test_end, align 8
  %call1 = call ptr @signal(i32 noundef 2, ptr noundef @longStatLoopModeStop) #15
  br label %while.body

while.body:                                       ; preds = %if.end21, %if.then, %entry
  %call2 = call i64 @ustime()
  store i64 %call2, ptr %start, align 8
  %call3 = call i64 @compute_something_fast()
  %call4 = call i64 @ustime()
  store i64 %call4, ptr %end, align 8
  %2 = load i64, ptr %end, align 8
  %3 = load i64, ptr %start, align 8
  %sub = sub nsw i64 %2, %3
  store i64 %sub, ptr %latency, align 8
  %4 = load i64, ptr %runs, align 8
  %inc = add nsw i64 %4, 1
  store i64 %inc, ptr %runs, align 8
  %5 = load i64, ptr %latency, align 8
  %cmp = icmp sle i64 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.body

if.end:                                           ; preds = %while.body
  %6 = load i64, ptr %latency, align 8
  %7 = load i64, ptr %max_latency, align 8
  %cmp6 = icmp sgt i64 %6, %7
  br i1 %cmp6, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end
  %8 = load i64, ptr %latency, align 8
  store i64 %8, ptr %max_latency, align 8
  %9 = load i64, ptr %max_latency, align 8
  %call9 = call i32 (ptr, ...) @printf(ptr noundef @.str.719, i64 noundef %9)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end
  %10 = load i64, ptr %run_time, align 8
  %conv11 = sitofp i64 %10 to double
  %11 = load i64, ptr %runs, align 8
  %conv12 = sitofp i64 %11 to double
  %div = fdiv double %conv11, %conv12
  store double %div, ptr %avg_us, align 8
  %12 = load double, ptr %avg_us, align 8
  %mul13 = fmul double %12, 1.000000e+03
  store double %mul13, ptr %avg_ns, align 8
  %13 = load volatile i32, ptr @force_cancel_loop, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end10
  %14 = load i64, ptr %end, align 8
  %15 = load i64, ptr %test_end, align 8
  %cmp14 = icmp sgt i64 %14, %15
  br i1 %cmp14, label %if.then16, label %if.end21

if.then16:                                        ; preds = %lor.lhs.false, %if.end10
  %16 = load i64, ptr %runs, align 8
  %17 = load double, ptr %avg_us, align 8
  %18 = load double, ptr %avg_ns, align 8
  %call17 = call i32 (ptr, ...) @printf(ptr noundef @.str.720, i64 noundef %16, double noundef %17, double noundef %18)
  %19 = load i64, ptr %max_latency, align 8
  %conv18 = sitofp i64 %19 to double
  %20 = load double, ptr %avg_us, align 8
  %div19 = fdiv double %conv18, %20
  %call20 = call i32 (ptr, ...) @printf(ptr noundef @.str.721, double noundef %div19)
  call void @exit(i32 noundef 0) #17
  unreachable

if.end21:                                         ; preds = %lor.lhs.false
  br label %while.body
}

; Function Attrs: nounwind
declare ptr @signal(i32 noundef, ptr noundef) #6

; Function Attrs: nounwind uwtable
define internal void @sigIntHandler(i32 noundef %s) #0 {
entry:
  %s.addr = alloca i32, align 4
  store i32 %s, ptr %s.addr, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 9), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load ptr, ptr @context, align 8
  %fd = getelementptr inbounds %struct.redisContext, ptr %2, i32 0, i32 3
  %3 = load i32, ptr %fd, align 4
  %call = call i32 @close(i32 noundef %3)
  %4 = load ptr, ptr @context, align 8
  %fd2 = getelementptr inbounds %struct.redisContext, ptr %4, i32 0, i32 3
  store i32 -1, ptr %fd2, align 4
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 11), align 4
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @repl() #0 {
entry:
  %historyfile = alloca ptr, align 8
  %history = alloca i32, align 4
  %line = alloca ptr, align 8
  %argc = alloca i32, align 4
  %argv = alloca ptr, align 8
  %repeat = alloca i64, align 8
  %skipargs = alloca i32, align 4
  %endptr = alloca ptr, align 8
  %is_sensitive = alloca i32, align 4
  %start_time = alloca i64, align 8
  %elapsed = alloca i64, align 8
  store ptr null, ptr %historyfile, align 8
  store i32 0, ptr %history, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr @stdin, align 8
  %call = call i32 @fileno(ptr noundef %1) #15
  %call1 = call i32 @isatty(i32 noundef %call) #15
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @cliInitHelp()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 7), align 4
  call void @linenoiseSetMultiLine(i32 noundef 1)
  call void @linenoiseSetCompletionCallback(ptr noundef @completionCallback)
  call void @linenoiseSetHintsCallback(ptr noundef @hintsCallback)
  call void @linenoiseSetFreeHintsCallback(ptr noundef @freeHintsCallback)
  %2 = load ptr, ptr @stdin, align 8
  %call3 = call i32 @fileno(ptr noundef %2) #15
  %call4 = call i32 @isatty(i32 noundef %call3) #15
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end11

if.then6:                                         ; preds = %if.end
  %call7 = call ptr @getDotfilePath(ptr noundef @.str.722, ptr noundef @.str.723)
  store ptr %call7, ptr %historyfile, align 8
  store i32 1, ptr %history, align 4
  %3 = load ptr, ptr %historyfile, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.then6
  %4 = load ptr, ptr %historyfile, align 8
  %call9 = call i32 @linenoiseHistoryLoad(ptr noundef %4)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.then6
  call void @cliLoadPreferences()
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.end
  call void @cliRefreshPrompt()
  br label %while.body

while.body:                                       ; preds = %if.end164, %if.then97, %if.then65, %if.then43, %if.end39, %if.then20, %if.end11
  %5 = load ptr, ptr @context, align 8
  %tobool12 = icmp ne ptr %5, null
  %cond = select i1 %tobool12, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 45), ptr @.str.724
  %call13 = call ptr @linenoise(ptr noundef %cond)
  store ptr %call13, ptr %line, align 8
  %6 = load ptr, ptr %line, align 8
  %cmp14 = icmp eq ptr %6, null
  br i1 %cmp14, label %if.then15, label %if.else

if.then15:                                        ; preds = %while.body
  %7 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool16 = icmp ne i32 %7, 0
  br i1 %tobool16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.then15
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %call18 = call i32 @cliConnect(i32 noundef 1)
  %cmp19 = icmp eq i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.then17
  br label %while.body

if.end21:                                         ; preds = %if.then17
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then15
  br label %while.end

if.else:                                          ; preds = %while.body
  %8 = load ptr, ptr %line, align 8
  %arrayidx = getelementptr inbounds i8, ptr %8, i64 0
  %9 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %9 to i32
  %cmp23 = icmp ne i32 %conv, 0
  br i1 %cmp23, label %if.then25, label %if.end160

if.then25:                                        ; preds = %if.else
  store i64 1, ptr %repeat, align 8
  store i32 0, ptr %skipargs, align 4
  store ptr null, ptr %endptr, align 8
  %10 = load ptr, ptr %line, align 8
  %call26 = call ptr @cliSplitArgs(ptr noundef %10, ptr noundef %argc)
  store ptr %call26, ptr %argv, align 8
  %11 = load ptr, ptr %argv, align 8
  %cmp27 = icmp eq ptr %11, null
  br i1 %cmp27, label %if.then29, label %if.else40

if.then29:                                        ; preds = %if.then25
  %call30 = call i32 (ptr, ...) @printf(ptr noundef @.str.725)
  %12 = load ptr, ptr @stdout, align 8
  %call31 = call i32 @fflush(ptr noundef %12)
  %13 = load i32, ptr %history, align 4
  %tobool32 = icmp ne i32 %13, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %if.then29
  %14 = load ptr, ptr %line, align 8
  %call34 = call i32 @linenoiseHistoryAdd(ptr noundef %14, i32 noundef 0)
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %if.then29
  %15 = load ptr, ptr %historyfile, align 8
  %tobool36 = icmp ne ptr %15, null
  br i1 %tobool36, label %if.then37, label %if.end39

if.then37:                                        ; preds = %if.end35
  %16 = load ptr, ptr %historyfile, align 8
  %call38 = call i32 @linenoiseHistorySave(ptr noundef %16)
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %if.end35
  %17 = load ptr, ptr %line, align 8
  call void @linenoiseFree(ptr noundef %17)
  br label %while.body

if.else40:                                        ; preds = %if.then25
  %18 = load i32, ptr %argc, align 4
  %cmp41 = icmp eq i32 %18, 0
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.else40
  %19 = load ptr, ptr %argv, align 8
  %20 = load i32, ptr %argc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %19, i32 noundef %20)
  %21 = load ptr, ptr %line, align 8
  call void @linenoiseFree(ptr noundef %21)
  br label %while.body

if.end44:                                         ; preds = %if.else40
  br label %if.end45

if.end45:                                         ; preds = %if.end44
  %call46 = call ptr @__errno_location() #16
  store i32 0, ptr %call46, align 4
  %22 = load ptr, ptr %argv, align 8
  %arrayidx47 = getelementptr inbounds ptr, ptr %22, i64 0
  %23 = load ptr, ptr %arrayidx47, align 8
  %call48 = call i64 @strtol(ptr noundef %23, ptr noundef %endptr, i32 noundef 10) #15
  store i64 %call48, ptr %repeat, align 8
  %24 = load i32, ptr %argc, align 4
  %cmp49 = icmp sgt i32 %24, 1
  br i1 %cmp49, label %land.lhs.true51, label %if.else68

land.lhs.true51:                                  ; preds = %if.end45
  %25 = load ptr, ptr %endptr, align 8
  %26 = load i8, ptr %25, align 1
  %conv52 = sext i8 %26 to i32
  %cmp53 = icmp eq i32 %conv52, 0
  br i1 %cmp53, label %if.then55, label %if.else68

if.then55:                                        ; preds = %land.lhs.true51
  %call56 = call ptr @__errno_location() #16
  %27 = load i32, ptr %call56, align 4
  %cmp57 = icmp eq i32 %27, 34
  br i1 %cmp57, label %if.then65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then55
  %call59 = call ptr @__errno_location() #16
  %28 = load i32, ptr %call59, align 4
  %cmp60 = icmp eq i32 %28, 22
  br i1 %cmp60, label %if.then65, label %lor.lhs.false62

lor.lhs.false62:                                  ; preds = %lor.lhs.false
  %29 = load i64, ptr %repeat, align 8
  %cmp63 = icmp sle i64 %29, 0
  br i1 %cmp63, label %if.then65, label %if.end67

if.then65:                                        ; preds = %lor.lhs.false62, %lor.lhs.false, %if.then55
  %30 = load ptr, ptr @stdout, align 8
  %call66 = call i32 @fputs(ptr noundef @.str.726, ptr noundef %30)
  %31 = load ptr, ptr %argv, align 8
  %32 = load i32, ptr %argc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %31, i32 noundef %32)
  %33 = load ptr, ptr %line, align 8
  call void @linenoiseFree(ptr noundef %33)
  br label %while.body

if.end67:                                         ; preds = %lor.lhs.false62
  store i32 1, ptr %skipargs, align 4
  br label %if.end69

if.else68:                                        ; preds = %land.lhs.true51, %if.end45
  store i64 1, ptr %repeat, align 8
  br label %if.end69

if.end69:                                         ; preds = %if.else68, %if.end67
  %34 = load i32, ptr %argc, align 4
  %35 = load i32, ptr %skipargs, align 4
  %sub = sub nsw i32 %34, %35
  %36 = load ptr, ptr %argv, align 8
  %37 = load i32, ptr %skipargs, align 4
  %idx.ext = sext i32 %37 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %36, i64 %idx.ext
  %call70 = call i32 @isSensitiveCommand(i32 noundef %sub, ptr noundef %add.ptr)
  store i32 %call70, ptr %is_sensitive, align 4
  %38 = load i32, ptr %history, align 4
  %tobool71 = icmp ne i32 %38, 0
  br i1 %tobool71, label %if.then72, label %if.end74

if.then72:                                        ; preds = %if.end69
  %39 = load ptr, ptr %line, align 8
  %40 = load i32, ptr %is_sensitive, align 4
  %call73 = call i32 @linenoiseHistoryAdd(ptr noundef %39, i32 noundef %40)
  br label %if.end74

if.end74:                                         ; preds = %if.then72, %if.end69
  %41 = load i32, ptr %is_sensitive, align 4
  %tobool75 = icmp ne i32 %41, 0
  br i1 %tobool75, label %if.end80, label %land.lhs.true76

land.lhs.true76:                                  ; preds = %if.end74
  %42 = load ptr, ptr %historyfile, align 8
  %tobool77 = icmp ne ptr %42, null
  br i1 %tobool77, label %if.then78, label %if.end80

if.then78:                                        ; preds = %land.lhs.true76
  %43 = load ptr, ptr %historyfile, align 8
  %call79 = call i32 @linenoiseHistorySave(ptr noundef %43)
  br label %if.end80

if.end80:                                         ; preds = %if.then78, %land.lhs.true76, %if.end74
  %44 = load ptr, ptr %argv, align 8
  %arrayidx81 = getelementptr inbounds ptr, ptr %44, i64 0
  %45 = load ptr, ptr %arrayidx81, align 8
  %call82 = call i32 @strcasecmp(ptr noundef %45, ptr noundef @.str.727) #12
  %cmp83 = icmp eq i32 %call82, 0
  br i1 %cmp83, label %if.then90, label %lor.lhs.false85

lor.lhs.false85:                                  ; preds = %if.end80
  %46 = load ptr, ptr %argv, align 8
  %arrayidx86 = getelementptr inbounds ptr, ptr %46, i64 0
  %47 = load ptr, ptr %arrayidx86, align 8
  %call87 = call i32 @strcasecmp(ptr noundef %47, ptr noundef @.str.728) #12
  %cmp88 = icmp eq i32 %call87, 0
  br i1 %cmp88, label %if.then90, label %if.else91

if.then90:                                        ; preds = %lor.lhs.false85, %if.end80
  call void @exit(i32 noundef 0) #17
  unreachable

if.else91:                                        ; preds = %lor.lhs.false85
  %48 = load ptr, ptr %argv, align 8
  %arrayidx92 = getelementptr inbounds ptr, ptr %48, i64 0
  %49 = load ptr, ptr %arrayidx92, align 8
  %arrayidx93 = getelementptr inbounds i8, ptr %49, i64 0
  %50 = load i8, ptr %arrayidx93, align 1
  %conv94 = sext i8 %50 to i32
  %cmp95 = icmp eq i32 %conv94, 58
  br i1 %cmp95, label %if.then97, label %if.else98

if.then97:                                        ; preds = %if.else91
  %51 = load ptr, ptr %argv, align 8
  %52 = load i32, ptr %argc, align 4
  call void @cliSetPreferences(ptr noundef %51, i32 noundef %52, i32 noundef 1)
  %53 = load ptr, ptr %argv, align 8
  %54 = load i32, ptr %argc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %53, i32 noundef %54)
  %55 = load ptr, ptr %line, align 8
  call void @linenoiseFree(ptr noundef %55)
  br label %while.body

if.else98:                                        ; preds = %if.else91
  %56 = load ptr, ptr %argv, align 8
  %arrayidx99 = getelementptr inbounds ptr, ptr %56, i64 0
  %57 = load ptr, ptr %arrayidx99, align 8
  %call100 = call i32 @strcasecmp(ptr noundef %57, ptr noundef @.str.729) #12
  %cmp101 = icmp eq i32 %call100, 0
  br i1 %cmp101, label %if.then103, label %if.else110

if.then103:                                       ; preds = %if.else98
  %58 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 46), align 8
  %tobool104 = icmp ne ptr %58, null
  br i1 %tobool104, label %if.then105, label %if.else106

if.then105:                                       ; preds = %if.then103
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %59 = load ptr, ptr %argv, align 8
  %60 = load i32, ptr %argc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %59, i32 noundef %60)
  %61 = load ptr, ptr %line, align 8
  call void @linenoiseFree(ptr noundef %61)
  ret void

if.else106:                                       ; preds = %if.then103
  %call107 = call i32 (ptr, ...) @printf(ptr noundef @.str.730)
  %62 = load ptr, ptr @stdout, align 8
  %call108 = call i32 @fflush(ptr noundef %62)
  br label %if.end109

if.end109:                                        ; preds = %if.else106
  br label %if.end157

if.else110:                                       ; preds = %if.else98
  %63 = load i32, ptr %argc, align 4
  %cmp111 = icmp eq i32 %63, 3
  br i1 %cmp111, label %land.lhs.true113, label %if.else123

land.lhs.true113:                                 ; preds = %if.else110
  %64 = load ptr, ptr %argv, align 8
  %arrayidx114 = getelementptr inbounds ptr, ptr %64, i64 0
  %65 = load ptr, ptr %arrayidx114, align 8
  %call115 = call i32 @strcasecmp(ptr noundef %65, ptr noundef @.str.731) #12
  %tobool116 = icmp ne i32 %call115, 0
  br i1 %tobool116, label %if.else123, label %if.then117

if.then117:                                       ; preds = %land.lhs.true113
  %66 = load ptr, ptr @config, align 8
  call void @hi_sdsfree(ptr noundef %66)
  %67 = load ptr, ptr %argv, align 8
  %arrayidx118 = getelementptr inbounds ptr, ptr %67, i64 1
  %68 = load ptr, ptr %arrayidx118, align 8
  %call119 = call ptr @hi_sdsnew(ptr noundef %68)
  store ptr %call119, ptr @config, align 8
  %69 = load ptr, ptr %argv, align 8
  %arrayidx120 = getelementptr inbounds ptr, ptr %69, i64 2
  %70 = load ptr, ptr %arrayidx120, align 8
  %call121 = call i32 @atoi(ptr noundef %70) #12
  store i32 %call121, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  call void @cliRefreshPrompt()
  %call122 = call i32 @cliConnect(i32 noundef 1)
  br label %if.end156

if.else123:                                       ; preds = %land.lhs.true113, %if.else110
  %71 = load i32, ptr %argc, align 4
  %cmp124 = icmp eq i32 %71, 1
  br i1 %cmp124, label %land.lhs.true126, label %if.else131

land.lhs.true126:                                 ; preds = %if.else123
  %72 = load ptr, ptr %argv, align 8
  %arrayidx127 = getelementptr inbounds ptr, ptr %72, i64 0
  %73 = load ptr, ptr %arrayidx127, align 8
  %call128 = call i32 @strcasecmp(ptr noundef %73, ptr noundef @.str.732) #12
  %tobool129 = icmp ne i32 %call128, 0
  br i1 %tobool129, label %if.else131, label %if.then130

if.then130:                                       ; preds = %land.lhs.true126
  call void @linenoiseClearScreen()
  br label %if.end155

if.else131:                                       ; preds = %land.lhs.true126, %if.else123
  %call132 = call i64 @mstime()
  store i64 %call132, ptr %start_time, align 8
  %74 = load i32, ptr %argc, align 4
  %75 = load i32, ptr %skipargs, align 4
  %sub133 = sub nsw i32 %74, %75
  %76 = load ptr, ptr %argv, align 8
  %77 = load i32, ptr %skipargs, align 4
  %idx.ext134 = sext i32 %77 to i64
  %add.ptr135 = getelementptr inbounds ptr, ptr %76, i64 %idx.ext134
  %78 = load i64, ptr %repeat, align 8
  %call136 = call i32 @issueCommandRepeat(i32 noundef %sub133, ptr noundef %add.ptr135, i64 noundef %78)
  %79 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 49), align 8
  %tobool137 = icmp ne i32 %79, 0
  br i1 %tobool137, label %if.then138, label %if.end143

if.then138:                                       ; preds = %if.else131
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 49), align 8
  %call139 = call i32 @cliReadReply(i32 noundef 0)
  %80 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 48), align 4
  %tobool140 = icmp ne i32 %80, 0
  %cond141 = select i1 %tobool140, ptr @.str.26, ptr @.str.734
  %call142 = call i32 (ptr, ...) @printf(ptr noundef @.str.733, ptr noundef %cond141)
  call void @cliInitHelp()
  br label %if.end143

if.end143:                                        ; preds = %if.then138, %if.else131
  %call144 = call i64 @mstime()
  %81 = load i64, ptr %start_time, align 8
  %sub145 = sub nsw i64 %call144, %81
  store i64 %sub145, ptr %elapsed, align 8
  %82 = load i64, ptr %elapsed, align 8
  %cmp146 = icmp sge i64 %82, 500
  br i1 %cmp146, label %land.lhs.true148, label %if.end154

land.lhs.true148:                                 ; preds = %if.end143
  %83 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp149 = icmp eq i32 %83, 0
  br i1 %cmp149, label %if.then151, label %if.end154

if.then151:                                       ; preds = %land.lhs.true148
  %84 = load i64, ptr %elapsed, align 8
  %conv152 = sitofp i64 %84 to double
  %div = fdiv double %conv152, 1.000000e+03
  %call153 = call i32 (ptr, ...) @printf(ptr noundef @.str.735, double noundef %div)
  br label %if.end154

if.end154:                                        ; preds = %if.then151, %land.lhs.true148, %if.end143
  br label %if.end155

if.end155:                                        ; preds = %if.end154, %if.then130
  br label %if.end156

if.end156:                                        ; preds = %if.end155, %if.then117
  br label %if.end157

if.end157:                                        ; preds = %if.end156, %if.end109
  br label %if.end158

if.end158:                                        ; preds = %if.end157
  br label %if.end159

if.end159:                                        ; preds = %if.end158
  %85 = load ptr, ptr %argv, align 8
  %86 = load i32, ptr %argc, align 4
  call void @hi_sdsfreesplitres(ptr noundef %85, i32 noundef %86)
  br label %if.end160

if.end160:                                        ; preds = %if.end159, %if.else
  br label %if.end161

if.end161:                                        ; preds = %if.end160
  %87 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool162 = icmp ne i32 %87, 0
  br i1 %tobool162, label %if.then163, label %if.end164

if.then163:                                       ; preds = %if.end161
  call void @cliWaitForMessagesOrStdin()
  br label %if.end164

if.end164:                                        ; preds = %if.then163, %if.end161
  %88 = load ptr, ptr %line, align 8
  call void @linenoiseFree(ptr noundef %88)
  br label %while.body

while.end:                                        ; preds = %if.end22
  call void @exit(i32 noundef 0) #17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @evalMode(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %script = alloca ptr, align 8
  %fp = alloca ptr, align 8
  %buf = alloca [1024 x i8], align 16
  %nread = alloca i64, align 8
  %argv2 = alloca ptr, align 8
  %j = alloca i32, align 4
  %got_comma = alloca i32, align 4
  %keys = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %reply = alloca ptr, align 8
  %eval_ldb = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store ptr null, ptr %script, align 8
  store i32 0, ptr %retval1, align 4
  br label %while.body

while.body:                                       ; preds = %if.end71, %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.802)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %1 = load ptr, ptr %script, align 8
  call void @hi_sdsfree(ptr noundef %1)
  %call2 = call ptr @hi_sdsempty()
  store ptr %call2, ptr %script, align 8
  store i32 0, ptr %got_comma, align 4
  store i32 0, ptr %keys, align 4
  %2 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 46), align 8
  %call3 = call noalias ptr @fopen64(ptr noundef %2, ptr noundef @.str.31)
  store ptr %call3, ptr %fp, align 8
  %3 = load ptr, ptr %fp, align 8
  %tobool4 = icmp ne ptr %3, null
  br i1 %tobool4, label %if.end9, label %if.then5

if.then5:                                         ; preds = %if.end
  %4 = load ptr, ptr @stderr, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 46), align 8
  %call6 = call ptr @__errno_location() #16
  %6 = load i32, ptr %call6, align 4
  %call7 = call ptr @strerror(i32 noundef %6) #15
  %call8 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %4, ptr noundef @.str.117, ptr noundef %5, ptr noundef %call7)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end9:                                          ; preds = %if.end
  br label %while.cond10

while.cond10:                                     ; preds = %while.body12, %if.end9
  %arraydecay = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %7 = load ptr, ptr %fp, align 8
  %call11 = call i64 @fread(ptr noundef %arraydecay, i64 noundef 1, i64 noundef 1024, ptr noundef %7)
  store i64 %call11, ptr %nread, align 8
  %cmp = icmp ne i64 %call11, 0
  br i1 %cmp, label %while.body12, label %while.end

while.body12:                                     ; preds = %while.cond10
  %8 = load ptr, ptr %script, align 8
  %arraydecay13 = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %9 = load i64, ptr %nread, align 8
  %call14 = call ptr @hi_sdscatlen(ptr noundef %8, ptr noundef %arraydecay13, i64 noundef %9)
  store ptr %call14, ptr %script, align 8
  br label %while.cond10, !llvm.loop !99

while.end:                                        ; preds = %while.cond10
  %10 = load ptr, ptr %fp, align 8
  %call15 = call i32 @fclose(ptr noundef %10)
  %11 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool16 = icmp ne i32 %11, 0
  br i1 %tobool16, label %if.then17, label %if.end23

if.then17:                                        ; preds = %while.end
  %12 = load ptr, ptr @context, align 8
  %13 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 48), align 4
  %tobool18 = icmp ne i32 %13, 0
  %cond = select i1 %tobool18, ptr @.str.803, ptr @.str.804
  %call19 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %12, ptr noundef %cond)
  store ptr %call19, ptr %reply, align 8
  %14 = load ptr, ptr %reply, align 8
  %tobool20 = icmp ne ptr %14, null
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.then17
  %15 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %15)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.then17
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %while.end
  %16 = load i32, ptr %argc.addr, align 4
  %add = add nsw i32 %16, 3
  %conv = sext i32 %add to i64
  %mul = mul i64 8, %conv
  %call24 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call24, ptr %argv2, align 8
  %call25 = call ptr @hi_sdsnew(ptr noundef @.str.805)
  %17 = load ptr, ptr %argv2, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %17, i64 0
  store ptr %call25, ptr %arrayidx, align 8
  %18 = load ptr, ptr %script, align 8
  %19 = load ptr, ptr %argv2, align 8
  %arrayidx26 = getelementptr inbounds ptr, ptr %19, i64 1
  store ptr %18, ptr %arrayidx26, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end23
  %20 = load i32, ptr %j, align 4
  %21 = load i32, ptr %argc.addr, align 4
  %cmp27 = icmp slt i32 %20, %21
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load i32, ptr %got_comma, align 4
  %tobool29 = icmp ne i32 %22, 0
  br i1 %tobool29, label %if.end43, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %23 = load ptr, ptr %argv.addr, align 8
  %24 = load i32, ptr %j, align 4
  %idxprom = sext i32 %24 to i64
  %arrayidx30 = getelementptr inbounds ptr, ptr %23, i64 %idxprom
  %25 = load ptr, ptr %arrayidx30, align 8
  %arrayidx31 = getelementptr inbounds i8, ptr %25, i64 0
  %26 = load i8, ptr %arrayidx31, align 1
  %conv32 = sext i8 %26 to i32
  %cmp33 = icmp eq i32 %conv32, 44
  br i1 %cmp33, label %land.lhs.true35, label %if.end43

land.lhs.true35:                                  ; preds = %land.lhs.true
  %27 = load ptr, ptr %argv.addr, align 8
  %28 = load i32, ptr %j, align 4
  %idxprom36 = sext i32 %28 to i64
  %arrayidx37 = getelementptr inbounds ptr, ptr %27, i64 %idxprom36
  %29 = load ptr, ptr %arrayidx37, align 8
  %arrayidx38 = getelementptr inbounds i8, ptr %29, i64 1
  %30 = load i8, ptr %arrayidx38, align 1
  %conv39 = sext i8 %30 to i32
  %cmp40 = icmp eq i32 %conv39, 0
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %land.lhs.true35
  store i32 1, ptr %got_comma, align 4
  br label %for.inc

if.end43:                                         ; preds = %land.lhs.true35, %land.lhs.true, %for.body
  %31 = load ptr, ptr %argv.addr, align 8
  %32 = load i32, ptr %j, align 4
  %idxprom44 = sext i32 %32 to i64
  %arrayidx45 = getelementptr inbounds ptr, ptr %31, i64 %idxprom44
  %33 = load ptr, ptr %arrayidx45, align 8
  %call46 = call ptr @hi_sdsnew(ptr noundef %33)
  %34 = load ptr, ptr %argv2, align 8
  %35 = load i32, ptr %j, align 4
  %add47 = add nsw i32 %35, 3
  %36 = load i32, ptr %got_comma, align 4
  %sub = sub nsw i32 %add47, %36
  %idxprom48 = sext i32 %sub to i64
  %arrayidx49 = getelementptr inbounds ptr, ptr %34, i64 %idxprom48
  store ptr %call46, ptr %arrayidx49, align 8
  %37 = load i32, ptr %got_comma, align 4
  %tobool50 = icmp ne i32 %37, 0
  br i1 %tobool50, label %if.end52, label %if.then51

if.then51:                                        ; preds = %if.end43
  %38 = load i32, ptr %keys, align 4
  %inc = add nsw i32 %38, 1
  store i32 %inc, ptr %keys, align 4
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %if.end43
  br label %for.inc

for.inc:                                          ; preds = %if.end52, %if.then42
  %39 = load i32, ptr %j, align 4
  %inc53 = add nsw i32 %39, 1
  store i32 %inc53, ptr %j, align 4
  br label %for.cond, !llvm.loop !100

for.end:                                          ; preds = %for.cond
  %call54 = call ptr @hi_sdsempty()
  %40 = load i32, ptr %keys, align 4
  %call55 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %call54, ptr noundef @.str.303, i32 noundef %40)
  %41 = load ptr, ptr %argv2, align 8
  %arrayidx56 = getelementptr inbounds ptr, ptr %41, i64 2
  store ptr %call55, ptr %arrayidx56, align 8
  %42 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  store i32 %42, ptr %eval_ldb, align 4
  %43 = load i32, ptr %argc.addr, align 4
  %add57 = add nsw i32 %43, 3
  %44 = load i32, ptr %got_comma, align 4
  %sub58 = sub nsw i32 %add57, %44
  %45 = load ptr, ptr %argv2, align 8
  %call59 = call i32 @issueCommand(i32 noundef %sub58, ptr noundef %45)
  store i32 %call59, ptr %retval1, align 4
  %46 = load i32, ptr %eval_ldb, align 4
  %tobool60 = icmp ne i32 %46, 0
  br i1 %tobool60, label %if.then61, label %if.else70

if.then61:                                        ; preds = %for.end
  %47 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool62 = icmp ne i32 %47, 0
  br i1 %tobool62, label %if.else, label %if.then63

if.then63:                                        ; preds = %if.then61
  %call64 = call i32 (ptr, ...) @printf(ptr noundef @.str.806)
  %call65 = call i32 @cliReadReply(i32 noundef 0)
  br label %while.end72

if.else:                                          ; preds = %if.then61
  %call66 = call ptr @strncpy(ptr noundef getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 45), ptr noundef @.str.807, i64 noundef 128) #15
  call void @repl()
  %call67 = call i32 @cliConnect(i32 noundef 1)
  %call68 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  br label %if.end69

if.end69:                                         ; preds = %if.else
  br label %if.end71

if.else70:                                        ; preds = %for.end
  br label %while.end72

if.end71:                                         ; preds = %if.end69
  br label %while.body

while.end72:                                      ; preds = %if.else70, %if.then63
  %48 = load i32, ptr %retval1, align 4
  %cmp73 = icmp eq i32 %48, 0
  %cond75 = select i1 %cmp73, i32 0, i32 1
  ret i32 %cond75
}

; Function Attrs: nounwind uwtable
define internal i32 @noninteractive(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %retval1 = alloca i32, align 4
  %sds_args = alloca ptr, align 8
  %i = alloca i32, align 4
  %tag_match = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 0, ptr %retval1, align 4
  %0 = load i32, ptr %argc.addr, align 4
  %1 = load ptr, ptr %argv.addr, align 8
  %2 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 40), align 4
  %call = call ptr @getSdsArrayFromArgv(i32 noundef %0, ptr noundef %1, i32 noundef %2)
  store ptr %call, ptr %sds_args, align 8
  %3 = load ptr, ptr %sds_args, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call2 = call i32 (ptr, ...) @printf(ptr noundef @.str.808)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 36), align 8
  %tobool3 = icmp ne i32 %4, 0
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %5 = load ptr, ptr %sds_args, align 8
  %6 = load i32, ptr %argc.addr, align 4
  %add = add nsw i32 %6, 1
  %conv = sext i32 %add to i64
  %mul = mul i64 %conv, 8
  %call5 = call ptr @hi_sds_realloc(ptr noundef %5, i64 noundef %mul)
  store ptr %call5, ptr %sds_args, align 8
  %call6 = call ptr @readArgFromStdin()
  %7 = load ptr, ptr %sds_args, align 8
  %8 = load i32, ptr %argc.addr, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 %idxprom
  store ptr %call6, ptr %arrayidx, align 8
  %9 = load i32, ptr %argc.addr, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %argc.addr, align 4
  br label %if.end28

if.else:                                          ; preds = %if.end
  %10 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 37), align 4
  %tobool7 = icmp ne i32 %10, 0
  br i1 %tobool7, label %if.then8, label %if.end27

if.then8:                                         ; preds = %if.else
  store i32 0, ptr %i, align 4
  store i32 0, ptr %tag_match, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then8
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %argc.addr, align 4
  %cmp = icmp slt i32 %11, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 38), align 8
  %14 = load ptr, ptr %sds_args, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom10 = sext i32 %15 to i64
  %arrayidx11 = getelementptr inbounds ptr, ptr %14, i64 %idxprom10
  %16 = load ptr, ptr %arrayidx11, align 8
  %call12 = call i32 @strcmp(ptr noundef %13, ptr noundef %16) #12
  %cmp13 = icmp ne i32 %call12, 0
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body
  br label %for.inc

if.end16:                                         ; preds = %for.body
  store i32 1, ptr %tag_match, align 4
  %17 = load ptr, ptr %sds_args, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom17 = sext i32 %18 to i64
  %arrayidx18 = getelementptr inbounds ptr, ptr %17, i64 %idxprom17
  %19 = load ptr, ptr %arrayidx18, align 8
  call void @hi_sdsfree(ptr noundef %19)
  %call19 = call ptr @readArgFromStdin()
  %20 = load ptr, ptr %sds_args, align 8
  %21 = load i32, ptr %i, align 4
  %idxprom20 = sext i32 %21 to i64
  %arrayidx21 = getelementptr inbounds ptr, ptr %20, i64 %idxprom20
  store ptr %call19, ptr %arrayidx21, align 8
  br label %for.end

for.inc:                                          ; preds = %if.then15
  %22 = load i32, ptr %i, align 4
  %inc22 = add nsw i32 %22, 1
  store i32 %inc22, ptr %i, align 4
  br label %for.cond, !llvm.loop !101

for.end:                                          ; preds = %if.end16, %for.cond
  %23 = load i32, ptr %tag_match, align 4
  %tobool23 = icmp ne i32 %23, 0
  br i1 %tobool23, label %if.end26, label %if.then24

if.then24:                                        ; preds = %for.end
  %24 = load ptr, ptr %sds_args, align 8
  %25 = load i32, ptr %argc.addr, align 4
  call void @hi_sdsfreesplitres(ptr noundef %24, i32 noundef %25)
  %26 = load ptr, ptr @stderr, align 8
  %call25 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %26, ptr noundef @.str.568)
  store i32 1, ptr %retval, align 4
  br label %return

if.end26:                                         ; preds = %for.end
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.else
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then4
  %27 = load i32, ptr %argc.addr, align 4
  %28 = load ptr, ptr %sds_args, align 8
  %call29 = call i32 @issueCommand(i32 noundef %27, ptr noundef %28)
  store i32 %call29, ptr %retval1, align 4
  %29 = load ptr, ptr %sds_args, align 8
  %30 = load i32, ptr %argc.addr, align 4
  call void @hi_sdsfreesplitres(ptr noundef %29, i32 noundef %30)
  br label %while.cond

while.cond:                                       ; preds = %if.end35, %if.end28
  %31 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool30 = icmp ne i32 %31, 0
  br i1 %tobool30, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call31 = call i32 @cliReadReply(i32 noundef 0)
  %cmp32 = icmp ne i32 %call31, 0
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %while.body
  call void @cliPrintContextError()
  call void @exit(i32 noundef 1) #17
  unreachable

if.end35:                                         ; preds = %while.body
  %32 = load ptr, ptr @stdout, align 8
  %call36 = call i32 @fflush(ptr noundef %32)
  br label %while.cond, !llvm.loop !102

while.end:                                        ; preds = %while.cond
  %33 = load i32, ptr %retval1, align 4
  %cmp37 = icmp eq i32 %33, 0
  %cond = select i1 %cmp37, i32 0, i32 1
  store i32 %cond, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then24, %if.then
  %34 = load i32, ptr %retval, align 4
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define internal void @cliFillInCommandHelpEntry(ptr noundef %help, ptr noundef %cmdname, ptr noundef %subcommandname) #0 {
entry:
  %help.addr = alloca ptr, align 8
  %cmdname.addr = alloca ptr, align 8
  %subcommandname.addr = alloca ptr, align 8
  %pipe = alloca ptr, align 8
  %fullname = alloca ptr, align 8
  store ptr %help, ptr %help.addr, align 8
  store ptr %cmdname, ptr %cmdname.addr, align 8
  store ptr %subcommandname, ptr %subcommandname.addr, align 8
  %0 = load ptr, ptr %subcommandname.addr, align 8
  %tobool = icmp ne ptr %0, null
  %cond = select i1 %tobool, i32 2, i32 1
  %1 = load ptr, ptr %help.addr, align 8
  %argc = getelementptr inbounds %struct.helpEntry, ptr %1, i32 0, i32 1
  store i32 %cond, ptr %argc, align 4
  %2 = load ptr, ptr %help.addr, align 8
  %argc1 = getelementptr inbounds %struct.helpEntry, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %argc1, align 4
  %conv = sext i32 %3 to i64
  %mul = mul i64 8, %conv
  %call = call noalias ptr @zmalloc(i64 noundef %mul) #14
  %4 = load ptr, ptr %help.addr, align 8
  %argv = getelementptr inbounds %struct.helpEntry, ptr %4, i32 0, i32 2
  store ptr %call, ptr %argv, align 8
  %5 = load ptr, ptr %cmdname.addr, align 8
  %call2 = call ptr @hi_sdsnew(ptr noundef %5)
  %6 = load ptr, ptr %help.addr, align 8
  %argv3 = getelementptr inbounds %struct.helpEntry, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %argv3, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 0
  store ptr %call2, ptr %arrayidx, align 8
  %8 = load ptr, ptr %help.addr, align 8
  %argv4 = getelementptr inbounds %struct.helpEntry, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %argv4, align 8
  %arrayidx5 = getelementptr inbounds ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx5, align 8
  call void @hi_sdstoupper(ptr noundef %10)
  %11 = load ptr, ptr %subcommandname.addr, align 8
  %tobool6 = icmp ne ptr %11, null
  br i1 %tobool6, label %if.then, label %if.end18

if.then:                                          ; preds = %entry
  %12 = load ptr, ptr %subcommandname.addr, align 8
  %call7 = call ptr @strchr(ptr noundef %12, i32 noundef 124) #12
  store ptr %call7, ptr %pipe, align 8
  %13 = load ptr, ptr %pipe, align 8
  %cmp = icmp ne ptr %13, null
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then
  %14 = load ptr, ptr %pipe, align 8
  %add.ptr = getelementptr inbounds i8, ptr %14, i64 1
  %call10 = call ptr @hi_sdsnew(ptr noundef %add.ptr)
  %15 = load ptr, ptr %help.addr, align 8
  %argv11 = getelementptr inbounds %struct.helpEntry, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %argv11, align 8
  %arrayidx12 = getelementptr inbounds ptr, ptr %16, i64 1
  store ptr %call10, ptr %arrayidx12, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %17 = load ptr, ptr %subcommandname.addr, align 8
  %call13 = call ptr @hi_sdsnew(ptr noundef %17)
  %18 = load ptr, ptr %help.addr, align 8
  %argv14 = getelementptr inbounds %struct.helpEntry, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %argv14, align 8
  %arrayidx15 = getelementptr inbounds ptr, ptr %19, i64 1
  store ptr %call13, ptr %arrayidx15, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then9
  %20 = load ptr, ptr %help.addr, align 8
  %argv16 = getelementptr inbounds %struct.helpEntry, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %argv16, align 8
  %arrayidx17 = getelementptr inbounds ptr, ptr %21, i64 1
  %22 = load ptr, ptr %arrayidx17, align 8
  call void @hi_sdstoupper(ptr noundef %22)
  br label %if.end18

if.end18:                                         ; preds = %if.end, %entry
  %23 = load ptr, ptr %help.addr, align 8
  %argv19 = getelementptr inbounds %struct.helpEntry, ptr %23, i32 0, i32 2
  %24 = load ptr, ptr %argv19, align 8
  %arrayidx20 = getelementptr inbounds ptr, ptr %24, i64 0
  %25 = load ptr, ptr %arrayidx20, align 8
  %call21 = call ptr @hi_sdsnew(ptr noundef %25)
  store ptr %call21, ptr %fullname, align 8
  %26 = load ptr, ptr %subcommandname.addr, align 8
  %tobool22 = icmp ne ptr %26, null
  br i1 %tobool22, label %if.then23, label %if.end28

if.then23:                                        ; preds = %if.end18
  %27 = load ptr, ptr %fullname, align 8
  %call24 = call ptr @hi_sdscat(ptr noundef %27, ptr noundef @.str.136)
  store ptr %call24, ptr %fullname, align 8
  %28 = load ptr, ptr %fullname, align 8
  %29 = load ptr, ptr %help.addr, align 8
  %argv25 = getelementptr inbounds %struct.helpEntry, ptr %29, i32 0, i32 2
  %30 = load ptr, ptr %argv25, align 8
  %arrayidx26 = getelementptr inbounds ptr, ptr %30, i64 1
  %31 = load ptr, ptr %arrayidx26, align 8
  %call27 = call ptr @hi_sdscat(ptr noundef %28, ptr noundef %31)
  store ptr %call27, ptr %fullname, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then23, %if.end18
  %32 = load ptr, ptr %fullname, align 8
  %33 = load ptr, ptr %help.addr, align 8
  %full = getelementptr inbounds %struct.helpEntry, ptr %33, i32 0, i32 3
  store ptr %32, ptr %full, align 8
  %34 = load ptr, ptr %help.addr, align 8
  %type = getelementptr inbounds %struct.helpEntry, ptr %34, i32 0, i32 0
  store i32 1, ptr %type, align 8
  %35 = load ptr, ptr %help.addr, align 8
  %full29 = getelementptr inbounds %struct.helpEntry, ptr %35, i32 0, i32 3
  %36 = load ptr, ptr %full29, align 8
  %37 = load ptr, ptr %help.addr, align 8
  %docs = getelementptr inbounds %struct.helpEntry, ptr %37, i32 0, i32 4
  %name = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 0
  store ptr %36, ptr %name, align 8
  %38 = load ptr, ptr %help.addr, align 8
  %docs30 = getelementptr inbounds %struct.helpEntry, ptr %38, i32 0, i32 4
  %params = getelementptr inbounds %struct.commandDocs, ptr %docs30, i32 0, i32 7
  store ptr null, ptr %params, align 8
  %39 = load ptr, ptr %help.addr, align 8
  %docs31 = getelementptr inbounds %struct.helpEntry, ptr %39, i32 0, i32 4
  %args = getelementptr inbounds %struct.commandDocs, ptr %docs31, i32 0, i32 5
  store ptr null, ptr %args, align 8
  %40 = load ptr, ptr %help.addr, align 8
  %docs32 = getelementptr inbounds %struct.helpEntry, ptr %40, i32 0, i32 4
  %numargs = getelementptr inbounds %struct.commandDocs, ptr %docs32, i32 0, i32 4
  store i32 0, ptr %numargs, align 8
  %41 = load ptr, ptr %help.addr, align 8
  %docs33 = getelementptr inbounds %struct.helpEntry, ptr %41, i32 0, i32 4
  %since = getelementptr inbounds %struct.commandDocs, ptr %docs33, i32 0, i32 3
  store ptr null, ptr %since, align 8
  ret void
}

declare ptr @hi_sdsdup(ptr noundef) #2

declare i32 @dictAdd(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: allocsize(0)
declare noalias ptr @zcalloc(i64 noundef) #4

; Function Attrs: nounwind uwtable
define internal void @cliMakeCommandDocArgs(ptr noundef %arguments, ptr noundef %result) #0 {
entry:
  %arguments.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %j = alloca i64, align 8
  store ptr %arguments, ptr %arguments.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i64 0, ptr %j, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %j, align 8
  %1 = load ptr, ptr %arguments.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %1, i32 0, i32 6
  %2 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %result.addr, align 8
  %4 = load i64, ptr %j, align 8
  %arrayidx = getelementptr inbounds %struct.cliCommandArg, ptr %3, i64 %4
  %5 = load ptr, ptr %arguments.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 7
  %6 = load ptr, ptr %element, align 8
  %7 = load i64, ptr %j, align 8
  %arrayidx1 = getelementptr inbounds ptr, ptr %6, i64 %7
  %8 = load ptr, ptr %arrayidx1, align 8
  call void @cliAddCommandDocArg(ptr noundef %arrayidx, ptr noundef %8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, ptr %j, align 8
  %inc = add i64 %9, 1
  store i64 %inc, ptr %j, align 8
  br label %for.cond, !llvm.loop !103

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @makeHint(ptr noundef %inputargv, i32 noundef %inputargc, i32 noundef %cmdlen, ptr noundef byval(%struct.commandDocs) align 8 %docs) #0 {
entry:
  %retval = alloca ptr, align 8
  %inputargv.addr = alloca ptr, align 8
  %inputargc.addr = alloca i32, align 4
  %cmdlen.addr = alloca i32, align 4
  %hint = alloca ptr, align 8
  %matchedWords = alloca i32, align 4
  store ptr %inputargv, ptr %inputargv.addr, align 8
  store i32 %inputargc, ptr %inputargc.addr, align 4
  store i32 %cmdlen, ptr %cmdlen.addr, align 4
  %args = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 5
  %0 = load ptr, ptr %args, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %args1 = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 5
  %1 = load ptr, ptr %args1, align 8
  %numargs = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 4
  %2 = load i32, ptr %numargs, align 8
  call void @clearMatchedArgs(ptr noundef %1, i32 noundef %2)
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %hint, align 8
  store i32 0, ptr %matchedWords, align 4
  %3 = load ptr, ptr %inputargv.addr, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %4 = load i32, ptr %inputargc.addr, align 4
  %tobool3 = icmp ne i32 %4, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %land.lhs.true
  %5 = load ptr, ptr %inputargv.addr, align 8
  %6 = load i32, ptr %cmdlen.addr, align 4
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %5, i64 %idx.ext
  %7 = load i32, ptr %inputargc.addr, align 4
  %8 = load i32, ptr %cmdlen.addr, align 4
  %sub = sub nsw i32 %7, %8
  %args5 = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 5
  %9 = load ptr, ptr %args5, align 8
  %numargs6 = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 4
  %10 = load i32, ptr %numargs6, align 8
  %call7 = call i32 @matchArgs(ptr noundef %add.ptr, i32 noundef %sub, ptr noundef %9, i32 noundef %10)
  store i32 %call7, ptr %matchedWords, align 4
  br label %if.end

if.end:                                           ; preds = %if.then4, %land.lhs.true, %if.then
  %11 = load i32, ptr %matchedWords, align 4
  %12 = load i32, ptr %inputargc.addr, align 4
  %13 = load i32, ptr %cmdlen.addr, align 4
  %sub8 = sub nsw i32 %12, %13
  %cmp = icmp eq i32 %11, %sub8
  br i1 %cmp, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end
  %14 = load ptr, ptr %hint, align 8
  %args10 = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 5
  %15 = load ptr, ptr %args10, align 8
  %numargs11 = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 4
  %16 = load i32, ptr %numargs11, align 8
  %call12 = call ptr @addHintForArguments(ptr noundef %14, ptr noundef %15, i32 noundef %16, ptr noundef @.str.136)
  store ptr %call12, ptr %hint, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then9, %if.end
  %17 = load ptr, ptr %hint, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %entry
  %18 = load i32, ptr %inputargc.addr, align 4
  %19 = load i32, ptr %cmdlen.addr, align 4
  %cmp15 = icmp sle i32 %18, %19
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end14
  %params = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 7
  %20 = load ptr, ptr %params, align 8
  %call17 = call ptr @hi_sdsnew(ptr noundef %20)
  store ptr %call17, ptr %hint, align 8
  br label %if.end19

if.else:                                          ; preds = %if.end14
  %call18 = call ptr @hi_sdsempty()
  store ptr %call18, ptr %hint, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then16
  %21 = load ptr, ptr %hint, align 8
  store ptr %21, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.end13
  %22 = load ptr, ptr %retval, align 8
  ret ptr %22
}

declare void @hi_sdstoupper(ptr noundef) #2

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strchr(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @cliAddCommandDocArg(ptr noundef %cmdArg, ptr noundef %argMap) #0 {
entry:
  %cmdArg.addr = alloca ptr, align 8
  %argMap.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %key = alloca ptr, align 8
  %type30 = alloca ptr, align 8
  %arguments = alloca ptr, align 8
  %flags = alloca ptr, align 8
  %j = alloca i64, align 8
  %flag = alloca ptr, align 8
  store ptr %cmdArg, ptr %cmdArg.addr, align 8
  store ptr %argMap, ptr %argMap.addr, align 8
  %0 = load ptr, ptr %argMap.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  %cmp = icmp ne i32 %1, 9
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %argMap.addr, align 8
  %type1 = getelementptr inbounds %struct.redisReply, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %type1, align 8
  %cmp2 = icmp ne i32 %3, 2
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %for.end141

if.end:                                           ; preds = %land.lhs.true, %entry
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc139, %if.end
  %4 = load i64, ptr %i, align 8
  %5 = load ptr, ptr %argMap.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %elements, align 8
  %cmp3 = icmp ult i64 %4, %6
  br i1 %cmp3, label %for.body, label %for.end141

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %argMap.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 7
  %8 = load ptr, ptr %element, align 8
  %9 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %8, i64 %9
  %10 = load ptr, ptr %arrayidx, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %str, align 8
  store ptr %11, ptr %key, align 8
  %12 = load ptr, ptr %key, align 8
  %call = call i32 @strcmp(ptr noundef %12, ptr noundef @.str.137) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then4

if.then4:                                         ; preds = %for.body
  %13 = load ptr, ptr %argMap.addr, align 8
  %element5 = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 7
  %14 = load ptr, ptr %element5, align 8
  %15 = load i64, ptr %i, align 8
  %add = add i64 %15, 1
  %arrayidx6 = getelementptr inbounds ptr, ptr %14, i64 %add
  %16 = load ptr, ptr %arrayidx6, align 8
  %str7 = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 4
  %17 = load ptr, ptr %str7, align 8
  %call8 = call ptr @hi_sdsnew(ptr noundef %17)
  %18 = load ptr, ptr %cmdArg.addr, align 8
  %name = getelementptr inbounds %struct.cliCommandArg, ptr %18, i32 0, i32 0
  store ptr %call8, ptr %name, align 8
  br label %if.end138

if.else:                                          ; preds = %for.body
  %19 = load ptr, ptr %key, align 8
  %call9 = call i32 @strcmp(ptr noundef %19, ptr noundef @.str.138) #12
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.else17, label %if.then11

if.then11:                                        ; preds = %if.else
  %20 = load ptr, ptr %argMap.addr, align 8
  %element12 = getelementptr inbounds %struct.redisReply, ptr %20, i32 0, i32 7
  %21 = load ptr, ptr %element12, align 8
  %22 = load i64, ptr %i, align 8
  %add13 = add i64 %22, 1
  %arrayidx14 = getelementptr inbounds ptr, ptr %21, i64 %add13
  %23 = load ptr, ptr %arrayidx14, align 8
  %str15 = getelementptr inbounds %struct.redisReply, ptr %23, i32 0, i32 4
  %24 = load ptr, ptr %str15, align 8
  %call16 = call ptr @hi_sdsnew(ptr noundef %24)
  %25 = load ptr, ptr %cmdArg.addr, align 8
  %display_text = getelementptr inbounds %struct.cliCommandArg, ptr %25, i32 0, i32 7
  store ptr %call16, ptr %display_text, align 8
  br label %if.end137

if.else17:                                        ; preds = %if.else
  %26 = load ptr, ptr %key, align 8
  %call18 = call i32 @strcmp(ptr noundef %26, ptr noundef @.str.139) #12
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.else26, label %if.then20

if.then20:                                        ; preds = %if.else17
  %27 = load ptr, ptr %argMap.addr, align 8
  %element21 = getelementptr inbounds %struct.redisReply, ptr %27, i32 0, i32 7
  %28 = load ptr, ptr %element21, align 8
  %29 = load i64, ptr %i, align 8
  %add22 = add i64 %29, 1
  %arrayidx23 = getelementptr inbounds ptr, ptr %28, i64 %add22
  %30 = load ptr, ptr %arrayidx23, align 8
  %str24 = getelementptr inbounds %struct.redisReply, ptr %30, i32 0, i32 4
  %31 = load ptr, ptr %str24, align 8
  %call25 = call ptr @hi_sdsnew(ptr noundef %31)
  %32 = load ptr, ptr %cmdArg.addr, align 8
  %token = getelementptr inbounds %struct.cliCommandArg, ptr %32, i32 0, i32 2
  store ptr %call25, ptr %token, align 8
  br label %if.end136

if.else26:                                        ; preds = %if.else17
  %33 = load ptr, ptr %key, align 8
  %call27 = call i32 @strcmp(ptr noundef %33, ptr noundef @.str.140) #12
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.else88, label %if.then29

if.then29:                                        ; preds = %if.else26
  %34 = load ptr, ptr %argMap.addr, align 8
  %element31 = getelementptr inbounds %struct.redisReply, ptr %34, i32 0, i32 7
  %35 = load ptr, ptr %element31, align 8
  %36 = load i64, ptr %i, align 8
  %add32 = add i64 %36, 1
  %arrayidx33 = getelementptr inbounds ptr, ptr %35, i64 %add32
  %37 = load ptr, ptr %arrayidx33, align 8
  %str34 = getelementptr inbounds %struct.redisReply, ptr %37, i32 0, i32 4
  %38 = load ptr, ptr %str34, align 8
  store ptr %38, ptr %type30, align 8
  %39 = load ptr, ptr %type30, align 8
  %call35 = call i32 @strcmp(ptr noundef %39, ptr noundef @.str.91) #12
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.else39, label %if.then37

if.then37:                                        ; preds = %if.then29
  %40 = load ptr, ptr %cmdArg.addr, align 8
  %type38 = getelementptr inbounds %struct.cliCommandArg, ptr %40, i32 0, i32 1
  store i32 0, ptr %type38, align 8
  br label %if.end87

if.else39:                                        ; preds = %if.then29
  %41 = load ptr, ptr %type30, align 8
  %call40 = call i32 @strcmp(ptr noundef %41, ptr noundef @.str.141) #12
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.else44, label %if.then42

if.then42:                                        ; preds = %if.else39
  %42 = load ptr, ptr %cmdArg.addr, align 8
  %type43 = getelementptr inbounds %struct.cliCommandArg, ptr %42, i32 0, i32 1
  store i32 1, ptr %type43, align 8
  br label %if.end86

if.else44:                                        ; preds = %if.else39
  %43 = load ptr, ptr %type30, align 8
  %call45 = call i32 @strcmp(ptr noundef %43, ptr noundef @.str.142) #12
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.else49, label %if.then47

if.then47:                                        ; preds = %if.else44
  %44 = load ptr, ptr %cmdArg.addr, align 8
  %type48 = getelementptr inbounds %struct.cliCommandArg, ptr %44, i32 0, i32 1
  store i32 2, ptr %type48, align 8
  br label %if.end85

if.else49:                                        ; preds = %if.else44
  %45 = load ptr, ptr %type30, align 8
  %call50 = call i32 @strcmp(ptr noundef %45, ptr noundef @.str.143) #12
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.else54, label %if.then52

if.then52:                                        ; preds = %if.else49
  %46 = load ptr, ptr %cmdArg.addr, align 8
  %type53 = getelementptr inbounds %struct.cliCommandArg, ptr %46, i32 0, i32 1
  store i32 3, ptr %type53, align 8
  br label %if.end84

if.else54:                                        ; preds = %if.else49
  %47 = load ptr, ptr %type30, align 8
  %call55 = call i32 @strcmp(ptr noundef %47, ptr noundef @.str.144) #12
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.else59, label %if.then57

if.then57:                                        ; preds = %if.else54
  %48 = load ptr, ptr %cmdArg.addr, align 8
  %type58 = getelementptr inbounds %struct.cliCommandArg, ptr %48, i32 0, i32 1
  store i32 4, ptr %type58, align 8
  br label %if.end83

if.else59:                                        ; preds = %if.else54
  %49 = load ptr, ptr %type30, align 8
  %call60 = call i32 @strcmp(ptr noundef %49, ptr noundef @.str.145) #12
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %if.else64, label %if.then62

if.then62:                                        ; preds = %if.else59
  %50 = load ptr, ptr %cmdArg.addr, align 8
  %type63 = getelementptr inbounds %struct.cliCommandArg, ptr %50, i32 0, i32 1
  store i32 5, ptr %type63, align 8
  br label %if.end82

if.else64:                                        ; preds = %if.else59
  %51 = load ptr, ptr %type30, align 8
  %call65 = call i32 @strcmp(ptr noundef %51, ptr noundef @.str.146) #12
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.else69, label %if.then67

if.then67:                                        ; preds = %if.else64
  %52 = load ptr, ptr %cmdArg.addr, align 8
  %type68 = getelementptr inbounds %struct.cliCommandArg, ptr %52, i32 0, i32 1
  store i32 6, ptr %type68, align 8
  br label %if.end81

if.else69:                                        ; preds = %if.else64
  %53 = load ptr, ptr %type30, align 8
  %call70 = call i32 @strcmp(ptr noundef %53, ptr noundef @.str.147) #12
  %tobool71 = icmp ne i32 %call70, 0
  br i1 %tobool71, label %if.else74, label %if.then72

if.then72:                                        ; preds = %if.else69
  %54 = load ptr, ptr %cmdArg.addr, align 8
  %type73 = getelementptr inbounds %struct.cliCommandArg, ptr %54, i32 0, i32 1
  store i32 7, ptr %type73, align 8
  br label %if.end80

if.else74:                                        ; preds = %if.else69
  %55 = load ptr, ptr %type30, align 8
  %call75 = call i32 @strcmp(ptr noundef %55, ptr noundef @.str.148) #12
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %if.end79, label %if.then77

if.then77:                                        ; preds = %if.else74
  %56 = load ptr, ptr %cmdArg.addr, align 8
  %type78 = getelementptr inbounds %struct.cliCommandArg, ptr %56, i32 0, i32 1
  store i32 8, ptr %type78, align 8
  br label %if.end79

if.end79:                                         ; preds = %if.then77, %if.else74
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %if.then72
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %if.then67
  br label %if.end82

if.end82:                                         ; preds = %if.end81, %if.then62
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.then57
  br label %if.end84

if.end84:                                         ; preds = %if.end83, %if.then52
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %if.then47
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.then42
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.then37
  br label %if.end135

if.else88:                                        ; preds = %if.else26
  %57 = load ptr, ptr %key, align 8
  %call89 = call i32 @strcmp(ptr noundef %57, ptr noundef @.str.134) #12
  %tobool90 = icmp ne i32 %call89, 0
  br i1 %tobool90, label %if.else99, label %if.then91

if.then91:                                        ; preds = %if.else88
  %58 = load ptr, ptr %argMap.addr, align 8
  %element92 = getelementptr inbounds %struct.redisReply, ptr %58, i32 0, i32 7
  %59 = load ptr, ptr %element92, align 8
  %60 = load i64, ptr %i, align 8
  %add93 = add i64 %60, 1
  %arrayidx94 = getelementptr inbounds ptr, ptr %59, i64 %add93
  %61 = load ptr, ptr %arrayidx94, align 8
  store ptr %61, ptr %arguments, align 8
  %62 = load ptr, ptr %arguments, align 8
  %elements95 = getelementptr inbounds %struct.redisReply, ptr %62, i32 0, i32 6
  %63 = load i64, ptr %elements95, align 8
  %mul = mul i64 %63, 72
  %call96 = call noalias ptr @zcalloc(i64 noundef %mul) #14
  %64 = load ptr, ptr %cmdArg.addr, align 8
  %subargs = getelementptr inbounds %struct.cliCommandArg, ptr %64, i32 0, i32 6
  store ptr %call96, ptr %subargs, align 8
  %65 = load ptr, ptr %arguments, align 8
  %elements97 = getelementptr inbounds %struct.redisReply, ptr %65, i32 0, i32 6
  %66 = load i64, ptr %elements97, align 8
  %conv = trunc i64 %66 to i32
  %67 = load ptr, ptr %cmdArg.addr, align 8
  %numsubargs = getelementptr inbounds %struct.cliCommandArg, ptr %67, i32 0, i32 5
  store i32 %conv, ptr %numsubargs, align 4
  %68 = load ptr, ptr %arguments, align 8
  %69 = load ptr, ptr %cmdArg.addr, align 8
  %subargs98 = getelementptr inbounds %struct.cliCommandArg, ptr %69, i32 0, i32 6
  %70 = load ptr, ptr %subargs98, align 8
  call void @cliMakeCommandDocArgs(ptr noundef %68, ptr noundef %70)
  br label %if.end134

if.else99:                                        ; preds = %if.else88
  %71 = load ptr, ptr %key, align 8
  %call100 = call i32 @strcmp(ptr noundef %71, ptr noundef @.str.149) #12
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %if.end133, label %if.then102

if.then102:                                       ; preds = %if.else99
  %72 = load ptr, ptr %argMap.addr, align 8
  %element103 = getelementptr inbounds %struct.redisReply, ptr %72, i32 0, i32 7
  %73 = load ptr, ptr %element103, align 8
  %74 = load i64, ptr %i, align 8
  %add104 = add i64 %74, 1
  %arrayidx105 = getelementptr inbounds ptr, ptr %73, i64 %add104
  %75 = load ptr, ptr %arrayidx105, align 8
  store ptr %75, ptr %flags, align 8
  store i64 0, ptr %j, align 8
  br label %for.cond106

for.cond106:                                      ; preds = %for.inc, %if.then102
  %76 = load i64, ptr %j, align 8
  %77 = load ptr, ptr %flags, align 8
  %elements107 = getelementptr inbounds %struct.redisReply, ptr %77, i32 0, i32 6
  %78 = load i64, ptr %elements107, align 8
  %cmp108 = icmp ult i64 %76, %78
  br i1 %cmp108, label %for.body110, label %for.end

for.body110:                                      ; preds = %for.cond106
  %79 = load ptr, ptr %flags, align 8
  %element111 = getelementptr inbounds %struct.redisReply, ptr %79, i32 0, i32 7
  %80 = load ptr, ptr %element111, align 8
  %81 = load i64, ptr %j, align 8
  %arrayidx112 = getelementptr inbounds ptr, ptr %80, i64 %81
  %82 = load ptr, ptr %arrayidx112, align 8
  %str113 = getelementptr inbounds %struct.redisReply, ptr %82, i32 0, i32 4
  %83 = load ptr, ptr %str113, align 8
  store ptr %83, ptr %flag, align 8
  %84 = load ptr, ptr %flag, align 8
  %call114 = call i32 @strcmp(ptr noundef %84, ptr noundef @.str.150) #12
  %tobool115 = icmp ne i32 %call114, 0
  br i1 %tobool115, label %if.else118, label %if.then116

if.then116:                                       ; preds = %for.body110
  %85 = load ptr, ptr %cmdArg.addr, align 8
  %flags117 = getelementptr inbounds %struct.cliCommandArg, ptr %85, i32 0, i32 4
  %86 = load i32, ptr %flags117, align 8
  %or = or i32 %86, 1
  store i32 %or, ptr %flags117, align 8
  br label %if.end132

if.else118:                                       ; preds = %for.body110
  %87 = load ptr, ptr %flag, align 8
  %call119 = call i32 @strcmp(ptr noundef %87, ptr noundef @.str.151) #12
  %tobool120 = icmp ne i32 %call119, 0
  br i1 %tobool120, label %if.else124, label %if.then121

if.then121:                                       ; preds = %if.else118
  %88 = load ptr, ptr %cmdArg.addr, align 8
  %flags122 = getelementptr inbounds %struct.cliCommandArg, ptr %88, i32 0, i32 4
  %89 = load i32, ptr %flags122, align 8
  %or123 = or i32 %89, 2
  store i32 %or123, ptr %flags122, align 8
  br label %if.end131

if.else124:                                       ; preds = %if.else118
  %90 = load ptr, ptr %flag, align 8
  %call125 = call i32 @strcmp(ptr noundef %90, ptr noundef @.str.152) #12
  %tobool126 = icmp ne i32 %call125, 0
  br i1 %tobool126, label %if.end130, label %if.then127

if.then127:                                       ; preds = %if.else124
  %91 = load ptr, ptr %cmdArg.addr, align 8
  %flags128 = getelementptr inbounds %struct.cliCommandArg, ptr %91, i32 0, i32 4
  %92 = load i32, ptr %flags128, align 8
  %or129 = or i32 %92, 4
  store i32 %or129, ptr %flags128, align 8
  br label %if.end130

if.end130:                                        ; preds = %if.then127, %if.else124
  br label %if.end131

if.end131:                                        ; preds = %if.end130, %if.then121
  br label %if.end132

if.end132:                                        ; preds = %if.end131, %if.then116
  br label %for.inc

for.inc:                                          ; preds = %if.end132
  %93 = load i64, ptr %j, align 8
  %inc = add i64 %93, 1
  store i64 %inc, ptr %j, align 8
  br label %for.cond106, !llvm.loop !104

for.end:                                          ; preds = %for.cond106
  br label %if.end133

if.end133:                                        ; preds = %for.end, %if.else99
  br label %if.end134

if.end134:                                        ; preds = %if.end133, %if.then91
  br label %if.end135

if.end135:                                        ; preds = %if.end134, %if.end87
  br label %if.end136

if.end136:                                        ; preds = %if.end135, %if.then20
  br label %if.end137

if.end137:                                        ; preds = %if.end136, %if.then11
  br label %if.end138

if.end138:                                        ; preds = %if.end137, %if.then4
  br label %for.inc139

for.inc139:                                       ; preds = %if.end138
  %94 = load i64, ptr %i, align 8
  %add140 = add i64 %94, 2
  store i64 %add140, ptr %i, align 8
  br label %for.cond, !llvm.loop !105

for.end141:                                       ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clearMatchedArgs(ptr noundef %args, i32 noundef %numargs) #0 {
entry:
  %args.addr = alloca ptr, align 8
  %numargs.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %args, ptr %args.addr, align 8
  store i32 %numargs, ptr %numargs.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %numargs.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %args.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.cliCommandArg, ptr %2, i64 %idxprom
  %matched = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx, i32 0, i32 8
  store i32 0, ptr %matched, align 8
  %4 = load ptr, ptr %args.addr, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds %struct.cliCommandArg, ptr %4, i64 %idxprom1
  %matched_token = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx2, i32 0, i32 9
  store i32 0, ptr %matched_token, align 4
  %6 = load ptr, ptr %args.addr, align 8
  %7 = load i32, ptr %i, align 4
  %idxprom3 = sext i32 %7 to i64
  %arrayidx4 = getelementptr inbounds %struct.cliCommandArg, ptr %6, i64 %idxprom3
  %matched_name = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx4, i32 0, i32 10
  store i32 0, ptr %matched_name, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i32, ptr %i, align 4
  %idxprom5 = sext i32 %9 to i64
  %arrayidx6 = getelementptr inbounds %struct.cliCommandArg, ptr %8, i64 %idxprom5
  %matched_all = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx6, i32 0, i32 11
  store i32 0, ptr %matched_all, align 4
  %10 = load ptr, ptr %args.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom7 = sext i32 %11 to i64
  %arrayidx8 = getelementptr inbounds %struct.cliCommandArg, ptr %10, i64 %idxprom7
  %subargs = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx8, i32 0, i32 6
  %12 = load ptr, ptr %subargs, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %13 = load ptr, ptr %args.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %14 to i64
  %arrayidx10 = getelementptr inbounds %struct.cliCommandArg, ptr %13, i64 %idxprom9
  %subargs11 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx10, i32 0, i32 6
  %15 = load ptr, ptr %subargs11, align 8
  %16 = load ptr, ptr %args.addr, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom12 = sext i32 %17 to i64
  %arrayidx13 = getelementptr inbounds %struct.cliCommandArg, ptr %16, i64 %idxprom12
  %numsubargs = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx13, i32 0, i32 5
  %18 = load i32, ptr %numsubargs, align 4
  call void @clearMatchedArgs(ptr noundef %15, i32 noundef %18)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i32, ptr %i, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !106

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @matchArgs(ptr noundef %words, i32 noundef %numwords, ptr noundef %args, i32 noundef %numargs) #0 {
entry:
  %retval = alloca i32, align 4
  %words.addr = alloca ptr, align 8
  %numwords.addr = alloca i32, align 4
  %args.addr = alloca ptr, align 8
  %numargs.addr = alloca i32, align 4
  %nextword = alloca i32, align 4
  %nextarg = alloca i32, align 4
  %matchedWords = alloca i32, align 4
  %lastoptional = alloca i32, align 4
  store ptr %words, ptr %words.addr, align 8
  store i32 %numwords, ptr %numwords.addr, align 4
  store ptr %args, ptr %args.addr, align 8
  store i32 %numargs, ptr %numargs.addr, align 4
  store i32 0, ptr %nextword, align 4
  store i32 0, ptr %nextarg, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc27, %entry
  %0 = load i32, ptr %nextword, align 4
  %1 = load i32, ptr %numwords.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %2 = load i32, ptr %nextarg, align 4
  %3 = load i32, ptr %numargs.addr, align 4
  %cmp1 = icmp ne i32 %2, %3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %4 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %4, label %for.body, label %for.end29

for.body:                                         ; preds = %land.end
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i32, ptr %nextarg, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds %struct.cliCommandArg, ptr %5, i64 %idxprom
  %flags = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx, i32 0, i32 4
  %7 = load i32, ptr %flags, align 8
  %and = and i32 %7, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %8 = load i32, ptr %nextarg, align 4
  store i32 %8, ptr %lastoptional, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %if.then
  %9 = load i32, ptr %lastoptional, align 4
  %10 = load i32, ptr %numargs.addr, align 4
  %cmp3 = icmp slt i32 %9, %10
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  %11 = load ptr, ptr %args.addr, align 8
  %12 = load i32, ptr %lastoptional, align 4
  %idxprom5 = sext i32 %12 to i64
  %arrayidx6 = getelementptr inbounds %struct.cliCommandArg, ptr %11, i64 %idxprom5
  %flags7 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx6, i32 0, i32 4
  %13 = load i32, ptr %flags7, align 8
  %and8 = and i32 %13, 1
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end, label %if.then10

if.then10:                                        ; preds = %for.body4
  br label %for.end

if.end:                                           ; preds = %for.body4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %14 = load i32, ptr %lastoptional, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %lastoptional, align 4
  br label %for.cond2, !llvm.loop !107

for.end:                                          ; preds = %if.then10, %for.cond2
  %15 = load ptr, ptr %words.addr, align 8
  %16 = load i32, ptr %nextword, align 4
  %idxprom11 = sext i32 %16 to i64
  %arrayidx12 = getelementptr inbounds ptr, ptr %15, i64 %idxprom11
  %17 = load i32, ptr %numwords.addr, align 4
  %18 = load i32, ptr %nextword, align 4
  %sub = sub nsw i32 %17, %18
  %19 = load ptr, ptr %args.addr, align 8
  %20 = load i32, ptr %nextarg, align 4
  %idxprom13 = sext i32 %20 to i64
  %arrayidx14 = getelementptr inbounds %struct.cliCommandArg, ptr %19, i64 %idxprom13
  %21 = load i32, ptr %lastoptional, align 4
  %22 = load i32, ptr %nextarg, align 4
  %sub15 = sub nsw i32 %21, %22
  %call = call i32 @matchOptionalArgs(ptr noundef %arrayidx12, i32 noundef %sub, ptr noundef %arrayidx14, i32 noundef %sub15)
  store i32 %call, ptr %matchedWords, align 4
  %23 = load i32, ptr %lastoptional, align 4
  %sub16 = sub nsw i32 %23, 1
  store i32 %sub16, ptr %nextarg, align 4
  br label %if.end26

if.else:                                          ; preds = %for.body
  %24 = load ptr, ptr %words.addr, align 8
  %25 = load i32, ptr %nextword, align 4
  %idxprom17 = sext i32 %25 to i64
  %arrayidx18 = getelementptr inbounds ptr, ptr %24, i64 %idxprom17
  %26 = load i32, ptr %numwords.addr, align 4
  %27 = load i32, ptr %nextword, align 4
  %sub19 = sub nsw i32 %26, %27
  %28 = load ptr, ptr %args.addr, align 8
  %29 = load i32, ptr %nextarg, align 4
  %idxprom20 = sext i32 %29 to i64
  %arrayidx21 = getelementptr inbounds %struct.cliCommandArg, ptr %28, i64 %idxprom20
  %call22 = call i32 @matchArg(ptr noundef %arrayidx18, i32 noundef %sub19, ptr noundef %arrayidx21)
  store i32 %call22, ptr %matchedWords, align 4
  %30 = load i32, ptr %matchedWords, align 4
  %cmp23 = icmp eq i32 %30, 0
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %for.end
  %31 = load i32, ptr %matchedWords, align 4
  %32 = load i32, ptr %nextword, align 4
  %add = add nsw i32 %32, %31
  store i32 %add, ptr %nextword, align 4
  br label %for.inc27

for.inc27:                                        ; preds = %if.end26
  %33 = load i32, ptr %nextarg, align 4
  %inc28 = add nsw i32 %33, 1
  store i32 %inc28, ptr %nextarg, align 4
  br label %for.cond, !llvm.loop !108

for.end29:                                        ; preds = %land.end
  %34 = load i32, ptr %nextword, align 4
  store i32 %34, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end29, %if.then24
  %35 = load i32, ptr %retval, align 4
  ret i32 %35
}

; Function Attrs: nounwind uwtable
define internal ptr @addHintForArguments(ptr noundef %hint, ptr noundef %args, i32 noundef %numargs, ptr noundef %separator) #0 {
entry:
  %hint.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %numargs.addr = alloca i32, align 4
  %separator.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %incomplete = alloca i32, align 4
  %len = alloca i64, align 8
  store ptr %hint, ptr %hint.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i32 %numargs, ptr %numargs.addr, align 4
  store ptr %separator, ptr %separator.addr, align 8
  %0 = load ptr, ptr %hint.addr, align 8
  %call = call i64 @hi_sdslen(ptr noundef %0)
  store i64 %call, ptr %len, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc62, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %numargs.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end64

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %args.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds %struct.cliCommandArg, ptr %3, i64 %idxprom
  %flags = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx, i32 0, i32 4
  %5 = load i32, ptr %flags, align 8
  %and = and i32 %5, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %hint.addr, align 8
  %7 = load ptr, ptr %args.addr, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom1 = sext i32 %8 to i64
  %arrayidx2 = getelementptr inbounds %struct.cliCommandArg, ptr %7, i64 %idxprom1
  %call3 = call ptr @addHintForArgument(ptr noundef %6, ptr noundef %arrayidx2)
  store ptr %call3, ptr %hint.addr, align 8
  %9 = load ptr, ptr %hint.addr, align 8
  %10 = load ptr, ptr %separator.addr, align 8
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %numargs.addr, align 4
  %sub = sub nsw i32 %12, 1
  %cmp4 = icmp eq i32 %11, %sub
  %conv = zext i1 %cmp4 to i32
  %call5 = call ptr @addSeparator(ptr noundef %9, ptr noundef %len, ptr noundef %10, i32 noundef %conv)
  store ptr %call5, ptr %hint.addr, align 8
  br label %for.inc62

if.end:                                           ; preds = %for.body
  %13 = load i32, ptr %i, align 4
  store i32 %13, ptr %j, align 4
  store i32 -1, ptr %incomplete, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %if.end
  %14 = load i32, ptr %j, align 4
  %15 = load i32, ptr %numargs.addr, align 4
  %cmp7 = icmp slt i32 %14, %15
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %16 = load ptr, ptr %args.addr, align 8
  %17 = load i32, ptr %j, align 4
  %idxprom10 = sext i32 %17 to i64
  %arrayidx11 = getelementptr inbounds %struct.cliCommandArg, ptr %16, i64 %idxprom10
  %flags12 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx11, i32 0, i32 4
  %18 = load i32, ptr %flags12, align 8
  %and13 = and i32 %18, 1
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %for.body9
  br label %for.end

if.end16:                                         ; preds = %for.body9
  %19 = load ptr, ptr %args.addr, align 8
  %20 = load i32, ptr %j, align 4
  %idxprom17 = sext i32 %20 to i64
  %arrayidx18 = getelementptr inbounds %struct.cliCommandArg, ptr %19, i64 %idxprom17
  %matched = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx18, i32 0, i32 8
  %21 = load i32, ptr %matched, align 8
  %cmp19 = icmp ne i32 %21, 0
  br i1 %cmp19, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %if.end16
  %22 = load ptr, ptr %args.addr, align 8
  %23 = load i32, ptr %j, align 4
  %idxprom21 = sext i32 %23 to i64
  %arrayidx22 = getelementptr inbounds %struct.cliCommandArg, ptr %22, i64 %idxprom21
  %matched_all = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx22, i32 0, i32 11
  %24 = load i32, ptr %matched_all, align 4
  %cmp23 = icmp eq i32 %24, 0
  br i1 %cmp23, label %if.then25, label %if.end33

if.then25:                                        ; preds = %land.lhs.true
  %25 = load ptr, ptr %hint.addr, align 8
  %26 = load ptr, ptr %args.addr, align 8
  %27 = load i32, ptr %j, align 4
  %idxprom26 = sext i32 %27 to i64
  %arrayidx27 = getelementptr inbounds %struct.cliCommandArg, ptr %26, i64 %idxprom26
  %call28 = call ptr @addHintForArgument(ptr noundef %25, ptr noundef %arrayidx27)
  store ptr %call28, ptr %hint.addr, align 8
  %28 = load ptr, ptr %hint.addr, align 8
  %29 = load ptr, ptr %separator.addr, align 8
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %numargs.addr, align 4
  %sub29 = sub nsw i32 %31, 1
  %cmp30 = icmp eq i32 %30, %sub29
  %conv31 = zext i1 %cmp30 to i32
  %call32 = call ptr @addSeparator(ptr noundef %28, ptr noundef %len, ptr noundef %29, i32 noundef %conv31)
  store ptr %call32, ptr %hint.addr, align 8
  %32 = load i32, ptr %j, align 4
  store i32 %32, ptr %incomplete, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.then25, %land.lhs.true, %if.end16
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %33 = load i32, ptr %j, align 4
  %inc = add nsw i32 %33, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond6, !llvm.loop !109

for.end:                                          ; preds = %if.then15, %for.cond6
  %34 = load i32, ptr %j, align 4
  %35 = load i32, ptr %numargs.addr, align 4
  %cmp34 = icmp eq i32 %34, %35
  br i1 %cmp34, label %if.then41, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %36 = load ptr, ptr %args.addr, align 8
  %37 = load i32, ptr %j, align 4
  %idxprom36 = sext i32 %37 to i64
  %arrayidx37 = getelementptr inbounds %struct.cliCommandArg, ptr %36, i64 %idxprom36
  %matched38 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx37, i32 0, i32 8
  %38 = load i32, ptr %matched38, align 8
  %cmp39 = icmp eq i32 %38, 0
  br i1 %cmp39, label %if.then41, label %if.end60

if.then41:                                        ; preds = %lor.lhs.false, %for.end
  br label %for.cond42

for.cond42:                                       ; preds = %for.inc57, %if.then41
  %39 = load i32, ptr %i, align 4
  %40 = load i32, ptr %j, align 4
  %cmp43 = icmp slt i32 %39, %40
  br i1 %cmp43, label %for.body45, label %for.end59

for.body45:                                       ; preds = %for.cond42
  %41 = load i32, ptr %incomplete, align 4
  %42 = load i32, ptr %i, align 4
  %cmp46 = icmp ne i32 %41, %42
  br i1 %cmp46, label %if.then48, label %if.end56

if.then48:                                        ; preds = %for.body45
  %43 = load ptr, ptr %hint.addr, align 8
  %44 = load ptr, ptr %args.addr, align 8
  %45 = load i32, ptr %i, align 4
  %idxprom49 = sext i32 %45 to i64
  %arrayidx50 = getelementptr inbounds %struct.cliCommandArg, ptr %44, i64 %idxprom49
  %call51 = call ptr @addHintForArgument(ptr noundef %43, ptr noundef %arrayidx50)
  store ptr %call51, ptr %hint.addr, align 8
  %46 = load ptr, ptr %hint.addr, align 8
  %47 = load ptr, ptr %separator.addr, align 8
  %48 = load i32, ptr %i, align 4
  %49 = load i32, ptr %numargs.addr, align 4
  %sub52 = sub nsw i32 %49, 1
  %cmp53 = icmp eq i32 %48, %sub52
  %conv54 = zext i1 %cmp53 to i32
  %call55 = call ptr @addSeparator(ptr noundef %46, ptr noundef %len, ptr noundef %47, i32 noundef %conv54)
  store ptr %call55, ptr %hint.addr, align 8
  br label %if.end56

if.end56:                                         ; preds = %if.then48, %for.body45
  br label %for.inc57

for.inc57:                                        ; preds = %if.end56
  %50 = load i32, ptr %i, align 4
  %inc58 = add nsw i32 %50, 1
  store i32 %inc58, ptr %i, align 4
  br label %for.cond42, !llvm.loop !110

for.end59:                                        ; preds = %for.cond42
  br label %if.end60

if.end60:                                         ; preds = %for.end59, %lor.lhs.false
  %51 = load i32, ptr %j, align 4
  %sub61 = sub nsw i32 %51, 1
  store i32 %sub61, ptr %i, align 4
  br label %for.inc62

for.inc62:                                        ; preds = %if.end60, %if.then
  %52 = load i32, ptr %i, align 4
  %inc63 = add nsw i32 %52, 1
  store i32 %inc63, ptr %i, align 4
  br label %for.cond, !llvm.loop !111

for.end64:                                        ; preds = %for.cond
  %53 = load ptr, ptr %hint.addr, align 8
  ret ptr %53
}

; Function Attrs: nounwind uwtable
define internal i32 @matchOptionalArgs(ptr noundef %words, i32 noundef %numwords, ptr noundef %args, i32 noundef %numargs) #0 {
entry:
  %words.addr = alloca ptr, align 8
  %numwords.addr = alloca i32, align 4
  %args.addr = alloca ptr, align 8
  %numargs.addr = alloca i32, align 4
  %nextword = alloca i32, align 4
  %matchedarg = alloca i32, align 4
  %lastmatchedarg = alloca i32, align 4
  %matchedWords = alloca i32, align 4
  store ptr %words, ptr %words.addr, align 8
  store i32 %numwords, ptr %numwords.addr, align 4
  store ptr %args, ptr %args.addr, align 8
  store i32 %numargs, ptr %numargs.addr, align 4
  store i32 0, ptr %nextword, align 4
  store i32 -1, ptr %matchedarg, align 4
  store i32 -1, ptr %lastmatchedarg, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end6, %entry
  %0 = load i32, ptr %nextword, align 4
  %1 = load i32, ptr %numwords.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %words.addr, align 8
  %3 = load i32, ptr %nextword, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 %idxprom
  %4 = load i32, ptr %numwords.addr, align 4
  %5 = load i32, ptr %nextword, align 4
  %sub = sub nsw i32 %4, %5
  %6 = load ptr, ptr %args.addr, align 8
  %7 = load i32, ptr %numargs.addr, align 4
  %call = call i32 @matchOneOptionalArg(ptr noundef %arrayidx, i32 noundef %sub, ptr noundef %6, i32 noundef %7, ptr noundef %matchedarg)
  store i32 %call, ptr %matchedWords, align 4
  %8 = load i32, ptr %matchedWords, align 4
  %cmp1 = icmp eq i32 %8, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %9 = load i32, ptr %lastmatchedarg, align 4
  %cmp2 = icmp ne i32 %9, -1
  br i1 %cmp2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %10 = load ptr, ptr %args.addr, align 8
  %11 = load i32, ptr %lastmatchedarg, align 4
  %idxprom4 = sext i32 %11 to i64
  %arrayidx5 = getelementptr inbounds %struct.cliCommandArg, ptr %10, i64 %idxprom4
  %matched_all = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx5, i32 0, i32 11
  store i32 1, ptr %matched_all, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %12 = load i32, ptr %matchedarg, align 4
  store i32 %12, ptr %lastmatchedarg, align 4
  %13 = load i32, ptr %matchedWords, align 4
  %14 = load i32, ptr %nextword, align 4
  %add = add nsw i32 %14, %13
  store i32 %add, ptr %nextword, align 4
  br label %while.cond, !llvm.loop !112

while.end:                                        ; preds = %if.then, %while.cond
  %15 = load i32, ptr %nextword, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @matchArg(ptr noundef %nextword, i32 noundef %numwords, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %nextword.addr = alloca ptr, align 8
  %numwords.addr = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  %matchedWords = alloca i32, align 4
  %matchedOnce = alloca i32, align 4
  store ptr %nextword, ptr %nextword.addr, align 8
  store i32 %numwords, ptr %numwords.addr, align 4
  store ptr %arg, ptr %arg.addr, align 8
  store i32 0, ptr %matchedWords, align 4
  %0 = load ptr, ptr %nextword.addr, align 8
  %1 = load i32, ptr %numwords.addr, align 4
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @matchArgOnce(ptr noundef %0, i32 noundef %1, ptr noundef %2)
  store i32 %call, ptr %matchedOnce, align 4
  %3 = load ptr, ptr %arg.addr, align 8
  %flags = getelementptr inbounds %struct.cliCommandArg, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, ptr %matchedOnce, align 4
  store i32 %5, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, ptr %matchedOnce, align 4
  %7 = load i32, ptr %matchedWords, align 4
  %add = add nsw i32 %7, %6
  store i32 %add, ptr %matchedWords, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end15, %if.end
  %8 = load ptr, ptr %arg.addr, align 8
  %matched_all = getelementptr inbounds %struct.cliCommandArg, ptr %8, i32 0, i32 11
  %9 = load i32, ptr %matched_all, align 4
  %tobool1 = icmp ne i32 %9, 0
  br i1 %tobool1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %10 = load i32, ptr %matchedWords, align 4
  %11 = load i32, ptr %numwords.addr, align 4
  %cmp = icmp slt i32 %10, %11
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %12 = phi i1 [ false, %while.cond ], [ %cmp, %land.rhs ]
  br i1 %12, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %13 = load ptr, ptr %arg.addr, align 8
  call void @clearMatchedArgs(ptr noundef %13, i32 noundef 1)
  %14 = load ptr, ptr %arg.addr, align 8
  %token = getelementptr inbounds %struct.cliCommandArg, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %token, align 8
  %cmp2 = icmp ne ptr %15, null
  br i1 %cmp2, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %while.body
  %16 = load ptr, ptr %arg.addr, align 8
  %flags3 = getelementptr inbounds %struct.cliCommandArg, ptr %16, i32 0, i32 4
  %17 = load i32, ptr %flags3, align 8
  %and4 = and i32 %17, 4
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.else, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %18 = load ptr, ptr %nextword.addr, align 8
  %19 = load i32, ptr %matchedWords, align 4
  %idx.ext = sext i32 %19 to i64
  %add.ptr = getelementptr inbounds ptr, ptr %18, i64 %idx.ext
  %20 = load i32, ptr %numwords.addr, align 4
  %21 = load i32, ptr %matchedWords, align 4
  %sub = sub nsw i32 %20, %21
  %22 = load ptr, ptr %arg.addr, align 8
  %call7 = call i32 @matchNoTokenArg(ptr noundef %add.ptr, i32 noundef %sub, ptr noundef %22)
  store i32 %call7, ptr %matchedOnce, align 4
  %23 = load ptr, ptr %arg.addr, align 8
  %matched = getelementptr inbounds %struct.cliCommandArg, ptr %23, i32 0, i32 8
  %24 = load i32, ptr %matched, align 8
  %tobool8 = icmp ne i32 %24, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then6
  %25 = load ptr, ptr %arg.addr, align 8
  %matched_token = getelementptr inbounds %struct.cliCommandArg, ptr %25, i32 0, i32 9
  store i32 1, ptr %matched_token, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.then6
  br label %if.end15

if.else:                                          ; preds = %land.lhs.true, %while.body
  %26 = load ptr, ptr %nextword.addr, align 8
  %27 = load i32, ptr %matchedWords, align 4
  %idx.ext11 = sext i32 %27 to i64
  %add.ptr12 = getelementptr inbounds ptr, ptr %26, i64 %idx.ext11
  %28 = load i32, ptr %numwords.addr, align 4
  %29 = load i32, ptr %matchedWords, align 4
  %sub13 = sub nsw i32 %28, %29
  %30 = load ptr, ptr %arg.addr, align 8
  %call14 = call i32 @matchArgOnce(ptr noundef %add.ptr12, i32 noundef %sub13, ptr noundef %30)
  store i32 %call14, ptr %matchedOnce, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.end10
  %31 = load i32, ptr %matchedOnce, align 4
  %32 = load i32, ptr %matchedWords, align 4
  %add16 = add nsw i32 %32, %31
  store i32 %add16, ptr %matchedWords, align 4
  br label %while.cond, !llvm.loop !113

while.end:                                        ; preds = %land.end
  %33 = load ptr, ptr %arg.addr, align 8
  %matched_all17 = getelementptr inbounds %struct.cliCommandArg, ptr %33, i32 0, i32 11
  store i32 0, ptr %matched_all17, align 4
  %34 = load i32, ptr %matchedWords, align 4
  store i32 %34, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %35 = load i32, ptr %retval, align 4
  ret i32 %35
}

; Function Attrs: nounwind uwtable
define internal i32 @matchOneOptionalArg(ptr noundef %words, i32 noundef %numwords, ptr noundef %args, i32 noundef %numargs, ptr noundef %matchedarg) #0 {
entry:
  %retval = alloca i32, align 4
  %words.addr = alloca ptr, align 8
  %numwords.addr = alloca i32, align 4
  %args.addr = alloca ptr, align 8
  %numargs.addr = alloca i32, align 4
  %matchedarg.addr = alloca ptr, align 8
  %nextword = alloca i32, align 4
  %nextarg = alloca i32, align 4
  %matchedWords = alloca i32, align 4
  store ptr %words, ptr %words.addr, align 8
  store i32 %numwords, ptr %numwords.addr, align 4
  store ptr %args, ptr %args.addr, align 8
  store i32 %numargs, ptr %numargs.addr, align 4
  store ptr %matchedarg, ptr %matchedarg.addr, align 8
  store i32 0, ptr %nextword, align 4
  store i32 0, ptr %nextarg, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %nextword, align 4
  %1 = load i32, ptr %numwords.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %2 = load i32, ptr %nextarg, align 4
  %3 = load i32, ptr %numargs.addr, align 4
  %cmp1 = icmp ne i32 %2, %3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %4 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %4, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %5 = load ptr, ptr %args.addr, align 8
  %6 = load i32, ptr %nextarg, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds %struct.cliCommandArg, ptr %5, i64 %idxprom
  %matched = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx, i32 0, i32 8
  %7 = load i32, ptr %matched, align 8
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %8 = load ptr, ptr %words.addr, align 8
  %9 = load i32, ptr %nextword, align 4
  %idxprom2 = sext i32 %9 to i64
  %arrayidx3 = getelementptr inbounds ptr, ptr %8, i64 %idxprom2
  %10 = load i32, ptr %numwords.addr, align 4
  %11 = load i32, ptr %nextword, align 4
  %sub = sub nsw i32 %10, %11
  %12 = load ptr, ptr %args.addr, align 8
  %13 = load i32, ptr %nextarg, align 4
  %idxprom4 = sext i32 %13 to i64
  %arrayidx5 = getelementptr inbounds %struct.cliCommandArg, ptr %12, i64 %idxprom4
  %call = call i32 @matchArg(ptr noundef %arrayidx3, i32 noundef %sub, ptr noundef %arrayidx5)
  store i32 %call, ptr %matchedWords, align 4
  %14 = load i32, ptr %matchedWords, align 4
  %cmp6 = icmp ne i32 %14, 0
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  %15 = load i32, ptr %nextarg, align 4
  %16 = load ptr, ptr %matchedarg.addr, align 8
  store i32 %15, ptr %16, align 4
  %17 = load i32, ptr %matchedWords, align 4
  store i32 %17, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end8, %if.then
  %18 = load i32, ptr %nextarg, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %nextarg, align 4
  br label %for.cond, !llvm.loop !114

for.end:                                          ; preds = %land.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then7
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind uwtable
define internal i32 @matchArgOnce(ptr noundef %nextword, i32 noundef %numwords, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %nextword.addr = alloca ptr, align 8
  %numwords.addr = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  store ptr %nextword, ptr %nextword.addr, align 8
  store i32 %numwords, ptr %numwords.addr, align 4
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %token = getelementptr inbounds %struct.cliCommandArg, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %token, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %nextword.addr, align 8
  %3 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @matchToken(ptr noundef %2, ptr noundef %3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %4 = load ptr, ptr %arg.addr, align 8
  %type = getelementptr inbounds %struct.cliCommandArg, ptr %4, i32 0, i32 1
  %5 = load i32, ptr %type, align 8
  %cmp2 = icmp eq i32 %5, 6
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %arg.addr, align 8
  %matched_all = getelementptr inbounds %struct.cliCommandArg, ptr %6, i32 0, i32 11
  store i32 1, ptr %matched_all, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %7 = load i32, ptr %numwords.addr, align 4
  %cmp5 = icmp eq i32 %7, 1
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  %8 = load ptr, ptr %nextword.addr, align 8
  %incdec.ptr = getelementptr inbounds ptr, ptr %8, i32 1
  store ptr %incdec.ptr, ptr %nextword.addr, align 8
  %9 = load i32, ptr %numwords.addr, align 4
  %dec = add nsw i32 %9, -1
  store i32 %dec, ptr %numwords.addr, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %entry
  %10 = load ptr, ptr %nextword.addr, align 8
  %11 = load i32, ptr %numwords.addr, align 4
  %12 = load ptr, ptr %arg.addr, align 8
  %call9 = call i32 @matchNoTokenArg(ptr noundef %10, i32 noundef %11, ptr noundef %12)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end8
  store i32 0, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  %13 = load ptr, ptr %arg.addr, align 8
  %matched = getelementptr inbounds %struct.cliCommandArg, ptr %13, i32 0, i32 8
  %14 = load i32, ptr %matched, align 8
  store i32 %14, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then6, %if.then3, %if.then1
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @matchNoTokenArg(ptr noundef %nextword, i32 noundef %numwords, ptr noundef %arg) #0 {
entry:
  %nextword.addr = alloca ptr, align 8
  %numwords.addr = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %value = alloca i64, align 8
  %value42 = alloca double, align 8
  store ptr %nextword, ptr %nextword.addr, align 8
  store i32 %numwords, ptr %numwords.addr, align 4
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %type = getelementptr inbounds %struct.cliCommandArg, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %type, align 8
  switch i32 %1, label %sw.default [
    i32 8, label %sw.bb
    i32 7, label %sw.bb6
    i32 1, label %sw.bb31
    i32 5, label %sw.bb31
    i32 2, label %sw.bb41
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %nextword.addr, align 8
  %3 = load i32, ptr %numwords.addr, align 4
  %4 = load ptr, ptr %arg.addr, align 8
  %subargs = getelementptr inbounds %struct.cliCommandArg, ptr %4, i32 0, i32 6
  %5 = load ptr, ptr %subargs, align 8
  %6 = load ptr, ptr %arg.addr, align 8
  %numsubargs = getelementptr inbounds %struct.cliCommandArg, ptr %6, i32 0, i32 5
  %7 = load i32, ptr %numsubargs, align 4
  %call = call i32 @matchArgs(ptr noundef %2, i32 noundef %3, ptr noundef %5, i32 noundef %7)
  %8 = load ptr, ptr %arg.addr, align 8
  %matched = getelementptr inbounds %struct.cliCommandArg, ptr %8, i32 0, i32 8
  %9 = load i32, ptr %matched, align 8
  %add = add nsw i32 %9, %call
  store i32 %add, ptr %matched, align 8
  %10 = load ptr, ptr %arg.addr, align 8
  %matched_all = getelementptr inbounds %struct.cliCommandArg, ptr %10, i32 0, i32 11
  store i32 1, ptr %matched_all, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb
  %11 = load i32, ptr %i, align 4
  %12 = load ptr, ptr %arg.addr, align 8
  %numsubargs1 = getelementptr inbounds %struct.cliCommandArg, ptr %12, i32 0, i32 5
  %13 = load i32, ptr %numsubargs1, align 4
  %cmp = icmp slt i32 %11, %13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load ptr, ptr %arg.addr, align 8
  %subargs2 = getelementptr inbounds %struct.cliCommandArg, ptr %14, i32 0, i32 6
  %15 = load ptr, ptr %subargs2, align 8
  %16 = load i32, ptr %i, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr inbounds %struct.cliCommandArg, ptr %15, i64 %idxprom
  %matched_all3 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx, i32 0, i32 11
  %17 = load i32, ptr %matched_all3, align 4
  %cmp4 = icmp eq i32 %17, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %18 = load ptr, ptr %arg.addr, align 8
  %matched_all5 = getelementptr inbounds %struct.cliCommandArg, ptr %18, i32 0, i32 11
  store i32 0, ptr %matched_all5, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i32, ptr %i, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !115

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  store i32 0, ptr %i, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc28, %sw.bb6
  %20 = load i32, ptr %i, align 4
  %21 = load ptr, ptr %arg.addr, align 8
  %numsubargs8 = getelementptr inbounds %struct.cliCommandArg, ptr %21, i32 0, i32 5
  %22 = load i32, ptr %numsubargs8, align 4
  %cmp9 = icmp slt i32 %20, %22
  br i1 %cmp9, label %for.body10, label %for.end30

for.body10:                                       ; preds = %for.cond7
  %23 = load ptr, ptr %nextword.addr, align 8
  %24 = load i32, ptr %numwords.addr, align 4
  %25 = load ptr, ptr %arg.addr, align 8
  %subargs11 = getelementptr inbounds %struct.cliCommandArg, ptr %25, i32 0, i32 6
  %26 = load ptr, ptr %subargs11, align 8
  %27 = load i32, ptr %i, align 4
  %idxprom12 = sext i32 %27 to i64
  %arrayidx13 = getelementptr inbounds %struct.cliCommandArg, ptr %26, i64 %idxprom12
  %call14 = call i32 @matchArg(ptr noundef %23, i32 noundef %24, ptr noundef %arrayidx13)
  %tobool = icmp ne i32 %call14, 0
  br i1 %tobool, label %if.then15, label %if.end27

if.then15:                                        ; preds = %for.body10
  %28 = load ptr, ptr %arg.addr, align 8
  %subargs16 = getelementptr inbounds %struct.cliCommandArg, ptr %28, i32 0, i32 6
  %29 = load ptr, ptr %subargs16, align 8
  %30 = load i32, ptr %i, align 4
  %idxprom17 = sext i32 %30 to i64
  %arrayidx18 = getelementptr inbounds %struct.cliCommandArg, ptr %29, i64 %idxprom17
  %matched19 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx18, i32 0, i32 8
  %31 = load i32, ptr %matched19, align 8
  %32 = load ptr, ptr %arg.addr, align 8
  %matched20 = getelementptr inbounds %struct.cliCommandArg, ptr %32, i32 0, i32 8
  %33 = load i32, ptr %matched20, align 8
  %add21 = add nsw i32 %33, %31
  store i32 %add21, ptr %matched20, align 8
  %34 = load ptr, ptr %arg.addr, align 8
  %subargs22 = getelementptr inbounds %struct.cliCommandArg, ptr %34, i32 0, i32 6
  %35 = load ptr, ptr %subargs22, align 8
  %36 = load i32, ptr %i, align 4
  %idxprom23 = sext i32 %36 to i64
  %arrayidx24 = getelementptr inbounds %struct.cliCommandArg, ptr %35, i64 %idxprom23
  %matched_all25 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx24, i32 0, i32 11
  %37 = load i32, ptr %matched_all25, align 4
  %38 = load ptr, ptr %arg.addr, align 8
  %matched_all26 = getelementptr inbounds %struct.cliCommandArg, ptr %38, i32 0, i32 11
  store i32 %37, ptr %matched_all26, align 4
  br label %for.end30

if.end27:                                         ; preds = %for.body10
  br label %for.inc28

for.inc28:                                        ; preds = %if.end27
  %39 = load i32, ptr %i, align 4
  %inc29 = add nsw i32 %39, 1
  store i32 %inc29, ptr %i, align 4
  br label %for.cond7, !llvm.loop !116

for.end30:                                        ; preds = %if.then15, %for.cond7
  br label %sw.epilog

sw.bb31:                                          ; preds = %entry, %entry
  %40 = load ptr, ptr %nextword.addr, align 8
  %41 = load ptr, ptr %40, align 8
  %call32 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %41, ptr noundef @.str.153, ptr noundef %value) #15
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.else

if.then34:                                        ; preds = %sw.bb31
  %42 = load ptr, ptr %arg.addr, align 8
  %matched35 = getelementptr inbounds %struct.cliCommandArg, ptr %42, i32 0, i32 8
  %43 = load i32, ptr %matched35, align 8
  %add36 = add nsw i32 %43, 1
  store i32 %add36, ptr %matched35, align 8
  %44 = load ptr, ptr %arg.addr, align 8
  %matched_name = getelementptr inbounds %struct.cliCommandArg, ptr %44, i32 0, i32 10
  store i32 1, ptr %matched_name, align 8
  %45 = load ptr, ptr %arg.addr, align 8
  %matched_all37 = getelementptr inbounds %struct.cliCommandArg, ptr %45, i32 0, i32 11
  store i32 1, ptr %matched_all37, align 4
  br label %if.end40

if.else:                                          ; preds = %sw.bb31
  %46 = load ptr, ptr %arg.addr, align 8
  %matched38 = getelementptr inbounds %struct.cliCommandArg, ptr %46, i32 0, i32 8
  store i32 0, ptr %matched38, align 8
  %47 = load ptr, ptr %arg.addr, align 8
  %matched_name39 = getelementptr inbounds %struct.cliCommandArg, ptr %47, i32 0, i32 10
  store i32 0, ptr %matched_name39, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.then34
  br label %sw.epilog

sw.bb41:                                          ; preds = %entry
  %48 = load ptr, ptr %nextword.addr, align 8
  %49 = load ptr, ptr %48, align 8
  %call43 = call i32 (ptr, ptr, ...) @__isoc99_sscanf(ptr noundef %49, ptr noundef @.str.154, ptr noundef %value42) #15
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %if.then45, label %if.else50

if.then45:                                        ; preds = %sw.bb41
  %50 = load ptr, ptr %arg.addr, align 8
  %matched46 = getelementptr inbounds %struct.cliCommandArg, ptr %50, i32 0, i32 8
  %51 = load i32, ptr %matched46, align 8
  %add47 = add nsw i32 %51, 1
  store i32 %add47, ptr %matched46, align 8
  %52 = load ptr, ptr %arg.addr, align 8
  %matched_name48 = getelementptr inbounds %struct.cliCommandArg, ptr %52, i32 0, i32 10
  store i32 1, ptr %matched_name48, align 8
  %53 = load ptr, ptr %arg.addr, align 8
  %matched_all49 = getelementptr inbounds %struct.cliCommandArg, ptr %53, i32 0, i32 11
  store i32 1, ptr %matched_all49, align 4
  br label %if.end53

if.else50:                                        ; preds = %sw.bb41
  %54 = load ptr, ptr %arg.addr, align 8
  %matched51 = getelementptr inbounds %struct.cliCommandArg, ptr %54, i32 0, i32 8
  store i32 0, ptr %matched51, align 8
  %55 = load ptr, ptr %arg.addr, align 8
  %matched_name52 = getelementptr inbounds %struct.cliCommandArg, ptr %55, i32 0, i32 10
  store i32 0, ptr %matched_name52, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.else50, %if.then45
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %56 = load ptr, ptr %arg.addr, align 8
  %matched54 = getelementptr inbounds %struct.cliCommandArg, ptr %56, i32 0, i32 8
  %57 = load i32, ptr %matched54, align 8
  %add55 = add nsw i32 %57, 1
  store i32 %add55, ptr %matched54, align 8
  %58 = load ptr, ptr %arg.addr, align 8
  %matched_name56 = getelementptr inbounds %struct.cliCommandArg, ptr %58, i32 0, i32 10
  store i32 1, ptr %matched_name56, align 8
  %59 = load ptr, ptr %arg.addr, align 8
  %matched_all57 = getelementptr inbounds %struct.cliCommandArg, ptr %59, i32 0, i32 11
  store i32 1, ptr %matched_all57, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end53, %if.end40, %for.end30, %for.end
  %60 = load ptr, ptr %arg.addr, align 8
  %matched58 = getelementptr inbounds %struct.cliCommandArg, ptr %60, i32 0, i32 8
  %61 = load i32, ptr %matched58, align 8
  ret i32 %61
}

; Function Attrs: nounwind uwtable
define internal i32 @matchToken(ptr noundef %nextword, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %nextword.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %nextword, ptr %nextword.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %token = getelementptr inbounds %struct.cliCommandArg, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %token, align 8
  %2 = load ptr, ptr %nextword.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 0
  %3 = load ptr, ptr %arrayidx, align 8
  %call = call i32 @strcasecmp(ptr noundef %1, ptr noundef %3) #12
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %arg.addr, align 8
  %matched_token = getelementptr inbounds %struct.cliCommandArg, ptr %4, i32 0, i32 9
  store i32 1, ptr %matched_token, align 4
  %5 = load ptr, ptr %arg.addr, align 8
  %matched = getelementptr inbounds %struct.cliCommandArg, ptr %5, i32 0, i32 8
  store i32 1, ptr %matched, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind
declare i32 @__isoc99_sscanf(ptr noundef, ptr noundef, ...) #6

; Function Attrs: nounwind uwtable
define internal ptr @addHintForArgument(ptr noundef %hint, ptr noundef %arg) #0 {
entry:
  %retval = alloca ptr, align 8
  %hint.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %hint, ptr %hint.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %matched_all = getelementptr inbounds %struct.cliCommandArg, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %matched_all, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %hint.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %arg.addr, align 8
  %flags = getelementptr inbounds %struct.cliCommandArg, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %5 = load ptr, ptr %arg.addr, align 8
  %matched = getelementptr inbounds %struct.cliCommandArg, ptr %5, i32 0, i32 8
  %6 = load i32, ptr %matched, align 8
  %tobool2 = icmp ne i32 %6, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %7 = load ptr, ptr %hint.addr, align 8
  %call = call ptr @hi_sdscat(ptr noundef %7, ptr noundef @.str.155)
  store ptr %call, ptr %hint.addr, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %land.lhs.true, %if.end
  %8 = load ptr, ptr %arg.addr, align 8
  %token = getelementptr inbounds %struct.cliCommandArg, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %token, align 8
  %cmp = icmp ne ptr %9, null
  br i1 %cmp, label %land.lhs.true5, label %if.end14

land.lhs.true5:                                   ; preds = %if.end4
  %10 = load ptr, ptr %arg.addr, align 8
  %matched_token = getelementptr inbounds %struct.cliCommandArg, ptr %10, i32 0, i32 9
  %11 = load i32, ptr %matched_token, align 4
  %tobool6 = icmp ne i32 %11, 0
  br i1 %tobool6, label %if.end14, label %if.then7

if.then7:                                         ; preds = %land.lhs.true5
  %12 = load ptr, ptr %hint.addr, align 8
  %13 = load ptr, ptr %arg.addr, align 8
  %token8 = getelementptr inbounds %struct.cliCommandArg, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %token8, align 8
  %call9 = call ptr @sdscat_orempty(ptr noundef %12, ptr noundef %14)
  store ptr %call9, ptr %hint.addr, align 8
  %15 = load ptr, ptr %arg.addr, align 8
  %type = getelementptr inbounds %struct.cliCommandArg, ptr %15, i32 0, i32 1
  %16 = load i32, ptr %type, align 8
  %cmp10 = icmp ne i32 %16, 6
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.then7
  %17 = load ptr, ptr %hint.addr, align 8
  %call12 = call ptr @hi_sdscat(ptr noundef %17, ptr noundef @.str.136)
  store ptr %call12, ptr %hint.addr, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.then7
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %land.lhs.true5, %if.end4
  %18 = load ptr, ptr %arg.addr, align 8
  %type15 = getelementptr inbounds %struct.cliCommandArg, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %type15, align 8
  switch i32 %19, label %sw.default [
    i32 7, label %sw.bb
    i32 8, label %sw.bb32
    i32 6, label %sw.bb36
  ]

sw.bb:                                            ; preds = %if.end14
  %20 = load ptr, ptr %arg.addr, align 8
  %matched16 = getelementptr inbounds %struct.cliCommandArg, ptr %20, i32 0, i32 8
  %21 = load i32, ptr %matched16, align 8
  %cmp17 = icmp eq i32 %21, 0
  br i1 %cmp17, label %if.then18, label %if.else

if.then18:                                        ; preds = %sw.bb
  %22 = load ptr, ptr %hint.addr, align 8
  %23 = load ptr, ptr %arg.addr, align 8
  %subargs = getelementptr inbounds %struct.cliCommandArg, ptr %23, i32 0, i32 6
  %24 = load ptr, ptr %subargs, align 8
  %25 = load ptr, ptr %arg.addr, align 8
  %numsubargs = getelementptr inbounds %struct.cliCommandArg, ptr %25, i32 0, i32 5
  %26 = load i32, ptr %numsubargs, align 4
  %call19 = call ptr @addHintForArguments(ptr noundef %22, ptr noundef %24, i32 noundef %26, ptr noundef @.str.156)
  store ptr %call19, ptr %hint.addr, align 8
  br label %if.end31

if.else:                                          ; preds = %sw.bb
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %27 = load i32, ptr %i, align 4
  %28 = load ptr, ptr %arg.addr, align 8
  %numsubargs20 = getelementptr inbounds %struct.cliCommandArg, ptr %28, i32 0, i32 5
  %29 = load i32, ptr %numsubargs20, align 4
  %cmp21 = icmp slt i32 %27, %29
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %30 = load ptr, ptr %arg.addr, align 8
  %subargs22 = getelementptr inbounds %struct.cliCommandArg, ptr %30, i32 0, i32 6
  %31 = load ptr, ptr %subargs22, align 8
  %32 = load i32, ptr %i, align 4
  %idxprom = sext i32 %32 to i64
  %arrayidx = getelementptr inbounds %struct.cliCommandArg, ptr %31, i64 %idxprom
  %matched23 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx, i32 0, i32 8
  %33 = load i32, ptr %matched23, align 8
  %cmp24 = icmp ne i32 %33, 0
  br i1 %cmp24, label %if.then25, label %if.end30

if.then25:                                        ; preds = %for.body
  %34 = load ptr, ptr %hint.addr, align 8
  %35 = load ptr, ptr %arg.addr, align 8
  %subargs26 = getelementptr inbounds %struct.cliCommandArg, ptr %35, i32 0, i32 6
  %36 = load ptr, ptr %subargs26, align 8
  %37 = load i32, ptr %i, align 4
  %idxprom27 = sext i32 %37 to i64
  %arrayidx28 = getelementptr inbounds %struct.cliCommandArg, ptr %36, i64 %idxprom27
  %call29 = call ptr @addHintForArgument(ptr noundef %34, ptr noundef %arrayidx28)
  store ptr %call29, ptr %hint.addr, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then25, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end30
  %38 = load i32, ptr %i, align 4
  %inc = add nsw i32 %38, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !117

for.end:                                          ; preds = %for.cond
  br label %if.end31

if.end31:                                         ; preds = %for.end, %if.then18
  br label %sw.epilog

sw.bb32:                                          ; preds = %if.end14
  %39 = load ptr, ptr %hint.addr, align 8
  %40 = load ptr, ptr %arg.addr, align 8
  %subargs33 = getelementptr inbounds %struct.cliCommandArg, ptr %40, i32 0, i32 6
  %41 = load ptr, ptr %subargs33, align 8
  %42 = load ptr, ptr %arg.addr, align 8
  %numsubargs34 = getelementptr inbounds %struct.cliCommandArg, ptr %42, i32 0, i32 5
  %43 = load i32, ptr %numsubargs34, align 4
  %call35 = call ptr @addHintForArguments(ptr noundef %39, ptr noundef %41, i32 noundef %43, ptr noundef @.str.136)
  store ptr %call35, ptr %hint.addr, align 8
  br label %sw.epilog

sw.bb36:                                          ; preds = %if.end14
  br label %sw.epilog

sw.default:                                       ; preds = %if.end14
  %44 = load ptr, ptr %arg.addr, align 8
  %matched_name = getelementptr inbounds %struct.cliCommandArg, ptr %44, i32 0, i32 10
  %45 = load i32, ptr %matched_name, align 8
  %tobool37 = icmp ne i32 %45, 0
  br i1 %tobool37, label %if.end42, label %if.then38

if.then38:                                        ; preds = %sw.default
  %46 = load ptr, ptr %hint.addr, align 8
  %47 = load ptr, ptr %arg.addr, align 8
  %display_text = getelementptr inbounds %struct.cliCommandArg, ptr %47, i32 0, i32 7
  %48 = load ptr, ptr %display_text, align 8
  %tobool39 = icmp ne ptr %48, null
  br i1 %tobool39, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then38
  %49 = load ptr, ptr %arg.addr, align 8
  %display_text40 = getelementptr inbounds %struct.cliCommandArg, ptr %49, i32 0, i32 7
  %50 = load ptr, ptr %display_text40, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then38
  %51 = load ptr, ptr %arg.addr, align 8
  %name = getelementptr inbounds %struct.cliCommandArg, ptr %51, i32 0, i32 0
  %52 = load ptr, ptr %name, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %50, %cond.true ], [ %52, %cond.false ]
  %call41 = call ptr @sdscat_orempty(ptr noundef %46, ptr noundef %cond)
  store ptr %call41, ptr %hint.addr, align 8
  br label %if.end42

if.end42:                                         ; preds = %cond.end, %sw.default
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end42, %sw.bb36, %sw.bb32, %if.end31
  %53 = load ptr, ptr %hint.addr, align 8
  %54 = load ptr, ptr %arg.addr, align 8
  %call43 = call ptr @addHintForRepeatedArgument(ptr noundef %53, ptr noundef %54)
  store ptr %call43, ptr %hint.addr, align 8
  %55 = load ptr, ptr %arg.addr, align 8
  %flags44 = getelementptr inbounds %struct.cliCommandArg, ptr %55, i32 0, i32 4
  %56 = load i32, ptr %flags44, align 8
  %and45 = and i32 %56, 1
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %land.lhs.true47, label %if.end52

land.lhs.true47:                                  ; preds = %sw.epilog
  %57 = load ptr, ptr %arg.addr, align 8
  %matched48 = getelementptr inbounds %struct.cliCommandArg, ptr %57, i32 0, i32 8
  %58 = load i32, ptr %matched48, align 8
  %tobool49 = icmp ne i32 %58, 0
  br i1 %tobool49, label %if.end52, label %if.then50

if.then50:                                        ; preds = %land.lhs.true47
  %59 = load ptr, ptr %hint.addr, align 8
  %call51 = call ptr @hi_sdscat(ptr noundef %59, ptr noundef @.str.157)
  store ptr %call51, ptr %hint.addr, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %land.lhs.true47, %sw.epilog
  %60 = load ptr, ptr %hint.addr, align 8
  store ptr %60, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end52, %if.then
  %61 = load ptr, ptr %retval, align 8
  ret ptr %61
}

; Function Attrs: nounwind uwtable
define internal ptr @addSeparator(ptr noundef %str, ptr noundef %len, ptr noundef %separator, i32 noundef %is_last) #0 {
entry:
  %str.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %separator.addr = alloca ptr, align 8
  %is_last.addr = alloca i32, align 4
  store ptr %str, ptr %str.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  store ptr %separator, ptr %separator.addr, align 8
  store i32 %is_last, ptr %is_last.addr, align 4
  %0 = load ptr, ptr %str.addr, align 8
  %call = call i64 @hi_sdslen(ptr noundef %0)
  %1 = load ptr, ptr %len.addr, align 8
  %2 = load i64, ptr %1, align 8
  %cmp = icmp ugt i64 %call, %2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i32, ptr %is_last.addr, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %4 = load ptr, ptr %str.addr, align 8
  %5 = load ptr, ptr %separator.addr, align 8
  %call1 = call ptr @hi_sdscat(ptr noundef %4, ptr noundef %5)
  store ptr %call1, ptr %str.addr, align 8
  %6 = load ptr, ptr %str.addr, align 8
  %call2 = call i64 @hi_sdslen(ptr noundef %6)
  %7 = load ptr, ptr %len.addr, align 8
  store i64 %call2, ptr %7, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %8 = load ptr, ptr %str.addr, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal ptr @sdscat_orempty(ptr noundef %params, ptr noundef %value) #0 {
entry:
  %retval = alloca ptr, align 8
  %params.addr = alloca ptr, align 8
  %value.addr = alloca ptr, align 8
  store ptr %params, ptr %params.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %params.addr, align 8
  %call = call ptr @hi_sdscat(ptr noundef %2, ptr noundef @.str.158)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %params.addr, align 8
  %4 = load ptr, ptr %value.addr, align 8
  %call2 = call ptr @hi_sdscat(ptr noundef %3, ptr noundef %4)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define internal ptr @addHintForRepeatedArgument(ptr noundef %hint, ptr noundef %arg) #0 {
entry:
  %retval = alloca ptr, align 8
  %hint.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %hint, ptr %hint.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %flags = getelementptr inbounds %struct.cliCommandArg, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %flags, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %hint.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %arg.addr, align 8
  call void @clearMatchedArgs(ptr noundef %3, i32 noundef 1)
  %4 = load ptr, ptr %hint.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %4, i64 0
  %5 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %5 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %6 = load ptr, ptr %hint.addr, align 8
  %call = call ptr @hi_sdscat(ptr noundef %6, ptr noundef @.str.136)
  store ptr %call, ptr %hint.addr, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %7 = load ptr, ptr %hint.addr, align 8
  %call4 = call ptr @hi_sdscat(ptr noundef %7, ptr noundef @.str.155)
  store ptr %call4, ptr %hint.addr, align 8
  %8 = load ptr, ptr %arg.addr, align 8
  %flags5 = getelementptr inbounds %struct.cliCommandArg, ptr %8, i32 0, i32 4
  %9 = load i32, ptr %flags5, align 8
  %and6 = and i32 %9, 4
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.end15

if.then8:                                         ; preds = %if.end3
  %10 = load ptr, ptr %hint.addr, align 8
  %11 = load ptr, ptr %arg.addr, align 8
  %token = getelementptr inbounds %struct.cliCommandArg, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %token, align 8
  %call9 = call ptr @sdscat_orempty(ptr noundef %10, ptr noundef %12)
  store ptr %call9, ptr %hint.addr, align 8
  %13 = load ptr, ptr %arg.addr, align 8
  %type = getelementptr inbounds %struct.cliCommandArg, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %type, align 8
  %cmp10 = icmp ne i32 %14, 6
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.then8
  %15 = load ptr, ptr %hint.addr, align 8
  %call13 = call ptr @hi_sdscat(ptr noundef %15, ptr noundef @.str.136)
  store ptr %call13, ptr %hint.addr, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.end3
  %16 = load ptr, ptr %arg.addr, align 8
  %type16 = getelementptr inbounds %struct.cliCommandArg, ptr %16, i32 0, i32 1
  %17 = load i32, ptr %type16, align 8
  switch i32 %17, label %sw.default [
    i32 7, label %sw.bb
    i32 8, label %sw.bb18
    i32 6, label %sw.bb22
  ]

sw.bb:                                            ; preds = %if.end15
  %18 = load ptr, ptr %hint.addr, align 8
  %19 = load ptr, ptr %arg.addr, align 8
  %subargs = getelementptr inbounds %struct.cliCommandArg, ptr %19, i32 0, i32 6
  %20 = load ptr, ptr %subargs, align 8
  %21 = load ptr, ptr %arg.addr, align 8
  %numsubargs = getelementptr inbounds %struct.cliCommandArg, ptr %21, i32 0, i32 5
  %22 = load i32, ptr %numsubargs, align 4
  %call17 = call ptr @addHintForArguments(ptr noundef %18, ptr noundef %20, i32 noundef %22, ptr noundef @.str.156)
  store ptr %call17, ptr %hint.addr, align 8
  br label %sw.epilog

sw.bb18:                                          ; preds = %if.end15
  %23 = load ptr, ptr %hint.addr, align 8
  %24 = load ptr, ptr %arg.addr, align 8
  %subargs19 = getelementptr inbounds %struct.cliCommandArg, ptr %24, i32 0, i32 6
  %25 = load ptr, ptr %subargs19, align 8
  %26 = load ptr, ptr %arg.addr, align 8
  %numsubargs20 = getelementptr inbounds %struct.cliCommandArg, ptr %26, i32 0, i32 5
  %27 = load i32, ptr %numsubargs20, align 4
  %call21 = call ptr @addHintForArguments(ptr noundef %23, ptr noundef %25, i32 noundef %27, ptr noundef @.str.136)
  store ptr %call21, ptr %hint.addr, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %if.end15
  br label %sw.epilog

sw.default:                                       ; preds = %if.end15
  %28 = load ptr, ptr %hint.addr, align 8
  %29 = load ptr, ptr %arg.addr, align 8
  %display_text = getelementptr inbounds %struct.cliCommandArg, ptr %29, i32 0, i32 7
  %30 = load ptr, ptr %display_text, align 8
  %tobool23 = icmp ne ptr %30, null
  br i1 %tobool23, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.default
  %31 = load ptr, ptr %arg.addr, align 8
  %display_text24 = getelementptr inbounds %struct.cliCommandArg, ptr %31, i32 0, i32 7
  %32 = load ptr, ptr %display_text24, align 8
  br label %cond.end

cond.false:                                       ; preds = %sw.default
  %33 = load ptr, ptr %arg.addr, align 8
  %name = getelementptr inbounds %struct.cliCommandArg, ptr %33, i32 0, i32 0
  %34 = load ptr, ptr %name, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %32, %cond.true ], [ %34, %cond.false ]
  %call25 = call ptr @sdscat_orempty(ptr noundef %28, ptr noundef %cond)
  store ptr %call25, ptr %hint.addr, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end, %sw.bb22, %sw.bb18, %sw.bb
  %35 = load ptr, ptr %hint.addr, align 8
  %call26 = call ptr @hi_sdscat(ptr noundef %35, ptr noundef @.str.159)
  store ptr %call26, ptr %hint.addr, align 8
  %36 = load ptr, ptr %hint.addr, align 8
  store ptr %36, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  %37 = load ptr, ptr %retval, align 8
  ret ptr %37
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @atoi(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @removeUnsupportedArgs(ptr noundef %args, ptr noundef %numargs, ptr noundef %version) #0 {
entry:
  %args.addr = alloca ptr, align 8
  %numargs.addr = alloca ptr, align 8
  %version.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  store ptr %args, ptr %args.addr, align 8
  store ptr %numargs, ptr %numargs.addr, align 8
  store ptr %version, ptr %version.addr, align 8
  store i32 0, ptr %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.end, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load ptr, ptr %numargs.addr, align 8
  %2 = load i32, ptr %1, align 4
  %cmp = icmp ne i32 %0, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %version.addr, align 8
  %4 = load ptr, ptr %args.addr, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds %struct.cliCommandArg, ptr %4, i64 %idxprom
  %since = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx, i32 0, i32 3
  %6 = load ptr, ptr %since, align 8
  %call = call i32 @versionIsSupported(ptr noundef %3, ptr noundef %6)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %while.body
  %7 = load ptr, ptr %args.addr, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom1 = sext i32 %8 to i64
  %arrayidx2 = getelementptr inbounds %struct.cliCommandArg, ptr %7, i64 %idxprom1
  %subargs = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx2, i32 0, i32 6
  %9 = load ptr, ptr %subargs, align 8
  %tobool3 = icmp ne ptr %9, null
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %10 = load ptr, ptr %args.addr, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom5 = sext i32 %11 to i64
  %arrayidx6 = getelementptr inbounds %struct.cliCommandArg, ptr %10, i64 %idxprom5
  %subargs7 = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx6, i32 0, i32 6
  %12 = load ptr, ptr %subargs7, align 8
  %13 = load ptr, ptr %args.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom8 = sext i32 %14 to i64
  %arrayidx9 = getelementptr inbounds %struct.cliCommandArg, ptr %13, i64 %idxprom8
  %numsubargs = getelementptr inbounds %struct.cliCommandArg, ptr %arrayidx9, i32 0, i32 5
  %15 = load ptr, ptr %version.addr, align 8
  call void @removeUnsupportedArgs(ptr noundef %12, ptr noundef %numsubargs, ptr noundef %15)
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %16 = load i32, ptr %i, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %i, align 4
  br label %while.cond, !llvm.loop !118

if.end10:                                         ; preds = %while.body
  %17 = load i32, ptr %i, align 4
  store i32 %17, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %18 = load i32, ptr %j, align 4
  %19 = load ptr, ptr %numargs.addr, align 8
  %20 = load i32, ptr %19, align 4
  %cmp11 = icmp ne i32 %18, %20
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load ptr, ptr %args.addr, align 8
  %22 = load i32, ptr %j, align 4
  %idxprom12 = sext i32 %22 to i64
  %arrayidx13 = getelementptr inbounds %struct.cliCommandArg, ptr %21, i64 %idxprom12
  %23 = load ptr, ptr %args.addr, align 8
  %24 = load i32, ptr %j, align 4
  %add = add nsw i32 %24, 1
  %idxprom14 = sext i32 %add to i64
  %arrayidx15 = getelementptr inbounds %struct.cliCommandArg, ptr %23, i64 %idxprom14
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx13, ptr align 8 %arrayidx15, i64 72, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %25 = load i32, ptr %j, align 4
  %inc16 = add nsw i32 %25, 1
  store i32 %inc16, ptr %j, align 4
  br label %for.cond, !llvm.loop !119

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %numargs.addr, align 8
  %27 = load i32, ptr %26, align 4
  %dec = add nsw i32 %27, -1
  store i32 %dec, ptr %26, align 4
  br label %while.cond, !llvm.loop !118

while.end:                                        ; preds = %while.cond
  ret void
}

declare ptr @listCreate() #2

; Function Attrs: nounwind uwtable
define internal i32 @parseClusterNodeAddress(ptr noundef %addr, ptr noundef %ip_ptr, ptr noundef %port_ptr, ptr noundef %bus_port_ptr) #0 {
entry:
  %retval = alloca i32, align 4
  %addr.addr = alloca ptr, align 8
  %ip_ptr.addr = alloca ptr, align 8
  %port_ptr.addr = alloca ptr, align 8
  %bus_port_ptr.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store ptr %ip_ptr, ptr %ip_ptr.addr, align 8
  store ptr %port_ptr, ptr %port_ptr.addr, align 8
  store ptr %bus_port_ptr, ptr %bus_port_ptr.addr, align 8
  %0 = load ptr, ptr %addr.addr, align 8
  %call = call ptr @strrchr(ptr noundef %0, i32 noundef 64) #12
  store ptr %call, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c, align 8
  store i8 0, ptr %2, align 1
  %3 = load ptr, ptr %bus_port_ptr.addr, align 8
  %cmp1 = icmp ne ptr %3, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %4 = load ptr, ptr %c, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 1
  %call3 = call i32 @atoi(ptr noundef %add.ptr) #12
  %5 = load ptr, ptr %bus_port_ptr.addr, align 8
  store i32 %call3, ptr %5, align 4
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %6 = load ptr, ptr %addr.addr, align 8
  %call5 = call ptr @strrchr(ptr noundef %6, i32 noundef 58) #12
  store ptr %call5, ptr %c, align 8
  %7 = load ptr, ptr %c, align 8
  %cmp6 = icmp ne ptr %7, null
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end4
  %8 = load ptr, ptr %c, align 8
  store i8 0, ptr %8, align 1
  %9 = load ptr, ptr %addr.addr, align 8
  %10 = load ptr, ptr %ip_ptr.addr, align 8
  store ptr %9, ptr %10, align 8
  %11 = load ptr, ptr %c, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %11, i32 1
  store ptr %incdec.ptr, ptr %c, align 8
  %call8 = call i32 @atoi(ptr noundef %incdec.ptr) #12
  %12 = load ptr, ptr %port_ptr.addr, align 8
  store i32 %call8, ptr %12, align 4
  br label %if.end9

if.else:                                          ; preds = %if.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.then7
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.else
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNewNode(ptr noundef %ip, i32 noundef %port, i32 noundef %bus_port) #0 {
entry:
  %ip.addr = alloca ptr, align 8
  %port.addr = alloca i32, align 4
  %bus_port.addr = alloca i32, align 4
  %node = alloca ptr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i32 %port, ptr %port.addr, align 4
  store i32 %bus_port, ptr %bus_port.addr, align 4
  %call = call noalias ptr @zmalloc(i64 noundef 16520) #14
  store ptr %call, ptr %node, align 8
  %0 = load ptr, ptr %node, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  store ptr null, ptr %context, align 8
  %1 = load ptr, ptr %node, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %1, i32 0, i32 1
  store ptr null, ptr %name, align 8
  %2 = load ptr, ptr %ip.addr, align 8
  %3 = load ptr, ptr %node, align 8
  %ip1 = getelementptr inbounds %struct.clusterManagerNode, ptr %3, i32 0, i32 2
  store ptr %2, ptr %ip1, align 8
  %4 = load i32, ptr %port.addr, align 4
  %5 = load ptr, ptr %node, align 8
  %port2 = getelementptr inbounds %struct.clusterManagerNode, ptr %5, i32 0, i32 3
  store i32 %4, ptr %port2, align 8
  %6 = load i32, ptr %bus_port.addr, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load i32, ptr %bus_port.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  %8 = load i32, ptr %port.addr, align 4
  %add = add nsw i32 %8, 10000
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %7, %cond.true ], [ %add, %cond.false ]
  %9 = load ptr, ptr %node, align 8
  %bus_port3 = getelementptr inbounds %struct.clusterManagerNode, ptr %9, i32 0, i32 4
  store i32 %cond, ptr %bus_port3, align 4
  %10 = load ptr, ptr %node, align 8
  %current_epoch = getelementptr inbounds %struct.clusterManagerNode, ptr %10, i32 0, i32 5
  store i64 0, ptr %current_epoch, align 8
  %11 = load ptr, ptr %node, align 8
  %ping_sent = getelementptr inbounds %struct.clusterManagerNode, ptr %11, i32 0, i32 6
  store i64 0, ptr %ping_sent, align 8
  %12 = load ptr, ptr %node, align 8
  %ping_recv = getelementptr inbounds %struct.clusterManagerNode, ptr %12, i32 0, i32 7
  store i64 0, ptr %ping_recv, align 8
  %13 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %13, i32 0, i32 8
  store i32 0, ptr %flags, align 8
  %14 = load ptr, ptr %node, align 8
  %flags_str = getelementptr inbounds %struct.clusterManagerNode, ptr %14, i32 0, i32 9
  store ptr null, ptr %flags_str, align 8
  %15 = load ptr, ptr %node, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %15, i32 0, i32 10
  store ptr null, ptr %replicate, align 8
  %16 = load ptr, ptr %node, align 8
  %dirty = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 11
  store i32 0, ptr %dirty, align 8
  %17 = load ptr, ptr %node, align 8
  %friends = getelementptr inbounds %struct.clusterManagerNode, ptr %17, i32 0, i32 15
  store ptr null, ptr %friends, align 8
  %18 = load ptr, ptr %node, align 8
  %migrating = getelementptr inbounds %struct.clusterManagerNode, ptr %18, i32 0, i32 16
  store ptr null, ptr %migrating, align 8
  %19 = load ptr, ptr %node, align 8
  %importing = getelementptr inbounds %struct.clusterManagerNode, ptr %19, i32 0, i32 17
  store ptr null, ptr %importing, align 8
  %20 = load ptr, ptr %node, align 8
  %migrating_count = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 18
  store i32 0, ptr %migrating_count, align 8
  %21 = load ptr, ptr %node, align 8
  %importing_count = getelementptr inbounds %struct.clusterManagerNode, ptr %21, i32 0, i32 19
  store i32 0, ptr %importing_count, align 4
  %22 = load ptr, ptr %node, align 8
  %replicas_count = getelementptr inbounds %struct.clusterManagerNode, ptr %22, i32 0, i32 14
  store i32 0, ptr %replicas_count, align 8
  %23 = load ptr, ptr %node, align 8
  %weight = getelementptr inbounds %struct.clusterManagerNode, ptr %23, i32 0, i32 20
  store float 1.000000e+00, ptr %weight, align 8
  %24 = load ptr, ptr %node, align 8
  %balance = getelementptr inbounds %struct.clusterManagerNode, ptr %24, i32 0, i32 21
  store i32 0, ptr %balance, align 4
  %25 = load ptr, ptr %node, align 8
  call void @clusterManagerNodeResetSlots(ptr noundef %25)
  %26 = load ptr, ptr %node, align 8
  ret ptr %26
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerNodeConnect(ptr noundef %node) #0 {
entry:
  %retval = alloca i32, align 4
  %node.addr = alloca ptr, align 8
  %err7 = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %ok = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %node.addr, align 8
  %context1 = getelementptr inbounds %struct.clusterManagerNode, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %context1, align 8
  call void @redisFree(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %ip, align 8
  %6 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %port, align 8
  %call = call ptr @redisConnect(ptr noundef %5, i32 noundef %7)
  %8 = load ptr, ptr %node.addr, align 8
  %context2 = getelementptr inbounds %struct.clusterManagerNode, ptr %8, i32 0, i32 0
  store ptr %call, ptr %context2, align 8
  %9 = load ptr, ptr %node.addr, align 8
  %context3 = getelementptr inbounds %struct.clusterManagerNode, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %context3, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %10, i32 0, i32 1
  %11 = load i32, ptr %err, align 8
  %tobool4 = icmp ne i32 %11, 0
  br i1 %tobool4, label %if.end17, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %12 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 2), align 8
  %tobool5 = icmp ne i32 %12, 0
  br i1 %tobool5, label %if.then6, label %if.end17

if.then6:                                         ; preds = %land.lhs.true
  store ptr null, ptr %err7, align 8
  %13 = load ptr, ptr %node.addr, align 8
  %context8 = getelementptr inbounds %struct.clusterManagerNode, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %context8, align 8
  %call9 = call i32 @cliSecureConnection(ptr noundef %14, ptr noundef byval(%struct.cliSSLconfig) align 8 getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 3), ptr noundef %err7)
  %cmp = icmp eq i32 %call9, -1
  br i1 %cmp, label %land.lhs.true10, label %if.end16

land.lhs.true10:                                  ; preds = %if.then6
  %15 = load ptr, ptr %err7, align 8
  %tobool11 = icmp ne ptr %15, null
  br i1 %tobool11, label %if.then12, label %if.end16

if.then12:                                        ; preds = %land.lhs.true10
  %16 = load ptr, ptr @stderr, align 8
  %17 = load ptr, ptr %err7, align 8
  %call13 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %16, ptr noundef @.str.180, ptr noundef %17)
  %18 = load ptr, ptr %node.addr, align 8
  %context14 = getelementptr inbounds %struct.clusterManagerNode, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %context14, align 8
  call void @redisFree(ptr noundef %19)
  %20 = load ptr, ptr %node.addr, align 8
  %context15 = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 0
  store ptr null, ptr %context15, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true10, %if.then6
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %land.lhs.true, %if.end
  %21 = load ptr, ptr %node.addr, align 8
  %context18 = getelementptr inbounds %struct.clusterManagerNode, ptr %21, i32 0, i32 0
  %22 = load ptr, ptr %context18, align 8
  %err19 = getelementptr inbounds %struct.redisContext, ptr %22, i32 0, i32 1
  %23 = load i32, ptr %err19, align 8
  %tobool20 = icmp ne i32 %23, 0
  br i1 %tobool20, label %if.then21, label %if.end29

if.then21:                                        ; preds = %if.end17
  %24 = load ptr, ptr @stderr, align 8
  %call22 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %24, ptr noundef @.str.181)
  %25 = load ptr, ptr @stderr, align 8
  %26 = load ptr, ptr %node.addr, align 8
  %ip23 = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %ip23, align 8
  %28 = load ptr, ptr %node.addr, align 8
  %port24 = getelementptr inbounds %struct.clusterManagerNode, ptr %28, i32 0, i32 3
  %29 = load i32, ptr %port24, align 8
  %30 = load ptr, ptr %node.addr, align 8
  %context25 = getelementptr inbounds %struct.clusterManagerNode, ptr %30, i32 0, i32 0
  %31 = load ptr, ptr %context25, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %31, i32 0, i32 2
  %arraydecay = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call26 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %25, ptr noundef @.str.182, ptr noundef %27, i32 noundef %29, ptr noundef %arraydecay)
  %32 = load ptr, ptr %node.addr, align 8
  %context27 = getelementptr inbounds %struct.clusterManagerNode, ptr %32, i32 0, i32 0
  %33 = load ptr, ptr %context27, align 8
  call void @redisFree(ptr noundef %33)
  %34 = load ptr, ptr %node.addr, align 8
  %context28 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 0
  store ptr null, ptr %context28, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end17
  %35 = load ptr, ptr %node.addr, align 8
  %context30 = getelementptr inbounds %struct.clusterManagerNode, ptr %35, i32 0, i32 0
  %36 = load ptr, ptr %context30, align 8
  %fd = getelementptr inbounds %struct.redisContext, ptr %36, i32 0, i32 3
  %37 = load i32, ptr %fd, align 4
  %call31 = call i32 @anetKeepAlive(ptr noundef null, i32 noundef %37, i32 noundef 15)
  %38 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %tobool32 = icmp ne ptr %38, null
  br i1 %tobool32, label %if.then33, label %if.end48

if.then33:                                        ; preds = %if.end29
  %39 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %cmp34 = icmp eq ptr %39, null
  br i1 %cmp34, label %if.then35, label %if.else

if.then35:                                        ; preds = %if.then33
  %40 = load ptr, ptr %node.addr, align 8
  %context36 = getelementptr inbounds %struct.clusterManagerNode, ptr %40, i32 0, i32 0
  %41 = load ptr, ptr %context36, align 8
  %42 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %call37 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %41, ptr noundef @.str.183, ptr noundef %42)
  store ptr %call37, ptr %reply, align 8
  br label %if.end40

if.else:                                          ; preds = %if.then33
  %43 = load ptr, ptr %node.addr, align 8
  %context38 = getelementptr inbounds %struct.clusterManagerNode, ptr %43, i32 0, i32 0
  %44 = load ptr, ptr %context38, align 8
  %45 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %46 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %call39 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %44, ptr noundef @.str.184, ptr noundef %45, ptr noundef %46)
  store ptr %call39, ptr %reply, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.then35
  %47 = load ptr, ptr %node.addr, align 8
  %48 = load ptr, ptr %reply, align 8
  %call41 = call i32 @clusterManagerCheckRedisReply(ptr noundef %47, ptr noundef %48, ptr noundef null)
  store i32 %call41, ptr %ok, align 4
  %49 = load ptr, ptr %reply, align 8
  %cmp42 = icmp ne ptr %49, null
  br i1 %cmp42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end40
  %50 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %50)
  br label %if.end44

if.end44:                                         ; preds = %if.then43, %if.end40
  %51 = load i32, ptr %ok, align 4
  %tobool45 = icmp ne i32 %51, 0
  br i1 %tobool45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.end44
  store i32 0, ptr %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.end44
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end29
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end48, %if.then46, %if.then21, %if.then12
  %52 = load i32, ptr %retval, align 4
  ret i32 %52
}

; Function Attrs: nounwind uwtable
define internal void @freeClusterManagerNode(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %fn = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %node.addr, align 8
  %context1 = getelementptr inbounds %struct.clusterManagerNode, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %context1, align 8
  call void @redisFree(ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %node.addr, align 8
  %friends = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 15
  %5 = load ptr, ptr %friends, align 8
  %cmp2 = icmp ne ptr %5, null
  br i1 %cmp2, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %node.addr, align 8
  %friends4 = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 15
  %7 = load ptr, ptr %friends4, align 8
  call void @listRewind(ptr noundef %7, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then3
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp5 = icmp ne ptr %call, null
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %value, align 8
  store ptr %9, ptr %fn, align 8
  %10 = load ptr, ptr %fn, align 8
  call void @freeClusterManagerNode(ptr noundef %10)
  br label %while.cond, !llvm.loop !120

while.end:                                        ; preds = %while.cond
  %11 = load ptr, ptr %node.addr, align 8
  %friends6 = getelementptr inbounds %struct.clusterManagerNode, ptr %11, i32 0, i32 15
  %12 = load ptr, ptr %friends6, align 8
  call void @listRelease(ptr noundef %12)
  %13 = load ptr, ptr %node.addr, align 8
  %friends7 = getelementptr inbounds %struct.clusterManagerNode, ptr %13, i32 0, i32 15
  store ptr null, ptr %friends7, align 8
  br label %if.end8

if.end8:                                          ; preds = %while.end, %if.end
  %14 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %name, align 8
  %cmp9 = icmp ne ptr %15, null
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %16 = load ptr, ptr %node.addr, align 8
  %name11 = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %name11, align 8
  call void @hi_sdsfree(ptr noundef %17)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %18 = load ptr, ptr %node.addr, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %18, i32 0, i32 10
  %19 = load ptr, ptr %replicate, align 8
  %cmp13 = icmp ne ptr %19, null
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %20 = load ptr, ptr %node.addr, align 8
  %replicate15 = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 10
  %21 = load ptr, ptr %replicate15, align 8
  call void @hi_sdsfree(ptr noundef %21)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %22 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %22, i32 0, i32 8
  %23 = load i32, ptr %flags, align 8
  %and = and i32 %23, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end16
  %24 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %ip, align 8
  %tobool17 = icmp ne ptr %25, null
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %land.lhs.true
  %26 = load ptr, ptr %node.addr, align 8
  %ip19 = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %ip19, align 8
  call void @hi_sdsfree(ptr noundef %27)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %land.lhs.true, %if.end16
  %28 = load ptr, ptr %node.addr, align 8
  %migrating = getelementptr inbounds %struct.clusterManagerNode, ptr %28, i32 0, i32 16
  %29 = load ptr, ptr %migrating, align 8
  %cmp21 = icmp ne ptr %29, null
  br i1 %cmp21, label %if.then22, label %if.end26

if.then22:                                        ; preds = %if.end20
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then22
  %30 = load i32, ptr %i, align 4
  %31 = load ptr, ptr %node.addr, align 8
  %migrating_count = getelementptr inbounds %struct.clusterManagerNode, ptr %31, i32 0, i32 18
  %32 = load i32, ptr %migrating_count, align 8
  %cmp23 = icmp slt i32 %30, %32
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %33 = load ptr, ptr %node.addr, align 8
  %migrating24 = getelementptr inbounds %struct.clusterManagerNode, ptr %33, i32 0, i32 16
  %34 = load ptr, ptr %migrating24, align 8
  %35 = load i32, ptr %i, align 4
  %idxprom = sext i32 %35 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %34, i64 %idxprom
  %36 = load ptr, ptr %arrayidx, align 8
  call void @hi_sdsfree(ptr noundef %36)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %37 = load i32, ptr %i, align 4
  %inc = add nsw i32 %37, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !121

for.end:                                          ; preds = %for.cond
  %38 = load ptr, ptr %node.addr, align 8
  %migrating25 = getelementptr inbounds %struct.clusterManagerNode, ptr %38, i32 0, i32 16
  %39 = load ptr, ptr %migrating25, align 8
  call void @zfree(ptr noundef %39)
  br label %if.end26

if.end26:                                         ; preds = %for.end, %if.end20
  %40 = load ptr, ptr %node.addr, align 8
  %importing = getelementptr inbounds %struct.clusterManagerNode, ptr %40, i32 0, i32 17
  %41 = load ptr, ptr %importing, align 8
  %cmp27 = icmp ne ptr %41, null
  br i1 %cmp27, label %if.then28, label %if.end39

if.then28:                                        ; preds = %if.end26
  store i32 0, ptr %i, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc35, %if.then28
  %42 = load i32, ptr %i, align 4
  %43 = load ptr, ptr %node.addr, align 8
  %importing_count = getelementptr inbounds %struct.clusterManagerNode, ptr %43, i32 0, i32 19
  %44 = load i32, ptr %importing_count, align 4
  %cmp30 = icmp slt i32 %42, %44
  br i1 %cmp30, label %for.body31, label %for.end37

for.body31:                                       ; preds = %for.cond29
  %45 = load ptr, ptr %node.addr, align 8
  %importing32 = getelementptr inbounds %struct.clusterManagerNode, ptr %45, i32 0, i32 17
  %46 = load ptr, ptr %importing32, align 8
  %47 = load i32, ptr %i, align 4
  %idxprom33 = sext i32 %47 to i64
  %arrayidx34 = getelementptr inbounds ptr, ptr %46, i64 %idxprom33
  %48 = load ptr, ptr %arrayidx34, align 8
  call void @hi_sdsfree(ptr noundef %48)
  br label %for.inc35

for.inc35:                                        ; preds = %for.body31
  %49 = load i32, ptr %i, align 4
  %inc36 = add nsw i32 %49, 1
  store i32 %inc36, ptr %i, align 4
  br label %for.cond29, !llvm.loop !122

for.end37:                                        ; preds = %for.cond29
  %50 = load ptr, ptr %node.addr, align 8
  %importing38 = getelementptr inbounds %struct.clusterManagerNode, ptr %50, i32 0, i32 17
  %51 = load ptr, ptr %importing38, align 8
  call void @zfree(ptr noundef %51)
  br label %if.end39

if.end39:                                         ; preds = %for.end37, %if.end26
  %52 = load ptr, ptr %node.addr, align 8
  %flags_str = getelementptr inbounds %struct.clusterManagerNode, ptr %52, i32 0, i32 9
  %53 = load ptr, ptr %flags_str, align 8
  %cmp40 = icmp ne ptr %53, null
  br i1 %cmp40, label %if.then41, label %if.end44

if.then41:                                        ; preds = %if.end39
  %54 = load ptr, ptr %node.addr, align 8
  %flags_str42 = getelementptr inbounds %struct.clusterManagerNode, ptr %54, i32 0, i32 9
  %55 = load ptr, ptr %flags_str42, align 8
  call void @freeClusterManagerNodeFlags(ptr noundef %55)
  %56 = load ptr, ptr %node.addr, align 8
  %flags_str43 = getelementptr inbounds %struct.clusterManagerNode, ptr %56, i32 0, i32 9
  store ptr null, ptr %flags_str43, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %if.end39
  %57 = load ptr, ptr %node.addr, align 8
  call void @zfree(ptr noundef %57)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerNodeIsCluster(ptr noundef %node, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %node.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %info = alloca ptr, align 8
  %is_cluster = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %1 = load ptr, ptr %err.addr, align 8
  %call = call ptr @clusterManagerGetNodeRedisInfo(ptr noundef %0, ptr noundef %1)
  store ptr %call, ptr %info, align 8
  %2 = load ptr, ptr %info, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %info, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %str, align 8
  %call1 = call i64 @getLongInfoField(ptr noundef %4, ptr noundef @.str.185)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, ptr %is_cluster, align 4
  %5 = load ptr, ptr %info, align 8
  call void @freeReplyObject(ptr noundef %5)
  %6 = load i32, ptr %is_cluster, align 4
  store i32 %6, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerPrintNotClusterNodeError(ptr noundef %node, ptr noundef %err) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %msg = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %err.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %err.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ @.str.187, %cond.false ]
  store ptr %cond, ptr %msg, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ip, align 8
  %4 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %port, align 8
  %6 = load ptr, ptr %msg, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.188, ptr noundef %3, i32 noundef %5, ptr noundef %6)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerNodeLoadInfo(ptr noundef %node, i32 noundef %opts, ptr noundef %err) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %opts.addr = alloca i32, align 4
  %err.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %success = alloca i32, align 4
  %getfriends = alloca i32, align 4
  %lines = alloca ptr, align 8
  %p = alloca ptr, align 8
  %line = alloca ptr, align 8
  %name = alloca ptr, align 8
  %addr = alloca ptr, align 8
  %flags = alloca ptr, align 8
  %master_id = alloca ptr, align 8
  %ping_sent = alloca ptr, align 8
  %ping_recv = alloca ptr, align 8
  %config_epoch = alloca ptr, align 8
  %link_status = alloca ptr, align 8
  %i = alloca i32, align 4
  %token = alloca ptr, align 8
  %ip = alloca ptr, align 8
  %port = alloca i32, align 4
  %bus_port = alloca i32, align 4
  %myself = alloca i32, align 4
  %currentNode = alloca ptr, align 8
  %remaining = alloca i32, align 4
  %slotsdef = alloca ptr, align 8
  %dash = alloca ptr, align 8
  %closing_bracket = alloca ptr, align 8
  %slot = alloca ptr, align 8
  %dst = alloca ptr, align 8
  %closing_bracket86 = alloca ptr, align 8
  %slot91 = alloca ptr, align 8
  %src = alloca ptr, align 8
  %start = alloca i32, align 4
  %stop = alloca i32, align 4
  %flag_len = alloca i32, align 4
  %flag = alloca ptr, align 8
  %fp = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store i32 %opts, ptr %opts.addr, align 4
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.189)
  store ptr %call, ptr %reply, align 8
  store i32 1, ptr %success, align 4
  %2 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %2, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %4 = load ptr, ptr %reply, align 8
  %5 = load ptr, ptr %err.addr, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %3, ptr noundef %4, ptr noundef %5)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end:                                           ; preds = %entry
  %6 = load i32, ptr %opts.addr, align 4
  %and = and i32 %6, 1
  store i32 %and, ptr %getfriends, align 4
  %7 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %str, align 8
  store ptr %8, ptr %lines, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end267, %if.then152, %if.end
  %9 = load ptr, ptr %lines, align 8
  %call2 = call ptr @strstr(ptr noundef %9, ptr noundef @.str.116) #12
  store ptr %call2, ptr %p, align 8
  %cmp = icmp ne ptr %call2, null
  br i1 %cmp, label %while.body, label %while.end268

while.body:                                       ; preds = %while.cond
  %10 = load ptr, ptr %p, align 8
  store i8 0, ptr %10, align 1
  %11 = load ptr, ptr %lines, align 8
  store ptr %11, ptr %line, align 8
  %12 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %12, i64 1
  store ptr %add.ptr, ptr %lines, align 8
  store ptr null, ptr %name, align 8
  store ptr null, ptr %addr, align 8
  store ptr null, ptr %flags, align 8
  store ptr null, ptr %master_id, align 8
  store ptr null, ptr %ping_sent, align 8
  store ptr null, ptr %ping_recv, align 8
  store ptr null, ptr %config_epoch, align 8
  store ptr null, ptr %link_status, align 8
  store i32 0, ptr %i, align 4
  br label %while.cond3

while.cond3:                                      ; preds = %if.end17, %while.body
  %13 = load ptr, ptr %line, align 8
  %call4 = call ptr @strchr(ptr noundef %13, i32 noundef 32) #12
  store ptr %call4, ptr %p, align 8
  %cmp5 = icmp ne ptr %call4, null
  br i1 %cmp5, label %while.body6, label %while.end

while.body6:                                      ; preds = %while.cond3
  %14 = load ptr, ptr %p, align 8
  store i8 0, ptr %14, align 1
  %15 = load ptr, ptr %line, align 8
  store ptr %15, ptr %token, align 8
  %16 = load ptr, ptr %p, align 8
  %add.ptr7 = getelementptr inbounds i8, ptr %16, i64 1
  store ptr %add.ptr7, ptr %line, align 8
  %17 = load i32, ptr %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %i, align 4
  switch i32 %17, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb8
    i32 2, label %sw.bb9
    i32 3, label %sw.bb10
    i32 4, label %sw.bb11
    i32 5, label %sw.bb12
    i32 6, label %sw.bb13
    i32 7, label %sw.bb14
  ]

sw.bb:                                            ; preds = %while.body6
  %18 = load ptr, ptr %token, align 8
  store ptr %18, ptr %name, align 8
  br label %sw.epilog

sw.bb8:                                           ; preds = %while.body6
  %19 = load ptr, ptr %token, align 8
  store ptr %19, ptr %addr, align 8
  br label %sw.epilog

sw.bb9:                                           ; preds = %while.body6
  %20 = load ptr, ptr %token, align 8
  store ptr %20, ptr %flags, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %while.body6
  %21 = load ptr, ptr %token, align 8
  store ptr %21, ptr %master_id, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %while.body6
  %22 = load ptr, ptr %token, align 8
  store ptr %22, ptr %ping_sent, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %while.body6
  %23 = load ptr, ptr %token, align 8
  store ptr %23, ptr %ping_recv, align 8
  br label %sw.epilog

sw.bb13:                                          ; preds = %while.body6
  %24 = load ptr, ptr %token, align 8
  store ptr %24, ptr %config_epoch, align 8
  br label %sw.epilog

sw.bb14:                                          ; preds = %while.body6
  %25 = load ptr, ptr %token, align 8
  store ptr %25, ptr %link_status, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb, %while.body6
  %26 = load i32, ptr %i, align 4
  %cmp15 = icmp eq i32 %26, 8
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %sw.epilog
  br label %while.end

if.end17:                                         ; preds = %sw.epilog
  br label %while.cond3, !llvm.loop !123

while.end:                                        ; preds = %if.then16, %while.cond3
  %27 = load ptr, ptr %flags, align 8
  %tobool18 = icmp ne ptr %27, null
  br i1 %tobool18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %while.end
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end20:                                         ; preds = %while.end
  store ptr null, ptr %ip, align 8
  store i32 0, ptr %port, align 4
  store i32 0, ptr %bus_port, align 4
  %28 = load ptr, ptr %addr, align 8
  %cmp21 = icmp eq ptr %28, null
  br i1 %cmp21, label %if.then24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end20
  %29 = load ptr, ptr %addr, align 8
  %call22 = call i32 @parseClusterNodeAddress(ptr noundef %29, ptr noundef %ip, ptr noundef %port, ptr noundef %bus_port)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.end26, label %if.then24

if.then24:                                        ; preds = %lor.lhs.false, %if.end20
  %30 = load ptr, ptr @stderr, align 8
  %call25 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %30, ptr noundef @.str.190)
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end26:                                         ; preds = %lor.lhs.false
  %31 = load ptr, ptr %flags, align 8
  %call27 = call ptr @strstr(ptr noundef %31, ptr noundef @.str.191) #12
  %cmp28 = icmp ne ptr %call27, null
  %conv = zext i1 %cmp28 to i32
  store i32 %conv, ptr %myself, align 4
  store ptr null, ptr %currentNode, align 8
  %32 = load i32, ptr %myself, align 4
  %tobool29 = icmp ne i32 %32, 0
  br i1 %tobool29, label %if.then30, label %if.else146

if.then30:                                        ; preds = %if.end26
  %33 = load i32, ptr %bus_port, align 4
  %34 = load ptr, ptr %node.addr, align 8
  %bus_port31 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 4
  store i32 %33, ptr %bus_port31, align 4
  %35 = load ptr, ptr %node.addr, align 8
  %flags32 = getelementptr inbounds %struct.clusterManagerNode, ptr %35, i32 0, i32 8
  %36 = load i32, ptr %flags32, align 8
  %or = or i32 %36, 1
  store i32 %or, ptr %flags32, align 8
  %37 = load ptr, ptr %node.addr, align 8
  store ptr %37, ptr %currentNode, align 8
  %38 = load ptr, ptr %node.addr, align 8
  call void @clusterManagerNodeResetSlots(ptr noundef %38)
  %39 = load i32, ptr %i, align 4
  %cmp33 = icmp eq i32 %39, 8
  br i1 %cmp33, label %if.then35, label %if.end145

if.then35:                                        ; preds = %if.then30
  %40 = load ptr, ptr %line, align 8
  %call36 = call i64 @strlen(ptr noundef %40) #12
  %conv37 = trunc i64 %call36 to i32
  store i32 %conv37, ptr %remaining, align 4
  br label %while.cond38

while.cond38:                                     ; preds = %if.end143, %if.then35
  %41 = load i32, ptr %remaining, align 4
  %cmp39 = icmp sgt i32 %41, 0
  br i1 %cmp39, label %while.body41, label %while.end144

while.body41:                                     ; preds = %while.cond38
  %42 = load ptr, ptr %line, align 8
  %call42 = call ptr @strchr(ptr noundef %42, i32 noundef 32) #12
  store ptr %call42, ptr %p, align 8
  %43 = load ptr, ptr %p, align 8
  %cmp43 = icmp eq ptr %43, null
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %while.body41
  %44 = load ptr, ptr %line, align 8
  %45 = load i32, ptr %remaining, align 4
  %idx.ext = sext i32 %45 to i64
  %add.ptr46 = getelementptr inbounds i8, ptr %44, i64 %idx.ext
  store ptr %add.ptr46, ptr %p, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %while.body41
  %46 = load ptr, ptr %p, align 8
  %47 = load ptr, ptr %line, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %46 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %47 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %48 = load i32, ptr %remaining, align 4
  %conv48 = sext i32 %48 to i64
  %sub = sub nsw i64 %conv48, %sub.ptr.sub
  %conv49 = trunc i64 %sub to i32
  store i32 %conv49, ptr %remaining, align 4
  %49 = load ptr, ptr %line, align 8
  store ptr %49, ptr %slotsdef, align 8
  %50 = load ptr, ptr %p, align 8
  store i8 0, ptr %50, align 1
  %51 = load i32, ptr %remaining, align 4
  %tobool50 = icmp ne i32 %51, 0
  br i1 %tobool50, label %if.then51, label %if.else

if.then51:                                        ; preds = %if.end47
  %52 = load ptr, ptr %p, align 8
  %add.ptr52 = getelementptr inbounds i8, ptr %52, i64 1
  store ptr %add.ptr52, ptr %line, align 8
  %53 = load i32, ptr %remaining, align 4
  %dec = add nsw i32 %53, -1
  store i32 %dec, ptr %remaining, align 4
  br label %if.end53

if.else:                                          ; preds = %if.end47
  %54 = load ptr, ptr %p, align 8
  store ptr %54, ptr %line, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.else, %if.then51
  store ptr null, ptr %dash, align 8
  %55 = load ptr, ptr %slotsdef, align 8
  %arrayidx = getelementptr inbounds i8, ptr %55, i64 0
  %56 = load i8, ptr %arrayidx, align 1
  %conv54 = sext i8 %56 to i32
  %cmp55 = icmp eq i32 %conv54, 91
  br i1 %cmp55, label %if.then57, label %if.else112

if.then57:                                        ; preds = %if.end53
  %57 = load ptr, ptr %slotsdef, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %57, i32 1
  store ptr %incdec.ptr, ptr %slotsdef, align 8
  %58 = load ptr, ptr %slotsdef, align 8
  %call58 = call ptr @strstr(ptr noundef %58, ptr noundef @.str.192) #12
  store ptr %call58, ptr %p, align 8
  %tobool59 = icmp ne ptr %call58, null
  br i1 %tobool59, label %if.then60, label %if.else81

if.then60:                                        ; preds = %if.then57
  %59 = load ptr, ptr %p, align 8
  store i8 0, ptr %59, align 1
  %60 = load ptr, ptr %p, align 8
  %add.ptr61 = getelementptr inbounds i8, ptr %60, i64 3
  store ptr %add.ptr61, ptr %p, align 8
  %61 = load ptr, ptr %p, align 8
  %call62 = call ptr @strchr(ptr noundef %61, i32 noundef 93) #12
  store ptr %call62, ptr %closing_bracket, align 8
  %62 = load ptr, ptr %closing_bracket, align 8
  %tobool63 = icmp ne ptr %62, null
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.then60
  %63 = load ptr, ptr %closing_bracket, align 8
  store i8 0, ptr %63, align 1
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.then60
  %64 = load ptr, ptr %slotsdef, align 8
  %call66 = call ptr @hi_sdsnew(ptr noundef %64)
  store ptr %call66, ptr %slot, align 8
  %65 = load ptr, ptr %p, align 8
  %call67 = call ptr @hi_sdsnew(ptr noundef %65)
  store ptr %call67, ptr %dst, align 8
  %66 = load ptr, ptr %node.addr, align 8
  %migrating_count = getelementptr inbounds %struct.clusterManagerNode, ptr %66, i32 0, i32 18
  %67 = load i32, ptr %migrating_count, align 8
  %add = add nsw i32 %67, 2
  store i32 %add, ptr %migrating_count, align 8
  %68 = load ptr, ptr %node.addr, align 8
  %migrating = getelementptr inbounds %struct.clusterManagerNode, ptr %68, i32 0, i32 16
  %69 = load ptr, ptr %migrating, align 8
  %70 = load ptr, ptr %node.addr, align 8
  %migrating_count68 = getelementptr inbounds %struct.clusterManagerNode, ptr %70, i32 0, i32 18
  %71 = load i32, ptr %migrating_count68, align 8
  %conv69 = sext i32 %71 to i64
  %mul = mul i64 %conv69, 8
  %call70 = call ptr @zrealloc(ptr noundef %69, i64 noundef %mul) #13
  %72 = load ptr, ptr %node.addr, align 8
  %migrating71 = getelementptr inbounds %struct.clusterManagerNode, ptr %72, i32 0, i32 16
  store ptr %call70, ptr %migrating71, align 8
  %73 = load ptr, ptr %slot, align 8
  %74 = load ptr, ptr %node.addr, align 8
  %migrating72 = getelementptr inbounds %struct.clusterManagerNode, ptr %74, i32 0, i32 16
  %75 = load ptr, ptr %migrating72, align 8
  %76 = load ptr, ptr %node.addr, align 8
  %migrating_count73 = getelementptr inbounds %struct.clusterManagerNode, ptr %76, i32 0, i32 18
  %77 = load i32, ptr %migrating_count73, align 8
  %sub74 = sub nsw i32 %77, 2
  %idxprom = sext i32 %sub74 to i64
  %arrayidx75 = getelementptr inbounds ptr, ptr %75, i64 %idxprom
  store ptr %73, ptr %arrayidx75, align 8
  %78 = load ptr, ptr %dst, align 8
  %79 = load ptr, ptr %node.addr, align 8
  %migrating76 = getelementptr inbounds %struct.clusterManagerNode, ptr %79, i32 0, i32 16
  %80 = load ptr, ptr %migrating76, align 8
  %81 = load ptr, ptr %node.addr, align 8
  %migrating_count77 = getelementptr inbounds %struct.clusterManagerNode, ptr %81, i32 0, i32 18
  %82 = load i32, ptr %migrating_count77, align 8
  %sub78 = sub nsw i32 %82, 1
  %idxprom79 = sext i32 %sub78 to i64
  %arrayidx80 = getelementptr inbounds ptr, ptr %80, i64 %idxprom79
  store ptr %78, ptr %arrayidx80, align 8
  br label %if.end111

if.else81:                                        ; preds = %if.then57
  %83 = load ptr, ptr %slotsdef, align 8
  %call82 = call ptr @strstr(ptr noundef %83, ptr noundef @.str.193) #12
  store ptr %call82, ptr %p, align 8
  %tobool83 = icmp ne ptr %call82, null
  br i1 %tobool83, label %if.then84, label %if.end110

if.then84:                                        ; preds = %if.else81
  %84 = load ptr, ptr %p, align 8
  store i8 0, ptr %84, align 1
  %85 = load ptr, ptr %p, align 8
  %add.ptr85 = getelementptr inbounds i8, ptr %85, i64 3
  store ptr %add.ptr85, ptr %p, align 8
  %86 = load ptr, ptr %p, align 8
  %call87 = call ptr @strchr(ptr noundef %86, i32 noundef 93) #12
  store ptr %call87, ptr %closing_bracket86, align 8
  %87 = load ptr, ptr %closing_bracket86, align 8
  %tobool88 = icmp ne ptr %87, null
  br i1 %tobool88, label %if.then89, label %if.end90

if.then89:                                        ; preds = %if.then84
  %88 = load ptr, ptr %closing_bracket86, align 8
  store i8 0, ptr %88, align 1
  br label %if.end90

if.end90:                                         ; preds = %if.then89, %if.then84
  %89 = load ptr, ptr %slotsdef, align 8
  %call92 = call ptr @hi_sdsnew(ptr noundef %89)
  store ptr %call92, ptr %slot91, align 8
  %90 = load ptr, ptr %p, align 8
  %call93 = call ptr @hi_sdsnew(ptr noundef %90)
  store ptr %call93, ptr %src, align 8
  %91 = load ptr, ptr %node.addr, align 8
  %importing_count = getelementptr inbounds %struct.clusterManagerNode, ptr %91, i32 0, i32 19
  %92 = load i32, ptr %importing_count, align 4
  %add94 = add nsw i32 %92, 2
  store i32 %add94, ptr %importing_count, align 4
  %93 = load ptr, ptr %node.addr, align 8
  %importing = getelementptr inbounds %struct.clusterManagerNode, ptr %93, i32 0, i32 17
  %94 = load ptr, ptr %importing, align 8
  %95 = load ptr, ptr %node.addr, align 8
  %importing_count95 = getelementptr inbounds %struct.clusterManagerNode, ptr %95, i32 0, i32 19
  %96 = load i32, ptr %importing_count95, align 4
  %conv96 = sext i32 %96 to i64
  %mul97 = mul i64 %conv96, 8
  %call98 = call ptr @zrealloc(ptr noundef %94, i64 noundef %mul97) #13
  %97 = load ptr, ptr %node.addr, align 8
  %importing99 = getelementptr inbounds %struct.clusterManagerNode, ptr %97, i32 0, i32 17
  store ptr %call98, ptr %importing99, align 8
  %98 = load ptr, ptr %slot91, align 8
  %99 = load ptr, ptr %node.addr, align 8
  %importing100 = getelementptr inbounds %struct.clusterManagerNode, ptr %99, i32 0, i32 17
  %100 = load ptr, ptr %importing100, align 8
  %101 = load ptr, ptr %node.addr, align 8
  %importing_count101 = getelementptr inbounds %struct.clusterManagerNode, ptr %101, i32 0, i32 19
  %102 = load i32, ptr %importing_count101, align 4
  %sub102 = sub nsw i32 %102, 2
  %idxprom103 = sext i32 %sub102 to i64
  %arrayidx104 = getelementptr inbounds ptr, ptr %100, i64 %idxprom103
  store ptr %98, ptr %arrayidx104, align 8
  %103 = load ptr, ptr %src, align 8
  %104 = load ptr, ptr %node.addr, align 8
  %importing105 = getelementptr inbounds %struct.clusterManagerNode, ptr %104, i32 0, i32 17
  %105 = load ptr, ptr %importing105, align 8
  %106 = load ptr, ptr %node.addr, align 8
  %importing_count106 = getelementptr inbounds %struct.clusterManagerNode, ptr %106, i32 0, i32 19
  %107 = load i32, ptr %importing_count106, align 4
  %sub107 = sub nsw i32 %107, 1
  %idxprom108 = sext i32 %sub107 to i64
  %arrayidx109 = getelementptr inbounds ptr, ptr %105, i64 %idxprom108
  store ptr %103, ptr %arrayidx109, align 8
  br label %if.end110

if.end110:                                        ; preds = %if.end90, %if.else81
  br label %if.end111

if.end111:                                        ; preds = %if.end110, %if.end65
  br label %if.end143

if.else112:                                       ; preds = %if.end53
  %108 = load ptr, ptr %slotsdef, align 8
  %call113 = call ptr @strchr(ptr noundef %108, i32 noundef 45) #12
  store ptr %call113, ptr %dash, align 8
  %cmp114 = icmp ne ptr %call113, null
  br i1 %cmp114, label %if.then116, label %if.else131

if.then116:                                       ; preds = %if.else112
  %109 = load ptr, ptr %dash, align 8
  store ptr %109, ptr %p, align 8
  %110 = load ptr, ptr %p, align 8
  store i8 0, ptr %110, align 1
  %111 = load ptr, ptr %slotsdef, align 8
  %call117 = call i32 @atoi(ptr noundef %111) #12
  store i32 %call117, ptr %start, align 4
  %112 = load ptr, ptr %p, align 8
  %add.ptr118 = getelementptr inbounds i8, ptr %112, i64 1
  %call119 = call i32 @atoi(ptr noundef %add.ptr118) #12
  store i32 %call119, ptr %stop, align 4
  %113 = load i32, ptr %stop, align 4
  %114 = load i32, ptr %start, align 4
  %sub120 = sub nsw i32 %114, 1
  %sub121 = sub nsw i32 %113, %sub120
  %115 = load ptr, ptr %node.addr, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %115, i32 0, i32 13
  %116 = load i32, ptr %slots_count, align 4
  %add122 = add nsw i32 %116, %sub121
  store i32 %add122, ptr %slots_count, align 4
  br label %while.cond123

while.cond123:                                    ; preds = %while.body126, %if.then116
  %117 = load i32, ptr %start, align 4
  %118 = load i32, ptr %stop, align 4
  %cmp124 = icmp sle i32 %117, %118
  br i1 %cmp124, label %while.body126, label %while.end130

while.body126:                                    ; preds = %while.cond123
  %119 = load ptr, ptr %node.addr, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %119, i32 0, i32 12
  %120 = load i32, ptr %start, align 4
  %inc127 = add nsw i32 %120, 1
  store i32 %inc127, ptr %start, align 4
  %idxprom128 = sext i32 %120 to i64
  %arrayidx129 = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom128
  store i8 1, ptr %arrayidx129, align 1
  br label %while.cond123, !llvm.loop !124

while.end130:                                     ; preds = %while.cond123
  br label %if.end142

if.else131:                                       ; preds = %if.else112
  %121 = load ptr, ptr %p, align 8
  %122 = load ptr, ptr %slotsdef, align 8
  %cmp132 = icmp ugt ptr %121, %122
  br i1 %cmp132, label %if.then134, label %if.end141

if.then134:                                       ; preds = %if.else131
  %123 = load ptr, ptr %node.addr, align 8
  %slots135 = getelementptr inbounds %struct.clusterManagerNode, ptr %123, i32 0, i32 12
  %124 = load ptr, ptr %slotsdef, align 8
  %call136 = call i32 @atoi(ptr noundef %124) #12
  %idxprom137 = sext i32 %call136 to i64
  %arrayidx138 = getelementptr inbounds [16384 x i8], ptr %slots135, i64 0, i64 %idxprom137
  store i8 1, ptr %arrayidx138, align 1
  %125 = load ptr, ptr %node.addr, align 8
  %slots_count139 = getelementptr inbounds %struct.clusterManagerNode, ptr %125, i32 0, i32 13
  %126 = load i32, ptr %slots_count139, align 4
  %inc140 = add nsw i32 %126, 1
  store i32 %inc140, ptr %slots_count139, align 4
  br label %if.end141

if.end141:                                        ; preds = %if.then134, %if.else131
  br label %if.end142

if.end142:                                        ; preds = %if.end141, %while.end130
  br label %if.end143

if.end143:                                        ; preds = %if.end142, %if.end111
  br label %while.cond38, !llvm.loop !125

while.end144:                                     ; preds = %while.cond38
  br label %if.end145

if.end145:                                        ; preds = %while.end144, %if.then30
  %127 = load ptr, ptr %node.addr, align 8
  %dirty = getelementptr inbounds %struct.clusterManagerNode, ptr %127, i32 0, i32 11
  store i32 0, ptr %dirty, align 8
  br label %if.end168

if.else146:                                       ; preds = %if.end26
  %128 = load i32, ptr %getfriends, align 4
  %tobool147 = icmp ne i32 %128, 0
  br i1 %tobool147, label %if.else154, label %if.then148

if.then148:                                       ; preds = %if.else146
  %129 = load ptr, ptr %node.addr, align 8
  %flags149 = getelementptr inbounds %struct.clusterManagerNode, ptr %129, i32 0, i32 8
  %130 = load i32, ptr %flags149, align 8
  %and150 = and i32 %130, 1
  %tobool151 = icmp ne i32 %and150, 0
  br i1 %tobool151, label %if.else153, label %if.then152

if.then152:                                       ; preds = %if.then148
  br label %while.cond, !llvm.loop !126

if.else153:                                       ; preds = %if.then148
  br label %while.end268

if.else154:                                       ; preds = %if.else146
  %131 = load ptr, ptr %ip, align 8
  %call155 = call ptr @hi_sdsnew(ptr noundef %131)
  %132 = load i32, ptr %port, align 4
  %133 = load i32, ptr %bus_port, align 4
  %call156 = call ptr @clusterManagerNewNode(ptr noundef %call155, i32 noundef %132, i32 noundef %133)
  store ptr %call156, ptr %currentNode, align 8
  %134 = load ptr, ptr %currentNode, align 8
  %flags157 = getelementptr inbounds %struct.clusterManagerNode, ptr %134, i32 0, i32 8
  %135 = load i32, ptr %flags157, align 8
  %or158 = or i32 %135, 4
  store i32 %or158, ptr %flags157, align 8
  %136 = load ptr, ptr %node.addr, align 8
  %friends = getelementptr inbounds %struct.clusterManagerNode, ptr %136, i32 0, i32 15
  %137 = load ptr, ptr %friends, align 8
  %cmp159 = icmp eq ptr %137, null
  br i1 %cmp159, label %if.then161, label %if.end164

if.then161:                                       ; preds = %if.else154
  %call162 = call ptr @listCreate()
  %138 = load ptr, ptr %node.addr, align 8
  %friends163 = getelementptr inbounds %struct.clusterManagerNode, ptr %138, i32 0, i32 15
  store ptr %call162, ptr %friends163, align 8
  br label %if.end164

if.end164:                                        ; preds = %if.then161, %if.else154
  %139 = load ptr, ptr %node.addr, align 8
  %friends165 = getelementptr inbounds %struct.clusterManagerNode, ptr %139, i32 0, i32 15
  %140 = load ptr, ptr %friends165, align 8
  %141 = load ptr, ptr %currentNode, align 8
  %call166 = call ptr @listAddNodeTail(ptr noundef %140, ptr noundef %141)
  br label %if.end167

if.end167:                                        ; preds = %if.end164
  br label %if.end168

if.end168:                                        ; preds = %if.end167, %if.end145
  %142 = load ptr, ptr %name, align 8
  %cmp169 = icmp ne ptr %142, null
  br i1 %cmp169, label %if.then171, label %if.end179

if.then171:                                       ; preds = %if.end168
  %143 = load ptr, ptr %currentNode, align 8
  %name172 = getelementptr inbounds %struct.clusterManagerNode, ptr %143, i32 0, i32 1
  %144 = load ptr, ptr %name172, align 8
  %tobool173 = icmp ne ptr %144, null
  br i1 %tobool173, label %if.then174, label %if.end176

if.then174:                                       ; preds = %if.then171
  %145 = load ptr, ptr %currentNode, align 8
  %name175 = getelementptr inbounds %struct.clusterManagerNode, ptr %145, i32 0, i32 1
  %146 = load ptr, ptr %name175, align 8
  call void @hi_sdsfree(ptr noundef %146)
  br label %if.end176

if.end176:                                        ; preds = %if.then174, %if.then171
  %147 = load ptr, ptr %name, align 8
  %call177 = call ptr @hi_sdsnew(ptr noundef %147)
  %148 = load ptr, ptr %currentNode, align 8
  %name178 = getelementptr inbounds %struct.clusterManagerNode, ptr %148, i32 0, i32 1
  store ptr %call177, ptr %name178, align 8
  br label %if.end179

if.end179:                                        ; preds = %if.end176, %if.end168
  %149 = load ptr, ptr %currentNode, align 8
  %flags_str = getelementptr inbounds %struct.clusterManagerNode, ptr %149, i32 0, i32 9
  %150 = load ptr, ptr %flags_str, align 8
  %cmp180 = icmp ne ptr %150, null
  br i1 %cmp180, label %if.then182, label %if.end184

if.then182:                                       ; preds = %if.end179
  %151 = load ptr, ptr %currentNode, align 8
  %flags_str183 = getelementptr inbounds %struct.clusterManagerNode, ptr %151, i32 0, i32 9
  %152 = load ptr, ptr %flags_str183, align 8
  call void @freeClusterManagerNodeFlags(ptr noundef %152)
  br label %if.end184

if.end184:                                        ; preds = %if.then182, %if.end179
  %call185 = call ptr @listCreate()
  %153 = load ptr, ptr %currentNode, align 8
  %flags_str186 = getelementptr inbounds %struct.clusterManagerNode, ptr %153, i32 0, i32 9
  store ptr %call185, ptr %flags_str186, align 8
  br label %while.cond187

while.cond187:                                    ; preds = %if.end243, %if.end184
  %154 = load ptr, ptr %flags, align 8
  %call188 = call i64 @strlen(ptr noundef %154) #12
  %conv189 = trunc i64 %call188 to i32
  store i32 %conv189, ptr %flag_len, align 4
  %cmp190 = icmp sgt i32 %conv189, 0
  br i1 %cmp190, label %while.body192, label %while.end246

while.body192:                                    ; preds = %while.cond187
  store ptr null, ptr %flag, align 8
  %155 = load ptr, ptr %flags, align 8
  %call193 = call ptr @strchr(ptr noundef %155, i32 noundef 44) #12
  store ptr %call193, ptr %fp, align 8
  %156 = load ptr, ptr %fp, align 8
  %tobool194 = icmp ne ptr %156, null
  br i1 %tobool194, label %if.then195, label %if.else198

if.then195:                                       ; preds = %while.body192
  %157 = load ptr, ptr %fp, align 8
  store i8 0, ptr %157, align 1
  %158 = load ptr, ptr %flags, align 8
  %call196 = call ptr @hi_sdsnew(ptr noundef %158)
  store ptr %call196, ptr %flag, align 8
  %159 = load ptr, ptr %fp, align 8
  %add.ptr197 = getelementptr inbounds i8, ptr %159, i64 1
  store ptr %add.ptr197, ptr %flags, align 8
  br label %if.end202

if.else198:                                       ; preds = %while.body192
  %160 = load ptr, ptr %flags, align 8
  %call199 = call ptr @hi_sdsnew(ptr noundef %160)
  store ptr %call199, ptr %flag, align 8
  %161 = load i32, ptr %flag_len, align 4
  %162 = load ptr, ptr %flags, align 8
  %idx.ext200 = sext i32 %161 to i64
  %add.ptr201 = getelementptr inbounds i8, ptr %162, i64 %idx.ext200
  store ptr %add.ptr201, ptr %flags, align 8
  br label %if.end202

if.end202:                                        ; preds = %if.else198, %if.then195
  %163 = load ptr, ptr %flag, align 8
  %call203 = call i32 @strcmp(ptr noundef %163, ptr noundef @.str.194) #12
  %cmp204 = icmp eq i32 %call203, 0
  br i1 %cmp204, label %if.then206, label %if.else209

if.then206:                                       ; preds = %if.end202
  %164 = load ptr, ptr %currentNode, align 8
  %flags207 = getelementptr inbounds %struct.clusterManagerNode, ptr %164, i32 0, i32 8
  %165 = load i32, ptr %flags207, align 8
  %or208 = or i32 %165, 8
  store i32 %or208, ptr %flags207, align 8
  br label %if.end243

if.else209:                                       ; preds = %if.end202
  %166 = load ptr, ptr %flag, align 8
  %call210 = call i32 @strcmp(ptr noundef %166, ptr noundef @.str.195) #12
  %cmp211 = icmp eq i32 %call210, 0
  br i1 %cmp211, label %if.then213, label %if.else216

if.then213:                                       ; preds = %if.else209
  %167 = load ptr, ptr %currentNode, align 8
  %flags214 = getelementptr inbounds %struct.clusterManagerNode, ptr %167, i32 0, i32 8
  %168 = load i32, ptr %flags214, align 8
  %or215 = or i32 %168, 16
  store i32 %or215, ptr %flags214, align 8
  br label %if.end242

if.else216:                                       ; preds = %if.else209
  %169 = load ptr, ptr %flag, align 8
  %call217 = call i32 @strcmp(ptr noundef %169, ptr noundef @.str.196) #12
  %cmp218 = icmp eq i32 %call217, 0
  br i1 %cmp218, label %if.then220, label %if.else223

if.then220:                                       ; preds = %if.else216
  %170 = load ptr, ptr %currentNode, align 8
  %flags221 = getelementptr inbounds %struct.clusterManagerNode, ptr %170, i32 0, i32 8
  %171 = load i32, ptr %flags221, align 8
  %or222 = or i32 %171, 32
  store i32 %or222, ptr %flags221, align 8
  br label %if.end241

if.else223:                                       ; preds = %if.else216
  %172 = load ptr, ptr %flag, align 8
  %call224 = call i32 @strcmp(ptr noundef %172, ptr noundef @.str.197) #12
  %cmp225 = icmp eq i32 %call224, 0
  br i1 %cmp225, label %if.then227, label %if.end240

if.then227:                                       ; preds = %if.else223
  %173 = load ptr, ptr %currentNode, align 8
  %flags228 = getelementptr inbounds %struct.clusterManagerNode, ptr %173, i32 0, i32 8
  %174 = load i32, ptr %flags228, align 8
  %or229 = or i32 %174, 2
  store i32 %or229, ptr %flags228, align 8
  %175 = load ptr, ptr %master_id, align 8
  %cmp230 = icmp ne ptr %175, null
  br i1 %cmp230, label %if.then232, label %if.end239

if.then232:                                       ; preds = %if.then227
  %176 = load ptr, ptr %currentNode, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %176, i32 0, i32 10
  %177 = load ptr, ptr %replicate, align 8
  %tobool233 = icmp ne ptr %177, null
  br i1 %tobool233, label %if.then234, label %if.end236

if.then234:                                       ; preds = %if.then232
  %178 = load ptr, ptr %currentNode, align 8
  %replicate235 = getelementptr inbounds %struct.clusterManagerNode, ptr %178, i32 0, i32 10
  %179 = load ptr, ptr %replicate235, align 8
  call void @hi_sdsfree(ptr noundef %179)
  br label %if.end236

if.end236:                                        ; preds = %if.then234, %if.then232
  %180 = load ptr, ptr %master_id, align 8
  %call237 = call ptr @hi_sdsnew(ptr noundef %180)
  %181 = load ptr, ptr %currentNode, align 8
  %replicate238 = getelementptr inbounds %struct.clusterManagerNode, ptr %181, i32 0, i32 10
  store ptr %call237, ptr %replicate238, align 8
  br label %if.end239

if.end239:                                        ; preds = %if.end236, %if.then227
  br label %if.end240

if.end240:                                        ; preds = %if.end239, %if.else223
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.then220
  br label %if.end242

if.end242:                                        ; preds = %if.end241, %if.then213
  br label %if.end243

if.end243:                                        ; preds = %if.end242, %if.then206
  %182 = load ptr, ptr %currentNode, align 8
  %flags_str244 = getelementptr inbounds %struct.clusterManagerNode, ptr %182, i32 0, i32 9
  %183 = load ptr, ptr %flags_str244, align 8
  %184 = load ptr, ptr %flag, align 8
  %call245 = call ptr @listAddNodeTail(ptr noundef %183, ptr noundef %184)
  br label %while.cond187, !llvm.loop !127

while.end246:                                     ; preds = %while.cond187
  %185 = load ptr, ptr %config_epoch, align 8
  %cmp247 = icmp ne ptr %185, null
  br i1 %cmp247, label %if.then249, label %if.end251

if.then249:                                       ; preds = %while.end246
  %186 = load ptr, ptr %config_epoch, align 8
  %call250 = call i64 @atoll(ptr noundef %186) #12
  %187 = load ptr, ptr %currentNode, align 8
  %current_epoch = getelementptr inbounds %struct.clusterManagerNode, ptr %187, i32 0, i32 5
  store i64 %call250, ptr %current_epoch, align 8
  br label %if.end251

if.end251:                                        ; preds = %if.then249, %while.end246
  %188 = load ptr, ptr %ping_sent, align 8
  %cmp252 = icmp ne ptr %188, null
  br i1 %cmp252, label %if.then254, label %if.end257

if.then254:                                       ; preds = %if.end251
  %189 = load ptr, ptr %ping_sent, align 8
  %call255 = call i64 @atoll(ptr noundef %189) #12
  %190 = load ptr, ptr %currentNode, align 8
  %ping_sent256 = getelementptr inbounds %struct.clusterManagerNode, ptr %190, i32 0, i32 6
  store i64 %call255, ptr %ping_sent256, align 8
  br label %if.end257

if.end257:                                        ; preds = %if.then254, %if.end251
  %191 = load ptr, ptr %ping_recv, align 8
  %cmp258 = icmp ne ptr %191, null
  br i1 %cmp258, label %if.then260, label %if.end263

if.then260:                                       ; preds = %if.end257
  %192 = load ptr, ptr %ping_recv, align 8
  %call261 = call i64 @atoll(ptr noundef %192) #12
  %193 = load ptr, ptr %currentNode, align 8
  %ping_recv262 = getelementptr inbounds %struct.clusterManagerNode, ptr %193, i32 0, i32 7
  store i64 %call261, ptr %ping_recv262, align 8
  br label %if.end263

if.end263:                                        ; preds = %if.then260, %if.end257
  %194 = load i32, ptr %getfriends, align 4
  %tobool264 = icmp ne i32 %194, 0
  br i1 %tobool264, label %if.end267, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end263
  %195 = load i32, ptr %myself, align 4
  %tobool265 = icmp ne i32 %195, 0
  br i1 %tobool265, label %if.then266, label %if.end267

if.then266:                                       ; preds = %land.lhs.true
  br label %while.end268

if.end267:                                        ; preds = %land.lhs.true, %if.end263
  br label %while.cond, !llvm.loop !126

while.end268:                                     ; preds = %if.then266, %if.else153, %while.cond
  br label %cleanup

cleanup:                                          ; preds = %while.end268, %if.then24, %if.then19, %if.then
  %196 = load ptr, ptr %reply, align 8
  %tobool269 = icmp ne ptr %196, null
  br i1 %tobool269, label %if.then270, label %if.end271

if.then270:                                       ; preds = %cleanup
  %197 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %197)
  br label %if.end271

if.end271:                                        ; preds = %if.then270, %cleanup
  %198 = load i32, ptr %success, align 4
  ret i32 %198
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerLog(i32 noundef %level, ptr noundef %fmt, ...) #0 {
entry:
  %level.addr = alloca i32, align 4
  %fmt.addr = alloca ptr, align 8
  %use_colors = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store i32 %level, ptr %level.addr, align 4
  store ptr %fmt, ptr %fmt.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %0, 256
  store i32 %and, ptr %use_colors, align 4
  %1 = load i32, ptr %use_colors, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.198)
  %2 = load i32, ptr %level.addr, align 4
  switch i32 %2, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb2
    i32 3, label %sw.bb4
    i32 4, label %sw.bb6
  ]

sw.bb:                                            ; preds = %if.then
  %call1 = call i32 (ptr, ...) @printf(ptr noundef @.str.199)
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.then
  %call3 = call i32 (ptr, ...) @printf(ptr noundef @.str.200)
  br label %sw.epilog

sw.bb4:                                           ; preds = %if.then
  %call5 = call i32 (ptr, ...) @printf(ptr noundef @.str.201)
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.then
  %call7 = call i32 (ptr, ...) @printf(ptr noundef @.str.202)
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  %call8 = call i32 (ptr, ...) @printf(ptr noundef @.str.203)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb4, %sw.bb2, %sw.bb
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %entry
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %3 = load ptr, ptr %fmt.addr, align 8
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call10 = call i32 @vprintf(ptr noundef %3, ptr noundef %arraydecay9)
  %arraydecay11 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay11)
  %4 = load i32, ptr %use_colors, align 4
  %tobool12 = icmp ne i32 %4, 0
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end
  %call14 = call i32 (ptr, ...) @printf(ptr noundef @.str.14)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerNodeIsEmpty(ptr noundef %node, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %node.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %info = alloca ptr, align 8
  %is_empty = alloca i32, align 4
  %known_nodes = alloca i64, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %1 = load ptr, ptr %err.addr, align 8
  %call = call ptr @clusterManagerGetNodeRedisInfo(ptr noundef %0, ptr noundef %1)
  store ptr %call, ptr %info, align 8
  store i32 1, ptr %is_empty, align 4
  %2 = load ptr, ptr %info, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %info, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %str, align 8
  %call1 = call ptr @strstr(ptr noundef %4, ptr noundef @.str.204) #12
  %cmp2 = icmp ne ptr %call1, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 0, ptr %is_empty, align 4
  br label %result

if.end4:                                          ; preds = %if.end
  %5 = load ptr, ptr %info, align 8
  call void @freeReplyObject(ptr noundef %5)
  %6 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %context, align 8
  %call5 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %7, ptr noundef @.str.205)
  store ptr %call5, ptr %info, align 8
  %8 = load ptr, ptr %err.addr, align 8
  %cmp6 = icmp ne ptr %8, null
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %9 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %9, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %10 = load ptr, ptr %node.addr, align 8
  %11 = load ptr, ptr %info, align 8
  %12 = load ptr, ptr %err.addr, align 8
  %call9 = call i32 @clusterManagerCheckRedisReply(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end8
  store i32 0, ptr %is_empty, align 4
  br label %result

if.end11:                                         ; preds = %if.end8
  %13 = load ptr, ptr %info, align 8
  %str12 = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %str12, align 8
  %call13 = call i64 @getLongInfoField(ptr noundef %14, ptr noundef @.str.206)
  store i64 %call13, ptr %known_nodes, align 8
  %15 = load i64, ptr %known_nodes, align 8
  %cmp14 = icmp eq i64 %15, 1
  %conv = zext i1 %cmp14 to i32
  store i32 %conv, ptr %is_empty, align 4
  br label %result

result:                                           ; preds = %if.end11, %if.then10, %if.then3
  %16 = load ptr, ptr %info, align 8
  call void @freeReplyObject(ptr noundef %16)
  %17 = load i32, ptr %is_empty, align 4
  store i32 %17, ptr %retval, align 4
  br label %return

return:                                           ; preds = %result, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerPrintNotEmptyNodeError(ptr noundef %node, ptr noundef %err) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %msg = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %err.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %err.addr, align 8
  store ptr %1, ptr %msg, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store ptr @.str.207, ptr %msg, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %2 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ip, align 8
  %4 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %port, align 8
  %6 = load ptr, ptr %msg, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.188, ptr noundef %3, i32 noundef %5, ptr noundef %6)
  ret void
}

declare ptr @listAddNodeTail(ptr noundef, ptr noundef) #2

declare void @listRewind(ptr noundef, ptr noundef) #2

declare ptr @listNext(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @clusterManagerNodeArrayInit(ptr noundef %array, i32 noundef %alloc_len) #0 {
entry:
  %array.addr = alloca ptr, align 8
  %alloc_len.addr = alloca i32, align 4
  store ptr %array, ptr %array.addr, align 8
  store i32 %alloc_len, ptr %alloc_len.addr, align 4
  %0 = load i32, ptr %alloc_len.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 %conv, 8
  %call = call noalias ptr @zcalloc(i64 noundef %mul) #14
  %1 = load ptr, ptr %array.addr, align 8
  %nodes = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %1, i32 0, i32 0
  store ptr %call, ptr %nodes, align 8
  %2 = load ptr, ptr %array.addr, align 8
  %nodes1 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %nodes1, align 8
  %4 = load ptr, ptr %array.addr, align 8
  %alloc = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %4, i32 0, i32 1
  store ptr %3, ptr %alloc, align 8
  %5 = load i32, ptr %alloc_len.addr, align 4
  %6 = load ptr, ptr %array.addr, align 8
  %len = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %6, i32 0, i32 2
  store i32 %5, ptr %len, align 8
  %7 = load ptr, ptr %array.addr, align 8
  %count = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %7, i32 0, i32 3
  store i32 0, ptr %count, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerNodeArrayAdd(ptr noundef %array, ptr noundef %node) #0 {
entry:
  %array.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  store ptr %array, ptr %array.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %1 = load ptr, ptr %array.addr, align 8
  %nodes = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %nodes, align 8
  %3 = load ptr, ptr %array.addr, align 8
  %count = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %count, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %count, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 %idxprom
  store ptr %0, ptr %arrayidx, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerNodeArrayShift(ptr noundef %array, ptr noundef %nodeptr) #0 {
entry:
  %array.addr = alloca ptr, align 8
  %nodeptr.addr = alloca ptr, align 8
  store ptr %array, ptr %array.addr, align 8
  store ptr %nodeptr, ptr %nodeptr.addr, align 8
  %0 = load ptr, ptr %array.addr, align 8
  %nodes = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %nodes, align 8
  %2 = load ptr, ptr %1, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %array.addr, align 8
  %count = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %count, align 4
  %dec = add nsw i32 %4, -1
  store i32 %dec, ptr %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %array.addr, align 8
  %nodes1 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %nodes1, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %nodeptr.addr, align 8
  store ptr %7, ptr %8, align 8
  %9 = load ptr, ptr %array.addr, align 8
  %nodes2 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %nodes2, align 8
  %incdec.ptr = getelementptr inbounds ptr, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %nodes2, align 8
  %11 = load ptr, ptr %array.addr, align 8
  %len = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %11, i32 0, i32 2
  %12 = load i32, ptr %len, align 8
  %dec3 = add nsw i32 %12, -1
  store i32 %dec3, ptr %len, align 8
  ret void
}

; Function Attrs: nounwind
declare i64 @lround(double noundef) #6

; Function Attrs: nounwind uwtable
define internal void @clusterManagerNodeArrayReset(ptr noundef %array) #0 {
entry:
  %array.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %array, ptr %array.addr, align 8
  %0 = load ptr, ptr %array.addr, align 8
  %nodes = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %nodes, align 8
  %2 = load ptr, ptr %array.addr, align 8
  %alloc = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %alloc, align 8
  %cmp = icmp ugt ptr %1, %3
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %array.addr, align 8
  %nodes1 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %nodes1, align 8
  %6 = load ptr, ptr %array.addr, align 8
  %alloc2 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %alloc2, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  %8 = load ptr, ptr %array.addr, align 8
  %len = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %8, i32 0, i32 2
  store i32 %conv, ptr %len, align 8
  %9 = load ptr, ptr %array.addr, align 8
  %alloc3 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %alloc3, align 8
  %11 = load ptr, ptr %array.addr, align 8
  %nodes4 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %11, i32 0, i32 0
  store ptr %10, ptr %nodes4, align 8
  %12 = load ptr, ptr %array.addr, align 8
  %count = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %12, i32 0, i32 3
  store i32 0, ptr %count, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %13 = load i32, ptr %i, align 4
  %14 = load ptr, ptr %array.addr, align 8
  %len5 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %14, i32 0, i32 2
  %15 = load i32, ptr %len5, align 8
  %cmp6 = icmp slt i32 %13, %15
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load ptr, ptr %array.addr, align 8
  %nodes8 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %nodes8, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom = sext i32 %18 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %17, i64 %idxprom
  %19 = load ptr, ptr %arrayidx, align 8
  %cmp9 = icmp ne ptr %19, null
  br i1 %cmp9, label %if.then11, label %if.end

if.then11:                                        ; preds = %for.body
  %20 = load ptr, ptr %array.addr, align 8
  %count12 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %20, i32 0, i32 3
  %21 = load i32, ptr %count12, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, ptr %count12, align 4
  br label %if.end

if.end:                                           ; preds = %if.then11, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i32, ptr %i, align 4
  %inc13 = add nsw i32 %22, 1
  store i32 %inc13, ptr %i, align 4
  br label %for.cond, !llvm.loop !128

for.end:                                          ; preds = %for.cond
  br label %if.end14

if.end14:                                         ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerOptimizeAntiAffinity(ptr noundef %ipnodes, i32 noundef %ip_count) #0 {
entry:
  %ipnodes.addr = alloca ptr, align 8
  %ip_count.addr = alloca i32, align 4
  %offenders = alloca ptr, align 8
  %score = alloca i32, align 4
  %node_len = alloca i32, align 4
  %maxiter = alloca i32, align 4
  %offending_len = alloca i32, align 4
  %rand_idx = alloca i32, align 4
  %first = alloca ptr, align 8
  %second = alloca ptr, align 8
  %other_replicas = alloca ptr, align 8
  %other_replicas_count = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %first_master = alloca ptr, align 8
  %second_master = alloca ptr, align 8
  %new_score = alloca i32, align 4
  %msg = alloca ptr, align 8
  %perfect = alloca i32, align 4
  %log_level = alloca i32, align 4
  store ptr %ipnodes, ptr %ipnodes.addr, align 8
  store i32 %ip_count, ptr %ip_count.addr, align 4
  store ptr null, ptr %offenders, align 8
  %0 = load ptr, ptr %ipnodes.addr, align 8
  %1 = load i32, ptr %ip_count.addr, align 4
  %call = call i32 @clusterManagerGetAntiAffinityScore(ptr noundef %0, i32 noundef %1, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %score, align 4
  %2 = load i32, ptr %score, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %cleanup

if.end:                                           ; preds = %entry
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.208)
  %3 = load ptr, ptr @cluster_manager, align 8
  %len = getelementptr inbounds %struct.list, ptr %3, i32 0, i32 5
  %4 = load i64, ptr %len, align 8
  %conv = trunc i64 %4 to i32
  store i32 %conv, ptr %node_len, align 4
  %5 = load i32, ptr %node_len, align 4
  %mul = mul nsw i32 500, %5
  store i32 %mul, ptr %maxiter, align 4
  %call1 = call i64 @time(ptr noundef null) #15
  %conv2 = trunc i64 %call1 to i32
  call void @srand(i32 noundef %conv2) #15
  br label %while.cond

while.cond:                                       ; preds = %if.end52, %if.end
  %6 = load i32, ptr %maxiter, align 4
  %cmp3 = icmp sgt i32 %6, 0
  br i1 %cmp3, label %while.body, label %while.end53

while.body:                                       ; preds = %while.cond
  store i32 0, ptr %offending_len, align 4
  %7 = load ptr, ptr %offenders, align 8
  %cmp5 = icmp ne ptr %7, null
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %while.body
  %8 = load ptr, ptr %offenders, align 8
  call void @zfree(ptr noundef %8)
  store ptr null, ptr %offenders, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %while.body
  %9 = load ptr, ptr %ipnodes.addr, align 8
  %10 = load i32, ptr %ip_count.addr, align 4
  %call9 = call i32 @clusterManagerGetAntiAffinityScore(ptr noundef %9, i32 noundef %10, ptr noundef %offenders, ptr noundef %offending_len)
  store i32 %call9, ptr %score, align 4
  %11 = load i32, ptr %score, align 4
  %cmp10 = icmp eq i32 %11, 0
  br i1 %cmp10, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end8
  %12 = load i32, ptr %offending_len, align 4
  %cmp12 = icmp eq i32 %12, 0
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %lor.lhs.false, %if.end8
  br label %while.end53

if.end15:                                         ; preds = %lor.lhs.false
  %call16 = call i32 @rand() #15
  %13 = load i32, ptr %offending_len, align 4
  %rem = srem i32 %call16, %13
  store i32 %rem, ptr %rand_idx, align 4
  %14 = load ptr, ptr %offenders, align 8
  %15 = load i32, ptr %rand_idx, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %14, i64 %idxprom
  %16 = load ptr, ptr %arrayidx, align 8
  store ptr %16, ptr %first, align 8
  store ptr null, ptr %second, align 8
  %17 = load i32, ptr %node_len, align 4
  %sub = sub nsw i32 %17, 1
  %conv17 = sext i32 %sub to i64
  %mul18 = mul i64 %conv17, 8
  %call19 = call noalias ptr @zcalloc(i64 noundef %mul18) #14
  store ptr %call19, ptr %other_replicas, align 8
  store i32 0, ptr %other_replicas_count, align 4
  %18 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %18, ptr noundef %li)
  br label %while.cond20

while.cond20:                                     ; preds = %if.end32, %if.end15
  %call21 = call ptr @listNext(ptr noundef %li)
  store ptr %call21, ptr %ln, align 8
  %cmp22 = icmp ne ptr %call21, null
  br i1 %cmp22, label %while.body24, label %while.end

while.body24:                                     ; preds = %while.cond20
  %19 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %value, align 8
  store ptr %20, ptr %n, align 8
  %21 = load ptr, ptr %n, align 8
  %22 = load ptr, ptr %first, align 8
  %cmp25 = icmp ne ptr %21, %22
  br i1 %cmp25, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %while.body24
  %23 = load ptr, ptr %n, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %23, i32 0, i32 10
  %24 = load ptr, ptr %replicate, align 8
  %cmp27 = icmp ne ptr %24, null
  br i1 %cmp27, label %if.then29, label %if.end32

if.then29:                                        ; preds = %land.lhs.true
  %25 = load ptr, ptr %n, align 8
  %26 = load ptr, ptr %other_replicas, align 8
  %27 = load i32, ptr %other_replicas_count, align 4
  %inc = add nsw i32 %27, 1
  store i32 %inc, ptr %other_replicas_count, align 4
  %idxprom30 = sext i32 %27 to i64
  %arrayidx31 = getelementptr inbounds ptr, ptr %26, i64 %idxprom30
  store ptr %25, ptr %arrayidx31, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then29, %land.lhs.true, %while.body24
  br label %while.cond20, !llvm.loop !129

while.end:                                        ; preds = %while.cond20
  %28 = load i32, ptr %other_replicas_count, align 4
  %cmp33 = icmp eq i32 %28, 0
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %while.end
  %29 = load ptr, ptr %other_replicas, align 8
  call void @zfree(ptr noundef %29)
  br label %while.end53

if.end36:                                         ; preds = %while.end
  %call37 = call i32 @rand() #15
  %30 = load i32, ptr %other_replicas_count, align 4
  %rem38 = srem i32 %call37, %30
  store i32 %rem38, ptr %rand_idx, align 4
  %31 = load ptr, ptr %other_replicas, align 8
  %32 = load i32, ptr %rand_idx, align 4
  %idxprom39 = sext i32 %32 to i64
  %arrayidx40 = getelementptr inbounds ptr, ptr %31, i64 %idxprom39
  %33 = load ptr, ptr %arrayidx40, align 8
  store ptr %33, ptr %second, align 8
  %34 = load ptr, ptr %first, align 8
  %replicate41 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 10
  %35 = load ptr, ptr %replicate41, align 8
  store ptr %35, ptr %first_master, align 8
  %36 = load ptr, ptr %second, align 8
  %replicate42 = getelementptr inbounds %struct.clusterManagerNode, ptr %36, i32 0, i32 10
  %37 = load ptr, ptr %replicate42, align 8
  store ptr %37, ptr %second_master, align 8
  %38 = load ptr, ptr %second_master, align 8
  %39 = load ptr, ptr %first, align 8
  %replicate43 = getelementptr inbounds %struct.clusterManagerNode, ptr %39, i32 0, i32 10
  store ptr %38, ptr %replicate43, align 8
  %40 = load ptr, ptr %first, align 8
  %dirty = getelementptr inbounds %struct.clusterManagerNode, ptr %40, i32 0, i32 11
  store i32 1, ptr %dirty, align 8
  %41 = load ptr, ptr %first_master, align 8
  %42 = load ptr, ptr %second, align 8
  %replicate44 = getelementptr inbounds %struct.clusterManagerNode, ptr %42, i32 0, i32 10
  store ptr %41, ptr %replicate44, align 8
  %43 = load ptr, ptr %second, align 8
  %dirty45 = getelementptr inbounds %struct.clusterManagerNode, ptr %43, i32 0, i32 11
  store i32 1, ptr %dirty45, align 8
  %44 = load ptr, ptr %ipnodes.addr, align 8
  %45 = load i32, ptr %ip_count.addr, align 4
  %call46 = call i32 @clusterManagerGetAntiAffinityScore(ptr noundef %44, i32 noundef %45, ptr noundef null, ptr noundef null)
  store i32 %call46, ptr %new_score, align 4
  %46 = load i32, ptr %new_score, align 4
  %47 = load i32, ptr %score, align 4
  %cmp47 = icmp sgt i32 %46, %47
  br i1 %cmp47, label %if.then49, label %if.end52

if.then49:                                        ; preds = %if.end36
  %48 = load ptr, ptr %first_master, align 8
  %49 = load ptr, ptr %first, align 8
  %replicate50 = getelementptr inbounds %struct.clusterManagerNode, ptr %49, i32 0, i32 10
  store ptr %48, ptr %replicate50, align 8
  %50 = load ptr, ptr %second_master, align 8
  %51 = load ptr, ptr %second, align 8
  %replicate51 = getelementptr inbounds %struct.clusterManagerNode, ptr %51, i32 0, i32 10
  store ptr %50, ptr %replicate51, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.then49, %if.end36
  %52 = load ptr, ptr %other_replicas, align 8
  call void @zfree(ptr noundef %52)
  %53 = load i32, ptr %maxiter, align 4
  %dec = add nsw i32 %53, -1
  store i32 %dec, ptr %maxiter, align 4
  br label %while.cond, !llvm.loop !130

while.end53:                                      ; preds = %if.then35, %if.then14, %while.cond
  %54 = load ptr, ptr %ipnodes.addr, align 8
  %55 = load i32, ptr %ip_count.addr, align 4
  %call54 = call i32 @clusterManagerGetAntiAffinityScore(ptr noundef %54, i32 noundef %55, ptr noundef null, ptr noundef null)
  store i32 %call54, ptr %score, align 4
  %56 = load i32, ptr %score, align 4
  %cmp55 = icmp eq i32 %56, 0
  %conv56 = zext i1 %cmp55 to i32
  store i32 %conv56, ptr %perfect, align 4
  %57 = load i32, ptr %perfect, align 4
  %tobool = icmp ne i32 %57, 0
  %cond = select i1 %tobool, i32 4, i32 2
  store i32 %cond, ptr %log_level, align 4
  %58 = load i32, ptr %perfect, align 4
  %tobool57 = icmp ne i32 %58, 0
  br i1 %tobool57, label %if.then58, label %if.else

if.then58:                                        ; preds = %while.end53
  store ptr @.str.209, ptr %msg, align 8
  br label %if.end64

if.else:                                          ; preds = %while.end53
  %59 = load i32, ptr %score, align 4
  %cmp59 = icmp sge i32 %59, 10000
  br i1 %cmp59, label %if.then61, label %if.else62

if.then61:                                        ; preds = %if.else
  store ptr @.str.210, ptr %msg, align 8
  br label %if.end63

if.else62:                                        ; preds = %if.else
  store ptr @.str.211, ptr %msg, align 8
  br label %if.end63

if.end63:                                         ; preds = %if.else62, %if.then61
  br label %if.end64

if.end64:                                         ; preds = %if.end63, %if.then58
  %60 = load i32, ptr %log_level, align 4
  %61 = load ptr, ptr %msg, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef %60, ptr noundef @.str.115, ptr noundef %61)
  br label %cleanup

cleanup:                                          ; preds = %if.end64, %if.then
  %62 = load ptr, ptr %offenders, align 8
  call void @zfree(ptr noundef %62)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerShowNodes() #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %node = alloca ptr, align 8
  %info = alloca ptr, align 8
  %0 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %node, align 8
  %3 = load ptr, ptr %node, align 8
  %call1 = call ptr @clusterManagerNodeInfo(ptr noundef %3, i32 noundef 0)
  store ptr %call1, ptr %info, align 8
  %4 = load ptr, ptr %info, align 8
  %call2 = call i32 (ptr, ...) @printf(ptr noundef @.str.115, ptr noundef %4)
  %5 = load ptr, ptr %info, align 8
  call void @hi_sdsfree(ptr noundef %5)
  br label %while.cond, !llvm.loop !131

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @confirmWithYes(ptr noundef %msg, i32 noundef %ignore_force) #0 {
entry:
  %retval = alloca i32, align 4
  %msg.addr = alloca ptr, align 8
  %ignore_force.addr = alloca i32, align 4
  %buf = alloca [4 x i8], align 1
  %nread = alloca i32, align 4
  store ptr %msg, ptr %msg.addr, align 8
  store i32 %ignore_force, ptr %ignore_force.addr, align 4
  %0 = load i32, ptr %ignore_force.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %1, 4
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %msg.addr, align 8
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.224, ptr noundef %2)
  %3 = load ptr, ptr @stdout, align 8
  %call2 = call i32 @fflush(ptr noundef %3)
  %4 = load ptr, ptr @stdin, align 8
  %call3 = call i32 @fileno(ptr noundef %4) #15
  %arraydecay = getelementptr inbounds [4 x i8], ptr %buf, i64 0, i64 0
  %call4 = call i64 @read(i32 noundef %call3, ptr noundef %arraydecay, i64 noundef 4)
  %conv = trunc i64 %call4 to i32
  store i32 %conv, ptr %nread, align 4
  %arrayidx = getelementptr inbounds [4 x i8], ptr %buf, i64 0, i64 3
  store i8 0, ptr %arrayidx, align 1
  %5 = load i32, ptr %nread, align 4
  %cmp = icmp ne i32 %5, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %arraydecay6 = getelementptr inbounds [4 x i8], ptr %buf, i64 0, i64 0
  %call7 = call i32 @strcmp(ptr noundef @.str.225, ptr noundef %arraydecay6) #12
  %tobool8 = icmp ne i32 %call7, 0
  %lnot = xor i1 %tobool8, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %6 = phi i1 [ false, %if.end ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %6 to i32
  store i32 %land.ext, ptr %retval, align 4
  br label %return

return:                                           ; preds = %land.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerFlushNodeConfig(ptr noundef %node, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %node.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %is_err = alloca i32, align 4
  %success = alloca i32, align 4
  %added = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %dirty = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %dirty, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %reply, align 8
  store i32 0, ptr %is_err, align 4
  store i32 1, ptr %success, align 4
  %2 = load ptr, ptr %err.addr, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %3 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %3, align 8
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %4 = load ptr, ptr %node.addr, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 10
  %5 = load ptr, ptr %replicate, align 8
  %cmp3 = icmp ne ptr %5, null
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end2
  %6 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %context, align 8
  %8 = load ptr, ptr %node.addr, align 8
  %replicate5 = getelementptr inbounds %struct.clusterManagerNode, ptr %8, i32 0, i32 10
  %9 = load ptr, ptr %replicate5, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %7, ptr noundef @.str.226, ptr noundef %9)
  store ptr %call, ptr %reply, align 8
  %10 = load ptr, ptr %reply, align 8
  %cmp6 = icmp eq ptr %10, null
  br i1 %cmp6, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then4
  %11 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type, align 8
  %cmp7 = icmp eq i32 %12, 6
  %conv = zext i1 %cmp7 to i32
  store i32 %conv, ptr %is_err, align 4
  br i1 %cmp7, label %if.then8, label %if.end18

if.then8:                                         ; preds = %lor.lhs.false, %if.then4
  %13 = load i32, ptr %is_err, align 4
  %tobool9 = icmp ne i32 %13, 0
  br i1 %tobool9, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then8
  %14 = load ptr, ptr %err.addr, align 8
  %cmp10 = icmp ne ptr %14, null
  br i1 %cmp10, label %if.then12, label %if.end17

if.then12:                                        ; preds = %land.lhs.true
  %15 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 3
  %16 = load i64, ptr %len, align 8
  %add = add i64 %16, 1
  %mul = mul i64 %add, 1
  %call13 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  %17 = load ptr, ptr %err.addr, align 8
  store ptr %call13, ptr %17, align 8
  %18 = load ptr, ptr %err.addr, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %20, i32 0, i32 4
  %21 = load ptr, ptr %str, align 8
  %22 = load ptr, ptr %reply, align 8
  %len14 = getelementptr inbounds %struct.redisReply, ptr %22, i32 0, i32 3
  %23 = load i64, ptr %len14, align 8
  %add15 = add i64 %23, 1
  %call16 = call i64 @redis_strlcpy(ptr noundef %19, ptr noundef %21, i64 noundef %add15)
  br label %if.end17

if.end17:                                         ; preds = %if.then12, %land.lhs.true, %if.then8
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end18:                                         ; preds = %lor.lhs.false
  br label %if.end26

if.else:                                          ; preds = %if.end2
  %24 = load ptr, ptr %node.addr, align 8
  %25 = load ptr, ptr %err.addr, align 8
  %call19 = call i32 @clusterManagerAddSlots(ptr noundef %24, ptr noundef %25)
  store i32 %call19, ptr %added, align 4
  %26 = load i32, ptr %added, align 4
  %tobool20 = icmp ne i32 %26, 0
  br i1 %tobool20, label %lor.lhs.false21, label %if.then24

lor.lhs.false21:                                  ; preds = %if.else
  %27 = load ptr, ptr %err.addr, align 8
  %28 = load ptr, ptr %27, align 8
  %cmp22 = icmp ne ptr %28, null
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %lor.lhs.false21, %if.else
  store i32 0, ptr %success, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %lor.lhs.false21
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end18
  %29 = load ptr, ptr %node.addr, align 8
  %dirty27 = getelementptr inbounds %struct.clusterManagerNode, ptr %29, i32 0, i32 11
  store i32 0, ptr %dirty27, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %if.end17
  %30 = load ptr, ptr %reply, align 8
  %cmp28 = icmp ne ptr %30, null
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %cleanup
  %31 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %31)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %cleanup
  %32 = load i32, ptr %success, align 4
  store i32 %32, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end31, %if.then
  %33 = load i32, ptr %retval, align 4
  ret i32 %33
}

declare i32 @anetResolve(ptr noundef, ptr noundef, ptr noundef, i64 noundef, i32 noundef) #2

declare i32 @sleep(i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal void @clusterManagerWaitForClusterJoin() #0 {
entry:
  %counter = alloca i32, align 4
  %check_after = alloca i32, align 4
  %status = alloca ptr, align 8
  %iter = alloca ptr, align 8
  %entry23 = alloca ptr, align 8
  %nodeaddr = alloca ptr, align 8
  %node_ip = alloca ptr, align 8
  %node_port = alloca i32, align 4
  %node_bus_port = alloca i32, align 4
  %from = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %from_addr = alloca ptr, align 8
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.229)
  store i32 0, ptr %counter, align 4
  %0 = load ptr, ptr @cluster_manager, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %conv = uitofp i64 %1 to float
  %mul = fmul float %conv, 0x3FC3333340000000
  %conv1 = fptosi float %mul to i32
  %add = add nsw i32 20, %conv1
  store i32 %add, ptr %check_after, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end51, %entry
  %call2 = call i32 @clusterManagerIsConfigConsistent()
  %tobool = icmp ne i32 %call2, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end52

while.body:                                       ; preds = %while.cond
  %call3 = call i32 (ptr, ...) @printf(ptr noundef @.str.230)
  %2 = load ptr, ptr @stdout, align 8
  %call4 = call i32 @fflush(ptr noundef %2)
  %call5 = call i32 @sleep(i32 noundef 1)
  %3 = load i32, ptr %counter, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %counter, align 4
  %4 = load i32, ptr %check_after, align 4
  %cmp = icmp sgt i32 %inc, %4
  br i1 %cmp, label %if.then, label %if.end51

if.then:                                          ; preds = %while.body
  %call7 = call ptr @clusterManagerGetLinkStatus()
  store ptr %call7, ptr %status, align 8
  store ptr null, ptr %iter, align 8
  %5 = load ptr, ptr %status, align 8
  %cmp8 = icmp ne ptr %5, null
  br i1 %cmp8, label %land.lhs.true, label %if.end42

land.lhs.true:                                    ; preds = %if.then
  %6 = load ptr, ptr %status, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %6, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %7 = load i64, ptr %arrayidx, align 8
  %8 = load ptr, ptr %status, align 8
  %ht_used10 = getelementptr inbounds %struct.dict, ptr %8, i32 0, i32 2
  %arrayidx11 = getelementptr inbounds [2 x i64], ptr %ht_used10, i64 0, i64 1
  %9 = load i64, ptr %arrayidx11, align 8
  %add12 = add i64 %7, %9
  %cmp13 = icmp ugt i64 %add12, 0
  br i1 %cmp13, label %if.then15, label %if.end42

if.then15:                                        ; preds = %land.lhs.true
  %call16 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  %10 = load ptr, ptr %status, align 8
  %ht_used17 = getelementptr inbounds %struct.dict, ptr %10, i32 0, i32 2
  %arrayidx18 = getelementptr inbounds [2 x i64], ptr %ht_used17, i64 0, i64 0
  %11 = load i64, ptr %arrayidx18, align 8
  %12 = load ptr, ptr %status, align 8
  %ht_used19 = getelementptr inbounds %struct.dict, ptr %12, i32 0, i32 2
  %arrayidx20 = getelementptr inbounds [2 x i64], ptr %ht_used19, i64 0, i64 1
  %13 = load i64, ptr %arrayidx20, align 8
  %add21 = add i64 %11, %13
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.231, i64 noundef %add21)
  %14 = load ptr, ptr %status, align 8
  %call22 = call ptr @dictGetIterator(ptr noundef %14)
  store ptr %call22, ptr %iter, align 8
  br label %while.cond24

while.cond24:                                     ; preds = %while.end, %if.then15
  %15 = load ptr, ptr %iter, align 8
  %call25 = call ptr @dictNext(ptr noundef %15)
  store ptr %call25, ptr %entry23, align 8
  %cmp26 = icmp ne ptr %call25, null
  br i1 %cmp26, label %while.body28, label %while.end41

while.body28:                                     ; preds = %while.cond24
  %16 = load ptr, ptr %entry23, align 8
  %call29 = call ptr @dictGetKey(ptr noundef %16)
  store ptr %call29, ptr %nodeaddr, align 8
  store ptr null, ptr %node_ip, align 8
  store i32 0, ptr %node_port, align 4
  store i32 0, ptr %node_bus_port, align 4
  %17 = load ptr, ptr %entry23, align 8
  %call30 = call ptr @dictGetVal(ptr noundef %17)
  store ptr %call30, ptr %from, align 8
  %18 = load ptr, ptr %nodeaddr, align 8
  %call31 = call i32 @parseClusterNodeAddress(ptr noundef %18, ptr noundef %node_ip, ptr noundef %node_port, ptr noundef %node_bus_port)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %land.lhs.true33, label %if.else

land.lhs.true33:                                  ; preds = %while.body28
  %19 = load i32, ptr %node_bus_port, align 4
  %tobool34 = icmp ne i32 %19, 0
  br i1 %tobool34, label %if.then35, label %if.else

if.then35:                                        ; preds = %land.lhs.true33
  %20 = load i32, ptr %node_bus_port, align 4
  %21 = load ptr, ptr %node_ip, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.232, i32 noundef %20, ptr noundef %21)
  br label %if.end

if.else:                                          ; preds = %land.lhs.true33, %while.body28
  %22 = load ptr, ptr %nodeaddr, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.233, ptr noundef %22)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then35
  %23 = load ptr, ptr %from, align 8
  call void @listRewind(ptr noundef %23, ptr noundef %li)
  br label %while.cond36

while.cond36:                                     ; preds = %while.body40, %if.end
  %call37 = call ptr @listNext(ptr noundef %li)
  store ptr %call37, ptr %ln, align 8
  %cmp38 = icmp ne ptr %call37, null
  br i1 %cmp38, label %while.body40, label %while.end

while.body40:                                     ; preds = %while.cond36
  %24 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %value, align 8
  store ptr %25, ptr %from_addr, align 8
  %26 = load ptr, ptr %from_addr, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.234, ptr noundef %26)
  %27 = load ptr, ptr %from_addr, align 8
  call void @hi_sdsfree(ptr noundef %27)
  br label %while.cond36, !llvm.loop !132

while.end:                                        ; preds = %while.cond36
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.235)
  %28 = load ptr, ptr %from, align 8
  call void @listEmpty(ptr noundef %28)
  br label %while.cond24, !llvm.loop !133

while.end41:                                      ; preds = %while.cond24
  br label %if.end42

if.end42:                                         ; preds = %while.end41, %land.lhs.true, %if.then
  %29 = load ptr, ptr %iter, align 8
  %cmp43 = icmp ne ptr %29, null
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end42
  %30 = load ptr, ptr %iter, align 8
  call void @dictReleaseIterator(ptr noundef %30)
  br label %if.end46

if.end46:                                         ; preds = %if.then45, %if.end42
  %31 = load ptr, ptr %status, align 8
  %cmp47 = icmp ne ptr %31, null
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end46
  %32 = load ptr, ptr %status, align 8
  call void @dictRelease(ptr noundef %32)
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %if.end46
  store i32 0, ptr %counter, align 4
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %while.body
  br label %while.cond, !llvm.loop !134

while.end52:                                      ; preds = %while.cond
  %call53 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  ret void
}

declare void @listEmpty(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerLoadInfoFromNode(ptr noundef %node) #0 {
entry:
  %retval = alloca i32, align 4
  %node.addr = alloca ptr, align 8
  %e = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %friend = alloca ptr, align 8
  %n = alloca ptr, align 8
  %master = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %node.addr, align 8
  %call = call i32 @clusterManagerNodeConnect(ptr noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %node.addr, align 8
  call void @freeClusterManagerNode(ptr noundef %3)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store ptr null, ptr %e, align 8
  %4 = load ptr, ptr %node.addr, align 8
  %call1 = call i32 @clusterManagerNodeIsCluster(ptr noundef %4, ptr noundef %e)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end7, label %if.then3

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %node.addr, align 8
  %6 = load ptr, ptr %e, align 8
  call void @clusterManagerPrintNotClusterNodeError(ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %e, align 8
  %tobool4 = icmp ne ptr %7, null
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then3
  %8 = load ptr, ptr %e, align 8
  call void @zfree(ptr noundef %8)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then3
  %9 = load ptr, ptr %node.addr, align 8
  call void @freeClusterManagerNode(ptr noundef %9)
  store i32 0, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  store ptr null, ptr %e, align 8
  %10 = load ptr, ptr %node.addr, align 8
  %call8 = call i32 @clusterManagerNodeLoadInfo(ptr noundef %10, i32 noundef 1, ptr noundef %e)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end14, label %if.then10

if.then10:                                        ; preds = %if.end7
  %11 = load ptr, ptr %e, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.then10
  %12 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %ip, align 8
  %14 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %14, i32 0, i32 3
  %15 = load i32, ptr %port, align 8
  %16 = load ptr, ptr %e, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %13, i32 noundef %15, ptr noundef %16)
  %17 = load ptr, ptr %e, align 8
  call void @zfree(ptr noundef %17)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.then10
  %18 = load ptr, ptr %node.addr, align 8
  call void @freeClusterManagerNode(ptr noundef %18)
  store i32 0, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end7
  %19 = load ptr, ptr @cluster_manager, align 8
  %cmp15 = icmp ne ptr %19, null
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end14
  %20 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %20, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then16
  %call17 = call ptr @listNext(ptr noundef %li)
  store ptr %call17, ptr %ln, align 8
  %cmp18 = icmp ne ptr %call17, null
  br i1 %cmp18, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %21, i32 0, i32 2
  %22 = load ptr, ptr %value, align 8
  call void @freeClusterManagerNode(ptr noundef %22)
  br label %while.cond, !llvm.loop !135

while.end:                                        ; preds = %while.cond
  %23 = load ptr, ptr @cluster_manager, align 8
  call void @listRelease(ptr noundef %23)
  br label %if.end19

if.end19:                                         ; preds = %while.end, %if.end14
  %call20 = call ptr @listCreate()
  store ptr %call20, ptr @cluster_manager, align 8
  %24 = load ptr, ptr @cluster_manager, align 8
  %25 = load ptr, ptr %node.addr, align 8
  %call21 = call ptr @listAddNodeTail(ptr noundef %24, ptr noundef %25)
  %26 = load ptr, ptr %node.addr, align 8
  %friends = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 15
  %27 = load ptr, ptr %friends, align 8
  %cmp22 = icmp ne ptr %27, null
  br i1 %cmp22, label %if.then23, label %if.end61

if.then23:                                        ; preds = %if.end19
  %28 = load ptr, ptr %node.addr, align 8
  %friends24 = getelementptr inbounds %struct.clusterManagerNode, ptr %28, i32 0, i32 15
  %29 = load ptr, ptr %friends24, align 8
  call void @listRewind(ptr noundef %29, ptr noundef %li)
  br label %while.cond25

while.cond25:                                     ; preds = %if.end57, %if.end52, %if.then23
  %call26 = call ptr @listNext(ptr noundef %li)
  store ptr %call26, ptr %ln, align 8
  %cmp27 = icmp ne ptr %call26, null
  br i1 %cmp27, label %while.body28, label %while.end58

while.body28:                                     ; preds = %while.cond25
  %30 = load ptr, ptr %ln, align 8
  %value29 = getelementptr inbounds %struct.listNode, ptr %30, i32 0, i32 2
  %31 = load ptr, ptr %value29, align 8
  store ptr %31, ptr %friend, align 8
  %32 = load ptr, ptr %friend, align 8
  %ip30 = getelementptr inbounds %struct.clusterManagerNode, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %ip30, align 8
  %tobool31 = icmp ne ptr %33, null
  br i1 %tobool31, label %lor.lhs.false, label %if.then34

lor.lhs.false:                                    ; preds = %while.body28
  %34 = load ptr, ptr %friend, align 8
  %port32 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 3
  %35 = load i32, ptr %port32, align 8
  %tobool33 = icmp ne i32 %35, 0
  br i1 %tobool33, label %if.end35, label %if.then34

if.then34:                                        ; preds = %lor.lhs.false, %while.body28
  br label %invalid_friend

if.end35:                                         ; preds = %lor.lhs.false
  %36 = load ptr, ptr %friend, align 8
  %context36 = getelementptr inbounds %struct.clusterManagerNode, ptr %36, i32 0, i32 0
  %37 = load ptr, ptr %context36, align 8
  %tobool37 = icmp ne ptr %37, null
  br i1 %tobool37, label %if.end42, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %if.end35
  %38 = load ptr, ptr %friend, align 8
  %call39 = call i32 @clusterManagerNodeConnect(ptr noundef %38)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %land.lhs.true38
  br label %invalid_friend

if.end42:                                         ; preds = %land.lhs.true38, %if.end35
  store ptr null, ptr %e, align 8
  %39 = load ptr, ptr %friend, align 8
  %call43 = call i32 @clusterManagerNodeLoadInfo(ptr noundef %39, i32 noundef 0, ptr noundef %e)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %if.then45, label %if.else

if.then45:                                        ; preds = %if.end42
  %40 = load ptr, ptr %friend, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %40, i32 0, i32 8
  %41 = load i32, ptr %flags, align 8
  %and = and i32 %41, 56
  %tobool46 = icmp ne i32 %and, 0
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.then45
  br label %invalid_friend

if.end48:                                         ; preds = %if.then45
  %42 = load ptr, ptr @cluster_manager, align 8
  %43 = load ptr, ptr %friend, align 8
  %call49 = call ptr @listAddNodeTail(ptr noundef %42, ptr noundef %43)
  br label %if.end52

if.else:                                          ; preds = %if.end42
  %44 = load ptr, ptr %friend, align 8
  %ip50 = getelementptr inbounds %struct.clusterManagerNode, ptr %44, i32 0, i32 2
  %45 = load ptr, ptr %ip50, align 8
  %46 = load ptr, ptr %friend, align 8
  %port51 = getelementptr inbounds %struct.clusterManagerNode, ptr %46, i32 0, i32 3
  %47 = load i32, ptr %port51, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.240, ptr noundef %45, i32 noundef %47)
  br label %invalid_friend

if.end52:                                         ; preds = %if.end48
  br label %while.cond25, !llvm.loop !136

invalid_friend:                                   ; preds = %if.else, %if.then47, %if.then41, %if.then34
  %48 = load ptr, ptr %friend, align 8
  %flags53 = getelementptr inbounds %struct.clusterManagerNode, ptr %48, i32 0, i32 8
  %49 = load i32, ptr %flags53, align 8
  %and54 = and i32 %49, 2
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %invalid_friend
  %50 = load i32, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 2), align 8
  %inc = add nsw i32 %50, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 2), align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %invalid_friend
  %51 = load ptr, ptr %friend, align 8
  call void @freeClusterManagerNode(ptr noundef %51)
  br label %while.cond25, !llvm.loop !136

while.end58:                                      ; preds = %while.cond25
  %52 = load ptr, ptr %node.addr, align 8
  %friends59 = getelementptr inbounds %struct.clusterManagerNode, ptr %52, i32 0, i32 15
  %53 = load ptr, ptr %friends59, align 8
  call void @listRelease(ptr noundef %53)
  %54 = load ptr, ptr %node.addr, align 8
  %friends60 = getelementptr inbounds %struct.clusterManagerNode, ptr %54, i32 0, i32 15
  store ptr null, ptr %friends60, align 8
  br label %if.end61

if.end61:                                         ; preds = %while.end58, %if.end19
  %55 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %55, ptr noundef %li)
  br label %while.cond62

while.cond62:                                     ; preds = %if.end79, %if.end61
  %call63 = call ptr @listNext(ptr noundef %li)
  store ptr %call63, ptr %ln, align 8
  %cmp64 = icmp ne ptr %call63, null
  br i1 %cmp64, label %while.body65, label %while.end80

while.body65:                                     ; preds = %while.cond62
  %56 = load ptr, ptr %ln, align 8
  %value66 = getelementptr inbounds %struct.listNode, ptr %56, i32 0, i32 2
  %57 = load ptr, ptr %value66, align 8
  store ptr %57, ptr %n, align 8
  %58 = load ptr, ptr %n, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %58, i32 0, i32 10
  %59 = load ptr, ptr %replicate, align 8
  %cmp67 = icmp ne ptr %59, null
  br i1 %cmp67, label %if.then68, label %if.end79

if.then68:                                        ; preds = %while.body65
  %60 = load ptr, ptr %n, align 8
  %replicate69 = getelementptr inbounds %struct.clusterManagerNode, ptr %60, i32 0, i32 10
  %61 = load ptr, ptr %replicate69, align 8
  %call70 = call ptr @clusterManagerNodeByName(ptr noundef %61)
  store ptr %call70, ptr %master, align 8
  %62 = load ptr, ptr %master, align 8
  %cmp71 = icmp eq ptr %62, null
  br i1 %cmp71, label %if.then72, label %if.else76

if.then72:                                        ; preds = %if.then68
  %63 = load ptr, ptr %n, align 8
  %ip73 = getelementptr inbounds %struct.clusterManagerNode, ptr %63, i32 0, i32 2
  %64 = load ptr, ptr %ip73, align 8
  %65 = load ptr, ptr %n, align 8
  %port74 = getelementptr inbounds %struct.clusterManagerNode, ptr %65, i32 0, i32 3
  %66 = load i32, ptr %port74, align 8
  %67 = load ptr, ptr %n, align 8
  %replicate75 = getelementptr inbounds %struct.clusterManagerNode, ptr %67, i32 0, i32 10
  %68 = load ptr, ptr %replicate75, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.241, ptr noundef %64, i32 noundef %66, ptr noundef %68)
  br label %if.end78

if.else76:                                        ; preds = %if.then68
  %69 = load ptr, ptr %master, align 8
  %replicas_count = getelementptr inbounds %struct.clusterManagerNode, ptr %69, i32 0, i32 14
  %70 = load i32, ptr %replicas_count, align 8
  %inc77 = add nsw i32 %70, 1
  store i32 %inc77, ptr %replicas_count, align 8
  br label %if.end78

if.end78:                                         ; preds = %if.else76, %if.then72
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %while.body65
  br label %while.cond62, !llvm.loop !137

while.end80:                                      ; preds = %while.cond62
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end80, %if.end13, %if.end6, %if.then
  %71 = load i32, ptr %retval, align 4
  ret i32 %71
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCheckCluster(i32 noundef %quiet) #0 {
entry:
  %retval = alloca i32, align 4
  %quiet.addr = alloca i32, align 4
  %ln = alloca ptr, align 8
  %node = alloca ptr, align 8
  %result = alloca i32, align 4
  %consistent = alloca i32, align 4
  %do_fix = alloca i32, align 4
  %err = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %i = alloca i32, align 4
  %open_slots = alloca ptr, align 8
  %n = alloca ptr, align 8
  %errstr = alloca ptr, align 8
  %slot = alloca ptr, align 8
  %fmt = alloca ptr, align 8
  %errstr38 = alloca ptr, align 8
  %slot46 = alloca ptr, align 8
  %fmt56 = alloca ptr, align 8
  %iter = alloca ptr, align 8
  %entry68 = alloca ptr, align 8
  %errstr69 = alloca ptr, align 8
  %slot75 = alloca ptr, align 8
  %fmt77 = alloca ptr, align 8
  %slot89 = alloca ptr, align 8
  %slots = alloca [16384 x i8], align 16
  %coverage = alloca i32, align 4
  %err104 = alloca ptr, align 8
  %dtype = alloca %struct.dictType, align 8
  %fixed = alloca i32, align 4
  %search_multiple_owners = alloca i32, align 4
  %slot120 = alloca i32, align 4
  %slots_with_multiple_owners = alloca i32, align 4
  %li124 = alloca %struct.listIter, align 8
  %ln125 = alloca ptr, align 8
  %owners = alloca ptr, align 8
  %n131 = alloca ptr, align 8
  %count = alloca i32, align 4
  %n158 = alloca ptr, align 8
  store i32 %quiet, ptr %quiet.addr, align 4
  %0 = load ptr, ptr @cluster_manager, align 8
  %head = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %head, align 8
  store ptr %1, ptr %ln, align 8
  %2 = load ptr, ptr %ln, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %node, align 8
  %5 = load ptr, ptr %node, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ip, align 8
  %7 = load ptr, ptr %node, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %7, i32 0, i32 3
  %8 = load i32, ptr %port, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.242, ptr noundef %6, i32 noundef %8)
  store i32 1, ptr %result, align 4
  store i32 0, ptr %consistent, align 4
  %9 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %9, 1
  store i32 %and, ptr %do_fix, align 4
  %10 = load i32, ptr %quiet.addr, align 4
  %tobool1 = icmp ne i32 %10, 0
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  call void @clusterManagerShowNodes()
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %call = call i32 @clusterManagerIsConfigConsistent()
  store i32 %call, ptr %consistent, align 4
  %11 = load i32, ptr %consistent, align 4
  %tobool4 = icmp ne i32 %11, 0
  br i1 %tobool4, label %if.else, label %if.then5

if.then5:                                         ; preds = %if.end3
  %call6 = call ptr @hi_sdsnew(ptr noundef @.str.243)
  store ptr %call6, ptr %err, align 8
  %12 = load ptr, ptr %err, align 8
  call void @clusterManagerOnError(ptr noundef %12)
  store i32 0, ptr %result, align 4
  br label %if.end7

if.else:                                          ; preds = %if.end3
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 4, ptr noundef @.str.244)
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then5
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.245)
  %13 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %13, ptr noundef %li)
  store ptr null, ptr %open_slots, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end64, %if.end7
  %call8 = call ptr @listNext(ptr noundef %li)
  store ptr %call8, ptr %ln, align 8
  %cmp = icmp ne ptr %call8, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %14 = load ptr, ptr %ln, align 8
  %value9 = getelementptr inbounds %struct.listNode, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %value9, align 8
  store ptr %15, ptr %n, align 8
  %16 = load ptr, ptr %n, align 8
  %migrating = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 16
  %17 = load ptr, ptr %migrating, align 8
  %cmp10 = icmp ne ptr %17, null
  br i1 %cmp10, label %if.then11, label %if.end31

if.then11:                                        ; preds = %while.body
  %18 = load ptr, ptr %open_slots, align 8
  %cmp12 = icmp eq ptr %18, null
  br i1 %cmp12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.then11
  %call14 = call ptr @dictCreate(ptr noundef @clusterManagerDictType)
  store ptr %call14, ptr %open_slots, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.then11
  %call16 = call ptr @hi_sdsempty()
  store ptr %call16, ptr %errstr, align 8
  %19 = load ptr, ptr %errstr, align 8
  %20 = load ptr, ptr %n, align 8
  %ip17 = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %ip17, align 8
  %22 = load ptr, ptr %n, align 8
  %port18 = getelementptr inbounds %struct.clusterManagerNode, ptr %22, i32 0, i32 3
  %23 = load i32, ptr %port18, align 8
  %call19 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %19, ptr noundef @.str.246, ptr noundef %21, i32 noundef %23)
  store ptr %call19, ptr %errstr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end15
  %24 = load i32, ptr %i, align 4
  %25 = load ptr, ptr %n, align 8
  %migrating_count = getelementptr inbounds %struct.clusterManagerNode, ptr %25, i32 0, i32 18
  %26 = load i32, ptr %migrating_count, align 8
  %cmp20 = icmp slt i32 %24, %26
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %27 = load ptr, ptr %n, align 8
  %migrating21 = getelementptr inbounds %struct.clusterManagerNode, ptr %27, i32 0, i32 16
  %28 = load ptr, ptr %migrating21, align 8
  %29 = load i32, ptr %i, align 4
  %idxprom = sext i32 %29 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %28, i64 %idxprom
  %30 = load ptr, ptr %arrayidx, align 8
  store ptr %30, ptr %slot, align 8
  %31 = load ptr, ptr %open_slots, align 8
  %32 = load ptr, ptr %slot, align 8
  %33 = load ptr, ptr %n, align 8
  %migrating22 = getelementptr inbounds %struct.clusterManagerNode, ptr %33, i32 0, i32 16
  %34 = load ptr, ptr %migrating22, align 8
  %35 = load i32, ptr %i, align 4
  %add = add nsw i32 %35, 1
  %idxprom23 = sext i32 %add to i64
  %arrayidx24 = getelementptr inbounds ptr, ptr %34, i64 %idxprom23
  %36 = load ptr, ptr %arrayidx24, align 8
  %call25 = call ptr @hi_sdsdup(ptr noundef %36)
  %call26 = call i32 @dictReplace(ptr noundef %31, ptr noundef %32, ptr noundef %call25)
  %37 = load i32, ptr %i, align 4
  %cmp27 = icmp sgt i32 %37, 0
  %cond = select i1 %cmp27, ptr @.str.247, ptr @.str.223
  store ptr %cond, ptr %fmt, align 8
  %38 = load ptr, ptr %errstr, align 8
  %39 = load ptr, ptr %fmt, align 8
  %40 = load ptr, ptr %slot, align 8
  %call28 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %38, ptr noundef %39, ptr noundef %40)
  store ptr %call28, ptr %errstr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %41 = load i32, ptr %i, align 4
  %add29 = add nsw i32 %41, 2
  store i32 %add29, ptr %i, align 4
  br label %for.cond, !llvm.loop !138

for.end:                                          ; preds = %for.cond
  %42 = load ptr, ptr %errstr, align 8
  %call30 = call ptr @hi_sdscat(ptr noundef %42, ptr noundef @.str.230)
  store ptr %call30, ptr %errstr, align 8
  %43 = load ptr, ptr %errstr, align 8
  call void @clusterManagerOnError(ptr noundef %43)
  br label %if.end31

if.end31:                                         ; preds = %for.end, %while.body
  %44 = load ptr, ptr %n, align 8
  %importing = getelementptr inbounds %struct.clusterManagerNode, ptr %44, i32 0, i32 17
  %45 = load ptr, ptr %importing, align 8
  %cmp32 = icmp ne ptr %45, null
  br i1 %cmp32, label %if.then33, label %if.end64

if.then33:                                        ; preds = %if.end31
  %46 = load ptr, ptr %open_slots, align 8
  %cmp34 = icmp eq ptr %46, null
  br i1 %cmp34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.then33
  %call36 = call ptr @dictCreate(ptr noundef @clusterManagerDictType)
  store ptr %call36, ptr %open_slots, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.then33
  %call39 = call ptr @hi_sdsempty()
  store ptr %call39, ptr %errstr38, align 8
  %47 = load ptr, ptr %errstr38, align 8
  %48 = load ptr, ptr %n, align 8
  %ip40 = getelementptr inbounds %struct.clusterManagerNode, ptr %48, i32 0, i32 2
  %49 = load ptr, ptr %ip40, align 8
  %50 = load ptr, ptr %n, align 8
  %port41 = getelementptr inbounds %struct.clusterManagerNode, ptr %50, i32 0, i32 3
  %51 = load i32, ptr %port41, align 8
  %call42 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %47, ptr noundef @.str.248, ptr noundef %49, i32 noundef %51)
  store ptr %call42, ptr %errstr38, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond43

for.cond43:                                       ; preds = %for.inc60, %if.end37
  %52 = load i32, ptr %i, align 4
  %53 = load ptr, ptr %n, align 8
  %importing_count = getelementptr inbounds %struct.clusterManagerNode, ptr %53, i32 0, i32 19
  %54 = load i32, ptr %importing_count, align 4
  %cmp44 = icmp slt i32 %52, %54
  br i1 %cmp44, label %for.body45, label %for.end62

for.body45:                                       ; preds = %for.cond43
  %55 = load ptr, ptr %n, align 8
  %importing47 = getelementptr inbounds %struct.clusterManagerNode, ptr %55, i32 0, i32 17
  %56 = load ptr, ptr %importing47, align 8
  %57 = load i32, ptr %i, align 4
  %idxprom48 = sext i32 %57 to i64
  %arrayidx49 = getelementptr inbounds ptr, ptr %56, i64 %idxprom48
  %58 = load ptr, ptr %arrayidx49, align 8
  store ptr %58, ptr %slot46, align 8
  %59 = load ptr, ptr %open_slots, align 8
  %60 = load ptr, ptr %slot46, align 8
  %61 = load ptr, ptr %n, align 8
  %importing50 = getelementptr inbounds %struct.clusterManagerNode, ptr %61, i32 0, i32 17
  %62 = load ptr, ptr %importing50, align 8
  %63 = load i32, ptr %i, align 4
  %add51 = add nsw i32 %63, 1
  %idxprom52 = sext i32 %add51 to i64
  %arrayidx53 = getelementptr inbounds ptr, ptr %62, i64 %idxprom52
  %64 = load ptr, ptr %arrayidx53, align 8
  %call54 = call ptr @hi_sdsdup(ptr noundef %64)
  %call55 = call i32 @dictReplace(ptr noundef %59, ptr noundef %60, ptr noundef %call54)
  %65 = load i32, ptr %i, align 4
  %cmp57 = icmp sgt i32 %65, 0
  %cond58 = select i1 %cmp57, ptr @.str.247, ptr @.str.223
  store ptr %cond58, ptr %fmt56, align 8
  %66 = load ptr, ptr %errstr38, align 8
  %67 = load ptr, ptr %fmt56, align 8
  %68 = load ptr, ptr %slot46, align 8
  %call59 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %66, ptr noundef %67, ptr noundef %68)
  store ptr %call59, ptr %errstr38, align 8
  br label %for.inc60

for.inc60:                                        ; preds = %for.body45
  %69 = load i32, ptr %i, align 4
  %add61 = add nsw i32 %69, 2
  store i32 %add61, ptr %i, align 4
  br label %for.cond43, !llvm.loop !139

for.end62:                                        ; preds = %for.cond43
  %70 = load ptr, ptr %errstr38, align 8
  %call63 = call ptr @hi_sdscat(ptr noundef %70, ptr noundef @.str.230)
  store ptr %call63, ptr %errstr38, align 8
  %71 = load ptr, ptr %errstr38, align 8
  call void @clusterManagerOnError(ptr noundef %71)
  br label %if.end64

if.end64:                                         ; preds = %for.end62, %if.end31
  br label %while.cond, !llvm.loop !140

while.end:                                        ; preds = %while.cond
  %72 = load ptr, ptr %open_slots, align 8
  %cmp65 = icmp ne ptr %72, null
  br i1 %cmp65, label %if.then66, label %if.end98

if.then66:                                        ; preds = %while.end
  store i32 0, ptr %result, align 4
  %73 = load ptr, ptr %open_slots, align 8
  %call67 = call ptr @dictGetIterator(ptr noundef %73)
  store ptr %call67, ptr %iter, align 8
  %call70 = call ptr @hi_sdsnew(ptr noundef @.str.249)
  store ptr %call70, ptr %errstr69, align 8
  store i32 0, ptr %i, align 4
  br label %while.cond71

while.cond71:                                     ; preds = %while.body74, %if.then66
  %74 = load ptr, ptr %iter, align 8
  %call72 = call ptr @dictNext(ptr noundef %74)
  store ptr %call72, ptr %entry68, align 8
  %cmp73 = icmp ne ptr %call72, null
  br i1 %cmp73, label %while.body74, label %while.end81

while.body74:                                     ; preds = %while.cond71
  %75 = load ptr, ptr %entry68, align 8
  %call76 = call ptr @dictGetKey(ptr noundef %75)
  store ptr %call76, ptr %slot75, align 8
  %76 = load i32, ptr %i, align 4
  %inc = add nsw i32 %76, 1
  store i32 %inc, ptr %i, align 4
  %cmp78 = icmp sgt i32 %76, 0
  %cond79 = select i1 %cmp78, ptr @.str.247, ptr @.str.223
  store ptr %cond79, ptr %fmt77, align 8
  %77 = load ptr, ptr %errstr69, align 8
  %78 = load ptr, ptr %fmt77, align 8
  %79 = load ptr, ptr %slot75, align 8
  %call80 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %77, ptr noundef %78, ptr noundef %79)
  store ptr %call80, ptr %errstr69, align 8
  br label %while.cond71, !llvm.loop !141

while.end81:                                      ; preds = %while.cond71
  %80 = load ptr, ptr %errstr69, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.250, ptr noundef %80)
  %81 = load ptr, ptr %errstr69, align 8
  call void @hi_sdsfree(ptr noundef %81)
  %82 = load i32, ptr %do_fix, align 4
  %tobool82 = icmp ne i32 %82, 0
  br i1 %tobool82, label %if.then83, label %if.end97

if.then83:                                        ; preds = %while.end81
  %83 = load ptr, ptr %iter, align 8
  call void @dictReleaseIterator(ptr noundef %83)
  %84 = load ptr, ptr %open_slots, align 8
  %call84 = call ptr @dictGetIterator(ptr noundef %84)
  store ptr %call84, ptr %iter, align 8
  br label %while.cond85

while.cond85:                                     ; preds = %if.end95, %if.then83
  %85 = load ptr, ptr %iter, align 8
  %call86 = call ptr @dictNext(ptr noundef %85)
  store ptr %call86, ptr %entry68, align 8
  %cmp87 = icmp ne ptr %call86, null
  br i1 %cmp87, label %while.body88, label %while.end96

while.body88:                                     ; preds = %while.cond85
  %86 = load ptr, ptr %entry68, align 8
  %call90 = call ptr @dictGetKey(ptr noundef %86)
  store ptr %call90, ptr %slot89, align 8
  %87 = load ptr, ptr %slot89, align 8
  %call91 = call i32 @atoi(ptr noundef %87) #12
  %call92 = call i32 @clusterManagerFixOpenSlot(i32 noundef %call91)
  store i32 %call92, ptr %result, align 4
  %88 = load i32, ptr %result, align 4
  %tobool93 = icmp ne i32 %88, 0
  br i1 %tobool93, label %if.end95, label %if.then94

if.then94:                                        ; preds = %while.body88
  br label %while.end96

if.end95:                                         ; preds = %while.body88
  br label %while.cond85, !llvm.loop !142

while.end96:                                      ; preds = %if.then94, %while.cond85
  br label %if.end97

if.end97:                                         ; preds = %while.end96, %while.end81
  %89 = load ptr, ptr %iter, align 8
  call void @dictReleaseIterator(ptr noundef %89)
  %90 = load ptr, ptr %open_slots, align 8
  call void @dictRelease(ptr noundef %90)
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %while.end
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.251)
  %arraydecay = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay, i8 0, i64 16384, i1 false)
  %arraydecay99 = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 0
  %call100 = call i32 @clusterManagerGetCoveredSlots(ptr noundef %arraydecay99)
  store i32 %call100, ptr %coverage, align 4
  %91 = load i32, ptr %coverage, align 4
  %cmp101 = icmp eq i32 %91, 16384
  br i1 %cmp101, label %if.then102, label %if.else103

if.then102:                                       ; preds = %if.end98
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 4, ptr noundef @.str.252, i32 noundef 16384)
  br label %if.end116

if.else103:                                       ; preds = %if.end98
  %call105 = call ptr @hi_sdsempty()
  store ptr %call105, ptr %err104, align 8
  %92 = load ptr, ptr %err104, align 8
  %call106 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %92, ptr noundef @.str.253, i32 noundef 16384)
  store ptr %call106, ptr %err104, align 8
  %93 = load ptr, ptr %err104, align 8
  call void @clusterManagerOnError(ptr noundef %93)
  store i32 0, ptr %result, align 4
  %94 = load i32, ptr %do_fix, align 4
  %tobool107 = icmp ne i32 %94, 0
  br i1 %tobool107, label %if.then108, label %if.end115

if.then108:                                       ; preds = %if.else103
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %dtype, ptr align 8 @clusterManagerDictType, i64 88, i1 false)
  %keyDestructor = getelementptr inbounds %struct.dictType, ptr %dtype, i32 0, i32 4
  store ptr @dictSdsDestructor, ptr %keyDestructor, align 8
  %valDestructor = getelementptr inbounds %struct.dictType, ptr %dtype, i32 0, i32 5
  store ptr @dictListDestructor, ptr %valDestructor, align 8
  %call109 = call ptr @dictCreate(ptr noundef %dtype)
  store ptr %call109, ptr @clusterManagerUncoveredSlots, align 8
  %arraydecay110 = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 0
  %call111 = call i32 @clusterManagerFixSlotsCoverage(ptr noundef %arraydecay110)
  store i32 %call111, ptr %fixed, align 4
  %95 = load i32, ptr %fixed, align 4
  %cmp112 = icmp sgt i32 %95, 0
  br i1 %cmp112, label %if.then113, label %if.end114

if.then113:                                       ; preds = %if.then108
  store i32 1, ptr %result, align 4
  br label %if.end114

if.end114:                                        ; preds = %if.then113, %if.then108
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %if.else103
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.then102
  %96 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and117 = and i32 %96, 512
  store i32 %and117, ptr %search_multiple_owners, align 4
  %97 = load i32, ptr %search_multiple_owners, align 4
  %tobool118 = icmp ne i32 %97, 0
  br i1 %tobool118, label %if.then119, label %if.end179

if.then119:                                       ; preds = %if.end116
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.254)
  store i32 0, ptr %slot120, align 4
  store i32 0, ptr %slots_with_multiple_owners, align 4
  br label %for.cond121

for.cond121:                                      ; preds = %for.inc173, %if.then119
  %98 = load i32, ptr %slot120, align 4
  %cmp122 = icmp slt i32 %98, 16384
  br i1 %cmp122, label %for.body123, label %for.end175

for.body123:                                      ; preds = %for.cond121
  %99 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %99, ptr noundef %li124)
  %call126 = call ptr @listCreate()
  store ptr %call126, ptr %owners, align 8
  br label %while.cond127

while.cond127:                                    ; preds = %if.end149, %if.then135, %for.body123
  %call128 = call ptr @listNext(ptr noundef %li124)
  store ptr %call128, ptr %ln125, align 8
  %cmp129 = icmp ne ptr %call128, null
  br i1 %cmp129, label %while.body130, label %while.end150

while.body130:                                    ; preds = %while.cond127
  %100 = load ptr, ptr %ln125, align 8
  %value132 = getelementptr inbounds %struct.listNode, ptr %100, i32 0, i32 2
  %101 = load ptr, ptr %value132, align 8
  store ptr %101, ptr %n131, align 8
  %102 = load ptr, ptr %n131, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %102, i32 0, i32 8
  %103 = load i32, ptr %flags, align 8
  %and133 = and i32 %103, 2
  %tobool134 = icmp ne i32 %and133, 0
  br i1 %tobool134, label %if.then135, label %if.end136

if.then135:                                       ; preds = %while.body130
  br label %while.cond127, !llvm.loop !143

if.end136:                                        ; preds = %while.body130
  %104 = load ptr, ptr %n131, align 8
  %slots137 = getelementptr inbounds %struct.clusterManagerNode, ptr %104, i32 0, i32 12
  %105 = load i32, ptr %slot120, align 4
  %idxprom138 = sext i32 %105 to i64
  %arrayidx139 = getelementptr inbounds [16384 x i8], ptr %slots137, i64 0, i64 %idxprom138
  %106 = load i8, ptr %arrayidx139, align 1
  %tobool140 = icmp ne i8 %106, 0
  br i1 %tobool140, label %if.then141, label %if.else143

if.then141:                                       ; preds = %if.end136
  %107 = load ptr, ptr %owners, align 8
  %108 = load ptr, ptr %n131, align 8
  %call142 = call ptr @listAddNodeTail(ptr noundef %107, ptr noundef %108)
  br label %if.end149

if.else143:                                       ; preds = %if.end136
  %109 = load ptr, ptr %n131, align 8
  %110 = load i32, ptr %slot120, align 4
  %call144 = call i32 @clusterManagerCountKeysInSlot(ptr noundef %109, i32 noundef %110)
  store i32 %call144, ptr %count, align 4
  %111 = load i32, ptr %count, align 4
  %cmp145 = icmp sgt i32 %111, 0
  br i1 %cmp145, label %if.then146, label %if.end148

if.then146:                                       ; preds = %if.else143
  %112 = load ptr, ptr %owners, align 8
  %113 = load ptr, ptr %n131, align 8
  %call147 = call ptr @listAddNodeTail(ptr noundef %112, ptr noundef %113)
  br label %if.end148

if.end148:                                        ; preds = %if.then146, %if.else143
  br label %if.end149

if.end149:                                        ; preds = %if.end148, %if.then141
  br label %while.cond127, !llvm.loop !143

while.end150:                                     ; preds = %while.cond127
  %114 = load ptr, ptr %owners, align 8
  %len = getelementptr inbounds %struct.list, ptr %114, i32 0, i32 5
  %115 = load i64, ptr %len, align 8
  %cmp151 = icmp ugt i64 %115, 1
  br i1 %cmp151, label %if.then152, label %if.end172

if.then152:                                       ; preds = %while.end150
  store i32 0, ptr %result, align 4
  %116 = load i32, ptr %slot120, align 4
  %117 = load ptr, ptr %owners, align 8
  %len153 = getelementptr inbounds %struct.list, ptr %117, i32 0, i32 5
  %118 = load i64, ptr %len153, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.255, i32 noundef %116, i64 noundef %118)
  %119 = load ptr, ptr %owners, align 8
  call void @listRewind(ptr noundef %119, ptr noundef %li124)
  br label %while.cond154

while.cond154:                                    ; preds = %while.body157, %if.then152
  %call155 = call ptr @listNext(ptr noundef %li124)
  store ptr %call155, ptr %ln125, align 8
  %cmp156 = icmp ne ptr %call155, null
  br i1 %cmp156, label %while.body157, label %while.end162

while.body157:                                    ; preds = %while.cond154
  %120 = load ptr, ptr %ln125, align 8
  %value159 = getelementptr inbounds %struct.listNode, ptr %120, i32 0, i32 2
  %121 = load ptr, ptr %value159, align 8
  store ptr %121, ptr %n158, align 8
  %122 = load ptr, ptr %n158, align 8
  %ip160 = getelementptr inbounds %struct.clusterManagerNode, ptr %122, i32 0, i32 2
  %123 = load ptr, ptr %ip160, align 8
  %124 = load ptr, ptr %n158, align 8
  %port161 = getelementptr inbounds %struct.clusterManagerNode, ptr %124, i32 0, i32 3
  %125 = load i32, ptr %port161, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.256, ptr noundef %123, i32 noundef %125)
  br label %while.cond154, !llvm.loop !144

while.end162:                                     ; preds = %while.cond154
  %126 = load i32, ptr %slots_with_multiple_owners, align 4
  %inc163 = add nsw i32 %126, 1
  store i32 %inc163, ptr %slots_with_multiple_owners, align 4
  %127 = load i32, ptr %do_fix, align 4
  %tobool164 = icmp ne i32 %127, 0
  br i1 %tobool164, label %if.then165, label %if.end171

if.then165:                                       ; preds = %while.end162
  %128 = load i32, ptr %slot120, align 4
  %129 = load ptr, ptr %owners, align 8
  %call166 = call i32 @clusterManagerFixMultipleSlotOwners(i32 noundef %128, ptr noundef %129)
  store i32 %call166, ptr %result, align 4
  %130 = load i32, ptr %result, align 4
  %tobool167 = icmp ne i32 %130, 0
  br i1 %tobool167, label %if.else169, label %if.then168

if.then168:                                       ; preds = %if.then165
  %131 = load i32, ptr %slot120, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.257, i32 noundef %131)
  %132 = load ptr, ptr %owners, align 8
  call void @listRelease(ptr noundef %132)
  br label %for.end175

if.else169:                                       ; preds = %if.then165
  %133 = load i32, ptr %slots_with_multiple_owners, align 4
  %dec = add nsw i32 %133, -1
  store i32 %dec, ptr %slots_with_multiple_owners, align 4
  br label %if.end170

if.end170:                                        ; preds = %if.else169
  br label %if.end171

if.end171:                                        ; preds = %if.end170, %while.end162
  br label %if.end172

if.end172:                                        ; preds = %if.end171, %while.end150
  %134 = load ptr, ptr %owners, align 8
  call void @listRelease(ptr noundef %134)
  br label %for.inc173

for.inc173:                                       ; preds = %if.end172
  %135 = load i32, ptr %slot120, align 4
  %inc174 = add nsw i32 %135, 1
  store i32 %inc174, ptr %slot120, align 4
  br label %for.cond121, !llvm.loop !145

for.end175:                                       ; preds = %if.then168, %for.cond121
  %136 = load i32, ptr %slots_with_multiple_owners, align 4
  %cmp176 = icmp eq i32 %136, 0
  br i1 %cmp176, label %if.then177, label %if.end178

if.then177:                                       ; preds = %for.end175
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 4, ptr noundef @.str.258)
  br label %if.end178

if.end178:                                        ; preds = %if.then177, %for.end175
  br label %if.end179

if.end179:                                        ; preds = %if.end178, %if.end116
  %137 = load i32, ptr %result, align 4
  store i32 %137, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end179, %if.then
  %138 = load i32, ptr %retval, align 4
  ret i32 %138
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strrchr(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @clusterManagerNodeResetSlots(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 12
  %arraydecay = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 4 %arraydecay, i8 0, i64 16384, i1 false)
  %1 = load ptr, ptr %node.addr, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %1, i32 0, i32 13
  store i32 0, ptr %slots_count, align 4
  ret void
}

declare void @redisFree(ptr noundef) #2

declare ptr @redisConnect(ptr noundef, i32 noundef) #2

declare i32 @cliSecureConnection(ptr noundef, ptr noundef byval(%struct.cliSSLconfig) align 8, ptr noundef) #2

declare i32 @anetKeepAlive(ptr noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCheckRedisReply(ptr noundef %n, ptr noundef %r, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %n.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %is_err = alloca i32, align 4
  store ptr %n, ptr %n.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  store i32 0, ptr %is_err, align 4
  %0 = load ptr, ptr %r.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %r.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %2, 6
  %conv = zext i1 %cmp to i32
  store i32 %conv, ptr %is_err, align 4
  br i1 %cmp, label %if.then, label %if.end11

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load i32, ptr %is_err, align 4
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end10

if.then2:                                         ; preds = %if.then
  %4 = load ptr, ptr %err.addr, align 8
  %cmp3 = icmp ne ptr %4, null
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then2
  %5 = load ptr, ptr %r.addr, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 3
  %6 = load i64, ptr %len, align 8
  %add = add i64 %6, 1
  %mul = mul i64 %add, 1
  %call = call noalias ptr @zmalloc(i64 noundef %mul) #14
  %7 = load ptr, ptr %err.addr, align 8
  store ptr %call, ptr %7, align 8
  %8 = load ptr, ptr %err.addr, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %r.addr, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %str, align 8
  %12 = load ptr, ptr %r.addr, align 8
  %len6 = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 3
  %13 = load i64, ptr %len6, align 8
  %add7 = add i64 %13, 1
  %call8 = call i64 @redis_strlcpy(ptr noundef %9, ptr noundef %11, i64 noundef %add7)
  br label %if.end

if.else:                                          ; preds = %if.then2
  %14 = load ptr, ptr %n.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %ip, align 8
  %16 = load ptr, ptr %n.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %port, align 8
  %18 = load ptr, ptr %r.addr, align 8
  %str9 = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 4
  %19 = load ptr, ptr %str9, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %15, i32 noundef %17, ptr noundef %19)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then5
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %lor.lhs.false
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.end10
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

declare i64 @redis_strlcpy(ptr noundef, ptr noundef, i64 noundef) #2

declare void @listRelease(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @freeClusterManagerNodeFlags(ptr noundef %flags) #0 {
entry:
  %flags.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %flag = alloca ptr, align 8
  store ptr %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %flags.addr, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %flag, align 8
  %3 = load ptr, ptr %flag, align 8
  call void @hi_sdsfree(ptr noundef %3)
  br label %while.cond, !llvm.loop !146

while.end:                                        ; preds = %while.cond
  %4 = load ptr, ptr %flags.addr, align 8
  call void @listRelease(ptr noundef %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerGetNodeRedisInfo(ptr noundef %node, ptr noundef %err) #0 {
entry:
  %retval = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %info = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.186)
  store ptr %call, ptr %info, align 8
  %2 = load ptr, ptr %err.addr, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %info, align 8
  %cmp1 = icmp eq ptr %4, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %5 = load ptr, ptr %info, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type, align 8
  %cmp4 = icmp eq i32 %6, 6
  br i1 %cmp4, label %if.then5, label %if.end13

if.then5:                                         ; preds = %if.end3
  %7 = load ptr, ptr %err.addr, align 8
  %cmp6 = icmp ne ptr %7, null
  br i1 %cmp6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.then5
  %8 = load ptr, ptr %info, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 3
  %9 = load i64, ptr %len, align 8
  %add = add i64 %9, 1
  %mul = mul i64 %add, 1
  %call8 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  %10 = load ptr, ptr %err.addr, align 8
  store ptr %call8, ptr %10, align 8
  %11 = load ptr, ptr %err.addr, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %info, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %str, align 8
  %15 = load ptr, ptr %info, align 8
  %len9 = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 3
  %16 = load i64, ptr %len9, align 8
  %add10 = add i64 %16, 1
  %call11 = call i64 @redis_strlcpy(ptr noundef %12, ptr noundef %14, i64 noundef %add10)
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %if.then5
  %17 = load ptr, ptr %info, align 8
  call void @freeReplyObject(ptr noundef %17)
  store ptr null, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end3
  %18 = load ptr, ptr %info, align 8
  store ptr %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end13, %if.end12, %if.then2
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define internal i64 @getLongInfoField(ptr noundef %info, ptr noundef %field) #0 {
entry:
  %retval = alloca i64, align 8
  %info.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %value = alloca ptr, align 8
  %l = alloca i64, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %1 = load ptr, ptr %field.addr, align 8
  %call = call ptr @getInfoField(ptr noundef %0, ptr noundef %1)
  store ptr %call, ptr %value, align 8
  %2 = load ptr, ptr %value, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 -9223372036854775808, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %value, align 8
  %call1 = call i64 @strtol(ptr noundef %3, ptr noundef null, i32 noundef 10) #15
  store i64 %call1, ptr %l, align 8
  %4 = load ptr, ptr %value, align 8
  call void @zfree(ptr noundef %4)
  %5 = load i64, ptr %l, align 8
  store i64 %5, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i64, ptr %retval, align 8
  ret i64 %6
}

; Function Attrs: nounwind uwtable
define internal ptr @getInfoField(ptr noundef %info, ptr noundef %field) #0 {
entry:
  %retval = alloca ptr, align 8
  %info.addr = alloca ptr, align 8
  %field.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %n1 = alloca ptr, align 8
  %n2 = alloca ptr, align 8
  %result = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %field, ptr %field.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %1 = load ptr, ptr %field.addr, align 8
  %call = call ptr @strstr(ptr noundef %0, ptr noundef %1) #12
  store ptr %call, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %field.addr, align 8
  %call1 = call i64 @strlen(ptr noundef %3) #12
  %add = add i64 %call1, 1
  %4 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 %add
  store ptr %add.ptr, ptr %p, align 8
  %5 = load ptr, ptr %p, align 8
  %call2 = call ptr @strchr(ptr noundef %5, i32 noundef 13) #12
  store ptr %call2, ptr %n1, align 8
  %6 = load ptr, ptr %p, align 8
  %call3 = call ptr @strchr(ptr noundef %6, i32 noundef 44) #12
  store ptr %call3, ptr %n2, align 8
  %7 = load ptr, ptr %n2, align 8
  %tobool4 = icmp ne ptr %7, null
  br i1 %tobool4, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %8 = load ptr, ptr %n2, align 8
  %9 = load ptr, ptr %n1, align 8
  %cmp = icmp ult ptr %8, %9
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  %10 = load ptr, ptr %n2, align 8
  store ptr %10, ptr %n1, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  %11 = load ptr, ptr %n1, align 8
  %12 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %11 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %12 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %mul = mul i64 1, %sub.ptr.sub
  %add7 = add i64 %mul, 1
  %call8 = call noalias ptr @zmalloc(i64 noundef %add7) #14
  store ptr %call8, ptr %result, align 8
  %13 = load ptr, ptr %result, align 8
  %14 = load ptr, ptr %p, align 8
  %15 = load ptr, ptr %n1, align 8
  %16 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast9 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast10 = ptrtoint ptr %16 to i64
  %sub.ptr.sub11 = sub i64 %sub.ptr.lhs.cast9, %sub.ptr.rhs.cast10
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %13, ptr align 1 %14, i64 %sub.ptr.sub11, i1 false)
  %17 = load ptr, ptr %result, align 8
  %18 = load ptr, ptr %n1, align 8
  %19 = load ptr, ptr %p, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %18 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %19 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %arrayidx = getelementptr inbounds i8, ptr %17, i64 %sub.ptr.sub14
  store i8 0, ptr %arrayidx, align 1
  %20 = load ptr, ptr %result, align 8
  store ptr %20, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

; Function Attrs: nounwind
declare i64 @strtol(ptr noundef, ptr noundef, i32 noundef) #6

; Function Attrs: nounwind willreturn memory(read)
declare i64 @atoll(ptr noundef) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #11

declare i32 @vprintf(ptr noundef, ptr noundef) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #11

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerGetAntiAffinityScore(ptr noundef %ipnodes, i32 noundef %ip_count, ptr noundef %offending, ptr noundef %offending_len) #0 {
entry:
  %ipnodes.addr = alloca ptr, align 8
  %ip_count.addr = alloca i32, align 4
  %offending.addr = alloca ptr, align 8
  %offending_len.addr = alloca ptr, align 8
  %score = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %node_len = alloca i32, align 4
  %offending_p = alloca ptr, align 8
  %node_array = alloca ptr, align 8
  %related = alloca ptr, align 8
  %ip = alloca ptr, align 8
  %node = alloca ptr, align 8
  %types = alloca ptr, align 8
  %key = alloca ptr, align 8
  %entry22 = alloca ptr, align 8
  %s = alloca ptr, align 8
  %iter = alloca ptr, align 8
  %entry40 = alloca ptr, align 8
  %types44 = alloca ptr, align 8
  %name46 = alloca ptr, align 8
  %typeslen = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %ipnodes, ptr %ipnodes.addr, align 8
  store i32 %ip_count, ptr %ip_count.addr, align 4
  store ptr %offending, ptr %offending.addr, align 8
  store ptr %offending_len, ptr %offending_len.addr, align 8
  store i32 0, ptr %score, align 4
  %0 = load ptr, ptr @cluster_manager, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %node_len, align 4
  store ptr null, ptr %offending_p, align 8
  %2 = load ptr, ptr %offending.addr, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, ptr %node_len, align 4
  %conv2 = sext i32 %3 to i64
  %mul = mul i64 %conv2, 8
  %call = call noalias ptr @zcalloc(i64 noundef %mul) #14
  %4 = load ptr, ptr %offending.addr, align 8
  store ptr %call, ptr %4, align 8
  %5 = load ptr, ptr %offending.addr, align 8
  %6 = load ptr, ptr %5, align 8
  store ptr %6, ptr %offending_p, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc92, %if.end
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr %ip_count.addr, align 4
  %cmp3 = icmp slt i32 %7, %8
  br i1 %cmp3, label %for.body, label %for.end94

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %ipnodes.addr, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %9, i64 %idxprom
  store ptr %arrayidx, ptr %node_array, align 8
  %call5 = call ptr @dictCreate(ptr noundef @clusterManagerDictType)
  store ptr %call5, ptr %related, align 8
  store ptr null, ptr %ip, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %11 = load i32, ptr %j, align 4
  %12 = load ptr, ptr %node_array, align 8
  %len7 = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %12, i32 0, i32 2
  %13 = load i32, ptr %len7, align 8
  %cmp8 = icmp slt i32 %11, %13
  br i1 %cmp8, label %for.body10, label %for.end

for.body10:                                       ; preds = %for.cond6
  %14 = load ptr, ptr %node_array, align 8
  %nodes = getelementptr inbounds %struct.clusterManagerNodeArray, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %nodes, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom11 = sext i32 %16 to i64
  %arrayidx12 = getelementptr inbounds ptr, ptr %15, i64 %idxprom11
  %17 = load ptr, ptr %arrayidx12, align 8
  store ptr %17, ptr %node, align 8
  %18 = load ptr, ptr %node, align 8
  %cmp13 = icmp eq ptr %18, null
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body10
  br label %for.inc

if.end16:                                         ; preds = %for.body10
  %19 = load ptr, ptr %ip, align 8
  %tobool = icmp ne ptr %19, null
  br i1 %tobool, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.end16
  %20 = load ptr, ptr %node, align 8
  %ip18 = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %ip18, align 8
  store ptr %21, ptr %ip, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end16
  %22 = load ptr, ptr %node, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %22, i32 0, i32 10
  %23 = load ptr, ptr %replicate, align 8
  %tobool20 = icmp ne ptr %23, null
  br i1 %tobool20, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end19
  %24 = load ptr, ptr %node, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %24, i32 0, i32 1
  %25 = load ptr, ptr %name, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end19
  %26 = load ptr, ptr %node, align 8
  %replicate21 = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 10
  %27 = load ptr, ptr %replicate21, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %25, %cond.true ], [ %27, %cond.false ]
  store ptr %cond, ptr %key, align 8
  %28 = load ptr, ptr %related, align 8
  %29 = load ptr, ptr %key, align 8
  %call23 = call ptr @dictFind(ptr noundef %28, ptr noundef %29)
  store ptr %call23, ptr %entry22, align 8
  %30 = load ptr, ptr %entry22, align 8
  %tobool24 = icmp ne ptr %30, null
  br i1 %tobool24, label %if.then25, label %if.else

if.then25:                                        ; preds = %cond.end
  %31 = load ptr, ptr %entry22, align 8
  %call26 = call ptr @dictGetVal(ptr noundef %31)
  %call27 = call ptr @hi_sdsdup(ptr noundef %call26)
  store ptr %call27, ptr %types, align 8
  br label %if.end29

if.else:                                          ; preds = %cond.end
  %call28 = call ptr @hi_sdsempty()
  store ptr %call28, ptr %types, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.else, %if.then25
  %32 = load ptr, ptr %node, align 8
  %replicate30 = getelementptr inbounds %struct.clusterManagerNode, ptr %32, i32 0, i32 10
  %33 = load ptr, ptr %replicate30, align 8
  %tobool31 = icmp ne ptr %33, null
  br i1 %tobool31, label %if.then32, label %if.else34

if.then32:                                        ; preds = %if.end29
  %34 = load ptr, ptr %types, align 8
  %call33 = call ptr @hi_sdscat(ptr noundef %34, ptr noundef @.str.212)
  store ptr %call33, ptr %types, align 8
  br label %if.end37

if.else34:                                        ; preds = %if.end29
  %call35 = call ptr @hi_sdsnew(ptr noundef @.str.213)
  %35 = load ptr, ptr %types, align 8
  %call36 = call ptr @hi_sdscatsds(ptr noundef %call35, ptr noundef %35)
  store ptr %call36, ptr %s, align 8
  %36 = load ptr, ptr %types, align 8
  call void @hi_sdsfree(ptr noundef %36)
  %37 = load ptr, ptr %s, align 8
  store ptr %37, ptr %types, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.else34, %if.then32
  %38 = load ptr, ptr %related, align 8
  %39 = load ptr, ptr %key, align 8
  %40 = load ptr, ptr %types, align 8
  %call38 = call i32 @dictReplace(ptr noundef %38, ptr noundef %39, ptr noundef %40)
  br label %for.inc

for.inc:                                          ; preds = %if.end37, %if.then15
  %41 = load i32, ptr %j, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond6, !llvm.loop !147

for.end:                                          ; preds = %for.cond6
  %42 = load ptr, ptr %related, align 8
  %call39 = call ptr @dictGetIterator(ptr noundef %42)
  store ptr %call39, ptr %iter, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.end, %if.then66, %if.then52, %for.end
  %43 = load ptr, ptr %iter, align 8
  %call41 = call ptr @dictNext(ptr noundef %43)
  store ptr %call41, ptr %entry40, align 8
  %cmp42 = icmp ne ptr %call41, null
  br i1 %cmp42, label %while.body, label %while.end91

while.body:                                       ; preds = %while.cond
  %44 = load ptr, ptr %entry40, align 8
  %call45 = call ptr @dictGetVal(ptr noundef %44)
  store ptr %call45, ptr %types44, align 8
  %45 = load ptr, ptr %entry40, align 8
  %call47 = call ptr @dictGetKey(ptr noundef %45)
  store ptr %call47, ptr %name46, align 8
  %46 = load ptr, ptr %types44, align 8
  %call48 = call i64 @hi_sdslen(ptr noundef %46)
  %conv49 = trunc i64 %call48 to i32
  store i32 %conv49, ptr %typeslen, align 4
  %47 = load i32, ptr %typeslen, align 4
  %cmp50 = icmp slt i32 %47, 2
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %while.body
  br label %while.cond, !llvm.loop !148

if.end53:                                         ; preds = %while.body
  %48 = load ptr, ptr %types44, align 8
  %arrayidx54 = getelementptr inbounds i8, ptr %48, i64 0
  %49 = load i8, ptr %arrayidx54, align 1
  %conv55 = sext i8 %49 to i32
  %cmp56 = icmp eq i32 %conv55, 109
  br i1 %cmp56, label %if.then58, label %if.else60

if.then58:                                        ; preds = %if.end53
  %50 = load i32, ptr %typeslen, align 4
  %sub = sub nsw i32 %50, 1
  %mul59 = mul nsw i32 10000, %sub
  %51 = load i32, ptr %score, align 4
  %add = add nsw i32 %51, %mul59
  store i32 %add, ptr %score, align 4
  br label %if.end63

if.else60:                                        ; preds = %if.end53
  %52 = load i32, ptr %typeslen, align 4
  %mul61 = mul nsw i32 1, %52
  %53 = load i32, ptr %score, align 4
  %add62 = add nsw i32 %53, %mul61
  store i32 %add62, ptr %score, align 4
  br label %if.end63

if.end63:                                         ; preds = %if.else60, %if.then58
  %54 = load ptr, ptr %offending.addr, align 8
  %cmp64 = icmp eq ptr %54, null
  br i1 %cmp64, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.end63
  br label %while.cond, !llvm.loop !148

if.end67:                                         ; preds = %if.end63
  %55 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %55, ptr noundef %li)
  br label %while.cond68

while.cond68:                                     ; preds = %if.end90, %if.then76, %if.end67
  %call69 = call ptr @listNext(ptr noundef %li)
  store ptr %call69, ptr %ln, align 8
  %cmp70 = icmp ne ptr %call69, null
  br i1 %cmp70, label %while.body72, label %while.end

while.body72:                                     ; preds = %while.cond68
  %56 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %56, i32 0, i32 2
  %57 = load ptr, ptr %value, align 8
  store ptr %57, ptr %n, align 8
  %58 = load ptr, ptr %n, align 8
  %replicate73 = getelementptr inbounds %struct.clusterManagerNode, ptr %58, i32 0, i32 10
  %59 = load ptr, ptr %replicate73, align 8
  %cmp74 = icmp eq ptr %59, null
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %while.body72
  br label %while.cond68, !llvm.loop !149

if.end77:                                         ; preds = %while.body72
  %60 = load ptr, ptr %n, align 8
  %replicate78 = getelementptr inbounds %struct.clusterManagerNode, ptr %60, i32 0, i32 10
  %61 = load ptr, ptr %replicate78, align 8
  %62 = load ptr, ptr %name46, align 8
  %call79 = call i32 @strcmp(ptr noundef %61, ptr noundef %62) #12
  %tobool80 = icmp ne i32 %call79, 0
  br i1 %tobool80, label %if.end90, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end77
  %63 = load ptr, ptr %n, align 8
  %ip81 = getelementptr inbounds %struct.clusterManagerNode, ptr %63, i32 0, i32 2
  %64 = load ptr, ptr %ip81, align 8
  %65 = load ptr, ptr %ip, align 8
  %call82 = call i32 @strcmp(ptr noundef %64, ptr noundef %65) #12
  %tobool83 = icmp ne i32 %call82, 0
  br i1 %tobool83, label %if.end90, label %if.then84

if.then84:                                        ; preds = %land.lhs.true
  %66 = load ptr, ptr %n, align 8
  %67 = load ptr, ptr %offending_p, align 8
  %incdec.ptr = getelementptr inbounds ptr, ptr %67, i32 1
  store ptr %incdec.ptr, ptr %offending_p, align 8
  store ptr %66, ptr %67, align 8
  %68 = load ptr, ptr %offending_len.addr, align 8
  %cmp85 = icmp ne ptr %68, null
  br i1 %cmp85, label %if.then87, label %if.end89

if.then87:                                        ; preds = %if.then84
  %69 = load ptr, ptr %offending_len.addr, align 8
  %70 = load i32, ptr %69, align 4
  %inc88 = add nsw i32 %70, 1
  store i32 %inc88, ptr %69, align 4
  br label %if.end89

if.end89:                                         ; preds = %if.then87, %if.then84
  br label %while.end

if.end90:                                         ; preds = %land.lhs.true, %if.end77
  br label %while.cond68, !llvm.loop !149

while.end:                                        ; preds = %if.end89, %while.cond68
  br label %while.cond, !llvm.loop !148

while.end91:                                      ; preds = %while.cond
  %71 = load ptr, ptr %iter, align 8
  call void @dictReleaseIterator(ptr noundef %71)
  %72 = load ptr, ptr %related, align 8
  call void @dictRelease(ptr noundef %72)
  br label %for.inc92

for.inc92:                                        ; preds = %while.end91
  %73 = load i32, ptr %i, align 4
  %inc93 = add nsw i32 %73, 1
  store i32 %inc93, ptr %i, align 4
  br label %for.cond, !llvm.loop !150

for.end94:                                        ; preds = %for.cond
  %74 = load i32, ptr %score, align 4
  ret i32 %74
}

; Function Attrs: nounwind
declare void @srand(i32 noundef) #6

; Function Attrs: nounwind
declare i64 @time(ptr noundef) #6

declare ptr @dictCreate(ptr noundef) #2

declare ptr @dictFind(ptr noundef, ptr noundef) #2

declare ptr @dictGetVal(ptr noundef) #2

declare ptr @hi_sdscatsds(ptr noundef, ptr noundef) #2

declare i32 @dictReplace(ptr noundef, ptr noundef, ptr noundef) #2

declare void @dictRelease(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i64 @dictSdsHash(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %call = call i64 @hi_sdslen(ptr noundef %1)
  %call1 = call i64 @dictGenHashFunction(ptr noundef %0, i64 noundef %call)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal i32 @dictSdsKeyCompare(ptr noundef %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %retval = alloca i32, align 4
  %d.addr = alloca ptr, align 8
  %key1.addr = alloca ptr, align 8
  %key2.addr = alloca ptr, align 8
  %l1 = alloca i32, align 4
  %l2 = alloca i32, align 4
  store ptr %d, ptr %d.addr, align 8
  store ptr %key1, ptr %key1.addr, align 8
  store ptr %key2, ptr %key2.addr, align 8
  %0 = load ptr, ptr %key1.addr, align 8
  %call = call i64 @hi_sdslen(ptr noundef %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %l1, align 4
  %1 = load ptr, ptr %key2.addr, align 8
  %call1 = call i64 @hi_sdslen(ptr noundef %1)
  %conv2 = trunc i64 %call1 to i32
  store i32 %conv2, ptr %l2, align 4
  %2 = load i32, ptr %l1, align 4
  %3 = load i32, ptr %l2, align 4
  %cmp = icmp ne i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %key1.addr, align 8
  %5 = load ptr, ptr %key2.addr, align 8
  %6 = load i32, ptr %l1, align 4
  %conv4 = sext i32 %6 to i64
  %call5 = call i32 @memcmp(ptr noundef %4, ptr noundef %5, i64 noundef %conv4) #12
  %cmp6 = icmp eq i32 %call5, 0
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal void @dictSdsDestructor(ptr noundef %d, ptr noundef %val) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %val.addr, align 8
  call void @hi_sdsfree(ptr noundef %0)
  ret void
}

declare i64 @dictGenHashFunction(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNodeInfo(ptr noundef %node, i32 noundef %indent) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %indent.addr = alloca i32, align 4
  %info = alloca ptr, align 8
  %spaces = alloca ptr, align 8
  %i = alloca i32, align 4
  %is_master = alloca i32, align 4
  %role = alloca ptr, align 8
  %slots = alloca ptr, align 8
  %flags11 = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store i32 %indent, ptr %indent.addr, align 4
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %info, align 8
  %call1 = call ptr @hi_sdsempty()
  store ptr %call1, ptr %spaces, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %indent.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %spaces, align 8
  %call2 = call ptr @hi_sdscat(ptr noundef %2, ptr noundef @.str.136)
  store ptr %call2, ptr %spaces, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i32, ptr %i, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !151

for.end:                                          ; preds = %for.cond
  %4 = load i32, ptr %indent.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %5 = load ptr, ptr %info, align 8
  %6 = load ptr, ptr %spaces, align 8
  %call3 = call ptr @hi_sdscat(ptr noundef %5, ptr noundef %6)
  store ptr %call3, ptr %info, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %7 = load ptr, ptr %node.addr, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %7, i32 0, i32 8
  %8 = load i32, ptr %flags, align 8
  %and = and i32 %8, 2
  %tobool4 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool4, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %is_master, align 4
  %9 = load i32, ptr %is_master, align 4
  %tobool5 = icmp ne i32 %9, 0
  %cond = select i1 %tobool5, ptr @.str.214, ptr @.str.215
  store ptr %cond, ptr %role, align 8
  store ptr null, ptr %slots, align 8
  %10 = load ptr, ptr %node.addr, align 8
  %dirty = getelementptr inbounds %struct.clusterManagerNode, ptr %10, i32 0, i32 11
  %11 = load i32, ptr %dirty, align 8
  %tobool6 = icmp ne i32 %11, 0
  br i1 %tobool6, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %12 = load ptr, ptr %node.addr, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %12, i32 0, i32 10
  %13 = load ptr, ptr %replicate, align 8
  %cmp7 = icmp ne ptr %13, null
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %land.lhs.true
  %14 = load ptr, ptr %info, align 8
  %15 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %15, i32 0, i32 1
  %16 = load ptr, ptr %name, align 8
  %17 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %ip, align 8
  %19 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %19, i32 0, i32 3
  %20 = load i32, ptr %port, align 8
  %call9 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %14, ptr noundef @.str.216, ptr noundef %16, ptr noundef %18, i32 noundef %20)
  store ptr %call9, ptr %info, align 8
  br label %if.end17

if.else:                                          ; preds = %land.lhs.true, %if.end
  %21 = load ptr, ptr %node.addr, align 8
  %call10 = call ptr @clusterManagerNodeSlotsString(ptr noundef %21)
  store ptr %call10, ptr %slots, align 8
  %22 = load ptr, ptr %node.addr, align 8
  %call12 = call ptr @clusterManagerNodeFlagString(ptr noundef %22)
  store ptr %call12, ptr %flags11, align 8
  %23 = load ptr, ptr %info, align 8
  %24 = load ptr, ptr %role, align 8
  %25 = load ptr, ptr %node.addr, align 8
  %name13 = getelementptr inbounds %struct.clusterManagerNode, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %name13, align 8
  %27 = load ptr, ptr %node.addr, align 8
  %ip14 = getelementptr inbounds %struct.clusterManagerNode, ptr %27, i32 0, i32 2
  %28 = load ptr, ptr %ip14, align 8
  %29 = load ptr, ptr %node.addr, align 8
  %port15 = getelementptr inbounds %struct.clusterManagerNode, ptr %29, i32 0, i32 3
  %30 = load i32, ptr %port15, align 8
  %31 = load ptr, ptr %spaces, align 8
  %32 = load ptr, ptr %slots, align 8
  %33 = load ptr, ptr %node.addr, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %33, i32 0, i32 13
  %34 = load i32, ptr %slots_count, align 4
  %35 = load ptr, ptr %flags11, align 8
  %call16 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %23, ptr noundef @.str.217, ptr noundef %24, ptr noundef %26, ptr noundef %28, i32 noundef %30, ptr noundef %31, ptr noundef %32, i32 noundef %34, ptr noundef %35)
  store ptr %call16, ptr %info, align 8
  %36 = load ptr, ptr %slots, align 8
  call void @hi_sdsfree(ptr noundef %36)
  %37 = load ptr, ptr %flags11, align 8
  call void @hi_sdsfree(ptr noundef %37)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then8
  %38 = load ptr, ptr %node.addr, align 8
  %replicate18 = getelementptr inbounds %struct.clusterManagerNode, ptr %38, i32 0, i32 10
  %39 = load ptr, ptr %replicate18, align 8
  %cmp19 = icmp ne ptr %39, null
  br i1 %cmp19, label %if.then20, label %if.else23

if.then20:                                        ; preds = %if.end17
  %40 = load ptr, ptr %info, align 8
  %41 = load ptr, ptr %spaces, align 8
  %42 = load ptr, ptr %node.addr, align 8
  %replicate21 = getelementptr inbounds %struct.clusterManagerNode, ptr %42, i32 0, i32 10
  %43 = load ptr, ptr %replicate21, align 8
  %call22 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %40, ptr noundef @.str.218, ptr noundef %41, ptr noundef %43)
  store ptr %call22, ptr %info, align 8
  br label %if.end29

if.else23:                                        ; preds = %if.end17
  %44 = load ptr, ptr %node.addr, align 8
  %replicas_count = getelementptr inbounds %struct.clusterManagerNode, ptr %44, i32 0, i32 14
  %45 = load i32, ptr %replicas_count, align 8
  %tobool24 = icmp ne i32 %45, 0
  br i1 %tobool24, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.else23
  %46 = load ptr, ptr %info, align 8
  %47 = load ptr, ptr %spaces, align 8
  %48 = load ptr, ptr %node.addr, align 8
  %replicas_count26 = getelementptr inbounds %struct.clusterManagerNode, ptr %48, i32 0, i32 14
  %49 = load i32, ptr %replicas_count26, align 8
  %call27 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %46, ptr noundef @.str.219, ptr noundef %47, i32 noundef %49)
  store ptr %call27, ptr %info, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then25, %if.else23
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then20
  %50 = load ptr, ptr %spaces, align 8
  call void @hi_sdsfree(ptr noundef %50)
  %51 = load ptr, ptr %info, align 8
  ret ptr %51
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNodeSlotsString(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %slots = alloca ptr, align 8
  %first_range_idx = alloca i32, align 4
  %last_slot_idx = alloca i32, align 4
  %i = alloca i32, align 4
  %has_slot = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %slots, align 8
  store i32 -1, ptr %first_range_idx, align 4
  store i32 -1, ptr %last_slot_idx, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %node.addr, align 8
  %slots1 = getelementptr inbounds %struct.clusterManagerNode, ptr %1, i32 0, i32 12
  %2 = load i32, ptr %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [16384 x i8], ptr %slots1, i64 0, i64 %idxprom
  %3 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %3 to i32
  store i32 %conv, ptr %has_slot, align 4
  %4 = load i32, ptr %has_slot, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %5 = load i32, ptr %first_range_idx, align 4
  %cmp2 = icmp eq i32 %5, -1
  br i1 %cmp2, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.then
  %6 = load ptr, ptr %slots, align 8
  %call5 = call i64 @hi_sdslen(ptr noundef %6)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then4
  %7 = load ptr, ptr %slots, align 8
  %call8 = call ptr @hi_sdscat(ptr noundef %7, ptr noundef @.str.220)
  store ptr %call8, ptr %slots, align 8
  br label %if.end

if.end:                                           ; preds = %if.then7, %if.then4
  %8 = load i32, ptr %i, align 4
  store i32 %8, ptr %first_range_idx, align 4
  %9 = load ptr, ptr %slots, align 8
  %10 = load i32, ptr %i, align 4
  %call9 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %9, ptr noundef @.str.221, i32 noundef %10)
  store ptr %call9, ptr %slots, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  %11 = load i32, ptr %i, align 4
  store i32 %11, ptr %last_slot_idx, align 4
  br label %if.end22

if.else:                                          ; preds = %for.body
  %12 = load i32, ptr %last_slot_idx, align 4
  %cmp11 = icmp sge i32 %12, 0
  br i1 %cmp11, label %if.then13, label %if.end21

if.then13:                                        ; preds = %if.else
  %13 = load i32, ptr %first_range_idx, align 4
  %14 = load i32, ptr %last_slot_idx, align 4
  %cmp14 = icmp eq i32 %13, %14
  br i1 %cmp14, label %if.then16, label %if.else18

if.then16:                                        ; preds = %if.then13
  %15 = load ptr, ptr %slots, align 8
  %call17 = call ptr @hi_sdscat(ptr noundef %15, ptr noundef @.str.157)
  store ptr %call17, ptr %slots, align 8
  br label %if.end20

if.else18:                                        ; preds = %if.then13
  %16 = load ptr, ptr %slots, align 8
  %17 = load i32, ptr %last_slot_idx, align 4
  %call19 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %16, ptr noundef @.str.222, i32 noundef %17)
  store ptr %call19, ptr %slots, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.else18, %if.then16
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.else
  store i32 -1, ptr %last_slot_idx, align 4
  store i32 -1, ptr %first_range_idx, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end10
  br label %for.inc

for.inc:                                          ; preds = %if.end22
  %18 = load i32, ptr %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !152

for.end:                                          ; preds = %for.cond
  %19 = load i32, ptr %last_slot_idx, align 4
  %cmp23 = icmp sge i32 %19, 0
  br i1 %cmp23, label %if.then25, label %if.end33

if.then25:                                        ; preds = %for.end
  %20 = load i32, ptr %first_range_idx, align 4
  %21 = load i32, ptr %last_slot_idx, align 4
  %cmp26 = icmp eq i32 %20, %21
  br i1 %cmp26, label %if.then28, label %if.else30

if.then28:                                        ; preds = %if.then25
  %22 = load ptr, ptr %slots, align 8
  %call29 = call ptr @hi_sdscat(ptr noundef %22, ptr noundef @.str.157)
  store ptr %call29, ptr %slots, align 8
  br label %if.end32

if.else30:                                        ; preds = %if.then25
  %23 = load ptr, ptr %slots, align 8
  %24 = load i32, ptr %last_slot_idx, align 4
  %call31 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %23, ptr noundef @.str.222, i32 noundef %24)
  store ptr %call31, ptr %slots, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.else30, %if.then28
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %for.end
  %25 = load ptr, ptr %slots, align 8
  ret ptr %25
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNodeFlagString(ptr noundef %node) #0 {
entry:
  %retval = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %flags = alloca ptr, align 8
  %empty = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %flag = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %flags, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %flags_str = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 9
  %1 = load ptr, ptr %flags_str, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %flags, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %empty, align 4
  %3 = load ptr, ptr %node.addr, align 8
  %flags_str1 = getelementptr inbounds %struct.clusterManagerNode, ptr %3, i32 0, i32 9
  %4 = load ptr, ptr %flags_str1, align 8
  call void @listRewind(ptr noundef %4, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end10, %if.then5, %if.end
  %call2 = call ptr @listNext(ptr noundef %li)
  store ptr %call2, ptr %ln, align 8
  %cmp = icmp ne ptr %call2, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %flag, align 8
  %7 = load ptr, ptr %flag, align 8
  %call3 = call i32 @strcmp(ptr noundef %7, ptr noundef @.str.191) #12
  %cmp4 = icmp eq i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !153

if.end6:                                          ; preds = %while.body
  %8 = load i32, ptr %empty, align 4
  %tobool7 = icmp ne i32 %8, 0
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end6
  %9 = load ptr, ptr %flags, align 8
  %call9 = call ptr @hi_sdscat(ptr noundef %9, ptr noundef @.str.220)
  store ptr %call9, ptr %flags, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.end6
  %10 = load ptr, ptr %flags, align 8
  %11 = load ptr, ptr %flag, align 8
  %call11 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %10, ptr noundef @.str.223, ptr noundef %11)
  store ptr %call11, ptr %flags, align 8
  store i32 0, ptr %empty, align 4
  br label %while.cond, !llvm.loop !153

while.end:                                        ; preds = %while.cond
  %12 = load ptr, ptr %flags, align 8
  store ptr %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

declare i64 @read(i32 noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerAddSlots(ptr noundef %node, ptr noundef %err) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %_reply = alloca ptr, align 8
  %success = alloca i32, align 4
  %argc = alloca i32, align 4
  %argv = alloca ptr, align 8
  %argvlen = alloca ptr, align 8
  %i = alloca i32, align 4
  %argv_idx = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  store ptr null, ptr %reply, align 8
  store ptr null, ptr %_reply, align 8
  store i32 1, ptr %success, align 4
  %0 = load ptr, ptr %node.addr, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 13
  %1 = load i32, ptr %slots_count, align 4
  %add = add nsw i32 %1, 2
  store i32 %add, ptr %argc, align 4
  %2 = load i32, ptr %argc, align 4
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, 8
  %call = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call, ptr %argv, align 8
  %3 = load i32, ptr %argc, align 4
  %conv1 = sext i32 %3 to i64
  %mul2 = mul i64 %conv1, 8
  %call3 = call noalias ptr @zmalloc(i64 noundef %mul2) #14
  store ptr %call3, ptr %argvlen, align 8
  %4 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 0
  store ptr @.str.227, ptr %arrayidx, align 8
  %5 = load ptr, ptr %argv, align 8
  %arrayidx4 = getelementptr inbounds ptr, ptr %5, i64 1
  store ptr @.str.228, ptr %arrayidx4, align 8
  %6 = load ptr, ptr %argvlen, align 8
  %arrayidx5 = getelementptr inbounds i64, ptr %6, i64 0
  store i64 7, ptr %arrayidx5, align 8
  %7 = load ptr, ptr %argvlen, align 8
  %arrayidx6 = getelementptr inbounds i64, ptr %7, i64 1
  store i64 8, ptr %arrayidx6, align 8
  %8 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %8, align 8
  store i32 2, ptr %argv_idx, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %9 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %9, 16384
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32, ptr %argv_idx, align 4
  %11 = load i32, ptr %argc, align 4
  %cmp8 = icmp sge i32 %10, %11
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  %12 = load ptr, ptr %node.addr, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %12, i32 0, i32 12
  %13 = load i32, ptr %i, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx10 = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom
  %14 = load i8, ptr %arrayidx10, align 1
  %tobool = icmp ne i8 %14, 0
  br i1 %tobool, label %if.then11, label %if.end21

if.then11:                                        ; preds = %if.end
  %15 = load i32, ptr %i, align 4
  %conv12 = sext i32 %15 to i64
  %call13 = call ptr @hi_sdsfromlonglong(i64 noundef %conv12)
  %16 = load ptr, ptr %argv, align 8
  %17 = load i32, ptr %argv_idx, align 4
  %idxprom14 = sext i32 %17 to i64
  %arrayidx15 = getelementptr inbounds ptr, ptr %16, i64 %idxprom14
  store ptr %call13, ptr %arrayidx15, align 8
  %18 = load ptr, ptr %argv, align 8
  %19 = load i32, ptr %argv_idx, align 4
  %idxprom16 = sext i32 %19 to i64
  %arrayidx17 = getelementptr inbounds ptr, ptr %18, i64 %idxprom16
  %20 = load ptr, ptr %arrayidx17, align 8
  %call18 = call i64 @hi_sdslen(ptr noundef %20)
  %21 = load ptr, ptr %argvlen, align 8
  %22 = load i32, ptr %argv_idx, align 4
  %idxprom19 = sext i32 %22 to i64
  %arrayidx20 = getelementptr inbounds i64, ptr %21, i64 %idxprom19
  store i64 %call18, ptr %arrayidx20, align 8
  %23 = load i32, ptr %argv_idx, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, ptr %argv_idx, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then11, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end21
  %24 = load i32, ptr %i, align 4
  %inc22 = add nsw i32 %24, 1
  store i32 %inc22, ptr %i, align 4
  br label %for.cond, !llvm.loop !154

for.end:                                          ; preds = %if.then, %for.cond
  %25 = load i32, ptr %argv_idx, align 4
  %cmp23 = icmp eq i32 %25, 2
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %for.end
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end26:                                         ; preds = %for.end
  %26 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 0
  %27 = load ptr, ptr %context, align 8
  %28 = load i32, ptr %argc, align 4
  %29 = load ptr, ptr %argv, align 8
  %30 = load ptr, ptr %argvlen, align 8
  %call27 = call i32 @redisAppendCommandArgv(ptr noundef %27, i32 noundef %28, ptr noundef %29, ptr noundef %30)
  %31 = load ptr, ptr %node.addr, align 8
  %context28 = getelementptr inbounds %struct.clusterManagerNode, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %context28, align 8
  %call29 = call i32 @redisGetReply(ptr noundef %32, ptr noundef %_reply)
  %cmp30 = icmp ne i32 %call29, 0
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end26
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end33:                                         ; preds = %if.end26
  %33 = load ptr, ptr %_reply, align 8
  store ptr %33, ptr %reply, align 8
  %34 = load ptr, ptr %node.addr, align 8
  %35 = load ptr, ptr %reply, align 8
  %36 = load ptr, ptr %err.addr, align 8
  %call34 = call i32 @clusterManagerCheckRedisReply(ptr noundef %34, ptr noundef %35, ptr noundef %36)
  store i32 %call34, ptr %success, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end33, %if.then32, %if.then25
  %37 = load ptr, ptr %argvlen, align 8
  call void @zfree(ptr noundef %37)
  %38 = load ptr, ptr %argv, align 8
  %cmp35 = icmp ne ptr %38, null
  br i1 %cmp35, label %if.then37, label %if.end47

if.then37:                                        ; preds = %cleanup
  store i32 2, ptr %i, align 4
  br label %for.cond38

for.cond38:                                       ; preds = %for.inc44, %if.then37
  %39 = load i32, ptr %i, align 4
  %40 = load i32, ptr %argc, align 4
  %cmp39 = icmp slt i32 %39, %40
  br i1 %cmp39, label %for.body41, label %for.end46

for.body41:                                       ; preds = %for.cond38
  %41 = load ptr, ptr %argv, align 8
  %42 = load i32, ptr %i, align 4
  %idxprom42 = sext i32 %42 to i64
  %arrayidx43 = getelementptr inbounds ptr, ptr %41, i64 %idxprom42
  %43 = load ptr, ptr %arrayidx43, align 8
  call void @hi_sdsfree(ptr noundef %43)
  br label %for.inc44

for.inc44:                                        ; preds = %for.body41
  %44 = load i32, ptr %i, align 4
  %inc45 = add nsw i32 %44, 1
  store i32 %inc45, ptr %i, align 4
  br label %for.cond38, !llvm.loop !155

for.end46:                                        ; preds = %for.cond38
  %45 = load ptr, ptr %argv, align 8
  call void @zfree(ptr noundef %45)
  br label %if.end47

if.end47:                                         ; preds = %for.end46, %cleanup
  %46 = load ptr, ptr %reply, align 8
  %cmp48 = icmp ne ptr %46, null
  br i1 %cmp48, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end47
  %47 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %47)
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %if.end47
  %48 = load i32, ptr %success, align 4
  ret i32 %48
}

declare ptr @hi_sdsfromlonglong(i64 noundef) #2

declare i32 @redisAppendCommandArgv(ptr noundef, i32 noundef, ptr noundef, ptr noundef) #2

declare i32 @redisGetReply(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerIsConfigConsistent() #0 {
entry:
  %retval = alloca i32, align 4
  %consistent = alloca i32, align 4
  %first_cfg = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %node = alloca ptr, align 8
  %cfg = alloca ptr, align 8
  %0 = load ptr, ptr @cluster_manager, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @cluster_manager, align 8
  %len = getelementptr inbounds %struct.list, ptr %1, i32 0, i32 5
  %2 = load i64, ptr %len, align 8
  %cmp1 = icmp ule i64 %2, 1
  %conv = zext i1 %cmp1 to i32
  store i32 %conv, ptr %consistent, align 4
  %3 = load i32, ptr %consistent, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store ptr null, ptr %first_cfg, align 8
  %4 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %4, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end19, %if.end3
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp4 = icmp ne ptr %call, null
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %node, align 8
  %7 = load ptr, ptr %node, align 8
  %call6 = call ptr @clusterManagerGetConfigSignature(ptr noundef %7)
  store ptr %call6, ptr %cfg, align 8
  %8 = load ptr, ptr %cfg, align 8
  %cmp7 = icmp eq ptr %8, null
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %while.body
  store i32 0, ptr %consistent, align 4
  br label %while.end

if.end10:                                         ; preds = %while.body
  %9 = load ptr, ptr %first_cfg, align 8
  %cmp11 = icmp eq ptr %9, null
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end10
  %10 = load ptr, ptr %cfg, align 8
  store ptr %10, ptr %first_cfg, align 8
  br label %if.end19

if.else:                                          ; preds = %if.end10
  %11 = load ptr, ptr %first_cfg, align 8
  %12 = load ptr, ptr %cfg, align 8
  %call14 = call i32 @hi_sdscmp(ptr noundef %11, ptr noundef %12)
  %tobool15 = icmp ne i32 %call14, 0
  %lnot = xor i1 %tobool15, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %consistent, align 4
  %13 = load ptr, ptr %cfg, align 8
  call void @hi_sdsfree(ptr noundef %13)
  %14 = load i32, ptr %consistent, align 4
  %tobool16 = icmp ne i32 %14, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.else
  br label %while.end

if.end18:                                         ; preds = %if.else
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.then13
  br label %while.cond, !llvm.loop !156

while.end:                                        ; preds = %if.then17, %if.then9, %while.cond
  %15 = load ptr, ptr %first_cfg, align 8
  %cmp20 = icmp ne ptr %15, null
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %while.end
  %16 = load ptr, ptr %first_cfg, align 8
  call void @hi_sdsfree(ptr noundef %16)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %while.end
  %17 = load i32, ptr %consistent, align 4
  store i32 %17, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.then2, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerGetLinkStatus() #0 {
entry:
  %retval = alloca ptr, align 8
  %status = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %node = alloca ptr, align 8
  %links = alloca ptr, align 8
  %lli = alloca %struct.listIter, align 8
  %lln = alloca ptr, align 8
  %link = alloca ptr, align 8
  %from = alloca ptr, align 8
  %entry10 = alloca ptr, align 8
  %myaddr = alloca ptr, align 8
  %0 = load ptr, ptr @cluster_manager, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call = call ptr @dictCreate(ptr noundef @clusterManagerLinkDictType)
  store ptr %call, ptr %status, align 8
  %1 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end24, %if.end
  %call1 = call ptr @listNext(ptr noundef %li)
  store ptr %call1, ptr %ln, align 8
  %cmp2 = icmp ne ptr %call1, null
  br i1 %cmp2, label %while.body, label %while.end25

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %node, align 8
  %4 = load ptr, ptr %node, align 8
  %call3 = call ptr @clusterManagerGetDisconnectedLinks(ptr noundef %4)
  store ptr %call3, ptr %links, align 8
  %5 = load ptr, ptr %links, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.then4, label %if.end24

if.then4:                                         ; preds = %while.body
  %6 = load ptr, ptr %links, align 8
  call void @listRewind(ptr noundef %6, ptr noundef %lli)
  br label %while.cond5

while.cond5:                                      ; preds = %if.end19, %if.then4
  %call6 = call ptr @listNext(ptr noundef %lli)
  store ptr %call6, ptr %lln, align 8
  %cmp7 = icmp ne ptr %call6, null
  br i1 %cmp7, label %while.body8, label %while.end

while.body8:                                      ; preds = %while.cond5
  %7 = load ptr, ptr %lln, align 8
  %value9 = getelementptr inbounds %struct.listNode, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %value9, align 8
  store ptr %8, ptr %link, align 8
  store ptr null, ptr %from, align 8
  %9 = load ptr, ptr %status, align 8
  %10 = load ptr, ptr %link, align 8
  %node_addr = getelementptr inbounds %struct.clusterManagerLink, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %node_addr, align 8
  %call11 = call ptr @dictFind(ptr noundef %9, ptr noundef %11)
  store ptr %call11, ptr %entry10, align 8
  %12 = load ptr, ptr %entry10, align 8
  %tobool12 = icmp ne ptr %12, null
  br i1 %tobool12, label %if.then13, label %if.else

if.then13:                                        ; preds = %while.body8
  %13 = load ptr, ptr %entry10, align 8
  %call14 = call ptr @dictGetVal(ptr noundef %13)
  store ptr %call14, ptr %from, align 8
  br label %if.end19

if.else:                                          ; preds = %while.body8
  %call15 = call ptr @listCreate()
  store ptr %call15, ptr %from, align 8
  %14 = load ptr, ptr %status, align 8
  %15 = load ptr, ptr %link, align 8
  %node_addr16 = getelementptr inbounds %struct.clusterManagerLink, ptr %15, i32 0, i32 1
  %16 = load ptr, ptr %node_addr16, align 8
  %call17 = call ptr @hi_sdsdup(ptr noundef %16)
  %17 = load ptr, ptr %from, align 8
  %call18 = call i32 @dictAdd(ptr noundef %14, ptr noundef %call17, ptr noundef %17)
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then13
  %call20 = call ptr @hi_sdsempty()
  store ptr %call20, ptr %myaddr, align 8
  %18 = load ptr, ptr %myaddr, align 8
  %19 = load ptr, ptr %node, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %ip, align 8
  %21 = load ptr, ptr %node, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %21, i32 0, i32 3
  %22 = load i32, ptr %port, align 8
  %call21 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %18, ptr noundef @.str.238, ptr noundef %20, i32 noundef %22)
  store ptr %call21, ptr %myaddr, align 8
  %23 = load ptr, ptr %from, align 8
  %24 = load ptr, ptr %myaddr, align 8
  %call22 = call ptr @listAddNodeTail(ptr noundef %23, ptr noundef %24)
  %25 = load ptr, ptr %link, align 8
  %node_name = getelementptr inbounds %struct.clusterManagerLink, ptr %25, i32 0, i32 0
  %26 = load ptr, ptr %node_name, align 8
  call void @hi_sdsfree(ptr noundef %26)
  %27 = load ptr, ptr %link, align 8
  %node_addr23 = getelementptr inbounds %struct.clusterManagerLink, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %node_addr23, align 8
  call void @hi_sdsfree(ptr noundef %28)
  %29 = load ptr, ptr %link, align 8
  call void @zfree(ptr noundef %29)
  br label %while.cond5, !llvm.loop !157

while.end:                                        ; preds = %while.cond5
  %30 = load ptr, ptr %links, align 8
  call void @listRelease(ptr noundef %30)
  br label %if.end24

if.end24:                                         ; preds = %while.end, %while.body
  br label %while.cond, !llvm.loop !158

while.end25:                                      ; preds = %while.cond
  %31 = load ptr, ptr %status, align 8
  store ptr %31, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end25, %if.then
  %32 = load ptr, ptr %retval, align 8
  ret ptr %32
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerGetConfigSignature(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %signature = alloca ptr, align 8
  %node_count = alloca i32, align 4
  %i = alloca i32, align 4
  %name_len = alloca i32, align 4
  %node_configs = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %lines = alloca ptr, align 8
  %p = alloca ptr, align 8
  %line = alloca ptr, align 8
  %nodename = alloca ptr, align 8
  %tot_size = alloca i32, align 4
  %token = alloca ptr, align 8
  %remaining = alloca i32, align 4
  %slots = alloca ptr, align 8
  %c = alloca i32, align 4
  %size = alloca i32, align 4
  %slotsdef = alloca ptr, align 8
  %cfg = alloca ptr, align 8
  %sp = alloca ptr, align 8
  %slen = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store ptr null, ptr %signature, align 8
  store i32 0, ptr %node_count, align 4
  store i32 0, ptr %i, align 4
  store i32 0, ptr %name_len, align 4
  store ptr null, ptr %node_configs, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.189)
  store ptr %call, ptr %reply, align 8
  %2 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %4, 6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %5 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %str, align 8
  store ptr %6, ptr %lines, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end105, %if.then29, %if.then23, %if.then19, %if.end
  %7 = load ptr, ptr %lines, align 8
  %call2 = call ptr @strstr(ptr noundef %7, ptr noundef @.str.116) #12
  store ptr %call2, ptr %p, align 8
  %cmp3 = icmp ne ptr %call2, null
  br i1 %cmp3, label %while.body, label %while.end106

while.body:                                       ; preds = %while.cond
  store i32 0, ptr %i, align 4
  %8 = load ptr, ptr %p, align 8
  store i8 0, ptr %8, align 1
  %9 = load ptr, ptr %lines, align 8
  store ptr %9, ptr %line, align 8
  %10 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %10, i64 1
  store ptr %add.ptr, ptr %lines, align 8
  store ptr null, ptr %nodename, align 8
  store i32 0, ptr %tot_size, align 4
  br label %while.cond4

while.cond4:                                      ; preds = %if.end16, %while.body
  %11 = load ptr, ptr %line, align 8
  %call5 = call ptr @strchr(ptr noundef %11, i32 noundef 32) #12
  store ptr %call5, ptr %p, align 8
  %cmp6 = icmp ne ptr %call5, null
  br i1 %cmp6, label %while.body7, label %while.end

while.body7:                                      ; preds = %while.cond4
  %12 = load ptr, ptr %p, align 8
  store i8 0, ptr %12, align 1
  %13 = load ptr, ptr %line, align 8
  store ptr %13, ptr %token, align 8
  %14 = load ptr, ptr %p, align 8
  %add.ptr8 = getelementptr inbounds i8, ptr %14, i64 1
  store ptr %add.ptr8, ptr %line, align 8
  %15 = load i32, ptr %i, align 4
  %cmp9 = icmp eq i32 %15, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %while.body7
  %16 = load ptr, ptr %token, align 8
  store ptr %16, ptr %nodename, align 8
  %17 = load ptr, ptr %p, align 8
  %18 = load ptr, ptr %token, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %18 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  store i32 %conv, ptr %tot_size, align 4
  %19 = load i32, ptr %tot_size, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, ptr %tot_size, align 4
  store i32 %19, ptr %name_len, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %while.body7
  %20 = load i32, ptr %i, align 4
  %inc12 = add nsw i32 %20, 1
  store i32 %inc12, ptr %i, align 4
  %cmp13 = icmp eq i32 %inc12, 8
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  br label %while.end

if.end16:                                         ; preds = %if.end11
  br label %while.cond4, !llvm.loop !159

while.end:                                        ; preds = %if.then15, %while.cond4
  %21 = load i32, ptr %i, align 4
  %cmp17 = icmp ne i32 %21, 8
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %while.end
  br label %while.cond, !llvm.loop !160

if.end20:                                         ; preds = %while.end
  %22 = load ptr, ptr %nodename, align 8
  %cmp21 = icmp eq ptr %22, null
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end20
  br label %while.cond, !llvm.loop !160

if.end24:                                         ; preds = %if.end20
  %23 = load ptr, ptr %line, align 8
  %call25 = call i64 @strlen(ptr noundef %23) #12
  %conv26 = trunc i64 %call25 to i32
  store i32 %conv26, ptr %remaining, align 4
  %24 = load i32, ptr %remaining, align 4
  %cmp27 = icmp eq i32 %24, 0
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end24
  br label %while.cond, !llvm.loop !160

if.end30:                                         ; preds = %if.end24
  store ptr null, ptr %slots, align 8
  store i32 0, ptr %c, align 4
  br label %while.cond31

while.cond31:                                     ; preds = %if.end57, %if.end30
  %25 = load i32, ptr %remaining, align 4
  %cmp32 = icmp sgt i32 %25, 0
  br i1 %cmp32, label %while.body34, label %while.end58

while.body34:                                     ; preds = %while.cond31
  %26 = load ptr, ptr %line, align 8
  %call35 = call ptr @strchr(ptr noundef %26, i32 noundef 32) #12
  store ptr %call35, ptr %p, align 8
  %27 = load ptr, ptr %p, align 8
  %cmp36 = icmp eq ptr %27, null
  br i1 %cmp36, label %if.then38, label %if.end40

if.then38:                                        ; preds = %while.body34
  %28 = load ptr, ptr %line, align 8
  %29 = load i32, ptr %remaining, align 4
  %idx.ext = sext i32 %29 to i64
  %add.ptr39 = getelementptr inbounds i8, ptr %28, i64 %idx.ext
  store ptr %add.ptr39, ptr %p, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %while.body34
  %30 = load ptr, ptr %p, align 8
  %31 = load ptr, ptr %line, align 8
  %sub.ptr.lhs.cast41 = ptrtoint ptr %30 to i64
  %sub.ptr.rhs.cast42 = ptrtoint ptr %31 to i64
  %sub.ptr.sub43 = sub i64 %sub.ptr.lhs.cast41, %sub.ptr.rhs.cast42
  %conv44 = trunc i64 %sub.ptr.sub43 to i32
  store i32 %conv44, ptr %size, align 4
  %32 = load i32, ptr %size, align 4
  %33 = load i32, ptr %remaining, align 4
  %sub = sub nsw i32 %33, %32
  store i32 %sub, ptr %remaining, align 4
  %34 = load i32, ptr %size, align 4
  %35 = load i32, ptr %tot_size, align 4
  %add = add nsw i32 %35, %34
  store i32 %add, ptr %tot_size, align 4
  %36 = load ptr, ptr %line, align 8
  store ptr %36, ptr %slotsdef, align 8
  %37 = load ptr, ptr %p, align 8
  store i8 0, ptr %37, align 1
  %38 = load i32, ptr %remaining, align 4
  %tobool = icmp ne i32 %38, 0
  br i1 %tobool, label %if.then45, label %if.else

if.then45:                                        ; preds = %if.end40
  %39 = load ptr, ptr %p, align 8
  %add.ptr46 = getelementptr inbounds i8, ptr %39, i64 1
  store ptr %add.ptr46, ptr %line, align 8
  %40 = load i32, ptr %remaining, align 4
  %dec = add nsw i32 %40, -1
  store i32 %dec, ptr %remaining, align 4
  br label %if.end47

if.else:                                          ; preds = %if.end40
  %41 = load ptr, ptr %p, align 8
  store ptr %41, ptr %line, align 8
  br label %if.end47

if.end47:                                         ; preds = %if.else, %if.then45
  %42 = load ptr, ptr %slotsdef, align 8
  %arrayidx = getelementptr inbounds i8, ptr %42, i64 0
  %43 = load i8, ptr %arrayidx, align 1
  %conv48 = sext i8 %43 to i32
  %cmp49 = icmp ne i32 %conv48, 91
  br i1 %cmp49, label %if.then51, label %if.end57

if.then51:                                        ; preds = %if.end47
  %44 = load i32, ptr %c, align 4
  %inc52 = add nsw i32 %44, 1
  store i32 %inc52, ptr %c, align 4
  %45 = load ptr, ptr %slots, align 8
  %46 = load i32, ptr %c, align 4
  %conv53 = sext i32 %46 to i64
  %mul = mul i64 %conv53, 8
  %call54 = call ptr @zrealloc(ptr noundef %45, i64 noundef %mul) #13
  store ptr %call54, ptr %slots, align 8
  %47 = load ptr, ptr %slotsdef, align 8
  %48 = load ptr, ptr %slots, align 8
  %49 = load i32, ptr %c, align 4
  %sub55 = sub nsw i32 %49, 1
  %idxprom = sext i32 %sub55 to i64
  %arrayidx56 = getelementptr inbounds ptr, ptr %48, i64 %idxprom
  store ptr %47, ptr %arrayidx56, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then51, %if.end47
  br label %while.cond31, !llvm.loop !161

while.end58:                                      ; preds = %while.cond31
  %50 = load i32, ptr %c, align 4
  %cmp59 = icmp sgt i32 %50, 0
  br i1 %cmp59, label %if.then61, label %if.end105

if.then61:                                        ; preds = %while.end58
  %51 = load i32, ptr %c, align 4
  %cmp62 = icmp sgt i32 %51, 1
  br i1 %cmp62, label %if.then64, label %if.end66

if.then64:                                        ; preds = %if.then61
  %52 = load ptr, ptr %slots, align 8
  %53 = load i32, ptr %c, align 4
  %conv65 = sext i32 %53 to i64
  call void @qsort(ptr noundef %52, i64 noundef %conv65, i64 noundef 8, ptr noundef @clusterManagerSlotCompare)
  br label %if.end66

if.end66:                                         ; preds = %if.then64, %if.then61
  %54 = load i32, ptr %node_count, align 4
  %inc67 = add nsw i32 %54, 1
  store i32 %inc67, ptr %node_count, align 4
  %55 = load ptr, ptr %node_configs, align 8
  %56 = load i32, ptr %node_count, align 4
  %conv68 = sext i32 %56 to i64
  %mul69 = mul i64 %conv68, 8
  %call70 = call ptr @zrealloc(ptr noundef %55, i64 noundef %mul69) #13
  store ptr %call70, ptr %node_configs, align 8
  %57 = load i32, ptr %c, align 4
  %sub71 = sub nsw i32 %57, 1
  %conv72 = sext i32 %sub71 to i64
  %mul73 = mul i64 1, %conv72
  %58 = load i32, ptr %tot_size, align 4
  %conv74 = sext i32 %58 to i64
  %add75 = add i64 %conv74, %mul73
  %conv76 = trunc i64 %add75 to i32
  store i32 %conv76, ptr %tot_size, align 4
  %59 = load i32, ptr %tot_size, align 4
  %conv77 = sext i32 %59 to i64
  %mul78 = mul i64 1, %conv77
  %add79 = add i64 %mul78, 1
  %call80 = call noalias ptr @zmalloc(i64 noundef %add79) #14
  store ptr %call80, ptr %cfg, align 8
  %60 = load ptr, ptr %cfg, align 8
  %61 = load ptr, ptr %nodename, align 8
  %62 = load i32, ptr %name_len, align 4
  %conv81 = sext i32 %62 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %60, ptr align 1 %61, i64 %conv81, i1 false)
  %63 = load ptr, ptr %cfg, align 8
  %64 = load i32, ptr %name_len, align 4
  %idx.ext82 = sext i32 %64 to i64
  %add.ptr83 = getelementptr inbounds i8, ptr %63, i64 %idx.ext82
  store ptr %add.ptr83, ptr %sp, align 8
  %65 = load ptr, ptr %sp, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %65, i32 1
  store ptr %incdec.ptr, ptr %sp, align 8
  store i8 58, ptr %65, align 1
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end66
  %66 = load i32, ptr %i, align 4
  %67 = load i32, ptr %c, align 4
  %cmp84 = icmp slt i32 %66, %67
  br i1 %cmp84, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %68 = load i32, ptr %i, align 4
  %cmp86 = icmp sgt i32 %68, 0
  br i1 %cmp86, label %if.then88, label %if.end90

if.then88:                                        ; preds = %for.body
  %69 = load ptr, ptr %sp, align 8
  %incdec.ptr89 = getelementptr inbounds i8, ptr %69, i32 1
  store ptr %incdec.ptr89, ptr %sp, align 8
  store i8 44, ptr %69, align 1
  br label %if.end90

if.end90:                                         ; preds = %if.then88, %for.body
  %70 = load ptr, ptr %slots, align 8
  %71 = load i32, ptr %i, align 4
  %idxprom91 = sext i32 %71 to i64
  %arrayidx92 = getelementptr inbounds ptr, ptr %70, i64 %idxprom91
  %72 = load ptr, ptr %arrayidx92, align 8
  %call93 = call i64 @strlen(ptr noundef %72) #12
  %conv94 = trunc i64 %call93 to i32
  store i32 %conv94, ptr %slen, align 4
  %73 = load ptr, ptr %sp, align 8
  %74 = load ptr, ptr %slots, align 8
  %75 = load i32, ptr %i, align 4
  %idxprom95 = sext i32 %75 to i64
  %arrayidx96 = getelementptr inbounds ptr, ptr %74, i64 %idxprom95
  %76 = load ptr, ptr %arrayidx96, align 8
  %77 = load i32, ptr %slen, align 4
  %conv97 = sext i32 %77 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %73, ptr align 1 %76, i64 %conv97, i1 false)
  %78 = load i32, ptr %slen, align 4
  %79 = load ptr, ptr %sp, align 8
  %idx.ext98 = sext i32 %78 to i64
  %add.ptr99 = getelementptr inbounds i8, ptr %79, i64 %idx.ext98
  store ptr %add.ptr99, ptr %sp, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end90
  %80 = load i32, ptr %i, align 4
  %inc100 = add nsw i32 %80, 1
  store i32 %inc100, ptr %i, align 4
  br label %for.cond, !llvm.loop !162

for.end:                                          ; preds = %for.cond
  %81 = load ptr, ptr %sp, align 8
  %incdec.ptr101 = getelementptr inbounds i8, ptr %81, i32 1
  store ptr %incdec.ptr101, ptr %sp, align 8
  store i8 0, ptr %81, align 1
  %82 = load ptr, ptr %cfg, align 8
  %83 = load ptr, ptr %node_configs, align 8
  %84 = load i32, ptr %node_count, align 4
  %sub102 = sub nsw i32 %84, 1
  %idxprom103 = sext i32 %sub102 to i64
  %arrayidx104 = getelementptr inbounds ptr, ptr %83, i64 %idxprom103
  store ptr %82, ptr %arrayidx104, align 8
  br label %if.end105

if.end105:                                        ; preds = %for.end, %while.end58
  %85 = load ptr, ptr %slots, align 8
  call void @zfree(ptr noundef %85)
  br label %while.cond, !llvm.loop !160

while.end106:                                     ; preds = %while.cond
  %86 = load i32, ptr %node_count, align 4
  %cmp107 = icmp sgt i32 %86, 0
  br i1 %cmp107, label %if.then109, label %if.end131

if.then109:                                       ; preds = %while.end106
  %87 = load i32, ptr %node_count, align 4
  %cmp110 = icmp sgt i32 %87, 1
  br i1 %cmp110, label %if.then112, label %if.end114

if.then112:                                       ; preds = %if.then109
  %88 = load ptr, ptr %node_configs, align 8
  %89 = load i32, ptr %node_count, align 4
  %conv113 = sext i32 %89 to i64
  call void @qsort(ptr noundef %88, i64 noundef %conv113, i64 noundef 8, ptr noundef @clusterManagerSlotCompare)
  br label %if.end114

if.end114:                                        ; preds = %if.then112, %if.then109
  %call115 = call ptr @hi_sdsempty()
  store ptr %call115, ptr %signature, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond116

for.cond116:                                      ; preds = %for.inc128, %if.end114
  %90 = load i32, ptr %i, align 4
  %91 = load i32, ptr %node_count, align 4
  %cmp117 = icmp slt i32 %90, %91
  br i1 %cmp117, label %for.body119, label %for.end130

for.body119:                                      ; preds = %for.cond116
  %92 = load i32, ptr %i, align 4
  %cmp120 = icmp sgt i32 %92, 0
  br i1 %cmp120, label %if.then122, label %if.end124

if.then122:                                       ; preds = %for.body119
  %93 = load ptr, ptr %signature, align 8
  %call123 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %93, ptr noundef @.str.236, i32 noundef 124)
  store ptr %call123, ptr %signature, align 8
  br label %if.end124

if.end124:                                        ; preds = %if.then122, %for.body119
  %94 = load ptr, ptr %signature, align 8
  %95 = load ptr, ptr %node_configs, align 8
  %96 = load i32, ptr %i, align 4
  %idxprom125 = sext i32 %96 to i64
  %arrayidx126 = getelementptr inbounds ptr, ptr %95, i64 %idxprom125
  %97 = load ptr, ptr %arrayidx126, align 8
  %call127 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %94, ptr noundef @.str.237, ptr noundef %97)
  store ptr %call127, ptr %signature, align 8
  br label %for.inc128

for.inc128:                                       ; preds = %if.end124
  %98 = load i32, ptr %i, align 4
  %inc129 = add nsw i32 %98, 1
  store i32 %inc129, ptr %i, align 4
  br label %for.cond116, !llvm.loop !163

for.end130:                                       ; preds = %for.cond116
  br label %if.end131

if.end131:                                        ; preds = %for.end130, %while.end106
  br label %cleanup

cleanup:                                          ; preds = %if.end131, %if.then
  %99 = load ptr, ptr %reply, align 8
  %cmp132 = icmp ne ptr %99, null
  br i1 %cmp132, label %if.then134, label %if.end135

if.then134:                                       ; preds = %cleanup
  %100 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %100)
  br label %if.end135

if.end135:                                        ; preds = %if.then134, %cleanup
  %101 = load ptr, ptr %node_configs, align 8
  %cmp136 = icmp ne ptr %101, null
  br i1 %cmp136, label %if.then138, label %if.end148

if.then138:                                       ; preds = %if.end135
  store i32 0, ptr %i, align 4
  br label %for.cond139

for.cond139:                                      ; preds = %for.inc145, %if.then138
  %102 = load i32, ptr %i, align 4
  %103 = load i32, ptr %node_count, align 4
  %cmp140 = icmp slt i32 %102, %103
  br i1 %cmp140, label %for.body142, label %for.end147

for.body142:                                      ; preds = %for.cond139
  %104 = load ptr, ptr %node_configs, align 8
  %105 = load i32, ptr %i, align 4
  %idxprom143 = sext i32 %105 to i64
  %arrayidx144 = getelementptr inbounds ptr, ptr %104, i64 %idxprom143
  %106 = load ptr, ptr %arrayidx144, align 8
  call void @zfree(ptr noundef %106)
  br label %for.inc145

for.inc145:                                       ; preds = %for.body142
  %107 = load i32, ptr %i, align 4
  %inc146 = add nsw i32 %107, 1
  store i32 %inc146, ptr %i, align 4
  br label %for.cond139, !llvm.loop !164

for.end147:                                       ; preds = %for.cond139
  %108 = load ptr, ptr %node_configs, align 8
  call void @zfree(ptr noundef %108)
  br label %if.end148

if.end148:                                        ; preds = %for.end147, %if.end135
  %109 = load ptr, ptr %signature, align 8
  ret ptr %109
}

declare i32 @hi_sdscmp(ptr noundef, ptr noundef) #2

declare void @qsort(ptr noundef, i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerGetDisconnectedLinks(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %links = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %lines = alloca ptr, align 8
  %p = alloca ptr, align 8
  %line = alloca ptr, align 8
  %i = alloca i32, align 4
  %nodename = alloca ptr, align 8
  %addr = alloca ptr, align 8
  %flags = alloca ptr, align 8
  %link_status = alloca ptr, align 8
  %token = alloca ptr, align 8
  %disconnected = alloca i32, align 4
  %handshaking = alloca i32, align 4
  %link = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr null, ptr %links, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.189)
  store ptr %call, ptr %reply, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %3 = load ptr, ptr %reply, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %2, ptr noundef %3, ptr noundef null)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call ptr @listCreate()
  store ptr %call2, ptr %links, align 8
  %4 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %str, align 8
  store ptr %5, ptr %lines, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end57, %if.then40, %if.then36, %if.end
  %6 = load ptr, ptr %lines, align 8
  %call3 = call ptr @strstr(ptr noundef %6, ptr noundef @.str.116) #12
  store ptr %call3, ptr %p, align 8
  %cmp = icmp ne ptr %call3, null
  br i1 %cmp, label %while.body, label %while.end58

while.body:                                       ; preds = %while.cond
  store i32 0, ptr %i, align 4
  %7 = load ptr, ptr %p, align 8
  store i8 0, ptr %7, align 1
  %8 = load ptr, ptr %lines, align 8
  store ptr %8, ptr %line, align 8
  %9 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr inbounds i8, ptr %9, i64 1
  store ptr %add.ptr, ptr %lines, align 8
  store ptr null, ptr %nodename, align 8
  store ptr null, ptr %addr, align 8
  store ptr null, ptr %flags, align 8
  store ptr null, ptr %link_status, align 8
  br label %while.cond4

while.cond4:                                      ; preds = %if.end26, %while.body
  %10 = load ptr, ptr %line, align 8
  %call5 = call ptr @strchr(ptr noundef %10, i32 noundef 32) #12
  store ptr %call5, ptr %p, align 8
  %cmp6 = icmp ne ptr %call5, null
  br i1 %cmp6, label %while.body7, label %while.end

while.body7:                                      ; preds = %while.cond4
  %11 = load ptr, ptr %p, align 8
  store i8 0, ptr %11, align 1
  %12 = load ptr, ptr %line, align 8
  store ptr %12, ptr %token, align 8
  %13 = load ptr, ptr %p, align 8
  %add.ptr8 = getelementptr inbounds i8, ptr %13, i64 1
  store ptr %add.ptr8, ptr %line, align 8
  %14 = load i32, ptr %i, align 4
  %cmp9 = icmp eq i32 %14, 0
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %while.body7
  %15 = load ptr, ptr %token, align 8
  store ptr %15, ptr %nodename, align 8
  br label %if.end26

if.else:                                          ; preds = %while.body7
  %16 = load i32, ptr %i, align 4
  %cmp11 = icmp eq i32 %16, 1
  br i1 %cmp11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.else
  %17 = load ptr, ptr %token, align 8
  store ptr %17, ptr %addr, align 8
  br label %if.end25

if.else13:                                        ; preds = %if.else
  %18 = load i32, ptr %i, align 4
  %cmp14 = icmp eq i32 %18, 2
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.else13
  %19 = load ptr, ptr %token, align 8
  store ptr %19, ptr %flags, align 8
  br label %if.end24

if.else16:                                        ; preds = %if.else13
  %20 = load i32, ptr %i, align 4
  %cmp17 = icmp eq i32 %20, 7
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.else16
  %21 = load ptr, ptr %token, align 8
  store ptr %21, ptr %link_status, align 8
  br label %if.end23

if.else19:                                        ; preds = %if.else16
  %22 = load i32, ptr %i, align 4
  %cmp20 = icmp eq i32 %22, 8
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.else19
  br label %while.end

if.end22:                                         ; preds = %if.else19
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then18
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then15
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then12
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.then10
  %23 = load i32, ptr %i, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %while.cond4, !llvm.loop !165

while.end:                                        ; preds = %if.then21, %while.cond4
  %24 = load i32, ptr %i, align 4
  %cmp27 = icmp eq i32 %24, 7
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %while.end
  %25 = load ptr, ptr %line, align 8
  store ptr %25, ptr %link_status, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %while.end
  %26 = load ptr, ptr %nodename, align 8
  %cmp30 = icmp eq ptr %26, null
  br i1 %cmp30, label %if.then36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end29
  %27 = load ptr, ptr %addr, align 8
  %cmp31 = icmp eq ptr %27, null
  br i1 %cmp31, label %if.then36, label %lor.lhs.false32

lor.lhs.false32:                                  ; preds = %lor.lhs.false
  %28 = load ptr, ptr %flags, align 8
  %cmp33 = icmp eq ptr %28, null
  br i1 %cmp33, label %if.then36, label %lor.lhs.false34

lor.lhs.false34:                                  ; preds = %lor.lhs.false32
  %29 = load ptr, ptr %link_status, align 8
  %cmp35 = icmp eq ptr %29, null
  br i1 %cmp35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %lor.lhs.false34, %lor.lhs.false32, %lor.lhs.false, %if.end29
  br label %while.cond, !llvm.loop !166

if.end37:                                         ; preds = %lor.lhs.false34
  %30 = load ptr, ptr %flags, align 8
  %call38 = call ptr @strstr(ptr noundef %30, ptr noundef @.str.191) #12
  %cmp39 = icmp ne ptr %call38, null
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end37
  br label %while.cond, !llvm.loop !166

if.end41:                                         ; preds = %if.end37
  %31 = load ptr, ptr %flags, align 8
  %call42 = call ptr @strstr(ptr noundef %31, ptr noundef @.str.195) #12
  %cmp43 = icmp ne ptr %call42, null
  br i1 %cmp43, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end41
  %32 = load ptr, ptr %link_status, align 8
  %call44 = call ptr @strstr(ptr noundef %32, ptr noundef @.str.195) #12
  %tobool45 = icmp ne ptr %call44, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end41
  %33 = phi i1 [ true, %if.end41 ], [ %tobool45, %lor.rhs ]
  %lor.ext = zext i1 %33 to i32
  store i32 %lor.ext, ptr %disconnected, align 4
  %34 = load ptr, ptr %flags, align 8
  %call46 = call ptr @strstr(ptr noundef %34, ptr noundef @.str.239) #12
  %cmp47 = icmp ne ptr %call46, null
  %conv = zext i1 %cmp47 to i32
  store i32 %conv, ptr %handshaking, align 4
  %35 = load i32, ptr %disconnected, align 4
  %tobool48 = icmp ne i32 %35, 0
  br i1 %tobool48, label %if.then51, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.end
  %36 = load i32, ptr %handshaking, align 4
  %tobool50 = icmp ne i32 %36, 0
  br i1 %tobool50, label %if.then51, label %if.end57

if.then51:                                        ; preds = %lor.lhs.false49, %lor.end
  %call52 = call noalias ptr @zmalloc(i64 noundef 24) #14
  store ptr %call52, ptr %link, align 8
  %37 = load ptr, ptr %nodename, align 8
  %call53 = call ptr @hi_sdsnew(ptr noundef %37)
  %38 = load ptr, ptr %link, align 8
  %node_name = getelementptr inbounds %struct.clusterManagerLink, ptr %38, i32 0, i32 0
  store ptr %call53, ptr %node_name, align 8
  %39 = load ptr, ptr %addr, align 8
  %call54 = call ptr @hi_sdsnew(ptr noundef %39)
  %40 = load ptr, ptr %link, align 8
  %node_addr = getelementptr inbounds %struct.clusterManagerLink, ptr %40, i32 0, i32 1
  store ptr %call54, ptr %node_addr, align 8
  %41 = load ptr, ptr %link, align 8
  %connected = getelementptr inbounds %struct.clusterManagerLink, ptr %41, i32 0, i32 2
  store i32 0, ptr %connected, align 8
  %42 = load i32, ptr %handshaking, align 4
  %43 = load ptr, ptr %link, align 8
  %handshaking55 = getelementptr inbounds %struct.clusterManagerLink, ptr %43, i32 0, i32 3
  store i32 %42, ptr %handshaking55, align 4
  %44 = load ptr, ptr %links, align 8
  %45 = load ptr, ptr %link, align 8
  %call56 = call ptr @listAddNodeTail(ptr noundef %44, ptr noundef %45)
  br label %if.end57

if.end57:                                         ; preds = %if.then51, %lor.lhs.false49
  br label %while.cond, !llvm.loop !166

while.end58:                                      ; preds = %while.cond
  br label %cleanup

cleanup:                                          ; preds = %while.end58, %if.then
  %46 = load ptr, ptr %reply, align 8
  %cmp59 = icmp ne ptr %46, null
  br i1 %cmp59, label %if.then61, label %if.end62

if.then61:                                        ; preds = %cleanup
  %47 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %47)
  br label %if.end62

if.end62:                                         ; preds = %if.then61, %cleanup
  %48 = load ptr, ptr %links, align 8
  ret ptr %48
}

; Function Attrs: nounwind uwtable
define internal void @dictListDestructor(ptr noundef %d, ptr noundef %val) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %val.addr, align 8
  call void @listRelease(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNodeByName(ptr noundef %name) #0 {
entry:
  %retval = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %found = alloca ptr, align 8
  %lcname = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr @cluster_manager, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %found, align 8
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %lcname, align 8
  %1 = load ptr, ptr %lcname, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %call1 = call ptr @hi_sdscpy(ptr noundef %1, ptr noundef %2)
  store ptr %call1, ptr %lcname, align 8
  %3 = load ptr, ptr %lcname, align 8
  call void @hi_sdstolower(ptr noundef %3)
  %4 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %4, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %if.end
  %call2 = call ptr @listNext(ptr noundef %li)
  store ptr %call2, ptr %ln, align 8
  %cmp3 = icmp ne ptr %call2, null
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %n, align 8
  %7 = load ptr, ptr %n, align 8
  %name4 = getelementptr inbounds %struct.clusterManagerNode, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %name4, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %while.body
  %9 = load ptr, ptr %n, align 8
  %name5 = getelementptr inbounds %struct.clusterManagerNode, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %name5, align 8
  %11 = load ptr, ptr %lcname, align 8
  %call6 = call i32 @hi_sdscmp(ptr noundef %10, ptr noundef %11)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %land.lhs.true
  %12 = load ptr, ptr %n, align 8
  store ptr %12, ptr %found, align 8
  br label %while.end

if.end9:                                          ; preds = %land.lhs.true, %while.body
  br label %while.cond, !llvm.loop !167

while.end:                                        ; preds = %if.then8, %while.cond
  %13 = load ptr, ptr %lcname, align 8
  call void @hi_sdsfree(ptr noundef %13)
  %14 = load ptr, ptr %found, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

declare ptr @hi_sdscpy(ptr noundef, ptr noundef) #2

declare void @hi_sdstolower(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @clusterManagerOnError(ptr noundef %err) #0 {
entry:
  %err.addr = alloca ptr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @listCreate()
  store ptr %call, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  %2 = load ptr, ptr %err.addr, align 8
  %call1 = call ptr @listAddNodeTail(ptr noundef %1, ptr noundef %2)
  %3 = load ptr, ptr %err.addr, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.115, ptr noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerFixOpenSlot(i32 noundef %slot) #0 {
entry:
  %slot.addr = alloca i32, align 4
  %force_fix = alloca i32, align 4
  %success = alloca i32, align 4
  %owners = alloca ptr, align 8
  %migrating = alloca ptr, align 8
  %importing = alloca ptr, align 8
  %migrating_str = alloca ptr, align 8
  %importing_str = alloca ptr, align 8
  %owner = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %r = alloca ptr, align 8
  %n37 = alloca ptr, align 8
  %is_migrating = alloca i32, align 4
  %is_importing = alloca i32, align 4
  %i = alloca i32, align 4
  %migrating_slot = alloca ptr, align 8
  %sep = alloca ptr, align 8
  %i67 = alloca i32, align 4
  %importing_slot = alloca ptr, align 8
  %sep77 = alloca ptr, align 8
  %r96 = alloca ptr, align 8
  %sep107 = alloca ptr, align 8
  %n161 = alloca ptr, align 8
  %move_opts = alloca i32, align 4
  %src = alloca ptr, align 8
  %dst = alloca ptr, align 8
  %n213 = alloca ptr, align 8
  %n233 = alloca ptr, align 8
  %try_to_fix = alloca i32, align 4
  %src255 = alloca ptr, align 8
  %dst258 = alloca ptr, align 8
  %target_id = alloca ptr, align 8
  %i259 = alloca i32, align 4
  %migrating_slot264 = alloca ptr, align 8
  %li279 = alloca %struct.listIter, align 8
  %ln280 = alloca ptr, align 8
  %n285 = alloca ptr, align 8
  %count = alloca i32, align 4
  %n313 = alloca ptr, align 8
  %n332 = alloca ptr, align 8
  %try_to_close_slot = alloca i32, align 4
  %n347 = alloca ptr, align 8
  %r353 = alloca ptr, align 8
  %n371 = alloca ptr, align 8
  %r376 = alloca ptr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %0, 1024
  store i32 %and, ptr %force_fix, align 4
  %1 = load i32, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 2), align 8
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, ptr %force_fix, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %3 = load i32, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 2), align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.259, i32 noundef %3)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %land.lhs.true, %entry
  %4 = load i32, ptr %slot.addr, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.260, i32 noundef %4)
  store i32 1, ptr %success, align 4
  %call = call ptr @listCreate()
  store ptr %call, ptr %owners, align 8
  %call1 = call ptr @listCreate()
  store ptr %call1, ptr %migrating, align 8
  %call2 = call ptr @listCreate()
  store ptr %call2, ptr %importing, align 8
  %call3 = call ptr @hi_sdsempty()
  store ptr %call3, ptr %migrating_str, align 8
  %call4 = call ptr @hi_sdsempty()
  store ptr %call4, ptr %importing_str, align 8
  store ptr null, ptr %owner, align 8
  %5 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %5, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end28, %if.then9, %if.end
  %call5 = call ptr @listNext(ptr noundef %li)
  store ptr %call5, ptr %ln, align 8
  %cmp6 = icmp ne ptr %call5, null
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %value, align 8
  store ptr %7, ptr %n, align 8
  %8 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %8, i32 0, i32 8
  %9 = load i32, ptr %flags, align 8
  %and7 = and i32 %9, 2
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !168

if.end10:                                         ; preds = %while.body
  %10 = load ptr, ptr %n, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %10, i32 0, i32 12
  %11 = load i32, ptr %slot.addr, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom
  %12 = load i8, ptr %arrayidx, align 1
  %tobool11 = icmp ne i8 %12, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end10
  %13 = load ptr, ptr %owners, align 8
  %14 = load ptr, ptr %n, align 8
  %call13 = call ptr @listAddNodeTail(ptr noundef %13, ptr noundef %14)
  br label %if.end28

if.else:                                          ; preds = %if.end10
  %15 = load ptr, ptr %n, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %context, align 8
  %17 = load i32, ptr %slot.addr, align 4
  %call14 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %16, ptr noundef @.str.261, i32 noundef %17)
  store ptr %call14, ptr %r, align 8
  %18 = load ptr, ptr %n, align 8
  %19 = load ptr, ptr %r, align 8
  %call15 = call i32 @clusterManagerCheckRedisReply(ptr noundef %18, ptr noundef %19, ptr noundef null)
  store i32 %call15, ptr %success, align 4
  %20 = load i32, ptr %success, align 4
  %tobool16 = icmp ne i32 %20, 0
  br i1 %tobool16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.else
  %21 = load ptr, ptr %r, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %21, i32 0, i32 1
  %22 = load i64, ptr %integer, align 8
  %cmp18 = icmp sgt i64 %22, 0
  br i1 %cmp18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %land.lhs.true17
  %23 = load i32, ptr %slot.addr, align 4
  %24 = load ptr, ptr %n, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %ip, align 8
  %26 = load ptr, ptr %n, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 3
  %27 = load i32, ptr %port, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.262, i32 noundef %23, ptr noundef %25, i32 noundef %27)
  %28 = load ptr, ptr %owners, align 8
  %29 = load ptr, ptr %n, align 8
  %call20 = call ptr @listAddNodeTail(ptr noundef %28, ptr noundef %29)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %land.lhs.true17, %if.else
  %30 = load ptr, ptr %r, align 8
  %tobool22 = icmp ne ptr %30, null
  br i1 %tobool22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end21
  %31 = load ptr, ptr %r, align 8
  call void @freeReplyObject(ptr noundef %31)
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end21
  %32 = load i32, ptr %success, align 4
  %tobool25 = icmp ne i32 %32, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.end24
  br label %cleanup

if.end27:                                         ; preds = %if.end24
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.then12
  br label %while.cond, !llvm.loop !168

while.end:                                        ; preds = %while.cond
  %33 = load ptr, ptr %owners, align 8
  %len = getelementptr inbounds %struct.list, ptr %33, i32 0, i32 5
  %34 = load i64, ptr %len, align 8
  %cmp29 = icmp eq i64 %34, 1
  br i1 %cmp29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %while.end
  %35 = load ptr, ptr %owners, align 8
  %head = getelementptr inbounds %struct.list, ptr %35, i32 0, i32 0
  %36 = load ptr, ptr %head, align 8
  %value31 = getelementptr inbounds %struct.listNode, ptr %36, i32 0, i32 2
  %37 = load ptr, ptr %value31, align 8
  store ptr %37, ptr %owner, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %while.end
  %38 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %38, ptr noundef %li)
  br label %while.cond33

while.cond33:                                     ; preds = %if.end122, %if.then42, %if.end32
  %call34 = call ptr @listNext(ptr noundef %li)
  store ptr %call34, ptr %ln, align 8
  %cmp35 = icmp ne ptr %call34, null
  br i1 %cmp35, label %while.body36, label %while.end123

while.body36:                                     ; preds = %while.cond33
  %39 = load ptr, ptr %ln, align 8
  %value38 = getelementptr inbounds %struct.listNode, ptr %39, i32 0, i32 2
  %40 = load ptr, ptr %value38, align 8
  store ptr %40, ptr %n37, align 8
  %41 = load ptr, ptr %n37, align 8
  %flags39 = getelementptr inbounds %struct.clusterManagerNode, ptr %41, i32 0, i32 8
  %42 = load i32, ptr %flags39, align 8
  %and40 = and i32 %42, 2
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %while.body36
  br label %while.cond33, !llvm.loop !169

if.end43:                                         ; preds = %while.body36
  store i32 0, ptr %is_migrating, align 4
  store i32 0, ptr %is_importing, align 4
  %43 = load ptr, ptr %n37, align 8
  %migrating44 = getelementptr inbounds %struct.clusterManagerNode, ptr %43, i32 0, i32 16
  %44 = load ptr, ptr %migrating44, align 8
  %tobool45 = icmp ne ptr %44, null
  br i1 %tobool45, label %if.then46, label %if.end61

if.then46:                                        ; preds = %if.end43
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then46
  %45 = load i32, ptr %i, align 4
  %46 = load ptr, ptr %n37, align 8
  %migrating_count = getelementptr inbounds %struct.clusterManagerNode, ptr %46, i32 0, i32 18
  %47 = load i32, ptr %migrating_count, align 8
  %cmp47 = icmp slt i32 %45, %47
  br i1 %cmp47, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %48 = load ptr, ptr %n37, align 8
  %migrating48 = getelementptr inbounds %struct.clusterManagerNode, ptr %48, i32 0, i32 16
  %49 = load ptr, ptr %migrating48, align 8
  %50 = load i32, ptr %i, align 4
  %idxprom49 = sext i32 %50 to i64
  %arrayidx50 = getelementptr inbounds ptr, ptr %49, i64 %idxprom49
  %51 = load ptr, ptr %arrayidx50, align 8
  store ptr %51, ptr %migrating_slot, align 8
  %52 = load ptr, ptr %migrating_slot, align 8
  %call51 = call i32 @atoi(ptr noundef %52) #12
  %53 = load i32, ptr %slot.addr, align 4
  %cmp52 = icmp eq i32 %call51, %53
  br i1 %cmp52, label %if.then53, label %if.end60

if.then53:                                        ; preds = %for.body
  %54 = load ptr, ptr %migrating, align 8
  %len54 = getelementptr inbounds %struct.list, ptr %54, i32 0, i32 5
  %55 = load i64, ptr %len54, align 8
  %cmp55 = icmp eq i64 %55, 0
  %cond = select i1 %cmp55, ptr @.str.26, ptr @.str.220
  store ptr %cond, ptr %sep, align 8
  %56 = load ptr, ptr %migrating_str, align 8
  %57 = load ptr, ptr %sep, align 8
  %58 = load ptr, ptr %n37, align 8
  %ip56 = getelementptr inbounds %struct.clusterManagerNode, ptr %58, i32 0, i32 2
  %59 = load ptr, ptr %ip56, align 8
  %60 = load ptr, ptr %n37, align 8
  %port57 = getelementptr inbounds %struct.clusterManagerNode, ptr %60, i32 0, i32 3
  %61 = load i32, ptr %port57, align 8
  %call58 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %56, ptr noundef @.str.263, ptr noundef %57, ptr noundef %59, i32 noundef %61)
  store ptr %call58, ptr %migrating_str, align 8
  %62 = load ptr, ptr %migrating, align 8
  %63 = load ptr, ptr %n37, align 8
  %call59 = call ptr @listAddNodeTail(ptr noundef %62, ptr noundef %63)
  store i32 1, ptr %is_migrating, align 4
  br label %for.end

if.end60:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end60
  %64 = load i32, ptr %i, align 4
  %add = add nsw i32 %64, 2
  store i32 %add, ptr %i, align 4
  br label %for.cond, !llvm.loop !170

for.end:                                          ; preds = %if.then53, %for.cond
  br label %if.end61

if.end61:                                         ; preds = %for.end, %if.end43
  %65 = load i32, ptr %is_migrating, align 4
  %tobool62 = icmp ne i32 %65, 0
  br i1 %tobool62, label %if.end89, label %land.lhs.true63

land.lhs.true63:                                  ; preds = %if.end61
  %66 = load ptr, ptr %n37, align 8
  %importing64 = getelementptr inbounds %struct.clusterManagerNode, ptr %66, i32 0, i32 17
  %67 = load ptr, ptr %importing64, align 8
  %tobool65 = icmp ne ptr %67, null
  br i1 %tobool65, label %if.then66, label %if.end89

if.then66:                                        ; preds = %land.lhs.true63
  store i32 0, ptr %i67, align 4
  br label %for.cond68

for.cond68:                                       ; preds = %for.inc86, %if.then66
  %68 = load i32, ptr %i67, align 4
  %69 = load ptr, ptr %n37, align 8
  %importing_count = getelementptr inbounds %struct.clusterManagerNode, ptr %69, i32 0, i32 19
  %70 = load i32, ptr %importing_count, align 4
  %cmp69 = icmp slt i32 %68, %70
  br i1 %cmp69, label %for.body70, label %for.end88

for.body70:                                       ; preds = %for.cond68
  %71 = load ptr, ptr %n37, align 8
  %importing71 = getelementptr inbounds %struct.clusterManagerNode, ptr %71, i32 0, i32 17
  %72 = load ptr, ptr %importing71, align 8
  %73 = load i32, ptr %i67, align 4
  %idxprom72 = sext i32 %73 to i64
  %arrayidx73 = getelementptr inbounds ptr, ptr %72, i64 %idxprom72
  %74 = load ptr, ptr %arrayidx73, align 8
  store ptr %74, ptr %importing_slot, align 8
  %75 = load ptr, ptr %importing_slot, align 8
  %call74 = call i32 @atoi(ptr noundef %75) #12
  %76 = load i32, ptr %slot.addr, align 4
  %cmp75 = icmp eq i32 %call74, %76
  br i1 %cmp75, label %if.then76, label %if.end85

if.then76:                                        ; preds = %for.body70
  %77 = load ptr, ptr %importing, align 8
  %len78 = getelementptr inbounds %struct.list, ptr %77, i32 0, i32 5
  %78 = load i64, ptr %len78, align 8
  %cmp79 = icmp eq i64 %78, 0
  %cond80 = select i1 %cmp79, ptr @.str.26, ptr @.str.220
  store ptr %cond80, ptr %sep77, align 8
  %79 = load ptr, ptr %importing_str, align 8
  %80 = load ptr, ptr %sep77, align 8
  %81 = load ptr, ptr %n37, align 8
  %ip81 = getelementptr inbounds %struct.clusterManagerNode, ptr %81, i32 0, i32 2
  %82 = load ptr, ptr %ip81, align 8
  %83 = load ptr, ptr %n37, align 8
  %port82 = getelementptr inbounds %struct.clusterManagerNode, ptr %83, i32 0, i32 3
  %84 = load i32, ptr %port82, align 8
  %call83 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %79, ptr noundef @.str.263, ptr noundef %80, ptr noundef %82, i32 noundef %84)
  store ptr %call83, ptr %importing_str, align 8
  %85 = load ptr, ptr %importing, align 8
  %86 = load ptr, ptr %n37, align 8
  %call84 = call ptr @listAddNodeTail(ptr noundef %85, ptr noundef %86)
  store i32 1, ptr %is_importing, align 4
  br label %for.end88

if.end85:                                         ; preds = %for.body70
  br label %for.inc86

for.inc86:                                        ; preds = %if.end85
  %87 = load i32, ptr %i67, align 4
  %add87 = add nsw i32 %87, 2
  store i32 %add87, ptr %i67, align 4
  br label %for.cond68, !llvm.loop !171

for.end88:                                        ; preds = %if.then76, %for.cond68
  br label %if.end89

if.end89:                                         ; preds = %for.end88, %land.lhs.true63, %if.end61
  %88 = load i32, ptr %is_migrating, align 4
  %tobool90 = icmp ne i32 %88, 0
  br i1 %tobool90, label %if.end122, label %land.lhs.true91

land.lhs.true91:                                  ; preds = %if.end89
  %89 = load i32, ptr %is_importing, align 4
  %tobool92 = icmp ne i32 %89, 0
  br i1 %tobool92, label %if.end122, label %land.lhs.true93

land.lhs.true93:                                  ; preds = %land.lhs.true91
  %90 = load ptr, ptr %n37, align 8
  %91 = load ptr, ptr %owner, align 8
  %cmp94 = icmp ne ptr %90, %91
  br i1 %cmp94, label %if.then95, label %if.end122

if.then95:                                        ; preds = %land.lhs.true93
  %92 = load ptr, ptr %n37, align 8
  %context97 = getelementptr inbounds %struct.clusterManagerNode, ptr %92, i32 0, i32 0
  %93 = load ptr, ptr %context97, align 8
  %94 = load i32, ptr %slot.addr, align 4
  %call98 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %93, ptr noundef @.str.261, i32 noundef %94)
  store ptr %call98, ptr %r96, align 8
  %95 = load ptr, ptr %n37, align 8
  %96 = load ptr, ptr %r96, align 8
  %call99 = call i32 @clusterManagerCheckRedisReply(ptr noundef %95, ptr noundef %96, ptr noundef null)
  store i32 %call99, ptr %success, align 4
  %97 = load i32, ptr %success, align 4
  %tobool100 = icmp ne i32 %97, 0
  br i1 %tobool100, label %land.lhs.true101, label %if.end115

land.lhs.true101:                                 ; preds = %if.then95
  %98 = load ptr, ptr %r96, align 8
  %integer102 = getelementptr inbounds %struct.redisReply, ptr %98, i32 0, i32 1
  %99 = load i64, ptr %integer102, align 8
  %cmp103 = icmp sgt i64 %99, 0
  br i1 %cmp103, label %if.then104, label %if.end115

if.then104:                                       ; preds = %land.lhs.true101
  %100 = load i32, ptr %slot.addr, align 4
  %101 = load ptr, ptr %n37, align 8
  %ip105 = getelementptr inbounds %struct.clusterManagerNode, ptr %101, i32 0, i32 2
  %102 = load ptr, ptr %ip105, align 8
  %103 = load ptr, ptr %n37, align 8
  %port106 = getelementptr inbounds %struct.clusterManagerNode, ptr %103, i32 0, i32 3
  %104 = load i32, ptr %port106, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.264, i32 noundef %100, ptr noundef %102, i32 noundef %104)
  %105 = load ptr, ptr %importing, align 8
  %len108 = getelementptr inbounds %struct.list, ptr %105, i32 0, i32 5
  %106 = load i64, ptr %len108, align 8
  %cmp109 = icmp eq i64 %106, 0
  %cond110 = select i1 %cmp109, ptr @.str.26, ptr @.str.220
  store ptr %cond110, ptr %sep107, align 8
  %107 = load ptr, ptr %importing_str, align 8
  %108 = load ptr, ptr %sep107, align 8
  %109 = load ptr, ptr %n37, align 8
  %ip111 = getelementptr inbounds %struct.clusterManagerNode, ptr %109, i32 0, i32 2
  %110 = load ptr, ptr %ip111, align 8
  %111 = load ptr, ptr %n37, align 8
  %port112 = getelementptr inbounds %struct.clusterManagerNode, ptr %111, i32 0, i32 3
  %112 = load i32, ptr %port112, align 8
  %call113 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %107, ptr noundef @.str.263, ptr noundef %108, ptr noundef %110, i32 noundef %112)
  store ptr %call113, ptr %importing_str, align 8
  %113 = load ptr, ptr %importing, align 8
  %114 = load ptr, ptr %n37, align 8
  %call114 = call ptr @listAddNodeTail(ptr noundef %113, ptr noundef %114)
  br label %if.end115

if.end115:                                        ; preds = %if.then104, %land.lhs.true101, %if.then95
  %115 = load ptr, ptr %r96, align 8
  %tobool116 = icmp ne ptr %115, null
  br i1 %tobool116, label %if.then117, label %if.end118

if.then117:                                       ; preds = %if.end115
  %116 = load ptr, ptr %r96, align 8
  call void @freeReplyObject(ptr noundef %116)
  br label %if.end118

if.end118:                                        ; preds = %if.then117, %if.end115
  %117 = load i32, ptr %success, align 4
  %tobool119 = icmp ne i32 %117, 0
  br i1 %tobool119, label %if.end121, label %if.then120

if.then120:                                       ; preds = %if.end118
  br label %cleanup

if.end121:                                        ; preds = %if.end118
  br label %if.end122

if.end122:                                        ; preds = %if.end121, %land.lhs.true93, %land.lhs.true91, %if.end89
  br label %while.cond33, !llvm.loop !169

while.end123:                                     ; preds = %while.cond33
  %118 = load ptr, ptr %migrating_str, align 8
  %call124 = call i64 @hi_sdslen(ptr noundef %118)
  %cmp125 = icmp ugt i64 %call124, 0
  br i1 %cmp125, label %if.then126, label %if.end128

if.then126:                                       ; preds = %while.end123
  %119 = load ptr, ptr %migrating_str, align 8
  %call127 = call i32 (ptr, ...) @printf(ptr noundef @.str.265, ptr noundef %119)
  br label %if.end128

if.end128:                                        ; preds = %if.then126, %while.end123
  %120 = load ptr, ptr %importing_str, align 8
  %call129 = call i64 @hi_sdslen(ptr noundef %120)
  %cmp130 = icmp ugt i64 %call129, 0
  br i1 %cmp130, label %if.then131, label %if.end133

if.then131:                                       ; preds = %if.end128
  %121 = load ptr, ptr %importing_str, align 8
  %call132 = call i32 (ptr, ...) @printf(ptr noundef @.str.266, ptr noundef %121)
  br label %if.end133

if.end133:                                        ; preds = %if.then131, %if.end128
  %122 = load ptr, ptr %owner, align 8
  %cmp134 = icmp eq ptr %122, null
  br i1 %cmp134, label %if.then135, label %if.end153

if.then135:                                       ; preds = %if.end133
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.267)
  %123 = load ptr, ptr @cluster_manager, align 8
  %124 = load i32, ptr %slot.addr, align 4
  %call136 = call ptr @clusterManagerGetNodeWithMostKeysInSlot(ptr noundef %123, i32 noundef %124, ptr noundef null)
  store ptr %call136, ptr %owner, align 8
  %125 = load ptr, ptr %owner, align 8
  %cmp137 = icmp eq ptr %125, null
  br i1 %cmp137, label %if.then138, label %if.end139

if.then138:                                       ; preds = %if.then135
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.268)
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end139:                                        ; preds = %if.then135
  %126 = load ptr, ptr %owner, align 8
  %ip140 = getelementptr inbounds %struct.clusterManagerNode, ptr %126, i32 0, i32 2
  %127 = load ptr, ptr %ip140, align 8
  %128 = load ptr, ptr %owner, align 8
  %port141 = getelementptr inbounds %struct.clusterManagerNode, ptr %128, i32 0, i32 3
  %129 = load i32, ptr %port141, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.269, ptr noundef %127, i32 noundef %129)
  %130 = load ptr, ptr %owner, align 8
  %131 = load i32, ptr %slot.addr, align 4
  %call142 = call i32 @clusterManagerClearSlotStatus(ptr noundef %130, i32 noundef %131)
  store i32 %call142, ptr %success, align 4
  %132 = load i32, ptr %success, align 4
  %tobool143 = icmp ne i32 %132, 0
  br i1 %tobool143, label %if.end145, label %if.then144

if.then144:                                       ; preds = %if.end139
  br label %cleanup

if.end145:                                        ; preds = %if.end139
  %133 = load ptr, ptr %owner, align 8
  %134 = load i32, ptr %slot.addr, align 4
  %call146 = call i32 @clusterManagerSetSlotOwner(ptr noundef %133, i32 noundef %134, i32 noundef 0)
  store i32 %call146, ptr %success, align 4
  %135 = load i32, ptr %success, align 4
  %tobool147 = icmp ne i32 %135, 0
  br i1 %tobool147, label %if.end149, label %if.then148

if.then148:                                       ; preds = %if.end145
  br label %cleanup

if.end149:                                        ; preds = %if.end145
  %136 = load ptr, ptr %owner, align 8
  %slots150 = getelementptr inbounds %struct.clusterManagerNode, ptr %136, i32 0, i32 12
  %137 = load i32, ptr %slot.addr, align 4
  %idxprom151 = sext i32 %137 to i64
  %arrayidx152 = getelementptr inbounds [16384 x i8], ptr %slots150, i64 0, i64 %idxprom151
  store i8 1, ptr %arrayidx152, align 1
  %138 = load ptr, ptr %migrating, align 8
  %139 = load ptr, ptr %owner, align 8
  call void @clusterManagerRemoveNodeFromList(ptr noundef %138, ptr noundef %139)
  %140 = load ptr, ptr %importing, align 8
  %141 = load ptr, ptr %owner, align 8
  call void @clusterManagerRemoveNodeFromList(ptr noundef %140, ptr noundef %141)
  br label %if.end153

if.end153:                                        ; preds = %if.end149, %if.end133
  %142 = load ptr, ptr %owners, align 8
  %len154 = getelementptr inbounds %struct.list, ptr %142, i32 0, i32 5
  %143 = load i64, ptr %len154, align 8
  %cmp155 = icmp ugt i64 %143, 1
  br i1 %cmp155, label %if.then156, label %if.end183

if.then156:                                       ; preds = %if.end153
  %144 = load ptr, ptr %owners, align 8
  call void @listRewind(ptr noundef %144, ptr noundef %li)
  br label %while.cond157

while.cond157:                                    ; preds = %if.end180, %if.then164, %if.then156
  %call158 = call ptr @listNext(ptr noundef %li)
  store ptr %call158, ptr %ln, align 8
  %cmp159 = icmp ne ptr %call158, null
  br i1 %cmp159, label %while.body160, label %while.end182

while.body160:                                    ; preds = %while.cond157
  %145 = load ptr, ptr %ln, align 8
  %value162 = getelementptr inbounds %struct.listNode, ptr %145, i32 0, i32 2
  %146 = load ptr, ptr %value162, align 8
  store ptr %146, ptr %n161, align 8
  %147 = load ptr, ptr %n161, align 8
  %148 = load ptr, ptr %owner, align 8
  %cmp163 = icmp eq ptr %147, %148
  br i1 %cmp163, label %if.then164, label %if.end165

if.then164:                                       ; preds = %while.body160
  br label %while.cond157, !llvm.loop !172

if.end165:                                        ; preds = %while.body160
  %149 = load ptr, ptr %n161, align 8
  %150 = load i32, ptr %slot.addr, align 4
  %call166 = call i32 @clusterManagerDelSlot(ptr noundef %149, i32 noundef %150, i32 noundef 1)
  store i32 %call166, ptr %success, align 4
  %151 = load i32, ptr %success, align 4
  %tobool167 = icmp ne i32 %151, 0
  br i1 %tobool167, label %if.end169, label %if.then168

if.then168:                                       ; preds = %if.end165
  br label %cleanup

if.end169:                                        ; preds = %if.end165
  %152 = load ptr, ptr %n161, align 8
  %slots170 = getelementptr inbounds %struct.clusterManagerNode, ptr %152, i32 0, i32 12
  %153 = load i32, ptr %slot.addr, align 4
  %idxprom171 = sext i32 %153 to i64
  %arrayidx172 = getelementptr inbounds [16384 x i8], ptr %slots170, i64 0, i64 %idxprom171
  store i8 0, ptr %arrayidx172, align 1
  %154 = load ptr, ptr %n161, align 8
  %155 = load ptr, ptr %owner, align 8
  %156 = load i32, ptr %slot.addr, align 4
  %call173 = call i32 @clusterManagerSetSlot(ptr noundef %154, ptr noundef %155, i32 noundef %156, ptr noundef @.str.270, ptr noundef null)
  store i32 %call173, ptr %success, align 4
  %157 = load i32, ptr %success, align 4
  %tobool174 = icmp ne i32 %157, 0
  br i1 %tobool174, label %if.end176, label %if.then175

if.then175:                                       ; preds = %if.end169
  br label %cleanup

if.end176:                                        ; preds = %if.end169
  %158 = load ptr, ptr %n161, align 8
  %159 = load ptr, ptr %owner, align 8
  %160 = load i32, ptr %slot.addr, align 4
  %call177 = call i32 @clusterManagerSetSlot(ptr noundef %158, ptr noundef %159, i32 noundef %160, ptr noundef @.str.271, ptr noundef null)
  store i32 %call177, ptr %success, align 4
  %161 = load i32, ptr %success, align 4
  %tobool178 = icmp ne i32 %161, 0
  br i1 %tobool178, label %if.end180, label %if.then179

if.then179:                                       ; preds = %if.end176
  br label %cleanup

if.end180:                                        ; preds = %if.end176
  %162 = load ptr, ptr %importing, align 8
  %163 = load ptr, ptr %n161, align 8
  call void @clusterManagerRemoveNodeFromList(ptr noundef %162, ptr noundef %163)
  %164 = load ptr, ptr %importing, align 8
  %165 = load ptr, ptr %n161, align 8
  %call181 = call ptr @listAddNodeTail(ptr noundef %164, ptr noundef %165)
  %166 = load ptr, ptr %migrating, align 8
  %167 = load ptr, ptr %n161, align 8
  call void @clusterManagerRemoveNodeFromList(ptr noundef %166, ptr noundef %167)
  br label %while.cond157, !llvm.loop !172

while.end182:                                     ; preds = %while.cond157
  br label %if.end183

if.end183:                                        ; preds = %while.end182, %if.end153
  store i32 128, ptr %move_opts, align 4
  %168 = load ptr, ptr %migrating, align 8
  %len184 = getelementptr inbounds %struct.list, ptr %168, i32 0, i32 5
  %169 = load i64, ptr %len184, align 8
  %cmp185 = icmp eq i64 %169, 1
  br i1 %cmp185, label %land.lhs.true186, label %if.else199

land.lhs.true186:                                 ; preds = %if.end183
  %170 = load ptr, ptr %importing, align 8
  %len187 = getelementptr inbounds %struct.list, ptr %170, i32 0, i32 5
  %171 = load i64, ptr %len187, align 8
  %cmp188 = icmp eq i64 %171, 1
  br i1 %cmp188, label %if.then189, label %if.else199

if.then189:                                       ; preds = %land.lhs.true186
  %172 = load ptr, ptr %migrating, align 8
  %head190 = getelementptr inbounds %struct.list, ptr %172, i32 0, i32 0
  %173 = load ptr, ptr %head190, align 8
  %value191 = getelementptr inbounds %struct.listNode, ptr %173, i32 0, i32 2
  %174 = load ptr, ptr %value191, align 8
  store ptr %174, ptr %src, align 8
  %175 = load ptr, ptr %importing, align 8
  %head192 = getelementptr inbounds %struct.list, ptr %175, i32 0, i32 0
  %176 = load ptr, ptr %head192, align 8
  %value193 = getelementptr inbounds %struct.listNode, ptr %176, i32 0, i32 2
  %177 = load ptr, ptr %value193, align 8
  store ptr %177, ptr %dst, align 8
  %178 = load i32, ptr %slot.addr, align 4
  %179 = load ptr, ptr %src, align 8
  %ip194 = getelementptr inbounds %struct.clusterManagerNode, ptr %179, i32 0, i32 2
  %180 = load ptr, ptr %ip194, align 8
  %181 = load ptr, ptr %src, align 8
  %port195 = getelementptr inbounds %struct.clusterManagerNode, ptr %181, i32 0, i32 3
  %182 = load i32, ptr %port195, align 8
  %183 = load ptr, ptr %dst, align 8
  %ip196 = getelementptr inbounds %struct.clusterManagerNode, ptr %183, i32 0, i32 2
  %184 = load ptr, ptr %ip196, align 8
  %185 = load ptr, ptr %dst, align 8
  %port197 = getelementptr inbounds %struct.clusterManagerNode, ptr %185, i32 0, i32 3
  %186 = load i32, ptr %port197, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.272, i32 noundef %178, ptr noundef %180, i32 noundef %182, ptr noundef %184, i32 noundef %186)
  %187 = load i32, ptr %move_opts, align 4
  %or = or i32 %187, 4
  store i32 %or, ptr %move_opts, align 4
  %188 = load ptr, ptr %src, align 8
  %189 = load ptr, ptr %dst, align 8
  %190 = load i32, ptr %slot.addr, align 4
  %191 = load i32, ptr %move_opts, align 4
  %call198 = call i32 @clusterManagerMoveSlot(ptr noundef %188, ptr noundef %189, i32 noundef %190, i32 noundef %191, ptr noundef null)
  store i32 %call198, ptr %success, align 4
  br label %if.end392

if.else199:                                       ; preds = %land.lhs.true186, %if.end183
  %192 = load ptr, ptr %migrating, align 8
  %len200 = getelementptr inbounds %struct.list, ptr %192, i32 0, i32 5
  %193 = load i64, ptr %len200, align 8
  %cmp201 = icmp eq i64 %193, 0
  br i1 %cmp201, label %land.lhs.true202, label %if.else248

land.lhs.true202:                                 ; preds = %if.else199
  %194 = load ptr, ptr %importing, align 8
  %len203 = getelementptr inbounds %struct.list, ptr %194, i32 0, i32 5
  %195 = load i64, ptr %len203, align 8
  %cmp204 = icmp ugt i64 %195, 0
  br i1 %cmp204, label %if.then205, label %if.else248

if.then205:                                       ; preds = %land.lhs.true202
  %196 = load i32, ptr %slot.addr, align 4
  %197 = load ptr, ptr %owner, align 8
  %ip206 = getelementptr inbounds %struct.clusterManagerNode, ptr %197, i32 0, i32 2
  %198 = load ptr, ptr %ip206, align 8
  %199 = load ptr, ptr %owner, align 8
  %port207 = getelementptr inbounds %struct.clusterManagerNode, ptr %199, i32 0, i32 3
  %200 = load i32, ptr %port207, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.273, i32 noundef %196, ptr noundef %198, i32 noundef %200)
  %201 = load i32, ptr %move_opts, align 4
  %or208 = or i32 %201, 2
  store i32 %or208, ptr %move_opts, align 4
  %202 = load ptr, ptr %importing, align 8
  call void @listRewind(ptr noundef %202, ptr noundef %li)
  br label %while.cond209

while.cond209:                                    ; preds = %if.end227, %if.then216, %if.then205
  %call210 = call ptr @listNext(ptr noundef %li)
  store ptr %call210, ptr %ln, align 8
  %cmp211 = icmp ne ptr %call210, null
  br i1 %cmp211, label %while.body212, label %while.end228

while.body212:                                    ; preds = %while.cond209
  %203 = load ptr, ptr %ln, align 8
  %value214 = getelementptr inbounds %struct.listNode, ptr %203, i32 0, i32 2
  %204 = load ptr, ptr %value214, align 8
  store ptr %204, ptr %n213, align 8
  %205 = load ptr, ptr %n213, align 8
  %206 = load ptr, ptr %owner, align 8
  %cmp215 = icmp eq ptr %205, %206
  br i1 %cmp215, label %if.then216, label %if.end217

if.then216:                                       ; preds = %while.body212
  br label %while.cond209, !llvm.loop !173

if.end217:                                        ; preds = %while.body212
  %207 = load ptr, ptr %n213, align 8
  %208 = load ptr, ptr %owner, align 8
  %209 = load i32, ptr %slot.addr, align 4
  %210 = load i32, ptr %move_opts, align 4
  %call218 = call i32 @clusterManagerMoveSlot(ptr noundef %207, ptr noundef %208, i32 noundef %209, i32 noundef %210, ptr noundef null)
  store i32 %call218, ptr %success, align 4
  %211 = load i32, ptr %success, align 4
  %tobool219 = icmp ne i32 %211, 0
  br i1 %tobool219, label %if.end221, label %if.then220

if.then220:                                       ; preds = %if.end217
  br label %cleanup

if.end221:                                        ; preds = %if.end217
  %212 = load i32, ptr %slot.addr, align 4
  %213 = load ptr, ptr %n213, align 8
  %ip222 = getelementptr inbounds %struct.clusterManagerNode, ptr %213, i32 0, i32 2
  %214 = load ptr, ptr %ip222, align 8
  %215 = load ptr, ptr %n213, align 8
  %port223 = getelementptr inbounds %struct.clusterManagerNode, ptr %215, i32 0, i32 3
  %216 = load i32, ptr %port223, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.274, i32 noundef %212, ptr noundef %214, i32 noundef %216)
  %217 = load ptr, ptr %n213, align 8
  %218 = load i32, ptr %slot.addr, align 4
  %call224 = call i32 @clusterManagerClearSlotStatus(ptr noundef %217, i32 noundef %218)
  store i32 %call224, ptr %success, align 4
  %219 = load i32, ptr %success, align 4
  %tobool225 = icmp ne i32 %219, 0
  br i1 %tobool225, label %if.end227, label %if.then226

if.then226:                                       ; preds = %if.end221
  br label %cleanup

if.end227:                                        ; preds = %if.end221
  br label %while.cond209, !llvm.loop !173

while.end228:                                     ; preds = %while.cond209
  %220 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %220, ptr noundef %li)
  br label %while.cond229

while.cond229:                                    ; preds = %if.end246, %if.then241, %if.then236, %while.end228
  %call230 = call ptr @listNext(ptr noundef %li)
  store ptr %call230, ptr %ln, align 8
  %cmp231 = icmp ne ptr %call230, null
  br i1 %cmp231, label %while.body232, label %while.end247

while.body232:                                    ; preds = %while.cond229
  %221 = load ptr, ptr %ln, align 8
  %value234 = getelementptr inbounds %struct.listNode, ptr %221, i32 0, i32 2
  %222 = load ptr, ptr %value234, align 8
  store ptr %222, ptr %n233, align 8
  %223 = load ptr, ptr %n233, align 8
  %224 = load ptr, ptr %owner, align 8
  %cmp235 = icmp eq ptr %223, %224
  br i1 %cmp235, label %if.then236, label %if.end237

if.then236:                                       ; preds = %while.body232
  br label %while.cond229, !llvm.loop !174

if.end237:                                        ; preds = %while.body232
  %225 = load ptr, ptr %n233, align 8
  %flags238 = getelementptr inbounds %struct.clusterManagerNode, ptr %225, i32 0, i32 8
  %226 = load i32, ptr %flags238, align 8
  %and239 = and i32 %226, 2
  %tobool240 = icmp ne i32 %and239, 0
  br i1 %tobool240, label %if.then241, label %if.end242

if.then241:                                       ; preds = %if.end237
  br label %while.cond229, !llvm.loop !174

if.end242:                                        ; preds = %if.end237
  %227 = load ptr, ptr %n233, align 8
  %228 = load ptr, ptr %owner, align 8
  %229 = load i32, ptr %slot.addr, align 4
  %call243 = call i32 @clusterManagerSetSlot(ptr noundef %227, ptr noundef %228, i32 noundef %229, ptr noundef @.str.275, ptr noundef null)
  store i32 %call243, ptr %success, align 4
  %230 = load i32, ptr %success, align 4
  %tobool244 = icmp ne i32 %230, 0
  br i1 %tobool244, label %if.end246, label %if.then245

if.then245:                                       ; preds = %if.end242
  br label %cleanup

if.end246:                                        ; preds = %if.end242
  br label %while.cond229, !llvm.loop !174

while.end247:                                     ; preds = %while.cond229
  br label %if.end391

if.else248:                                       ; preds = %land.lhs.true202, %if.else199
  %231 = load ptr, ptr %migrating, align 8
  %len249 = getelementptr inbounds %struct.list, ptr %231, i32 0, i32 5
  %232 = load i64, ptr %len249, align 8
  %cmp250 = icmp eq i64 %232, 1
  br i1 %cmp250, label %land.lhs.true251, label %if.else340

land.lhs.true251:                                 ; preds = %if.else248
  %233 = load ptr, ptr %importing, align 8
  %len252 = getelementptr inbounds %struct.list, ptr %233, i32 0, i32 5
  %234 = load i64, ptr %len252, align 8
  %cmp253 = icmp ugt i64 %234, 1
  br i1 %cmp253, label %if.then254, label %if.else340

if.then254:                                       ; preds = %land.lhs.true251
  store i32 1, ptr %try_to_fix, align 4
  %235 = load ptr, ptr %migrating, align 8
  %head256 = getelementptr inbounds %struct.list, ptr %235, i32 0, i32 0
  %236 = load ptr, ptr %head256, align 8
  %value257 = getelementptr inbounds %struct.listNode, ptr %236, i32 0, i32 2
  %237 = load ptr, ptr %value257, align 8
  store ptr %237, ptr %src255, align 8
  store ptr null, ptr %dst258, align 8
  store ptr null, ptr %target_id, align 8
  store i32 0, ptr %i259, align 4
  br label %for.cond260

for.cond260:                                      ; preds = %for.inc276, %if.then254
  %238 = load i32, ptr %i259, align 4
  %239 = load ptr, ptr %src255, align 8
  %migrating_count261 = getelementptr inbounds %struct.clusterManagerNode, ptr %239, i32 0, i32 18
  %240 = load i32, ptr %migrating_count261, align 8
  %cmp262 = icmp slt i32 %238, %240
  br i1 %cmp262, label %for.body263, label %for.end278

for.body263:                                      ; preds = %for.cond260
  %241 = load ptr, ptr %src255, align 8
  %migrating265 = getelementptr inbounds %struct.clusterManagerNode, ptr %241, i32 0, i32 16
  %242 = load ptr, ptr %migrating265, align 8
  %243 = load i32, ptr %i259, align 4
  %idxprom266 = sext i32 %243 to i64
  %arrayidx267 = getelementptr inbounds ptr, ptr %242, i64 %idxprom266
  %244 = load ptr, ptr %arrayidx267, align 8
  store ptr %244, ptr %migrating_slot264, align 8
  %245 = load ptr, ptr %migrating_slot264, align 8
  %call268 = call i32 @atoi(ptr noundef %245) #12
  %246 = load i32, ptr %slot.addr, align 4
  %cmp269 = icmp eq i32 %call268, %246
  br i1 %cmp269, label %if.then270, label %if.end275

if.then270:                                       ; preds = %for.body263
  %247 = load ptr, ptr %src255, align 8
  %migrating271 = getelementptr inbounds %struct.clusterManagerNode, ptr %247, i32 0, i32 16
  %248 = load ptr, ptr %migrating271, align 8
  %249 = load i32, ptr %i259, align 4
  %add272 = add nsw i32 %249, 1
  %idxprom273 = sext i32 %add272 to i64
  %arrayidx274 = getelementptr inbounds ptr, ptr %248, i64 %idxprom273
  %250 = load ptr, ptr %arrayidx274, align 8
  store ptr %250, ptr %target_id, align 8
  br label %for.end278

if.end275:                                        ; preds = %for.body263
  br label %for.inc276

for.inc276:                                       ; preds = %if.end275
  %251 = load i32, ptr %i259, align 4
  %add277 = add nsw i32 %251, 2
  store i32 %add277, ptr %i259, align 4
  br label %for.cond260, !llvm.loop !175

for.end278:                                       ; preds = %if.then270, %for.cond260
  %252 = load ptr, ptr %importing, align 8
  call void @listRewind(ptr noundef %252, ptr noundef %li279)
  br label %while.cond281

while.cond281:                                    ; preds = %if.end294, %for.end278
  %call282 = call ptr @listNext(ptr noundef %li279)
  store ptr %call282, ptr %ln280, align 8
  %cmp283 = icmp ne ptr %call282, null
  br i1 %cmp283, label %while.body284, label %while.end295

while.body284:                                    ; preds = %while.cond281
  %253 = load ptr, ptr %ln280, align 8
  %value286 = getelementptr inbounds %struct.listNode, ptr %253, i32 0, i32 2
  %254 = load ptr, ptr %value286, align 8
  store ptr %254, ptr %n285, align 8
  %255 = load ptr, ptr %n285, align 8
  %256 = load i32, ptr %slot.addr, align 4
  %call287 = call i32 @clusterManagerCountKeysInSlot(ptr noundef %255, i32 noundef %256)
  store i32 %call287, ptr %count, align 4
  %257 = load i32, ptr %count, align 4
  %cmp288 = icmp sgt i32 %257, 0
  br i1 %cmp288, label %if.then289, label %if.end290

if.then289:                                       ; preds = %while.body284
  store i32 0, ptr %try_to_fix, align 4
  br label %while.end295

if.end290:                                        ; preds = %while.body284
  %258 = load ptr, ptr %n285, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %258, i32 0, i32 1
  %259 = load ptr, ptr %name, align 8
  %260 = load ptr, ptr %target_id, align 8
  %call291 = call i32 @strcmp(ptr noundef %259, ptr noundef %260) #12
  %cmp292 = icmp eq i32 %call291, 0
  br i1 %cmp292, label %if.then293, label %if.end294

if.then293:                                       ; preds = %if.end290
  %261 = load ptr, ptr %n285, align 8
  store ptr %261, ptr %dst258, align 8
  br label %if.end294

if.end294:                                        ; preds = %if.then293, %if.end290
  br label %while.cond281, !llvm.loop !176

while.end295:                                     ; preds = %if.then289, %while.cond281
  %262 = load i32, ptr %try_to_fix, align 4
  %tobool296 = icmp ne i32 %262, 0
  br i1 %tobool296, label %if.end298, label %if.then297

if.then297:                                       ; preds = %while.end295
  br label %unhandled_case

if.end298:                                        ; preds = %while.end295
  %263 = load ptr, ptr %dst258, align 8
  %cmp299 = icmp ne ptr %263, null
  br i1 %cmp299, label %if.then300, label %if.else323

if.then300:                                       ; preds = %if.end298
  %264 = load i32, ptr %slot.addr, align 4
  %265 = load ptr, ptr %src255, align 8
  %ip301 = getelementptr inbounds %struct.clusterManagerNode, ptr %265, i32 0, i32 2
  %266 = load ptr, ptr %ip301, align 8
  %267 = load ptr, ptr %src255, align 8
  %port302 = getelementptr inbounds %struct.clusterManagerNode, ptr %267, i32 0, i32 3
  %268 = load i32, ptr %port302, align 8
  %269 = load ptr, ptr %dst258, align 8
  %ip303 = getelementptr inbounds %struct.clusterManagerNode, ptr %269, i32 0, i32 2
  %270 = load ptr, ptr %ip303, align 8
  %271 = load ptr, ptr %dst258, align 8
  %port304 = getelementptr inbounds %struct.clusterManagerNode, ptr %271, i32 0, i32 3
  %272 = load i32, ptr %port304, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.276, i32 noundef %264, ptr noundef %266, i32 noundef %268, ptr noundef %270, i32 noundef %272)
  %273 = load ptr, ptr %src255, align 8
  %274 = load ptr, ptr %dst258, align 8
  %275 = load i32, ptr %slot.addr, align 4
  %276 = load i32, ptr %move_opts, align 4
  %call305 = call i32 @clusterManagerMoveSlot(ptr noundef %273, ptr noundef %274, i32 noundef %275, i32 noundef %276, ptr noundef null)
  store i32 %call305, ptr %success, align 4
  %277 = load i32, ptr %success, align 4
  %tobool306 = icmp ne i32 %277, 0
  br i1 %tobool306, label %if.end308, label %if.then307

if.then307:                                       ; preds = %if.then300
  br label %cleanup

if.end308:                                        ; preds = %if.then300
  %278 = load ptr, ptr %importing, align 8
  call void @listRewind(ptr noundef %278, ptr noundef %li279)
  br label %while.cond309

while.cond309:                                    ; preds = %if.end321, %if.then316, %if.end308
  %call310 = call ptr @listNext(ptr noundef %li279)
  store ptr %call310, ptr %ln280, align 8
  %cmp311 = icmp ne ptr %call310, null
  br i1 %cmp311, label %while.body312, label %while.end322

while.body312:                                    ; preds = %while.cond309
  %279 = load ptr, ptr %ln280, align 8
  %value314 = getelementptr inbounds %struct.listNode, ptr %279, i32 0, i32 2
  %280 = load ptr, ptr %value314, align 8
  store ptr %280, ptr %n313, align 8
  %281 = load ptr, ptr %dst258, align 8
  %282 = load ptr, ptr %n313, align 8
  %cmp315 = icmp eq ptr %281, %282
  br i1 %cmp315, label %if.then316, label %if.end317

if.then316:                                       ; preds = %while.body312
  br label %while.cond309, !llvm.loop !177

if.end317:                                        ; preds = %while.body312
  %283 = load ptr, ptr %n313, align 8
  %284 = load i32, ptr %slot.addr, align 4
  %call318 = call i32 @clusterManagerClearSlotStatus(ptr noundef %283, i32 noundef %284)
  store i32 %call318, ptr %success, align 4
  %285 = load i32, ptr %success, align 4
  %tobool319 = icmp ne i32 %285, 0
  br i1 %tobool319, label %if.end321, label %if.then320

if.then320:                                       ; preds = %if.end317
  br label %cleanup

if.end321:                                        ; preds = %if.end317
  br label %while.cond309, !llvm.loop !177

while.end322:                                     ; preds = %while.cond309
  br label %if.end339

if.else323:                                       ; preds = %if.end298
  %286 = load i32, ptr %slot.addr, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.277, i32 noundef %286)
  %287 = load ptr, ptr %src255, align 8
  %288 = load i32, ptr %slot.addr, align 4
  %call324 = call i32 @clusterManagerClearSlotStatus(ptr noundef %287, i32 noundef %288)
  store i32 %call324, ptr %success, align 4
  %289 = load i32, ptr %success, align 4
  %tobool325 = icmp ne i32 %289, 0
  br i1 %tobool325, label %if.end327, label %if.then326

if.then326:                                       ; preds = %if.else323
  br label %cleanup

if.end327:                                        ; preds = %if.else323
  %290 = load ptr, ptr %importing, align 8
  call void @listRewind(ptr noundef %290, ptr noundef %li279)
  br label %while.cond328

while.cond328:                                    ; preds = %if.end337, %if.end327
  %call329 = call ptr @listNext(ptr noundef %li279)
  store ptr %call329, ptr %ln280, align 8
  %cmp330 = icmp ne ptr %call329, null
  br i1 %cmp330, label %while.body331, label %while.end338

while.body331:                                    ; preds = %while.cond328
  %291 = load ptr, ptr %ln280, align 8
  %value333 = getelementptr inbounds %struct.listNode, ptr %291, i32 0, i32 2
  %292 = load ptr, ptr %value333, align 8
  store ptr %292, ptr %n332, align 8
  %293 = load ptr, ptr %n332, align 8
  %294 = load i32, ptr %slot.addr, align 4
  %call334 = call i32 @clusterManagerClearSlotStatus(ptr noundef %293, i32 noundef %294)
  store i32 %call334, ptr %success, align 4
  %295 = load i32, ptr %success, align 4
  %tobool335 = icmp ne i32 %295, 0
  br i1 %tobool335, label %if.end337, label %if.then336

if.then336:                                       ; preds = %while.body331
  br label %cleanup

if.end337:                                        ; preds = %while.body331
  br label %while.cond328, !llvm.loop !178

while.end338:                                     ; preds = %while.cond328
  br label %if.end339

if.end339:                                        ; preds = %while.end338, %while.end322
  br label %if.end390

if.else340:                                       ; preds = %land.lhs.true251, %if.else248
  %296 = load ptr, ptr %importing, align 8
  %len341 = getelementptr inbounds %struct.list, ptr %296, i32 0, i32 5
  %297 = load i64, ptr %len341, align 8
  %cmp342 = icmp eq i64 %297, 0
  br i1 %cmp342, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.else340
  %298 = load ptr, ptr %migrating, align 8
  %len343 = getelementptr inbounds %struct.list, ptr %298, i32 0, i32 5
  %299 = load i64, ptr %len343, align 8
  %cmp344 = icmp eq i64 %299, 1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.else340
  %300 = phi i1 [ false, %if.else340 ], [ %cmp344, %land.rhs ]
  %land.ext = zext i1 %300 to i32
  store i32 %land.ext, ptr %try_to_close_slot, align 4
  %301 = load i32, ptr %try_to_close_slot, align 4
  %tobool345 = icmp ne i32 %301, 0
  br i1 %tobool345, label %if.then346, label %if.end368

if.then346:                                       ; preds = %land.end
  %302 = load ptr, ptr %migrating, align 8
  %head348 = getelementptr inbounds %struct.list, ptr %302, i32 0, i32 0
  %303 = load ptr, ptr %head348, align 8
  %value349 = getelementptr inbounds %struct.listNode, ptr %303, i32 0, i32 2
  %304 = load ptr, ptr %value349, align 8
  store ptr %304, ptr %n347, align 8
  %305 = load ptr, ptr %owner, align 8
  %tobool350 = icmp ne ptr %305, null
  br i1 %tobool350, label %lor.lhs.false, label %if.then352

lor.lhs.false:                                    ; preds = %if.then346
  %306 = load ptr, ptr %owner, align 8
  %307 = load ptr, ptr %n347, align 8
  %cmp351 = icmp ne ptr %306, %307
  br i1 %cmp351, label %if.then352, label %if.end367

if.then352:                                       ; preds = %lor.lhs.false, %if.then346
  %308 = load ptr, ptr %n347, align 8
  %context354 = getelementptr inbounds %struct.clusterManagerNode, ptr %308, i32 0, i32 0
  %309 = load ptr, ptr %context354, align 8
  %310 = load i32, ptr %slot.addr, align 4
  %call355 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %309, ptr noundef @.str.278, i32 noundef %310, i32 noundef 10)
  store ptr %call355, ptr %r353, align 8
  %311 = load ptr, ptr %n347, align 8
  %312 = load ptr, ptr %r353, align 8
  %call356 = call i32 @clusterManagerCheckRedisReply(ptr noundef %311, ptr noundef %312, ptr noundef null)
  store i32 %call356, ptr %success, align 4
  %313 = load ptr, ptr %r353, align 8
  %tobool357 = icmp ne ptr %313, null
  br i1 %tobool357, label %if.then358, label %if.end363

if.then358:                                       ; preds = %if.then352
  %314 = load i32, ptr %success, align 4
  %tobool359 = icmp ne i32 %314, 0
  br i1 %tobool359, label %if.then360, label %if.end362

if.then360:                                       ; preds = %if.then358
  %315 = load ptr, ptr %r353, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %315, i32 0, i32 6
  %316 = load i64, ptr %elements, align 8
  %cmp361 = icmp eq i64 %316, 0
  %conv = zext i1 %cmp361 to i32
  store i32 %conv, ptr %try_to_close_slot, align 4
  br label %if.end362

if.end362:                                        ; preds = %if.then360, %if.then358
  %317 = load ptr, ptr %r353, align 8
  call void @freeReplyObject(ptr noundef %317)
  br label %if.end363

if.end363:                                        ; preds = %if.end362, %if.then352
  %318 = load i32, ptr %success, align 4
  %tobool364 = icmp ne i32 %318, 0
  br i1 %tobool364, label %if.end366, label %if.then365

if.then365:                                       ; preds = %if.end363
  br label %cleanup

if.end366:                                        ; preds = %if.end363
  br label %if.end367

if.end367:                                        ; preds = %if.end366, %lor.lhs.false
  br label %if.end368

if.end368:                                        ; preds = %if.end367, %land.end
  %319 = load i32, ptr %try_to_close_slot, align 4
  %tobool369 = icmp ne i32 %319, 0
  br i1 %tobool369, label %if.then370, label %if.else386

if.then370:                                       ; preds = %if.end368
  %320 = load ptr, ptr %migrating, align 8
  %head372 = getelementptr inbounds %struct.list, ptr %320, i32 0, i32 0
  %321 = load ptr, ptr %head372, align 8
  %value373 = getelementptr inbounds %struct.listNode, ptr %321, i32 0, i32 2
  %322 = load ptr, ptr %value373, align 8
  store ptr %322, ptr %n371, align 8
  %323 = load i32, ptr %slot.addr, align 4
  %324 = load ptr, ptr %n371, align 8
  %ip374 = getelementptr inbounds %struct.clusterManagerNode, ptr %324, i32 0, i32 2
  %325 = load ptr, ptr %ip374, align 8
  %326 = load ptr, ptr %n371, align 8
  %port375 = getelementptr inbounds %struct.clusterManagerNode, ptr %326, i32 0, i32 3
  %327 = load i32, ptr %port375, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.279, i32 noundef %323, ptr noundef %325, i32 noundef %327)
  %328 = load ptr, ptr %n371, align 8
  %context377 = getelementptr inbounds %struct.clusterManagerNode, ptr %328, i32 0, i32 0
  %329 = load ptr, ptr %context377, align 8
  %330 = load i32, ptr %slot.addr, align 4
  %call378 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %329, ptr noundef @.str.280, i32 noundef %330, ptr noundef @.str.281)
  store ptr %call378, ptr %r376, align 8
  %331 = load ptr, ptr %n371, align 8
  %332 = load ptr, ptr %r376, align 8
  %call379 = call i32 @clusterManagerCheckRedisReply(ptr noundef %331, ptr noundef %332, ptr noundef null)
  store i32 %call379, ptr %success, align 4
  %333 = load ptr, ptr %r376, align 8
  %tobool380 = icmp ne ptr %333, null
  br i1 %tobool380, label %if.then381, label %if.end382

if.then381:                                       ; preds = %if.then370
  %334 = load ptr, ptr %r376, align 8
  call void @freeReplyObject(ptr noundef %334)
  br label %if.end382

if.end382:                                        ; preds = %if.then381, %if.then370
  %335 = load i32, ptr %success, align 4
  %tobool383 = icmp ne i32 %335, 0
  br i1 %tobool383, label %if.end385, label %if.then384

if.then384:                                       ; preds = %if.end382
  br label %cleanup

if.end385:                                        ; preds = %if.end382
  br label %if.end389

if.else386:                                       ; preds = %if.end368
  br label %unhandled_case

unhandled_case:                                   ; preds = %if.else386, %if.then297
  store i32 0, ptr %success, align 4
  %336 = load ptr, ptr %migrating_str, align 8
  %337 = load ptr, ptr %importing_str, align 8
  %338 = load ptr, ptr %owner, align 8
  %ip387 = getelementptr inbounds %struct.clusterManagerNode, ptr %338, i32 0, i32 2
  %339 = load ptr, ptr %ip387, align 8
  %340 = load ptr, ptr %owner, align 8
  %port388 = getelementptr inbounds %struct.clusterManagerNode, ptr %340, i32 0, i32 3
  %341 = load i32, ptr %port388, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.282, ptr noundef %336, ptr noundef %337, ptr noundef %339, i32 noundef %341)
  br label %if.end389

if.end389:                                        ; preds = %unhandled_case, %if.end385
  br label %if.end390

if.end390:                                        ; preds = %if.end389, %if.end339
  br label %if.end391

if.end391:                                        ; preds = %if.end390, %while.end247
  br label %if.end392

if.end392:                                        ; preds = %if.end391, %if.then189
  br label %cleanup

cleanup:                                          ; preds = %if.end392, %if.then384, %if.then365, %if.then336, %if.then326, %if.then320, %if.then307, %if.then245, %if.then226, %if.then220, %if.then179, %if.then175, %if.then168, %if.then148, %if.then144, %if.then138, %if.then120, %if.then26
  %342 = load ptr, ptr %owners, align 8
  call void @listRelease(ptr noundef %342)
  %343 = load ptr, ptr %migrating, align 8
  call void @listRelease(ptr noundef %343)
  %344 = load ptr, ptr %importing, align 8
  call void @listRelease(ptr noundef %344)
  %345 = load ptr, ptr %migrating_str, align 8
  call void @hi_sdsfree(ptr noundef %345)
  %346 = load ptr, ptr %importing_str, align 8
  call void @hi_sdsfree(ptr noundef %346)
  %347 = load i32, ptr %success, align 4
  ret i32 %347
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerGetCoveredSlots(ptr noundef %all_slots) #0 {
entry:
  %retval = alloca i32, align 4
  %all_slots.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %totslots = alloca i32, align 4
  %i = alloca i32, align 4
  %node = alloca ptr, align 8
  store ptr %all_slots, ptr %all_slots.addr, align 8
  %0 = load ptr, ptr @cluster_manager, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  store i32 0, ptr %totslots, align 4
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp1 = icmp ne ptr %call, null
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %node, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %4 = load i32, ptr %i, align 4
  %cmp2 = icmp slt i32 %4, 16384
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %node, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %5, i32 0, i32 12
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom
  %7 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %7 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %for.body
  %8 = load ptr, ptr %all_slots.addr, align 8
  %9 = load i32, ptr %i, align 4
  %idxprom3 = sext i32 %9 to i64
  %arrayidx4 = getelementptr inbounds i8, ptr %8, i64 %idxprom3
  %10 = load i8, ptr %arrayidx4, align 1
  %tobool5 = icmp ne i8 %10, 0
  br i1 %tobool5, label %if.end9, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %11 = load ptr, ptr %all_slots.addr, align 8
  %12 = load i32, ptr %i, align 4
  %idxprom7 = sext i32 %12 to i64
  %arrayidx8 = getelementptr inbounds i8, ptr %11, i64 %idxprom7
  store i8 1, ptr %arrayidx8, align 1
  %13 = load i32, ptr %totslots, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %totslots, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then6, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %14 = load i32, ptr %i, align 4
  %inc10 = add nsw i32 %14, 1
  store i32 %inc10, ptr %i, align 4
  br label %for.cond, !llvm.loop !179

for.end:                                          ; preds = %for.cond
  br label %while.cond, !llvm.loop !180

while.end:                                        ; preds = %while.cond
  %15 = load i32, ptr %totslots, align 4
  store i32 %15, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerFixSlotsCoverage(ptr noundef %all_slots) #0 {
entry:
  %all_slots.addr = alloca ptr, align 8
  %force_fix = alloca i32, align 4
  %i = alloca i32, align 4
  %fixed = alloca i32, align 4
  %none = alloca ptr, align 8
  %single = alloca ptr, align 8
  %multi = alloca ptr, align 8
  %covered = alloca i32, align 4
  %slot = alloca ptr, align 8
  %slot_nodes = alloca ptr, align 8
  %slot_nodes_str = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %iter = alloca ptr, align 8
  %entry40 = alloca ptr, align 8
  %slot46 = alloca ptr, align 8
  %nodes = alloca ptr, align 8
  %ignore_force = alloca i32, align 4
  %li63 = alloca %struct.listIter, align 8
  %ln64 = alloca ptr, align 8
  %slot70 = alloca ptr, align 8
  %s = alloca i32, align 4
  %n73 = alloca ptr, align 8
  %li95 = alloca %struct.listIter, align 8
  %ln96 = alloca ptr, align 8
  %slot102 = alloca ptr, align 8
  %s104 = alloca i32, align 4
  %entry106 = alloca ptr, align 8
  %nodes108 = alloca ptr, align 8
  %fn = alloca ptr, align 8
  %n110 = alloca ptr, align 8
  %li134 = alloca %struct.listIter, align 8
  %ln135 = alloca ptr, align 8
  %slot141 = alloca ptr, align 8
  %entry143 = alloca ptr, align 8
  %nodes145 = alloca ptr, align 8
  %s147 = alloca i32, align 4
  %target = alloca ptr, align 8
  %nli = alloca %struct.listIter, align 8
  %nln = alloca ptr, align 8
  %src = alloca ptr, align 8
  %opts = alloca i32, align 4
  store ptr %all_slots, ptr %all_slots.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %0, 1024
  store i32 %and, ptr %force_fix, align 4
  %1 = load i32, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 2), align 8
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, ptr %force_fix, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %3 = load i32, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 2), align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.313, i32 noundef %3)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, ptr %fixed, align 4
  store ptr null, ptr %none, align 8
  store ptr null, ptr %single, align 8
  store ptr null, ptr %multi, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.314)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, ptr %i, align 4
  %cmp1 = icmp slt i32 %4, 16384
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %all_slots.addr, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, ptr %5, i64 %idxprom
  %7 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %7 to i32
  store i32 %conv, ptr %covered, align 4
  %8 = load i32, ptr %covered, align 4
  %tobool2 = icmp ne i32 %8, 0
  br i1 %tobool2, label %if.end35, label %if.then3

if.then3:                                         ; preds = %for.body
  %9 = load i32, ptr %i, align 4
  %conv4 = sext i32 %9 to i64
  %call = call ptr @hi_sdsfromlonglong(i64 noundef %conv4)
  store ptr %call, ptr %slot, align 8
  %call5 = call ptr @listCreate()
  store ptr %call5, ptr %slot_nodes, align 8
  %call6 = call ptr @hi_sdsempty()
  store ptr %call6, ptr %slot_nodes_str, align 8
  %10 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %10, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end33, %if.then13, %if.then3
  %call7 = call ptr @listNext(ptr noundef %li)
  store ptr %call7, ptr %ln, align 8
  %cmp8 = icmp ne ptr %call7, null
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %value, align 8
  store ptr %12, ptr %n, align 8
  %13 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %13, i32 0, i32 8
  %14 = load i32, ptr %flags, align 8
  %and10 = and i32 %14, 2
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %15 = load ptr, ptr %n, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %15, i32 0, i32 10
  %16 = load ptr, ptr %replicate, align 8
  %tobool12 = icmp ne ptr %16, null
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %lor.lhs.false, %while.body
  br label %while.cond, !llvm.loop !181

if.end14:                                         ; preds = %lor.lhs.false
  %17 = load ptr, ptr %n, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %context, align 8
  %19 = load i32, ptr %i, align 4
  %call15 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %18, ptr noundef @.str.278, i32 noundef %19, i32 noundef 1)
  store ptr %call15, ptr %reply, align 8
  %20 = load ptr, ptr %n, align 8
  %21 = load ptr, ptr %reply, align 8
  %call16 = call i32 @clusterManagerCheckRedisReply(ptr noundef %20, ptr noundef %21, ptr noundef null)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.end22, label %if.then18

if.then18:                                        ; preds = %if.end14
  store i32 -1, ptr %fixed, align 4
  %22 = load ptr, ptr %reply, align 8
  %tobool19 = icmp ne ptr %22, null
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.then18
  %23 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %23)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.then18
  br label %cleanup

if.end22:                                         ; preds = %if.end14
  %24 = load ptr, ptr %reply, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %24, i32 0, i32 6
  %25 = load i64, ptr %elements, align 8
  %cmp23 = icmp ugt i64 %25, 0
  br i1 %cmp23, label %if.then25, label %if.end33

if.then25:                                        ; preds = %if.end22
  %26 = load ptr, ptr %slot_nodes, align 8
  %27 = load ptr, ptr %n, align 8
  %call26 = call ptr @listAddNodeTail(ptr noundef %26, ptr noundef %27)
  %28 = load ptr, ptr %slot_nodes, align 8
  %len = getelementptr inbounds %struct.list, ptr %28, i32 0, i32 5
  %29 = load i64, ptr %len, align 8
  %cmp27 = icmp ugt i64 %29, 1
  br i1 %cmp27, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.then25
  %30 = load ptr, ptr %slot_nodes_str, align 8
  %call30 = call ptr @hi_sdscat(ptr noundef %30, ptr noundef @.str.315)
  store ptr %call30, ptr %slot_nodes_str, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.then25
  %31 = load ptr, ptr %slot_nodes_str, align 8
  %32 = load ptr, ptr %n, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %ip, align 8
  %34 = load ptr, ptr %n, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 3
  %35 = load i32, ptr %port, align 8
  %call32 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %31, ptr noundef @.str.238, ptr noundef %33, i32 noundef %35)
  store ptr %call32, ptr %slot_nodes_str, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.end31, %if.end22
  %36 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %36)
  br label %while.cond, !llvm.loop !181

while.end:                                        ; preds = %while.cond
  %37 = load ptr, ptr %slot_nodes_str, align 8
  call void @hi_sdsfree(ptr noundef %37)
  %38 = load ptr, ptr @clusterManagerUncoveredSlots, align 8
  %39 = load ptr, ptr %slot, align 8
  %40 = load ptr, ptr %slot_nodes, align 8
  %call34 = call i32 @dictAdd(ptr noundef %38, ptr noundef %39, ptr noundef %40)
  br label %if.end35

if.end35:                                         ; preds = %while.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end35
  %41 = load i32, ptr %i, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !182

for.end:                                          ; preds = %for.cond
  %call36 = call ptr @listCreate()
  store ptr %call36, ptr %none, align 8
  %call37 = call ptr @listCreate()
  store ptr %call37, ptr %single, align 8
  %call38 = call ptr @listCreate()
  store ptr %call38, ptr %multi, align 8
  %42 = load ptr, ptr @clusterManagerUncoveredSlots, align 8
  %call39 = call ptr @dictGetIterator(ptr noundef %42)
  store ptr %call39, ptr %iter, align 8
  br label %while.cond41

while.cond41:                                     ; preds = %sw.epilog, %for.end
  %43 = load ptr, ptr %iter, align 8
  %call42 = call ptr @dictNext(ptr noundef %43)
  store ptr %call42, ptr %entry40, align 8
  %cmp43 = icmp ne ptr %call42, null
  br i1 %cmp43, label %while.body45, label %while.end54

while.body45:                                     ; preds = %while.cond41
  %44 = load ptr, ptr %entry40, align 8
  %call47 = call ptr @dictGetKey(ptr noundef %44)
  store ptr %call47, ptr %slot46, align 8
  %45 = load ptr, ptr %entry40, align 8
  %call48 = call ptr @dictGetVal(ptr noundef %45)
  store ptr %call48, ptr %nodes, align 8
  %46 = load ptr, ptr %nodes, align 8
  %len49 = getelementptr inbounds %struct.list, ptr %46, i32 0, i32 5
  %47 = load i64, ptr %len49, align 8
  switch i64 %47, label %sw.default [
    i64 0, label %sw.bb
    i64 1, label %sw.bb51
  ]

sw.bb:                                            ; preds = %while.body45
  %48 = load ptr, ptr %none, align 8
  %49 = load ptr, ptr %slot46, align 8
  %call50 = call ptr @listAddNodeTail(ptr noundef %48, ptr noundef %49)
  br label %sw.epilog

sw.bb51:                                          ; preds = %while.body45
  %50 = load ptr, ptr %single, align 8
  %51 = load ptr, ptr %slot46, align 8
  %call52 = call ptr @listAddNodeTail(ptr noundef %50, ptr noundef %51)
  br label %sw.epilog

sw.default:                                       ; preds = %while.body45
  %52 = load ptr, ptr %multi, align 8
  %53 = load ptr, ptr %slot46, align 8
  %call53 = call ptr @listAddNodeTail(ptr noundef %52, ptr noundef %53)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb51, %sw.bb
  br label %while.cond41, !llvm.loop !183

while.end54:                                      ; preds = %while.cond41
  %54 = load ptr, ptr %iter, align 8
  call void @dictReleaseIterator(ptr noundef %54)
  store i32 1, ptr %ignore_force, align 4
  %55 = load ptr, ptr %none, align 8
  %len55 = getelementptr inbounds %struct.list, ptr %55, i32 0, i32 5
  %56 = load i64, ptr %len55, align 8
  %cmp56 = icmp ugt i64 %56, 0
  br i1 %cmp56, label %if.then58, label %if.end86

if.then58:                                        ; preds = %while.end54
  %call59 = call i32 (ptr, ...) @printf(ptr noundef @.str.316)
  %57 = load ptr, ptr %none, align 8
  call void @clusterManagerPrintSlotsList(ptr noundef %57)
  %58 = load i32, ptr %ignore_force, align 4
  %call60 = call i32 @confirmWithYes(ptr noundef @.str.317, i32 noundef %58)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %if.then62, label %if.end85

if.then62:                                        ; preds = %if.then58
  %59 = load ptr, ptr %none, align 8
  call void @listRewind(ptr noundef %59, ptr noundef %li63)
  br label %while.cond65

while.cond65:                                     ; preds = %if.end80, %if.then62
  %call66 = call ptr @listNext(ptr noundef %li63)
  store ptr %call66, ptr %ln64, align 8
  %cmp67 = icmp ne ptr %call66, null
  br i1 %cmp67, label %while.body69, label %while.end84

while.body69:                                     ; preds = %while.cond65
  %60 = load ptr, ptr %ln64, align 8
  %value71 = getelementptr inbounds %struct.listNode, ptr %60, i32 0, i32 2
  %61 = load ptr, ptr %value71, align 8
  store ptr %61, ptr %slot70, align 8
  %62 = load ptr, ptr %slot70, align 8
  %call72 = call i32 @atoi(ptr noundef %62) #12
  store i32 %call72, ptr %s, align 4
  %call74 = call ptr @clusterManagerNodeMasterRandom()
  store ptr %call74, ptr %n73, align 8
  %63 = load ptr, ptr %slot70, align 8
  %64 = load ptr, ptr %n73, align 8
  %ip75 = getelementptr inbounds %struct.clusterManagerNode, ptr %64, i32 0, i32 2
  %65 = load ptr, ptr %ip75, align 8
  %66 = load ptr, ptr %n73, align 8
  %port76 = getelementptr inbounds %struct.clusterManagerNode, ptr %66, i32 0, i32 3
  %67 = load i32, ptr %port76, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.318, ptr noundef %63, ptr noundef %65, i32 noundef %67)
  %68 = load ptr, ptr %n73, align 8
  %69 = load i32, ptr %s, align 4
  %call77 = call i32 @clusterManagerSetSlotOwner(ptr noundef %68, i32 noundef %69, i32 noundef 0)
  %tobool78 = icmp ne i32 %call77, 0
  br i1 %tobool78, label %if.end80, label %if.then79

if.then79:                                        ; preds = %while.body69
  store i32 -1, ptr %fixed, align 4
  br label %cleanup

if.end80:                                         ; preds = %while.body69
  %70 = load ptr, ptr %n73, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %70, i32 0, i32 12
  %71 = load i32, ptr %s, align 4
  %idxprom81 = sext i32 %71 to i64
  %arrayidx82 = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom81
  store i8 1, ptr %arrayidx82, align 1
  %72 = load i32, ptr %fixed, align 4
  %inc83 = add nsw i32 %72, 1
  store i32 %inc83, ptr %fixed, align 4
  br label %while.cond65, !llvm.loop !184

while.end84:                                      ; preds = %while.cond65
  br label %if.end85

if.end85:                                         ; preds = %while.end84, %if.then58
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %while.end54
  %73 = load ptr, ptr %single, align 8
  %len87 = getelementptr inbounds %struct.list, ptr %73, i32 0, i32 5
  %74 = load i64, ptr %len87, align 8
  %cmp88 = icmp ugt i64 %74, 0
  br i1 %cmp88, label %if.then90, label %if.end125

if.then90:                                        ; preds = %if.end86
  %call91 = call i32 (ptr, ...) @printf(ptr noundef @.str.319)
  %75 = load ptr, ptr %single, align 8
  call void @clusterManagerPrintSlotsList(ptr noundef %75)
  %76 = load i32, ptr %ignore_force, align 4
  %call92 = call i32 @confirmWithYes(ptr noundef @.str.320, i32 noundef %76)
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %if.then94, label %if.end124

if.then94:                                        ; preds = %if.then90
  %77 = load ptr, ptr %single, align 8
  call void @listRewind(ptr noundef %77, ptr noundef %li95)
  br label %while.cond97

while.cond97:                                     ; preds = %if.end117, %if.then94
  %call98 = call ptr @listNext(ptr noundef %li95)
  store ptr %call98, ptr %ln96, align 8
  %cmp99 = icmp ne ptr %call98, null
  br i1 %cmp99, label %while.body101, label %while.end123

while.body101:                                    ; preds = %while.cond97
  %78 = load ptr, ptr %ln96, align 8
  %value103 = getelementptr inbounds %struct.listNode, ptr %78, i32 0, i32 2
  %79 = load ptr, ptr %value103, align 8
  store ptr %79, ptr %slot102, align 8
  %80 = load ptr, ptr %slot102, align 8
  %call105 = call i32 @atoi(ptr noundef %80) #12
  store i32 %call105, ptr %s104, align 4
  %81 = load ptr, ptr @clusterManagerUncoveredSlots, align 8
  %82 = load ptr, ptr %slot102, align 8
  %call107 = call ptr @dictFind(ptr noundef %81, ptr noundef %82)
  store ptr %call107, ptr %entry106, align 8
  %83 = load ptr, ptr %entry106, align 8
  %call109 = call ptr @dictGetVal(ptr noundef %83)
  store ptr %call109, ptr %nodes108, align 8
  %84 = load ptr, ptr %nodes108, align 8
  %head = getelementptr inbounds %struct.list, ptr %84, i32 0, i32 0
  %85 = load ptr, ptr %head, align 8
  store ptr %85, ptr %fn, align 8
  %86 = load ptr, ptr %fn, align 8
  %value111 = getelementptr inbounds %struct.listNode, ptr %86, i32 0, i32 2
  %87 = load ptr, ptr %value111, align 8
  store ptr %87, ptr %n110, align 8
  %88 = load ptr, ptr %slot102, align 8
  %89 = load ptr, ptr %n110, align 8
  %ip112 = getelementptr inbounds %struct.clusterManagerNode, ptr %89, i32 0, i32 2
  %90 = load ptr, ptr %ip112, align 8
  %91 = load ptr, ptr %n110, align 8
  %port113 = getelementptr inbounds %struct.clusterManagerNode, ptr %91, i32 0, i32 3
  %92 = load i32, ptr %port113, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.318, ptr noundef %88, ptr noundef %90, i32 noundef %92)
  %93 = load ptr, ptr %n110, align 8
  %94 = load i32, ptr %s104, align 4
  %call114 = call i32 @clusterManagerSetSlotOwner(ptr noundef %93, i32 noundef %94, i32 noundef 0)
  %tobool115 = icmp ne i32 %call114, 0
  br i1 %tobool115, label %if.end117, label %if.then116

if.then116:                                       ; preds = %while.body101
  store i32 -1, ptr %fixed, align 4
  br label %cleanup

if.end117:                                        ; preds = %while.body101
  %95 = load ptr, ptr %n110, align 8
  %slots118 = getelementptr inbounds %struct.clusterManagerNode, ptr %95, i32 0, i32 12
  %96 = load ptr, ptr %slot102, align 8
  %call119 = call i32 @atoi(ptr noundef %96) #12
  %idxprom120 = sext i32 %call119 to i64
  %arrayidx121 = getelementptr inbounds [16384 x i8], ptr %slots118, i64 0, i64 %idxprom120
  store i8 1, ptr %arrayidx121, align 1
  %97 = load i32, ptr %fixed, align 4
  %inc122 = add nsw i32 %97, 1
  store i32 %inc122, ptr %fixed, align 4
  br label %while.cond97, !llvm.loop !185

while.end123:                                     ; preds = %while.cond97
  br label %if.end124

if.end124:                                        ; preds = %while.end123, %if.then90
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %if.end86
  %98 = load ptr, ptr %multi, align 8
  %len126 = getelementptr inbounds %struct.list, ptr %98, i32 0, i32 5
  %99 = load i64, ptr %len126, align 8
  %cmp127 = icmp ugt i64 %99, 0
  br i1 %cmp127, label %if.then129, label %if.end206

if.then129:                                       ; preds = %if.end125
  %call130 = call i32 (ptr, ...) @printf(ptr noundef @.str.321)
  %100 = load ptr, ptr %multi, align 8
  call void @clusterManagerPrintSlotsList(ptr noundef %100)
  %101 = load i32, ptr %ignore_force, align 4
  %call131 = call i32 @confirmWithYes(ptr noundef @.str.322, i32 noundef %101)
  %tobool132 = icmp ne i32 %call131, 0
  br i1 %tobool132, label %if.then133, label %if.end205

if.then133:                                       ; preds = %if.then129
  %102 = load ptr, ptr %multi, align 8
  call void @listRewind(ptr noundef %102, ptr noundef %li134)
  br label %while.cond136

while.cond136:                                    ; preds = %while.end202, %if.then133
  %call137 = call ptr @listNext(ptr noundef %li134)
  store ptr %call137, ptr %ln135, align 8
  %cmp138 = icmp ne ptr %call137, null
  br i1 %cmp138, label %while.body140, label %while.end204

while.body140:                                    ; preds = %while.cond136
  %103 = load ptr, ptr %ln135, align 8
  %value142 = getelementptr inbounds %struct.listNode, ptr %103, i32 0, i32 2
  %104 = load ptr, ptr %value142, align 8
  store ptr %104, ptr %slot141, align 8
  %105 = load ptr, ptr @clusterManagerUncoveredSlots, align 8
  %106 = load ptr, ptr %slot141, align 8
  %call144 = call ptr @dictFind(ptr noundef %105, ptr noundef %106)
  store ptr %call144, ptr %entry143, align 8
  %107 = load ptr, ptr %entry143, align 8
  %call146 = call ptr @dictGetVal(ptr noundef %107)
  store ptr %call146, ptr %nodes145, align 8
  %108 = load ptr, ptr %slot141, align 8
  %call148 = call i32 @atoi(ptr noundef %108) #12
  store i32 %call148, ptr %s147, align 4
  %109 = load ptr, ptr %nodes145, align 8
  %110 = load i32, ptr %s147, align 4
  %call149 = call ptr @clusterManagerGetNodeWithMostKeysInSlot(ptr noundef %109, i32 noundef %110, ptr noundef null)
  store ptr %call149, ptr %target, align 8
  %111 = load ptr, ptr %target, align 8
  %cmp150 = icmp eq ptr %111, null
  br i1 %cmp150, label %if.then152, label %if.end153

if.then152:                                       ; preds = %while.body140
  store i32 -1, ptr %fixed, align 4
  br label %cleanup

if.end153:                                        ; preds = %while.body140
  %112 = load ptr, ptr %slot141, align 8
  %113 = load ptr, ptr %target, align 8
  %ip154 = getelementptr inbounds %struct.clusterManagerNode, ptr %113, i32 0, i32 2
  %114 = load ptr, ptr %ip154, align 8
  %115 = load ptr, ptr %target, align 8
  %port155 = getelementptr inbounds %struct.clusterManagerNode, ptr %115, i32 0, i32 3
  %116 = load i32, ptr %port155, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.323, ptr noundef %112, ptr noundef %114, i32 noundef %116)
  %117 = load ptr, ptr %target, align 8
  %118 = load i32, ptr %s147, align 4
  %call156 = call i32 @clusterManagerSetSlotOwner(ptr noundef %117, i32 noundef %118, i32 noundef 1)
  %tobool157 = icmp ne i32 %call156, 0
  br i1 %tobool157, label %if.end159, label %if.then158

if.then158:                                       ; preds = %if.end153
  store i32 -1, ptr %fixed, align 4
  br label %cleanup

if.end159:                                        ; preds = %if.end153
  %119 = load ptr, ptr %target, align 8
  %slots160 = getelementptr inbounds %struct.clusterManagerNode, ptr %119, i32 0, i32 12
  %120 = load ptr, ptr %slot141, align 8
  %call161 = call i32 @atoi(ptr noundef %120) #12
  %idxprom162 = sext i32 %call161 to i64
  %arrayidx163 = getelementptr inbounds [16384 x i8], ptr %slots160, i64 0, i64 %idxprom162
  store i8 1, ptr %arrayidx163, align 1
  %121 = load ptr, ptr %nodes145, align 8
  call void @listRewind(ptr noundef %121, ptr noundef %nli)
  br label %while.cond164

while.cond164:                                    ; preds = %if.end201, %if.then172, %if.end159
  %call165 = call ptr @listNext(ptr noundef %nli)
  store ptr %call165, ptr %nln, align 8
  %cmp166 = icmp ne ptr %call165, null
  br i1 %cmp166, label %while.body168, label %while.end202

while.body168:                                    ; preds = %while.cond164
  %122 = load ptr, ptr %nln, align 8
  %value169 = getelementptr inbounds %struct.listNode, ptr %122, i32 0, i32 2
  %123 = load ptr, ptr %value169, align 8
  store ptr %123, ptr %src, align 8
  %124 = load ptr, ptr %src, align 8
  %125 = load ptr, ptr %target, align 8
  %cmp170 = icmp eq ptr %124, %125
  br i1 %cmp170, label %if.then172, label %if.end173

if.then172:                                       ; preds = %while.body168
  br label %while.cond164, !llvm.loop !186

if.end173:                                        ; preds = %while.body168
  %126 = load ptr, ptr %src, align 8
  %127 = load ptr, ptr %target, align 8
  %128 = load i32, ptr %s147, align 4
  %call174 = call i32 @clusterManagerSetSlot(ptr noundef %126, ptr noundef %127, i32 noundef %128, ptr noundef @.str.275, ptr noundef null)
  %tobool175 = icmp ne i32 %call174, 0
  br i1 %tobool175, label %if.end177, label %if.then176

if.then176:                                       ; preds = %if.end173
  store i32 -1, ptr %fixed, align 4
  br label %if.end177

if.end177:                                        ; preds = %if.then176, %if.end173
  %129 = load i32, ptr %fixed, align 4
  %cmp178 = icmp slt i32 %129, 0
  br i1 %cmp178, label %if.then180, label %if.end181

if.then180:                                       ; preds = %if.end177
  br label %cleanup

if.end181:                                        ; preds = %if.end177
  %130 = load ptr, ptr %src, align 8
  %131 = load ptr, ptr %target, align 8
  %132 = load i32, ptr %s147, align 4
  %call182 = call i32 @clusterManagerSetSlot(ptr noundef %130, ptr noundef %131, i32 noundef %132, ptr noundef @.str.324, ptr noundef null)
  %tobool183 = icmp ne i32 %call182, 0
  br i1 %tobool183, label %if.end185, label %if.then184

if.then184:                                       ; preds = %if.end181
  store i32 -1, ptr %fixed, align 4
  br label %if.end185

if.end185:                                        ; preds = %if.then184, %if.end181
  %133 = load i32, ptr %fixed, align 4
  %cmp186 = icmp slt i32 %133, 0
  br i1 %cmp186, label %if.then188, label %if.end189

if.then188:                                       ; preds = %if.end185
  br label %cleanup

if.end189:                                        ; preds = %if.end185
  store i32 130, ptr %opts, align 4
  %134 = load ptr, ptr %src, align 8
  %135 = load ptr, ptr %target, align 8
  %136 = load i32, ptr %s147, align 4
  %137 = load i32, ptr %opts, align 4
  %call190 = call i32 @clusterManagerMoveSlot(ptr noundef %134, ptr noundef %135, i32 noundef %136, i32 noundef %137, ptr noundef null)
  %tobool191 = icmp ne i32 %call190, 0
  br i1 %tobool191, label %if.end193, label %if.then192

if.then192:                                       ; preds = %if.end189
  store i32 -1, ptr %fixed, align 4
  br label %cleanup

if.end193:                                        ; preds = %if.end189
  %138 = load ptr, ptr %src, align 8
  %139 = load i32, ptr %s147, align 4
  %call194 = call i32 @clusterManagerClearSlotStatus(ptr noundef %138, i32 noundef %139)
  %tobool195 = icmp ne i32 %call194, 0
  br i1 %tobool195, label %if.end197, label %if.then196

if.then196:                                       ; preds = %if.end193
  store i32 -1, ptr %fixed, align 4
  br label %if.end197

if.end197:                                        ; preds = %if.then196, %if.end193
  %140 = load i32, ptr %fixed, align 4
  %cmp198 = icmp slt i32 %140, 0
  br i1 %cmp198, label %if.then200, label %if.end201

if.then200:                                       ; preds = %if.end197
  br label %cleanup

if.end201:                                        ; preds = %if.end197
  br label %while.cond164, !llvm.loop !186

while.end202:                                     ; preds = %while.cond164
  %141 = load i32, ptr %fixed, align 4
  %inc203 = add nsw i32 %141, 1
  store i32 %inc203, ptr %fixed, align 4
  br label %while.cond136, !llvm.loop !187

while.end204:                                     ; preds = %while.cond136
  br label %if.end205

if.end205:                                        ; preds = %while.end204, %if.then129
  br label %if.end206

if.end206:                                        ; preds = %if.end205, %if.end125
  br label %cleanup

cleanup:                                          ; preds = %if.end206, %if.then200, %if.then192, %if.then188, %if.then180, %if.then158, %if.then152, %if.then116, %if.then79, %if.end21
  %142 = load ptr, ptr %none, align 8
  %tobool207 = icmp ne ptr %142, null
  br i1 %tobool207, label %if.then208, label %if.end209

if.then208:                                       ; preds = %cleanup
  %143 = load ptr, ptr %none, align 8
  call void @listRelease(ptr noundef %143)
  br label %if.end209

if.end209:                                        ; preds = %if.then208, %cleanup
  %144 = load ptr, ptr %single, align 8
  %tobool210 = icmp ne ptr %144, null
  br i1 %tobool210, label %if.then211, label %if.end212

if.then211:                                       ; preds = %if.end209
  %145 = load ptr, ptr %single, align 8
  call void @listRelease(ptr noundef %145)
  br label %if.end212

if.end212:                                        ; preds = %if.then211, %if.end209
  %146 = load ptr, ptr %multi, align 8
  %tobool213 = icmp ne ptr %146, null
  br i1 %tobool213, label %if.then214, label %if.end215

if.then214:                                       ; preds = %if.end212
  %147 = load ptr, ptr %multi, align 8
  call void @listRelease(ptr noundef %147)
  br label %if.end215

if.end215:                                        ; preds = %if.then214, %if.end212
  %148 = load i32, ptr %fixed, align 4
  ret i32 %148
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCountKeysInSlot(ptr noundef %node, i32 noundef %slot) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %reply = alloca ptr, align 8
  %count = alloca i32, align 4
  %success = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %2 = load i32, ptr %slot.addr, align 4
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.261, i32 noundef %2)
  store ptr %call, ptr %reply, align 8
  store i32 -1, ptr %count, align 4
  %3 = load ptr, ptr %node.addr, align 8
  %4 = load ptr, ptr %reply, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %3, ptr noundef %4, ptr noundef null)
  store i32 %call1, ptr %success, align 4
  %5 = load i32, ptr %success, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %6 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %7, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load ptr, ptr %reply, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 1
  %9 = load i64, ptr %integer, align 8
  %conv = trunc i64 %9 to i32
  store i32 %conv, ptr %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %10 = load ptr, ptr %reply, align 8
  %tobool2 = icmp ne ptr %10, null
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %11)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %12 = load i32, ptr %count, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerFixMultipleSlotOwners(i32 noundef %slot, ptr noundef %owners) #0 {
entry:
  %retval = alloca i32, align 4
  %slot.addr = alloca i32, align 4
  %owners.addr = alloca ptr, align 8
  %success = alloca i32, align 4
  %owner = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %count = alloca i32, align 4
  %opts = alloca i32, align 4
  store i32 %slot, ptr %slot.addr, align 4
  store ptr %owners, ptr %owners.addr, align 8
  %0 = load i32, ptr %slot.addr, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.325, i32 noundef %0)
  store i32 0, ptr %success, align 4
  %1 = load ptr, ptr %owners.addr, align 8
  %2 = load i32, ptr %slot.addr, align 4
  %call = call ptr @clusterManagerGetNodeWithMostKeysInSlot(ptr noundef %1, i32 noundef %2, ptr noundef null)
  store ptr %call, ptr %owner, align 8
  %3 = load ptr, ptr %owner, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %owners.addr, align 8
  %head = getelementptr inbounds %struct.list, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %head, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %owner, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32, ptr %slot.addr, align 4
  %8 = load ptr, ptr %owner, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %ip, align 8
  %10 = load ptr, ptr %owner, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %10, i32 0, i32 3
  %11 = load i32, ptr %port, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 1, ptr noundef @.str.326, i32 noundef %7, ptr noundef %9, i32 noundef %11)
  %12 = load ptr, ptr %owner, align 8
  %13 = load i32, ptr %slot.addr, align 4
  %call1 = call i32 @clusterManagerSetSlotOwner(ptr noundef %12, i32 noundef %13, i32 noundef 0)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %14 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %14, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end30, %if.then11, %if.then8, %if.end4
  %call5 = call ptr @listNext(ptr noundef %li)
  store ptr %call5, ptr %ln, align 8
  %cmp = icmp ne ptr %call5, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load ptr, ptr %ln, align 8
  %value6 = getelementptr inbounds %struct.listNode, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %value6, align 8
  store ptr %16, ptr %n, align 8
  %17 = load ptr, ptr %n, align 8
  %18 = load ptr, ptr %owner, align 8
  %cmp7 = icmp eq ptr %17, %18
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !188

if.end9:                                          ; preds = %while.body
  %19 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %19, i32 0, i32 8
  %20 = load i32, ptr %flags, align 8
  %and = and i32 %20, 2
  %tobool10 = icmp ne i32 %and, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end9
  br label %while.cond, !llvm.loop !188

if.end12:                                         ; preds = %if.end9
  %21 = load ptr, ptr %n, align 8
  %22 = load i32, ptr %slot.addr, align 4
  %call13 = call i32 @clusterManagerCountKeysInSlot(ptr noundef %21, i32 noundef %22)
  store i32 %call13, ptr %count, align 4
  %23 = load i32, ptr %count, align 4
  %cmp14 = icmp sge i32 %23, 0
  %conv = zext i1 %cmp14 to i32
  store i32 %conv, ptr %success, align 4
  %24 = load i32, ptr %success, align 4
  %tobool15 = icmp ne i32 %24, 0
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end12
  br label %while.end

if.end17:                                         ; preds = %if.end12
  %25 = load ptr, ptr %n, align 8
  %26 = load i32, ptr %slot.addr, align 4
  %call18 = call i32 @clusterManagerDelSlot(ptr noundef %25, i32 noundef %26, i32 noundef 1)
  %27 = load ptr, ptr %n, align 8
  %28 = load ptr, ptr %owner, align 8
  %29 = load i32, ptr %slot.addr, align 4
  %call19 = call i32 @clusterManagerSetSlot(ptr noundef %27, ptr noundef %28, i32 noundef %29, ptr noundef @.str.270, ptr noundef null)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end17
  store i32 0, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end17
  %30 = load i32, ptr %count, align 4
  %cmp23 = icmp sgt i32 %30, 0
  br i1 %cmp23, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.end22
  store i32 130, ptr %opts, align 4
  %31 = load ptr, ptr %n, align 8
  %32 = load ptr, ptr %owner, align 8
  %33 = load i32, ptr %slot.addr, align 4
  %34 = load i32, ptr %opts, align 4
  %call26 = call i32 @clusterManagerMoveSlot(ptr noundef %31, ptr noundef %32, i32 noundef %33, i32 noundef %34, ptr noundef null)
  store i32 %call26, ptr %success, align 4
  %35 = load i32, ptr %success, align 4
  %tobool27 = icmp ne i32 %35, 0
  br i1 %tobool27, label %if.end29, label %if.then28

if.then28:                                        ; preds = %if.then25
  br label %while.end

if.end29:                                         ; preds = %if.then25
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.end22
  br label %while.cond, !llvm.loop !188

while.end:                                        ; preds = %if.then28, %if.then16, %while.cond
  %36 = load i32, ptr %success, align 4
  store i32 %36, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then21, %if.then3
  %37 = load i32, ptr %retval, align 4
  ret i32 %37
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerGetNodeWithMostKeysInSlot(ptr noundef %nodes, i32 noundef %slot, ptr noundef %err) #0 {
entry:
  %nodes.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %err.addr = alloca ptr, align 8
  %node = alloca ptr, align 8
  %numkeys = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %r = alloca ptr, align 8
  %success = alloca i32, align 4
  store ptr %nodes, ptr %nodes.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  store ptr %err, ptr %err.addr, align 8
  store ptr null, ptr %node, align 8
  store i32 0, ptr %numkeys, align 4
  %0 = load ptr, ptr %nodes.addr, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  %1 = load ptr, ptr %err.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end31, %if.then3, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %n, align 8
  %5 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %5, i32 0, i32 8
  %6 = load i32, ptr %flags, align 8
  %and = and i32 %6, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %7 = load ptr, ptr %n, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %7, i32 0, i32 10
  %8 = load ptr, ptr %replicate, align 8
  %tobool2 = icmp ne ptr %8, null
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %lor.lhs.false, %while.body
  br label %while.cond, !llvm.loop !189

if.end4:                                          ; preds = %lor.lhs.false
  %9 = load ptr, ptr %n, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %context, align 8
  %11 = load i32, ptr %slot.addr, align 4
  %call5 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %10, ptr noundef @.str.261, i32 noundef %11)
  store ptr %call5, ptr %r, align 8
  %12 = load ptr, ptr %n, align 8
  %13 = load ptr, ptr %r, align 8
  %14 = load ptr, ptr %err.addr, align 8
  %call6 = call i32 @clusterManagerCheckRedisReply(ptr noundef %12, ptr noundef %13, ptr noundef %14)
  store i32 %call6, ptr %success, align 4
  %15 = load i32, ptr %success, align 4
  %tobool7 = icmp ne i32 %15, 0
  br i1 %tobool7, label %if.then8, label %if.end18

if.then8:                                         ; preds = %if.end4
  %16 = load ptr, ptr %r, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 1
  %17 = load i64, ptr %integer, align 8
  %18 = load i32, ptr %numkeys, align 4
  %conv = sext i32 %18 to i64
  %cmp9 = icmp sgt i64 %17, %conv
  br i1 %cmp9, label %if.then14, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %if.then8
  %19 = load ptr, ptr %node, align 8
  %cmp12 = icmp eq ptr %19, null
  br i1 %cmp12, label %if.then14, label %if.end17

if.then14:                                        ; preds = %lor.lhs.false11, %if.then8
  %20 = load ptr, ptr %r, align 8
  %integer15 = getelementptr inbounds %struct.redisReply, ptr %20, i32 0, i32 1
  %21 = load i64, ptr %integer15, align 8
  %conv16 = trunc i64 %21 to i32
  store i32 %conv16, ptr %numkeys, align 4
  %22 = load ptr, ptr %n, align 8
  store ptr %22, ptr %node, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %lor.lhs.false11
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end4
  %23 = load ptr, ptr %r, align 8
  %cmp19 = icmp ne ptr %23, null
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %24 = load ptr, ptr %r, align 8
  call void @freeReplyObject(ptr noundef %24)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end18
  %25 = load i32, ptr %success, align 4
  %tobool23 = icmp ne i32 %25, 0
  br i1 %tobool23, label %if.end31, label %if.then24

if.then24:                                        ; preds = %if.end22
  %26 = load ptr, ptr %err.addr, align 8
  %cmp25 = icmp ne ptr %26, null
  br i1 %cmp25, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.then24
  %27 = load ptr, ptr %err.addr, align 8
  %28 = load ptr, ptr %27, align 8
  %cmp27 = icmp ne ptr %28, null
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %land.lhs.true
  %29 = load ptr, ptr %n, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %29, i32 0, i32 2
  %30 = load ptr, ptr %ip, align 8
  %31 = load ptr, ptr %n, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %31, i32 0, i32 3
  %32 = load i32, ptr %port, align 8
  %33 = load ptr, ptr %err.addr, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %30, i32 noundef %32, ptr noundef %33)
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %land.lhs.true, %if.then24
  store ptr null, ptr %node, align 8
  br label %while.end

if.end31:                                         ; preds = %if.end22
  br label %while.cond, !llvm.loop !189

while.end:                                        ; preds = %if.end30, %while.cond
  %34 = load ptr, ptr %node, align 8
  ret ptr %34
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerClearSlotStatus(ptr noundef %node, i32 noundef %slot) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %reply = alloca ptr, align 8
  %success = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %2 = load i32, ptr %slot.addr, align 4
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.280, i32 noundef %2, ptr noundef @.str.281)
  store ptr %call, ptr %reply, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %4 = load ptr, ptr %reply, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %3, ptr noundef %4, ptr noundef null)
  store i32 %call1, ptr %success, align 4
  %5 = load ptr, ptr %reply, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32, ptr %success, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerSetSlotOwner(ptr noundef %owner, i32 noundef %slot, i32 noundef %do_clear) #0 {
entry:
  %retval = alloca i32, align 4
  %owner.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %do_clear.addr = alloca i32, align 4
  %success = alloca i32, align 4
  store ptr %owner, ptr %owner.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  store i32 %do_clear, ptr %do_clear.addr, align 4
  %0 = load ptr, ptr %owner.addr, align 8
  %call = call i32 @clusterManagerStartTransaction(ptr noundef %0)
  store i32 %call, ptr %success, align 4
  %1 = load i32, ptr %success, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %owner.addr, align 8
  %3 = load i32, ptr %slot.addr, align 4
  %call1 = call i32 @clusterManagerDelSlot(ptr noundef %2, i32 noundef %3, i32 noundef 1)
  %4 = load ptr, ptr %owner.addr, align 8
  %5 = load i32, ptr %slot.addr, align 4
  %call2 = call i32 @clusterManagerAddSlot(ptr noundef %4, i32 noundef %5)
  %6 = load i32, ptr %do_clear.addr, align 4
  %tobool3 = icmp ne i32 %6, 0
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %7 = load ptr, ptr %owner.addr, align 8
  %8 = load i32, ptr %slot.addr, align 4
  %call5 = call i32 @clusterManagerClearSlotStatus(ptr noundef %7, i32 noundef %8)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %9 = load ptr, ptr %owner.addr, align 8
  %call7 = call i32 @clusterManagerBumpEpoch(ptr noundef %9)
  %10 = load ptr, ptr %owner.addr, align 8
  %call8 = call i32 @clusterManagerExecTransaction(ptr noundef %10, ptr noundef @clusterManagerOnSetOwnerErr)
  store i32 %call8, ptr %success, align 4
  %11 = load i32, ptr %success, align 4
  store i32 %11, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerRemoveNodeFromList(ptr noundef %nodelist, ptr noundef %node) #0 {
entry:
  %nodelist.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  store ptr %nodelist, ptr %nodelist.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %nodelist.addr, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %node.addr, align 8
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  %cmp1 = icmp eq ptr %1, %3
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %4 = load ptr, ptr %nodelist.addr, align 8
  %5 = load ptr, ptr %ln, align 8
  call void @listDelNode(ptr noundef %4, ptr noundef %5)
  br label %while.end

if.end:                                           ; preds = %while.body
  br label %while.cond, !llvm.loop !190

while.end:                                        ; preds = %if.then, %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerDelSlot(ptr noundef %node, i32 noundef %slot, i32 noundef %ignore_unassigned_err) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %ignore_unassigned_err.addr = alloca i32, align 4
  %reply = alloca ptr, align 8
  %err = alloca ptr, align 8
  %success = alloca i32, align 4
  %get_owner_err = alloca ptr, align 8
  %assigned_to = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  store i32 %ignore_unassigned_err, ptr %ignore_unassigned_err.addr, align 4
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %2 = load i32, ptr %slot.addr, align 4
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.287, i32 noundef %2)
  store ptr %call, ptr %reply, align 8
  store ptr null, ptr %err, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %4 = load ptr, ptr %reply, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %3, ptr noundef %4, ptr noundef %err)
  store i32 %call1, ptr %success, align 4
  %5 = load i32, ptr %success, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %6 = load ptr, ptr %reply, align 8
  %tobool2 = icmp ne ptr %6, null
  br i1 %tobool2, label %land.lhs.true3, label %if.end12

land.lhs.true3:                                   ; preds = %land.lhs.true
  %7 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %8, 6
  br i1 %cmp, label %land.lhs.true4, label %if.end12

land.lhs.true4:                                   ; preds = %land.lhs.true3
  %9 = load i32, ptr %ignore_unassigned_err.addr, align 4
  %tobool5 = icmp ne i32 %9, 0
  br i1 %tobool5, label %if.then, label %if.end12

if.then:                                          ; preds = %land.lhs.true4
  store ptr null, ptr %get_owner_err, align 8
  %10 = load ptr, ptr %node.addr, align 8
  %11 = load i32, ptr %slot.addr, align 4
  %call6 = call ptr @clusterManagerGetSlotOwner(ptr noundef %10, i32 noundef %11, ptr noundef %get_owner_err)
  store ptr %call6, ptr %assigned_to, align 8
  %12 = load ptr, ptr %assigned_to, align 8
  %tobool7 = icmp ne ptr %12, null
  br i1 %tobool7, label %if.end11, label %if.then8

if.then8:                                         ; preds = %if.then
  %13 = load ptr, ptr %get_owner_err, align 8
  %cmp9 = icmp eq ptr %13, null
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then8
  store i32 1, ptr %success, align 4
  br label %if.end

if.else:                                          ; preds = %if.then8
  %14 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %ip, align 8
  %16 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %port, align 8
  %18 = load ptr, ptr %get_owner_err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %15, i32 noundef %17, ptr noundef %18)
  %19 = load ptr, ptr %get_owner_err, align 8
  call void @zfree(ptr noundef %19)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then10
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %land.lhs.true4, %land.lhs.true3, %land.lhs.true, %entry
  %20 = load i32, ptr %success, align 4
  %tobool13 = icmp ne i32 %20, 0
  br i1 %tobool13, label %if.end19, label %land.lhs.true14

land.lhs.true14:                                  ; preds = %if.end12
  %21 = load ptr, ptr %err, align 8
  %cmp15 = icmp ne ptr %21, null
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %land.lhs.true14
  %22 = load ptr, ptr %node.addr, align 8
  %ip17 = getelementptr inbounds %struct.clusterManagerNode, ptr %22, i32 0, i32 2
  %23 = load ptr, ptr %ip17, align 8
  %24 = load ptr, ptr %node.addr, align 8
  %port18 = getelementptr inbounds %struct.clusterManagerNode, ptr %24, i32 0, i32 3
  %25 = load i32, ptr %port18, align 8
  %26 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %23, i32 noundef %25, ptr noundef %26)
  %27 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %27)
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %land.lhs.true14, %if.end12
  %28 = load ptr, ptr %reply, align 8
  %tobool20 = icmp ne ptr %28, null
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  %29 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %29)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end19
  %30 = load i32, ptr %success, align 4
  ret i32 %30
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerSetSlot(ptr noundef %node1, ptr noundef %node2, i32 noundef %slot, ptr noundef %status, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %node1.addr = alloca ptr, align 8
  %node2.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %status.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %success = alloca i32, align 4
  store ptr %node1, ptr %node1.addr, align 8
  store ptr %node2, ptr %node2.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  store ptr %status, ptr %status.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %node1.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %2 = load i32, ptr %slot.addr, align 4
  %3 = load ptr, ptr %status.addr, align 8
  %4 = load ptr, ptr %node2.addr, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %name, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.289, i32 noundef %2, ptr noundef %3, ptr noundef %5)
  store ptr %call, ptr %reply, align 8
  %6 = load ptr, ptr %err.addr, align 8
  %cmp = icmp ne ptr %6, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %7, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load ptr, ptr %reply, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end6, label %if.then1

if.then1:                                         ; preds = %if.end
  %9 = load ptr, ptr %err.addr, align 8
  %tobool2 = icmp ne ptr %9, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.then1
  %call4 = call noalias ptr @zstrdup(ptr noundef @.str.290)
  %10 = load ptr, ptr %err.addr, align 8
  store ptr %call4, ptr %10, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.then1
  store i32 0, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  store i32 1, ptr %success, align 4
  %11 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type, align 8
  %cmp7 = icmp eq i32 %12, 6
  br i1 %cmp7, label %if.then8, label %if.end17

if.then8:                                         ; preds = %if.end6
  store i32 0, ptr %success, align 4
  %13 = load ptr, ptr %err.addr, align 8
  %cmp9 = icmp ne ptr %13, null
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then8
  %14 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %14, i32 0, i32 3
  %15 = load i64, ptr %len, align 8
  %add = add i64 %15, 1
  %mul = mul i64 %add, 1
  %call11 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  %16 = load ptr, ptr %err.addr, align 8
  store ptr %call11, ptr %16, align 8
  %17 = load ptr, ptr %err.addr, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 4
  %20 = load ptr, ptr %str, align 8
  %21 = load ptr, ptr %reply, align 8
  %len12 = getelementptr inbounds %struct.redisReply, ptr %21, i32 0, i32 3
  %22 = load i64, ptr %len12, align 8
  %add13 = add i64 %22, 1
  %call14 = call i64 @redis_strlcpy(ptr noundef %18, ptr noundef %20, i64 noundef %add13)
  br label %if.end16

if.else:                                          ; preds = %if.then8
  %23 = load ptr, ptr %node1.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %23, i32 0, i32 2
  %24 = load ptr, ptr %ip, align 8
  %25 = load ptr, ptr %node1.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %25, i32 0, i32 3
  %26 = load i32, ptr %port, align 8
  %27 = load ptr, ptr %reply, align 8
  %str15 = getelementptr inbounds %struct.redisReply, ptr %27, i32 0, i32 4
  %28 = load ptr, ptr %str15, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %24, i32 noundef %26, ptr noundef %28)
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then10
  br label %cleanup

if.end17:                                         ; preds = %if.end6
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.end16
  %29 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %29)
  %30 = load i32, ptr %success, align 4
  store i32 %30, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cleanup, %if.end5
  %31 = load i32, ptr %retval, align 4
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerMoveSlot(ptr noundef %source, ptr noundef %target, i32 noundef %slot, i32 noundef %opts, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %source.addr = alloca ptr, align 8
  %target.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %opts.addr = alloca i32, align 4
  %err.addr = alloca ptr, align 8
  %pipeline = alloca i32, align 4
  %timeout = alloca i32, align 4
  %print_dots = alloca i32, align 4
  %option_cold = alloca i32, align 4
  %success = alloca i32, align 4
  %acceptable = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %source, ptr %source.addr, align 8
  store ptr %target, ptr %target.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  store i32 %opts, ptr %opts.addr, align 4
  store ptr %err, ptr %err.addr, align 8
  %0 = load i32, ptr %opts.addr, align 4
  %and = and i32 %0, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %slot.addr, align 4
  %2 = load ptr, ptr %source.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ip, align 8
  %4 = load ptr, ptr %source.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %port, align 8
  %6 = load ptr, ptr %target.addr, align 8
  %ip1 = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %ip1, align 8
  %8 = load ptr, ptr %target.addr, align 8
  %port2 = getelementptr inbounds %struct.clusterManagerNode, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %port2, align 8
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.291, i32 noundef %1, ptr noundef %3, i32 noundef %5, ptr noundef %7, i32 noundef %9)
  %10 = load ptr, ptr @stdout, align 8
  %call3 = call i32 @fflush(ptr noundef %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load ptr, ptr %err.addr, align 8
  %cmp = icmp ne ptr %11, null
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  %12 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %12, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %13 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 13), align 8
  store i32 %13, ptr %pipeline, align 4
  %14 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 12), align 4
  store i32 %14, ptr %timeout, align 4
  %15 = load i32, ptr %opts.addr, align 4
  %and6 = and i32 %15, 128
  store i32 %and6, ptr %print_dots, align 4
  %16 = load i32, ptr %opts.addr, align 4
  %and7 = and i32 %16, 2
  store i32 %and7, ptr %option_cold, align 4
  store i32 1, ptr %success, align 4
  %17 = load i32, ptr %option_cold, align 4
  %tobool8 = icmp ne i32 %17, 0
  br i1 %tobool8, label %if.end18, label %if.then9

if.then9:                                         ; preds = %if.end5
  %18 = load ptr, ptr %target.addr, align 8
  %19 = load ptr, ptr %source.addr, align 8
  %20 = load i32, ptr %slot.addr, align 4
  %21 = load ptr, ptr %err.addr, align 8
  %call10 = call i32 @clusterManagerSetSlot(ptr noundef %18, ptr noundef %19, i32 noundef %20, ptr noundef @.str.271, ptr noundef %21)
  store i32 %call10, ptr %success, align 4
  %22 = load i32, ptr %success, align 4
  %tobool11 = icmp ne i32 %22, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.then9
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.then9
  %23 = load ptr, ptr %source.addr, align 8
  %24 = load ptr, ptr %target.addr, align 8
  %25 = load i32, ptr %slot.addr, align 4
  %26 = load ptr, ptr %err.addr, align 8
  %call14 = call i32 @clusterManagerSetSlot(ptr noundef %23, ptr noundef %24, i32 noundef %25, ptr noundef @.str.292, ptr noundef %26)
  store i32 %call14, ptr %success, align 4
  %27 = load i32, ptr %success, align 4
  %tobool15 = icmp ne i32 %27, 0
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end13
  store i32 0, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.end13
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end5
  %28 = load ptr, ptr %source.addr, align 8
  %29 = load ptr, ptr %target.addr, align 8
  %30 = load i32, ptr %slot.addr, align 4
  %31 = load i32, ptr %timeout, align 4
  %32 = load i32, ptr %pipeline, align 4
  %33 = load i32, ptr %print_dots, align 4
  %34 = load ptr, ptr %err.addr, align 8
  %call19 = call i32 @clusterManagerMigrateKeysInSlot(ptr noundef %28, ptr noundef %29, i32 noundef %30, i32 noundef %31, i32 noundef %32, i32 noundef %33, ptr noundef %34)
  store i32 %call19, ptr %success, align 4
  %35 = load i32, ptr %opts.addr, align 4
  %and20 = and i32 %35, 64
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.end24, label %if.then22

if.then22:                                        ; preds = %if.end18
  %call23 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %if.end18
  %36 = load i32, ptr %success, align 4
  %tobool25 = icmp ne i32 %36, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.end24
  store i32 0, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end24
  %37 = load i32, ptr %option_cold, align 4
  %tobool28 = icmp ne i32 %37, 0
  br i1 %tobool28, label %if.end62, label %if.then29

if.then29:                                        ; preds = %if.end27
  %38 = load ptr, ptr %target.addr, align 8
  %39 = load ptr, ptr %target.addr, align 8
  %40 = load i32, ptr %slot.addr, align 4
  %41 = load ptr, ptr %err.addr, align 8
  %call30 = call i32 @clusterManagerSetSlot(ptr noundef %38, ptr noundef %39, i32 noundef %40, ptr noundef @.str.270, ptr noundef %41)
  store i32 %call30, ptr %success, align 4
  %42 = load i32, ptr %success, align 4
  %tobool31 = icmp ne i32 %42, 0
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.then29
  store i32 0, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.then29
  %43 = load ptr, ptr %source.addr, align 8
  %44 = load ptr, ptr %target.addr, align 8
  %45 = load i32, ptr %slot.addr, align 4
  %46 = load ptr, ptr %err.addr, align 8
  %call34 = call i32 @clusterManagerSetSlot(ptr noundef %43, ptr noundef %44, i32 noundef %45, ptr noundef @.str.270, ptr noundef %46)
  store i32 %call34, ptr %success, align 4
  store ptr @.str.293, ptr %acceptable, align 8
  %47 = load i32, ptr %success, align 4
  %tobool35 = icmp ne i32 %47, 0
  br i1 %tobool35, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end33
  %48 = load ptr, ptr %err.addr, align 8
  %tobool36 = icmp ne ptr %48, null
  br i1 %tobool36, label %land.lhs.true37, label %if.else

land.lhs.true37:                                  ; preds = %land.lhs.true
  %49 = load ptr, ptr %err.addr, align 8
  %50 = load ptr, ptr %49, align 8
  %51 = load ptr, ptr %acceptable, align 8
  %52 = load ptr, ptr %acceptable, align 8
  %call38 = call i64 @strlen(ptr noundef %52) #12
  %call39 = call i32 @strncmp(ptr noundef %50, ptr noundef %51, i64 noundef %call38) #12
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.else, label %if.then41

if.then41:                                        ; preds = %land.lhs.true37
  %53 = load ptr, ptr %err.addr, align 8
  %54 = load ptr, ptr %53, align 8
  call void @zfree(ptr noundef %54)
  %55 = load ptr, ptr %err.addr, align 8
  store ptr null, ptr %55, align 8
  br label %if.end47

if.else:                                          ; preds = %land.lhs.true37, %land.lhs.true, %if.end33
  %56 = load i32, ptr %success, align 4
  %tobool42 = icmp ne i32 %56, 0
  br i1 %tobool42, label %if.end46, label %land.lhs.true43

land.lhs.true43:                                  ; preds = %if.else
  %57 = load ptr, ptr %err.addr, align 8
  %tobool44 = icmp ne ptr %57, null
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %land.lhs.true43
  store i32 0, ptr %retval, align 4
  br label %return

if.end46:                                         ; preds = %land.lhs.true43, %if.else
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then41
  %58 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %58, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end61, %if.then56, %if.then52, %if.end47
  %call48 = call ptr @listNext(ptr noundef %li)
  store ptr %call48, ptr %ln, align 8
  %cmp49 = icmp ne ptr %call48, null
  br i1 %cmp49, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %59 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %59, i32 0, i32 2
  %60 = load ptr, ptr %value, align 8
  store ptr %60, ptr %n, align 8
  %61 = load ptr, ptr %n, align 8
  %62 = load ptr, ptr %target.addr, align 8
  %cmp50 = icmp eq ptr %61, %62
  br i1 %cmp50, label %if.then52, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %63 = load ptr, ptr %n, align 8
  %64 = load ptr, ptr %source.addr, align 8
  %cmp51 = icmp eq ptr %63, %64
  br i1 %cmp51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %lor.lhs.false, %while.body
  br label %while.cond, !llvm.loop !191

if.end53:                                         ; preds = %lor.lhs.false
  %65 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %65, i32 0, i32 8
  %66 = load i32, ptr %flags, align 8
  %and54 = and i32 %66, 2
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end53
  br label %while.cond, !llvm.loop !191

if.end57:                                         ; preds = %if.end53
  %67 = load ptr, ptr %n, align 8
  %68 = load ptr, ptr %target.addr, align 8
  %69 = load i32, ptr %slot.addr, align 4
  %70 = load ptr, ptr %err.addr, align 8
  %call58 = call i32 @clusterManagerSetSlot(ptr noundef %67, ptr noundef %68, i32 noundef %69, ptr noundef @.str.270, ptr noundef %70)
  store i32 %call58, ptr %success, align 4
  %71 = load i32, ptr %success, align 4
  %tobool59 = icmp ne i32 %71, 0
  br i1 %tobool59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %if.end57
  store i32 0, ptr %retval, align 4
  br label %return

if.end61:                                         ; preds = %if.end57
  br label %while.cond, !llvm.loop !191

while.end:                                        ; preds = %while.cond
  br label %if.end62

if.end62:                                         ; preds = %while.end, %if.end27
  %72 = load i32, ptr %opts.addr, align 4
  %and63 = and i32 %72, 4
  %tobool64 = icmp ne i32 %and63, 0
  br i1 %tobool64, label %if.then65, label %if.end69

if.then65:                                        ; preds = %if.end62
  %73 = load ptr, ptr %source.addr, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %73, i32 0, i32 12
  %74 = load i32, ptr %slot.addr, align 4
  %idxprom = sext i32 %74 to i64
  %arrayidx = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom
  store i8 0, ptr %arrayidx, align 1
  %75 = load ptr, ptr %target.addr, align 8
  %slots66 = getelementptr inbounds %struct.clusterManagerNode, ptr %75, i32 0, i32 12
  %76 = load i32, ptr %slot.addr, align 4
  %idxprom67 = sext i32 %76 to i64
  %arrayidx68 = getelementptr inbounds [16384 x i8], ptr %slots66, i64 0, i64 %idxprom67
  store i8 1, ptr %arrayidx68, align 1
  br label %if.end69

if.end69:                                         ; preds = %if.then65, %if.end62
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end69, %if.then60, %if.then45, %if.then32, %if.then26, %if.then16, %if.then12
  %77 = load i32, ptr %retval, align 4
  ret i32 %77
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerStartTransaction(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %success = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.283)
  store ptr %call, ptr %reply, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %3 = load ptr, ptr %reply, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %2, ptr noundef %3, ptr noundef null)
  store i32 %call1, ptr %success, align 4
  %4 = load ptr, ptr %reply, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, ptr %success, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerAddSlot(ptr noundef %node, i32 noundef %slot) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %reply = alloca ptr, align 8
  %success = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %2 = load i32, ptr %slot.addr, align 4
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.284, i32 noundef %2)
  store ptr %call, ptr %reply, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %4 = load ptr, ptr %reply, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %3, ptr noundef %4, ptr noundef null)
  store i32 %call1, ptr %success, align 4
  %5 = load ptr, ptr %reply, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32, ptr %success, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerBumpEpoch(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %success = alloca i32, align 4
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.285)
  store ptr %call, ptr %reply, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %3 = load ptr, ptr %reply, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %2, ptr noundef %3, ptr noundef null)
  store i32 %call1, ptr %success, align 4
  %4 = load ptr, ptr %reply, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32, ptr %success, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerExecTransaction(ptr noundef %node, ptr noundef %onerror) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %onerror.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %success = alloca i32, align 4
  %i = alloca i64, align 8
  %r = alloca ptr, align 8
  %err = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store ptr %onerror, ptr %onerror.addr, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.286)
  store ptr %call, ptr %reply, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %3 = load ptr, ptr %reply, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %2, ptr noundef %3, ptr noundef null)
  store i32 %call1, ptr %success, align 4
  %4 = load i32, ptr %success, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end19

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type, align 8
  %cmp = icmp ne i32 %6, 2
  br i1 %cmp, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  store i32 0, ptr %success, align 4
  br label %cleanup

if.end:                                           ; preds = %if.then
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i64, ptr %i, align 8
  %8 = load ptr, ptr %reply, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %elements, align 8
  %cmp3 = icmp ult i64 %7, %9
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 7
  %11 = load ptr, ptr %element, align 8
  %12 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %11, i64 %12
  %13 = load ptr, ptr %arrayidx, align 8
  store ptr %13, ptr %r, align 8
  store ptr null, ptr %err, align 8
  %14 = load ptr, ptr %node.addr, align 8
  %15 = load ptr, ptr %r, align 8
  %call4 = call i32 @clusterManagerCheckRedisReply(ptr noundef %14, ptr noundef %15, ptr noundef %err)
  store i32 %call4, ptr %success, align 4
  %16 = load i32, ptr %success, align 4
  %tobool5 = icmp ne i32 %16, 0
  br i1 %tobool5, label %if.end9, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %17 = load ptr, ptr %onerror.addr, align 8
  %tobool6 = icmp ne ptr %17, null
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %land.lhs.true
  %18 = load ptr, ptr %onerror.addr, align 8
  %19 = load ptr, ptr %r, align 8
  %20 = load ptr, ptr %node.addr, align 8
  %21 = load i64, ptr %i, align 8
  %conv = trunc i64 %21 to i32
  %call8 = call i32 %18(ptr noundef %19, ptr noundef %20, i32 noundef %conv)
  store i32 %call8, ptr %success, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %land.lhs.true, %for.body
  %22 = load ptr, ptr %err, align 8
  %tobool10 = icmp ne ptr %22, null
  br i1 %tobool10, label %if.then11, label %if.end15

if.then11:                                        ; preds = %if.end9
  %23 = load i32, ptr %success, align 4
  %tobool12 = icmp ne i32 %23, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.then11
  %24 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %ip, align 8
  %26 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %26, i32 0, i32 3
  %27 = load i32, ptr %port, align 8
  %28 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %25, i32 noundef %27, ptr noundef %28)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.then11
  %29 = load ptr, ptr %err, align 8
  call void @zfree(ptr noundef %29)
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.end9
  %30 = load i32, ptr %success, align 4
  %tobool16 = icmp ne i32 %30, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %for.end

if.end18:                                         ; preds = %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end18
  %31 = load i64, ptr %i, align 8
  %inc = add i64 %31, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !192

for.end:                                          ; preds = %if.then17, %for.cond
  br label %if.end19

if.end19:                                         ; preds = %for.end, %entry
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then2
  %32 = load ptr, ptr %reply, align 8
  %tobool20 = icmp ne ptr %32, null
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %cleanup
  %33 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %33)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %cleanup
  %34 = load i32, ptr %success, align 4
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerOnSetOwnerErr(ptr noundef %reply, ptr noundef %n, i32 noundef %bulk_idx) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %bulk_idx.addr = alloca i32, align 4
  store ptr %reply, ptr %reply.addr, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 %bulk_idx, ptr %bulk_idx.addr, align 4
  %0 = load i32, ptr %bulk_idx.addr, align 4
  %cmp = icmp ne i32 %0, 1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare void @listDelNode(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerGetSlotOwner(ptr noundef %n, i32 noundef %slot, ptr noundef %err) #0 {
entry:
  %n.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %err.addr = alloca ptr, align 8
  %owner = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %i = alloca i64, align 8
  %r = alloca ptr, align 8
  %from = alloca i32, align 4
  %to = alloca i32, align 4
  %nr = alloca ptr, align 8
  %name = alloca ptr, align 8
  %ip = alloca ptr, align 8
  %port = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %nd = alloca ptr, align 8
  store ptr %n, ptr %n.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  store ptr %err, ptr %err.addr, align 8
  store ptr null, ptr %owner, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.288)
  store ptr %call, ptr %reply, align 8
  %2 = load ptr, ptr %n.addr, align 8
  %3 = load ptr, ptr %reply, align 8
  %4 = load ptr, ptr %err.addr, align 8
  %call1 = call i32 @clusterManagerCheckRedisReply(ptr noundef %2, ptr noundef %3, ptr noundef %4)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end49

if.then:                                          ; preds = %entry
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %5 = load i64, ptr %i, align 8
  %6 = load ptr, ptr %reply, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 7
  %9 = load ptr, ptr %element, align 8
  %10 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %9, i64 %10
  %11 = load ptr, ptr %arrayidx, align 8
  store ptr %11, ptr %r, align 8
  %12 = load ptr, ptr %r, align 8
  %element2 = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 7
  %13 = load ptr, ptr %element2, align 8
  %arrayidx3 = getelementptr inbounds ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx3, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %14, i32 0, i32 1
  %15 = load i64, ptr %integer, align 8
  %conv = trunc i64 %15 to i32
  store i32 %conv, ptr %from, align 4
  %16 = load ptr, ptr %r, align 8
  %element4 = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 7
  %17 = load ptr, ptr %element4, align 8
  %arrayidx5 = getelementptr inbounds ptr, ptr %17, i64 1
  %18 = load ptr, ptr %arrayidx5, align 8
  %integer6 = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 1
  %19 = load i64, ptr %integer6, align 8
  %conv7 = trunc i64 %19 to i32
  store i32 %conv7, ptr %to, align 4
  %20 = load i32, ptr %slot.addr, align 4
  %21 = load i32, ptr %from, align 4
  %cmp8 = icmp slt i32 %20, %21
  br i1 %cmp8, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %22 = load i32, ptr %slot.addr, align 4
  %23 = load i32, ptr %to, align 4
  %cmp10 = icmp sgt i32 %22, %23
  br i1 %cmp10, label %if.then12, label %if.end

if.then12:                                        ; preds = %lor.lhs.false, %for.body
  br label %for.inc

if.end:                                           ; preds = %lor.lhs.false
  %24 = load ptr, ptr %r, align 8
  %element13 = getelementptr inbounds %struct.redisReply, ptr %24, i32 0, i32 7
  %25 = load ptr, ptr %element13, align 8
  %arrayidx14 = getelementptr inbounds ptr, ptr %25, i64 2
  %26 = load ptr, ptr %arrayidx14, align 8
  store ptr %26, ptr %nr, align 8
  store ptr null, ptr %name, align 8
  %27 = load ptr, ptr %nr, align 8
  %elements15 = getelementptr inbounds %struct.redisReply, ptr %27, i32 0, i32 6
  %28 = load i64, ptr %elements15, align 8
  %cmp16 = icmp uge i64 %28, 3
  br i1 %cmp16, label %if.then18, label %if.end21

if.then18:                                        ; preds = %if.end
  %29 = load ptr, ptr %nr, align 8
  %element19 = getelementptr inbounds %struct.redisReply, ptr %29, i32 0, i32 7
  %30 = load ptr, ptr %element19, align 8
  %arrayidx20 = getelementptr inbounds ptr, ptr %30, i64 2
  %31 = load ptr, ptr %arrayidx20, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %31, i32 0, i32 4
  %32 = load ptr, ptr %str, align 8
  store ptr %32, ptr %name, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.then18, %if.end
  %33 = load ptr, ptr %name, align 8
  %cmp22 = icmp ne ptr %33, null
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %if.end21
  %34 = load ptr, ptr %name, align 8
  %call25 = call ptr @clusterManagerNodeByName(ptr noundef %34)
  store ptr %call25, ptr %owner, align 8
  br label %if.end45

if.else:                                          ; preds = %if.end21
  %35 = load ptr, ptr %nr, align 8
  %element26 = getelementptr inbounds %struct.redisReply, ptr %35, i32 0, i32 7
  %36 = load ptr, ptr %element26, align 8
  %arrayidx27 = getelementptr inbounds ptr, ptr %36, i64 0
  %37 = load ptr, ptr %arrayidx27, align 8
  %str28 = getelementptr inbounds %struct.redisReply, ptr %37, i32 0, i32 4
  %38 = load ptr, ptr %str28, align 8
  store ptr %38, ptr %ip, align 8
  %39 = load ptr, ptr %nr, align 8
  %element29 = getelementptr inbounds %struct.redisReply, ptr %39, i32 0, i32 7
  %40 = load ptr, ptr %element29, align 8
  %arrayidx30 = getelementptr inbounds ptr, ptr %40, i64 1
  %41 = load ptr, ptr %arrayidx30, align 8
  %integer31 = getelementptr inbounds %struct.redisReply, ptr %41, i32 0, i32 1
  %42 = load i64, ptr %integer31, align 8
  %conv32 = trunc i64 %42 to i32
  store i32 %conv32, ptr %port, align 4
  %43 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %43, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end44, %if.else
  %call33 = call ptr @listNext(ptr noundef %li)
  store ptr %call33, ptr %ln, align 8
  %cmp34 = icmp ne ptr %call33, null
  br i1 %cmp34, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %44 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %44, i32 0, i32 2
  %45 = load ptr, ptr %value, align 8
  store ptr %45, ptr %nd, align 8
  %46 = load ptr, ptr %nd, align 8
  %ip36 = getelementptr inbounds %struct.clusterManagerNode, ptr %46, i32 0, i32 2
  %47 = load ptr, ptr %ip36, align 8
  %48 = load ptr, ptr %ip, align 8
  %call37 = call i32 @strcmp(ptr noundef %47, ptr noundef %48) #12
  %cmp38 = icmp eq i32 %call37, 0
  br i1 %cmp38, label %land.lhs.true, label %if.end44

land.lhs.true:                                    ; preds = %while.body
  %49 = load i32, ptr %port, align 4
  %50 = load ptr, ptr %nd, align 8
  %port40 = getelementptr inbounds %struct.clusterManagerNode, ptr %50, i32 0, i32 3
  %51 = load i32, ptr %port40, align 8
  %cmp41 = icmp eq i32 %49, %51
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %land.lhs.true
  %52 = load ptr, ptr %nd, align 8
  store ptr %52, ptr %owner, align 8
  br label %while.end

if.end44:                                         ; preds = %land.lhs.true, %while.body
  br label %while.cond, !llvm.loop !193

while.end:                                        ; preds = %if.then43, %while.cond
  br label %if.end45

if.end45:                                         ; preds = %while.end, %if.then24
  %53 = load ptr, ptr %owner, align 8
  %tobool46 = icmp ne ptr %53, null
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end45
  br label %for.end

if.end48:                                         ; preds = %if.end45
  br label %for.inc

for.inc:                                          ; preds = %if.end48, %if.then12
  %54 = load i64, ptr %i, align 8
  %inc = add i64 %54, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !194

for.end:                                          ; preds = %if.then47, %for.cond
  br label %if.end49

if.end49:                                         ; preds = %for.end, %entry
  %55 = load ptr, ptr %reply, align 8
  %tobool50 = icmp ne ptr %55, null
  br i1 %tobool50, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end49
  %56 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %56)
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %if.end49
  %57 = load ptr, ptr %owner, align 8
  ret ptr %57
}

declare noalias ptr @zstrdup(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerMigrateKeysInSlot(ptr noundef %source, ptr noundef %target, i32 noundef %slot, i32 noundef %timeout, i32 noundef %pipeline, i32 noundef %verbose, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %source.addr = alloca ptr, align 8
  %target.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %timeout.addr = alloca i32, align 4
  %pipeline.addr = alloca i32, align 4
  %verbose.addr = alloca i32, align 4
  %err.addr = alloca ptr, align 8
  %success = alloca i32, align 4
  %do_fix = alloca i32, align 4
  %do_replace = alloca i32, align 4
  %dots = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %migrate_reply = alloca ptr, align 8
  %count = alloca i64, align 8
  %is_busy = alloca i32, align 4
  %not_served = alloca i32, align 4
  %get_owner_err = alloca ptr, align 8
  %served_by = alloca ptr, align 8
  %diffs = alloca ptr, align 8
  %dli = alloca %struct.listIter, align 8
  %dln = alloca ptr, align 8
  %k = alloca ptr, align 8
  store ptr %source, ptr %source.addr, align 8
  store ptr %target, ptr %target.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  store i32 %timeout, ptr %timeout.addr, align 4
  store i32 %pipeline, ptr %pipeline.addr, align 4
  store i32 %verbose, ptr %verbose.addr, align 4
  store ptr %err, ptr %err.addr, align 8
  store i32 1, ptr %success, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and = and i32 %0, 1
  store i32 %and, ptr %do_fix, align 4
  %1 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 4), align 8
  %and1 = and i32 %1, 64
  store i32 %and1, ptr %do_replace, align 4
  br label %while.body

while.body:                                       ; preds = %if.end135, %entry
  store ptr null, ptr %dots, align 8
  store ptr null, ptr %reply, align 8
  store ptr null, ptr %migrate_reply, align 8
  %2 = load ptr, ptr %source.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %context, align 8
  %4 = load i32, ptr %slot.addr, align 4
  %5 = load i32, ptr %pipeline.addr, align 4
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %3, ptr noundef @.str.278, i32 noundef %4, i32 noundef %5)
  store ptr %call, ptr %reply, align 8
  %6 = load ptr, ptr %reply, align 8
  %cmp = icmp ne ptr %6, null
  %conv = zext i1 %cmp to i32
  store i32 %conv, ptr %success, align 4
  %7 = load i32, ptr %success, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %while.body
  %8 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type, align 8
  %cmp2 = icmp eq i32 %9, 6
  br i1 %cmp2, label %if.then4, label %if.end13

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %success, align 4
  %10 = load ptr, ptr %err.addr, align 8
  %cmp5 = icmp ne ptr %10, null
  br i1 %cmp5, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.then4
  %11 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %len, align 8
  %add = add i64 %12, 1
  %mul = mul i64 %add, 1
  %call8 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  %13 = load ptr, ptr %err.addr, align 8
  store ptr %call8, ptr %13, align 8
  %14 = load ptr, ptr %err.addr, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 4
  %17 = load ptr, ptr %str, align 8
  %18 = load ptr, ptr %reply, align 8
  %len9 = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 3
  %19 = load i64, ptr %len9, align 8
  %add10 = add i64 %19, 1
  %call11 = call i64 @redis_strlcpy(ptr noundef %15, ptr noundef %17, i64 noundef %add10)
  %20 = load ptr, ptr %source.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %ip, align 8
  %22 = load ptr, ptr %source.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %22, i32 0, i32 3
  %23 = load i32, ptr %port, align 8
  %24 = load ptr, ptr %err.addr, align 8
  %25 = load ptr, ptr %24, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %21, i32 noundef %23, ptr noundef %25)
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %if.then4
  br label %next

if.end13:                                         ; preds = %if.end
  %26 = load ptr, ptr %reply, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %26, i32 0, i32 6
  %27 = load i64, ptr %elements, align 8
  store i64 %27, ptr %count, align 8
  %28 = load i64, ptr %count, align 8
  %cmp14 = icmp eq i64 %28, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  %29 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %29)
  br label %while.end136

if.end17:                                         ; preds = %if.end13
  %30 = load i32, ptr %verbose.addr, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %if.then19, label %if.end23

if.then19:                                        ; preds = %if.end17
  %31 = load i64, ptr %count, align 8
  %add20 = add i64 %31, 1
  %mul21 = mul i64 %add20, 1
  %call22 = call noalias ptr @zmalloc(i64 noundef %mul21) #14
  store ptr %call22, ptr %dots, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then19, %if.end17
  %32 = load ptr, ptr %source.addr, align 8
  %33 = load ptr, ptr %target.addr, align 8
  %34 = load ptr, ptr %reply, align 8
  %35 = load i32, ptr %timeout.addr, align 4
  %36 = load ptr, ptr %dots, align 8
  %call24 = call ptr @clusterManagerMigrateKeysInReply(ptr noundef %32, ptr noundef %33, ptr noundef %34, i32 noundef 0, i32 noundef %35, ptr noundef %36)
  store ptr %call24, ptr %migrate_reply, align 8
  %37 = load ptr, ptr %migrate_reply, align 8
  %cmp25 = icmp eq ptr %37, null
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end23
  br label %next

if.end28:                                         ; preds = %if.end23
  %38 = load ptr, ptr %migrate_reply, align 8
  %type29 = getelementptr inbounds %struct.redisReply, ptr %38, i32 0, i32 0
  %39 = load i32, ptr %type29, align 8
  %cmp30 = icmp eq i32 %39, 6
  br i1 %cmp30, label %if.then32, label %if.end116

if.then32:                                        ; preds = %if.end28
  %40 = load ptr, ptr %migrate_reply, align 8
  %str33 = getelementptr inbounds %struct.redisReply, ptr %40, i32 0, i32 4
  %41 = load ptr, ptr %str33, align 8
  %call34 = call ptr @strstr(ptr noundef %41, ptr noundef @.str.294) #12
  %cmp35 = icmp ne ptr %call34, null
  %conv36 = zext i1 %cmp35 to i32
  store i32 %conv36, ptr %is_busy, align 4
  store i32 0, ptr %not_served, align 4
  %42 = load i32, ptr %is_busy, align 4
  %tobool37 = icmp ne i32 %42, 0
  br i1 %tobool37, label %if.end49, label %if.then38

if.then38:                                        ; preds = %if.then32
  store ptr null, ptr %get_owner_err, align 8
  %43 = load ptr, ptr %source.addr, align 8
  %44 = load i32, ptr %slot.addr, align 4
  %call39 = call ptr @clusterManagerGetSlotOwner(ptr noundef %43, i32 noundef %44, ptr noundef %get_owner_err)
  store ptr %call39, ptr %served_by, align 8
  %45 = load ptr, ptr %served_by, align 8
  %tobool40 = icmp ne ptr %45, null
  br i1 %tobool40, label %if.end48, label %if.then41

if.then41:                                        ; preds = %if.then38
  %46 = load ptr, ptr %get_owner_err, align 8
  %cmp42 = icmp eq ptr %46, null
  br i1 %cmp42, label %if.then44, label %if.else

if.then44:                                        ; preds = %if.then41
  store i32 1, ptr %not_served, align 4
  br label %if.end47

if.else:                                          ; preds = %if.then41
  %47 = load ptr, ptr %source.addr, align 8
  %ip45 = getelementptr inbounds %struct.clusterManagerNode, ptr %47, i32 0, i32 2
  %48 = load ptr, ptr %ip45, align 8
  %49 = load ptr, ptr %source.addr, align 8
  %port46 = getelementptr inbounds %struct.clusterManagerNode, ptr %49, i32 0, i32 3
  %50 = load i32, ptr %port46, align 8
  %51 = load ptr, ptr %get_owner_err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %48, i32 noundef %50, ptr noundef %51)
  %52 = load ptr, ptr %get_owner_err, align 8
  call void @zfree(ptr noundef %52)
  br label %if.end47

if.end47:                                         ; preds = %if.else, %if.then44
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then38
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.then32
  %53 = load i32, ptr %is_busy, align 4
  %tobool50 = icmp ne i32 %53, 0
  br i1 %tobool50, label %if.then52, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end49
  %54 = load i32, ptr %not_served, align 4
  %tobool51 = icmp ne i32 %54, 0
  br i1 %tobool51, label %if.then52, label %if.else92

if.then52:                                        ; preds = %lor.lhs.false, %if.end49
  %55 = load i32, ptr %do_fix, align 4
  %tobool53 = icmp ne i32 %55, 0
  br i1 %tobool53, label %land.lhs.true, label %if.end59

land.lhs.true:                                    ; preds = %if.then52
  %56 = load i32, ptr %not_served, align 4
  %tobool54 = icmp ne i32 %56, 0
  br i1 %tobool54, label %if.then55, label %if.end59

if.then55:                                        ; preds = %land.lhs.true
  %57 = load ptr, ptr %target.addr, align 8
  %ip56 = getelementptr inbounds %struct.clusterManagerNode, ptr %57, i32 0, i32 2
  %58 = load ptr, ptr %ip56, align 8
  %59 = load ptr, ptr %target.addr, align 8
  %port57 = getelementptr inbounds %struct.clusterManagerNode, ptr %59, i32 0, i32 3
  %60 = load i32, ptr %port57, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.295, ptr noundef %58, i32 noundef %60)
  %61 = load ptr, ptr %source.addr, align 8
  %62 = load ptr, ptr %target.addr, align 8
  %63 = load i32, ptr %slot.addr, align 4
  %call58 = call i32 @clusterManagerSetSlot(ptr noundef %61, ptr noundef %62, i32 noundef %63, ptr noundef @.str.270, ptr noundef null)
  br label %if.end59

if.end59:                                         ; preds = %if.then55, %land.lhs.true, %if.then52
  %64 = load i32, ptr %is_busy, align 4
  %tobool60 = icmp ne i32 %64, 0
  br i1 %tobool60, label %if.then61, label %if.end85

if.then61:                                        ; preds = %if.end59
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.296)
  %65 = load i32, ptr %do_replace, align 4
  %tobool62 = icmp ne i32 %65, 0
  br i1 %tobool62, label %if.end84, label %if.then63

if.then63:                                        ; preds = %if.then61
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.297)
  %call64 = call ptr @listCreate()
  store ptr %call64, ptr %diffs, align 8
  %66 = load ptr, ptr %source.addr, align 8
  %67 = load ptr, ptr %target.addr, align 8
  %68 = load ptr, ptr %reply, align 8
  %69 = load ptr, ptr %diffs, align 8
  %call65 = call i32 @clusterManagerCompareKeysValues(ptr noundef %66, ptr noundef %67, ptr noundef %68, ptr noundef %69)
  store i32 %call65, ptr %success, align 4
  %70 = load i32, ptr %success, align 4
  %tobool66 = icmp ne i32 %70, 0
  br i1 %tobool66, label %if.end68, label %if.then67

if.then67:                                        ; preds = %if.then63
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.298)
  %71 = load ptr, ptr %diffs, align 8
  call void @listRelease(ptr noundef %71)
  br label %next

if.end68:                                         ; preds = %if.then63
  %72 = load ptr, ptr %diffs, align 8
  %len69 = getelementptr inbounds %struct.list, ptr %72, i32 0, i32 5
  %73 = load i64, ptr %len69, align 8
  %cmp70 = icmp ugt i64 %73, 0
  br i1 %cmp70, label %if.then72, label %if.end83

if.then72:                                        ; preds = %if.end68
  store i32 0, ptr %success, align 4
  %74 = load ptr, ptr %diffs, align 8
  %len73 = getelementptr inbounds %struct.list, ptr %74, i32 0, i32 5
  %75 = load i64, ptr %len73, align 8
  %76 = load ptr, ptr %source.addr, align 8
  %ip74 = getelementptr inbounds %struct.clusterManagerNode, ptr %76, i32 0, i32 2
  %77 = load ptr, ptr %ip74, align 8
  %78 = load ptr, ptr %source.addr, align 8
  %port75 = getelementptr inbounds %struct.clusterManagerNode, ptr %78, i32 0, i32 3
  %79 = load i32, ptr %port75, align 8
  %80 = load ptr, ptr %target.addr, align 8
  %ip76 = getelementptr inbounds %struct.clusterManagerNode, ptr %80, i32 0, i32 2
  %81 = load ptr, ptr %ip76, align 8
  %82 = load ptr, ptr %target.addr, align 8
  %port77 = getelementptr inbounds %struct.clusterManagerNode, ptr %82, i32 0, i32 3
  %83 = load i32, ptr %port77, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.299, i64 noundef %75, ptr noundef %77, i32 noundef %79, ptr noundef %81, i32 noundef %83)
  %84 = load ptr, ptr %diffs, align 8
  call void @listRewind(ptr noundef %84, ptr noundef %dli)
  br label %while.cond78

while.cond78:                                     ; preds = %while.body82, %if.then72
  %call79 = call ptr @listNext(ptr noundef %dli)
  store ptr %call79, ptr %dln, align 8
  %cmp80 = icmp ne ptr %call79, null
  br i1 %cmp80, label %while.body82, label %while.end

while.body82:                                     ; preds = %while.cond78
  %85 = load ptr, ptr %dln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %85, i32 0, i32 2
  %86 = load ptr, ptr %value, align 8
  store ptr %86, ptr %k, align 8
  %87 = load ptr, ptr %k, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.300, ptr noundef %87)
  br label %while.cond78, !llvm.loop !195

while.end:                                        ; preds = %while.cond78
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.301)
  %88 = load ptr, ptr %diffs, align 8
  call void @listRelease(ptr noundef %88)
  br label %next

if.end83:                                         ; preds = %if.end68
  %89 = load ptr, ptr %diffs, align 8
  call void @listRelease(ptr noundef %89)
  br label %if.end84

if.end84:                                         ; preds = %if.end83, %if.then61
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 2, ptr noundef @.str.302)
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %if.end59
  %90 = load ptr, ptr %migrate_reply, align 8
  call void @freeReplyObject(ptr noundef %90)
  %91 = load ptr, ptr %source.addr, align 8
  %92 = load ptr, ptr %target.addr, align 8
  %93 = load ptr, ptr %reply, align 8
  %94 = load i32, ptr %is_busy, align 4
  %95 = load i32, ptr %timeout.addr, align 4
  %call86 = call ptr @clusterManagerMigrateKeysInReply(ptr noundef %91, ptr noundef %92, ptr noundef %93, i32 noundef %94, i32 noundef %95, ptr noundef null)
  store ptr %call86, ptr %migrate_reply, align 8
  %96 = load ptr, ptr %migrate_reply, align 8
  %cmp87 = icmp ne ptr %96, null
  br i1 %cmp87, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end85
  %97 = load ptr, ptr %migrate_reply, align 8
  %type89 = getelementptr inbounds %struct.redisReply, ptr %97, i32 0, i32 0
  %98 = load i32, ptr %type89, align 8
  %cmp90 = icmp ne i32 %98, 6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end85
  %99 = phi i1 [ false, %if.end85 ], [ %cmp90, %land.rhs ]
  %land.ext = zext i1 %99 to i32
  store i32 %land.ext, ptr %success, align 4
  br label %if.end93

if.else92:                                        ; preds = %lor.lhs.false
  store i32 0, ptr %success, align 4
  br label %if.end93

if.end93:                                         ; preds = %if.else92, %land.end
  %100 = load i32, ptr %success, align 4
  %tobool94 = icmp ne i32 %100, 0
  br i1 %tobool94, label %if.end115, label %if.then95

if.then95:                                        ; preds = %if.end93
  %101 = load ptr, ptr %migrate_reply, align 8
  %cmp96 = icmp ne ptr %101, null
  br i1 %cmp96, label %if.then98, label %if.end114

if.then98:                                        ; preds = %if.then95
  %102 = load ptr, ptr %err.addr, align 8
  %tobool99 = icmp ne ptr %102, null
  br i1 %tobool99, label %if.then100, label %if.end109

if.then100:                                       ; preds = %if.then98
  %103 = load ptr, ptr %migrate_reply, align 8
  %len101 = getelementptr inbounds %struct.redisReply, ptr %103, i32 0, i32 3
  %104 = load i64, ptr %len101, align 8
  %add102 = add i64 %104, 1
  %mul103 = mul i64 %add102, 1
  %call104 = call noalias ptr @zmalloc(i64 noundef %mul103) #14
  %105 = load ptr, ptr %err.addr, align 8
  store ptr %call104, ptr %105, align 8
  %106 = load ptr, ptr %err.addr, align 8
  %107 = load ptr, ptr %106, align 8
  %108 = load ptr, ptr %migrate_reply, align 8
  %str105 = getelementptr inbounds %struct.redisReply, ptr %108, i32 0, i32 4
  %109 = load ptr, ptr %str105, align 8
  %110 = load ptr, ptr %migrate_reply, align 8
  %len106 = getelementptr inbounds %struct.redisReply, ptr %110, i32 0, i32 3
  %111 = load i64, ptr %len106, align 8
  %add107 = add i64 %111, 1
  %call108 = call i64 @redis_strlcpy(ptr noundef %107, ptr noundef %109, i64 noundef %add107)
  br label %if.end109

if.end109:                                        ; preds = %if.then100, %if.then98
  %call110 = call i32 (ptr, ...) @printf(ptr noundef @.str.116)
  %112 = load ptr, ptr %source.addr, align 8
  %ip111 = getelementptr inbounds %struct.clusterManagerNode, ptr %112, i32 0, i32 2
  %113 = load ptr, ptr %ip111, align 8
  %114 = load ptr, ptr %source.addr, align 8
  %port112 = getelementptr inbounds %struct.clusterManagerNode, ptr %114, i32 0, i32 3
  %115 = load i32, ptr %port112, align 8
  %116 = load ptr, ptr %migrate_reply, align 8
  %str113 = getelementptr inbounds %struct.redisReply, ptr %116, i32 0, i32 4
  %117 = load ptr, ptr %str113, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %113, i32 noundef %115, ptr noundef %117)
  br label %if.end114

if.end114:                                        ; preds = %if.end109, %if.then95
  br label %next

if.end115:                                        ; preds = %if.end93
  br label %if.end116

if.end116:                                        ; preds = %if.end115, %if.end28
  %118 = load i32, ptr %verbose.addr, align 4
  %tobool117 = icmp ne i32 %118, 0
  br i1 %tobool117, label %if.then118, label %if.end121

if.then118:                                       ; preds = %if.end116
  %119 = load ptr, ptr %dots, align 8
  %call119 = call i32 (ptr, ...) @printf(ptr noundef @.str.237, ptr noundef %119)
  %120 = load ptr, ptr @stdout, align 8
  %call120 = call i32 @fflush(ptr noundef %120)
  br label %if.end121

if.end121:                                        ; preds = %if.then118, %if.end116
  br label %next

next:                                             ; preds = %if.end121, %if.end114, %while.end, %if.then67, %if.then27, %if.end12
  %121 = load ptr, ptr %reply, align 8
  %cmp122 = icmp ne ptr %121, null
  br i1 %cmp122, label %if.then124, label %if.end125

if.then124:                                       ; preds = %next
  %122 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %122)
  br label %if.end125

if.end125:                                        ; preds = %if.then124, %next
  %123 = load ptr, ptr %migrate_reply, align 8
  %cmp126 = icmp ne ptr %123, null
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %if.end125
  %124 = load ptr, ptr %migrate_reply, align 8
  call void @freeReplyObject(ptr noundef %124)
  br label %if.end129

if.end129:                                        ; preds = %if.then128, %if.end125
  %125 = load ptr, ptr %dots, align 8
  %tobool130 = icmp ne ptr %125, null
  br i1 %tobool130, label %if.then131, label %if.end132

if.then131:                                       ; preds = %if.end129
  %126 = load ptr, ptr %dots, align 8
  call void @zfree(ptr noundef %126)
  br label %if.end132

if.end132:                                        ; preds = %if.then131, %if.end129
  %127 = load i32, ptr %success, align 4
  %tobool133 = icmp ne i32 %127, 0
  br i1 %tobool133, label %if.end135, label %if.then134

if.then134:                                       ; preds = %if.end132
  br label %while.end136

if.end135:                                        ; preds = %if.end132
  br label %while.body

while.end136:                                     ; preds = %if.then134, %if.then16
  %128 = load i32, ptr %success, align 4
  store i32 %128, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end136, %if.then
  %129 = load i32, ptr %retval, align 4
  ret i32 %129
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerMigrateKeysInReply(ptr noundef %source, ptr noundef %target, ptr noundef %reply, i32 noundef %replace, i32 noundef %timeout, ptr noundef %dots) #0 {
entry:
  %source.addr = alloca ptr, align 8
  %target.addr = alloca ptr, align 8
  %reply.addr = alloca ptr, align 8
  %replace.addr = alloca i32, align 4
  %timeout.addr = alloca i32, align 4
  %dots.addr = alloca ptr, align 8
  %migrate_reply = alloca ptr, align 8
  %argv = alloca ptr, align 8
  %argv_len = alloca ptr, align 8
  %c = alloca i32, align 4
  %argc = alloca i64, align 8
  %i = alloca i64, align 8
  %offset = alloca i64, align 8
  %portstr = alloca [255 x i8], align 16
  %timeoutstr = alloca [255 x i8], align 16
  %entry65 = alloca ptr, align 8
  %idx = alloca i64, align 8
  %_reply = alloca ptr, align 8
  %success = alloca i32, align 4
  store ptr %source, ptr %source.addr, align 8
  store ptr %target, ptr %target.addr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store i32 %replace, ptr %replace.addr, align 4
  store i32 %timeout, ptr %timeout.addr, align 4
  store ptr %dots, ptr %dots.addr, align 8
  store ptr null, ptr %migrate_reply, align 8
  store ptr null, ptr %argv, align 8
  store ptr null, ptr %argv_len, align 8
  %0 = load i32, ptr %replace.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i32 8, i32 7
  store i32 %cond, ptr %c, align 4
  %1 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %c, align 4
  %add = add nsw i32 %2, 2
  store i32 %add, ptr %c, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %4 = load i32, ptr %c, align 4
  %add4 = add nsw i32 %4, 1
  store i32 %add4, ptr %c, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %5 = load i32, ptr %c, align 4
  %conv = sext i32 %5 to i64
  %6 = load ptr, ptr %reply.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %elements, align 8
  %add6 = add i64 %conv, %7
  store i64 %add6, ptr %argc, align 8
  store i64 6, ptr %offset, align 8
  %8 = load i64, ptr %argc, align 8
  %mul = mul i64 %8, 8
  %call = call noalias ptr @zcalloc(i64 noundef %mul) #14
  store ptr %call, ptr %argv, align 8
  %9 = load i64, ptr %argc, align 8
  %mul7 = mul i64 %9, 8
  %call8 = call noalias ptr @zcalloc(i64 noundef %mul7) #14
  store ptr %call8, ptr %argv_len, align 8
  %arraydecay = getelementptr inbounds [255 x i8], ptr %portstr, i64 0, i64 0
  %10 = load ptr, ptr %target.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %10, i32 0, i32 3
  %11 = load i32, ptr %port, align 8
  %call9 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 10, ptr noundef @.str.303, i32 noundef %11) #15
  %arraydecay10 = getelementptr inbounds [255 x i8], ptr %timeoutstr, i64 0, i64 0
  %12 = load i32, ptr %timeout.addr, align 4
  %call11 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay10, i64 noundef 10, ptr noundef @.str.303, i32 noundef %12) #15
  %13 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %13, i64 0
  store ptr @.str.304, ptr %arrayidx, align 8
  %14 = load ptr, ptr %argv_len, align 8
  %arrayidx12 = getelementptr inbounds i64, ptr %14, i64 0
  store i64 7, ptr %arrayidx12, align 8
  %15 = load ptr, ptr %target.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %ip, align 8
  %17 = load ptr, ptr %argv, align 8
  %arrayidx13 = getelementptr inbounds ptr, ptr %17, i64 1
  store ptr %16, ptr %arrayidx13, align 8
  %18 = load ptr, ptr %target.addr, align 8
  %ip14 = getelementptr inbounds %struct.clusterManagerNode, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %ip14, align 8
  %call15 = call i64 @strlen(ptr noundef %19) #12
  %20 = load ptr, ptr %argv_len, align 8
  %arrayidx16 = getelementptr inbounds i64, ptr %20, i64 1
  store i64 %call15, ptr %arrayidx16, align 8
  %arraydecay17 = getelementptr inbounds [255 x i8], ptr %portstr, i64 0, i64 0
  %21 = load ptr, ptr %argv, align 8
  %arrayidx18 = getelementptr inbounds ptr, ptr %21, i64 2
  store ptr %arraydecay17, ptr %arrayidx18, align 8
  %arraydecay19 = getelementptr inbounds [255 x i8], ptr %portstr, i64 0, i64 0
  %call20 = call i64 @strlen(ptr noundef %arraydecay19) #12
  %22 = load ptr, ptr %argv_len, align 8
  %arrayidx21 = getelementptr inbounds i64, ptr %22, i64 2
  store i64 %call20, ptr %arrayidx21, align 8
  %23 = load ptr, ptr %argv, align 8
  %arrayidx22 = getelementptr inbounds ptr, ptr %23, i64 3
  store ptr @.str.26, ptr %arrayidx22, align 8
  %24 = load ptr, ptr %argv_len, align 8
  %arrayidx23 = getelementptr inbounds i64, ptr %24, i64 3
  store i64 0, ptr %arrayidx23, align 8
  %25 = load ptr, ptr %argv, align 8
  %arrayidx24 = getelementptr inbounds ptr, ptr %25, i64 4
  store ptr @.str.305, ptr %arrayidx24, align 8
  %26 = load ptr, ptr %argv_len, align 8
  %arrayidx25 = getelementptr inbounds i64, ptr %26, i64 4
  store i64 1, ptr %arrayidx25, align 8
  %arraydecay26 = getelementptr inbounds [255 x i8], ptr %timeoutstr, i64 0, i64 0
  %27 = load ptr, ptr %argv, align 8
  %arrayidx27 = getelementptr inbounds ptr, ptr %27, i64 5
  store ptr %arraydecay26, ptr %arrayidx27, align 8
  %arraydecay28 = getelementptr inbounds [255 x i8], ptr %timeoutstr, i64 0, i64 0
  %call29 = call i64 @strlen(ptr noundef %arraydecay28) #12
  %28 = load ptr, ptr %argv_len, align 8
  %arrayidx30 = getelementptr inbounds i64, ptr %28, i64 5
  store i64 %call29, ptr %arrayidx30, align 8
  %29 = load i32, ptr %replace.addr, align 4
  %tobool31 = icmp ne i32 %29, 0
  br i1 %tobool31, label %if.then32, label %if.end35

if.then32:                                        ; preds = %if.end5
  %30 = load ptr, ptr %argv, align 8
  %31 = load i64, ptr %offset, align 8
  %arrayidx33 = getelementptr inbounds ptr, ptr %30, i64 %31
  store ptr @.str.306, ptr %arrayidx33, align 8
  %32 = load ptr, ptr %argv_len, align 8
  %33 = load i64, ptr %offset, align 8
  %arrayidx34 = getelementptr inbounds i64, ptr %32, i64 %33
  store i64 7, ptr %arrayidx34, align 8
  %34 = load i64, ptr %offset, align 8
  %inc = add i64 %34, 1
  store i64 %inc, ptr %offset, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.then32, %if.end5
  %35 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %tobool36 = icmp ne ptr %35, null
  br i1 %tobool36, label %if.then37, label %if.end59

if.then37:                                        ; preds = %if.end35
  %36 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %tobool38 = icmp ne ptr %36, null
  br i1 %tobool38, label %if.then39, label %if.else

if.then39:                                        ; preds = %if.then37
  %37 = load ptr, ptr %argv, align 8
  %38 = load i64, ptr %offset, align 8
  %arrayidx40 = getelementptr inbounds ptr, ptr %37, i64 %38
  store ptr @.str.307, ptr %arrayidx40, align 8
  %39 = load ptr, ptr %argv_len, align 8
  %40 = load i64, ptr %offset, align 8
  %arrayidx41 = getelementptr inbounds i64, ptr %39, i64 %40
  store i64 5, ptr %arrayidx41, align 8
  %41 = load i64, ptr %offset, align 8
  %inc42 = add i64 %41, 1
  store i64 %inc42, ptr %offset, align 8
  %42 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %43 = load ptr, ptr %argv, align 8
  %44 = load i64, ptr %offset, align 8
  %arrayidx43 = getelementptr inbounds ptr, ptr %43, i64 %44
  store ptr %42, ptr %arrayidx43, align 8
  %45 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 4), align 8
  %call44 = call i64 @strlen(ptr noundef %45) #12
  %46 = load ptr, ptr %argv_len, align 8
  %47 = load i64, ptr %offset, align 8
  %arrayidx45 = getelementptr inbounds i64, ptr %46, i64 %47
  store i64 %call44, ptr %arrayidx45, align 8
  %48 = load i64, ptr %offset, align 8
  %inc46 = add i64 %48, 1
  store i64 %inc46, ptr %offset, align 8
  %49 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %50 = load ptr, ptr %argv, align 8
  %51 = load i64, ptr %offset, align 8
  %arrayidx47 = getelementptr inbounds ptr, ptr %50, i64 %51
  store ptr %49, ptr %arrayidx47, align 8
  %52 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %call48 = call i64 @strlen(ptr noundef %52) #12
  %53 = load ptr, ptr %argv_len, align 8
  %54 = load i64, ptr %offset, align 8
  %arrayidx49 = getelementptr inbounds i64, ptr %53, i64 %54
  store i64 %call48, ptr %arrayidx49, align 8
  %55 = load i64, ptr %offset, align 8
  %inc50 = add i64 %55, 1
  store i64 %inc50, ptr %offset, align 8
  br label %if.end58

if.else:                                          ; preds = %if.then37
  %56 = load ptr, ptr %argv, align 8
  %57 = load i64, ptr %offset, align 8
  %arrayidx51 = getelementptr inbounds ptr, ptr %56, i64 %57
  store ptr @.str.308, ptr %arrayidx51, align 8
  %58 = load ptr, ptr %argv_len, align 8
  %59 = load i64, ptr %offset, align 8
  %arrayidx52 = getelementptr inbounds i64, ptr %58, i64 %59
  store i64 4, ptr %arrayidx52, align 8
  %60 = load i64, ptr %offset, align 8
  %inc53 = add i64 %60, 1
  store i64 %inc53, ptr %offset, align 8
  %61 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %62 = load ptr, ptr %argv, align 8
  %63 = load i64, ptr %offset, align 8
  %arrayidx54 = getelementptr inbounds ptr, ptr %62, i64 %63
  store ptr %61, ptr %arrayidx54, align 8
  %64 = load ptr, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 3), align 8
  %call55 = call i64 @strlen(ptr noundef %64) #12
  %65 = load ptr, ptr %argv_len, align 8
  %66 = load i64, ptr %offset, align 8
  %arrayidx56 = getelementptr inbounds i64, ptr %65, i64 %66
  store i64 %call55, ptr %arrayidx56, align 8
  %67 = load i64, ptr %offset, align 8
  %inc57 = add i64 %67, 1
  store i64 %inc57, ptr %offset, align 8
  br label %if.end58

if.end58:                                         ; preds = %if.else, %if.then39
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.end35
  %68 = load ptr, ptr %argv, align 8
  %69 = load i64, ptr %offset, align 8
  %arrayidx60 = getelementptr inbounds ptr, ptr %68, i64 %69
  store ptr @.str.309, ptr %arrayidx60, align 8
  %70 = load ptr, ptr %argv_len, align 8
  %71 = load i64, ptr %offset, align 8
  %arrayidx61 = getelementptr inbounds i64, ptr %70, i64 %71
  store i64 4, ptr %arrayidx61, align 8
  %72 = load i64, ptr %offset, align 8
  %inc62 = add i64 %72, 1
  store i64 %inc62, ptr %offset, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end59
  %73 = load i64, ptr %i, align 8
  %74 = load ptr, ptr %reply.addr, align 8
  %elements63 = getelementptr inbounds %struct.redisReply, ptr %74, i32 0, i32 6
  %75 = load i64, ptr %elements63, align 8
  %cmp = icmp ult i64 %73, %75
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %76 = load ptr, ptr %reply.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %76, i32 0, i32 7
  %77 = load ptr, ptr %element, align 8
  %78 = load i64, ptr %i, align 8
  %arrayidx66 = getelementptr inbounds ptr, ptr %77, i64 %78
  %79 = load ptr, ptr %arrayidx66, align 8
  store ptr %79, ptr %entry65, align 8
  %80 = load i64, ptr %i, align 8
  %81 = load i64, ptr %offset, align 8
  %add67 = add i64 %80, %81
  store i64 %add67, ptr %idx, align 8
  %82 = load ptr, ptr %entry65, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %82, i32 0, i32 4
  %83 = load ptr, ptr %str, align 8
  %84 = load ptr, ptr %entry65, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %84, i32 0, i32 3
  %85 = load i64, ptr %len, align 8
  %call68 = call ptr @hi_sdsnewlen(ptr noundef %83, i64 noundef %85)
  %86 = load ptr, ptr %argv, align 8
  %87 = load i64, ptr %idx, align 8
  %arrayidx69 = getelementptr inbounds ptr, ptr %86, i64 %87
  store ptr %call68, ptr %arrayidx69, align 8
  %88 = load ptr, ptr %entry65, align 8
  %len70 = getelementptr inbounds %struct.redisReply, ptr %88, i32 0, i32 3
  %89 = load i64, ptr %len70, align 8
  %90 = load ptr, ptr %argv_len, align 8
  %91 = load i64, ptr %idx, align 8
  %arrayidx71 = getelementptr inbounds i64, ptr %90, i64 %91
  store i64 %89, ptr %arrayidx71, align 8
  %92 = load ptr, ptr %dots.addr, align 8
  %tobool72 = icmp ne ptr %92, null
  br i1 %tobool72, label %if.then73, label %if.end75

if.then73:                                        ; preds = %for.body
  %93 = load ptr, ptr %dots.addr, align 8
  %94 = load i64, ptr %i, align 8
  %arrayidx74 = getelementptr inbounds i8, ptr %93, i64 %94
  store i8 46, ptr %arrayidx74, align 1
  br label %if.end75

if.end75:                                         ; preds = %if.then73, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end75
  %95 = load i64, ptr %i, align 8
  %inc76 = add i64 %95, 1
  store i64 %inc76, ptr %i, align 8
  br label %for.cond, !llvm.loop !196

for.end:                                          ; preds = %for.cond
  %96 = load ptr, ptr %dots.addr, align 8
  %tobool77 = icmp ne ptr %96, null
  br i1 %tobool77, label %if.then78, label %if.end81

if.then78:                                        ; preds = %for.end
  %97 = load ptr, ptr %dots.addr, align 8
  %98 = load ptr, ptr %reply.addr, align 8
  %elements79 = getelementptr inbounds %struct.redisReply, ptr %98, i32 0, i32 6
  %99 = load i64, ptr %elements79, align 8
  %arrayidx80 = getelementptr inbounds i8, ptr %97, i64 %99
  store i8 0, ptr %arrayidx80, align 1
  br label %if.end81

if.end81:                                         ; preds = %if.then78, %for.end
  store ptr null, ptr %_reply, align 8
  %100 = load ptr, ptr %source.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %100, i32 0, i32 0
  %101 = load ptr, ptr %context, align 8
  %102 = load i64, ptr %argc, align 8
  %conv82 = trunc i64 %102 to i32
  %103 = load ptr, ptr %argv, align 8
  %104 = load ptr, ptr %argv_len, align 8
  %call83 = call i32 @redisAppendCommandArgv(ptr noundef %101, i32 noundef %conv82, ptr noundef %103, ptr noundef %104)
  %105 = load ptr, ptr %source.addr, align 8
  %context84 = getelementptr inbounds %struct.clusterManagerNode, ptr %105, i32 0, i32 0
  %106 = load ptr, ptr %context84, align 8
  %call85 = call i32 @redisGetReply(ptr noundef %106, ptr noundef %_reply)
  %cmp86 = icmp eq i32 %call85, 0
  %conv87 = zext i1 %cmp86 to i32
  store i32 %conv87, ptr %success, align 4
  store i64 0, ptr %i, align 8
  br label %for.cond88

for.cond88:                                       ; preds = %for.inc95, %if.end81
  %107 = load i64, ptr %i, align 8
  %108 = load ptr, ptr %reply.addr, align 8
  %elements89 = getelementptr inbounds %struct.redisReply, ptr %108, i32 0, i32 6
  %109 = load i64, ptr %elements89, align 8
  %cmp90 = icmp ult i64 %107, %109
  br i1 %cmp90, label %for.body92, label %for.end97

for.body92:                                       ; preds = %for.cond88
  %110 = load ptr, ptr %argv, align 8
  %111 = load i64, ptr %i, align 8
  %112 = load i64, ptr %offset, align 8
  %add93 = add i64 %111, %112
  %arrayidx94 = getelementptr inbounds ptr, ptr %110, i64 %add93
  %113 = load ptr, ptr %arrayidx94, align 8
  call void @hi_sdsfree(ptr noundef %113)
  br label %for.inc95

for.inc95:                                        ; preds = %for.body92
  %114 = load i64, ptr %i, align 8
  %inc96 = add i64 %114, 1
  store i64 %inc96, ptr %i, align 8
  br label %for.cond88, !llvm.loop !197

for.end97:                                        ; preds = %for.cond88
  %115 = load i32, ptr %success, align 4
  %tobool98 = icmp ne i32 %115, 0
  br i1 %tobool98, label %if.end100, label %if.then99

if.then99:                                        ; preds = %for.end97
  br label %cleanup

if.end100:                                        ; preds = %for.end97
  %116 = load ptr, ptr %_reply, align 8
  store ptr %116, ptr %migrate_reply, align 8
  br label %cleanup

cleanup:                                          ; preds = %if.end100, %if.then99
  %117 = load ptr, ptr %argv, align 8
  call void @zfree(ptr noundef %117)
  %118 = load ptr, ptr %argv_len, align 8
  call void @zfree(ptr noundef %118)
  %119 = load ptr, ptr %migrate_reply, align 8
  ret ptr %119
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerCompareKeysValues(ptr noundef %n1, ptr noundef %n2, ptr noundef %keys_reply, ptr noundef %diffs) #0 {
entry:
  %n1.addr = alloca ptr, align 8
  %n2.addr = alloca ptr, align 8
  %keys_reply.addr = alloca ptr, align 8
  %diffs.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %argc = alloca i64, align 8
  %argv = alloca ptr, align 8
  %argv_len = alloca ptr, align 8
  %entry7 = alloca ptr, align 8
  %idx = alloca i32, align 4
  %success = alloca i32, align 4
  %_reply1 = alloca ptr, align 8
  %_reply2 = alloca ptr, align 8
  %r1 = alloca ptr, align 8
  %r2 = alloca ptr, align 8
  %key = alloca ptr, align 8
  %hash1 = alloca ptr, align 8
  %hash2 = alloca ptr, align 8
  store ptr %n1, ptr %n1.addr, align 8
  store ptr %n2, ptr %n2.addr, align 8
  store ptr %keys_reply, ptr %keys_reply.addr, align 8
  store ptr %diffs, ptr %diffs.addr, align 8
  %0 = load ptr, ptr %keys_reply.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 6
  %1 = load i64, ptr %elements, align 8
  %add = add i64 %1, 2
  store i64 %add, ptr %argc, align 8
  %2 = load i64, ptr %argc, align 8
  %mul = mul i64 %2, 8
  %call = call noalias ptr @zcalloc(i64 noundef %mul) #14
  store ptr %call, ptr %argv, align 8
  %3 = load i64, ptr %argc, align 8
  %mul1 = mul i64 %3, 8
  %call2 = call noalias ptr @zcalloc(i64 noundef %mul1) #14
  store ptr %call2, ptr %argv_len, align 8
  %4 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 0
  store ptr @.str.311, ptr %arrayidx, align 8
  %5 = load ptr, ptr %argv_len, align 8
  %arrayidx3 = getelementptr inbounds i64, ptr %5, i64 0
  store i64 5, ptr %arrayidx3, align 8
  %6 = load ptr, ptr %argv, align 8
  %arrayidx4 = getelementptr inbounds ptr, ptr %6, i64 1
  store ptr @.str.312, ptr %arrayidx4, align 8
  %7 = load ptr, ptr %argv_len, align 8
  %arrayidx5 = getelementptr inbounds i64, ptr %7, i64 1
  store i64 12, ptr %arrayidx5, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i64, ptr %i, align 8
  %9 = load ptr, ptr %keys_reply.addr, align 8
  %elements6 = getelementptr inbounds %struct.redisReply, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %elements6, align 8
  %cmp = icmp ult i64 %8, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %keys_reply.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 7
  %12 = load ptr, ptr %element, align 8
  %13 = load i64, ptr %i, align 8
  %arrayidx8 = getelementptr inbounds ptr, ptr %12, i64 %13
  %14 = load ptr, ptr %arrayidx8, align 8
  store ptr %14, ptr %entry7, align 8
  %15 = load i64, ptr %i, align 8
  %add9 = add i64 %15, 2
  %conv = trunc i64 %add9 to i32
  store i32 %conv, ptr %idx, align 4
  %16 = load ptr, ptr %entry7, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 4
  %17 = load ptr, ptr %str, align 8
  %18 = load ptr, ptr %argv, align 8
  %19 = load i32, ptr %idx, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx10 = getelementptr inbounds ptr, ptr %18, i64 %idxprom
  store ptr %17, ptr %arrayidx10, align 8
  %20 = load ptr, ptr %entry7, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %20, i32 0, i32 3
  %21 = load i64, ptr %len, align 8
  %22 = load ptr, ptr %argv_len, align 8
  %23 = load i32, ptr %idx, align 4
  %idxprom11 = sext i32 %23 to i64
  %arrayidx12 = getelementptr inbounds i64, ptr %22, i64 %idxprom11
  store i64 %21, ptr %arrayidx12, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load i64, ptr %i, align 8
  %inc = add i64 %24, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !198

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %success, align 4
  store ptr null, ptr %_reply1, align 8
  store ptr null, ptr %_reply2, align 8
  store ptr null, ptr %r1, align 8
  store ptr null, ptr %r2, align 8
  %25 = load ptr, ptr %n1.addr, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %25, i32 0, i32 0
  %26 = load ptr, ptr %context, align 8
  %27 = load i64, ptr %argc, align 8
  %conv13 = trunc i64 %27 to i32
  %28 = load ptr, ptr %argv, align 8
  %29 = load ptr, ptr %argv_len, align 8
  %call14 = call i32 @redisAppendCommandArgv(ptr noundef %26, i32 noundef %conv13, ptr noundef %28, ptr noundef %29)
  %30 = load ptr, ptr %n1.addr, align 8
  %context15 = getelementptr inbounds %struct.clusterManagerNode, ptr %30, i32 0, i32 0
  %31 = load ptr, ptr %context15, align 8
  %call16 = call i32 @redisGetReply(ptr noundef %31, ptr noundef %_reply1)
  %cmp17 = icmp eq i32 %call16, 0
  %conv18 = zext i1 %cmp17 to i32
  store i32 %conv18, ptr %success, align 4
  %32 = load i32, ptr %success, align 4
  %tobool = icmp ne i32 %32, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.end
  br label %cleanup

if.end:                                           ; preds = %for.end
  %33 = load ptr, ptr %_reply1, align 8
  store ptr %33, ptr %r1, align 8
  %34 = load ptr, ptr %n2.addr, align 8
  %context19 = getelementptr inbounds %struct.clusterManagerNode, ptr %34, i32 0, i32 0
  %35 = load ptr, ptr %context19, align 8
  %36 = load i64, ptr %argc, align 8
  %conv20 = trunc i64 %36 to i32
  %37 = load ptr, ptr %argv, align 8
  %38 = load ptr, ptr %argv_len, align 8
  %call21 = call i32 @redisAppendCommandArgv(ptr noundef %35, i32 noundef %conv20, ptr noundef %37, ptr noundef %38)
  %39 = load ptr, ptr %n2.addr, align 8
  %context22 = getelementptr inbounds %struct.clusterManagerNode, ptr %39, i32 0, i32 0
  %40 = load ptr, ptr %context22, align 8
  %call23 = call i32 @redisGetReply(ptr noundef %40, ptr noundef %_reply2)
  %cmp24 = icmp eq i32 %call23, 0
  %conv25 = zext i1 %cmp24 to i32
  store i32 %conv25, ptr %success, align 4
  %41 = load i32, ptr %success, align 4
  %tobool26 = icmp ne i32 %41, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end
  br label %cleanup

if.end28:                                         ; preds = %if.end
  %42 = load ptr, ptr %_reply2, align 8
  store ptr %42, ptr %r2, align 8
  %43 = load ptr, ptr %r1, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %43, i32 0, i32 0
  %44 = load i32, ptr %type, align 8
  %cmp29 = icmp ne i32 %44, 6
  br i1 %cmp29, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end28
  %45 = load ptr, ptr %r2, align 8
  %type31 = getelementptr inbounds %struct.redisReply, ptr %45, i32 0, i32 0
  %46 = load i32, ptr %type31, align 8
  %cmp32 = icmp ne i32 %46, 6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end28
  %47 = phi i1 [ false, %if.end28 ], [ %cmp32, %land.rhs ]
  %land.ext = zext i1 %47 to i32
  store i32 %land.ext, ptr %success, align 4
  %48 = load ptr, ptr %r1, align 8
  %type34 = getelementptr inbounds %struct.redisReply, ptr %48, i32 0, i32 0
  %49 = load i32, ptr %type34, align 8
  %cmp35 = icmp eq i32 %49, 6
  br i1 %cmp35, label %if.then37, label %if.end39

if.then37:                                        ; preds = %land.end
  %50 = load ptr, ptr %n1.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %50, i32 0, i32 2
  %51 = load ptr, ptr %ip, align 8
  %52 = load ptr, ptr %n1.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %52, i32 0, i32 3
  %53 = load i32, ptr %port, align 8
  %54 = load ptr, ptr %r1, align 8
  %str38 = getelementptr inbounds %struct.redisReply, ptr %54, i32 0, i32 4
  %55 = load ptr, ptr %str38, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %51, i32 noundef %53, ptr noundef %55)
  store i32 0, ptr %success, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %land.end
  %56 = load ptr, ptr %r2, align 8
  %type40 = getelementptr inbounds %struct.redisReply, ptr %56, i32 0, i32 0
  %57 = load i32, ptr %type40, align 8
  %cmp41 = icmp eq i32 %57, 6
  br i1 %cmp41, label %if.then43, label %if.end47

if.then43:                                        ; preds = %if.end39
  %58 = load ptr, ptr %n2.addr, align 8
  %ip44 = getelementptr inbounds %struct.clusterManagerNode, ptr %58, i32 0, i32 2
  %59 = load ptr, ptr %ip44, align 8
  %60 = load ptr, ptr %n2.addr, align 8
  %port45 = getelementptr inbounds %struct.clusterManagerNode, ptr %60, i32 0, i32 3
  %61 = load i32, ptr %port45, align 8
  %62 = load ptr, ptr %r2, align 8
  %str46 = getelementptr inbounds %struct.redisReply, ptr %62, i32 0, i32 4
  %63 = load ptr, ptr %str46, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %59, i32 noundef %61, ptr noundef %63)
  store i32 0, ptr %success, align 4
  br label %if.end47

if.end47:                                         ; preds = %if.then43, %if.end39
  %64 = load i32, ptr %success, align 4
  %tobool48 = icmp ne i32 %64, 0
  br i1 %tobool48, label %if.end50, label %if.then49

if.then49:                                        ; preds = %if.end47
  br label %cleanup

if.end50:                                         ; preds = %if.end47
  store i64 0, ptr %i, align 8
  br label %for.cond51

for.cond51:                                       ; preds = %for.inc79, %if.end50
  %65 = load i64, ptr %i, align 8
  %66 = load ptr, ptr %keys_reply.addr, align 8
  %elements52 = getelementptr inbounds %struct.redisReply, ptr %66, i32 0, i32 6
  %67 = load i64, ptr %elements52, align 8
  %cmp53 = icmp ult i64 %65, %67
  br i1 %cmp53, label %for.body55, label %for.end81

for.body55:                                       ; preds = %for.cond51
  %68 = load ptr, ptr %keys_reply.addr, align 8
  %element56 = getelementptr inbounds %struct.redisReply, ptr %68, i32 0, i32 7
  %69 = load ptr, ptr %element56, align 8
  %70 = load i64, ptr %i, align 8
  %arrayidx57 = getelementptr inbounds ptr, ptr %69, i64 %70
  %71 = load ptr, ptr %arrayidx57, align 8
  %str58 = getelementptr inbounds %struct.redisReply, ptr %71, i32 0, i32 4
  %72 = load ptr, ptr %str58, align 8
  store ptr %72, ptr %key, align 8
  %73 = load ptr, ptr %r1, align 8
  %element59 = getelementptr inbounds %struct.redisReply, ptr %73, i32 0, i32 7
  %74 = load ptr, ptr %element59, align 8
  %75 = load i64, ptr %i, align 8
  %arrayidx60 = getelementptr inbounds ptr, ptr %74, i64 %75
  %76 = load ptr, ptr %arrayidx60, align 8
  %str61 = getelementptr inbounds %struct.redisReply, ptr %76, i32 0, i32 4
  %77 = load ptr, ptr %str61, align 8
  store ptr %77, ptr %hash1, align 8
  %78 = load ptr, ptr %r2, align 8
  %element62 = getelementptr inbounds %struct.redisReply, ptr %78, i32 0, i32 7
  %79 = load ptr, ptr %element62, align 8
  %80 = load i64, ptr %i, align 8
  %arrayidx63 = getelementptr inbounds ptr, ptr %79, i64 %80
  %81 = load ptr, ptr %arrayidx63, align 8
  %str64 = getelementptr inbounds %struct.redisReply, ptr %81, i32 0, i32 4
  %82 = load ptr, ptr %str64, align 8
  store ptr %82, ptr %hash2, align 8
  %83 = load ptr, ptr %hash1, align 8
  %84 = load ptr, ptr @clusterManagerCompareKeysValues.hash_zero, align 8
  %call65 = call i32 @strcmp(ptr noundef %83, ptr noundef %84) #12
  %cmp66 = icmp eq i32 %call65, 0
  br i1 %cmp66, label %if.then71, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body55
  %85 = load ptr, ptr %hash2, align 8
  %86 = load ptr, ptr @clusterManagerCompareKeysValues.hash_zero, align 8
  %call68 = call i32 @strcmp(ptr noundef %85, ptr noundef %86) #12
  %cmp69 = icmp eq i32 %call68, 0
  br i1 %cmp69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %lor.lhs.false, %for.body55
  br label %for.inc79

if.end72:                                         ; preds = %lor.lhs.false
  %87 = load ptr, ptr %hash1, align 8
  %88 = load ptr, ptr %hash2, align 8
  %call73 = call i32 @strcmp(ptr noundef %87, ptr noundef %88) #12
  %cmp74 = icmp ne i32 %call73, 0
  br i1 %cmp74, label %if.then76, label %if.end78

if.then76:                                        ; preds = %if.end72
  %89 = load ptr, ptr %diffs.addr, align 8
  %90 = load ptr, ptr %key, align 8
  %call77 = call ptr @listAddNodeTail(ptr noundef %89, ptr noundef %90)
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %if.end72
  br label %for.inc79

for.inc79:                                        ; preds = %if.end78, %if.then71
  %91 = load i64, ptr %i, align 8
  %inc80 = add i64 %91, 1
  store i64 %inc80, ptr %i, align 8
  br label %for.cond51, !llvm.loop !199

for.end81:                                        ; preds = %for.cond51
  br label %cleanup

cleanup:                                          ; preds = %for.end81, %if.then49, %if.then27, %if.then
  %92 = load ptr, ptr %r1, align 8
  %tobool82 = icmp ne ptr %92, null
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %cleanup
  %93 = load ptr, ptr %r1, align 8
  call void @freeReplyObject(ptr noundef %93)
  br label %if.end84

if.end84:                                         ; preds = %if.then83, %cleanup
  %94 = load ptr, ptr %r2, align 8
  %tobool85 = icmp ne ptr %94, null
  br i1 %tobool85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %if.end84
  %95 = load ptr, ptr %r2, align 8
  call void @freeReplyObject(ptr noundef %95)
  br label %if.end87

if.end87:                                         ; preds = %if.then86, %if.end84
  %96 = load ptr, ptr %argv, align 8
  call void @zfree(ptr noundef %96)
  %97 = load ptr, ptr %argv_len, align 8
  call void @zfree(ptr noundef %97)
  %98 = load i32, ptr %success, align 4
  ret i32 %98
}

declare ptr @hi_sdsnewlen(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define internal void @clusterManagerPrintSlotsList(ptr noundef %slots) #0 {
entry:
  %slots.addr = alloca ptr, align 8
  %n = alloca %struct.clusterManagerNode, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %slot = alloca i32, align 4
  %nodeslist = alloca ptr, align 8
  store ptr %slots, ptr %slots.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %n, i8 0, i64 16520, i1 false)
  %0 = load ptr, ptr %slots.addr, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  %call1 = call i32 @atoi(ptr noundef %2) #12
  store i32 %call1, ptr %slot, align 4
  %3 = load i32, ptr %slot, align 4
  %cmp2 = icmp sge i32 %3, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %4 = load i32, ptr %slot, align 4
  %cmp3 = icmp slt i32 %4, 16384
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %slots4 = getelementptr inbounds %struct.clusterManagerNode, ptr %n, i32 0, i32 12
  %5 = load i32, ptr %slot, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [16384 x i8], ptr %slots4, i64 0, i64 %idxprom
  store i8 1, ptr %arrayidx, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %while.body
  br label %while.cond, !llvm.loop !200

while.end:                                        ; preds = %while.cond
  %call5 = call ptr @clusterManagerNodeSlotsString(ptr noundef %n)
  store ptr %call5, ptr %nodeslist, align 8
  %6 = load ptr, ptr %nodeslist, align 8
  %call6 = call i32 (ptr, ...) @printf(ptr noundef @.str.115, ptr noundef %6)
  %7 = load ptr, ptr %nodeslist, align 8
  call void @hi_sdsfree(ptr noundef %7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNodeMasterRandom() #0 {
entry:
  %retval = alloca ptr, align 8
  %master_count = alloca i32, align 4
  %idx = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %n8 = alloca ptr, align 8
  store i32 0, ptr %master_count, align 4
  %0 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %n, align 8
  %3 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !201

if.end:                                           ; preds = %while.body
  %5 = load i32, ptr %master_count, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %master_count, align 4
  br label %while.cond, !llvm.loop !201

while.end:                                        ; preds = %while.cond
  %call1 = call i64 @time(ptr noundef null) #15
  %conv = trunc i64 %call1 to i32
  call void @srand(i32 noundef %conv) #15
  %call2 = call i32 @rand() #15
  %6 = load i32, ptr %master_count, align 4
  %rem = srem i32 %call2, %6
  store i32 %rem, ptr %idx, align 4
  %7 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %7, ptr noundef %li)
  br label %while.cond3

while.cond3:                                      ; preds = %if.end17, %if.then13, %while.end
  %call4 = call ptr @listNext(ptr noundef %li)
  store ptr %call4, ptr %ln, align 8
  %cmp5 = icmp ne ptr %call4, null
  br i1 %cmp5, label %while.body7, label %while.end18

while.body7:                                      ; preds = %while.cond3
  %8 = load ptr, ptr %ln, align 8
  %value9 = getelementptr inbounds %struct.listNode, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %value9, align 8
  store ptr %9, ptr %n8, align 8
  %10 = load ptr, ptr %n8, align 8
  %flags10 = getelementptr inbounds %struct.clusterManagerNode, ptr %10, i32 0, i32 8
  %11 = load i32, ptr %flags10, align 8
  %and11 = and i32 %11, 2
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %while.body7
  br label %while.cond3, !llvm.loop !202

if.end14:                                         ; preds = %while.body7
  %12 = load i32, ptr %idx, align 4
  %dec = add nsw i32 %12, -1
  store i32 %dec, ptr %idx, align 4
  %tobool15 = icmp ne i32 %12, 0
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %if.end14
  %13 = load ptr, ptr %n8, align 8
  store ptr %13, ptr %retval, align 8
  br label %while.end18

if.end17:                                         ; preds = %if.end14
  br label %while.cond3, !llvm.loop !202

while.end18:                                      ; preds = %if.then16, %while.cond3
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal i32 @getClusterHostFromCmdArgs(i32 noundef %argc, ptr noundef %argv, ptr noundef %ip_ptr, ptr noundef %port_ptr) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %ip_ptr.addr = alloca ptr, align 8
  %port_ptr.addr = alloca ptr, align 8
  %port = alloca i32, align 4
  %ip = alloca ptr, align 8
  %addr = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %ip_ptr, ptr %ip_ptr.addr, align 8
  store ptr %port_ptr, ptr %port_ptr.addr, align 8
  store i32 0, ptr %port, align 4
  store ptr null, ptr %ip, align 8
  %0 = load i32, ptr %argc.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 0
  %2 = load ptr, ptr %arrayidx, align 8
  store ptr %2, ptr %addr, align 8
  %3 = load ptr, ptr %addr, align 8
  %call = call i32 @parseClusterNodeAddress(ptr noundef %3, ptr noundef %ip, ptr noundef %port, ptr noundef null)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then1

if.then1:                                         ; preds = %if.then
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end5

if.else:                                          ; preds = %entry
  %4 = load ptr, ptr %argv.addr, align 8
  %arrayidx2 = getelementptr inbounds ptr, ptr %4, i64 0
  %5 = load ptr, ptr %arrayidx2, align 8
  store ptr %5, ptr %ip, align 8
  %6 = load ptr, ptr %argv.addr, align 8
  %arrayidx3 = getelementptr inbounds ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx3, align 8
  %call4 = call i32 @atoi(ptr noundef %7) #12
  store i32 %call4, ptr %port, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.end
  %8 = load ptr, ptr %ip, align 8
  %tobool6 = icmp ne ptr %8, null
  br i1 %tobool6, label %lor.lhs.false, label %if.then8

lor.lhs.false:                                    ; preds = %if.end5
  %9 = load i32, ptr %port, align 4
  %tobool7 = icmp ne i32 %9, 0
  br i1 %tobool7, label %if.else9, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false, %if.end5
  store i32 0, ptr %retval, align 4
  br label %return

if.else9:                                         ; preds = %lor.lhs.false
  %10 = load ptr, ptr %ip, align 8
  %11 = load ptr, ptr %ip_ptr.addr, align 8
  store ptr %10, ptr %11, align 8
  %12 = load i32, ptr %port, align 4
  %13 = load ptr, ptr %port_ptr.addr, align 8
  store i32 %12, ptr %13, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.else9
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then1
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNodeWithLeastReplicas() #0 {
entry:
  %node = alloca ptr, align 8
  %lowest_count = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr null, ptr %node, align 8
  store i32 0, ptr %lowest_count, align 4
  %0 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end5, %if.then, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %n, align 8
  %3 = load ptr, ptr %n, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !203

if.end:                                           ; preds = %while.body
  %5 = load ptr, ptr %node, align 8
  %cmp1 = icmp eq ptr %5, null
  br i1 %cmp1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %6 = load ptr, ptr %n, align 8
  %replicas_count = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 14
  %7 = load i32, ptr %replicas_count, align 8
  %8 = load i32, ptr %lowest_count, align 4
  %cmp2 = icmp slt i32 %7, %8
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  %9 = load ptr, ptr %n, align 8
  store ptr %9, ptr %node, align 8
  %10 = load ptr, ptr %n, align 8
  %replicas_count4 = getelementptr inbounds %struct.clusterManagerNode, ptr %10, i32 0, i32 14
  %11 = load i32, ptr %replicas_count4, align 8
  store i32 %11, ptr %lowest_count, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %lor.lhs.false
  br label %while.cond, !llvm.loop !203

while.end:                                        ; preds = %while.cond
  %12 = load ptr, ptr %node, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerShowClusterInfo() #0 {
entry:
  %masters = alloca i32, align 4
  %keys = alloca i64, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %node = alloca ptr, align 8
  %replicas = alloca i32, align 4
  %dbsize = alloca i64, align 8
  %name3 = alloca [9 x i8], align 1
  %ri = alloca %struct.listIter, align 8
  %rn = alloca ptr, align 8
  %n = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %err = alloca ptr, align 8
  %keys_per_slot = alloca float, align 4
  store i32 0, ptr %masters, align 4
  store i64 0, ptr %keys, align 8
  %0 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end49, %if.then2, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end50

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %node, align 8
  %3 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end49, label %if.then

if.then:                                          ; preds = %while.body
  %5 = load ptr, ptr %node, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %name, align 8
  %tobool1 = icmp ne ptr %6, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  br label %while.cond, !llvm.loop !204

if.end:                                           ; preds = %if.then
  store i32 0, ptr %replicas, align 4
  store i64 -1, ptr %dbsize, align 8
  %arraydecay = getelementptr inbounds [9 x i8], ptr %name3, i64 0, i64 0
  %7 = load ptr, ptr %node, align 8
  %name4 = getelementptr inbounds %struct.clusterManagerNode, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %name4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay, ptr align 1 %8, i64 8, i1 false)
  %arrayidx = getelementptr inbounds [9 x i8], ptr %name3, i64 0, i64 8
  store i8 0, ptr %arrayidx, align 1
  %9 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %9, ptr noundef %ri)
  br label %while.cond5

while.cond5:                                      ; preds = %if.end22, %if.then14, %if.end
  %call6 = call ptr @listNext(ptr noundef %ri)
  store ptr %call6, ptr %rn, align 8
  %cmp7 = icmp ne ptr %call6, null
  br i1 %cmp7, label %while.body8, label %while.end

while.body8:                                      ; preds = %while.cond5
  %10 = load ptr, ptr %rn, align 8
  %value9 = getelementptr inbounds %struct.listNode, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %value9, align 8
  store ptr %11, ptr %n, align 8
  %12 = load ptr, ptr %n, align 8
  %13 = load ptr, ptr %node, align 8
  %cmp10 = icmp eq ptr %12, %13
  br i1 %cmp10, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body8
  %14 = load ptr, ptr %n, align 8
  %flags11 = getelementptr inbounds %struct.clusterManagerNode, ptr %14, i32 0, i32 8
  %15 = load i32, ptr %flags11, align 8
  %and12 = and i32 %15, 2
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %lor.lhs.false, %while.body8
  br label %while.cond5, !llvm.loop !205

if.end15:                                         ; preds = %lor.lhs.false
  %16 = load ptr, ptr %n, align 8
  %replicate = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 10
  %17 = load ptr, ptr %replicate, align 8
  %tobool16 = icmp ne ptr %17, null
  br i1 %tobool16, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end15
  %18 = load ptr, ptr %n, align 8
  %replicate17 = getelementptr inbounds %struct.clusterManagerNode, ptr %18, i32 0, i32 10
  %19 = load ptr, ptr %replicate17, align 8
  %20 = load ptr, ptr %node, align 8
  %name18 = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 1
  %21 = load ptr, ptr %name18, align 8
  %call19 = call i32 @strcmp(ptr noundef %19, ptr noundef %21) #12
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %land.lhs.true
  %22 = load i32, ptr %replicas, align 4
  %inc = add nsw i32 %22, 1
  store i32 %inc, ptr %replicas, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %land.lhs.true, %if.end15
  br label %while.cond5, !llvm.loop !205

while.end:                                        ; preds = %while.cond5
  %23 = load ptr, ptr %node, align 8
  %context = getelementptr inbounds %struct.clusterManagerNode, ptr %23, i32 0, i32 0
  %24 = load ptr, ptr %context, align 8
  %call23 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %24, ptr noundef @.str.357)
  store ptr %call23, ptr %reply, align 8
  %25 = load ptr, ptr %reply, align 8
  %cmp24 = icmp ne ptr %25, null
  br i1 %cmp24, label %land.lhs.true25, label %if.end28

land.lhs.true25:                                  ; preds = %while.end
  %26 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %26, i32 0, i32 0
  %27 = load i32, ptr %type, align 8
  %cmp26 = icmp eq i32 %27, 3
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %land.lhs.true25
  %28 = load ptr, ptr %reply, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %28, i32 0, i32 1
  %29 = load i64, ptr %integer, align 8
  store i64 %29, ptr %dbsize, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %land.lhs.true25, %while.end
  %30 = load i64, ptr %dbsize, align 8
  %cmp29 = icmp slt i64 %30, 0
  br i1 %cmp29, label %if.then30, label %if.end40

if.then30:                                        ; preds = %if.end28
  store ptr @.str.26, ptr %err, align 8
  %31 = load ptr, ptr %reply, align 8
  %cmp31 = icmp ne ptr %31, null
  br i1 %cmp31, label %land.lhs.true32, label %if.end36

land.lhs.true32:                                  ; preds = %if.then30
  %32 = load ptr, ptr %reply, align 8
  %type33 = getelementptr inbounds %struct.redisReply, ptr %32, i32 0, i32 0
  %33 = load i32, ptr %type33, align 8
  %cmp34 = icmp eq i32 %33, 6
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true32
  %34 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %34, i32 0, i32 4
  %35 = load ptr, ptr %str, align 8
  store ptr %35, ptr %err, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %land.lhs.true32, %if.then30
  %36 = load ptr, ptr %node, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %36, i32 0, i32 2
  %37 = load ptr, ptr %ip, align 8
  %38 = load ptr, ptr %node, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %38, i32 0, i32 3
  %39 = load i32, ptr %port, align 8
  %40 = load ptr, ptr %err, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.164, ptr noundef %37, i32 noundef %39, ptr noundef %40)
  %41 = load ptr, ptr %reply, align 8
  %cmp37 = icmp ne ptr %41, null
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end36
  %42 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %42)
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.end36
  br label %return

if.end40:                                         ; preds = %if.end28
  %43 = load ptr, ptr %reply, align 8
  %cmp41 = icmp ne ptr %43, null
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end40
  %44 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %44)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.end40
  %45 = load ptr, ptr %node, align 8
  %ip44 = getelementptr inbounds %struct.clusterManagerNode, ptr %45, i32 0, i32 2
  %46 = load ptr, ptr %ip44, align 8
  %47 = load ptr, ptr %node, align 8
  %port45 = getelementptr inbounds %struct.clusterManagerNode, ptr %47, i32 0, i32 3
  %48 = load i32, ptr %port45, align 8
  %arraydecay46 = getelementptr inbounds [9 x i8], ptr %name3, i64 0, i64 0
  %49 = load i64, ptr %dbsize, align 8
  %50 = load ptr, ptr %node, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %50, i32 0, i32 13
  %51 = load i32, ptr %slots_count, align 4
  %52 = load i32, ptr %replicas, align 4
  %call47 = call i32 (ptr, ...) @printf(ptr noundef @.str.358, ptr noundef %46, i32 noundef %48, ptr noundef %arraydecay46, i64 noundef %49, i32 noundef %51, i32 noundef %52)
  %53 = load i32, ptr %masters, align 4
  %inc48 = add nsw i32 %53, 1
  store i32 %inc48, ptr %masters, align 4
  %54 = load i64, ptr %dbsize, align 8
  %55 = load i64, ptr %keys, align 8
  %add = add nsw i64 %55, %54
  store i64 %add, ptr %keys, align 8
  br label %if.end49

if.end49:                                         ; preds = %if.end43, %while.body
  br label %while.cond, !llvm.loop !204

while.end50:                                      ; preds = %while.cond
  %56 = load i64, ptr %keys, align 8
  %57 = load i32, ptr %masters, align 4
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 4, ptr noundef @.str.359, i64 noundef %56, i32 noundef %57)
  %58 = load i64, ptr %keys, align 8
  %conv = sitofp i64 %58 to float
  %div = fdiv float %conv, 1.638400e+04
  store float %div, ptr %keys_per_slot, align 4
  %59 = load float, ptr %keys_per_slot, align 4
  %conv51 = fpext float %59 to double
  %call52 = call i32 (ptr, ...) @printf(ptr noundef @.str.360, double noundef %conv51)
  br label %return

return:                                           ; preds = %while.end50, %if.end39
  ret void
}

declare i32 @getchar() #2

; Function Attrs: nounwind uwtable
define internal ptr @clusterNodeForResharding(ptr noundef %id, ptr noundef %target, ptr noundef %raise_err) #0 {
entry:
  %retval = alloca ptr, align 8
  %id.addr = alloca ptr, align 8
  %target.addr = alloca ptr, align 8
  %raise_err.addr = alloca ptr, align 8
  %node = alloca ptr, align 8
  %invalid_node_msg = alloca ptr, align 8
  store ptr %id, ptr %id.addr, align 8
  store ptr %target, ptr %target.addr, align 8
  store ptr %raise_err, ptr %raise_err.addr, align 8
  store ptr null, ptr %node, align 8
  store ptr @.str.377, ptr %invalid_node_msg, align 8
  %0 = load ptr, ptr %id.addr, align 8
  %call = call ptr @clusterManagerNodeByName(ptr noundef %0)
  store ptr %call, ptr %node, align 8
  %1 = load ptr, ptr %raise_err.addr, align 8
  store i32 0, ptr %1, align 4
  %2 = load ptr, ptr %node, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %node, align 8
  %flags = getelementptr inbounds %struct.clusterManagerNode, ptr %3, i32 0, i32 8
  %4 = load i32, ptr %flags, align 8
  %and = and i32 %4, 2
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load ptr, ptr %invalid_node_msg, align 8
  %6 = load ptr, ptr %id.addr, align 8
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %raise_err.addr, align 8
  store i32 1, ptr %7, align 4
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %8 = load ptr, ptr %target.addr, align 8
  %cmp = icmp ne ptr %8, null
  br i1 %cmp, label %if.then2, label %if.end7

if.then2:                                         ; preds = %if.else
  %9 = load ptr, ptr %node, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %name, align 8
  %11 = load ptr, ptr %target.addr, align 8
  %name3 = getelementptr inbounds %struct.clusterManagerNode, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %name3, align 8
  %call4 = call i32 @strcmp(ptr noundef %10, ptr noundef %12) #12
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end, label %if.then6

if.then6:                                         ; preds = %if.then2
  call void (i32, ptr, ...) @clusterManagerLog(i32 noundef 3, ptr noundef @.str.378)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then2
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end7
  %13 = load ptr, ptr %node, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerComputeReshardTable(ptr noundef %sources, i32 noundef %numslots) #0 {
entry:
  %sources.addr = alloca ptr, align 8
  %numslots.addr = alloca i32, align 4
  %moved = alloca ptr, align 8
  %src_count = alloca i32, align 4
  %i = alloca i32, align 4
  %tot_slots = alloca i32, align 4
  %j = alloca i32, align 4
  %sorted = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %node = alloca ptr, align 8
  %node8 = alloca ptr, align 8
  %n = alloca float, align 4
  %max = alloca i32, align 4
  %count = alloca i32, align 4
  %slot = alloca i32, align 4
  %item = alloca ptr, align 8
  store ptr %sources, ptr %sources.addr, align 8
  store i32 %numslots, ptr %numslots.addr, align 4
  %call = call ptr @listCreate()
  store ptr %call, ptr %moved, align 8
  %0 = load ptr, ptr %sources.addr, align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %src_count, align 4
  store i32 0, ptr %i, align 4
  store i32 0, ptr %tot_slots, align 4
  %2 = load i32, ptr %src_count, align 4
  %conv1 = sext i32 %2 to i64
  %mul = mul i64 %conv1, 8
  %call2 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call2, ptr %sorted, align 8
  %3 = load ptr, ptr %sources.addr, align 8
  call void @listRewind(ptr noundef %3, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call3 = call ptr @listNext(ptr noundef %li)
  store ptr %call3, ptr %ln, align 8
  %cmp = icmp ne ptr %call3, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %value, align 8
  store ptr %5, ptr %node, align 8
  %6 = load ptr, ptr %node, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 13
  %7 = load i32, ptr %slots_count, align 4
  %8 = load i32, ptr %tot_slots, align 4
  %add = add nsw i32 %8, %7
  store i32 %add, ptr %tot_slots, align 4
  %9 = load ptr, ptr %node, align 8
  %10 = load ptr, ptr %sorted, align 8
  %11 = load i32, ptr %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %10, i64 %idxprom
  store ptr %9, ptr %arrayidx, align 8
  br label %while.cond, !llvm.loop !206

while.end:                                        ; preds = %while.cond
  %12 = load ptr, ptr %sorted, align 8
  %13 = load i32, ptr %src_count, align 4
  %conv5 = sext i32 %13 to i64
  call void @qsort(ptr noundef %12, i64 noundef %conv5, i64 noundef 8, ptr noundef @clusterManagerSlotCountCompareDesc)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc45, %while.end
  %14 = load i32, ptr %i, align 4
  %15 = load i32, ptr %src_count, align 4
  %cmp6 = icmp slt i32 %14, %15
  br i1 %cmp6, label %for.body, label %for.end47

for.body:                                         ; preds = %for.cond
  %16 = load ptr, ptr %sorted, align 8
  %17 = load i32, ptr %i, align 4
  %idxprom9 = sext i32 %17 to i64
  %arrayidx10 = getelementptr inbounds ptr, ptr %16, i64 %idxprom9
  %18 = load ptr, ptr %arrayidx10, align 8
  store ptr %18, ptr %node8, align 8
  %19 = load i32, ptr %numslots.addr, align 4
  %conv11 = sitofp i32 %19 to float
  %20 = load i32, ptr %tot_slots, align 4
  %conv12 = sitofp i32 %20 to float
  %div = fdiv float %conv11, %conv12
  %21 = load ptr, ptr %node8, align 8
  %slots_count13 = getelementptr inbounds %struct.clusterManagerNode, ptr %21, i32 0, i32 13
  %22 = load i32, ptr %slots_count13, align 4
  %conv14 = sitofp i32 %22 to float
  %mul15 = fmul float %div, %conv14
  store float %mul15, ptr %n, align 4
  %23 = load i32, ptr %i, align 4
  %cmp16 = icmp eq i32 %23, 0
  br i1 %cmp16, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %24 = load float, ptr %n, align 4
  %conv18 = fpext float %24 to double
  %25 = call double @llvm.ceil.f64(double %conv18)
  %conv19 = fptrunc double %25 to float
  store float %conv19, ptr %n, align 4
  br label %if.end

if.else:                                          ; preds = %for.body
  %26 = load float, ptr %n, align 4
  %conv20 = fpext float %26 to double
  %27 = call double @llvm.floor.f64(double %conv20)
  %conv21 = fptrunc double %27 to float
  store float %conv21, ptr %n, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %28 = load float, ptr %n, align 4
  %conv22 = fptosi float %28 to i32
  store i32 %conv22, ptr %max, align 4
  store i32 0, ptr %count, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc, %if.end
  %29 = load i32, ptr %j, align 4
  %cmp24 = icmp slt i32 %29, 16384
  br i1 %cmp24, label %for.body26, label %for.end

for.body26:                                       ; preds = %for.cond23
  %30 = load ptr, ptr %node8, align 8
  %slots = getelementptr inbounds %struct.clusterManagerNode, ptr %30, i32 0, i32 12
  %31 = load i32, ptr %j, align 4
  %idxprom27 = sext i32 %31 to i64
  %arrayidx28 = getelementptr inbounds [16384 x i8], ptr %slots, i64 0, i64 %idxprom27
  %32 = load i8, ptr %arrayidx28, align 1
  %conv29 = zext i8 %32 to i32
  store i32 %conv29, ptr %slot, align 4
  %33 = load i32, ptr %slot, align 4
  %tobool = icmp ne i32 %33, 0
  br i1 %tobool, label %if.end31, label %if.then30

if.then30:                                        ; preds = %for.body26
  br label %for.inc

if.end31:                                         ; preds = %for.body26
  %34 = load i32, ptr %count, align 4
  %35 = load i32, ptr %max, align 4
  %cmp32 = icmp sge i32 %34, %35
  br i1 %cmp32, label %if.then38, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end31
  %36 = load ptr, ptr %moved, align 8
  %len34 = getelementptr inbounds %struct.list, ptr %36, i32 0, i32 5
  %37 = load i64, ptr %len34, align 8
  %conv35 = trunc i64 %37 to i32
  %38 = load i32, ptr %numslots.addr, align 4
  %cmp36 = icmp sge i32 %conv35, %38
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %lor.lhs.false, %if.end31
  br label %for.end

if.end39:                                         ; preds = %lor.lhs.false
  %call40 = call noalias ptr @zmalloc(i64 noundef 16) #14
  store ptr %call40, ptr %item, align 8
  %39 = load ptr, ptr %node8, align 8
  %40 = load ptr, ptr %item, align 8
  %source = getelementptr inbounds %struct.clusterManagerReshardTableItem, ptr %40, i32 0, i32 0
  store ptr %39, ptr %source, align 8
  %41 = load i32, ptr %j, align 4
  %42 = load ptr, ptr %item, align 8
  %slot41 = getelementptr inbounds %struct.clusterManagerReshardTableItem, ptr %42, i32 0, i32 1
  store i32 %41, ptr %slot41, align 8
  %43 = load ptr, ptr %moved, align 8
  %44 = load ptr, ptr %item, align 8
  %call42 = call ptr @listAddNodeTail(ptr noundef %43, ptr noundef %44)
  %45 = load i32, ptr %count, align 4
  %inc43 = add nsw i32 %45, 1
  store i32 %inc43, ptr %count, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end39, %if.then30
  %46 = load i32, ptr %j, align 4
  %inc44 = add nsw i32 %46, 1
  store i32 %inc44, ptr %j, align 4
  br label %for.cond23, !llvm.loop !207

for.end:                                          ; preds = %if.then38, %for.cond23
  br label %for.inc45

for.inc45:                                        ; preds = %for.end
  %47 = load i32, ptr %i, align 4
  %inc46 = add nsw i32 %47, 1
  store i32 %inc46, ptr %i, align 4
  br label %for.cond, !llvm.loop !208

for.end47:                                        ; preds = %for.cond
  %48 = load ptr, ptr %sorted, align 8
  call void @zfree(ptr noundef %48)
  %49 = load ptr, ptr %moved, align 8
  ret ptr %49
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerShowReshardTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %item = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  call void @listRewind(ptr noundef %0, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %value, align 8
  store ptr %2, ptr %item, align 8
  %3 = load ptr, ptr %item, align 8
  %source = getelementptr inbounds %struct.clusterManagerReshardTableItem, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %source, align 8
  store ptr %4, ptr %n, align 8
  %5 = load ptr, ptr %item, align 8
  %slot = getelementptr inbounds %struct.clusterManagerReshardTableItem, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %slot, align 8
  %7 = load ptr, ptr %n, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %name, align 8
  %call1 = call i32 (ptr, ...) @printf(ptr noundef @.str.379, i32 noundef %6, ptr noundef %8)
  br label %while.cond, !llvm.loop !209

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @clusterManagerReleaseReshardTable(ptr noundef %table) #0 {
entry:
  %table.addr = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %item = alloca ptr, align 8
  store ptr %table, ptr %table.addr, align 8
  %0 = load ptr, ptr %table.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %table.addr, align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp1 = icmp ne ptr %call, null
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %item, align 8
  %4 = load ptr, ptr %item, align 8
  call void @zfree(ptr noundef %4)
  br label %while.cond, !llvm.loop !210

while.end:                                        ; preds = %while.cond
  %5 = load ptr, ptr %table.addr, align 8
  call void @listRelease(ptr noundef %5)
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.floor.f64(double) #8

; Function Attrs: nounwind willreturn memory(read)
declare double @atof(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNodeByAbbreviatedName(ptr noundef %name) #0 {
entry:
  %retval = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %found = alloca ptr, align 8
  %lcname = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr @cluster_manager, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %found, align 8
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %lcname, align 8
  %1 = load ptr, ptr %lcname, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %call1 = call ptr @hi_sdscpy(ptr noundef %1, ptr noundef %2)
  store ptr %call1, ptr %lcname, align 8
  %3 = load ptr, ptr %lcname, align 8
  call void @hi_sdstolower(ptr noundef %3)
  %4 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %4, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end10, %if.end
  %call2 = call ptr @listNext(ptr noundef %li)
  store ptr %call2, ptr %ln, align 8
  %cmp3 = icmp ne ptr %call2, null
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %value, align 8
  store ptr %6, ptr %n, align 8
  %7 = load ptr, ptr %n, align 8
  %name4 = getelementptr inbounds %struct.clusterManagerNode, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %name4, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %while.body
  %9 = load ptr, ptr %n, align 8
  %name5 = getelementptr inbounds %struct.clusterManagerNode, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %name5, align 8
  %11 = load ptr, ptr %lcname, align 8
  %call6 = call ptr @strstr(ptr noundef %10, ptr noundef %11) #12
  %12 = load ptr, ptr %n, align 8
  %name7 = getelementptr inbounds %struct.clusterManagerNode, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %name7, align 8
  %cmp8 = icmp eq ptr %call6, %13
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true
  %14 = load ptr, ptr %n, align 8
  store ptr %14, ptr %found, align 8
  br label %while.end

if.end10:                                         ; preds = %land.lhs.true, %while.body
  br label %while.cond, !llvm.loop !211

while.end:                                        ; preds = %if.then9, %while.cond
  %15 = load ptr, ptr %lcname, align 8
  call void @hi_sdsfree(ptr noundef %15)
  %16 = load ptr, ptr %found, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fabs.f64(double) #8

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.abs.i32(i32, i1 immarg) #8

; Function Attrs: nounwind uwtable
define internal i32 @cliAuth(ptr noundef %ctx, ptr noundef %user, ptr noundef %auth) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %user.addr = alloca ptr, align 8
  %auth.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %result = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %user, ptr %user.addr, align 8
  store ptr %auth, ptr %auth.addr, align 8
  %0 = load ptr, ptr %auth.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %user.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %auth.addr, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %2, ptr noundef @.str.183, ptr noundef %3)
  store ptr %call, ptr %reply, align 8
  br label %if.end4

if.else:                                          ; preds = %if.end
  %4 = load ptr, ptr %ctx.addr, align 8
  %5 = load ptr, ptr %user.addr, align 8
  %6 = load ptr, ptr %auth.addr, align 8
  %call3 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %4, ptr noundef @.str.184, ptr noundef %5, ptr noundef %6)
  store ptr %call3, ptr %reply, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.then2
  %7 = load ptr, ptr %reply, align 8
  %cmp5 = icmp eq ptr %7, null
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %8 = load ptr, ptr @stderr, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %8, ptr noundef @.str.76)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end4
  store i32 0, ptr %result, align 4
  %9 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type, align 8
  %cmp9 = icmp eq i32 %10, 6
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  store i32 -1, ptr %result, align 4
  %11 = load ptr, ptr @stderr, align 8
  %12 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %str, align 8
  %call11 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %11, ptr noundef @.str.415, ptr noundef %13)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %14 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %14)
  %15 = load i32, ptr %result, align 4
  store i32 %15, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then6, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal ptr @reconnectingRedisCommand(ptr noundef %c, ptr noundef %fmt, ...) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %tries = alloca i32, align 4
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %err9 = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr null, ptr %reply, align 8
  store i32 0, ptr %tries, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end34, %entry
  %0 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %while.body, label %while.end35

while.body:                                       ; preds = %while.cond
  br label %while.cond1

while.cond1:                                      ; preds = %if.end16, %while.body
  %1 = load ptr, ptr %c.addr, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %err, align 8
  %and = and i32 %2, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %while.body2, label %while.end

while.body2:                                      ; preds = %while.cond1
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.416)
  %3 = load i32, ptr %tries, align 4
  %inc = add nsw i32 %3, 1
  store i32 %inc, ptr %tries, align 4
  %call3 = call i32 (ptr, ...) @printf(ptr noundef @.str.417, i32 noundef %inc)
  %4 = load ptr, ptr @stdout, align 8
  %call4 = call i32 @fflush(ptr noundef %4)
  %5 = load ptr, ptr %c.addr, align 8
  call void @redisFree(ptr noundef %5)
  %6 = load ptr, ptr @config, align 8
  %7 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %call5 = call ptr @redisConnect(ptr noundef %6, i32 noundef %7)
  store ptr %call5, ptr %c.addr, align 8
  %8 = load ptr, ptr %c.addr, align 8
  %err6 = getelementptr inbounds %struct.redisContext, ptr %8, i32 0, i32 1
  %9 = load i32, ptr %err6, align 8
  %tobool7 = icmp ne i32 %9, 0
  br i1 %tobool7, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.body2
  %10 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 2), align 8
  %tobool8 = icmp ne i32 %10, 0
  br i1 %tobool8, label %if.then, label %if.end16

if.then:                                          ; preds = %land.lhs.true
  store ptr null, ptr %err9, align 8
  %11 = load ptr, ptr %c.addr, align 8
  %call10 = call i32 @cliSecureConnection(ptr noundef %11, ptr noundef byval(%struct.cliSSLconfig) align 8 getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 3), ptr noundef %err9)
  %cmp11 = icmp eq i32 %call10, -1
  br i1 %cmp11, label %land.lhs.true12, label %if.end

land.lhs.true12:                                  ; preds = %if.then
  %12 = load ptr, ptr %err9, align 8
  %tobool13 = icmp ne ptr %12, null
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %land.lhs.true12
  %13 = load ptr, ptr @stderr, align 8
  %14 = load ptr, ptr %err9, align 8
  %call15 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %13, ptr noundef @.str.180, ptr noundef %14)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %land.lhs.true12, %if.then
  br label %if.end16

if.end16:                                         ; preds = %if.end, %land.lhs.true, %while.body2
  %call17 = call i32 @usleep(i32 noundef 1000000)
  br label %while.cond1, !llvm.loop !212

while.end:                                        ; preds = %while.cond1
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %15 = load ptr, ptr %c.addr, align 8
  %16 = load ptr, ptr %fmt.addr, align 8
  %arraydecay18 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call19 = call ptr @redisvCommand(ptr noundef %15, ptr noundef %16, ptr noundef %arraydecay18)
  store ptr %call19, ptr %reply, align 8
  %arraydecay20 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay20)
  %17 = load ptr, ptr %c.addr, align 8
  %err21 = getelementptr inbounds %struct.redisContext, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %err21, align 8
  %tobool22 = icmp ne i32 %18, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.else

land.lhs.true23:                                  ; preds = %while.end
  %19 = load ptr, ptr %c.addr, align 8
  %err24 = getelementptr inbounds %struct.redisContext, ptr %19, i32 0, i32 1
  %20 = load i32, ptr %err24, align 8
  %and25 = and i32 %20, 3
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.else, label %if.then27

if.then27:                                        ; preds = %land.lhs.true23
  %21 = load ptr, ptr @stderr, align 8
  %22 = load ptr, ptr %c.addr, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %22, i32 0, i32 2
  %arraydecay28 = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call29 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %21, ptr noundef @.str.418, ptr noundef %arraydecay28)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else:                                          ; preds = %land.lhs.true23, %while.end
  %23 = load i32, ptr %tries, align 4
  %cmp30 = icmp sgt i32 %23, 0
  br i1 %cmp30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.else
  %call32 = call i32 (ptr, ...) @printf(ptr noundef @.str.416)
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.else
  br label %if.end34

if.end34:                                         ; preds = %if.end33
  br label %while.cond, !llvm.loop !213

while.end35:                                      ; preds = %while.cond
  %24 = load ptr, ptr %c.addr, align 8
  store ptr %24, ptr @context, align 8
  %25 = load ptr, ptr %reply, align 8
  ret ptr %25
}

; Function Attrs: nounwind uwtable
define internal i32 @clusterManagerKeyHashSlot(ptr noundef %key, i32 noundef %keylen) #0 {
entry:
  %retval = alloca i32, align 4
  %key.addr = alloca ptr, align 8
  %keylen.addr = alloca i32, align 4
  %s = alloca i32, align 4
  %e = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store i32 %keylen, ptr %keylen.addr, align 4
  store i32 0, ptr %s, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %s, align 4
  %1 = load i32, ptr %keylen.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %key.addr, align 8
  %3 = load i32, ptr %s, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds i8, ptr %2, i64 %idxprom
  %4 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp1 = icmp eq i32 %conv, 123
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i32, ptr %s, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %s, align 4
  br label %for.cond, !llvm.loop !214

for.end:                                          ; preds = %if.then, %for.cond
  %6 = load i32, ptr %s, align 4
  %7 = load i32, ptr %keylen.addr, align 4
  %cmp3 = icmp eq i32 %6, %7
  br i1 %cmp3, label %if.then5, label %if.end7

if.then5:                                         ; preds = %for.end
  %8 = load ptr, ptr %key.addr, align 8
  %9 = load i32, ptr %keylen.addr, align 4
  %call = call zeroext i16 @crc16(ptr noundef %8, i32 noundef %9)
  %conv6 = zext i16 %call to i32
  %and = and i32 %conv6, 16383
  store i32 %and, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %for.end
  %10 = load i32, ptr %s, align 4
  %add = add nsw i32 %10, 1
  store i32 %add, ptr %e, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc19, %if.end7
  %11 = load i32, ptr %e, align 4
  %12 = load i32, ptr %keylen.addr, align 4
  %cmp9 = icmp slt i32 %11, %12
  br i1 %cmp9, label %for.body11, label %for.end21

for.body11:                                       ; preds = %for.cond8
  %13 = load ptr, ptr %key.addr, align 8
  %14 = load i32, ptr %e, align 4
  %idxprom12 = sext i32 %14 to i64
  %arrayidx13 = getelementptr inbounds i8, ptr %13, i64 %idxprom12
  %15 = load i8, ptr %arrayidx13, align 1
  %conv14 = sext i8 %15 to i32
  %cmp15 = icmp eq i32 %conv14, 125
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body11
  br label %for.end21

if.end18:                                         ; preds = %for.body11
  br label %for.inc19

for.inc19:                                        ; preds = %if.end18
  %16 = load i32, ptr %e, align 4
  %inc20 = add nsw i32 %16, 1
  store i32 %inc20, ptr %e, align 4
  br label %for.cond8, !llvm.loop !215

for.end21:                                        ; preds = %if.then17, %for.cond8
  %17 = load i32, ptr %e, align 4
  %18 = load i32, ptr %keylen.addr, align 4
  %cmp22 = icmp eq i32 %17, %18
  br i1 %cmp22, label %if.then27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end21
  %19 = load i32, ptr %e, align 4
  %20 = load i32, ptr %s, align 4
  %add24 = add nsw i32 %20, 1
  %cmp25 = icmp eq i32 %19, %add24
  br i1 %cmp25, label %if.then27, label %if.end31

if.then27:                                        ; preds = %lor.lhs.false, %for.end21
  %21 = load ptr, ptr %key.addr, align 8
  %22 = load i32, ptr %keylen.addr, align 4
  %call28 = call zeroext i16 @crc16(ptr noundef %21, i32 noundef %22)
  %conv29 = zext i16 %call28 to i32
  %and30 = and i32 %conv29, 16383
  store i32 %and30, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %lor.lhs.false
  %23 = load ptr, ptr %key.addr, align 8
  %24 = load i32, ptr %s, align 4
  %idx.ext = sext i32 %24 to i64
  %add.ptr = getelementptr inbounds i8, ptr %23, i64 %idx.ext
  %add.ptr32 = getelementptr inbounds i8, ptr %add.ptr, i64 1
  %25 = load i32, ptr %e, align 4
  %26 = load i32, ptr %s, align 4
  %sub = sub nsw i32 %25, %26
  %sub33 = sub nsw i32 %sub, 1
  %call34 = call zeroext i16 @crc16(ptr noundef %add.ptr32, i32 noundef %sub33)
  %conv35 = zext i16 %call34 to i32
  %and36 = and i32 %conv35, 16383
  store i32 %and36, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end31, %if.then27, %if.then5
  %27 = load i32, ptr %retval, align 4
  ret i32 %27
}

declare i32 @usleep(i32 noundef) #2

declare ptr @redisvCommand(ptr noundef, ptr noundef, ptr noundef) #2

declare zeroext i16 @crc16(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @cliFormatReplyRaw(ptr noundef %r) #0 {
entry:
  %r.addr = alloca ptr, align 8
  %out = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %i = alloca i64, align 8
  store ptr %r, ptr %r.addr, align 8
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %out, align 8
  %0 = load ptr, ptr %r.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  switch i32 %1, label %sw.default [
    i32 4, label %sw.bb
    i32 6, label %sw.bb1
    i32 5, label %sw.bb4
    i32 1, label %sw.bb4
    i32 14, label %sw.bb4
    i32 8, label %sw.bb19
    i32 3, label %sw.bb22
    i32 7, label %sw.bb25
    i32 10, label %sw.bb28
    i32 2, label %sw.bb28
    i32 12, label %sw.bb28
    i32 9, label %sw.bb37
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %2 = load ptr, ptr %out, align 8
  %3 = load ptr, ptr %r.addr, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %str, align 8
  %5 = load ptr, ptr %r.addr, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 3
  %6 = load i64, ptr %len, align 8
  %call2 = call ptr @hi_sdscatlen(ptr noundef %2, ptr noundef %4, i64 noundef %6)
  store ptr %call2, ptr %out, align 8
  %7 = load ptr, ptr %out, align 8
  %call3 = call ptr @hi_sdscatlen(ptr noundef %7, ptr noundef @.str.116, i64 noundef 1)
  store ptr %call3, ptr %out, align 8
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry, %entry, %entry
  %8 = load ptr, ptr %r.addr, align 8
  %type5 = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type5, align 8
  %cmp = icmp eq i32 %9, 5
  br i1 %cmp, label %land.lhs.true, label %if.else14

land.lhs.true:                                    ; preds = %sw.bb4
  %10 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then, label %if.else14

if.then:                                          ; preds = %land.lhs.true
  %11 = load ptr, ptr %r.addr, align 8
  %str6 = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 4
  %12 = load ptr, ptr %str6, align 8
  %call7 = call ptr @strstr(ptr noundef %12, ptr noundef @.str.422) #12
  %13 = load ptr, ptr %r.addr, align 8
  %str8 = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %str8, align 8
  %cmp9 = icmp eq ptr %call7, %14
  br i1 %cmp9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 50), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 49), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  call void @cliRefreshPrompt()
  br label %if.end

if.else:                                          ; preds = %if.then
  %15 = load ptr, ptr %out, align 8
  %16 = load ptr, ptr %r.addr, align 8
  %str11 = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 4
  %17 = load ptr, ptr %str11, align 8
  %18 = load ptr, ptr %r.addr, align 8
  %len12 = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 3
  %19 = load i64, ptr %len12, align 8
  %call13 = call ptr @sdsCatColorizedLdbReply(ptr noundef %15, ptr noundef %17, i64 noundef %19)
  store ptr %call13, ptr %out, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then10
  br label %if.end18

if.else14:                                        ; preds = %land.lhs.true, %sw.bb4
  %20 = load ptr, ptr %out, align 8
  %21 = load ptr, ptr %r.addr, align 8
  %str15 = getelementptr inbounds %struct.redisReply, ptr %21, i32 0, i32 4
  %22 = load ptr, ptr %str15, align 8
  %23 = load ptr, ptr %r.addr, align 8
  %len16 = getelementptr inbounds %struct.redisReply, ptr %23, i32 0, i32 3
  %24 = load i64, ptr %len16, align 8
  %call17 = call ptr @hi_sdscatlen(ptr noundef %20, ptr noundef %22, i64 noundef %24)
  store ptr %call17, ptr %out, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.else14, %if.end
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry
  %25 = load ptr, ptr %out, align 8
  %26 = load ptr, ptr %r.addr, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %26, i32 0, i32 1
  %27 = load i64, ptr %integer, align 8
  %tobool20 = icmp ne i64 %27, 0
  %cond = select i1 %tobool20, ptr @.str.423, ptr @.str.424
  %call21 = call ptr @hi_sdscat(ptr noundef %25, ptr noundef %cond)
  store ptr %call21, ptr %out, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %entry
  %28 = load ptr, ptr %out, align 8
  %29 = load ptr, ptr %r.addr, align 8
  %integer23 = getelementptr inbounds %struct.redisReply, ptr %29, i32 0, i32 1
  %30 = load i64, ptr %integer23, align 8
  %call24 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %28, ptr noundef @.str.153, i64 noundef %30)
  store ptr %call24, ptr %out, align 8
  br label %sw.epilog

sw.bb25:                                          ; preds = %entry
  %31 = load ptr, ptr %out, align 8
  %32 = load ptr, ptr %r.addr, align 8
  %str26 = getelementptr inbounds %struct.redisReply, ptr %32, i32 0, i32 4
  %33 = load ptr, ptr %str26, align 8
  %call27 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %31, ptr noundef @.str.237, ptr noundef %33)
  store ptr %call27, ptr %out, align 8
  br label %sw.epilog

sw.bb28:                                          ; preds = %entry, %entry, %entry
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb28
  %34 = load i64, ptr %i, align 8
  %35 = load ptr, ptr %r.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %35, i32 0, i32 6
  %36 = load i64, ptr %elements, align 8
  %cmp29 = icmp ult i64 %34, %36
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %37 = load i64, ptr %i, align 8
  %cmp30 = icmp ugt i64 %37, 0
  br i1 %cmp30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %for.body
  %38 = load ptr, ptr %out, align 8
  %39 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 43), align 8
  %call32 = call ptr @hi_sdscat(ptr noundef %38, ptr noundef %39)
  store ptr %call32, ptr %out, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %for.body
  %40 = load ptr, ptr %r.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %40, i32 0, i32 7
  %41 = load ptr, ptr %element, align 8
  %42 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %41, i64 %42
  %43 = load ptr, ptr %arrayidx, align 8
  %call34 = call ptr @cliFormatReplyRaw(ptr noundef %43)
  store ptr %call34, ptr %tmp, align 8
  %44 = load ptr, ptr %out, align 8
  %45 = load ptr, ptr %tmp, align 8
  %46 = load ptr, ptr %tmp, align 8
  %call35 = call i64 @hi_sdslen(ptr noundef %46)
  %call36 = call ptr @hi_sdscatlen(ptr noundef %44, ptr noundef %45, i64 noundef %call35)
  store ptr %call36, ptr %out, align 8
  %47 = load ptr, ptr %tmp, align 8
  call void @hi_sdsfree(ptr noundef %47)
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %48 = load i64, ptr %i, align 8
  %inc = add i64 %48, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !216

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.bb37:                                          ; preds = %entry
  store i64 0, ptr %i, align 8
  br label %for.cond38

for.cond38:                                       ; preds = %for.inc57, %sw.bb37
  %49 = load i64, ptr %i, align 8
  %50 = load ptr, ptr %r.addr, align 8
  %elements39 = getelementptr inbounds %struct.redisReply, ptr %50, i32 0, i32 6
  %51 = load i64, ptr %elements39, align 8
  %cmp40 = icmp ult i64 %49, %51
  br i1 %cmp40, label %for.body41, label %for.end59

for.body41:                                       ; preds = %for.cond38
  %52 = load i64, ptr %i, align 8
  %cmp42 = icmp ugt i64 %52, 0
  br i1 %cmp42, label %if.then43, label %if.end45

if.then43:                                        ; preds = %for.body41
  %53 = load ptr, ptr %out, align 8
  %54 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 43), align 8
  %call44 = call ptr @hi_sdscat(ptr noundef %53, ptr noundef %54)
  store ptr %call44, ptr %out, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then43, %for.body41
  %55 = load ptr, ptr %r.addr, align 8
  %element46 = getelementptr inbounds %struct.redisReply, ptr %55, i32 0, i32 7
  %56 = load ptr, ptr %element46, align 8
  %57 = load i64, ptr %i, align 8
  %arrayidx47 = getelementptr inbounds ptr, ptr %56, i64 %57
  %58 = load ptr, ptr %arrayidx47, align 8
  %call48 = call ptr @cliFormatReplyRaw(ptr noundef %58)
  store ptr %call48, ptr %tmp, align 8
  %59 = load ptr, ptr %out, align 8
  %60 = load ptr, ptr %tmp, align 8
  %61 = load ptr, ptr %tmp, align 8
  %call49 = call i64 @hi_sdslen(ptr noundef %61)
  %call50 = call ptr @hi_sdscatlen(ptr noundef %59, ptr noundef %60, i64 noundef %call49)
  store ptr %call50, ptr %out, align 8
  %62 = load ptr, ptr %tmp, align 8
  call void @hi_sdsfree(ptr noundef %62)
  %63 = load ptr, ptr %out, align 8
  %call51 = call ptr @hi_sdscatlen(ptr noundef %63, ptr noundef @.str.136, i64 noundef 1)
  store ptr %call51, ptr %out, align 8
  %64 = load ptr, ptr %r.addr, align 8
  %element52 = getelementptr inbounds %struct.redisReply, ptr %64, i32 0, i32 7
  %65 = load ptr, ptr %element52, align 8
  %66 = load i64, ptr %i, align 8
  %add = add i64 %66, 1
  %arrayidx53 = getelementptr inbounds ptr, ptr %65, i64 %add
  %67 = load ptr, ptr %arrayidx53, align 8
  %call54 = call ptr @cliFormatReplyRaw(ptr noundef %67)
  store ptr %call54, ptr %tmp, align 8
  %68 = load ptr, ptr %out, align 8
  %69 = load ptr, ptr %tmp, align 8
  %70 = load ptr, ptr %tmp, align 8
  %call55 = call i64 @hi_sdslen(ptr noundef %70)
  %call56 = call ptr @hi_sdscatlen(ptr noundef %68, ptr noundef %69, i64 noundef %call55)
  store ptr %call56, ptr %out, align 8
  %71 = load ptr, ptr %tmp, align 8
  call void @hi_sdsfree(ptr noundef %71)
  br label %for.inc57

for.inc57:                                        ; preds = %if.end45
  %72 = load i64, ptr %i, align 8
  %add58 = add i64 %72, 2
  store i64 %add58, ptr %i, align 8
  br label %for.cond38, !llvm.loop !217

for.end59:                                        ; preds = %for.cond38
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %73 = load ptr, ptr @stderr, align 8
  %74 = load ptr, ptr %r.addr, align 8
  %type60 = getelementptr inbounds %struct.redisReply, ptr %74, i32 0, i32 0
  %75 = load i32, ptr %type60, align 8
  %call61 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %73, ptr noundef @.str.425, i32 noundef %75)
  call void @exit(i32 noundef 1) #17
  unreachable

sw.epilog:                                        ; preds = %for.end59, %for.end, %sw.bb25, %sw.bb22, %sw.bb19, %if.end18, %sw.bb1, %sw.bb
  %76 = load ptr, ptr %out, align 8
  ret ptr %76
}

; Function Attrs: nounwind uwtable
define internal void @cliRefreshPrompt() #0 {
entry:
  %prompt = alloca ptr, align 8
  %addr = alloca [256 x i8], align 16
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %prompt, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %2 = load ptr, ptr %prompt, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 1), align 8
  %call2 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %2, ptr noundef @.str.426, ptr noundef %3)
  store ptr %call2, ptr %prompt, align 8
  br label %if.end8

if.else:                                          ; preds = %if.end
  %arraydecay = getelementptr inbounds [256 x i8], ptr %addr, i64 0, i64 0
  %4 = load ptr, ptr @config, align 8
  %5 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %call3 = call i32 @formatAddr(ptr noundef %arraydecay, i64 noundef 256, ptr noundef %4, i32 noundef %5)
  %6 = load ptr, ptr %prompt, align 8
  %arraydecay4 = getelementptr inbounds [256 x i8], ptr %addr, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [256 x i8], ptr %addr, i64 0, i64 0
  %call6 = call i64 @strlen(ptr noundef %arraydecay5) #12
  %call7 = call ptr @hi_sdscatlen(ptr noundef %6, ptr noundef %arraydecay4, i64 noundef %call6)
  store ptr %call7, ptr %prompt, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then1
  %7 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  %cmp9 = icmp ne i32 %7, 0
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %8 = load ptr, ptr %prompt, align 8
  %9 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  %call11 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %8, ptr noundef @.str.427, i32 noundef %9)
  store ptr %call11, ptr %prompt, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %10 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 60), align 8
  %tobool13 = icmp ne i32 %10, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %11 = load ptr, ptr %prompt, align 8
  %call15 = call ptr @hi_sdscatlen(ptr noundef %11, ptr noundef @.str.428, i64 noundef 4)
  store ptr %call15, ptr %prompt, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %12 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool17 = icmp ne i32 %12, 0
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end16
  %13 = load ptr, ptr %prompt, align 8
  %call19 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %13, ptr noundef @.str.429)
  store ptr %call19, ptr %prompt, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end16
  %14 = load ptr, ptr %prompt, align 8
  %call21 = call ptr @hi_sdscatlen(ptr noundef %14, ptr noundef @.str.430, i64 noundef 2)
  store ptr %call21, ptr %prompt, align 8
  %15 = load ptr, ptr %prompt, align 8
  %call22 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 45), i64 noundef 128, ptr noundef @.str.237, ptr noundef %15) #15
  %16 = load ptr, ptr %prompt, align 8
  call void @hi_sdsfree(ptr noundef %16)
  br label %return

return:                                           ; preds = %if.end20, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @formatAddr(ptr noundef %buf, i64 noundef %buf_len, ptr noundef %ip, i32 noundef %port) #0 {
entry:
  %buf.addr = alloca ptr, align 8
  %buf_len.addr = alloca i64, align 8
  %ip.addr = alloca ptr, align 8
  %port.addr = alloca i32, align 4
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %buf_len, ptr %buf_len.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i32 %port, ptr %port.addr, align 4
  %0 = load ptr, ptr %buf.addr, align 8
  %1 = load i64, ptr %buf_len.addr, align 8
  %2 = load ptr, ptr %ip.addr, align 8
  %call = call ptr @strchr(ptr noundef %2, i32 noundef 58) #12
  %tobool = icmp ne ptr %call, null
  %cond = select i1 %tobool, ptr @.str.431, ptr @.str.432
  %3 = load ptr, ptr %ip.addr, align 8
  %4 = load i32, ptr %port.addr, align 4
  %call1 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %0, i64 noundef %1, ptr noundef %cond, ptr noundef %3, i32 noundef %4) #15
  ret i32 %call1
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerNodeGetJSON(ptr noundef %node, i64 noundef %error_count) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %error_count.addr = alloca i64, align 8
  %json = alloca ptr, align 8
  %replicate = alloca ptr, align 8
  %slots = alloca ptr, align 8
  %flags = alloca ptr, align 8
  %p = alloca ptr, align 8
  %i = alloca i32, align 4
  %migrating17 = alloca ptr, align 8
  %slot = alloca ptr, align 8
  %dest = alloca ptr, align 8
  %i47 = alloca i32, align 4
  %importing48 = alloca ptr, align 8
  %slot54 = alloca ptr, align 8
  %from = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  store i64 %error_count, ptr %error_count.addr, align 8
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %json, align 8
  %call1 = call ptr @hi_sdsempty()
  store ptr %call1, ptr %replicate, align 8
  %0 = load ptr, ptr %node.addr, align 8
  %replicate2 = getelementptr inbounds %struct.clusterManagerNode, ptr %0, i32 0, i32 10
  %1 = load ptr, ptr %replicate2, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %replicate, align 8
  %3 = load ptr, ptr %node.addr, align 8
  %replicate3 = getelementptr inbounds %struct.clusterManagerNode, ptr %3, i32 0, i32 10
  %4 = load ptr, ptr %replicate3, align 8
  %call4 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %2, ptr noundef @.str.445, ptr noundef %4)
  store ptr %call4, ptr %replicate, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %replicate, align 8
  %call5 = call ptr @hi_sdscat(ptr noundef %5, ptr noundef @.str.446)
  store ptr %call5, ptr %replicate, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load ptr, ptr %node.addr, align 8
  %call6 = call ptr @clusterManagerNodeSlotsString(ptr noundef %6)
  store ptr %call6, ptr %slots, align 8
  %7 = load ptr, ptr %node.addr, align 8
  %call7 = call ptr @clusterManagerNodeFlagString(ptr noundef %7)
  store ptr %call7, ptr %flags, align 8
  %8 = load ptr, ptr %slots, align 8
  store ptr %8, ptr %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %9 = load ptr, ptr %p, align 8
  %call8 = call ptr @strchr(ptr noundef %9, i32 noundef 45) #12
  store ptr %call8, ptr %p, align 8
  %cmp = icmp ne ptr %call8, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  store i8 44, ptr %10, align 1
  br label %while.cond, !llvm.loop !218

while.end:                                        ; preds = %while.cond
  %11 = load ptr, ptr %json, align 8
  %12 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %name, align 8
  %14 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %ip, align 8
  %16 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %port, align 8
  %18 = load ptr, ptr %replicate, align 8
  %19 = load ptr, ptr %slots, align 8
  %20 = load ptr, ptr %node.addr, align 8
  %slots_count = getelementptr inbounds %struct.clusterManagerNode, ptr %20, i32 0, i32 13
  %21 = load i32, ptr %slots_count, align 4
  %22 = load ptr, ptr %flags, align 8
  %23 = load ptr, ptr %node.addr, align 8
  %current_epoch = getelementptr inbounds %struct.clusterManagerNode, ptr %23, i32 0, i32 5
  %24 = load i64, ptr %current_epoch, align 8
  %call9 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %11, ptr noundef @.str.447, ptr noundef %13, ptr noundef %15, i32 noundef %17, ptr noundef %18, ptr noundef %19, i32 noundef %21, ptr noundef %22, i64 noundef %24)
  store ptr %call9, ptr %json, align 8
  %25 = load i64, ptr %error_count.addr, align 8
  %cmp10 = icmp ugt i64 %25, 0
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %while.end
  %26 = load ptr, ptr %json, align 8
  %27 = load i64, ptr %error_count.addr, align 8
  %call12 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %26, ptr noundef @.str.448, i64 noundef %27)
  store ptr %call12, ptr %json, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %while.end
  %28 = load ptr, ptr %node.addr, align 8
  %migrating_count = getelementptr inbounds %struct.clusterManagerNode, ptr %28, i32 0, i32 18
  %29 = load i32, ptr %migrating_count, align 8
  %cmp14 = icmp sgt i32 %29, 0
  br i1 %cmp14, label %land.lhs.true, label %if.end42

land.lhs.true:                                    ; preds = %if.end13
  %30 = load ptr, ptr %node.addr, align 8
  %migrating = getelementptr inbounds %struct.clusterManagerNode, ptr %30, i32 0, i32 16
  %31 = load ptr, ptr %migrating, align 8
  %cmp15 = icmp ne ptr %31, null
  br i1 %cmp15, label %if.then16, label %if.end42

if.then16:                                        ; preds = %land.lhs.true
  store i32 0, ptr %i, align 4
  %call18 = call ptr @hi_sdsempty()
  store ptr %call18, ptr %migrating17, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then16
  %32 = load i32, ptr %i, align 4
  %33 = load ptr, ptr %node.addr, align 8
  %migrating_count19 = getelementptr inbounds %struct.clusterManagerNode, ptr %33, i32 0, i32 18
  %34 = load i32, ptr %migrating_count19, align 8
  %cmp20 = icmp slt i32 %32, %34
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load ptr, ptr %node.addr, align 8
  %migrating21 = getelementptr inbounds %struct.clusterManagerNode, ptr %35, i32 0, i32 16
  %36 = load ptr, ptr %migrating21, align 8
  %37 = load i32, ptr %i, align 4
  %idxprom = sext i32 %37 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %36, i64 %idxprom
  %38 = load ptr, ptr %arrayidx, align 8
  store ptr %38, ptr %slot, align 8
  %39 = load ptr, ptr %node.addr, align 8
  %migrating22 = getelementptr inbounds %struct.clusterManagerNode, ptr %39, i32 0, i32 16
  %40 = load ptr, ptr %migrating22, align 8
  %41 = load i32, ptr %i, align 4
  %add = add nsw i32 %41, 1
  %idxprom23 = sext i32 %add to i64
  %arrayidx24 = getelementptr inbounds ptr, ptr %40, i64 %idxprom23
  %42 = load ptr, ptr %arrayidx24, align 8
  store ptr %42, ptr %dest, align 8
  %43 = load ptr, ptr %slot, align 8
  %tobool25 = icmp ne ptr %43, null
  br i1 %tobool25, label %land.lhs.true26, label %if.end35

land.lhs.true26:                                  ; preds = %for.body
  %44 = load ptr, ptr %dest, align 8
  %tobool27 = icmp ne ptr %44, null
  br i1 %tobool27, label %if.then28, label %if.end35

if.then28:                                        ; preds = %land.lhs.true26
  %45 = load ptr, ptr %migrating17, align 8
  %call29 = call i64 @hi_sdslen(ptr noundef %45)
  %cmp30 = icmp ugt i64 %call29, 0
  br i1 %cmp30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.then28
  %46 = load ptr, ptr %migrating17, align 8
  %call32 = call ptr @hi_sdscat(ptr noundef %46, ptr noundef @.str.220)
  store ptr %call32, ptr %migrating17, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.then28
  %47 = load ptr, ptr %migrating17, align 8
  %48 = load ptr, ptr %slot, align 8
  %49 = load ptr, ptr %dest, align 8
  %call34 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %47, ptr noundef @.str.449, ptr noundef %48, ptr noundef %49)
  store ptr %call34, ptr %migrating17, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.end33, %land.lhs.true26, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end35
  %50 = load i32, ptr %i, align 4
  %add36 = add nsw i32 %50, 2
  store i32 %add36, ptr %i, align 4
  br label %for.cond, !llvm.loop !219

for.end:                                          ; preds = %for.cond
  %51 = load ptr, ptr %migrating17, align 8
  %call37 = call i64 @hi_sdslen(ptr noundef %51)
  %cmp38 = icmp ugt i64 %call37, 0
  br i1 %cmp38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %for.end
  %52 = load ptr, ptr %json, align 8
  %53 = load ptr, ptr %migrating17, align 8
  %call40 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %52, ptr noundef @.str.450, ptr noundef %53)
  store ptr %call40, ptr %json, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %for.end
  %54 = load ptr, ptr %migrating17, align 8
  call void @hi_sdsfree(ptr noundef %54)
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %land.lhs.true, %if.end13
  %55 = load ptr, ptr %node.addr, align 8
  %importing_count = getelementptr inbounds %struct.clusterManagerNode, ptr %55, i32 0, i32 19
  %56 = load i32, ptr %importing_count, align 4
  %cmp43 = icmp sgt i32 %56, 0
  br i1 %cmp43, label %land.lhs.true44, label %if.end81

land.lhs.true44:                                  ; preds = %if.end42
  %57 = load ptr, ptr %node.addr, align 8
  %importing = getelementptr inbounds %struct.clusterManagerNode, ptr %57, i32 0, i32 17
  %58 = load ptr, ptr %importing, align 8
  %cmp45 = icmp ne ptr %58, null
  br i1 %cmp45, label %if.then46, label %if.end81

if.then46:                                        ; preds = %land.lhs.true44
  store i32 0, ptr %i47, align 4
  %call49 = call ptr @hi_sdsempty()
  store ptr %call49, ptr %importing48, align 8
  br label %for.cond50

for.cond50:                                       ; preds = %for.inc73, %if.then46
  %59 = load i32, ptr %i47, align 4
  %60 = load ptr, ptr %node.addr, align 8
  %importing_count51 = getelementptr inbounds %struct.clusterManagerNode, ptr %60, i32 0, i32 19
  %61 = load i32, ptr %importing_count51, align 4
  %cmp52 = icmp slt i32 %59, %61
  br i1 %cmp52, label %for.body53, label %for.end75

for.body53:                                       ; preds = %for.cond50
  %62 = load ptr, ptr %node.addr, align 8
  %importing55 = getelementptr inbounds %struct.clusterManagerNode, ptr %62, i32 0, i32 17
  %63 = load ptr, ptr %importing55, align 8
  %64 = load i32, ptr %i47, align 4
  %idxprom56 = sext i32 %64 to i64
  %arrayidx57 = getelementptr inbounds ptr, ptr %63, i64 %idxprom56
  %65 = load ptr, ptr %arrayidx57, align 8
  store ptr %65, ptr %slot54, align 8
  %66 = load ptr, ptr %node.addr, align 8
  %importing58 = getelementptr inbounds %struct.clusterManagerNode, ptr %66, i32 0, i32 17
  %67 = load ptr, ptr %importing58, align 8
  %68 = load i32, ptr %i47, align 4
  %add59 = add nsw i32 %68, 1
  %idxprom60 = sext i32 %add59 to i64
  %arrayidx61 = getelementptr inbounds ptr, ptr %67, i64 %idxprom60
  %69 = load ptr, ptr %arrayidx61, align 8
  store ptr %69, ptr %from, align 8
  %70 = load ptr, ptr %slot54, align 8
  %tobool62 = icmp ne ptr %70, null
  br i1 %tobool62, label %land.lhs.true63, label %if.end72

land.lhs.true63:                                  ; preds = %for.body53
  %71 = load ptr, ptr %from, align 8
  %tobool64 = icmp ne ptr %71, null
  br i1 %tobool64, label %if.then65, label %if.end72

if.then65:                                        ; preds = %land.lhs.true63
  %72 = load ptr, ptr %importing48, align 8
  %call66 = call i64 @hi_sdslen(ptr noundef %72)
  %cmp67 = icmp ugt i64 %call66, 0
  br i1 %cmp67, label %if.then68, label %if.end70

if.then68:                                        ; preds = %if.then65
  %73 = load ptr, ptr %importing48, align 8
  %call69 = call ptr @hi_sdscat(ptr noundef %73, ptr noundef @.str.220)
  store ptr %call69, ptr %importing48, align 8
  br label %if.end70

if.end70:                                         ; preds = %if.then68, %if.then65
  %74 = load ptr, ptr %importing48, align 8
  %75 = load ptr, ptr %slot54, align 8
  %76 = load ptr, ptr %from, align 8
  %call71 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %74, ptr noundef @.str.449, ptr noundef %75, ptr noundef %76)
  store ptr %call71, ptr %importing48, align 8
  br label %if.end72

if.end72:                                         ; preds = %if.end70, %land.lhs.true63, %for.body53
  br label %for.inc73

for.inc73:                                        ; preds = %if.end72
  %77 = load i32, ptr %i47, align 4
  %add74 = add nsw i32 %77, 2
  store i32 %add74, ptr %i47, align 4
  br label %for.cond50, !llvm.loop !220

for.end75:                                        ; preds = %for.cond50
  %78 = load ptr, ptr %importing48, align 8
  %call76 = call i64 @hi_sdslen(ptr noundef %78)
  %cmp77 = icmp ugt i64 %call76, 0
  br i1 %cmp77, label %if.then78, label %if.end80

if.then78:                                        ; preds = %for.end75
  %79 = load ptr, ptr %json, align 8
  %80 = load ptr, ptr %importing48, align 8
  %call79 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %79, ptr noundef @.str.451, ptr noundef %80)
  store ptr %call79, ptr %json, align 8
  br label %if.end80

if.end80:                                         ; preds = %if.then78, %for.end75
  %81 = load ptr, ptr %importing48, align 8
  call void @hi_sdsfree(ptr noundef %81)
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %land.lhs.true44, %if.end42
  %82 = load ptr, ptr %json, align 8
  %call82 = call ptr @hi_sdscat(ptr noundef %82, ptr noundef @.str.452)
  store ptr %call82, ptr %json, align 8
  %83 = load ptr, ptr %replicate, align 8
  call void @hi_sdsfree(ptr noundef %83)
  %84 = load ptr, ptr %slots, align 8
  call void @hi_sdsfree(ptr noundef %84)
  %85 = load ptr, ptr %flags, align 8
  call void @hi_sdsfree(ptr noundef %85)
  %86 = load ptr, ptr %json, align 8
  ret ptr %86
}

declare i32 @fputs(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @cliLegacyInitHelp(ptr noundef %groups) #0 {
entry:
  %groups.addr = alloca ptr, align 8
  %serverVersion = alloca ptr, align 8
  store ptr %groups, ptr %groups.addr, align 8
  %call = call ptr @cliGetServerVersion()
  store ptr %call, ptr %serverVersion, align 8
  %0 = load ptr, ptr %serverVersion, align 8
  %call1 = call i64 @cliLegacyCountCommands(ptr noundef @redisCommandTable, ptr noundef %0)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, ptr @helpEntriesLen, align 4
  %1 = load i32, ptr @helpEntriesLen, align 4
  %conv2 = sext i32 %1 to i64
  %mul = mul i64 88, %conv2
  %call3 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call3, ptr @helpEntries, align 8
  %2 = load ptr, ptr %groups.addr, align 8
  %3 = load ptr, ptr %serverVersion, align 8
  %call4 = call i32 @cliLegacyInitCommandHelpEntries(ptr noundef @redisCommandTable, ptr noundef %2, ptr noundef %3)
  store i32 %call4, ptr @helpEntriesLen, align 4
  %4 = load ptr, ptr %groups.addr, align 8
  call void @cliInitGroupHelpEntries(ptr noundef %4)
  %5 = load ptr, ptr @helpEntries, align 8
  %6 = load i32, ptr @helpEntriesLen, align 4
  %conv5 = sext i32 %6 to i64
  call void @qsort(ptr noundef %5, i64 noundef %conv5, i64 noundef 88, ptr noundef @helpEntryCompare)
  %7 = load ptr, ptr %groups.addr, align 8
  call void @dictRelease(ptr noundef %7)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cliLegacyIntegrateHelp() #0 {
entry:
  %reply = alloca ptr, align 8
  %j = alloca i64, align 8
  %entry7 = alloca ptr, align 8
  %cmdname = alloca ptr, align 8
  %i = alloca i32, align 4
  %he = alloca ptr, align 8
  %new = alloca ptr, align 8
  %args62 = alloca i32, align 4
  %call = call i32 @cliConnect(i32 noundef 2)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %0 = load ptr, ptr @context, align 8
  %call1 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %0, ptr noundef @.str.461)
  store ptr %call1, ptr %reply, align 8
  %1 = load ptr, ptr %reply, align 8
  %cmp2 = icmp eq ptr %1, null
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %2 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %type, align 8
  %cmp3 = icmp ne i32 %3, 2
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  store i64 0, ptr %j, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc102, %if.end5
  %4 = load i64, ptr %j, align 8
  %5 = load ptr, ptr %reply, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 6
  %6 = load i64, ptr %elements, align 8
  %cmp6 = icmp ult i64 %4, %6
  br i1 %cmp6, label %for.body, label %for.end104

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 7
  %8 = load ptr, ptr %element, align 8
  %9 = load i64, ptr %j, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %8, i64 %9
  %10 = load ptr, ptr %arrayidx, align 8
  store ptr %10, ptr %entry7, align 8
  %11 = load ptr, ptr %entry7, align 8
  %type8 = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type8, align 8
  %cmp9 = icmp ne i32 %12, 2
  br i1 %cmp9, label %if.then28, label %lor.lhs.false10

lor.lhs.false10:                                  ; preds = %for.body
  %13 = load ptr, ptr %entry7, align 8
  %elements11 = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 6
  %14 = load i64, ptr %elements11, align 8
  %cmp12 = icmp ult i64 %14, 4
  br i1 %cmp12, label %if.then28, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false10
  %15 = load ptr, ptr %entry7, align 8
  %element14 = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 7
  %16 = load ptr, ptr %element14, align 8
  %arrayidx15 = getelementptr inbounds ptr, ptr %16, i64 0
  %17 = load ptr, ptr %arrayidx15, align 8
  %type16 = getelementptr inbounds %struct.redisReply, ptr %17, i32 0, i32 0
  %18 = load i32, ptr %type16, align 8
  %cmp17 = icmp ne i32 %18, 1
  br i1 %cmp17, label %if.then28, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %lor.lhs.false13
  %19 = load ptr, ptr %entry7, align 8
  %element19 = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 7
  %20 = load ptr, ptr %element19, align 8
  %arrayidx20 = getelementptr inbounds ptr, ptr %20, i64 1
  %21 = load ptr, ptr %arrayidx20, align 8
  %type21 = getelementptr inbounds %struct.redisReply, ptr %21, i32 0, i32 0
  %22 = load i32, ptr %type21, align 8
  %cmp22 = icmp ne i32 %22, 3
  br i1 %cmp22, label %if.then28, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %lor.lhs.false18
  %23 = load ptr, ptr %entry7, align 8
  %element24 = getelementptr inbounds %struct.redisReply, ptr %23, i32 0, i32 7
  %24 = load ptr, ptr %element24, align 8
  %arrayidx25 = getelementptr inbounds ptr, ptr %24, i64 3
  %25 = load ptr, ptr %arrayidx25, align 8
  %type26 = getelementptr inbounds %struct.redisReply, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %type26, align 8
  %cmp27 = icmp ne i32 %26, 3
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %lor.lhs.false23, %lor.lhs.false18, %lor.lhs.false13, %lor.lhs.false10, %for.body
  br label %return

if.end29:                                         ; preds = %lor.lhs.false23
  %27 = load ptr, ptr %entry7, align 8
  %element30 = getelementptr inbounds %struct.redisReply, ptr %27, i32 0, i32 7
  %28 = load ptr, ptr %element30, align 8
  %arrayidx31 = getelementptr inbounds ptr, ptr %28, i64 0
  %29 = load ptr, ptr %arrayidx31, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %29, i32 0, i32 4
  %30 = load ptr, ptr %str, align 8
  store ptr %30, ptr %cmdname, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond32

for.cond32:                                       ; preds = %for.inc, %if.end29
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr @helpEntriesLen, align 4
  %cmp33 = icmp slt i32 %31, %32
  br i1 %cmp33, label %for.body34, label %for.end

for.body34:                                       ; preds = %for.cond32
  %33 = load ptr, ptr @helpEntries, align 8
  %34 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %34 to i64
  %add.ptr = getelementptr inbounds %struct.helpEntry, ptr %33, i64 %idx.ext
  store ptr %add.ptr, ptr %he, align 8
  %35 = load ptr, ptr %he, align 8
  %argv = getelementptr inbounds %struct.helpEntry, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %argv, align 8
  %arrayidx35 = getelementptr inbounds ptr, ptr %36, i64 0
  %37 = load ptr, ptr %arrayidx35, align 8
  %38 = load ptr, ptr %cmdname, align 8
  %call36 = call i32 @strcasecmp(ptr noundef %37, ptr noundef %38) #12
  %tobool = icmp ne i32 %call36, 0
  br i1 %tobool, label %if.end38, label %if.then37

if.then37:                                        ; preds = %for.body34
  br label %for.end

if.end38:                                         ; preds = %for.body34
  br label %for.inc

for.inc:                                          ; preds = %if.end38
  %39 = load i32, ptr %i, align 4
  %inc = add nsw i32 %39, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond32, !llvm.loop !221

for.end:                                          ; preds = %if.then37, %for.cond32
  %40 = load i32, ptr %i, align 4
  %41 = load i32, ptr @helpEntriesLen, align 4
  %cmp39 = icmp ne i32 %40, %41
  br i1 %cmp39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %for.end
  br label %for.inc102

if.end41:                                         ; preds = %for.end
  %42 = load i32, ptr @helpEntriesLen, align 4
  %inc42 = add nsw i32 %42, 1
  store i32 %inc42, ptr @helpEntriesLen, align 4
  %43 = load ptr, ptr @helpEntries, align 8
  %44 = load i32, ptr @helpEntriesLen, align 4
  %conv = sext i32 %44 to i64
  %mul = mul i64 88, %conv
  %call43 = call ptr @zrealloc(ptr noundef %43, i64 noundef %mul) #13
  store ptr %call43, ptr @helpEntries, align 8
  %45 = load ptr, ptr @helpEntries, align 8
  %46 = load i32, ptr @helpEntriesLen, align 4
  %sub = sub nsw i32 %46, 1
  %idx.ext44 = sext i32 %sub to i64
  %add.ptr45 = getelementptr inbounds %struct.helpEntry, ptr %45, i64 %idx.ext44
  store ptr %add.ptr45, ptr %new, align 8
  %47 = load ptr, ptr %new, align 8
  %argc = getelementptr inbounds %struct.helpEntry, ptr %47, i32 0, i32 1
  store i32 1, ptr %argc, align 4
  %call46 = call noalias ptr @zmalloc(i64 noundef 8) #14
  %48 = load ptr, ptr %new, align 8
  %argv47 = getelementptr inbounds %struct.helpEntry, ptr %48, i32 0, i32 2
  store ptr %call46, ptr %argv47, align 8
  %49 = load ptr, ptr %cmdname, align 8
  %call48 = call ptr @hi_sdsnew(ptr noundef %49)
  %50 = load ptr, ptr %new, align 8
  %argv49 = getelementptr inbounds %struct.helpEntry, ptr %50, i32 0, i32 2
  %51 = load ptr, ptr %argv49, align 8
  %arrayidx50 = getelementptr inbounds ptr, ptr %51, i64 0
  store ptr %call48, ptr %arrayidx50, align 8
  %52 = load ptr, ptr %new, align 8
  %argv51 = getelementptr inbounds %struct.helpEntry, ptr %52, i32 0, i32 2
  %53 = load ptr, ptr %argv51, align 8
  %arrayidx52 = getelementptr inbounds ptr, ptr %53, i64 0
  %54 = load ptr, ptr %arrayidx52, align 8
  %55 = load ptr, ptr %new, align 8
  %full = getelementptr inbounds %struct.helpEntry, ptr %55, i32 0, i32 3
  store ptr %54, ptr %full, align 8
  %56 = load ptr, ptr %new, align 8
  %type53 = getelementptr inbounds %struct.helpEntry, ptr %56, i32 0, i32 0
  store i32 1, ptr %type53, align 8
  %57 = load ptr, ptr %new, align 8
  %argv54 = getelementptr inbounds %struct.helpEntry, ptr %57, i32 0, i32 2
  %58 = load ptr, ptr %argv54, align 8
  %arrayidx55 = getelementptr inbounds ptr, ptr %58, i64 0
  %59 = load ptr, ptr %arrayidx55, align 8
  call void @hi_sdstoupper(ptr noundef %59)
  %60 = load ptr, ptr %new, align 8
  %argv56 = getelementptr inbounds %struct.helpEntry, ptr %60, i32 0, i32 2
  %61 = load ptr, ptr %argv56, align 8
  %arrayidx57 = getelementptr inbounds ptr, ptr %61, i64 0
  %62 = load ptr, ptr %arrayidx57, align 8
  %63 = load ptr, ptr %new, align 8
  %docs = getelementptr inbounds %struct.helpEntry, ptr %63, i32 0, i32 4
  %name = getelementptr inbounds %struct.commandDocs, ptr %docs, i32 0, i32 0
  store ptr %62, ptr %name, align 8
  %64 = load ptr, ptr %new, align 8
  %docs58 = getelementptr inbounds %struct.helpEntry, ptr %64, i32 0, i32 4
  %args = getelementptr inbounds %struct.commandDocs, ptr %docs58, i32 0, i32 5
  store ptr null, ptr %args, align 8
  %65 = load ptr, ptr %new, align 8
  %docs59 = getelementptr inbounds %struct.helpEntry, ptr %65, i32 0, i32 4
  %numargs = getelementptr inbounds %struct.commandDocs, ptr %docs59, i32 0, i32 4
  store i32 0, ptr %numargs, align 8
  %call60 = call ptr @hi_sdsempty()
  %66 = load ptr, ptr %new, align 8
  %docs61 = getelementptr inbounds %struct.helpEntry, ptr %66, i32 0, i32 4
  %params = getelementptr inbounds %struct.commandDocs, ptr %docs61, i32 0, i32 7
  store ptr %call60, ptr %params, align 8
  %67 = load ptr, ptr %entry7, align 8
  %element63 = getelementptr inbounds %struct.redisReply, ptr %67, i32 0, i32 7
  %68 = load ptr, ptr %element63, align 8
  %arrayidx64 = getelementptr inbounds ptr, ptr %68, i64 1
  %69 = load ptr, ptr %arrayidx64, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %69, i32 0, i32 1
  %70 = load i64, ptr %integer, align 8
  %71 = call i64 @llvm.abs.i64(i64 %70, i1 true)
  %conv65 = trunc i64 %71 to i32
  store i32 %conv65, ptr %args62, align 4
  %72 = load i32, ptr %args62, align 4
  %dec = add nsw i32 %72, -1
  store i32 %dec, ptr %args62, align 4
  %73 = load ptr, ptr %entry7, align 8
  %element66 = getelementptr inbounds %struct.redisReply, ptr %73, i32 0, i32 7
  %74 = load ptr, ptr %element66, align 8
  %arrayidx67 = getelementptr inbounds ptr, ptr %74, i64 3
  %75 = load ptr, ptr %arrayidx67, align 8
  %integer68 = getelementptr inbounds %struct.redisReply, ptr %75, i32 0, i32 1
  %76 = load i64, ptr %integer68, align 8
  %cmp69 = icmp eq i64 %76, 1
  br i1 %cmp69, label %if.then71, label %if.end78

if.then71:                                        ; preds = %if.end41
  %77 = load ptr, ptr %new, align 8
  %docs72 = getelementptr inbounds %struct.helpEntry, ptr %77, i32 0, i32 4
  %params73 = getelementptr inbounds %struct.commandDocs, ptr %docs72, i32 0, i32 7
  %78 = load ptr, ptr %params73, align 8
  %call74 = call ptr @hi_sdscat(ptr noundef %78, ptr noundef @.str.462)
  %79 = load ptr, ptr %new, align 8
  %docs75 = getelementptr inbounds %struct.helpEntry, ptr %79, i32 0, i32 4
  %params76 = getelementptr inbounds %struct.commandDocs, ptr %docs75, i32 0, i32 7
  store ptr %call74, ptr %params76, align 8
  %80 = load i32, ptr %args62, align 4
  %dec77 = add nsw i32 %80, -1
  store i32 %dec77, ptr %args62, align 4
  br label %if.end78

if.end78:                                         ; preds = %if.then71, %if.end41
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end78
  %81 = load i32, ptr %args62, align 4
  %dec79 = add nsw i32 %81, -1
  store i32 %dec79, ptr %args62, align 4
  %cmp80 = icmp sgt i32 %81, 0
  br i1 %cmp80, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %82 = load ptr, ptr %new, align 8
  %docs82 = getelementptr inbounds %struct.helpEntry, ptr %82, i32 0, i32 4
  %params83 = getelementptr inbounds %struct.commandDocs, ptr %docs82, i32 0, i32 7
  %83 = load ptr, ptr %params83, align 8
  %call84 = call ptr @hi_sdscat(ptr noundef %83, ptr noundef @.str.463)
  %84 = load ptr, ptr %new, align 8
  %docs85 = getelementptr inbounds %struct.helpEntry, ptr %84, i32 0, i32 4
  %params86 = getelementptr inbounds %struct.commandDocs, ptr %docs85, i32 0, i32 7
  store ptr %call84, ptr %params86, align 8
  br label %while.cond, !llvm.loop !222

while.end:                                        ; preds = %while.cond
  %85 = load ptr, ptr %entry7, align 8
  %element87 = getelementptr inbounds %struct.redisReply, ptr %85, i32 0, i32 7
  %86 = load ptr, ptr %element87, align 8
  %arrayidx88 = getelementptr inbounds ptr, ptr %86, i64 1
  %87 = load ptr, ptr %arrayidx88, align 8
  %integer89 = getelementptr inbounds %struct.redisReply, ptr %87, i32 0, i32 1
  %88 = load i64, ptr %integer89, align 8
  %cmp90 = icmp slt i64 %88, 0
  br i1 %cmp90, label %if.then92, label %if.end98

if.then92:                                        ; preds = %while.end
  %89 = load ptr, ptr %new, align 8
  %docs93 = getelementptr inbounds %struct.helpEntry, ptr %89, i32 0, i32 4
  %params94 = getelementptr inbounds %struct.commandDocs, ptr %docs93, i32 0, i32 7
  %90 = load ptr, ptr %params94, align 8
  %call95 = call ptr @hi_sdscat(ptr noundef %90, ptr noundef @.str.464)
  %91 = load ptr, ptr %new, align 8
  %docs96 = getelementptr inbounds %struct.helpEntry, ptr %91, i32 0, i32 4
  %params97 = getelementptr inbounds %struct.commandDocs, ptr %docs96, i32 0, i32 7
  store ptr %call95, ptr %params97, align 8
  br label %if.end98

if.end98:                                         ; preds = %if.then92, %while.end
  %92 = load ptr, ptr %new, align 8
  %docs99 = getelementptr inbounds %struct.helpEntry, ptr %92, i32 0, i32 4
  %summary = getelementptr inbounds %struct.commandDocs, ptr %docs99, i32 0, i32 1
  store ptr @.str.465, ptr %summary, align 8
  %93 = load ptr, ptr %new, align 8
  %docs100 = getelementptr inbounds %struct.helpEntry, ptr %93, i32 0, i32 4
  %since = getelementptr inbounds %struct.commandDocs, ptr %docs100, i32 0, i32 3
  store ptr @.str.466, ptr %since, align 8
  %94 = load ptr, ptr %new, align 8
  %docs101 = getelementptr inbounds %struct.helpEntry, ptr %94, i32 0, i32 4
  %group = getelementptr inbounds %struct.commandDocs, ptr %docs101, i32 0, i32 2
  store ptr @.str.467, ptr %group, align 8
  br label %for.inc102

for.inc102:                                       ; preds = %if.end98, %if.then40
  %95 = load i64, ptr %j, align 8
  %inc103 = add i64 %95, 1
  store i64 %inc103, ptr %j, align 8
  br label %for.cond, !llvm.loop !223

for.end104:                                       ; preds = %for.cond
  %96 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %96)
  br label %return

return:                                           ; preds = %for.end104, %if.then28, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @cliCountCommands(ptr noundef %commandTable) #0 {
entry:
  %commandTable.addr = alloca ptr, align 8
  %numCommands = alloca i64, align 8
  %i = alloca i64, align 8
  %map = alloca ptr, align 8
  %j = alloca i64, align 8
  %key = alloca ptr, align 8
  %subcommands = alloca ptr, align 8
  store ptr %commandTable, ptr %commandTable.addr, align 8
  %0 = load ptr, ptr %commandTable.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 6
  %1 = load i64, ptr %elements, align 8
  %div = udiv i64 %1, 2
  store i64 %div, ptr %numCommands, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc15, %entry
  %2 = load i64, ptr %i, align 8
  %3 = load ptr, ptr %commandTable.addr, align 8
  %elements1 = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 6
  %4 = load i64, ptr %elements1, align 8
  %cmp = icmp ult i64 %2, %4
  br i1 %cmp, label %for.body, label %for.end17

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %commandTable.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 7
  %6 = load ptr, ptr %element, align 8
  %7 = load i64, ptr %i, align 8
  %add = add i64 %7, 1
  %arrayidx = getelementptr inbounds ptr, ptr %6, i64 %add
  %8 = load ptr, ptr %arrayidx, align 8
  store ptr %8, ptr %map, align 8
  store i64 0, ptr %j, align 8
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %9 = load i64, ptr %j, align 8
  %10 = load ptr, ptr %map, align 8
  %elements3 = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 6
  %11 = load i64, ptr %elements3, align 8
  %cmp4 = icmp ult i64 %9, %11
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond2
  %12 = load ptr, ptr %map, align 8
  %element6 = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 7
  %13 = load ptr, ptr %element6, align 8
  %14 = load i64, ptr %j, align 8
  %arrayidx7 = getelementptr inbounds ptr, ptr %13, i64 %14
  %15 = load ptr, ptr %arrayidx7, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %str, align 8
  store ptr %16, ptr %key, align 8
  %17 = load ptr, ptr %key, align 8
  %call = call i32 @strcmp(ptr noundef %17, ptr noundef @.str.135) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body5
  %18 = load ptr, ptr %map, align 8
  %element8 = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 7
  %19 = load ptr, ptr %element8, align 8
  %20 = load i64, ptr %j, align 8
  %add9 = add i64 %20, 1
  %arrayidx10 = getelementptr inbounds ptr, ptr %19, i64 %add9
  %21 = load ptr, ptr %arrayidx10, align 8
  store ptr %21, ptr %subcommands, align 8
  %22 = load ptr, ptr %subcommands, align 8
  %elements11 = getelementptr inbounds %struct.redisReply, ptr %22, i32 0, i32 6
  %23 = load i64, ptr %elements11, align 8
  %div12 = udiv i64 %23, 2
  %24 = load i64, ptr %numCommands, align 8
  %add13 = add i64 %24, %div12
  store i64 %add13, ptr %numCommands, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body5
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %25 = load i64, ptr %j, align 8
  %add14 = add i64 %25, 2
  store i64 %add14, ptr %j, align 8
  br label %for.cond2, !llvm.loop !224

for.end:                                          ; preds = %for.cond2
  br label %for.inc15

for.inc15:                                        ; preds = %for.end
  %26 = load i64, ptr %i, align 8
  %add16 = add i64 %26, 2
  store i64 %add16, ptr %i, align 8
  br label %for.cond, !llvm.loop !225

for.end17:                                        ; preds = %for.cond
  %27 = load i64, ptr %numCommands, align 8
  ret i64 %27
}

; Function Attrs: nounwind uwtable
define internal ptr @cliGetServerVersion() #0 {
entry:
  %retval = alloca ptr, align 8
  %serverInfo = alloca ptr, align 8
  %pos = alloca ptr, align 8
  %info = alloca ptr, align 8
  %end = alloca ptr, align 8
  %version = alloca ptr, align 8
  store ptr null, ptr %serverInfo, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 62), align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 62), align 8
  store ptr %1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr @context, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr @context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %3, ptr noundef @.str.460)
  store ptr %call, ptr %serverInfo, align 8
  %4 = load ptr, ptr %serverInfo, align 8
  %cmp3 = icmp eq ptr %4, null
  br i1 %cmp3, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end2
  %5 = load ptr, ptr %serverInfo, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type, align 8
  %cmp4 = icmp eq i32 %6, 6
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %lor.lhs.false, %if.end2
  %7 = load ptr, ptr %serverInfo, align 8
  call void @freeReplyObject(ptr noundef %7)
  %call6 = call ptr @hi_sdsempty()
  store ptr %call6, ptr %retval, align 8
  br label %return

if.end7:                                          ; preds = %lor.lhs.false
  %8 = load ptr, ptr %serverInfo, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %str, align 8
  store ptr %9, ptr %info, align 8
  %10 = load ptr, ptr %info, align 8
  %11 = load ptr, ptr @cliGetServerVersion.key, align 8
  %call8 = call ptr @strstr(ptr noundef %10, ptr noundef %11) #12
  store ptr %call8, ptr %pos, align 8
  %12 = load ptr, ptr %pos, align 8
  %tobool9 = icmp ne ptr %12, null
  br i1 %tobool9, label %if.then10, label %if.end17

if.then10:                                        ; preds = %if.end7
  %13 = load ptr, ptr @cliGetServerVersion.key, align 8
  %call11 = call i64 @strlen(ptr noundef %13) #12
  %14 = load ptr, ptr %pos, align 8
  %add.ptr = getelementptr inbounds i8, ptr %14, i64 %call11
  store ptr %add.ptr, ptr %pos, align 8
  %15 = load ptr, ptr %pos, align 8
  %call12 = call ptr @strchr(ptr noundef %15, i32 noundef 13) #12
  store ptr %call12, ptr %end, align 8
  %16 = load ptr, ptr %end, align 8
  %tobool13 = icmp ne ptr %16, null
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.then10
  %17 = load ptr, ptr %pos, align 8
  %18 = load ptr, ptr %end, align 8
  %19 = load ptr, ptr %pos, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %18 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %19 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call15 = call ptr @hi_sdsnewlen(ptr noundef %17, i64 noundef %sub.ptr.sub)
  store ptr %call15, ptr %version, align 8
  %20 = load ptr, ptr %serverInfo, align 8
  call void @freeReplyObject(ptr noundef %20)
  %21 = load ptr, ptr %version, align 8
  store ptr %21, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 62), align 8
  %22 = load ptr, ptr %version, align 8
  store ptr %22, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.then10
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end7
  %23 = load ptr, ptr %serverInfo, align 8
  call void @freeReplyObject(ptr noundef %23)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then14, %if.then5, %if.then1, %if.then
  %24 = load ptr, ptr %retval, align 8
  ret ptr %24
}

; Function Attrs: nounwind uwtable
define internal i64 @cliLegacyCountCommands(ptr noundef %commands, ptr noundef %version) #0 {
entry:
  %commands.addr = alloca ptr, align 8
  %version.addr = alloca ptr, align 8
  %numCommands = alloca i32, align 4
  %i = alloca i64, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store ptr %version, ptr %version.addr, align 8
  store i32 0, ptr %numCommands, align 4
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load ptr, ptr %commands.addr, align 8
  %1 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.commandDocs, ptr %0, i64 %1
  %name = getelementptr inbounds %struct.commandDocs, ptr %arrayidx, i32 0, i32 0
  %2 = load ptr, ptr %name, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %version.addr, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %4 = load ptr, ptr %version.addr, align 8
  %5 = load ptr, ptr %commands.addr, align 8
  %6 = load i64, ptr %i, align 8
  %arrayidx1 = getelementptr inbounds %struct.commandDocs, ptr %5, i64 %6
  %since = getelementptr inbounds %struct.commandDocs, ptr %arrayidx1, i32 0, i32 3
  %7 = load ptr, ptr %since, align 8
  %call = call i32 @versionIsSupported(ptr noundef %4, ptr noundef %7)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %8 = load i32, ptr %numCommands, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %numCommands, align 4
  %9 = load ptr, ptr %commands.addr, align 8
  %10 = load i64, ptr %i, align 8
  %arrayidx3 = getelementptr inbounds %struct.commandDocs, ptr %9, i64 %10
  %subcommands = getelementptr inbounds %struct.commandDocs, ptr %arrayidx3, i32 0, i32 6
  %11 = load ptr, ptr %subcommands, align 8
  %cmp4 = icmp ne ptr %11, null
  br i1 %cmp4, label %if.then5, label %if.end10

if.then5:                                         ; preds = %if.end
  %12 = load ptr, ptr %commands.addr, align 8
  %13 = load i64, ptr %i, align 8
  %arrayidx6 = getelementptr inbounds %struct.commandDocs, ptr %12, i64 %13
  %subcommands7 = getelementptr inbounds %struct.commandDocs, ptr %arrayidx6, i32 0, i32 6
  %14 = load ptr, ptr %subcommands7, align 8
  %15 = load ptr, ptr %version.addr, align 8
  %call8 = call i64 @cliLegacyCountCommands(ptr noundef %14, ptr noundef %15)
  %16 = load i32, ptr %numCommands, align 4
  %conv = sext i32 %16 to i64
  %add = add i64 %conv, %call8
  %conv9 = trunc i64 %add to i32
  store i32 %conv9, ptr %numCommands, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then5, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end10, %if.then
  %17 = load i64, ptr %i, align 8
  %inc11 = add i64 %17, 1
  store i64 %inc11, ptr %i, align 8
  br label %for.cond, !llvm.loop !226

for.end:                                          ; preds = %for.cond
  %18 = load i32, ptr %numCommands, align 4
  %conv12 = sext i32 %18 to i64
  ret i64 %conv12
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.abs.i64(i64, i1 immarg) #8

; Function Attrs: nounwind uwtable
define internal ptr @findHelpEntry(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %entry1 = alloca ptr, align 8
  %i = alloca i32, align 4
  %rawargc = alloca i32, align 4
  %matchlen = alloca i32, align 4
  %rawargv = alloca ptr, align 8
  %j = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store ptr null, ptr %entry1, align 8
  store i32 0, ptr %matchlen, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc27, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr @helpEntriesLen, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end29

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr @helpEntries, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.helpEntry, ptr %2, i64 %idxprom
  %type = getelementptr inbounds %struct.helpEntry, ptr %arrayidx, i32 0, i32 0
  %4 = load i32, ptr %type, align 8
  %and = and i32 %4, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc27

if.end:                                           ; preds = %for.body
  %5 = load ptr, ptr @helpEntries, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds %struct.helpEntry, ptr %5, i64 %idxprom2
  %argv4 = getelementptr inbounds %struct.helpEntry, ptr %arrayidx3, i32 0, i32 2
  %7 = load ptr, ptr %argv4, align 8
  store ptr %7, ptr %rawargv, align 8
  %8 = load ptr, ptr @helpEntries, align 8
  %9 = load i32, ptr %i, align 4
  %idxprom5 = sext i32 %9 to i64
  %arrayidx6 = getelementptr inbounds %struct.helpEntry, ptr %8, i64 %idxprom5
  %argc7 = getelementptr inbounds %struct.helpEntry, ptr %arrayidx6, i32 0, i32 1
  %10 = load i32, ptr %argc7, align 4
  store i32 %10, ptr %rawargc, align 4
  %11 = load i32, ptr %rawargc, align 4
  %12 = load i32, ptr %argc.addr, align 4
  %cmp8 = icmp sle i32 %11, %12
  br i1 %cmp8, label %if.then9, label %if.end26

if.then9:                                         ; preds = %if.end
  store i32 0, ptr %j, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc, %if.then9
  %13 = load i32, ptr %j, align 4
  %14 = load i32, ptr %rawargc, align 4
  %cmp11 = icmp slt i32 %13, %14
  br i1 %cmp11, label %for.body12, label %for.end

for.body12:                                       ; preds = %for.cond10
  %15 = load ptr, ptr %rawargv, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom13 = sext i32 %16 to i64
  %arrayidx14 = getelementptr inbounds ptr, ptr %15, i64 %idxprom13
  %17 = load ptr, ptr %arrayidx14, align 8
  %18 = load ptr, ptr %argv.addr, align 8
  %19 = load i32, ptr %j, align 4
  %idxprom15 = sext i32 %19 to i64
  %arrayidx16 = getelementptr inbounds ptr, ptr %18, i64 %idxprom15
  %20 = load ptr, ptr %arrayidx16, align 8
  %call = call i32 @strcasecmp(ptr noundef %17, ptr noundef %20) #12
  %tobool17 = icmp ne i32 %call, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %for.body12
  br label %for.end

if.end19:                                         ; preds = %for.body12
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %21 = load i32, ptr %j, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond10, !llvm.loop !227

for.end:                                          ; preds = %if.then18, %for.cond10
  %22 = load i32, ptr %j, align 4
  %23 = load i32, ptr %rawargc, align 4
  %cmp20 = icmp eq i32 %22, %23
  br i1 %cmp20, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %for.end
  %24 = load i32, ptr %rawargc, align 4
  %25 = load i32, ptr %matchlen, align 4
  %cmp21 = icmp sgt i32 %24, %25
  br i1 %cmp21, label %if.then22, label %if.end25

if.then22:                                        ; preds = %land.lhs.true
  %26 = load i32, ptr %rawargc, align 4
  store i32 %26, ptr %matchlen, align 4
  %27 = load ptr, ptr @helpEntries, align 8
  %28 = load i32, ptr %i, align 4
  %idxprom23 = sext i32 %28 to i64
  %arrayidx24 = getelementptr inbounds %struct.helpEntry, ptr %27, i64 %idxprom23
  store ptr %arrayidx24, ptr %entry1, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %land.lhs.true, %for.end
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end
  br label %for.inc27

for.inc27:                                        ; preds = %if.end26, %if.then
  %29 = load i32, ptr %i, align 4
  %inc28 = add nsw i32 %29, 1
  store i32 %inc28, ptr %i, align 4
  br label %for.cond, !llvm.loop !228

for.end29:                                        ; preds = %for.cond
  %30 = load ptr, ptr %entry1, align 8
  ret ptr %30
}

; Function Attrs: nounwind uwtable
define internal void @usage(i32 noundef %err) #0 {
entry:
  %err.addr = alloca i32, align 4
  %version = alloca ptr, align 8
  %target = alloca ptr, align 8
  %tls_usage = alloca ptr, align 8
  store i32 %err, ptr %err.addr, align 4
  %call = call ptr @cliVersion()
  store ptr %call, ptr %version, align 8
  %0 = load i32, ptr %err.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr @stderr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load ptr, ptr @stdout, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %1, %cond.true ], [ %2, %cond.false ]
  store ptr %cond, ptr %target, align 8
  store ptr @.str.26, ptr %tls_usage, align 8
  %3 = load ptr, ptr %target, align 8
  %4 = load ptr, ptr %version, align 8
  %5 = load ptr, ptr %tls_usage, align 8
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %3, ptr noundef @.str.564, ptr noundef %4, ptr noundef %5)
  %6 = load ptr, ptr %target, align 8
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.565, i32 noundef 30)
  %7 = load ptr, ptr %target, align 8
  %call3 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef @.str.566)
  %8 = load ptr, ptr %target, align 8
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %8, ptr noundef @.str.567)
  %9 = load ptr, ptr %version, align 8
  call void @hi_sdsfree(ptr noundef %9)
  %10 = load i32, ptr %err.addr, align 4
  call void @exit(i32 noundef %10) #17
  unreachable
}

; Function Attrs: nounwind
declare i64 @strtoll(ptr noundef, ptr noundef, i32 noundef) #6

declare void @parseRedisUri(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #2

declare ptr @unquoteCString(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @createClusterManagerCommand(ptr noundef %cmdname, i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %cmdname.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %new_argv = alloca ptr, align 8
  %i = alloca i32, align 4
  %tag_match = alloca i32, align 4
  store ptr %cmdname, ptr %cmdname.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55), ptr %cmd, align 8
  %0 = load ptr, ptr %cmdname.addr, align 8
  %1 = load ptr, ptr %cmd, align 8
  %name = getelementptr inbounds %struct.clusterManagerCommand, ptr %1, i32 0, i32 0
  store ptr %0, ptr %name, align 8
  %2 = load i32, ptr %argc.addr, align 4
  %3 = load ptr, ptr %cmd, align 8
  %argc1 = getelementptr inbounds %struct.clusterManagerCommand, ptr %3, i32 0, i32 1
  store i32 %2, ptr %argc1, align 8
  %4 = load i32, ptr %argc.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load ptr, ptr %argv.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %5, %cond.true ], [ null, %cond.false ]
  %6 = load ptr, ptr %cmd, align 8
  %argv2 = getelementptr inbounds %struct.clusterManagerCommand, ptr %6, i32 0, i32 2
  store ptr %cond, ptr %argv2, align 8
  %call = call i32 @isColorTerm()
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %7 = load ptr, ptr %cmd, align 8
  %flags = getelementptr inbounds %struct.clusterManagerCommand, ptr %7, i32 0, i32 4
  %8 = load i32, ptr %flags, align 8
  %or = or i32 %8, 256
  store i32 %or, ptr %flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %9 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 36), align 8
  %tobool4 = icmp ne i32 %9, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %10 = load ptr, ptr %cmd, align 8
  %argc6 = getelementptr inbounds %struct.clusterManagerCommand, ptr %10, i32 0, i32 1
  %11 = load i32, ptr %argc6, align 8
  %add = add nsw i32 %11, 1
  %conv = sext i32 %add to i64
  %mul = mul i64 8, %conv
  %call7 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call7, ptr %new_argv, align 8
  %12 = load ptr, ptr %new_argv, align 8
  %13 = load ptr, ptr %cmd, align 8
  %argv8 = getelementptr inbounds %struct.clusterManagerCommand, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %argv8, align 8
  %15 = load ptr, ptr %cmd, align 8
  %argc9 = getelementptr inbounds %struct.clusterManagerCommand, ptr %15, i32 0, i32 1
  %16 = load i32, ptr %argc9, align 8
  %conv10 = sext i32 %16 to i64
  %mul11 = mul i64 8, %conv10
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %12, ptr align 8 %14, i64 %mul11, i1 false)
  %call12 = call ptr @readArgFromStdin()
  %17 = load ptr, ptr %cmd, align 8
  %stdin_arg = getelementptr inbounds %struct.clusterManagerCommand, ptr %17, i32 0, i32 3
  store ptr %call12, ptr %stdin_arg, align 8
  %18 = load ptr, ptr %cmd, align 8
  %stdin_arg13 = getelementptr inbounds %struct.clusterManagerCommand, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %stdin_arg13, align 8
  %20 = load ptr, ptr %new_argv, align 8
  %21 = load ptr, ptr %cmd, align 8
  %argc14 = getelementptr inbounds %struct.clusterManagerCommand, ptr %21, i32 0, i32 1
  %22 = load i32, ptr %argc14, align 8
  %inc = add nsw i32 %22, 1
  store i32 %inc, ptr %argc14, align 8
  %idxprom = sext i32 %22 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %20, i64 %idxprom
  store ptr %19, ptr %arrayidx, align 8
  %23 = load ptr, ptr %new_argv, align 8
  %24 = load ptr, ptr %cmd, align 8
  %argv15 = getelementptr inbounds %struct.clusterManagerCommand, ptr %24, i32 0, i32 2
  store ptr %23, ptr %argv15, align 8
  br label %if.end39

if.else:                                          ; preds = %if.end
  %25 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 37), align 4
  %tobool16 = icmp ne i32 %25, 0
  br i1 %tobool16, label %if.then17, label %if.end38

if.then17:                                        ; preds = %if.else
  store i32 0, ptr %i, align 4
  store i32 0, ptr %tag_match, align 4
  %call18 = call ptr @readArgFromStdin()
  %26 = load ptr, ptr %cmd, align 8
  %stdin_arg19 = getelementptr inbounds %struct.clusterManagerCommand, ptr %26, i32 0, i32 3
  store ptr %call18, ptr %stdin_arg19, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then17
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %argc.addr, align 4
  %cmp = icmp slt i32 %27, %28
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load ptr, ptr %argv.addr, align 8
  %30 = load i32, ptr %i, align 4
  %idxprom21 = sext i32 %30 to i64
  %arrayidx22 = getelementptr inbounds ptr, ptr %29, i64 %idxprom21
  %31 = load ptr, ptr %arrayidx22, align 8
  %32 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 38), align 8
  %call23 = call i32 @strcmp(ptr noundef %31, ptr noundef %32) #12
  %cmp24 = icmp ne i32 %call23, 0
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body
  br label %for.inc

if.end27:                                         ; preds = %for.body
  store i32 1, ptr %tag_match, align 4
  %33 = load ptr, ptr %cmd, align 8
  %stdin_arg28 = getelementptr inbounds %struct.clusterManagerCommand, ptr %33, i32 0, i32 3
  %34 = load ptr, ptr %stdin_arg28, align 8
  %35 = load ptr, ptr %cmd, align 8
  %argv29 = getelementptr inbounds %struct.clusterManagerCommand, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %argv29, align 8
  %37 = load i32, ptr %i, align 4
  %idxprom30 = sext i32 %37 to i64
  %arrayidx31 = getelementptr inbounds ptr, ptr %36, i64 %idxprom30
  store ptr %34, ptr %arrayidx31, align 8
  br label %for.end

for.inc:                                          ; preds = %if.then26
  %38 = load i32, ptr %i, align 4
  %inc32 = add nsw i32 %38, 1
  store i32 %inc32, ptr %i, align 4
  br label %for.cond, !llvm.loop !229

for.end:                                          ; preds = %if.end27, %for.cond
  %39 = load i32, ptr %tag_match, align 4
  %tobool33 = icmp ne i32 %39, 0
  br i1 %tobool33, label %if.end37, label %if.then34

if.then34:                                        ; preds = %for.end
  %40 = load ptr, ptr %cmd, align 8
  %stdin_arg35 = getelementptr inbounds %struct.clusterManagerCommand, ptr %40, i32 0, i32 3
  %41 = load ptr, ptr %stdin_arg35, align 8
  call void @hi_sdsfree(ptr noundef %41)
  %42 = load ptr, ptr @stderr, align 8
  %call36 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %42, ptr noundef @.str.568)
  store i32 1, ptr %retval, align 4
  br label %return

if.end37:                                         ; preds = %for.end
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.else
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.then5
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end39, %if.then34
  %43 = load i32, ptr %retval, align 4
  ret i32 %43
}

; Function Attrs: nounwind uwtable
define internal ptr @cliVersion() #0 {
entry:
  %version = alloca ptr, align 8
  %call = call ptr @hi_sdsempty()
  %call1 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %call, ptr noundef @.str.237, ptr noundef @.str.569)
  store ptr %call1, ptr %version, align 8
  %call2 = call ptr @redisGitSHA1()
  %call3 = call i64 @strtoll(ptr noundef %call2, ptr noundef null, i32 noundef 16) #15
  %tobool = icmp ne i64 %call3, 0
  br i1 %tobool, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %0 = load ptr, ptr %version, align 8
  %call4 = call ptr @redisGitSHA1()
  %call5 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %0, ptr noundef @.str.570, ptr noundef %call4)
  store ptr %call5, ptr %version, align 8
  %call6 = call ptr @redisGitDirty()
  %call7 = call i64 @strtoll(ptr noundef %call6, ptr noundef null, i32 noundef 10) #15
  %tobool8 = icmp ne i64 %call7, 0
  br i1 %tobool8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  %1 = load ptr, ptr %version, align 8
  %call10 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %1, ptr noundef @.str.571)
  store ptr %call10, ptr %version, align 8
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.then
  %2 = load ptr, ptr %version, align 8
  %call11 = call ptr @hi_sdscat(ptr noundef %2, ptr noundef @.str.572)
  store ptr %call11, ptr %version, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end, %entry
  %3 = load ptr, ptr %version, align 8
  ret ptr %3
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strncasecmp(ptr noundef, ptr noundef, i64 noundef) #1

declare ptr @readArgFromStdin() #2

declare ptr @redisGitSHA1() #2

declare ptr @redisGitDirty() #2

declare void @linenoiseMaskModeEnable() #2

declare ptr @linenoise(ptr noundef) #2

declare void @linenoiseMaskModeDisable() #2

; Function Attrs: nounwind uwtable
define internal void @freeClusterManager() #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %n = alloca ptr, align 8
  %err = alloca ptr, align 8
  %0 = load ptr, ptr @cluster_manager, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @cluster_manager, align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp1 = icmp ne ptr %call, null
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %n, align 8
  %4 = load ptr, ptr %n, align 8
  call void @freeClusterManagerNode(ptr noundef %4)
  br label %while.cond, !llvm.loop !230

while.end:                                        ; preds = %while.cond
  %5 = load ptr, ptr @cluster_manager, align 8
  call void @listRelease(ptr noundef %5)
  store ptr null, ptr @cluster_manager, align 8
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  %6 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  %cmp2 = icmp ne ptr %6, null
  br i1 %cmp2, label %if.then3, label %if.end10

if.then3:                                         ; preds = %if.end
  %7 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  call void @listRewind(ptr noundef %7, ptr noundef %li)
  br label %while.cond4

while.cond4:                                      ; preds = %while.body7, %if.then3
  %call5 = call ptr @listNext(ptr noundef %li)
  store ptr %call5, ptr %ln, align 8
  %cmp6 = icmp ne ptr %call5, null
  br i1 %cmp6, label %while.body7, label %while.end9

while.body7:                                      ; preds = %while.cond4
  %8 = load ptr, ptr %ln, align 8
  %value8 = getelementptr inbounds %struct.listNode, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %value8, align 8
  store ptr %9, ptr %err, align 8
  %10 = load ptr, ptr %err, align 8
  call void @hi_sdsfree(ptr noundef %10)
  br label %while.cond4, !llvm.loop !231

while.end9:                                       ; preds = %while.cond4
  %11 = load ptr, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  call void @listRelease(ptr noundef %11)
  store ptr null, ptr getelementptr inbounds (%struct.clusterManager, ptr @cluster_manager, i32 0, i32 1), align 8
  br label %if.end10

if.end10:                                         ; preds = %while.end9, %if.end
  %12 = load ptr, ptr @clusterManagerUncoveredSlots, align 8
  %cmp11 = icmp ne ptr %12, null
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  %13 = load ptr, ptr @clusterManagerUncoveredSlots, align 8
  call void @dictRelease(ptr noundef %13)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10
  ret void
}

declare ptr @redisConnectUnix(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @cliSelect() #0 {
entry:
  %retval = alloca i32, align 4
  %reply = alloca ptr, align 8
  %result = alloca i32, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  %1 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr @context, align 8
  %3 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %2, ptr noundef @.str.579, i32 noundef %3)
  store ptr %call, ptr %reply, align 8
  %4 = load ptr, ptr %reply, align 8
  %cmp1 = icmp eq ptr %4, null
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %5 = load ptr, ptr @stderr, align 8
  %call3 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.76)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  store i32 0, ptr %result, align 4
  %6 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %type, align 8
  %cmp5 = icmp eq i32 %7, 6
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end4
  store i32 -1, ptr %result, align 4
  %8 = load ptr, ptr @stderr, align 8
  %9 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  %10 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %str, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %8, ptr noundef @.str.580, i32 noundef %9, ptr noundef %11)
  br label %if.end8

if.else:                                          ; preds = %if.end4
  %12 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  store i32 %12, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  call void @cliRefreshPrompt()
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then6
  %13 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %13)
  %14 = load i32, ptr %result, align 4
  store i32 %14, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then2, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @cliSwitchProto() #0 {
entry:
  %retval = alloca i32, align 4
  %reply = alloca ptr, align 8
  %result = alloca i32, align 4
  %i = alloca i64, align 8
  %key = alloca ptr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 57), align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr @context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %2, ptr noundef @.str.581)
  store ptr %call, ptr %reply, align 8
  %3 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr @stderr, align 8
  %call3 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %4, ptr noundef @.str.76)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  store i32 0, ptr %result, align 4
  %5 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type, align 8
  %cmp5 = icmp eq i32 %6, 6
  br i1 %cmp5, label %if.then6, label %if.end14

if.then6:                                         ; preds = %if.end4
  %7 = load ptr, ptr @stderr, align 8
  %8 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %str, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef @.str.582, ptr noundef %9)
  %10 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  %cmp8 = icmp eq i32 %10, 1
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then6
  store i32 -1, ptr %result, align 4
  br label %if.end13

if.else:                                          ; preds = %if.then6
  %11 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 58), align 8
  %cmp10 = icmp eq i32 %11, 2
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.else
  store i32 0, ptr %result, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.then9
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.end4
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %12 = load i64, ptr %i, align 8
  %13 = load ptr, ptr %reply, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 6
  %14 = load i64, ptr %elements, align 8
  %cmp15 = icmp ult i64 %12, %14
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 7
  %16 = load ptr, ptr %element, align 8
  %17 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %16, i64 %17
  %18 = load ptr, ptr %arrayidx, align 8
  %str16 = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 4
  %19 = load ptr, ptr %str16, align 8
  store ptr %19, ptr %key, align 8
  %20 = load ptr, ptr %key, align 8
  %call17 = call i32 @strcmp(ptr noundef %20, ptr noundef @.str.583) #12
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end24, label %if.then19

if.then19:                                        ; preds = %for.body
  %21 = load ptr, ptr %reply, align 8
  %element20 = getelementptr inbounds %struct.redisReply, ptr %21, i32 0, i32 7
  %22 = load ptr, ptr %element20, align 8
  %23 = load i64, ptr %i, align 8
  %add = add i64 %23, 1
  %arrayidx21 = getelementptr inbounds ptr, ptr %22, i64 %add
  %24 = load ptr, ptr %arrayidx21, align 8
  %str22 = getelementptr inbounds %struct.redisReply, ptr %24, i32 0, i32 4
  %25 = load ptr, ptr %str22, align 8
  %call23 = call ptr @hi_sdsnew(ptr noundef %25)
  store ptr %call23, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 62), align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then19, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end24
  %26 = load i64, ptr %i, align 8
  %add25 = add i64 %26, 2
  store i64 %add25, ptr %i, align 8
  br label %for.cond, !llvm.loop !232

for.end:                                          ; preds = %for.cond
  %27 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %27)
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 59), align 4
  %28 = load i32, ptr %result, align 4
  store i32 %28, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then2, %if.then
  %29 = load i32, ptr %retval, align 4
  ret i32 %29
}

declare ptr @redisSetPushCallback(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @cliPushHandler(ptr noundef %privdata, ptr noundef %reply) #0 {
entry:
  %privdata.addr = alloca ptr, align 8
  %reply.addr = alloca ptr, align 8
  %out = alloca ptr, align 8
  store ptr %privdata, ptr %privdata.addr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %reply.addr, align 8
  %call = call i32 @isInvalidateReply(ptr noundef %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr %reply.addr, align 8
  %call1 = call ptr @cliFormatInvalidateTTY(ptr noundef %2)
  store ptr %call1, ptr %out, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %3 = load ptr, ptr %reply.addr, align 8
  %4 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %call2 = call ptr @cliFormatReply(ptr noundef %3, i32 noundef %4, i32 noundef 0)
  store ptr %call2, ptr %out, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load ptr, ptr %out, align 8
  %6 = load ptr, ptr %out, align 8
  %call3 = call i64 @hi_sdslen(ptr noundef %6)
  %7 = load ptr, ptr @stdout, align 8
  %call4 = call i64 @fwrite(ptr noundef %5, i64 noundef %call3, i64 noundef 1, ptr noundef %7)
  %8 = load ptr, ptr %reply.addr, align 8
  call void @freeReplyObject(ptr noundef %8)
  %9 = load ptr, ptr %out, align 8
  call void @hi_sdsfree(ptr noundef %9)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @isInvalidateReply(ptr noundef %reply) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %reply.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %1, 12
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %reply.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %2, i32 0, i32 6
  %3 = load i64, ptr %elements, align 8
  %cmp1 = icmp eq i64 %3, 2
  br i1 %cmp1, label %land.lhs.true2, label %land.end

land.lhs.true2:                                   ; preds = %land.lhs.true
  %4 = load ptr, ptr %reply.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %4, i32 0, i32 7
  %5 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %5, i64 0
  %6 = load ptr, ptr %arrayidx, align 8
  %type3 = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %type3, align 8
  %cmp4 = icmp eq i32 %7, 1
  br i1 %cmp4, label %land.lhs.true5, label %land.end

land.lhs.true5:                                   ; preds = %land.lhs.true2
  %8 = load ptr, ptr %reply.addr, align 8
  %element6 = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 7
  %9 = load ptr, ptr %element6, align 8
  %arrayidx7 = getelementptr inbounds ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx7, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %str, align 8
  %call = call i32 @strncmp(ptr noundef %11, ptr noundef @.str.584, i64 noundef 10) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %land.lhs.true5
  %12 = load ptr, ptr %reply.addr, align 8
  %element8 = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 7
  %13 = load ptr, ptr %element8, align 8
  %arrayidx9 = getelementptr inbounds ptr, ptr %13, i64 1
  %14 = load ptr, ptr %arrayidx9, align 8
  %type10 = getelementptr inbounds %struct.redisReply, ptr %14, i32 0, i32 0
  %15 = load i32, ptr %type10, align 8
  %cmp11 = icmp eq i32 %15, 2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true5, %land.lhs.true2, %land.lhs.true, %entry
  %16 = phi i1 [ false, %land.lhs.true5 ], [ false, %land.lhs.true2 ], [ false, %land.lhs.true ], [ false, %entry ], [ %cmp11, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal ptr @cliFormatInvalidateTTY(ptr noundef %r) #0 {
entry:
  %r.addr = alloca ptr, align 8
  %out = alloca ptr, align 8
  %i = alloca i64, align 8
  %key = alloca ptr, align 8
  store ptr %r, ptr %r.addr, align 8
  %call = call ptr @hi_sdsnew(ptr noundef @.str.585)
  store ptr %call, ptr %out, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %1 = load ptr, ptr %r.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %1, i32 0, i32 7
  %2 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 1
  %3 = load ptr, ptr %arrayidx, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 6
  %4 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %0, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %r.addr, align 8
  %element1 = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 7
  %6 = load ptr, ptr %element1, align 8
  %arrayidx2 = getelementptr inbounds ptr, ptr %6, i64 1
  %7 = load ptr, ptr %arrayidx2, align 8
  %element3 = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 7
  %8 = load ptr, ptr %element3, align 8
  %9 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr inbounds ptr, ptr %8, i64 %9
  %10 = load ptr, ptr %arrayidx4, align 8
  store ptr %10, ptr %key, align 8
  %11 = load ptr, ptr %out, align 8
  %12 = load ptr, ptr %key, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %str, align 8
  %14 = load ptr, ptr %key, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %14, i32 0, i32 3
  %15 = load i64, ptr %len, align 8
  %call5 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %11, ptr noundef @.str.586, ptr noundef %13, i64 noundef %15)
  store ptr %call5, ptr %out, align 8
  %16 = load i64, ptr %i, align 8
  %17 = load ptr, ptr %r.addr, align 8
  %element6 = getelementptr inbounds %struct.redisReply, ptr %17, i32 0, i32 7
  %18 = load ptr, ptr %element6, align 8
  %arrayidx7 = getelementptr inbounds ptr, ptr %18, i64 1
  %19 = load ptr, ptr %arrayidx7, align 8
  %elements8 = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 6
  %20 = load i64, ptr %elements8, align 8
  %sub = sub i64 %20, 1
  %cmp9 = icmp ult i64 %16, %sub
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %21 = load ptr, ptr %out, align 8
  %call10 = call ptr @hi_sdscatlen(ptr noundef %21, ptr noundef @.str.315, i64 noundef 2)
  store ptr %call10, ptr %out, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !233

for.end:                                          ; preds = %for.cond
  %23 = load ptr, ptr %out, align 8
  %call11 = call ptr @hi_sdscatlen(ptr noundef %23, ptr noundef @.str.116, i64 noundef 1)
  ret ptr %call11
}

; Function Attrs: nounwind uwtable
define internal ptr @cliFormatReply(ptr noundef %reply, i32 noundef %mode, i32 noundef %verbatim) #0 {
entry:
  %reply.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %verbatim.addr = alloca i32, align 4
  %out = alloca ptr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store i32 %verbatim, ptr %verbatim.addr, align 4
  %0 = load i32, ptr %verbatim.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %reply.addr, align 8
  %call = call ptr @cliFormatReplyRaw(ptr noundef %1)
  store ptr %call, ptr %out, align 8
  br label %if.end25

if.else:                                          ; preds = %entry
  %2 = load i32, ptr %mode.addr, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then1, label %if.else3

if.then1:                                         ; preds = %if.else
  %3 = load ptr, ptr %reply.addr, align 8
  %call2 = call ptr @cliFormatReplyTTY(ptr noundef %3, ptr noundef @.str.26)
  store ptr %call2, ptr %out, align 8
  br label %if.end24

if.else3:                                         ; preds = %if.else
  %4 = load i32, ptr %mode.addr, align 4
  %cmp4 = icmp eq i32 %4, 1
  br i1 %cmp4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else3
  %5 = load ptr, ptr %reply.addr, align 8
  %call6 = call ptr @cliFormatReplyRaw(ptr noundef %5)
  store ptr %call6, ptr %out, align 8
  %6 = load ptr, ptr %out, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 44), align 8
  %call7 = call ptr @hi_sdscatsds(ptr noundef %6, ptr noundef %7)
  store ptr %call7, ptr %out, align 8
  br label %if.end23

if.else8:                                         ; preds = %if.else3
  %8 = load i32, ptr %mode.addr, align 4
  %cmp9 = icmp eq i32 %8, 2
  br i1 %cmp9, label %if.then10, label %if.else13

if.then10:                                        ; preds = %if.else8
  %9 = load ptr, ptr %reply.addr, align 8
  %call11 = call ptr @cliFormatReplyCSV(ptr noundef %9)
  store ptr %call11, ptr %out, align 8
  %10 = load ptr, ptr %out, align 8
  %call12 = call ptr @hi_sdscatlen(ptr noundef %10, ptr noundef @.str.116, i64 noundef 1)
  store ptr %call12, ptr %out, align 8
  br label %if.end22

if.else13:                                        ; preds = %if.else8
  %11 = load i32, ptr %mode.addr, align 4
  %cmp14 = icmp eq i32 %11, 3
  br i1 %cmp14, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else13
  %12 = load i32, ptr %mode.addr, align 4
  %cmp15 = icmp eq i32 %12, 4
  br i1 %cmp15, label %if.then16, label %if.else20

if.then16:                                        ; preds = %lor.lhs.false, %if.else13
  %call17 = call ptr @hi_sdsempty()
  %13 = load ptr, ptr %reply.addr, align 8
  %14 = load i32, ptr %mode.addr, align 4
  %call18 = call ptr @cliFormatReplyJson(ptr noundef %call17, ptr noundef %13, i32 noundef %14)
  store ptr %call18, ptr %out, align 8
  %15 = load ptr, ptr %out, align 8
  %call19 = call ptr @hi_sdscatlen(ptr noundef %15, ptr noundef @.str.116, i64 noundef 1)
  store ptr %call19, ptr %out, align 8
  br label %if.end

if.else20:                                        ; preds = %lor.lhs.false
  %16 = load ptr, ptr @stderr, align 8
  %17 = load i32, ptr %mode.addr, align 4
  %call21 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %16, ptr noundef @.str.587, i32 noundef %17)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %if.then16
  br label %if.end22

if.end22:                                         ; preds = %if.end, %if.then10
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then5
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then1
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then
  %18 = load ptr, ptr %out, align 8
  ret ptr %18
}

declare i64 @fwrite(ptr noundef, i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @cliFormatReplyTTY(ptr noundef %r, ptr noundef %prefix) #0 {
entry:
  %r.addr = alloca ptr, align 8
  %prefix.addr = alloca ptr, align 8
  %out = alloca ptr, align 8
  %i = alloca i32, align 4
  %idxlen = alloca i32, align 4
  %_prefixlen = alloca [16 x i8], align 16
  %_prefixfmt = alloca [16 x i8], align 16
  %_prefix = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %numsep = alloca i8, align 1
  %human_idx = alloca i32, align 4
  store ptr %r, ptr %r.addr, align 8
  store ptr %prefix, ptr %prefix.addr, align 8
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %out, align 8
  %0 = load ptr, ptr %r.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  switch i32 %1, label %sw.default [
    i32 6, label %sw.bb
    i32 5, label %sw.bb2
    i32 3, label %sw.bb6
    i32 7, label %sw.bb8
    i32 1, label %sw.bb11
    i32 14, label %sw.bb11
    i32 4, label %sw.bb20
    i32 8, label %sw.bb22
    i32 2, label %sw.bb25
    i32 9, label %sw.bb25
    i32 10, label %sw.bb25
    i32 12, label %sw.bb25
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %out, align 8
  %3 = load ptr, ptr %r.addr, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 4
  %4 = load ptr, ptr %str, align 8
  %call1 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %2, ptr noundef @.str.588, ptr noundef %4)
  store ptr %call1, ptr %out, align 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %5 = load ptr, ptr %out, align 8
  %6 = load ptr, ptr %r.addr, align 8
  %str3 = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %str3, align 8
  %call4 = call ptr @hi_sdscat(ptr noundef %5, ptr noundef %7)
  store ptr %call4, ptr %out, align 8
  %8 = load ptr, ptr %out, align 8
  %call5 = call ptr @hi_sdscat(ptr noundef %8, ptr noundef @.str.116)
  store ptr %call5, ptr %out, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %9 = load ptr, ptr %out, align 8
  %10 = load ptr, ptr %r.addr, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 1
  %11 = load i64, ptr %integer, align 8
  %call7 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %9, ptr noundef @.str.589, i64 noundef %11)
  store ptr %call7, ptr %out, align 8
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %12 = load ptr, ptr %out, align 8
  %13 = load ptr, ptr %r.addr, align 8
  %str9 = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 4
  %14 = load ptr, ptr %str9, align 8
  %call10 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %12, ptr noundef @.str.590, ptr noundef %14)
  store ptr %call10, ptr %out, align 8
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry, %entry
  %15 = load ptr, ptr %r.addr, align 8
  %type12 = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 0
  %16 = load i32, ptr %type12, align 8
  %cmp = icmp eq i32 %16, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb11
  %17 = load ptr, ptr %out, align 8
  %18 = load ptr, ptr %r.addr, align 8
  %str13 = getelementptr inbounds %struct.redisReply, ptr %18, i32 0, i32 4
  %19 = load ptr, ptr %str13, align 8
  %20 = load ptr, ptr %r.addr, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %20, i32 0, i32 3
  %21 = load i64, ptr %len, align 8
  %call14 = call ptr @hi_sdscatrepr(ptr noundef %17, ptr noundef %19, i64 noundef %21)
  store ptr %call14, ptr %out, align 8
  %22 = load ptr, ptr %out, align 8
  %call15 = call ptr @hi_sdscat(ptr noundef %22, ptr noundef @.str.116)
  store ptr %call15, ptr %out, align 8
  br label %if.end

if.else:                                          ; preds = %sw.bb11
  %23 = load ptr, ptr %out, align 8
  %24 = load ptr, ptr %r.addr, align 8
  %str16 = getelementptr inbounds %struct.redisReply, ptr %24, i32 0, i32 4
  %25 = load ptr, ptr %str16, align 8
  %26 = load ptr, ptr %r.addr, align 8
  %len17 = getelementptr inbounds %struct.redisReply, ptr %26, i32 0, i32 3
  %27 = load i64, ptr %len17, align 8
  %call18 = call ptr @hi_sdscatlen(ptr noundef %23, ptr noundef %25, i64 noundef %27)
  store ptr %call18, ptr %out, align 8
  %28 = load ptr, ptr %out, align 8
  %call19 = call ptr @hi_sdscat(ptr noundef %28, ptr noundef @.str.116)
  store ptr %call19, ptr %out, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %29 = load ptr, ptr %out, align 8
  %call21 = call ptr @hi_sdscat(ptr noundef %29, ptr noundef @.str.591)
  store ptr %call21, ptr %out, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %entry
  %30 = load ptr, ptr %out, align 8
  %31 = load ptr, ptr %r.addr, align 8
  %integer23 = getelementptr inbounds %struct.redisReply, ptr %31, i32 0, i32 1
  %32 = load i64, ptr %integer23, align 8
  %tobool = icmp ne i64 %32, 0
  %cond = select i1 %tobool, ptr @.str.592, ptr @.str.593
  %call24 = call ptr @hi_sdscat(ptr noundef %30, ptr noundef %cond)
  store ptr %call24, ptr %out, align 8
  br label %sw.epilog

sw.bb25:                                          ; preds = %entry, %entry, %entry, %entry
  %33 = load ptr, ptr %r.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %33, i32 0, i32 6
  %34 = load i64, ptr %elements, align 8
  %cmp26 = icmp eq i64 %34, 0
  br i1 %cmp26, label %if.then27, label %if.else53

if.then27:                                        ; preds = %sw.bb25
  %35 = load ptr, ptr %r.addr, align 8
  %type28 = getelementptr inbounds %struct.redisReply, ptr %35, i32 0, i32 0
  %36 = load i32, ptr %type28, align 8
  %cmp29 = icmp eq i32 %36, 2
  br i1 %cmp29, label %if.then30, label %if.else32

if.then30:                                        ; preds = %if.then27
  %37 = load ptr, ptr %out, align 8
  %call31 = call ptr @hi_sdscat(ptr noundef %37, ptr noundef @.str.594)
  store ptr %call31, ptr %out, align 8
  br label %if.end52

if.else32:                                        ; preds = %if.then27
  %38 = load ptr, ptr %r.addr, align 8
  %type33 = getelementptr inbounds %struct.redisReply, ptr %38, i32 0, i32 0
  %39 = load i32, ptr %type33, align 8
  %cmp34 = icmp eq i32 %39, 9
  br i1 %cmp34, label %if.then35, label %if.else37

if.then35:                                        ; preds = %if.else32
  %40 = load ptr, ptr %out, align 8
  %call36 = call ptr @hi_sdscat(ptr noundef %40, ptr noundef @.str.595)
  store ptr %call36, ptr %out, align 8
  br label %if.end51

if.else37:                                        ; preds = %if.else32
  %41 = load ptr, ptr %r.addr, align 8
  %type38 = getelementptr inbounds %struct.redisReply, ptr %41, i32 0, i32 0
  %42 = load i32, ptr %type38, align 8
  %cmp39 = icmp eq i32 %42, 10
  br i1 %cmp39, label %if.then40, label %if.else42

if.then40:                                        ; preds = %if.else37
  %43 = load ptr, ptr %out, align 8
  %call41 = call ptr @hi_sdscat(ptr noundef %43, ptr noundef @.str.596)
  store ptr %call41, ptr %out, align 8
  br label %if.end50

if.else42:                                        ; preds = %if.else37
  %44 = load ptr, ptr %r.addr, align 8
  %type43 = getelementptr inbounds %struct.redisReply, ptr %44, i32 0, i32 0
  %45 = load i32, ptr %type43, align 8
  %cmp44 = icmp eq i32 %45, 12
  br i1 %cmp44, label %if.then45, label %if.else47

if.then45:                                        ; preds = %if.else42
  %46 = load ptr, ptr %out, align 8
  %call46 = call ptr @hi_sdscat(ptr noundef %46, ptr noundef @.str.597)
  store ptr %call46, ptr %out, align 8
  br label %if.end49

if.else47:                                        ; preds = %if.else42
  %47 = load ptr, ptr %out, align 8
  %call48 = call ptr @hi_sdscat(ptr noundef %47, ptr noundef @.str.598)
  store ptr %call48, ptr %out, align 8
  br label %if.end49

if.end49:                                         ; preds = %if.else47, %if.then45
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.then40
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then35
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.then30
  br label %if.end129

if.else53:                                        ; preds = %sw.bb25
  store i32 0, ptr %idxlen, align 4
  %48 = load ptr, ptr %r.addr, align 8
  %elements54 = getelementptr inbounds %struct.redisReply, ptr %48, i32 0, i32 6
  %49 = load i64, ptr %elements54, align 8
  %conv = trunc i64 %49 to i32
  store i32 %conv, ptr %i, align 4
  %50 = load ptr, ptr %r.addr, align 8
  %type55 = getelementptr inbounds %struct.redisReply, ptr %50, i32 0, i32 0
  %51 = load i32, ptr %type55, align 8
  %cmp56 = icmp eq i32 %51, 9
  br i1 %cmp56, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.else53
  %52 = load i32, ptr %i, align 4
  %div = udiv i32 %52, 2
  store i32 %div, ptr %i, align 4
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %if.else53
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end59
  %53 = load i32, ptr %idxlen, align 4
  %inc = add i32 %53, 1
  store i32 %inc, ptr %idxlen, align 4
  %54 = load i32, ptr %i, align 4
  %div60 = udiv i32 %54, 10
  store i32 %div60, ptr %i, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %55 = load i32, ptr %i, align 4
  %tobool61 = icmp ne i32 %55, 0
  br i1 %tobool61, label %do.body, label %do.end, !llvm.loop !234

do.end:                                           ; preds = %do.cond
  %arraydecay = getelementptr inbounds [16 x i8], ptr %_prefixlen, i64 0, i64 0
  %56 = load i32, ptr %idxlen, align 4
  %add = add i32 %56, 2
  %conv62 = zext i32 %add to i64
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay, i8 32, i64 %conv62, i1 false)
  %57 = load i32, ptr %idxlen, align 4
  %add63 = add i32 %57, 2
  %idxprom = zext i32 %add63 to i64
  %arrayidx = getelementptr inbounds [16 x i8], ptr %_prefixlen, i64 0, i64 %idxprom
  store i8 0, ptr %arrayidx, align 1
  %58 = load ptr, ptr %prefix.addr, align 8
  %call64 = call ptr @hi_sdsnew(ptr noundef %58)
  %arraydecay65 = getelementptr inbounds [16 x i8], ptr %_prefixlen, i64 0, i64 0
  %call66 = call ptr @hi_sdscat(ptr noundef %call64, ptr noundef %arraydecay65)
  store ptr %call66, ptr %_prefix, align 8
  %59 = load ptr, ptr %r.addr, align 8
  %type67 = getelementptr inbounds %struct.redisReply, ptr %59, i32 0, i32 0
  %60 = load i32, ptr %type67, align 8
  %cmp68 = icmp eq i32 %60, 10
  br i1 %cmp68, label %if.then70, label %if.else71

if.then70:                                        ; preds = %do.end
  store i8 126, ptr %numsep, align 1
  br label %if.end78

if.else71:                                        ; preds = %do.end
  %61 = load ptr, ptr %r.addr, align 8
  %type72 = getelementptr inbounds %struct.redisReply, ptr %61, i32 0, i32 0
  %62 = load i32, ptr %type72, align 8
  %cmp73 = icmp eq i32 %62, 9
  br i1 %cmp73, label %if.then75, label %if.else76

if.then75:                                        ; preds = %if.else71
  store i8 35, ptr %numsep, align 1
  br label %if.end77

if.else76:                                        ; preds = %if.else71
  store i8 41, ptr %numsep, align 1
  br label %if.end77

if.end77:                                         ; preds = %if.else76, %if.then75
  br label %if.end78

if.end78:                                         ; preds = %if.end77, %if.then70
  %arraydecay79 = getelementptr inbounds [16 x i8], ptr %_prefixfmt, i64 0, i64 0
  %63 = load i32, ptr %idxlen, align 4
  %64 = load i8, ptr %numsep, align 1
  %conv80 = sext i8 %64 to i32
  %call81 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay79, i64 noundef 16, ptr noundef @.str.599, i32 noundef %63, i32 noundef %conv80) #15
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end78
  %65 = load i32, ptr %i, align 4
  %conv82 = zext i32 %65 to i64
  %66 = load ptr, ptr %r.addr, align 8
  %elements83 = getelementptr inbounds %struct.redisReply, ptr %66, i32 0, i32 6
  %67 = load i64, ptr %elements83, align 8
  %cmp84 = icmp ult i64 %conv82, %67
  br i1 %cmp84, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %68 = load ptr, ptr %r.addr, align 8
  %type86 = getelementptr inbounds %struct.redisReply, ptr %68, i32 0, i32 0
  %69 = load i32, ptr %type86, align 8
  %cmp87 = icmp eq i32 %69, 9
  br i1 %cmp87, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %70 = load i32, ptr %i, align 4
  %div89 = udiv i32 %70, 2
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %71 = load i32, ptr %i, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond90 = phi i32 [ %div89, %cond.true ], [ %71, %cond.false ]
  store i32 %cond90, ptr %human_idx, align 4
  %72 = load i32, ptr %human_idx, align 4
  %inc91 = add i32 %72, 1
  store i32 %inc91, ptr %human_idx, align 4
  %73 = load ptr, ptr %out, align 8
  %arraydecay92 = getelementptr inbounds [16 x i8], ptr %_prefixfmt, i64 0, i64 0
  %74 = load i32, ptr %i, align 4
  %cmp93 = icmp eq i32 %74, 0
  br i1 %cmp93, label %cond.true95, label %cond.false96

cond.true95:                                      ; preds = %cond.end
  br label %cond.end97

cond.false96:                                     ; preds = %cond.end
  %75 = load ptr, ptr %prefix.addr, align 8
  br label %cond.end97

cond.end97:                                       ; preds = %cond.false96, %cond.true95
  %cond98 = phi ptr [ @.str.26, %cond.true95 ], [ %75, %cond.false96 ]
  %76 = load i32, ptr %human_idx, align 4
  %call99 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %73, ptr noundef %arraydecay92, ptr noundef %cond98, i32 noundef %76)
  store ptr %call99, ptr %out, align 8
  %77 = load ptr, ptr %r.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %77, i32 0, i32 7
  %78 = load ptr, ptr %element, align 8
  %79 = load i32, ptr %i, align 4
  %idxprom100 = zext i32 %79 to i64
  %arrayidx101 = getelementptr inbounds ptr, ptr %78, i64 %idxprom100
  %80 = load ptr, ptr %arrayidx101, align 8
  %81 = load ptr, ptr %_prefix, align 8
  %call102 = call ptr @cliFormatReplyTTY(ptr noundef %80, ptr noundef %81)
  store ptr %call102, ptr %tmp, align 8
  %82 = load ptr, ptr %out, align 8
  %83 = load ptr, ptr %tmp, align 8
  %84 = load ptr, ptr %tmp, align 8
  %call103 = call i64 @hi_sdslen(ptr noundef %84)
  %call104 = call ptr @hi_sdscatlen(ptr noundef %82, ptr noundef %83, i64 noundef %call103)
  store ptr %call104, ptr %out, align 8
  %85 = load ptr, ptr %tmp, align 8
  call void @hi_sdsfree(ptr noundef %85)
  %86 = load ptr, ptr %r.addr, align 8
  %type105 = getelementptr inbounds %struct.redisReply, ptr %86, i32 0, i32 0
  %87 = load i32, ptr %type105, align 8
  %cmp106 = icmp eq i32 %87, 9
  br i1 %cmp106, label %if.then108, label %if.end127

if.then108:                                       ; preds = %cond.end97
  %88 = load i32, ptr %i, align 4
  %inc109 = add i32 %88, 1
  store i32 %inc109, ptr %i, align 4
  %89 = load ptr, ptr %out, align 8
  %call110 = call i32 @hi_sdsrange(ptr noundef %89, i64 noundef 0, i64 noundef -2)
  %90 = load ptr, ptr %out, align 8
  %call111 = call ptr @hi_sdscat(ptr noundef %90, ptr noundef @.str.600)
  store ptr %call111, ptr %out, align 8
  %91 = load ptr, ptr %r.addr, align 8
  %element112 = getelementptr inbounds %struct.redisReply, ptr %91, i32 0, i32 7
  %92 = load ptr, ptr %element112, align 8
  %93 = load i32, ptr %i, align 4
  %idxprom113 = zext i32 %93 to i64
  %arrayidx114 = getelementptr inbounds ptr, ptr %92, i64 %idxprom113
  %94 = load ptr, ptr %arrayidx114, align 8
  %call115 = call i32 @cliIsMultilineValueTTY(ptr noundef %94)
  %tobool116 = icmp ne i32 %call115, 0
  br i1 %tobool116, label %if.then117, label %if.end120

if.then117:                                       ; preds = %if.then108
  %95 = load ptr, ptr %out, align 8
  %call118 = call ptr @hi_sdscat(ptr noundef %95, ptr noundef @.str.116)
  store ptr %call118, ptr %out, align 8
  %96 = load ptr, ptr %out, align 8
  %97 = load ptr, ptr %_prefix, align 8
  %call119 = call ptr @hi_sdscat(ptr noundef %96, ptr noundef %97)
  store ptr %call119, ptr %out, align 8
  br label %if.end120

if.end120:                                        ; preds = %if.then117, %if.then108
  %98 = load ptr, ptr %r.addr, align 8
  %element121 = getelementptr inbounds %struct.redisReply, ptr %98, i32 0, i32 7
  %99 = load ptr, ptr %element121, align 8
  %100 = load i32, ptr %i, align 4
  %idxprom122 = zext i32 %100 to i64
  %arrayidx123 = getelementptr inbounds ptr, ptr %99, i64 %idxprom122
  %101 = load ptr, ptr %arrayidx123, align 8
  %102 = load ptr, ptr %_prefix, align 8
  %call124 = call ptr @cliFormatReplyTTY(ptr noundef %101, ptr noundef %102)
  store ptr %call124, ptr %tmp, align 8
  %103 = load ptr, ptr %out, align 8
  %104 = load ptr, ptr %tmp, align 8
  %105 = load ptr, ptr %tmp, align 8
  %call125 = call i64 @hi_sdslen(ptr noundef %105)
  %call126 = call ptr @hi_sdscatlen(ptr noundef %103, ptr noundef %104, i64 noundef %call125)
  store ptr %call126, ptr %out, align 8
  %106 = load ptr, ptr %tmp, align 8
  call void @hi_sdsfree(ptr noundef %106)
  br label %if.end127

if.end127:                                        ; preds = %if.end120, %cond.end97
  br label %for.inc

for.inc:                                          ; preds = %if.end127
  %107 = load i32, ptr %i, align 4
  %inc128 = add i32 %107, 1
  store i32 %inc128, ptr %i, align 4
  br label %for.cond, !llvm.loop !235

for.end:                                          ; preds = %for.cond
  %108 = load ptr, ptr %_prefix, align 8
  call void @hi_sdsfree(ptr noundef %108)
  br label %if.end129

if.end129:                                        ; preds = %for.end, %if.end52
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %109 = load ptr, ptr @stderr, align 8
  %110 = load ptr, ptr %r.addr, align 8
  %type130 = getelementptr inbounds %struct.redisReply, ptr %110, i32 0, i32 0
  %111 = load i32, ptr %type130, align 8
  %call131 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %109, ptr noundef @.str.425, i32 noundef %111)
  call void @exit(i32 noundef 1) #17
  unreachable

sw.epilog:                                        ; preds = %if.end129, %sw.bb22, %sw.bb20, %if.end, %sw.bb8, %sw.bb6, %sw.bb2, %sw.bb
  %112 = load ptr, ptr %out, align 8
  ret ptr %112
}

; Function Attrs: nounwind uwtable
define internal ptr @cliFormatReplyCSV(ptr noundef %r) #0 {
entry:
  %r.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %out = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %r, ptr %r.addr, align 8
  %call = call ptr @hi_sdsempty()
  store ptr %call, ptr %out, align 8
  %0 = load ptr, ptr %r.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  switch i32 %1, label %sw.default [
    i32 6, label %sw.bb
    i32 5, label %sw.bb5
    i32 3, label %sw.bb8
    i32 7, label %sw.bb10
    i32 1, label %sw.bb13
    i32 14, label %sw.bb13
    i32 4, label %sw.bb17
    i32 8, label %sw.bb19
    i32 2, label %sw.bb22
    i32 10, label %sw.bb22
    i32 12, label %sw.bb22
    i32 9, label %sw.bb22
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %out, align 8
  %call1 = call ptr @hi_sdscat(ptr noundef %2, ptr noundef @.str.601)
  store ptr %call1, ptr %out, align 8
  %3 = load ptr, ptr %out, align 8
  %4 = load ptr, ptr %r.addr, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %str, align 8
  %6 = load ptr, ptr %r.addr, align 8
  %str2 = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %str2, align 8
  %call3 = call i64 @strlen(ptr noundef %7) #12
  %call4 = call ptr @hi_sdscatrepr(ptr noundef %3, ptr noundef %5, i64 noundef %call3)
  store ptr %call4, ptr %out, align 8
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %8 = load ptr, ptr %out, align 8
  %9 = load ptr, ptr %r.addr, align 8
  %str6 = getelementptr inbounds %struct.redisReply, ptr %9, i32 0, i32 4
  %10 = load ptr, ptr %str6, align 8
  %11 = load ptr, ptr %r.addr, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %len, align 8
  %call7 = call ptr @hi_sdscatrepr(ptr noundef %8, ptr noundef %10, i64 noundef %12)
  store ptr %call7, ptr %out, align 8
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %13 = load ptr, ptr %out, align 8
  %14 = load ptr, ptr %r.addr, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %14, i32 0, i32 1
  %15 = load i64, ptr %integer, align 8
  %call9 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %13, ptr noundef @.str.153, i64 noundef %15)
  store ptr %call9, ptr %out, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  %16 = load ptr, ptr %out, align 8
  %17 = load ptr, ptr %r.addr, align 8
  %str11 = getelementptr inbounds %struct.redisReply, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %str11, align 8
  %call12 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %16, ptr noundef @.str.237, ptr noundef %18)
  store ptr %call12, ptr %out, align 8
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry, %entry
  %19 = load ptr, ptr %out, align 8
  %20 = load ptr, ptr %r.addr, align 8
  %str14 = getelementptr inbounds %struct.redisReply, ptr %20, i32 0, i32 4
  %21 = load ptr, ptr %str14, align 8
  %22 = load ptr, ptr %r.addr, align 8
  %len15 = getelementptr inbounds %struct.redisReply, ptr %22, i32 0, i32 3
  %23 = load i64, ptr %len15, align 8
  %call16 = call ptr @hi_sdscatrepr(ptr noundef %19, ptr noundef %21, i64 noundef %23)
  store ptr %call16, ptr %out, align 8
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  %24 = load ptr, ptr %out, align 8
  %call18 = call ptr @hi_sdscat(ptr noundef %24, ptr noundef @.str.602)
  store ptr %call18, ptr %out, align 8
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry
  %25 = load ptr, ptr %out, align 8
  %26 = load ptr, ptr %r.addr, align 8
  %integer20 = getelementptr inbounds %struct.redisReply, ptr %26, i32 0, i32 1
  %27 = load i64, ptr %integer20, align 8
  %tobool = icmp ne i64 %27, 0
  %cond = select i1 %tobool, ptr @.str.603, ptr @.str.604
  %call21 = call ptr @hi_sdscat(ptr noundef %25, ptr noundef %cond)
  store ptr %call21, ptr %out, align 8
  br label %sw.epilog

sw.bb22:                                          ; preds = %entry, %entry, %entry, %entry
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb22
  %28 = load i32, ptr %i, align 4
  %conv = zext i32 %28 to i64
  %29 = load ptr, ptr %r.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %29, i32 0, i32 6
  %30 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %conv, %30
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load ptr, ptr %r.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %31, i32 0, i32 7
  %32 = load ptr, ptr %element, align 8
  %33 = load i32, ptr %i, align 4
  %idxprom = zext i32 %33 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %32, i64 %idxprom
  %34 = load ptr, ptr %arrayidx, align 8
  %call24 = call ptr @cliFormatReplyCSV(ptr noundef %34)
  store ptr %call24, ptr %tmp, align 8
  %35 = load ptr, ptr %out, align 8
  %36 = load ptr, ptr %tmp, align 8
  %37 = load ptr, ptr %tmp, align 8
  %call25 = call i64 @hi_sdslen(ptr noundef %37)
  %call26 = call ptr @hi_sdscatlen(ptr noundef %35, ptr noundef %36, i64 noundef %call25)
  store ptr %call26, ptr %out, align 8
  %38 = load i32, ptr %i, align 4
  %conv27 = zext i32 %38 to i64
  %39 = load ptr, ptr %r.addr, align 8
  %elements28 = getelementptr inbounds %struct.redisReply, ptr %39, i32 0, i32 6
  %40 = load i64, ptr %elements28, align 8
  %sub = sub i64 %40, 1
  %cmp29 = icmp ne i64 %conv27, %sub
  br i1 %cmp29, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %41 = load ptr, ptr %out, align 8
  %call31 = call ptr @hi_sdscat(ptr noundef %41, ptr noundef @.str.220)
  store ptr %call31, ptr %out, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %42 = load ptr, ptr %tmp, align 8
  call void @hi_sdsfree(ptr noundef %42)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %43 = load i32, ptr %i, align 4
  %inc = add i32 %43, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !236

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %44 = load ptr, ptr @stderr, align 8
  %45 = load ptr, ptr %r.addr, align 8
  %type32 = getelementptr inbounds %struct.redisReply, ptr %45, i32 0, i32 0
  %46 = load i32, ptr %type32, align 8
  %call33 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %44, ptr noundef @.str.425, i32 noundef %46)
  call void @exit(i32 noundef 1) #17
  unreachable

sw.epilog:                                        ; preds = %for.end, %sw.bb19, %sw.bb17, %sw.bb13, %sw.bb10, %sw.bb8, %sw.bb5, %sw.bb
  %47 = load ptr, ptr %out, align 8
  ret ptr %47
}

; Function Attrs: nounwind uwtable
define internal ptr @cliFormatReplyJson(ptr noundef %out, ptr noundef %r, i32 noundef %mode) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %key = alloca ptr, align 8
  %keystr = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load ptr, ptr %r.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  switch i32 %1, label %sw.default [
    i32 6, label %sw.bb
    i32 5, label %sw.bb4
    i32 3, label %sw.bb8
    i32 7, label %sw.bb10
    i32 1, label %sw.bb13
    i32 14, label %sw.bb13
    i32 4, label %sw.bb18
    i32 8, label %sw.bb20
    i32 2, label %sw.bb23
    i32 10, label %sw.bb23
    i32 12, label %sw.bb23
    i32 9, label %sw.bb34
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %out.addr, align 8
  %call = call ptr @hi_sdscat(ptr noundef %2, ptr noundef @.str.605)
  store ptr %call, ptr %out.addr, align 8
  %3 = load ptr, ptr %out.addr, align 8
  %4 = load ptr, ptr %r.addr, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %str, align 8
  %6 = load ptr, ptr %r.addr, align 8
  %str1 = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %str1, align 8
  %call2 = call i64 @strlen(ptr noundef %7) #12
  %conv = trunc i64 %call2 to i32
  %8 = load i32, ptr %mode.addr, align 4
  %call3 = call ptr @jsonStringOutput(ptr noundef %3, ptr noundef %5, i32 noundef %conv, i32 noundef %8)
  store ptr %call3, ptr %out.addr, align 8
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %9 = load ptr, ptr %out.addr, align 8
  %10 = load ptr, ptr %r.addr, align 8
  %str5 = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %str5, align 8
  %12 = load ptr, ptr %r.addr, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 3
  %13 = load i64, ptr %len, align 8
  %conv6 = trunc i64 %13 to i32
  %14 = load i32, ptr %mode.addr, align 4
  %call7 = call ptr @jsonStringOutput(ptr noundef %9, ptr noundef %11, i32 noundef %conv6, i32 noundef %14)
  store ptr %call7, ptr %out.addr, align 8
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  %15 = load ptr, ptr %out.addr, align 8
  %16 = load ptr, ptr %r.addr, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 1
  %17 = load i64, ptr %integer, align 8
  %call9 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %15, ptr noundef @.str.153, i64 noundef %17)
  store ptr %call9, ptr %out.addr, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry
  %18 = load ptr, ptr %out.addr, align 8
  %19 = load ptr, ptr %r.addr, align 8
  %str11 = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 4
  %20 = load ptr, ptr %str11, align 8
  %call12 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %18, ptr noundef @.str.237, ptr noundef %20)
  store ptr %call12, ptr %out.addr, align 8
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry, %entry
  %21 = load ptr, ptr %out.addr, align 8
  %22 = load ptr, ptr %r.addr, align 8
  %str14 = getelementptr inbounds %struct.redisReply, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %str14, align 8
  %24 = load ptr, ptr %r.addr, align 8
  %len15 = getelementptr inbounds %struct.redisReply, ptr %24, i32 0, i32 3
  %25 = load i64, ptr %len15, align 8
  %conv16 = trunc i64 %25 to i32
  %26 = load i32, ptr %mode.addr, align 4
  %call17 = call ptr @jsonStringOutput(ptr noundef %21, ptr noundef %23, i32 noundef %conv16, i32 noundef %26)
  store ptr %call17, ptr %out.addr, align 8
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  %27 = load ptr, ptr %out.addr, align 8
  %call19 = call ptr @hi_sdscat(ptr noundef %27, ptr noundef @.str.446)
  store ptr %call19, ptr %out.addr, align 8
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %28 = load ptr, ptr %out.addr, align 8
  %29 = load ptr, ptr %r.addr, align 8
  %integer21 = getelementptr inbounds %struct.redisReply, ptr %29, i32 0, i32 1
  %30 = load i64, ptr %integer21, align 8
  %tobool = icmp ne i64 %30, 0
  %cond = select i1 %tobool, ptr @.str.603, ptr @.str.604
  %call22 = call ptr @hi_sdscat(ptr noundef %28, ptr noundef %cond)
  store ptr %call22, ptr %out.addr, align 8
  br label %sw.epilog

sw.bb23:                                          ; preds = %entry, %entry, %entry
  %31 = load ptr, ptr %out.addr, align 8
  %call24 = call ptr @hi_sdscat(ptr noundef %31, ptr noundef @.str.155)
  store ptr %call24, ptr %out.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb23
  %32 = load i32, ptr %i, align 4
  %conv25 = zext i32 %32 to i64
  %33 = load ptr, ptr %r.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %33, i32 0, i32 6
  %34 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %conv25, %34
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load ptr, ptr %out.addr, align 8
  %36 = load ptr, ptr %r.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %36, i32 0, i32 7
  %37 = load ptr, ptr %element, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom = zext i32 %38 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %37, i64 %idxprom
  %39 = load ptr, ptr %arrayidx, align 8
  %40 = load i32, ptr %mode.addr, align 4
  %call27 = call ptr @cliFormatReplyJson(ptr noundef %35, ptr noundef %39, i32 noundef %40)
  store ptr %call27, ptr %out.addr, align 8
  %41 = load i32, ptr %i, align 4
  %conv28 = zext i32 %41 to i64
  %42 = load ptr, ptr %r.addr, align 8
  %elements29 = getelementptr inbounds %struct.redisReply, ptr %42, i32 0, i32 6
  %43 = load i64, ptr %elements29, align 8
  %sub = sub i64 %43, 1
  %cmp30 = icmp ne i64 %conv28, %sub
  br i1 %cmp30, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %44 = load ptr, ptr %out.addr, align 8
  %call32 = call ptr @hi_sdscat(ptr noundef %44, ptr noundef @.str.220)
  store ptr %call32, ptr %out.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %45 = load i32, ptr %i, align 4
  %inc = add i32 %45, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !237

for.end:                                          ; preds = %for.cond
  %46 = load ptr, ptr %out.addr, align 8
  %call33 = call ptr @hi_sdscat(ptr noundef %46, ptr noundef @.str.157)
  store ptr %call33, ptr %out.addr, align 8
  br label %sw.epilog

sw.bb34:                                          ; preds = %entry
  %47 = load ptr, ptr %out.addr, align 8
  %call35 = call ptr @hi_sdscat(ptr noundef %47, ptr noundef @.str.606)
  store ptr %call35, ptr %out.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond36

for.cond36:                                       ; preds = %for.inc86, %sw.bb34
  %48 = load i32, ptr %i, align 4
  %conv37 = zext i32 %48 to i64
  %49 = load ptr, ptr %r.addr, align 8
  %elements38 = getelementptr inbounds %struct.redisReply, ptr %49, i32 0, i32 6
  %50 = load i64, ptr %elements38, align 8
  %cmp39 = icmp ult i64 %conv37, %50
  br i1 %cmp39, label %for.body41, label %for.end88

for.body41:                                       ; preds = %for.cond36
  %51 = load ptr, ptr %r.addr, align 8
  %element42 = getelementptr inbounds %struct.redisReply, ptr %51, i32 0, i32 7
  %52 = load ptr, ptr %element42, align 8
  %53 = load i32, ptr %i, align 4
  %idxprom43 = zext i32 %53 to i64
  %arrayidx44 = getelementptr inbounds ptr, ptr %52, i64 %idxprom43
  %54 = load ptr, ptr %arrayidx44, align 8
  store ptr %54, ptr %key, align 8
  %55 = load ptr, ptr %key, align 8
  %type45 = getelementptr inbounds %struct.redisReply, ptr %55, i32 0, i32 0
  %56 = load i32, ptr %type45, align 8
  %cmp46 = icmp eq i32 %56, 6
  br i1 %cmp46, label %if.then59, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body41
  %57 = load ptr, ptr %key, align 8
  %type48 = getelementptr inbounds %struct.redisReply, ptr %57, i32 0, i32 0
  %58 = load i32, ptr %type48, align 8
  %cmp49 = icmp eq i32 %58, 5
  br i1 %cmp49, label %if.then59, label %lor.lhs.false51

lor.lhs.false51:                                  ; preds = %lor.lhs.false
  %59 = load ptr, ptr %key, align 8
  %type52 = getelementptr inbounds %struct.redisReply, ptr %59, i32 0, i32 0
  %60 = load i32, ptr %type52, align 8
  %cmp53 = icmp eq i32 %60, 1
  br i1 %cmp53, label %if.then59, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %lor.lhs.false51
  %61 = load ptr, ptr %key, align 8
  %type56 = getelementptr inbounds %struct.redisReply, ptr %61, i32 0, i32 0
  %62 = load i32, ptr %type56, align 8
  %cmp57 = icmp eq i32 %62, 14
  br i1 %cmp57, label %if.then59, label %if.else

if.then59:                                        ; preds = %lor.lhs.false55, %lor.lhs.false51, %lor.lhs.false, %for.body41
  %63 = load ptr, ptr %out.addr, align 8
  %64 = load ptr, ptr %key, align 8
  %65 = load i32, ptr %mode.addr, align 4
  %call60 = call ptr @cliFormatReplyJson(ptr noundef %63, ptr noundef %64, i32 noundef %65)
  store ptr %call60, ptr %out.addr, align 8
  br label %if.end72

if.else:                                          ; preds = %lor.lhs.false55
  %call61 = call ptr @hi_sdsempty()
  %66 = load ptr, ptr %key, align 8
  %67 = load i32, ptr %mode.addr, align 4
  %call62 = call ptr @cliFormatReplyJson(ptr noundef %call61, ptr noundef %66, i32 noundef %67)
  store ptr %call62, ptr %keystr, align 8
  %68 = load ptr, ptr %keystr, align 8
  %arrayidx63 = getelementptr inbounds i8, ptr %68, i64 0
  %69 = load i8, ptr %arrayidx63, align 1
  %conv64 = sext i8 %69 to i32
  %cmp65 = icmp eq i32 %conv64, 34
  br i1 %cmp65, label %if.then67, label %if.else69

if.then67:                                        ; preds = %if.else
  %70 = load ptr, ptr %out.addr, align 8
  %71 = load ptr, ptr %keystr, align 8
  %call68 = call ptr @hi_sdscatsds(ptr noundef %70, ptr noundef %71)
  store ptr %call68, ptr %out.addr, align 8
  br label %if.end71

if.else69:                                        ; preds = %if.else
  %72 = load ptr, ptr %out.addr, align 8
  %73 = load ptr, ptr %keystr, align 8
  %call70 = call ptr (ptr, ptr, ...) @hi_sdscatfmt(ptr noundef %72, ptr noundef @.str.607, ptr noundef %73)
  store ptr %call70, ptr %out.addr, align 8
  br label %if.end71

if.end71:                                         ; preds = %if.else69, %if.then67
  %74 = load ptr, ptr %keystr, align 8
  call void @hi_sdsfree(ptr noundef %74)
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.then59
  %75 = load ptr, ptr %out.addr, align 8
  %call73 = call ptr @hi_sdscat(ptr noundef %75, ptr noundef @.str.608)
  store ptr %call73, ptr %out.addr, align 8
  %76 = load ptr, ptr %out.addr, align 8
  %77 = load ptr, ptr %r.addr, align 8
  %element74 = getelementptr inbounds %struct.redisReply, ptr %77, i32 0, i32 7
  %78 = load ptr, ptr %element74, align 8
  %79 = load i32, ptr %i, align 4
  %add = add i32 %79, 1
  %idxprom75 = zext i32 %add to i64
  %arrayidx76 = getelementptr inbounds ptr, ptr %78, i64 %idxprom75
  %80 = load ptr, ptr %arrayidx76, align 8
  %81 = load i32, ptr %mode.addr, align 4
  %call77 = call ptr @cliFormatReplyJson(ptr noundef %76, ptr noundef %80, i32 noundef %81)
  store ptr %call77, ptr %out.addr, align 8
  %82 = load i32, ptr %i, align 4
  %conv78 = zext i32 %82 to i64
  %83 = load ptr, ptr %r.addr, align 8
  %elements79 = getelementptr inbounds %struct.redisReply, ptr %83, i32 0, i32 6
  %84 = load i64, ptr %elements79, align 8
  %sub80 = sub i64 %84, 2
  %cmp81 = icmp ne i64 %conv78, %sub80
  br i1 %cmp81, label %if.then83, label %if.end85

if.then83:                                        ; preds = %if.end72
  %85 = load ptr, ptr %out.addr, align 8
  %call84 = call ptr @hi_sdscat(ptr noundef %85, ptr noundef @.str.220)
  store ptr %call84, ptr %out.addr, align 8
  br label %if.end85

if.end85:                                         ; preds = %if.then83, %if.end72
  br label %for.inc86

for.inc86:                                        ; preds = %if.end85
  %86 = load i32, ptr %i, align 4
  %add87 = add i32 %86, 2
  store i32 %add87, ptr %i, align 4
  br label %for.cond36, !llvm.loop !238

for.end88:                                        ; preds = %for.cond36
  %87 = load ptr, ptr %out.addr, align 8
  %call89 = call ptr @hi_sdscat(ptr noundef %87, ptr noundef @.str.609)
  store ptr %call89, ptr %out.addr, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %88 = load ptr, ptr @stderr, align 8
  %89 = load ptr, ptr %r.addr, align 8
  %type90 = getelementptr inbounds %struct.redisReply, ptr %89, i32 0, i32 0
  %90 = load i32, ptr %type90, align 8
  %call91 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %88, ptr noundef @.str.425, i32 noundef %90)
  call void @exit(i32 noundef 1) #17
  unreachable

sw.epilog:                                        ; preds = %for.end88, %for.end, %sw.bb20, %sw.bb18, %sw.bb13, %sw.bb10, %sw.bb8, %sw.bb4, %sw.bb
  %91 = load ptr, ptr %out.addr, align 8
  ret ptr %91
}

declare ptr @hi_sdscatrepr(ptr noundef, ptr noundef, i64 noundef) #2

declare i32 @hi_sdsrange(ptr noundef, i64 noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @cliIsMultilineValueTTY(ptr noundef %r) #0 {
entry:
  %retval = alloca i32, align 4
  %r.addr = alloca ptr, align 8
  store ptr %r, ptr %r.addr, align 8
  %0 = load ptr, ptr %r.addr, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  switch i32 %1, label %sw.default [
    i32 2, label %sw.bb
    i32 10, label %sw.bb
    i32 12, label %sw.bb
    i32 9, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  %2 = load ptr, ptr %r.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %2, i32 0, i32 6
  %3 = load i64, ptr %elements, align 8
  %cmp = icmp eq i64 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %sw.bb
  %4 = load ptr, ptr %r.addr, align 8
  %elements1 = getelementptr inbounds %struct.redisReply, ptr %4, i32 0, i32 6
  %5 = load i64, ptr %elements1, align 8
  %cmp2 = icmp ugt i64 %5, 1
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %r.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 7
  %7 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 0
  %8 = load ptr, ptr %arrayidx, align 8
  %call = call i32 @cliIsMultilineValueTTY(ptr noundef %8)
  store i32 %call, ptr %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %entry
  %9 = load ptr, ptr %r.addr, align 8
  %elements6 = getelementptr inbounds %struct.redisReply, ptr %9, i32 0, i32 6
  %10 = load i64, ptr %elements6, align 8
  %cmp7 = icmp eq i64 %10, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %sw.bb5
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %sw.bb5
  %11 = load ptr, ptr %r.addr, align 8
  %elements10 = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 6
  %12 = load i64, ptr %elements10, align 8
  %cmp11 = icmp ugt i64 %12, 2
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end9
  store i32 1, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end9
  %13 = load ptr, ptr %r.addr, align 8
  %element14 = getelementptr inbounds %struct.redisReply, ptr %13, i32 0, i32 7
  %14 = load ptr, ptr %element14, align 8
  %arrayidx15 = getelementptr inbounds ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx15, align 8
  %call16 = call i32 @cliIsMultilineValueTTY(ptr noundef %15)
  store i32 %call16, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %if.end13, %if.then12, %if.then8, %if.end4, %if.then3, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal ptr @jsonStringOutput(ptr noundef %out, ptr noundef %p, i32 noundef %len, i32 noundef %mode) #0 {
entry:
  %retval = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %len.addr = alloca i32, align 4
  %mode.addr = alloca i32, align 4
  %tmp = alloca ptr, align 8
  %tmplen = alloca i32, align 4
  %n = alloca ptr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i32 %len, ptr %len.addr, align 4
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load i32, ptr %mode.addr, align 4
  %cmp = icmp eq i32 %0, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %out.addr, align 8
  %2 = load ptr, ptr %p.addr, align 8
  %3 = load i32, ptr %len.addr, align 4
  %conv = sext i32 %3 to i64
  %call = call ptr @escapeJsonString(ptr noundef %1, ptr noundef %2, i64 noundef %conv)
  store ptr %call, ptr %retval, align 8
  br label %if.end18

if.else:                                          ; preds = %entry
  %4 = load i32, ptr %mode.addr, align 4
  %cmp1 = icmp eq i32 %4, 4
  br i1 %cmp1, label %if.then3, label %if.else16

if.then3:                                         ; preds = %if.else
  %call4 = call ptr @hi_sdsempty()
  %5 = load ptr, ptr %p.addr, align 8
  %6 = load i32, ptr %len.addr, align 4
  %conv5 = sext i32 %6 to i64
  %call6 = call ptr @hi_sdscatrepr(ptr noundef %call4, ptr noundef %5, i64 noundef %conv5)
  store ptr %call6, ptr %tmp, align 8
  %7 = load ptr, ptr %tmp, align 8
  %call7 = call i64 @hi_sdslen(ptr noundef %7)
  %conv8 = trunc i64 %call7 to i32
  store i32 %conv8, ptr %tmplen, align 4
  %8 = load ptr, ptr %tmp, align 8
  store ptr %8, ptr %n, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %if.then3
  %9 = load i32, ptr %tmplen, align 4
  %dec = add nsw i32 %9, -1
  store i32 %dec, ptr %tmplen, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load ptr, ptr %n, align 8
  %11 = load i8, ptr %10, align 1
  %conv9 = sext i8 %11 to i32
  %cmp10 = icmp eq i32 %conv9, 92
  br i1 %cmp10, label %if.then12, label %if.else14

if.then12:                                        ; preds = %while.body
  %12 = load ptr, ptr %out.addr, align 8
  %call13 = call ptr @hi_sdscatlen(ptr noundef %12, ptr noundef @.str.610, i64 noundef 2)
  store ptr %call13, ptr %out.addr, align 8
  br label %if.end

if.else14:                                        ; preds = %while.body
  %13 = load ptr, ptr %out.addr, align 8
  %14 = load ptr, ptr %n, align 8
  %call15 = call ptr @hi_sdscatlen(ptr noundef %13, ptr noundef %14, i64 noundef 1)
  store ptr %call15, ptr %out.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else14, %if.then12
  %15 = load ptr, ptr %n, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %15, i32 1
  store ptr %incdec.ptr, ptr %n, align 8
  br label %while.cond, !llvm.loop !239

while.end:                                        ; preds = %while.cond
  %16 = load ptr, ptr %tmp, align 8
  call void @hi_sdsfree(ptr noundef %16)
  %17 = load ptr, ptr %out.addr, align 8
  store ptr %17, ptr %retval, align 8
  br label %if.end18

if.else16:                                        ; preds = %if.else
  br label %if.end17

if.end17:                                         ; preds = %if.else16
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %while.end, %if.then
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

declare ptr @escapeJsonString(ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define internal i64 @mstime() #0 {
entry:
  %call = call i64 @ustime()
  %div = sdiv i64 %call, 1000
  ret i64 %div
}

; Function Attrs: nounwind uwtable
define internal void @latencyModePrint(i64 noundef %min, i64 noundef %max, double noundef %avg, i64 noundef %count) #0 {
entry:
  %min.addr = alloca i64, align 8
  %max.addr = alloca i64, align 8
  %avg.addr = alloca double, align 8
  %count.addr = alloca i64, align 8
  store i64 %min, ptr %min.addr, align 8
  store i64 %max, ptr %max.addr, align 8
  store double %avg, ptr %avg.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %min.addr, align 8
  %2 = load i64, ptr %max.addr, align 8
  %3 = load double, ptr %avg.addr, align 8
  %4 = load i64, ptr %count.addr, align 8
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.614, i64 noundef %1, i64 noundef %2, double noundef %3, i64 noundef %4)
  %5 = load ptr, ptr @stdout, align 8
  %call1 = call i32 @fflush(ptr noundef %5)
  br label %if.end15

if.else:                                          ; preds = %entry
  %6 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp2 = icmp eq i32 %6, 2
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  %7 = load i64, ptr %min.addr, align 8
  %8 = load i64, ptr %max.addr, align 8
  %9 = load double, ptr %avg.addr, align 8
  %10 = load i64, ptr %count.addr, align 8
  %call4 = call i32 (ptr, ...) @printf(ptr noundef @.str.615, i64 noundef %7, i64 noundef %8, double noundef %9, i64 noundef %10)
  br label %if.end14

if.else5:                                         ; preds = %if.else
  %11 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp6 = icmp eq i32 %11, 1
  br i1 %cmp6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.else5
  %12 = load i64, ptr %min.addr, align 8
  %13 = load i64, ptr %max.addr, align 8
  %14 = load double, ptr %avg.addr, align 8
  %15 = load i64, ptr %count.addr, align 8
  %call8 = call i32 (ptr, ...) @printf(ptr noundef @.str.616, i64 noundef %12, i64 noundef %13, double noundef %14, i64 noundef %15)
  br label %if.end13

if.else9:                                         ; preds = %if.else5
  %16 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp10 = icmp eq i32 %16, 3
  br i1 %cmp10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.else9
  %17 = load i64, ptr %min.addr, align 8
  %18 = load i64, ptr %max.addr, align 8
  %19 = load double, ptr %avg.addr, align 8
  %20 = load i64, ptr %count.addr, align 8
  %call12 = call i32 (ptr, ...) @printf(ptr noundef @.str.617, i64 noundef %17, i64 noundef %18, double noundef %19, i64 noundef %20)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.else9
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then7
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.then3
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @ustime() #0 {
entry:
  %tv = alloca %struct.timeval, align 8
  %ust = alloca i64, align 8
  %call = call i32 @gettimeofday(ptr noundef %tv, ptr noundef null) #15
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 0
  %0 = load i64, ptr %tv_sec, align 8
  %mul = mul nsw i64 %0, 1000000
  store i64 %mul, ptr %ust, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 1
  %1 = load i64, ptr %tv_usec, align 8
  %2 = load i64, ptr %ust, align 8
  %add = add nsw i64 %2, %1
  store i64 %add, ptr %ust, align 8
  %3 = load i64, ptr %ust, align 8
  ret i64 %3
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #5

; Function Attrs: nounwind uwtable
define internal i32 @cliReadReply(i32 noundef %output_raw_strings) #0 {
entry:
  %retval = alloca i32, align 4
  %output_raw_strings.addr = alloca i32, align 4
  %_reply = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %out = alloca ptr, align 8
  %output = alloca i32, align 4
  %p = alloca ptr, align 8
  %s = alloca ptr, align 8
  %slot = alloca i32, align 4
  store i32 %output_raw_strings, ptr %output_raw_strings.addr, align 4
  store ptr null, ptr %out, align 8
  store i32 1, ptr %output, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 52), align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 52), align 8
  call void @freeReplyObject(ptr noundef %1)
  store ptr null, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 52), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load ptr, ptr @context, align 8
  %call = call i32 @redisGetReply(ptr noundef %2, ptr noundef %_reply)
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then1, label %if.end23

if.then1:                                         ; preds = %if.end
  %3 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 11), align 4
  %tobool2 = icmp ne i32 %3, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.then1
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 11), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 9), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %call4 = call i32 @cliConnect(i32 noundef 1)
  store i32 %call4, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.then1
  %4 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 8), align 8
  %tobool6 = icmp ne i32 %4, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end5
  %5 = load ptr, ptr @context, align 8
  call void @redisFree(ptr noundef %5)
  store ptr null, ptr @context, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end5
  %6 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 7), align 4
  %tobool9 = icmp ne i32 %6, 0
  br i1 %tobool9, label %if.then10, label %if.end22

if.then10:                                        ; preds = %if.end8
  %7 = load ptr, ptr @context, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %7, i32 0, i32 1
  %8 = load i32, ptr %err, align 8
  %cmp11 = icmp eq i32 %8, 1
  br i1 %cmp11, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then10
  %call12 = call ptr @__errno_location() #16
  %9 = load i32, ptr %call12, align 4
  %cmp13 = icmp eq i32 %9, 104
  br i1 %cmp13, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %call14 = call ptr @__errno_location() #16
  %10 = load i32, ptr %call14, align 4
  %cmp15 = icmp eq i32 %10, 32
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %land.lhs.true
  store i32 -1, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %lor.lhs.false, %if.then10
  %11 = load ptr, ptr @context, align 8
  %err18 = getelementptr inbounds %struct.redisContext, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %err18, align 8
  %cmp19 = icmp eq i32 %12, 3
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end17
  store i32 -1, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end17
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end8
  call void @cliPrintContextError()
  call void @exit(i32 noundef 1) #17
  unreachable

if.end23:                                         ; preds = %if.end
  %13 = load ptr, ptr %_reply, align 8
  store ptr %13, ptr %reply, align 8
  store ptr %13, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 52), align 8
  %14 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %14, i32 0, i32 0
  %15 = load i32, ptr %type, align 8
  store i32 %15, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %16 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 17), align 8
  %tobool24 = icmp ne i32 %16, 0
  br i1 %tobool24, label %land.lhs.true25, label %if.else

land.lhs.true25:                                  ; preds = %if.end23
  %17 = load ptr, ptr %reply, align 8
  %type26 = getelementptr inbounds %struct.redisReply, ptr %17, i32 0, i32 0
  %18 = load i32, ptr %type26, align 8
  %cmp27 = icmp eq i32 %18, 6
  br i1 %cmp27, label %land.lhs.true28, label %if.else

land.lhs.true28:                                  ; preds = %land.lhs.true25
  %19 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 4
  %20 = load ptr, ptr %str, align 8
  %call29 = call i32 @strncmp(ptr noundef %20, ptr noundef @.str.627, i64 noundef 6) #12
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %lor.lhs.false31, label %if.then35

lor.lhs.false31:                                  ; preds = %land.lhs.true28
  %21 = load ptr, ptr %reply, align 8
  %str32 = getelementptr inbounds %struct.redisReply, ptr %21, i32 0, i32 4
  %22 = load ptr, ptr %str32, align 8
  %call33 = call i32 @strncmp(ptr noundef %22, ptr noundef @.str.628, i64 noundef 4) #12
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.else, label %if.then35

if.then35:                                        ; preds = %lor.lhs.false31, %land.lhs.true28
  %23 = load ptr, ptr %reply, align 8
  %str36 = getelementptr inbounds %struct.redisReply, ptr %23, i32 0, i32 4
  %24 = load ptr, ptr %str36, align 8
  store ptr %24, ptr %p, align 8
  store i32 0, ptr %output, align 4
  %25 = load ptr, ptr %p, align 8
  %call37 = call ptr @strchr(ptr noundef %25, i32 noundef 32) #12
  store ptr %call37, ptr %s, align 8
  %26 = load ptr, ptr %s, align 8
  %add.ptr = getelementptr inbounds i8, ptr %26, i64 1
  %call38 = call ptr @strchr(ptr noundef %add.ptr, i32 noundef 32) #12
  store ptr %call38, ptr %p, align 8
  %27 = load ptr, ptr %p, align 8
  store i8 0, ptr %27, align 1
  %28 = load ptr, ptr %s, align 8
  %add.ptr39 = getelementptr inbounds i8, ptr %28, i64 1
  %call40 = call i32 @atoi(ptr noundef %add.ptr39) #12
  store i32 %call40, ptr %slot, align 4
  %29 = load ptr, ptr %p, align 8
  %add.ptr41 = getelementptr inbounds i8, ptr %29, i64 1
  %call42 = call ptr @strrchr(ptr noundef %add.ptr41, i32 noundef 58) #12
  store ptr %call42, ptr %s, align 8
  %30 = load ptr, ptr %s, align 8
  store i8 0, ptr %30, align 1
  %31 = load ptr, ptr %p, align 8
  %add.ptr43 = getelementptr inbounds i8, ptr %31, i64 1
  %32 = load ptr, ptr %s, align 8
  %cmp44 = icmp ne ptr %add.ptr43, %32
  br i1 %cmp44, label %if.then45, label %if.end48

if.then45:                                        ; preds = %if.then35
  %33 = load ptr, ptr @config, align 8
  call void @hi_sdsfree(ptr noundef %33)
  %34 = load ptr, ptr %p, align 8
  %add.ptr46 = getelementptr inbounds i8, ptr %34, i64 1
  %call47 = call ptr @hi_sdsnew(ptr noundef %add.ptr46)
  store ptr %call47, ptr @config, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then45, %if.then35
  %35 = load ptr, ptr %s, align 8
  %add.ptr49 = getelementptr inbounds i8, ptr %35, i64 1
  %call50 = call i32 @atoi(ptr noundef %add.ptr49) #12
  store i32 %call50, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %36 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 7), align 4
  %tobool51 = icmp ne i32 %36, 0
  br i1 %tobool51, label %if.then52, label %if.end54

if.then52:                                        ; preds = %if.end48
  %37 = load i32, ptr %slot, align 4
  %38 = load ptr, ptr @config, align 8
  %39 = load i32, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 1), align 8
  %call53 = call i32 (ptr, ...) @printf(ptr noundef @.str.629, i32 noundef %37, ptr noundef %38, i32 noundef %39)
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %if.end48
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 18), align 4
  %40 = load ptr, ptr %reply, align 8
  %str55 = getelementptr inbounds %struct.redisReply, ptr %40, i32 0, i32 4
  %41 = load ptr, ptr %str55, align 8
  %call56 = call i32 @strncmp(ptr noundef %41, ptr noundef @.str.628, i64 noundef 4) #12
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %if.end59, label %if.then58

if.then58:                                        ; preds = %if.end54
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 19), align 8
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %if.end54
  call void @cliRefreshPrompt()
  br label %if.end70

if.else:                                          ; preds = %lor.lhs.false31, %land.lhs.true25, %if.end23
  %42 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 7), align 4
  %tobool60 = icmp ne i32 %42, 0
  br i1 %tobool60, label %if.end69, label %land.lhs.true61

land.lhs.true61:                                  ; preds = %if.else
  %43 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 54), align 4
  %tobool62 = icmp ne i32 %43, 0
  br i1 %tobool62, label %land.lhs.true63, label %if.end69

land.lhs.true63:                                  ; preds = %land.lhs.true61
  %44 = load ptr, ptr %reply, align 8
  %type64 = getelementptr inbounds %struct.redisReply, ptr %44, i32 0, i32 0
  %45 = load i32, ptr %type64, align 8
  %cmp65 = icmp eq i32 %45, 6
  br i1 %cmp65, label %if.then66, label %if.end69

if.then66:                                        ; preds = %land.lhs.true63
  %46 = load ptr, ptr @stderr, align 8
  %47 = load ptr, ptr %reply, align 8
  %str67 = getelementptr inbounds %struct.redisReply, ptr %47, i32 0, i32 4
  %48 = load ptr, ptr %str67, align 8
  %call68 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %46, ptr noundef @.str.115, ptr noundef %48)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end69:                                         ; preds = %land.lhs.true63, %land.lhs.true61, %if.else
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.end59
  %49 = load i32, ptr %output, align 4
  %tobool71 = icmp ne i32 %49, 0
  br i1 %tobool71, label %if.then72, label %if.end77

if.then72:                                        ; preds = %if.end70
  %50 = load ptr, ptr %reply, align 8
  %51 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %52 = load i32, ptr %output_raw_strings.addr, align 4
  %call73 = call ptr @cliFormatReply(ptr noundef %50, i32 noundef %51, i32 noundef %52)
  store ptr %call73, ptr %out, align 8
  %53 = load ptr, ptr %out, align 8
  %54 = load ptr, ptr %out, align 8
  %call74 = call i64 @hi_sdslen(ptr noundef %54)
  %55 = load ptr, ptr @stdout, align 8
  %call75 = call i64 @fwrite(ptr noundef %53, i64 noundef %call74, i64 noundef 1, ptr noundef %55)
  %56 = load ptr, ptr @stdout, align 8
  %call76 = call i32 @fflush(ptr noundef %56)
  %57 = load ptr, ptr %out, align 8
  call void @hi_sdsfree(ptr noundef %57)
  br label %if.end77

if.end77:                                         ; preds = %if.then72, %if.end70
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end77, %if.then20, %if.then16, %if.then7, %if.then3
  %58 = load i32, ptr %retval, align 4
  ret i32 %58
}

; Function Attrs: nounwind uwtable
define internal void @cliPrintContextError() #0 {
entry:
  %0 = load ptr, ptr @context, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @stderr, align 8
  %2 = load ptr, ptr @context, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %2, i32 0, i32 2
  %arraydecay = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %1, ptr noundef @.str.418, ptr noundef %arraydecay)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @clusterManagerGetNodeRDBFilename(ptr noundef %node) #0 {
entry:
  %node.addr = alloca ptr, align 8
  %filename = alloca ptr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 55, i32 15), align 8
  %call = call ptr @hi_sdsnew(ptr noundef %0)
  store ptr %call, ptr %filename, align 8
  %1 = load ptr, ptr %filename, align 8
  %2 = load ptr, ptr %filename, align 8
  %call1 = call i64 @hi_sdslen(ptr noundef %2)
  %sub = sub i64 %call1, 1
  %arrayidx = getelementptr inbounds i8, ptr %1, i64 %sub
  %3 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %3 to i32
  %cmp = icmp ne i32 %conv, 47
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %filename, align 8
  %call3 = call ptr @hi_sdscat(ptr noundef %4, ptr noundef @.str.437)
  store ptr %call3, ptr %filename, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %filename, align 8
  %6 = load ptr, ptr %node.addr, align 8
  %ip = getelementptr inbounds %struct.clusterManagerNode, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %ip, align 8
  %8 = load ptr, ptr %node.addr, align 8
  %port = getelementptr inbounds %struct.clusterManagerNode, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %port, align 8
  %10 = load ptr, ptr %node.addr, align 8
  %name = getelementptr inbounds %struct.clusterManagerNode, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %name, align 8
  %call4 = call ptr (ptr, ptr, ...) @hi_sdscatprintf(ptr noundef %5, ptr noundef @.str.641, ptr noundef %7, i32 noundef %9, ptr noundef %11)
  store ptr %call4, ptr %filename, align 8
  %12 = load ptr, ptr %filename, align 8
  ret ptr %12
}

declare i32 @open64(ptr noundef, i32 noundef, ...) #2

declare i64 @write(i32 noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i32 @ftruncate64(i32 noundef, i64 noundef) #6

declare i32 @fsync(i32 noundef) #2

declare i32 @close(i32 noundef) #2

declare i32 @anetNonBlock(ptr noundef, i32 noundef) #2

declare i32 @aeWait(i32 noundef, i32 noundef, i64 noundef) #2

declare i32 @redisBufferRead(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @typeinfo_add(ptr noundef %types, ptr noundef %name, ptr noundef %type_template) #0 {
entry:
  %types.addr = alloca ptr, align 8
  %name.addr = alloca ptr, align 8
  %type_template.addr = alloca ptr, align 8
  %info = alloca ptr, align 8
  store ptr %types, ptr %types.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store ptr %type_template, ptr %type_template.addr, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 56) #14
  store ptr %call, ptr %info, align 8
  %0 = load ptr, ptr %info, align 8
  %1 = load ptr, ptr %type_template.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %1, i64 56, i1 false)
  %2 = load ptr, ptr %name.addr, align 8
  %call1 = call ptr @hi_sdsnew(ptr noundef %2)
  %3 = load ptr, ptr %info, align 8
  %name2 = getelementptr inbounds %struct.typeinfo, ptr %3, i32 0, i32 0
  store ptr %call1, ptr %name2, align 8
  %4 = load ptr, ptr %types.addr, align 8
  %5 = load ptr, ptr %info, align 8
  %name3 = getelementptr inbounds %struct.typeinfo, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %name3, align 8
  %7 = load ptr, ptr %info, align 8
  %call4 = call i32 @dictAdd(ptr noundef %4, ptr noundef %6, ptr noundef %7)
  %8 = load ptr, ptr %info, align 8
  ret ptr %8
}

; Function Attrs: nounwind uwtable
define internal void @longStatLoopModeStop(i32 noundef %s) #0 {
entry:
  %s.addr = alloca i32, align 4
  store i32 %s, ptr %s.addr, align 4
  store volatile i32 1, ptr @force_cancel_loop, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @getDbSize() #0 {
entry:
  %reply = alloca ptr, align 8
  %size = alloca i32, align 4
  %0 = load ptr, ptr @context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %0, ptr noundef @.str.357)
  store ptr %call, ptr %reply, align 8
  %1 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @stderr, align 8
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef @.str.76)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type, align 8
  %cmp2 = icmp eq i32 %4, 6
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  %5 = load ptr, ptr @stderr, align 8
  %6 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %str, align 8
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.664, ptr noundef %7)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else5:                                         ; preds = %if.else
  %8 = load ptr, ptr %reply, align 8
  %type6 = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type6, align 8
  %cmp7 = icmp ne i32 %9, 3
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else5
  %10 = load ptr, ptr @stderr, align 8
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef @.str.665)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %if.else5
  br label %if.end10

if.end10:                                         ; preds = %if.end
  br label %if.end11

if.end11:                                         ; preds = %if.end10
  %11 = load ptr, ptr %reply, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %integer, align 8
  %conv = trunc i64 %12 to i32
  store i32 %conv, ptr %size, align 4
  %13 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %13)
  %14 = load i32, ptr %size, align 4
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal void @sendReadOnly() #0 {
entry:
  %read_reply = alloca ptr, align 8
  %0 = load ptr, ptr @context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %0, ptr noundef @.str.666)
  store ptr %call, ptr %read_reply, align 8
  %1 = load ptr, ptr %read_reply, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @stderr, align 8
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef @.str.76)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %read_reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type, align 8
  %cmp2 = icmp eq i32 %4, 6
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %5 = load ptr, ptr %read_reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %5, i32 0, i32 4
  %6 = load ptr, ptr %str, align 8
  %call3 = call i32 @strcmp(ptr noundef %6, ptr noundef @.str.667) #12
  %cmp4 = icmp ne i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %land.lhs.true
  %7 = load ptr, ptr @stderr, align 8
  %8 = load ptr, ptr %read_reply, align 8
  %str6 = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %str6, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef @.str.418, ptr noundef %9)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %land.lhs.true, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end
  %10 = load ptr, ptr %read_reply, align 8
  call void @freeReplyObject(ptr noundef %10)
  ret void
}

; Function Attrs: nounwind uwtable
define internal ptr @sendScan(ptr noundef %it) #0 {
entry:
  %it.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr @context, align 8
  %2 = load ptr, ptr %it.addr, align 8
  %3 = load i64, ptr %2, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 30), align 8
  %call = call i64 @hi_sdslen(ptr noundef %5)
  %6 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 27), align 8
  %call1 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.668, i64 noundef %3, ptr noundef %4, i64 noundef %call, i32 noundef %6)
  store ptr %call1, ptr %reply, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr @context, align 8
  %8 = load ptr, ptr %it.addr, align 8
  %9 = load i64, ptr %8, align 8
  %call2 = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %7, ptr noundef @.str.669, i64 noundef %9)
  store ptr %call2, ptr %reply, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %10, null
  br i1 %cmp, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.end
  %11 = load ptr, ptr @stderr, align 8
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %11, ptr noundef @.str.76)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else5:                                         ; preds = %if.end
  %12 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %type, align 8
  %cmp6 = icmp eq i32 %13, 6
  br i1 %cmp6, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.else5
  %14 = load ptr, ptr @stderr, align 8
  %15 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %str, align 8
  %call8 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %14, ptr noundef @.str.670, ptr noundef %16)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else9:                                         ; preds = %if.else5
  %17 = load ptr, ptr %reply, align 8
  %type10 = getelementptr inbounds %struct.redisReply, ptr %17, i32 0, i32 0
  %18 = load i32, ptr %type10, align 8
  %cmp11 = icmp ne i32 %18, 2
  br i1 %cmp11, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.else9
  %19 = load ptr, ptr @stderr, align 8
  %call13 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %19, ptr noundef @.str.671)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else14:                                        ; preds = %if.else9
  %20 = load ptr, ptr %reply, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %20, i32 0, i32 6
  %21 = load i64, ptr %elements, align 8
  %cmp15 = icmp ne i64 %21, 2
  br i1 %cmp15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.else14
  %22 = load ptr, ptr @stderr, align 8
  %call17 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %22, ptr noundef @.str.672)
  call void @exit(i32 noundef 1) #17
  unreachable

if.end18:                                         ; preds = %if.else14
  br label %if.end19

if.end19:                                         ; preds = %if.end18
  br label %if.end20

if.end20:                                         ; preds = %if.end19
  br label %if.end21

if.end21:                                         ; preds = %if.end20
  %23 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %23, i32 0, i32 7
  %24 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %24, i64 0
  %25 = load ptr, ptr %arrayidx, align 8
  %str22 = getelementptr inbounds %struct.redisReply, ptr %25, i32 0, i32 4
  %26 = load ptr, ptr %str22, align 8
  %call23 = call i64 @strtoull(ptr noundef %26, ptr noundef null, i32 noundef 10) #15
  %27 = load ptr, ptr %it.addr, align 8
  store i64 %call23, ptr %27, align 8
  %28 = load ptr, ptr %reply, align 8
  ret ptr %28
}

; Function Attrs: nounwind uwtable
define internal void @getKeyTypes(ptr noundef %types_dict, ptr noundef %keys, ptr noundef %types) #0 {
entry:
  %types_dict.addr = alloca ptr, align 8
  %keys.addr = alloca ptr, align 8
  %types.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %i = alloca i32, align 4
  %argv = alloca [2 x ptr], align 16
  %lens = alloca [2 x i64], align 16
  %typereply = alloca ptr, align 8
  %de = alloca ptr, align 8
  %type44 = alloca ptr, align 8
  store ptr %types_dict, ptr %types_dict.addr, align 8
  store ptr %keys, ptr %keys.addr, align 8
  store ptr %types, ptr %types.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %conv = zext i32 %0 to i64
  %1 = load ptr, ptr %keys.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %1, i32 0, i32 6
  %2 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %conv, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayinit.begin = getelementptr inbounds [2 x ptr], ptr %argv, i64 0, i64 0
  store ptr @.str.673, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %3 = load ptr, ptr %keys.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 7
  %4 = load ptr, ptr %element, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %str, align 8
  store ptr %7, ptr %arrayinit.element, align 8
  %arrayinit.begin2 = getelementptr inbounds [2 x i64], ptr %lens, i64 0, i64 0
  store i64 4, ptr %arrayinit.begin2, align 8
  %arrayinit.element3 = getelementptr inbounds i64, ptr %arrayinit.begin2, i64 1
  %8 = load ptr, ptr %keys.addr, align 8
  %element4 = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 7
  %9 = load ptr, ptr %element4, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom5 = zext i32 %10 to i64
  %arrayidx6 = getelementptr inbounds ptr, ptr %9, i64 %idxprom5
  %11 = load ptr, ptr %arrayidx6, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %len, align 8
  store i64 %12, ptr %arrayinit.element3, align 8
  %13 = load ptr, ptr @context, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argv, i64 0, i64 0
  %arraydecay7 = getelementptr inbounds [2 x i64], ptr %lens, i64 0, i64 0
  %call = call i32 @redisAppendCommandArgv(ptr noundef %13, i32 noundef 2, ptr noundef %arraydecay, ptr noundef %arraydecay7)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, ptr %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !240

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %i, align 4
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc58, %for.end
  %15 = load i32, ptr %i, align 4
  %conv9 = zext i32 %15 to i64
  %16 = load ptr, ptr %keys.addr, align 8
  %elements10 = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 6
  %17 = load i64, ptr %elements10, align 8
  %cmp11 = icmp ult i64 %conv9, %17
  br i1 %cmp11, label %for.body13, label %for.end60

for.body13:                                       ; preds = %for.cond8
  %18 = load ptr, ptr @context, align 8
  %call14 = call i32 @redisGetReply(ptr noundef %18, ptr noundef %reply)
  %cmp15 = icmp ne i32 %call14, 0
  br i1 %cmp15, label %if.then, label %if.else

if.then:                                          ; preds = %for.body13
  %19 = load ptr, ptr @stderr, align 8
  %20 = load ptr, ptr %keys.addr, align 8
  %element17 = getelementptr inbounds %struct.redisReply, ptr %20, i32 0, i32 7
  %21 = load ptr, ptr %element17, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom18 = zext i32 %22 to i64
  %arrayidx19 = getelementptr inbounds ptr, ptr %21, i64 %idxprom18
  %23 = load ptr, ptr %arrayidx19, align 8
  %str20 = getelementptr inbounds %struct.redisReply, ptr %23, i32 0, i32 4
  %24 = load ptr, ptr %str20, align 8
  %25 = load ptr, ptr @context, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %25, i32 0, i32 1
  %26 = load i32, ptr %err, align 8
  %27 = load ptr, ptr @context, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %27, i32 0, i32 2
  %arraydecay21 = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call22 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %19, ptr noundef @.str.674, ptr noundef %24, i32 noundef %26, ptr noundef %arraydecay21)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else:                                          ; preds = %for.body13
  %28 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %28, i32 0, i32 0
  %29 = load i32, ptr %type, align 8
  %cmp23 = icmp ne i32 %29, 5
  br i1 %cmp23, label %if.then25, label %if.end39

if.then25:                                        ; preds = %if.else
  %30 = load ptr, ptr %reply, align 8
  %type26 = getelementptr inbounds %struct.redisReply, ptr %30, i32 0, i32 0
  %31 = load i32, ptr %type26, align 8
  %cmp27 = icmp eq i32 %31, 6
  br i1 %cmp27, label %if.then29, label %if.else32

if.then29:                                        ; preds = %if.then25
  %32 = load ptr, ptr @stderr, align 8
  %33 = load ptr, ptr %reply, align 8
  %str30 = getelementptr inbounds %struct.redisReply, ptr %33, i32 0, i32 4
  %34 = load ptr, ptr %str30, align 8
  %call31 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %32, ptr noundef @.str.675, ptr noundef %34)
  br label %if.end

if.else32:                                        ; preds = %if.then25
  %35 = load ptr, ptr @stderr, align 8
  %36 = load ptr, ptr %reply, align 8
  %type33 = getelementptr inbounds %struct.redisReply, ptr %36, i32 0, i32 0
  %37 = load i32, ptr %type33, align 8
  %38 = load ptr, ptr %keys.addr, align 8
  %element34 = getelementptr inbounds %struct.redisReply, ptr %38, i32 0, i32 7
  %39 = load ptr, ptr %element34, align 8
  %40 = load i32, ptr %i, align 4
  %idxprom35 = zext i32 %40 to i64
  %arrayidx36 = getelementptr inbounds ptr, ptr %39, i64 %idxprom35
  %41 = load ptr, ptr %arrayidx36, align 8
  %str37 = getelementptr inbounds %struct.redisReply, ptr %41, i32 0, i32 4
  %42 = load ptr, ptr %str37, align 8
  %call38 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %35, ptr noundef @.str.676, i32 noundef %37, ptr noundef %42)
  br label %if.end

if.end:                                           ; preds = %if.else32, %if.then29
  call void @exit(i32 noundef 1) #17
  unreachable

if.end39:                                         ; preds = %if.else
  br label %if.end40

if.end40:                                         ; preds = %if.end39
  %43 = load ptr, ptr %reply, align 8
  %str41 = getelementptr inbounds %struct.redisReply, ptr %43, i32 0, i32 4
  %44 = load ptr, ptr %str41, align 8
  %call42 = call ptr @hi_sdsnew(ptr noundef %44)
  store ptr %call42, ptr %typereply, align 8
  %45 = load ptr, ptr %types_dict.addr, align 8
  %46 = load ptr, ptr %typereply, align 8
  %call43 = call ptr @dictFind(ptr noundef %45, ptr noundef %46)
  store ptr %call43, ptr %de, align 8
  %47 = load ptr, ptr %typereply, align 8
  call void @hi_sdsfree(ptr noundef %47)
  store ptr null, ptr %type44, align 8
  %48 = load ptr, ptr %de, align 8
  %tobool = icmp ne ptr %48, null
  br i1 %tobool, label %if.then45, label %if.else47

if.then45:                                        ; preds = %if.end40
  %49 = load ptr, ptr %de, align 8
  %call46 = call ptr @dictGetVal(ptr noundef %49)
  store ptr %call46, ptr %type44, align 8
  br label %if.end55

if.else47:                                        ; preds = %if.end40
  %50 = load ptr, ptr %reply, align 8
  %str48 = getelementptr inbounds %struct.redisReply, ptr %50, i32 0, i32 4
  %51 = load ptr, ptr %str48, align 8
  %call49 = call i32 @strcmp(ptr noundef %51, ptr noundef @.str.677) #12
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then51, label %if.end54

if.then51:                                        ; preds = %if.else47
  %52 = load ptr, ptr %types_dict.addr, align 8
  %53 = load ptr, ptr %reply, align 8
  %str52 = getelementptr inbounds %struct.redisReply, ptr %53, i32 0, i32 4
  %54 = load ptr, ptr %str52, align 8
  %call53 = call ptr @typeinfo_add(ptr noundef %52, ptr noundef %54, ptr noundef @type_other)
  store ptr %call53, ptr %type44, align 8
  br label %if.end54

if.end54:                                         ; preds = %if.then51, %if.else47
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.then45
  %55 = load ptr, ptr %type44, align 8
  %56 = load ptr, ptr %types.addr, align 8
  %57 = load i32, ptr %i, align 4
  %idxprom56 = zext i32 %57 to i64
  %arrayidx57 = getelementptr inbounds ptr, ptr %56, i64 %idxprom56
  store ptr %55, ptr %arrayidx57, align 8
  %58 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %58)
  br label %for.inc58

for.inc58:                                        ; preds = %if.end55
  %59 = load i32, ptr %i, align 4
  %inc59 = add i32 %59, 1
  store i32 %inc59, ptr %i, align 4
  br label %for.cond8, !llvm.loop !241

for.end60:                                        ; preds = %for.cond8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @getKeySizes(ptr noundef %keys, ptr noundef %types, ptr noundef %sizes, i32 noundef %memkeys, i32 noundef %memkeys_samples) #0 {
entry:
  %keys.addr = alloca ptr, align 8
  %types.addr = alloca ptr, align 8
  %sizes.addr = alloca ptr, align 8
  %memkeys.addr = alloca i32, align 4
  %memkeys_samples.addr = alloca i32, align 4
  %reply = alloca ptr, align 8
  %i = alloca i32, align 4
  %argv = alloca [2 x ptr], align 16
  %lens = alloca [2 x i64], align 16
  %argv26 = alloca [3 x ptr], align 16
  %lens34 = alloca [3 x i64], align 16
  %samplesstr = alloca ptr, align 8
  %argv48 = alloca [5 x ptr], align 16
  %lens58 = alloca [5 x i64], align 16
  store ptr %keys, ptr %keys.addr, align 8
  store ptr %types, ptr %types.addr, align 8
  store ptr %sizes, ptr %sizes.addr, align 8
  store i32 %memkeys, ptr %memkeys.addr, align 4
  store i32 %memkeys_samples, ptr %memkeys_samples.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %conv = zext i32 %0 to i64
  %1 = load ptr, ptr %keys.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %1, i32 0, i32 6
  %2 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %conv, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %types.addr, align 8
  %4 = load i32, ptr %i, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %arrayidx, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %for.body
  %6 = load ptr, ptr %types.addr, align 8
  %7 = load i32, ptr %i, align 4
  %idxprom2 = zext i32 %7 to i64
  %arrayidx3 = getelementptr inbounds ptr, ptr %6, i64 %idxprom2
  %8 = load ptr, ptr %arrayidx3, align 8
  %sizecmd = getelementptr inbounds %struct.typeinfo, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %sizecmd, align 8
  %tobool4 = icmp ne ptr %9, null
  br i1 %tobool4, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.lhs.false
  %10 = load i32, ptr %memkeys.addr, align 4
  %tobool5 = icmp ne i32 %10, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %for.body
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %11 = load i32, ptr %memkeys.addr, align 4
  %tobool6 = icmp ne i32 %11, 0
  br i1 %tobool6, label %if.else, label %if.then7

if.then7:                                         ; preds = %if.end
  %arrayinit.begin = getelementptr inbounds [2 x ptr], ptr %argv, i64 0, i64 0
  %12 = load ptr, ptr %types.addr, align 8
  %13 = load i32, ptr %i, align 4
  %idxprom8 = zext i32 %13 to i64
  %arrayidx9 = getelementptr inbounds ptr, ptr %12, i64 %idxprom8
  %14 = load ptr, ptr %arrayidx9, align 8
  %sizecmd10 = getelementptr inbounds %struct.typeinfo, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %sizecmd10, align 8
  store ptr %15, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %16 = load ptr, ptr %keys.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 7
  %17 = load ptr, ptr %element, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom11 = zext i32 %18 to i64
  %arrayidx12 = getelementptr inbounds ptr, ptr %17, i64 %idxprom11
  %19 = load ptr, ptr %arrayidx12, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 4
  %20 = load ptr, ptr %str, align 8
  store ptr %20, ptr %arrayinit.element, align 8
  %arrayinit.begin13 = getelementptr inbounds [2 x i64], ptr %lens, i64 0, i64 0
  %21 = load ptr, ptr %types.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom14 = zext i32 %22 to i64
  %arrayidx15 = getelementptr inbounds ptr, ptr %21, i64 %idxprom14
  %23 = load ptr, ptr %arrayidx15, align 8
  %sizecmd16 = getelementptr inbounds %struct.typeinfo, ptr %23, i32 0, i32 1
  %24 = load ptr, ptr %sizecmd16, align 8
  %call = call i64 @strlen(ptr noundef %24) #12
  store i64 %call, ptr %arrayinit.begin13, align 8
  %arrayinit.element17 = getelementptr inbounds i64, ptr %arrayinit.begin13, i64 1
  %25 = load ptr, ptr %keys.addr, align 8
  %element18 = getelementptr inbounds %struct.redisReply, ptr %25, i32 0, i32 7
  %26 = load ptr, ptr %element18, align 8
  %27 = load i32, ptr %i, align 4
  %idxprom19 = zext i32 %27 to i64
  %arrayidx20 = getelementptr inbounds ptr, ptr %26, i64 %idxprom19
  %28 = load ptr, ptr %arrayidx20, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %28, i32 0, i32 3
  %29 = load i64, ptr %len, align 8
  store i64 %29, ptr %arrayinit.element17, align 8
  %30 = load ptr, ptr @context, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %argv, i64 0, i64 0
  %arraydecay21 = getelementptr inbounds [2 x i64], ptr %lens, i64 0, i64 0
  %call22 = call i32 @redisAppendCommandArgv(ptr noundef %30, i32 noundef 2, ptr noundef %arraydecay, ptr noundef %arraydecay21)
  br label %if.end73

if.else:                                          ; preds = %if.end
  %31 = load i32, ptr %memkeys_samples.addr, align 4
  %cmp23 = icmp eq i32 %31, 0
  br i1 %cmp23, label %if.then25, label %if.else45

if.then25:                                        ; preds = %if.else
  %arrayinit.begin27 = getelementptr inbounds [3 x ptr], ptr %argv26, i64 0, i64 0
  store ptr @.str.678, ptr %arrayinit.begin27, align 8
  %arrayinit.element28 = getelementptr inbounds ptr, ptr %arrayinit.begin27, i64 1
  store ptr @.str.679, ptr %arrayinit.element28, align 8
  %arrayinit.element29 = getelementptr inbounds ptr, ptr %arrayinit.element28, i64 1
  %32 = load ptr, ptr %keys.addr, align 8
  %element30 = getelementptr inbounds %struct.redisReply, ptr %32, i32 0, i32 7
  %33 = load ptr, ptr %element30, align 8
  %34 = load i32, ptr %i, align 4
  %idxprom31 = zext i32 %34 to i64
  %arrayidx32 = getelementptr inbounds ptr, ptr %33, i64 %idxprom31
  %35 = load ptr, ptr %arrayidx32, align 8
  %str33 = getelementptr inbounds %struct.redisReply, ptr %35, i32 0, i32 4
  %36 = load ptr, ptr %str33, align 8
  store ptr %36, ptr %arrayinit.element29, align 8
  %arrayinit.begin35 = getelementptr inbounds [3 x i64], ptr %lens34, i64 0, i64 0
  store i64 6, ptr %arrayinit.begin35, align 8
  %arrayinit.element36 = getelementptr inbounds i64, ptr %arrayinit.begin35, i64 1
  store i64 5, ptr %arrayinit.element36, align 8
  %arrayinit.element37 = getelementptr inbounds i64, ptr %arrayinit.element36, i64 1
  %37 = load ptr, ptr %keys.addr, align 8
  %element38 = getelementptr inbounds %struct.redisReply, ptr %37, i32 0, i32 7
  %38 = load ptr, ptr %element38, align 8
  %39 = load i32, ptr %i, align 4
  %idxprom39 = zext i32 %39 to i64
  %arrayidx40 = getelementptr inbounds ptr, ptr %38, i64 %idxprom39
  %40 = load ptr, ptr %arrayidx40, align 8
  %len41 = getelementptr inbounds %struct.redisReply, ptr %40, i32 0, i32 3
  %41 = load i64, ptr %len41, align 8
  store i64 %41, ptr %arrayinit.element37, align 8
  %42 = load ptr, ptr @context, align 8
  %arraydecay42 = getelementptr inbounds [3 x ptr], ptr %argv26, i64 0, i64 0
  %arraydecay43 = getelementptr inbounds [3 x i64], ptr %lens34, i64 0, i64 0
  %call44 = call i32 @redisAppendCommandArgv(ptr noundef %42, i32 noundef 3, ptr noundef %arraydecay42, ptr noundef %arraydecay43)
  br label %if.end72

if.else45:                                        ; preds = %if.else
  %43 = load i32, ptr %memkeys_samples.addr, align 4
  %conv46 = zext i32 %43 to i64
  %call47 = call ptr @hi_sdsfromlonglong(i64 noundef %conv46)
  store ptr %call47, ptr %samplesstr, align 8
  %arrayinit.begin49 = getelementptr inbounds [5 x ptr], ptr %argv48, i64 0, i64 0
  store ptr @.str.678, ptr %arrayinit.begin49, align 8
  %arrayinit.element50 = getelementptr inbounds ptr, ptr %arrayinit.begin49, i64 1
  store ptr @.str.679, ptr %arrayinit.element50, align 8
  %arrayinit.element51 = getelementptr inbounds ptr, ptr %arrayinit.element50, i64 1
  %44 = load ptr, ptr %keys.addr, align 8
  %element52 = getelementptr inbounds %struct.redisReply, ptr %44, i32 0, i32 7
  %45 = load ptr, ptr %element52, align 8
  %46 = load i32, ptr %i, align 4
  %idxprom53 = zext i32 %46 to i64
  %arrayidx54 = getelementptr inbounds ptr, ptr %45, i64 %idxprom53
  %47 = load ptr, ptr %arrayidx54, align 8
  %str55 = getelementptr inbounds %struct.redisReply, ptr %47, i32 0, i32 4
  %48 = load ptr, ptr %str55, align 8
  store ptr %48, ptr %arrayinit.element51, align 8
  %arrayinit.element56 = getelementptr inbounds ptr, ptr %arrayinit.element51, i64 1
  store ptr @.str.680, ptr %arrayinit.element56, align 8
  %arrayinit.element57 = getelementptr inbounds ptr, ptr %arrayinit.element56, i64 1
  %49 = load ptr, ptr %samplesstr, align 8
  store ptr %49, ptr %arrayinit.element57, align 8
  %arrayinit.begin59 = getelementptr inbounds [5 x i64], ptr %lens58, i64 0, i64 0
  store i64 6, ptr %arrayinit.begin59, align 8
  %arrayinit.element60 = getelementptr inbounds i64, ptr %arrayinit.begin59, i64 1
  store i64 5, ptr %arrayinit.element60, align 8
  %arrayinit.element61 = getelementptr inbounds i64, ptr %arrayinit.element60, i64 1
  %50 = load ptr, ptr %keys.addr, align 8
  %element62 = getelementptr inbounds %struct.redisReply, ptr %50, i32 0, i32 7
  %51 = load ptr, ptr %element62, align 8
  %52 = load i32, ptr %i, align 4
  %idxprom63 = zext i32 %52 to i64
  %arrayidx64 = getelementptr inbounds ptr, ptr %51, i64 %idxprom63
  %53 = load ptr, ptr %arrayidx64, align 8
  %len65 = getelementptr inbounds %struct.redisReply, ptr %53, i32 0, i32 3
  %54 = load i64, ptr %len65, align 8
  store i64 %54, ptr %arrayinit.element61, align 8
  %arrayinit.element66 = getelementptr inbounds i64, ptr %arrayinit.element61, i64 1
  store i64 7, ptr %arrayinit.element66, align 8
  %arrayinit.element67 = getelementptr inbounds i64, ptr %arrayinit.element66, i64 1
  %55 = load ptr, ptr %samplesstr, align 8
  %call68 = call i64 @hi_sdslen(ptr noundef %55)
  store i64 %call68, ptr %arrayinit.element67, align 8
  %56 = load ptr, ptr @context, align 8
  %arraydecay69 = getelementptr inbounds [5 x ptr], ptr %argv48, i64 0, i64 0
  %arraydecay70 = getelementptr inbounds [5 x i64], ptr %lens58, i64 0, i64 0
  %call71 = call i32 @redisAppendCommandArgv(ptr noundef %56, i32 noundef 5, ptr noundef %arraydecay69, ptr noundef %arraydecay70)
  %57 = load ptr, ptr %samplesstr, align 8
  call void @hi_sdsfree(ptr noundef %57)
  br label %if.end72

if.end72:                                         ; preds = %if.else45, %if.then25
  br label %if.end73

if.end73:                                         ; preds = %if.end72, %if.then7
  br label %for.inc

for.inc:                                          ; preds = %if.end73, %if.then
  %58 = load i32, ptr %i, align 4
  %inc = add i32 %58, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !242

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %i, align 4
  br label %for.cond74

for.cond74:                                       ; preds = %for.inc124, %for.end
  %59 = load i32, ptr %i, align 4
  %conv75 = zext i32 %59 to i64
  %60 = load ptr, ptr %keys.addr, align 8
  %elements76 = getelementptr inbounds %struct.redisReply, ptr %60, i32 0, i32 6
  %61 = load i64, ptr %elements76, align 8
  %cmp77 = icmp ult i64 %conv75, %61
  br i1 %cmp77, label %for.body79, label %for.end126

for.body79:                                       ; preds = %for.cond74
  %62 = load ptr, ptr %types.addr, align 8
  %63 = load i32, ptr %i, align 4
  %idxprom80 = zext i32 %63 to i64
  %arrayidx81 = getelementptr inbounds ptr, ptr %62, i64 %idxprom80
  %64 = load ptr, ptr %arrayidx81, align 8
  %tobool82 = icmp ne ptr %64, null
  br i1 %tobool82, label %lor.lhs.false83, label %if.then90

lor.lhs.false83:                                  ; preds = %for.body79
  %65 = load ptr, ptr %types.addr, align 8
  %66 = load i32, ptr %i, align 4
  %idxprom84 = zext i32 %66 to i64
  %arrayidx85 = getelementptr inbounds ptr, ptr %65, i64 %idxprom84
  %67 = load ptr, ptr %arrayidx85, align 8
  %sizecmd86 = getelementptr inbounds %struct.typeinfo, ptr %67, i32 0, i32 1
  %68 = load ptr, ptr %sizecmd86, align 8
  %tobool87 = icmp ne ptr %68, null
  br i1 %tobool87, label %if.end93, label %land.lhs.true88

land.lhs.true88:                                  ; preds = %lor.lhs.false83
  %69 = load i32, ptr %memkeys.addr, align 4
  %tobool89 = icmp ne i32 %69, 0
  br i1 %tobool89, label %if.end93, label %if.then90

if.then90:                                        ; preds = %land.lhs.true88, %for.body79
  %70 = load ptr, ptr %sizes.addr, align 8
  %71 = load i32, ptr %i, align 4
  %idxprom91 = zext i32 %71 to i64
  %arrayidx92 = getelementptr inbounds i64, ptr %70, i64 %idxprom91
  store i64 0, ptr %arrayidx92, align 8
  br label %for.inc124

if.end93:                                         ; preds = %land.lhs.true88, %lor.lhs.false83
  %72 = load ptr, ptr @context, align 8
  %call94 = call i32 @redisGetReply(ptr noundef %72, ptr noundef %reply)
  %cmp95 = icmp ne i32 %call94, 0
  br i1 %cmp95, label %if.then97, label %if.else104

if.then97:                                        ; preds = %if.end93
  %73 = load ptr, ptr @stderr, align 8
  %74 = load ptr, ptr %keys.addr, align 8
  %element98 = getelementptr inbounds %struct.redisReply, ptr %74, i32 0, i32 7
  %75 = load ptr, ptr %element98, align 8
  %76 = load i32, ptr %i, align 4
  %idxprom99 = zext i32 %76 to i64
  %arrayidx100 = getelementptr inbounds ptr, ptr %75, i64 %idxprom99
  %77 = load ptr, ptr %arrayidx100, align 8
  %str101 = getelementptr inbounds %struct.redisReply, ptr %77, i32 0, i32 4
  %78 = load ptr, ptr %str101, align 8
  %79 = load ptr, ptr @context, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %79, i32 0, i32 1
  %80 = load i32, ptr %err, align 8
  %81 = load ptr, ptr @context, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %81, i32 0, i32 2
  %arraydecay102 = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call103 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %73, ptr noundef @.str.681, ptr noundef %78, i32 noundef %80, ptr noundef %arraydecay102)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else104:                                       ; preds = %if.end93
  %82 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %82, i32 0, i32 0
  %83 = load i32, ptr %type, align 8
  %cmp105 = icmp ne i32 %83, 3
  br i1 %cmp105, label %if.then107, label %if.else119

if.then107:                                       ; preds = %if.else104
  %84 = load ptr, ptr @stderr, align 8
  %85 = load i32, ptr %memkeys.addr, align 4
  %tobool108 = icmp ne i32 %85, 0
  br i1 %tobool108, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then107
  %86 = load ptr, ptr %types.addr, align 8
  %87 = load i32, ptr %i, align 4
  %idxprom109 = zext i32 %87 to i64
  %arrayidx110 = getelementptr inbounds ptr, ptr %86, i64 %idxprom109
  %88 = load ptr, ptr %arrayidx110, align 8
  %sizecmd111 = getelementptr inbounds %struct.typeinfo, ptr %88, i32 0, i32 1
  %89 = load ptr, ptr %sizecmd111, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then107
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %89, %cond.true ], [ @.str.683, %cond.false ]
  %90 = load ptr, ptr %keys.addr, align 8
  %element112 = getelementptr inbounds %struct.redisReply, ptr %90, i32 0, i32 7
  %91 = load ptr, ptr %element112, align 8
  %92 = load i32, ptr %i, align 4
  %idxprom113 = zext i32 %92 to i64
  %arrayidx114 = getelementptr inbounds ptr, ptr %91, i64 %idxprom113
  %93 = load ptr, ptr %arrayidx114, align 8
  %str115 = getelementptr inbounds %struct.redisReply, ptr %93, i32 0, i32 4
  %94 = load ptr, ptr %str115, align 8
  %call116 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %84, ptr noundef @.str.682, ptr noundef %cond, ptr noundef %94)
  %95 = load ptr, ptr %sizes.addr, align 8
  %96 = load i32, ptr %i, align 4
  %idxprom117 = zext i32 %96 to i64
  %arrayidx118 = getelementptr inbounds i64, ptr %95, i64 %idxprom117
  store i64 0, ptr %arrayidx118, align 8
  br label %if.end122

if.else119:                                       ; preds = %if.else104
  %97 = load ptr, ptr %reply, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %97, i32 0, i32 1
  %98 = load i64, ptr %integer, align 8
  %99 = load ptr, ptr %sizes.addr, align 8
  %100 = load i32, ptr %i, align 4
  %idxprom120 = zext i32 %100 to i64
  %arrayidx121 = getelementptr inbounds i64, ptr %99, i64 %idxprom120
  store i64 %98, ptr %arrayidx121, align 8
  br label %if.end122

if.end122:                                        ; preds = %if.else119, %cond.end
  br label %if.end123

if.end123:                                        ; preds = %if.end122
  %101 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %101)
  br label %for.inc124

for.inc124:                                       ; preds = %if.end123, %if.then90
  %102 = load i32, ptr %i, align 4
  %inc125 = add i32 %102, 1
  store i32 %inc125, ptr %i, align 4
  br label %for.cond74, !llvm.loop !243

for.end126:                                       ; preds = %for.cond74
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @getKeyFreqs(ptr noundef %keys, ptr noundef %freqs) #0 {
entry:
  %keys.addr = alloca ptr, align 8
  %freqs.addr = alloca ptr, align 8
  %reply = alloca ptr, align 8
  %i = alloca i32, align 4
  %argv = alloca [3 x ptr], align 16
  %lens = alloca [3 x i64], align 16
  %keyname = alloca ptr, align 8
  %keyname41 = alloca ptr, align 8
  store ptr %keys, ptr %keys.addr, align 8
  store ptr %freqs, ptr %freqs.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %conv = zext i32 %0 to i64
  %1 = load ptr, ptr %keys.addr, align 8
  %elements = getelementptr inbounds %struct.redisReply, ptr %1, i32 0, i32 6
  %2 = load i64, ptr %elements, align 8
  %cmp = icmp ult i64 %conv, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayinit.begin = getelementptr inbounds [3 x ptr], ptr %argv, i64 0, i64 0
  store ptr @.str.687, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  store ptr @.str.688, ptr %arrayinit.element, align 8
  %arrayinit.element2 = getelementptr inbounds ptr, ptr %arrayinit.element, i64 1
  %3 = load ptr, ptr %keys.addr, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 7
  %4 = load ptr, ptr %element, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %str, align 8
  store ptr %7, ptr %arrayinit.element2, align 8
  %arrayinit.begin3 = getelementptr inbounds [3 x i64], ptr %lens, i64 0, i64 0
  store i64 6, ptr %arrayinit.begin3, align 8
  %arrayinit.element4 = getelementptr inbounds i64, ptr %arrayinit.begin3, i64 1
  store i64 4, ptr %arrayinit.element4, align 8
  %arrayinit.element5 = getelementptr inbounds i64, ptr %arrayinit.element4, i64 1
  %8 = load ptr, ptr %keys.addr, align 8
  %element6 = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 7
  %9 = load ptr, ptr %element6, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom7 = zext i32 %10 to i64
  %arrayidx8 = getelementptr inbounds ptr, ptr %9, i64 %idxprom7
  %11 = load ptr, ptr %arrayidx8, align 8
  %len = getelementptr inbounds %struct.redisReply, ptr %11, i32 0, i32 3
  %12 = load i64, ptr %len, align 8
  store i64 %12, ptr %arrayinit.element5, align 8
  %13 = load ptr, ptr @context, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argv, i64 0, i64 0
  %arraydecay9 = getelementptr inbounds [3 x i64], ptr %lens, i64 0, i64 0
  %call = call i32 @redisAppendCommandArgv(ptr noundef %13, i32 noundef 3, ptr noundef %arraydecay, ptr noundef %arraydecay9)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, ptr %i, align 4
  %inc = add i32 %14, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !244

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %i, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc60, %for.end
  %15 = load i32, ptr %i, align 4
  %conv11 = zext i32 %15 to i64
  %16 = load ptr, ptr %keys.addr, align 8
  %elements12 = getelementptr inbounds %struct.redisReply, ptr %16, i32 0, i32 6
  %17 = load i64, ptr %elements12, align 8
  %cmp13 = icmp ult i64 %conv11, %17
  br i1 %cmp13, label %for.body15, label %for.end62

for.body15:                                       ; preds = %for.cond10
  %18 = load ptr, ptr @context, align 8
  %call16 = call i32 @redisGetReply(ptr noundef %18, ptr noundef %reply)
  %cmp17 = icmp ne i32 %call16, 0
  br i1 %cmp17, label %if.then, label %if.else

if.then:                                          ; preds = %for.body15
  %call19 = call ptr @hi_sdsempty()
  %19 = load ptr, ptr %keys.addr, align 8
  %element20 = getelementptr inbounds %struct.redisReply, ptr %19, i32 0, i32 7
  %20 = load ptr, ptr %element20, align 8
  %21 = load i32, ptr %i, align 4
  %idxprom21 = zext i32 %21 to i64
  %arrayidx22 = getelementptr inbounds ptr, ptr %20, i64 %idxprom21
  %22 = load ptr, ptr %arrayidx22, align 8
  %str23 = getelementptr inbounds %struct.redisReply, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %str23, align 8
  %24 = load ptr, ptr %keys.addr, align 8
  %element24 = getelementptr inbounds %struct.redisReply, ptr %24, i32 0, i32 7
  %25 = load ptr, ptr %element24, align 8
  %26 = load i32, ptr %i, align 4
  %idxprom25 = zext i32 %26 to i64
  %arrayidx26 = getelementptr inbounds ptr, ptr %25, i64 %idxprom25
  %27 = load ptr, ptr %arrayidx26, align 8
  %len27 = getelementptr inbounds %struct.redisReply, ptr %27, i32 0, i32 3
  %28 = load i64, ptr %len27, align 8
  %call28 = call ptr @hi_sdscatrepr(ptr noundef %call19, ptr noundef %23, i64 noundef %28)
  store ptr %call28, ptr %keyname, align 8
  %29 = load ptr, ptr @stderr, align 8
  %30 = load ptr, ptr %keyname, align 8
  %31 = load ptr, ptr @context, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %31, i32 0, i32 1
  %32 = load i32, ptr %err, align 8
  %33 = load ptr, ptr @context, align 8
  %errstr = getelementptr inbounds %struct.redisContext, ptr %33, i32 0, i32 2
  %arraydecay29 = getelementptr inbounds [128 x i8], ptr %errstr, i64 0, i64 0
  %call30 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %29, ptr noundef @.str.689, ptr noundef %30, i32 noundef %32, ptr noundef %arraydecay29)
  %34 = load ptr, ptr %keyname, align 8
  call void @hi_sdsfree(ptr noundef %34)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else:                                          ; preds = %for.body15
  %35 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %35, i32 0, i32 0
  %36 = load i32, ptr %type, align 8
  %cmp31 = icmp ne i32 %36, 3
  br i1 %cmp31, label %if.then33, label %if.else55

if.then33:                                        ; preds = %if.else
  %37 = load ptr, ptr %reply, align 8
  %type34 = getelementptr inbounds %struct.redisReply, ptr %37, i32 0, i32 0
  %38 = load i32, ptr %type34, align 8
  %cmp35 = icmp eq i32 %38, 6
  br i1 %cmp35, label %if.then37, label %if.else40

if.then37:                                        ; preds = %if.then33
  %39 = load ptr, ptr @stderr, align 8
  %40 = load ptr, ptr %reply, align 8
  %str38 = getelementptr inbounds %struct.redisReply, ptr %40, i32 0, i32 4
  %41 = load ptr, ptr %str38, align 8
  %call39 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %39, ptr noundef @.str.418, ptr noundef %41)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else40:                                        ; preds = %if.then33
  %call42 = call ptr @hi_sdsempty()
  %42 = load ptr, ptr %keys.addr, align 8
  %element43 = getelementptr inbounds %struct.redisReply, ptr %42, i32 0, i32 7
  %43 = load ptr, ptr %element43, align 8
  %44 = load i32, ptr %i, align 4
  %idxprom44 = zext i32 %44 to i64
  %arrayidx45 = getelementptr inbounds ptr, ptr %43, i64 %idxprom44
  %45 = load ptr, ptr %arrayidx45, align 8
  %str46 = getelementptr inbounds %struct.redisReply, ptr %45, i32 0, i32 4
  %46 = load ptr, ptr %str46, align 8
  %47 = load ptr, ptr %keys.addr, align 8
  %element47 = getelementptr inbounds %struct.redisReply, ptr %47, i32 0, i32 7
  %48 = load ptr, ptr %element47, align 8
  %49 = load i32, ptr %i, align 4
  %idxprom48 = zext i32 %49 to i64
  %arrayidx49 = getelementptr inbounds ptr, ptr %48, i64 %idxprom48
  %50 = load ptr, ptr %arrayidx49, align 8
  %len50 = getelementptr inbounds %struct.redisReply, ptr %50, i32 0, i32 3
  %51 = load i64, ptr %len50, align 8
  %call51 = call ptr @hi_sdscatrepr(ptr noundef %call42, ptr noundef %46, i64 noundef %51)
  store ptr %call51, ptr %keyname41, align 8
  %52 = load ptr, ptr @stderr, align 8
  %53 = load ptr, ptr %keyname41, align 8
  %call52 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %52, ptr noundef @.str.690, ptr noundef %53)
  %54 = load ptr, ptr %keyname41, align 8
  call void @hi_sdsfree(ptr noundef %54)
  %55 = load ptr, ptr %freqs.addr, align 8
  %56 = load i32, ptr %i, align 4
  %idxprom53 = zext i32 %56 to i64
  %arrayidx54 = getelementptr inbounds i64, ptr %55, i64 %idxprom53
  store i64 0, ptr %arrayidx54, align 8
  br label %if.end

if.end:                                           ; preds = %if.else40
  br label %if.end58

if.else55:                                        ; preds = %if.else
  %57 = load ptr, ptr %reply, align 8
  %integer = getelementptr inbounds %struct.redisReply, ptr %57, i32 0, i32 1
  %58 = load i64, ptr %integer, align 8
  %59 = load ptr, ptr %freqs.addr, align 8
  %60 = load i32, ptr %i, align 4
  %idxprom56 = zext i32 %60 to i64
  %arrayidx57 = getelementptr inbounds i64, ptr %59, i64 %idxprom56
  store i64 %58, ptr %arrayidx57, align 8
  br label %if.end58

if.end58:                                         ; preds = %if.else55, %if.end
  br label %if.end59

if.end59:                                         ; preds = %if.end58
  %61 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %61)
  br label %for.inc60

for.inc60:                                        ; preds = %if.end59
  %62 = load i32, ptr %i, align 4
  %inc61 = add i32 %62, 1
  store i32 %inc61, ptr %i, align 4
  br label %for.cond10, !llvm.loop !245

for.end62:                                        ; preds = %for.cond10
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @getDatabases() #0 {
entry:
  %reply = alloca ptr, align 8
  %dbnum = alloca i32, align 4
  %0 = load ptr, ptr @context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %0, ptr noundef @.str.713)
  store ptr %call, ptr %reply, align 8
  %1 = load ptr, ptr %reply, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr @stderr, align 8
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef @.str.76)
  call void @exit(i32 noundef 1) #17
  unreachable

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type, align 8
  %cmp2 = icmp eq i32 %4, 6
  br i1 %cmp2, label %if.then3, label %if.else5

if.then3:                                         ; preds = %if.else
  store i32 16, ptr %dbnum, align 4
  %5 = load ptr, ptr @stderr, align 8
  %6 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %str, align 8
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.714, ptr noundef %7)
  br label %if.end

if.else5:                                         ; preds = %if.else
  %8 = load ptr, ptr %reply, align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %8, i32 0, i32 7
  %9 = load ptr, ptr %element, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %9, i64 1
  %10 = load ptr, ptr %arrayidx, align 8
  %str6 = getelementptr inbounds %struct.redisReply, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %str6, align 8
  %call7 = call i32 @atoi(ptr noundef %11) #12
  store i32 %call7, ptr %dbnum, align 4
  br label %if.end

if.end:                                           ; preds = %if.else5, %if.then3
  br label %if.end8

if.end8:                                          ; preds = %if.end
  %12 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %12)
  %13 = load i32, ptr %dbnum, align 4
  ret i32 %13
}

declare i32 @redisAppendCommand(ptr noundef, ptr noundef, ...) #2

declare void @linenoiseSetMultiLine(i32 noundef) #2

declare void @linenoiseSetCompletionCallback(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @completionCallback(ptr noundef %buf, ptr noundef %lc) #0 {
entry:
  %buf.addr = alloca ptr, align 8
  %lc.addr = alloca ptr, align 8
  %startpos = alloca i64, align 8
  %mask = alloca i32, align 4
  %i = alloca i32, align 4
  %matchlen = alloca i64, align 8
  %tmp = alloca ptr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store ptr %lc, ptr %lc.addr, align 8
  store i64 0, ptr %startpos, align 8
  %0 = load ptr, ptr %buf.addr, align 8
  %call = call i32 @strncasecmp(ptr noundef %0, ptr noundef @.str.736, i64 noundef 5) #12
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 5, ptr %startpos, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %call1 = call ptr @__ctype_b_loc() #16
  %1 = load ptr, ptr %call1, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i64, ptr %startpos, align 8
  %arrayidx = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %idxprom = sext i32 %conv to i64
  %arrayidx2 = getelementptr inbounds i16, ptr %1, i64 %idxprom
  %5 = load i16, ptr %arrayidx2, align 2
  %conv3 = zext i16 %5 to i32
  %and = and i32 %conv3, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load i64, ptr %startpos, align 8
  %inc = add i64 %6, 1
  store i64 %inc, ptr %startpos, align 8
  br label %while.cond, !llvm.loop !246

while.end:                                        ; preds = %while.cond
  store i32 3, ptr %mask, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 1, ptr %mask, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %while.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %7 = load i32, ptr %i, align 4
  %8 = load i32, ptr @helpEntriesLen, align 4
  %cmp4 = icmp slt i32 %7, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr @helpEntries, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom6 = sext i32 %10 to i64
  %arrayidx7 = getelementptr inbounds %struct.helpEntry, ptr %9, i64 %idxprom6
  %type = getelementptr inbounds %struct.helpEntry, ptr %arrayidx7, i32 0, i32 0
  %11 = load i32, ptr %type, align 8
  %12 = load i32, ptr %mask, align 4
  %and8 = and i32 %11, %12
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %for.body
  br label %for.inc

if.end11:                                         ; preds = %for.body
  %13 = load ptr, ptr %buf.addr, align 8
  %14 = load i64, ptr %startpos, align 8
  %add.ptr = getelementptr inbounds i8, ptr %13, i64 %14
  %call12 = call i64 @strlen(ptr noundef %add.ptr) #12
  store i64 %call12, ptr %matchlen, align 8
  %15 = load ptr, ptr %buf.addr, align 8
  %16 = load i64, ptr %startpos, align 8
  %add.ptr13 = getelementptr inbounds i8, ptr %15, i64 %16
  %17 = load ptr, ptr @helpEntries, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom14 = sext i32 %18 to i64
  %arrayidx15 = getelementptr inbounds %struct.helpEntry, ptr %17, i64 %idxprom14
  %full = getelementptr inbounds %struct.helpEntry, ptr %arrayidx15, i32 0, i32 3
  %19 = load ptr, ptr %full, align 8
  %20 = load i64, ptr %matchlen, align 8
  %call16 = call i32 @strncasecmp(ptr noundef %add.ptr13, ptr noundef %19, i64 noundef %20) #12
  %cmp17 = icmp eq i32 %call16, 0
  br i1 %cmp17, label %if.then19, label %if.end25

if.then19:                                        ; preds = %if.end11
  %21 = load ptr, ptr %buf.addr, align 8
  %22 = load i64, ptr %startpos, align 8
  %call20 = call ptr @hi_sdsnewlen(ptr noundef %21, i64 noundef %22)
  store ptr %call20, ptr %tmp, align 8
  %23 = load ptr, ptr %tmp, align 8
  %24 = load ptr, ptr @helpEntries, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom21 = sext i32 %25 to i64
  %arrayidx22 = getelementptr inbounds %struct.helpEntry, ptr %24, i64 %idxprom21
  %full23 = getelementptr inbounds %struct.helpEntry, ptr %arrayidx22, i32 0, i32 3
  %26 = load ptr, ptr %full23, align 8
  %call24 = call ptr @hi_sdscat(ptr noundef %23, ptr noundef %26)
  store ptr %call24, ptr %tmp, align 8
  %27 = load ptr, ptr %lc.addr, align 8
  %28 = load ptr, ptr %tmp, align 8
  call void @linenoiseAddCompletion(ptr noundef %27, ptr noundef %28)
  %29 = load ptr, ptr %tmp, align 8
  call void @hi_sdsfree(ptr noundef %29)
  br label %if.end25

if.end25:                                         ; preds = %if.then19, %if.end11
  br label %for.inc

for.inc:                                          ; preds = %if.end25, %if.then10
  %30 = load i32, ptr %i, align 4
  %inc26 = add nsw i32 %30, 1
  store i32 %inc26, ptr %i, align 4
  br label %for.cond, !llvm.loop !247

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @linenoiseSetHintsCallback(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @hintsCallback(ptr noundef %buf, ptr noundef %color, ptr noundef %bold) #0 {
entry:
  %retval = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %color.addr = alloca ptr, align 8
  %bold.addr = alloca ptr, align 8
  %hint = alloca ptr, align 8
  %len = alloca i32, align 4
  %endspace = alloca i32, align 4
  %newhint = alloca ptr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store ptr %color, ptr %color.addr, align 8
  store ptr %bold, ptr %bold.addr, align 8
  %0 = load i32, ptr @pref, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %buf.addr, align 8
  %call = call ptr @getHintForInput(ptr noundef %1)
  store ptr %call, ptr %hint, align 8
  %2 = load ptr, ptr %hint, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %3 = load ptr, ptr %color.addr, align 8
  store i32 90, ptr %3, align 4
  %4 = load ptr, ptr %bold.addr, align 8
  store i32 0, ptr %4, align 4
  %5 = load ptr, ptr %buf.addr, align 8
  %call3 = call i64 @strlen(ptr noundef %5) #12
  %conv = trunc i64 %call3 to i32
  store i32 %conv, ptr %len, align 4
  %6 = load i32, ptr %len, align 4
  %tobool4 = icmp ne i32 %6, 0
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end2
  %call5 = call ptr @__ctype_b_loc() #16
  %7 = load ptr, ptr %call5, align 8
  %8 = load ptr, ptr %buf.addr, align 8
  %9 = load i32, ptr %len, align 4
  %sub = sub nsw i32 %9, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds i8, ptr %8, i64 %idxprom
  %10 = load i8, ptr %arrayidx, align 1
  %conv6 = sext i8 %10 to i32
  %idxprom7 = sext i32 %conv6 to i64
  %arrayidx8 = getelementptr inbounds i16, ptr %7, i64 %idxprom7
  %11 = load i16, ptr %arrayidx8, align 2
  %conv9 = zext i16 %11 to i32
  %and = and i32 %conv9, 8192
  %tobool10 = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end2
  %12 = phi i1 [ false, %if.end2 ], [ %tobool10, %land.rhs ]
  %land.ext = zext i1 %12 to i32
  store i32 %land.ext, ptr %endspace, align 4
  %13 = load i32, ptr %endspace, align 4
  %tobool11 = icmp ne i32 %13, 0
  br i1 %tobool11, label %if.end15, label %if.then12

if.then12:                                        ; preds = %land.end
  %call13 = call ptr @hi_sdsnewlen(ptr noundef @.str.136, i64 noundef 1)
  store ptr %call13, ptr %newhint, align 8
  %14 = load ptr, ptr %newhint, align 8
  %15 = load ptr, ptr %hint, align 8
  %call14 = call ptr @hi_sdscatsds(ptr noundef %14, ptr noundef %15)
  store ptr %call14, ptr %newhint, align 8
  %16 = load ptr, ptr %hint, align 8
  call void @hi_sdsfree(ptr noundef %16)
  %17 = load ptr, ptr %newhint, align 8
  store ptr %17, ptr %hint, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %land.end
  %18 = load ptr, ptr %hint, align 8
  store ptr %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then1, %if.then
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

declare void @linenoiseSetFreeHintsCallback(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @freeHintsCallback(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  call void @hi_sdsfree(ptr noundef %0)
  ret void
}

declare i32 @linenoiseHistoryLoad(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @cliSplitArgs(ptr noundef %line, ptr noundef %argc) #0 {
entry:
  %retval = alloca ptr, align 8
  %line.addr = alloca ptr, align 8
  %argc.addr = alloca ptr, align 8
  %argv = alloca ptr, align 8
  %len = alloca i32, align 4
  %elen = alloca i32, align 4
  store ptr %line, ptr %line.addr, align 8
  store ptr %argc, ptr %argc.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %line.addr, align 8
  %call = call ptr @strstr(ptr noundef %1, ptr noundef @.str.737) #12
  %2 = load ptr, ptr %line.addr, align 8
  %cmp = icmp eq ptr %call, %2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %line.addr, align 8
  %call1 = call ptr @strstr(ptr noundef %3, ptr noundef @.str.738) #12
  %4 = load ptr, ptr %line.addr, align 8
  %cmp2 = icmp eq ptr %call1, %4
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %call3 = call ptr @hi_sds_malloc(i64 noundef 16)
  store ptr %call3, ptr %argv, align 8
  %5 = load ptr, ptr %argc.addr, align 8
  store i32 2, ptr %5, align 4
  %6 = load ptr, ptr %line.addr, align 8
  %call4 = call i64 @strlen(ptr noundef %6) #12
  %conv = trunc i64 %call4 to i32
  store i32 %conv, ptr %len, align 4
  %7 = load ptr, ptr %line.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %7, i64 1
  %8 = load i8, ptr %arrayidx, align 1
  %conv5 = sext i8 %8 to i32
  %cmp6 = icmp eq i32 %conv5, 32
  %cond = select i1 %cmp6, i32 2, i32 5
  store i32 %cond, ptr %elen, align 4
  %9 = load ptr, ptr %line.addr, align 8
  %10 = load i32, ptr %elen, align 4
  %sub = sub nsw i32 %10, 1
  %conv8 = sext i32 %sub to i64
  %call9 = call ptr @hi_sdsnewlen(ptr noundef %9, i64 noundef %conv8)
  %11 = load ptr, ptr %argv, align 8
  %arrayidx10 = getelementptr inbounds ptr, ptr %11, i64 0
  store ptr %call9, ptr %arrayidx10, align 8
  %12 = load ptr, ptr %line.addr, align 8
  %13 = load i32, ptr %elen, align 4
  %idx.ext = sext i32 %13 to i64
  %add.ptr = getelementptr inbounds i8, ptr %12, i64 %idx.ext
  %14 = load i32, ptr %len, align 4
  %15 = load i32, ptr %elen, align 4
  %sub11 = sub nsw i32 %14, %15
  %conv12 = sext i32 %sub11 to i64
  %call13 = call ptr @hi_sdsnewlen(ptr noundef %add.ptr, i64 noundef %conv12)
  %16 = load ptr, ptr %argv, align 8
  %arrayidx14 = getelementptr inbounds ptr, ptr %16, i64 1
  store ptr %call13, ptr %arrayidx14, align 8
  %17 = load ptr, ptr %argv, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %lor.lhs.false, %entry
  %18 = load ptr, ptr %line.addr, align 8
  %19 = load ptr, ptr %argc.addr, align 8
  %call15 = call ptr @hi_sdssplitargs(ptr noundef %18, ptr noundef %19)
  store ptr %call15, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %20 = load ptr, ptr %retval, align 8
  ret ptr %20
}

declare i32 @linenoiseHistoryAdd(ptr noundef, i32 noundef) #2

declare i32 @linenoiseHistorySave(ptr noundef) #2

declare void @linenoiseFree(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @isSensitiveCommand(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %j59 = alloca i32, align 4
  %moreargs = alloca i32, align 4
  %j92 = alloca i32, align 4
  %moreargs96 = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  %0 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 0
  %1 = load ptr, ptr %arrayidx, align 8
  %call = call i32 @strcasecmp(ptr noundef %1, ptr noundef @.str.739) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i32, ptr %argc.addr, align 4
  %cmp = icmp sgt i32 %2, 1
  br i1 %cmp, label %land.lhs.true, label %if.else16

land.lhs.true:                                    ; preds = %if.else
  %3 = load ptr, ptr %argv.addr, align 8
  %arrayidx1 = getelementptr inbounds ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx1, align 8
  %call2 = call i32 @strcasecmp(ptr noundef %4, ptr noundef @.str.740) #12
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.else16, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %land.lhs.true
  %5 = load ptr, ptr %argv.addr, align 8
  %arrayidx5 = getelementptr inbounds ptr, ptr %5, i64 1
  %6 = load ptr, ptr %arrayidx5, align 8
  %call6 = call i32 @strcasecmp(ptr noundef %6, ptr noundef @.str.741) #12
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %lor.lhs.false, label %if.then15

lor.lhs.false:                                    ; preds = %land.lhs.true4
  %7 = load ptr, ptr %argv.addr, align 8
  %arrayidx8 = getelementptr inbounds ptr, ptr %7, i64 1
  %8 = load ptr, ptr %arrayidx8, align 8
  %call9 = call i32 @strcasecmp(ptr noundef %8, ptr noundef @.str.742) #12
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %lor.lhs.false11, label %if.then15

lor.lhs.false11:                                  ; preds = %lor.lhs.false
  %9 = load ptr, ptr %argv.addr, align 8
  %arrayidx12 = getelementptr inbounds ptr, ptr %9, i64 1
  %10 = load ptr, ptr %arrayidx12, align 8
  %call13 = call i32 @strcasecmp(ptr noundef %10, ptr noundef @.str.743) #12
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.else16, label %if.then15

if.then15:                                        ; preds = %lor.lhs.false11, %lor.lhs.false, %land.lhs.true4
  store i32 1, ptr %retval, align 4
  br label %return

if.else16:                                        ; preds = %lor.lhs.false11, %land.lhs.true, %if.else
  %11 = load i32, ptr %argc.addr, align 4
  %cmp17 = icmp sgt i32 %11, 2
  br i1 %cmp17, label %land.lhs.true18, label %if.else52

land.lhs.true18:                                  ; preds = %if.else16
  %12 = load ptr, ptr %argv.addr, align 8
  %arrayidx19 = getelementptr inbounds ptr, ptr %12, i64 0
  %13 = load ptr, ptr %arrayidx19, align 8
  %call20 = call i32 @strcasecmp(ptr noundef %13, ptr noundef @.str.744) #12
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.else52, label %land.lhs.true22

land.lhs.true22:                                  ; preds = %land.lhs.true18
  %14 = load ptr, ptr %argv.addr, align 8
  %arrayidx23 = getelementptr inbounds ptr, ptr %14, i64 1
  %15 = load ptr, ptr %arrayidx23, align 8
  %call24 = call i32 @strcasecmp(ptr noundef %15, ptr noundef @.str.97) #12
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.else52, label %if.then26

if.then26:                                        ; preds = %land.lhs.true22
  store i32 2, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then26
  %16 = load i32, ptr %j, align 4
  %17 = load i32, ptr %argc.addr, align 4
  %cmp27 = icmp slt i32 %16, %17
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %argv.addr, align 8
  %19 = load i32, ptr %j, align 4
  %idxprom = sext i32 %19 to i64
  %arrayidx28 = getelementptr inbounds ptr, ptr %18, i64 %idxprom
  %20 = load ptr, ptr %arrayidx28, align 8
  %call29 = call i32 @strcasecmp(ptr noundef %20, ptr noundef @.str.745) #12
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %lor.lhs.false31, label %if.then51

lor.lhs.false31:                                  ; preds = %for.body
  %21 = load ptr, ptr %argv.addr, align 8
  %22 = load i32, ptr %j, align 4
  %idxprom32 = sext i32 %22 to i64
  %arrayidx33 = getelementptr inbounds ptr, ptr %21, i64 %idxprom32
  %23 = load ptr, ptr %arrayidx33, align 8
  %call34 = call i32 @strcasecmp(ptr noundef %23, ptr noundef @.str.746) #12
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %lor.lhs.false36, label %if.then51

lor.lhs.false36:                                  ; preds = %lor.lhs.false31
  %24 = load ptr, ptr %argv.addr, align 8
  %25 = load i32, ptr %j, align 4
  %idxprom37 = sext i32 %25 to i64
  %arrayidx38 = getelementptr inbounds ptr, ptr %24, i64 %idxprom37
  %26 = load ptr, ptr %arrayidx38, align 8
  %call39 = call i32 @strcasecmp(ptr noundef %26, ptr noundef @.str.747) #12
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %lor.lhs.false41, label %if.then51

lor.lhs.false41:                                  ; preds = %lor.lhs.false36
  %27 = load ptr, ptr %argv.addr, align 8
  %28 = load i32, ptr %j, align 4
  %idxprom42 = sext i32 %28 to i64
  %arrayidx43 = getelementptr inbounds ptr, ptr %27, i64 %idxprom42
  %29 = load ptr, ptr %arrayidx43, align 8
  %call44 = call i32 @strcasecmp(ptr noundef %29, ptr noundef @.str.748) #12
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %lor.lhs.false46, label %if.then51

lor.lhs.false46:                                  ; preds = %lor.lhs.false41
  %30 = load ptr, ptr %argv.addr, align 8
  %31 = load i32, ptr %j, align 4
  %idxprom47 = sext i32 %31 to i64
  %arrayidx48 = getelementptr inbounds ptr, ptr %30, i64 %idxprom47
  %32 = load ptr, ptr %arrayidx48, align 8
  %call49 = call i32 @strcasecmp(ptr noundef %32, ptr noundef @.str.749) #12
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.end, label %if.then51

if.then51:                                        ; preds = %lor.lhs.false46, %lor.lhs.false41, %lor.lhs.false36, %lor.lhs.false31, %for.body
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false46
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %33 = load i32, ptr %j, align 4
  %add = add nsw i32 %33, 2
  store i32 %add, ptr %j, align 4
  br label %for.cond, !llvm.loop !248

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

if.else52:                                        ; preds = %land.lhs.true22, %land.lhs.true18, %if.else16
  %34 = load i32, ptr %argc.addr, align 4
  %cmp53 = icmp sgt i32 %34, 4
  br i1 %cmp53, label %land.lhs.true54, label %if.else85

land.lhs.true54:                                  ; preds = %if.else52
  %35 = load ptr, ptr %argv.addr, align 8
  %arrayidx55 = getelementptr inbounds ptr, ptr %35, i64 0
  %36 = load ptr, ptr %arrayidx55, align 8
  %call56 = call i32 @strcasecmp(ptr noundef %36, ptr noundef @.str.750) #12
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %if.else85, label %if.then58

if.then58:                                        ; preds = %land.lhs.true54
  store i32 2, ptr %j59, align 4
  br label %for.cond60

for.cond60:                                       ; preds = %for.inc82, %if.then58
  %37 = load i32, ptr %j59, align 4
  %38 = load i32, ptr %argc.addr, align 4
  %cmp61 = icmp slt i32 %37, %38
  br i1 %cmp61, label %for.body62, label %for.end84

for.body62:                                       ; preds = %for.cond60
  %39 = load i32, ptr %argc.addr, align 4
  %sub = sub nsw i32 %39, 1
  %40 = load i32, ptr %j59, align 4
  %sub63 = sub nsw i32 %sub, %40
  store i32 %sub63, ptr %moreargs, align 4
  %41 = load ptr, ptr %argv.addr, align 8
  %42 = load i32, ptr %j59, align 4
  %idxprom64 = sext i32 %42 to i64
  %arrayidx65 = getelementptr inbounds ptr, ptr %41, i64 %idxprom64
  %43 = load ptr, ptr %arrayidx65, align 8
  %call66 = call i32 @strcasecmp(ptr noundef %43, ptr noundef @.str.308) #12
  %tobool67 = icmp ne i32 %call66, 0
  br i1 %tobool67, label %if.else71, label %land.lhs.true68

land.lhs.true68:                                  ; preds = %for.body62
  %44 = load i32, ptr %moreargs, align 4
  %cmp69 = icmp sge i32 %44, 2
  br i1 %cmp69, label %if.then70, label %if.else71

if.then70:                                        ; preds = %land.lhs.true68
  store i32 1, ptr %retval, align 4
  br label %return

if.else71:                                        ; preds = %land.lhs.true68, %for.body62
  %45 = load ptr, ptr %argv.addr, align 8
  %46 = load i32, ptr %j59, align 4
  %idxprom72 = sext i32 %46 to i64
  %arrayidx73 = getelementptr inbounds ptr, ptr %45, i64 %idxprom72
  %47 = load ptr, ptr %arrayidx73, align 8
  %call74 = call i32 @strcasecmp(ptr noundef %47, ptr noundef @.str.751) #12
  %tobool75 = icmp ne i32 %call74, 0
  br i1 %tobool75, label %if.else79, label %land.lhs.true76

land.lhs.true76:                                  ; preds = %if.else71
  %48 = load i32, ptr %moreargs, align 4
  %tobool77 = icmp ne i32 %48, 0
  br i1 %tobool77, label %if.then78, label %if.else79

if.then78:                                        ; preds = %land.lhs.true76
  %49 = load i32, ptr %j59, align 4
  %inc = add nsw i32 %49, 1
  store i32 %inc, ptr %j59, align 4
  br label %if.end80

if.else79:                                        ; preds = %land.lhs.true76, %if.else71
  store i32 0, ptr %retval, align 4
  br label %return

if.end80:                                         ; preds = %if.then78
  br label %if.end81

if.end81:                                         ; preds = %if.end80
  br label %for.inc82

for.inc82:                                        ; preds = %if.end81
  %50 = load i32, ptr %j59, align 4
  %inc83 = add nsw i32 %50, 1
  store i32 %inc83, ptr %j59, align 4
  br label %for.cond60, !llvm.loop !249

for.end84:                                        ; preds = %for.cond60
  br label %if.end167

if.else85:                                        ; preds = %land.lhs.true54, %if.else52
  %51 = load i32, ptr %argc.addr, align 4
  %cmp86 = icmp sgt i32 %51, 7
  br i1 %cmp86, label %land.lhs.true87, label %if.else128

land.lhs.true87:                                  ; preds = %if.else85
  %52 = load ptr, ptr %argv.addr, align 8
  %arrayidx88 = getelementptr inbounds ptr, ptr %52, i64 0
  %53 = load ptr, ptr %arrayidx88, align 8
  %call89 = call i32 @strcasecmp(ptr noundef %53, ptr noundef @.str.752) #12
  %tobool90 = icmp ne i32 %call89, 0
  br i1 %tobool90, label %if.else128, label %if.then91

if.then91:                                        ; preds = %land.lhs.true87
  store i32 6, ptr %j92, align 4
  br label %for.cond93

for.cond93:                                       ; preds = %for.inc125, %if.then91
  %54 = load i32, ptr %j92, align 4
  %55 = load i32, ptr %argc.addr, align 4
  %cmp94 = icmp slt i32 %54, %55
  br i1 %cmp94, label %for.body95, label %for.end127

for.body95:                                       ; preds = %for.cond93
  %56 = load i32, ptr %argc.addr, align 4
  %sub97 = sub nsw i32 %56, 1
  %57 = load i32, ptr %j92, align 4
  %sub98 = sub nsw i32 %sub97, %57
  store i32 %sub98, ptr %moreargs96, align 4
  %58 = load ptr, ptr %argv.addr, align 8
  %59 = load i32, ptr %j92, align 4
  %idxprom99 = sext i32 %59 to i64
  %arrayidx100 = getelementptr inbounds ptr, ptr %58, i64 %idxprom99
  %60 = load ptr, ptr %arrayidx100, align 8
  %call101 = call i32 @strcasecmp(ptr noundef %60, ptr noundef @.str.739) #12
  %tobool102 = icmp ne i32 %call101, 0
  br i1 %tobool102, label %if.else106, label %land.lhs.true103

land.lhs.true103:                                 ; preds = %for.body95
  %61 = load i32, ptr %moreargs96, align 4
  %tobool104 = icmp ne i32 %61, 0
  br i1 %tobool104, label %if.then105, label %if.else106

if.then105:                                       ; preds = %land.lhs.true103
  store i32 1, ptr %retval, align 4
  br label %return

if.else106:                                       ; preds = %land.lhs.true103, %for.body95
  %62 = load ptr, ptr %argv.addr, align 8
  %63 = load i32, ptr %j92, align 4
  %idxprom107 = sext i32 %63 to i64
  %arrayidx108 = getelementptr inbounds ptr, ptr %62, i64 %idxprom107
  %64 = load ptr, ptr %arrayidx108, align 8
  %call109 = call i32 @strcasecmp(ptr noundef %64, ptr noundef @.str.753) #12
  %tobool110 = icmp ne i32 %call109, 0
  br i1 %tobool110, label %if.else114, label %land.lhs.true111

land.lhs.true111:                                 ; preds = %if.else106
  %65 = load i32, ptr %moreargs96, align 4
  %cmp112 = icmp sge i32 %65, 2
  br i1 %cmp112, label %if.then113, label %if.else114

if.then113:                                       ; preds = %land.lhs.true111
  store i32 1, ptr %retval, align 4
  br label %return

if.else114:                                       ; preds = %land.lhs.true111, %if.else106
  %66 = load ptr, ptr %argv.addr, align 8
  %67 = load i32, ptr %j92, align 4
  %idxprom115 = sext i32 %67 to i64
  %arrayidx116 = getelementptr inbounds ptr, ptr %66, i64 %idxprom115
  %68 = load ptr, ptr %arrayidx116, align 8
  %call117 = call i32 @strcasecmp(ptr noundef %68, ptr noundef @.str.754) #12
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %if.end122, label %land.lhs.true119

land.lhs.true119:                                 ; preds = %if.else114
  %69 = load i32, ptr %moreargs96, align 4
  %tobool120 = icmp ne i32 %69, 0
  br i1 %tobool120, label %if.then121, label %if.end122

if.then121:                                       ; preds = %land.lhs.true119
  store i32 0, ptr %retval, align 4
  br label %return

if.end122:                                        ; preds = %land.lhs.true119, %if.else114
  br label %if.end123

if.end123:                                        ; preds = %if.end122
  br label %if.end124

if.end124:                                        ; preds = %if.end123
  br label %for.inc125

for.inc125:                                       ; preds = %if.end124
  %70 = load i32, ptr %j92, align 4
  %inc126 = add nsw i32 %70, 1
  store i32 %inc126, ptr %j92, align 4
  br label %for.cond93, !llvm.loop !250

for.end127:                                       ; preds = %for.cond93
  br label %if.end166

if.else128:                                       ; preds = %land.lhs.true87, %if.else85
  %71 = load i32, ptr %argc.addr, align 4
  %cmp129 = icmp sgt i32 %71, 4
  br i1 %cmp129, label %land.lhs.true130, label %if.end165

land.lhs.true130:                                 ; preds = %if.else128
  %72 = load ptr, ptr %argv.addr, align 8
  %arrayidx131 = getelementptr inbounds ptr, ptr %72, i64 0
  %73 = load ptr, ptr %arrayidx131, align 8
  %call132 = call i32 @strcasecmp(ptr noundef %73, ptr noundef @.str.755) #12
  %tobool133 = icmp ne i32 %call132, 0
  br i1 %tobool133, label %if.end165, label %if.then134

if.then134:                                       ; preds = %land.lhs.true130
  %74 = load ptr, ptr %argv.addr, align 8
  %arrayidx135 = getelementptr inbounds ptr, ptr %74, i64 1
  %75 = load ptr, ptr %arrayidx135, align 8
  %call136 = call i32 @strcasecmp(ptr noundef %75, ptr noundef @.str.744) #12
  %tobool137 = icmp ne i32 %call136, 0
  br i1 %tobool137, label %if.end151, label %land.lhs.true138

land.lhs.true138:                                 ; preds = %if.then134
  %76 = load ptr, ptr %argv.addr, align 8
  %arrayidx139 = getelementptr inbounds ptr, ptr %76, i64 2
  %77 = load ptr, ptr %arrayidx139, align 8
  %call140 = call i32 @strcasecmp(ptr noundef %77, ptr noundef @.str.97) #12
  %tobool141 = icmp ne i32 %call140, 0
  br i1 %tobool141, label %if.end151, label %land.lhs.true142

land.lhs.true142:                                 ; preds = %land.lhs.true138
  %78 = load ptr, ptr %argv.addr, align 8
  %arrayidx143 = getelementptr inbounds ptr, ptr %78, i64 3
  %79 = load ptr, ptr %arrayidx143, align 8
  %call144 = call i32 @strcasecmp(ptr noundef %79, ptr noundef @.str.756) #12
  %tobool145 = icmp ne i32 %call144, 0
  br i1 %tobool145, label %lor.lhs.false146, label %if.then150

lor.lhs.false146:                                 ; preds = %land.lhs.true142
  %80 = load ptr, ptr %argv.addr, align 8
  %arrayidx147 = getelementptr inbounds ptr, ptr %80, i64 3
  %81 = load ptr, ptr %arrayidx147, align 8
  %call148 = call i32 @strcasecmp(ptr noundef %81, ptr noundef @.str.757) #12
  %tobool149 = icmp ne i32 %call148, 0
  br i1 %tobool149, label %if.end151, label %if.then150

if.then150:                                       ; preds = %lor.lhs.false146, %land.lhs.true142
  store i32 1, ptr %retval, align 4
  br label %return

if.end151:                                        ; preds = %lor.lhs.false146, %land.lhs.true138, %if.then134
  %82 = load ptr, ptr %argv.addr, align 8
  %arrayidx152 = getelementptr inbounds ptr, ptr %82, i64 1
  %83 = load ptr, ptr %arrayidx152, align 8
  %call153 = call i32 @strcasecmp(ptr noundef %83, ptr noundef @.str.97) #12
  %tobool154 = icmp ne i32 %call153, 0
  br i1 %tobool154, label %if.end164, label %land.lhs.true155

land.lhs.true155:                                 ; preds = %if.end151
  %84 = load ptr, ptr %argv.addr, align 8
  %arrayidx156 = getelementptr inbounds ptr, ptr %84, i64 3
  %85 = load ptr, ptr %arrayidx156, align 8
  %call157 = call i32 @strcasecmp(ptr noundef %85, ptr noundef @.str.758) #12
  %tobool158 = icmp ne i32 %call157, 0
  br i1 %tobool158, label %lor.lhs.false159, label %if.then163

lor.lhs.false159:                                 ; preds = %land.lhs.true155
  %86 = load ptr, ptr %argv.addr, align 8
  %arrayidx160 = getelementptr inbounds ptr, ptr %86, i64 3
  %87 = load ptr, ptr %arrayidx160, align 8
  %call161 = call i32 @strcasecmp(ptr noundef %87, ptr noundef @.str.759) #12
  %tobool162 = icmp ne i32 %call161, 0
  br i1 %tobool162, label %if.end164, label %if.then163

if.then163:                                       ; preds = %lor.lhs.false159, %land.lhs.true155
  store i32 1, ptr %retval, align 4
  br label %return

if.end164:                                        ; preds = %lor.lhs.false159, %if.end151
  br label %if.end165

if.end165:                                        ; preds = %if.end164, %land.lhs.true130, %if.else128
  br label %if.end166

if.end166:                                        ; preds = %if.end165, %for.end127
  br label %if.end167

if.end167:                                        ; preds = %if.end166, %for.end84
  br label %if.end168

if.end168:                                        ; preds = %if.end167
  br label %if.end169

if.end169:                                        ; preds = %if.end168
  br label %if.end170

if.end170:                                        ; preds = %if.end169
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end170, %if.then163, %if.then150, %if.then121, %if.then113, %if.then105, %if.else79, %if.then70, %for.end, %if.then51, %if.then15, %if.then
  %88 = load i32, ptr %retval, align 4
  ret i32 %88
}

declare void @linenoiseClearScreen() #2

; Function Attrs: nounwind uwtable
define internal i32 @issueCommandRepeat(i32 noundef %argc, ptr noundef %argv, i64 noundef %repeat) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %repeat.addr = alloca i64, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i64 %repeat, ptr %repeat.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 0
  %2 = load ptr, ptr %arrayidx, align 8
  %call = call i32 @strcasecmp(ptr noundef %2, ptr noundef @.str.60) #12
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %argv.addr, align 8
  %arrayidx2 = getelementptr inbounds ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx2, align 8
  %call3 = call i32 @strcasecmp(ptr noundef %4, ptr noundef @.str.109) #12
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load i32, ptr %argc.addr, align 4
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %argc.addr, align 4
  %6 = load ptr, ptr %argv.addr, align 8
  %incdec.ptr = getelementptr inbounds ptr, ptr %6, i32 1
  store ptr %incdec.ptr, ptr %argv.addr, align 8
  call void @cliOutputHelp(i32 noundef %dec, ptr noundef %incdec.ptr)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  br label %while.body

while.body:                                       ; preds = %if.then32, %if.end
  %7 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 18), align 4
  %tobool5 = icmp ne i32 %7, 0
  br i1 %tobool5, label %if.then12, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %while.body
  %8 = load ptr, ptr @context, align 8
  %cmp = icmp eq ptr %8, null
  br i1 %cmp, label %if.then12, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false6
  %9 = load ptr, ptr @context, align 8
  %err = getelementptr inbounds %struct.redisContext, ptr %9, i32 0, i32 1
  %10 = load i32, ptr %err, align 8
  %cmp8 = icmp eq i32 %10, 1
  br i1 %cmp8, label %if.then12, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false7
  %11 = load ptr, ptr @context, align 8
  %err10 = getelementptr inbounds %struct.redisContext, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %err10, align 8
  %cmp11 = icmp eq i32 %12, 3
  br i1 %cmp11, label %if.then12, label %if.end17

if.then12:                                        ; preds = %lor.lhs.false9, %lor.lhs.false7, %lor.lhs.false6, %while.body
  %call13 = call i32 @cliConnect(i32 noundef 1)
  %cmp14 = icmp ne i32 %call13, 0
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then12
  call void @cliPrintContextError()
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 18), align 4
  store i32 -1, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.then12
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %lor.lhs.false9
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 18), align 4
  %13 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 19), align 8
  %tobool18 = icmp ne i32 %13, 0
  br i1 %tobool18, label %if.then19, label %if.end24

if.then19:                                        ; preds = %if.end17
  %call20 = call i32 @cliSendAsking()
  %cmp21 = icmp ne i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then19
  call void @cliPrintContextError()
  store i32 -1, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.then19
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.end17
  %14 = load i32, ptr %argc.addr, align 4
  %15 = load ptr, ptr %argv.addr, align 8
  %16 = load i64, ptr %repeat.addr, align 8
  %call25 = call i32 @cliSendCommand(i32 noundef %14, ptr noundef %15, i64 noundef %16)
  %cmp26 = icmp ne i32 %call25, 0
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end24
  call void @cliPrintContextError()
  %17 = load ptr, ptr @context, align 8
  call void @redisFree(ptr noundef %17)
  store ptr null, ptr @context, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end24
  %18 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 17), align 8
  %tobool29 = icmp ne i32 %18, 0
  br i1 %tobool29, label %land.lhs.true30, label %if.end33

land.lhs.true30:                                  ; preds = %if.end28
  %19 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 18), align 4
  %tobool31 = icmp ne i32 %19, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true30
  br label %while.body

if.end33:                                         ; preds = %land.lhs.true30, %if.end28
  br label %while.end

while.end:                                        ; preds = %if.end33
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then27, %if.then22, %if.then15, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define internal void @cliWaitForMessagesOrStdin() #0 {
entry:
  %show_info = alloca i32, align 4
  %use_color = alloca i32, align 4
  %reply = alloca ptr, align 8
  %out = alloca ptr, align 8
  %tv = alloca %struct.timeval, align 8
  %readfds = alloca %struct.fd_set, align 8
  %__i = alloca i32, align 4
  %__arr = alloca ptr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call = call i32 @isatty(i32 noundef 1) #15
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %call1 = call ptr @getenv(ptr noundef @.str.125) #15
  %tobool2 = icmp ne ptr %call1, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %1 = phi i1 [ true, %land.rhs ], [ %tobool2, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %2 = phi i1 [ false, %entry ], [ %1, %lor.end ]
  %land.ext = zext i1 %2 to i32
  store i32 %land.ext, ptr %show_info, align 4
  %3 = load i32, ptr %show_info, align 4
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %land.rhs4, label %land.end7

land.rhs4:                                        ; preds = %land.end
  %call5 = call i32 @isColorTerm()
  %tobool6 = icmp ne i32 %call5, 0
  br label %land.end7

land.end7:                                        ; preds = %land.rhs4, %land.end
  %4 = phi i1 [ false, %land.end ], [ %tobool6, %land.rhs4 ]
  %land.ext8 = zext i1 %4 to i32
  store i32 %land.ext8, ptr %use_color, align 4
  call void @cliPressAnyKeyTTY()
  br label %while.cond

while.cond:                                       ; preds = %if.end86, %land.end7
  %5 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool9 = icmp ne i32 %5, 0
  br i1 %tobool9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %do.cond, %while.body
  %6 = load ptr, ptr @context, align 8
  %call10 = call i32 @redisGetReplyFromReader(ptr noundef %6, ptr noundef %reply)
  %cmp11 = icmp ne i32 %call10, 0
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  call void @cliPrintContextError()
  call void @exit(i32 noundef 1) #17
  unreachable

if.end:                                           ; preds = %do.body
  %7 = load ptr, ptr %reply, align 8
  %tobool12 = icmp ne ptr %7, null
  br i1 %tobool12, label %if.then13, label %if.end18

if.then13:                                        ; preds = %if.end
  %8 = load ptr, ptr %reply, align 8
  %9 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  %call14 = call ptr @cliFormatReply(ptr noundef %8, i32 noundef %9, i32 noundef 0)
  store ptr %call14, ptr %out, align 8
  %10 = load ptr, ptr %out, align 8
  %11 = load ptr, ptr %out, align 8
  %call15 = call i64 @hi_sdslen(ptr noundef %11)
  %12 = load ptr, ptr @stdout, align 8
  %call16 = call i64 @fwrite(ptr noundef %10, i64 noundef %call15, i64 noundef 1, ptr noundef %12)
  %13 = load ptr, ptr @stdout, align 8
  %call17 = call i32 @fflush(ptr noundef %13)
  %14 = load ptr, ptr %out, align 8
  call void @hi_sdsfree(ptr noundef %14)
  br label %if.end18

if.end18:                                         ; preds = %if.then13, %if.end
  br label %do.cond

do.cond:                                          ; preds = %if.end18
  %15 = load ptr, ptr %reply, align 8
  %tobool19 = icmp ne ptr %15, null
  br i1 %tobool19, label %do.body, label %do.end, !llvm.loop !251

do.end:                                           ; preds = %do.cond
  br label %do.body20

do.body20:                                        ; preds = %do.end
  store ptr %readfds, ptr %__arr, align 8
  store i32 0, ptr %__i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body20
  %16 = load i32, ptr %__i, align 4
  %conv = zext i32 %16 to i64
  %cmp21 = icmp ult i64 %conv, 16
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load ptr, ptr %__arr, align 8
  %fds_bits = getelementptr inbounds %struct.fd_set, ptr %17, i32 0, i32 0
  %18 = load i32, ptr %__i, align 4
  %idxprom = zext i32 %18 to i64
  %arrayidx = getelementptr inbounds [16 x i64], ptr %fds_bits, i64 0, i64 %idxprom
  store i64 0, ptr %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32, ptr %__i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, ptr %__i, align 4
  br label %for.cond, !llvm.loop !252

for.end:                                          ; preds = %for.cond
  br label %do.end24

do.end24:                                         ; preds = %for.end
  %20 = load ptr, ptr @context, align 8
  %fd = getelementptr inbounds %struct.redisContext, ptr %20, i32 0, i32 3
  %21 = load i32, ptr %fd, align 4
  %rem = srem i32 %21, 64
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom
  %fds_bits25 = getelementptr inbounds %struct.fd_set, ptr %readfds, i32 0, i32 0
  %22 = load ptr, ptr @context, align 8
  %fd26 = getelementptr inbounds %struct.redisContext, ptr %22, i32 0, i32 3
  %23 = load i32, ptr %fd26, align 4
  %div = sdiv i32 %23, 64
  %idxprom27 = sext i32 %div to i64
  %arrayidx28 = getelementptr inbounds [16 x i64], ptr %fds_bits25, i64 0, i64 %idxprom27
  %24 = load i64, ptr %arrayidx28, align 8
  %or = or i64 %24, %shl
  store i64 %or, ptr %arrayidx28, align 8
  %fds_bits29 = getelementptr inbounds %struct.fd_set, ptr %readfds, i32 0, i32 0
  %arrayidx30 = getelementptr inbounds [16 x i64], ptr %fds_bits29, i64 0, i64 0
  %25 = load i64, ptr %arrayidx30, align 8
  %or31 = or i64 %25, 1
  store i64 %or31, ptr %arrayidx30, align 8
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 0
  store i64 5, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 1
  store i64 0, ptr %tv_usec, align 8
  %26 = load i32, ptr %show_info, align 4
  %tobool32 = icmp ne i32 %26, 0
  br i1 %tobool32, label %if.then33, label %if.end44

if.then33:                                        ; preds = %do.end24
  %27 = load i32, ptr %use_color, align 4
  %tobool34 = icmp ne i32 %27, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.then33
  %call36 = call i32 (ptr, ...) @printf(ptr noundef @.str.799)
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.then33
  %call38 = call i32 (ptr, ...) @printf(ptr noundef @.str.800)
  %28 = load i32, ptr %use_color, align 4
  %tobool39 = icmp ne i32 %28, 0
  br i1 %tobool39, label %if.then40, label %if.end42

if.then40:                                        ; preds = %if.end37
  %call41 = call i32 (ptr, ...) @printf(ptr noundef @.str.14)
  br label %if.end42

if.end42:                                         ; preds = %if.then40, %if.end37
  %29 = load ptr, ptr @stdout, align 8
  %call43 = call i32 @fflush(ptr noundef %29)
  br label %if.end44

if.end44:                                         ; preds = %if.end42, %do.end24
  %30 = load ptr, ptr @context, align 8
  %fd45 = getelementptr inbounds %struct.redisContext, ptr %30, i32 0, i32 3
  %31 = load i32, ptr %fd45, align 4
  %add = add nsw i32 %31, 1
  %call46 = call i32 @select(i32 noundef %add, ptr noundef %readfds, ptr noundef null, ptr noundef null, ptr noundef %tv)
  %32 = load i32, ptr %show_info, align 4
  %tobool47 = icmp ne i32 %32, 0
  br i1 %tobool47, label %if.then48, label %if.end51

if.then48:                                        ; preds = %if.end44
  %call49 = call i32 (ptr, ...) @printf(ptr noundef @.str.801)
  %33 = load ptr, ptr @stdout, align 8
  %call50 = call i32 @fflush(ptr noundef %33)
  br label %if.end51

if.end51:                                         ; preds = %if.then48, %if.end44
  %34 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 11), align 4
  %tobool52 = icmp ne i32 %34, 0
  br i1 %tobool52, label %if.then53, label %if.else

if.then53:                                        ; preds = %if.end51
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 11), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %call54 = call i32 @cliConnect(i32 noundef 1)
  %cmp55 = icmp ne i32 %call54, 0
  br i1 %cmp55, label %if.then57, label %if.end58

if.then57:                                        ; preds = %if.then53
  call void @cliPrintContextError()
  call void @exit(i32 noundef 1) #17
  unreachable

if.end58:                                         ; preds = %if.then53
  br label %while.end

if.else:                                          ; preds = %if.end51
  %fds_bits59 = getelementptr inbounds %struct.fd_set, ptr %readfds, i32 0, i32 0
  %35 = load ptr, ptr @context, align 8
  %fd60 = getelementptr inbounds %struct.redisContext, ptr %35, i32 0, i32 3
  %36 = load i32, ptr %fd60, align 4
  %div61 = sdiv i32 %36, 64
  %idxprom62 = sext i32 %div61 to i64
  %arrayidx63 = getelementptr inbounds [16 x i64], ptr %fds_bits59, i64 0, i64 %idxprom62
  %37 = load i64, ptr %arrayidx63, align 8
  %38 = load ptr, ptr @context, align 8
  %fd64 = getelementptr inbounds %struct.redisContext, ptr %38, i32 0, i32 3
  %39 = load i32, ptr %fd64, align 4
  %rem65 = srem i32 %39, 64
  %sh_prom66 = zext i32 %rem65 to i64
  %shl67 = shl i64 1, %sh_prom66
  %and = and i64 %37, %shl67
  %cmp68 = icmp ne i64 %and, 0
  br i1 %cmp68, label %if.then70, label %if.else77

if.then70:                                        ; preds = %if.else
  %call71 = call i32 @cliReadReply(i32 noundef 0)
  %cmp72 = icmp ne i32 %call71, 0
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.then70
  call void @cliPrintContextError()
  call void @exit(i32 noundef 1) #17
  unreachable

if.end75:                                         ; preds = %if.then70
  %40 = load ptr, ptr @stdout, align 8
  %call76 = call i32 @fflush(ptr noundef %40)
  br label %if.end85

if.else77:                                        ; preds = %if.else
  %fds_bits78 = getelementptr inbounds %struct.fd_set, ptr %readfds, i32 0, i32 0
  %arrayidx79 = getelementptr inbounds [16 x i64], ptr %fds_bits78, i64 0, i64 0
  %41 = load i64, ptr %arrayidx79, align 8
  %and80 = and i64 %41, 1
  %cmp81 = icmp ne i64 %and80, 0
  br i1 %cmp81, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.else77
  br label %while.end

if.end84:                                         ; preds = %if.else77
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %if.end75
  br label %if.end86

if.end86:                                         ; preds = %if.end85
  br label %while.cond, !llvm.loop !253

while.end:                                        ; preds = %if.then83, %if.end58, %while.cond
  call void @cliRestoreTTY()
  ret void
}

declare void @linenoiseAddCompletion(ptr noundef, ptr noundef) #2

declare ptr @hi_sds_malloc(i64 noundef) #2

; Function Attrs: nounwind uwtable
define internal void @cliOutputHelp(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %group = alloca ptr, align 8
  %entry1 = alloca ptr, align 8
  %help = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store ptr null, ptr %group, align 8
  %0 = load i32, ptr %argc.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @cliOutputGenericHelp()
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i32, ptr %argc.addr, align 4
  %cmp2 = icmp sgt i32 %1, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %2 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 0
  %3 = load ptr, ptr %arrayidx, align 8
  %arrayidx3 = getelementptr inbounds i8, ptr %3, i64 0
  %4 = load i8, ptr %arrayidx3, align 1
  %conv = sext i8 %4 to i32
  %cmp4 = icmp eq i32 %conv, 64
  br i1 %cmp4, label %if.then6, label %if.end

if.then6:                                         ; preds = %land.lhs.true
  %5 = load ptr, ptr %argv.addr, align 8
  %arrayidx7 = getelementptr inbounds ptr, ptr %5, i64 0
  %6 = load ptr, ptr %arrayidx7, align 8
  %add.ptr = getelementptr inbounds i8, ptr %6, i64 1
  store ptr %add.ptr, ptr %group, align 8
  br label %if.end

if.end:                                           ; preds = %if.then6, %land.lhs.true, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end
  %7 = load ptr, ptr @helpEntries, align 8
  %cmp9 = icmp eq ptr %7, null
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  call void @cliInitHelp()
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc53, %if.end12
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr @helpEntriesLen, align 4
  %cmp13 = icmp slt i32 %8, %9
  br i1 %cmp13, label %for.body, label %for.end55

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr @helpEntries, align 8
  %11 = load i32, ptr %i, align 4
  %idxprom = sext i32 %11 to i64
  %arrayidx15 = getelementptr inbounds %struct.helpEntry, ptr %10, i64 %idxprom
  store ptr %arrayidx15, ptr %entry1, align 8
  %12 = load ptr, ptr %entry1, align 8
  %type = getelementptr inbounds %struct.helpEntry, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %type, align 8
  %cmp16 = icmp ne i32 %13, 1
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %for.body
  br label %for.inc53

if.end19:                                         ; preds = %for.body
  %14 = load ptr, ptr %entry1, align 8
  %docs = getelementptr inbounds %struct.helpEntry, ptr %14, i32 0, i32 4
  store ptr %docs, ptr %help, align 8
  %15 = load ptr, ptr %group, align 8
  %cmp20 = icmp eq ptr %15, null
  br i1 %cmp20, label %if.then22, label %if.else45

if.then22:                                        ; preds = %if.end19
  %16 = load i32, ptr %argc.addr, align 4
  %17 = load ptr, ptr %entry1, align 8
  %argc23 = getelementptr inbounds %struct.helpEntry, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %argc23, align 4
  %cmp24 = icmp sle i32 %16, %18
  br i1 %cmp24, label %if.then26, label %if.end44

if.then26:                                        ; preds = %if.then22
  store i32 0, ptr %j, align 4
  br label %for.cond27

for.cond27:                                       ; preds = %for.inc, %if.then26
  %19 = load i32, ptr %j, align 4
  %20 = load i32, ptr %argc.addr, align 4
  %cmp28 = icmp slt i32 %19, %20
  br i1 %cmp28, label %for.body30, label %for.end

for.body30:                                       ; preds = %for.cond27
  %21 = load ptr, ptr %argv.addr, align 8
  %22 = load i32, ptr %j, align 4
  %idxprom31 = sext i32 %22 to i64
  %arrayidx32 = getelementptr inbounds ptr, ptr %21, i64 %idxprom31
  %23 = load ptr, ptr %arrayidx32, align 8
  %24 = load ptr, ptr %entry1, align 8
  %argv33 = getelementptr inbounds %struct.helpEntry, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %argv33, align 8
  %26 = load i32, ptr %j, align 4
  %idxprom34 = sext i32 %26 to i64
  %arrayidx35 = getelementptr inbounds ptr, ptr %25, i64 %idxprom34
  %27 = load ptr, ptr %arrayidx35, align 8
  %call = call i32 @strcasecmp(ptr noundef %23, ptr noundef %27) #12
  %cmp36 = icmp ne i32 %call, 0
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %for.body30
  br label %for.end

if.end39:                                         ; preds = %for.body30
  br label %for.inc

for.inc:                                          ; preds = %if.end39
  %28 = load i32, ptr %j, align 4
  %inc = add nsw i32 %28, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond27, !llvm.loop !254

for.end:                                          ; preds = %if.then38, %for.cond27
  %29 = load i32, ptr %j, align 4
  %30 = load i32, ptr %argc.addr, align 4
  %cmp40 = icmp eq i32 %29, %30
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %for.end
  %31 = load ptr, ptr %help, align 8
  call void @cliOutputCommandHelp(ptr noundef %31, i32 noundef 1)
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %for.end
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.then22
  br label %if.end52

if.else45:                                        ; preds = %if.end19
  %32 = load ptr, ptr %group, align 8
  %33 = load ptr, ptr %help, align 8
  %group46 = getelementptr inbounds %struct.commandDocs, ptr %33, i32 0, i32 2
  %34 = load ptr, ptr %group46, align 8
  %call47 = call i32 @strcasecmp(ptr noundef %32, ptr noundef %34) #12
  %cmp48 = icmp eq i32 %call47, 0
  br i1 %cmp48, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.else45
  %35 = load ptr, ptr %help, align 8
  call void @cliOutputCommandHelp(ptr noundef %35, i32 noundef 0)
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %if.else45
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.end44
  br label %for.inc53

for.inc53:                                        ; preds = %if.end52, %if.then18
  %36 = load i32, ptr %i, align 4
  %inc54 = add nsw i32 %36, 1
  store i32 %inc54, ptr %i, align 4
  br label %for.cond, !llvm.loop !255

for.end55:                                        ; preds = %for.cond
  %call56 = call i32 (ptr, ...) @printf(ptr noundef @.str.760)
  br label %return

return:                                           ; preds = %for.end55, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @cliSendAsking() #0 {
entry:
  %retval = alloca i32, align 4
  %reply = alloca ptr, align 8
  %result = alloca i32, align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 19), align 8
  %0 = load ptr, ptr @context, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr @context, align 8
  %call = call ptr (ptr, ptr, ...) @redisCommand(ptr noundef %1, ptr noundef @.str.766)
  store ptr %call, ptr %reply, align 8
  %2 = load ptr, ptr %reply, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr @stderr, align 8
  %call3 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %3, ptr noundef @.str.76)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  store i32 0, ptr %result, align 4
  %4 = load ptr, ptr %reply, align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type, align 8
  %cmp5 = icmp eq i32 %5, 6
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  store i32 -1, ptr %result, align 4
  %6 = load ptr, ptr @stderr, align 8
  %7 = load ptr, ptr %reply, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %7, i32 0, i32 4
  %8 = load ptr, ptr %str, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.767, ptr noundef %8)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %9 = load ptr, ptr %reply, align 8
  call void @freeReplyObject(ptr noundef %9)
  %10 = load i32, ptr %result, align 4
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then2, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @cliSendCommand(i32 noundef %argc, ptr noundef %argv, i64 noundef %repeat) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %repeat.addr = alloca i64, align 8
  %command = alloca ptr, align 8
  %argvlen = alloca ptr, align 8
  %j = alloca i32, align 4
  %output_raw = alloca i32, align 4
  %is_subscribe = alloca i32, align 4
  %is_unsubscribe = alloca i32, align 4
  %num_expected_pubsub_push = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i64 %repeat, ptr %repeat.addr, align 8
  %0 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %0, i64 0
  %1 = load ptr, ptr %arrayidx, align 8
  store ptr %1, ptr %command, align 8
  %2 = load ptr, ptr @context, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %output_raw, align 4
  %3 = load ptr, ptr %command, align 8
  %call = call i32 @strcasecmp(ptr noundef %3, ptr noundef @.str.38) #12
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then95

lor.lhs.false:                                    ; preds = %if.end
  %4 = load ptr, ptr %command, align 8
  %call1 = call i32 @strcasecmp(ptr noundef %4, ptr noundef @.str.768) #12
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %lor.lhs.false3, label %if.then95

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %5 = load i32, ptr %argc.addr, align 4
  %cmp4 = icmp sge i32 %5, 2
  br i1 %cmp4, label %land.lhs.true, label %lor.lhs.false11

land.lhs.true:                                    ; preds = %lor.lhs.false3
  %6 = load ptr, ptr %command, align 8
  %call5 = call i32 @strcasecmp(ptr noundef %6, ptr noundef @.str.769) #12
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %lor.lhs.false11, label %land.lhs.true7

land.lhs.true7:                                   ; preds = %land.lhs.true
  %7 = load ptr, ptr %argv.addr, align 8
  %arrayidx8 = getelementptr inbounds ptr, ptr %7, i64 1
  %8 = load ptr, ptr %arrayidx8, align 8
  %call9 = call i32 @strcasecmp(ptr noundef %8, ptr noundef @.str.770) #12
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %lor.lhs.false11, label %if.then95

lor.lhs.false11:                                  ; preds = %land.lhs.true7, %land.lhs.true, %lor.lhs.false3
  %9 = load i32, ptr %argc.addr, align 4
  %cmp12 = icmp sge i32 %9, 2
  br i1 %cmp12, label %land.lhs.true13, label %lor.lhs.false20

land.lhs.true13:                                  ; preds = %lor.lhs.false11
  %10 = load ptr, ptr %command, align 8
  %call14 = call i32 @strcasecmp(ptr noundef %10, ptr noundef @.str.769) #12
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %lor.lhs.false20, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %11 = load ptr, ptr %argv.addr, align 8
  %arrayidx17 = getelementptr inbounds ptr, ptr %11, i64 1
  %12 = load ptr, ptr %arrayidx17, align 8
  %call18 = call i32 @strcasecmp(ptr noundef %12, ptr noundef @.str.771) #12
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %lor.lhs.false20, label %if.then95

lor.lhs.false20:                                  ; preds = %land.lhs.true16, %land.lhs.true13, %lor.lhs.false11
  %13 = load i32, ptr %argc.addr, align 4
  %cmp21 = icmp sge i32 %13, 2
  br i1 %cmp21, label %land.lhs.true22, label %lor.lhs.false29

land.lhs.true22:                                  ; preds = %lor.lhs.false20
  %14 = load ptr, ptr %command, align 8
  %call23 = call i32 @strcasecmp(ptr noundef %14, ptr noundef @.str.769) #12
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %lor.lhs.false29, label %land.lhs.true25

land.lhs.true25:                                  ; preds = %land.lhs.true22
  %15 = load ptr, ptr %argv.addr, align 8
  %arrayidx26 = getelementptr inbounds ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx26, align 8
  %call27 = call i32 @strcasecmp(ptr noundef %16, ptr noundef @.str.772) #12
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %lor.lhs.false29, label %if.then95

lor.lhs.false29:                                  ; preds = %land.lhs.true25, %land.lhs.true22, %lor.lhs.false20
  %17 = load i32, ptr %argc.addr, align 4
  %cmp30 = icmp sge i32 %17, 2
  br i1 %cmp30, label %land.lhs.true31, label %lor.lhs.false42

land.lhs.true31:                                  ; preds = %lor.lhs.false29
  %18 = load ptr, ptr %command, align 8
  %call32 = call i32 @strcasecmp(ptr noundef %18, ptr noundef @.str.773) #12
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %lor.lhs.false42, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %land.lhs.true31
  %19 = load ptr, ptr %argv.addr, align 8
  %arrayidx35 = getelementptr inbounds ptr, ptr %19, i64 1
  %20 = load ptr, ptr %arrayidx35, align 8
  %call36 = call i32 @strcasecmp(ptr noundef %20, ptr noundef @.str.774) #12
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %lor.lhs.false38, label %if.then95

lor.lhs.false38:                                  ; preds = %land.lhs.true34
  %21 = load ptr, ptr %argv.addr, align 8
  %arrayidx39 = getelementptr inbounds ptr, ptr %21, i64 1
  %22 = load ptr, ptr %arrayidx39, align 8
  %call40 = call i32 @strcasecmp(ptr noundef %22, ptr noundef @.str.775) #12
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %lor.lhs.false42, label %if.then95

lor.lhs.false42:                                  ; preds = %lor.lhs.false38, %land.lhs.true31, %lor.lhs.false29
  %23 = load i32, ptr %argc.addr, align 4
  %cmp43 = icmp eq i32 %23, 2
  br i1 %cmp43, label %land.lhs.true44, label %lor.lhs.false55

land.lhs.true44:                                  ; preds = %lor.lhs.false42
  %24 = load ptr, ptr %command, align 8
  %call45 = call i32 @strcasecmp(ptr noundef %24, ptr noundef @.str.776) #12
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %lor.lhs.false55, label %land.lhs.true47

land.lhs.true47:                                  ; preds = %land.lhs.true44
  %25 = load ptr, ptr %argv.addr, align 8
  %arrayidx48 = getelementptr inbounds ptr, ptr %25, i64 1
  %26 = load ptr, ptr %arrayidx48, align 8
  %call49 = call i32 @strcasecmp(ptr noundef %26, ptr noundef @.str.777) #12
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %lor.lhs.false51, label %if.then95

lor.lhs.false51:                                  ; preds = %land.lhs.true47
  %27 = load ptr, ptr %argv.addr, align 8
  %arrayidx52 = getelementptr inbounds ptr, ptr %27, i64 1
  %28 = load ptr, ptr %arrayidx52, align 8
  %call53 = call i32 @strcasecmp(ptr noundef %28, ptr noundef @.str.38) #12
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %lor.lhs.false55, label %if.then95

lor.lhs.false55:                                  ; preds = %lor.lhs.false51, %land.lhs.true44, %lor.lhs.false42
  %29 = load i32, ptr %argc.addr, align 4
  %cmp56 = icmp sge i32 %29, 2
  br i1 %cmp56, label %land.lhs.true57, label %lor.lhs.false68

land.lhs.true57:                                  ; preds = %lor.lhs.false55
  %30 = load ptr, ptr %command, align 8
  %call58 = call i32 @strcasecmp(ptr noundef %30, ptr noundef @.str.778) #12
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %lor.lhs.false68, label %land.lhs.true60

land.lhs.true60:                                  ; preds = %land.lhs.true57
  %31 = load ptr, ptr %argv.addr, align 8
  %arrayidx61 = getelementptr inbounds ptr, ptr %31, i64 1
  %32 = load ptr, ptr %arrayidx61, align 8
  %call62 = call i32 @strcasecmp(ptr noundef %32, ptr noundef @.str.94) #12
  %tobool63 = icmp ne i32 %call62, 0
  br i1 %tobool63, label %lor.lhs.false64, label %if.then95

lor.lhs.false64:                                  ; preds = %land.lhs.true60
  %33 = load ptr, ptr %argv.addr, align 8
  %arrayidx65 = getelementptr inbounds ptr, ptr %33, i64 1
  %34 = load ptr, ptr %arrayidx65, align 8
  %call66 = call i32 @strcasecmp(ptr noundef %34, ptr noundef @.str.38) #12
  %tobool67 = icmp ne i32 %call66, 0
  br i1 %tobool67, label %lor.lhs.false68, label %if.then95

lor.lhs.false68:                                  ; preds = %lor.lhs.false64, %land.lhs.true57, %lor.lhs.false55
  %35 = load i32, ptr %argc.addr, align 4
  %cmp69 = icmp eq i32 %35, 3
  br i1 %cmp69, label %land.lhs.true70, label %lor.lhs.false77

land.lhs.true70:                                  ; preds = %lor.lhs.false68
  %36 = load ptr, ptr %command, align 8
  %call71 = call i32 @strcasecmp(ptr noundef %36, ptr noundef @.str.779) #12
  %tobool72 = icmp ne i32 %call71, 0
  br i1 %tobool72, label %lor.lhs.false77, label %land.lhs.true73

land.lhs.true73:                                  ; preds = %land.lhs.true70
  %37 = load ptr, ptr %argv.addr, align 8
  %arrayidx74 = getelementptr inbounds ptr, ptr %37, i64 1
  %38 = load ptr, ptr %arrayidx74, align 8
  %call75 = call i32 @strcasecmp(ptr noundef %38, ptr noundef @.str.780) #12
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %lor.lhs.false77, label %if.then95

lor.lhs.false77:                                  ; preds = %land.lhs.true73, %land.lhs.true70, %lor.lhs.false68
  %39 = load i32, ptr %argc.addr, align 4
  %cmp78 = icmp eq i32 %39, 2
  br i1 %cmp78, label %land.lhs.true79, label %lor.lhs.false86

land.lhs.true79:                                  ; preds = %lor.lhs.false77
  %40 = load ptr, ptr %command, align 8
  %call80 = call i32 @strcasecmp(ptr noundef %40, ptr noundef @.str.779) #12
  %tobool81 = icmp ne i32 %call80, 0
  br i1 %tobool81, label %lor.lhs.false86, label %land.lhs.true82

land.lhs.true82:                                  ; preds = %land.lhs.true79
  %41 = load ptr, ptr %argv.addr, align 8
  %arrayidx83 = getelementptr inbounds ptr, ptr %41, i64 1
  %42 = load ptr, ptr %arrayidx83, align 8
  %call84 = call i32 @strcasecmp(ptr noundef %42, ptr noundef @.str.775) #12
  %tobool85 = icmp ne i32 %call84, 0
  br i1 %tobool85, label %lor.lhs.false86, label %if.then95

lor.lhs.false86:                                  ; preds = %land.lhs.true82, %land.lhs.true79, %lor.lhs.false77
  %43 = load i32, ptr %argc.addr, align 4
  %cmp87 = icmp sge i32 %43, 2
  br i1 %cmp87, label %land.lhs.true88, label %if.end96

land.lhs.true88:                                  ; preds = %lor.lhs.false86
  %44 = load ptr, ptr %command, align 8
  %call89 = call i32 @strcasecmp(ptr noundef %44, ptr noundef @.str.781) #12
  %tobool90 = icmp ne i32 %call89, 0
  br i1 %tobool90, label %if.end96, label %land.lhs.true91

land.lhs.true91:                                  ; preds = %land.lhs.true88
  %45 = load ptr, ptr %argv.addr, align 8
  %arrayidx92 = getelementptr inbounds ptr, ptr %45, i64 1
  %46 = load ptr, ptr %arrayidx92, align 8
  %call93 = call i32 @strcasecmp(ptr noundef %46, ptr noundef @.str.38) #12
  %tobool94 = icmp ne i32 %call93, 0
  br i1 %tobool94, label %if.end96, label %if.then95

if.then95:                                        ; preds = %land.lhs.true91, %land.lhs.true82, %land.lhs.true73, %lor.lhs.false64, %land.lhs.true60, %lor.lhs.false51, %land.lhs.true47, %lor.lhs.false38, %land.lhs.true34, %land.lhs.true25, %land.lhs.true16, %land.lhs.true7, %lor.lhs.false, %if.end
  store i32 1, ptr %output_raw, align 4
  br label %if.end96

if.end96:                                         ; preds = %if.then95, %land.lhs.true91, %land.lhs.true88, %lor.lhs.false86
  %47 = load ptr, ptr %command, align 8
  %call97 = call i32 @strcasecmp(ptr noundef %47, ptr noundef @.str.782) #12
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %if.end100, label %if.then99

if.then99:                                        ; preds = %if.end96
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 8), align 8
  br label %if.end100

if.end100:                                        ; preds = %if.then99, %if.end96
  %48 = load ptr, ptr %command, align 8
  %call101 = call i32 @strcasecmp(ptr noundef %48, ptr noundef @.str.783) #12
  %tobool102 = icmp ne i32 %call101, 0
  br i1 %tobool102, label %if.end104, label %if.then103

if.then103:                                       ; preds = %if.end100
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 9), align 4
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %if.end100
  %49 = load ptr, ptr %command, align 8
  %call105 = call i32 @strcasecmp(ptr noundef %49, ptr noundef @.str.2) #12
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %lor.lhs.false107, label %lor.end

lor.lhs.false107:                                 ; preds = %if.end104
  %50 = load ptr, ptr %command, align 8
  %call108 = call i32 @strcasecmp(ptr noundef %50, ptr noundef @.str.784) #12
  %tobool109 = icmp ne i32 %call108, 0
  br i1 %tobool109, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %lor.lhs.false107
  %51 = load ptr, ptr %command, align 8
  %call110 = call i32 @strcasecmp(ptr noundef %51, ptr noundef @.str.785) #12
  %tobool111 = icmp ne i32 %call110, 0
  %lnot = xor i1 %tobool111, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false107, %if.end104
  %52 = phi i1 [ true, %lor.lhs.false107 ], [ true, %if.end104 ], [ %lnot, %lor.rhs ]
  %lor.ext = zext i1 %52 to i32
  store i32 %lor.ext, ptr %is_subscribe, align 4
  %53 = load ptr, ptr %command, align 8
  %call112 = call i32 @strcasecmp(ptr noundef %53, ptr noundef @.str.786) #12
  %tobool113 = icmp ne i32 %call112, 0
  br i1 %tobool113, label %lor.lhs.false114, label %lor.end121

lor.lhs.false114:                                 ; preds = %lor.end
  %54 = load ptr, ptr %command, align 8
  %call115 = call i32 @strcasecmp(ptr noundef %54, ptr noundef @.str.787) #12
  %tobool116 = icmp ne i32 %call115, 0
  br i1 %tobool116, label %lor.rhs117, label %lor.end121

lor.rhs117:                                       ; preds = %lor.lhs.false114
  %55 = load ptr, ptr %command, align 8
  %call118 = call i32 @strcasecmp(ptr noundef %55, ptr noundef @.str.788) #12
  %tobool119 = icmp ne i32 %call118, 0
  %lnot120 = xor i1 %tobool119, true
  br label %lor.end121

lor.end121:                                       ; preds = %lor.rhs117, %lor.lhs.false114, %lor.end
  %56 = phi i1 [ true, %lor.lhs.false114 ], [ true, %lor.end ], [ %lnot120, %lor.rhs117 ]
  %lor.ext122 = zext i1 %56 to i32
  store i32 %lor.ext122, ptr %is_unsubscribe, align 4
  %57 = load ptr, ptr %command, align 8
  %call123 = call i32 @strcasecmp(ptr noundef %57, ptr noundef @.str.789) #12
  %tobool124 = icmp ne i32 %call123, 0
  br i1 %tobool124, label %lor.lhs.false125, label %if.then128

lor.lhs.false125:                                 ; preds = %lor.end121
  %58 = load ptr, ptr %command, align 8
  %call126 = call i32 @strcasecmp(ptr noundef %58, ptr noundef @.str.790) #12
  %tobool127 = icmp ne i32 %call126, 0
  br i1 %tobool127, label %if.end129, label %if.then128

if.then128:                                       ; preds = %lor.lhs.false125, %lor.end121
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 20), align 4
  br label %if.end129

if.end129:                                        ; preds = %if.then128, %lor.lhs.false125
  %59 = load i32, ptr %argc.addr, align 4
  %cmp130 = icmp eq i32 %59, 3
  br i1 %cmp130, label %land.lhs.true131, label %if.end149

land.lhs.true131:                                 ; preds = %if.end129
  %60 = load ptr, ptr %argv.addr, align 8
  %arrayidx132 = getelementptr inbounds ptr, ptr %60, i64 0
  %61 = load ptr, ptr %arrayidx132, align 8
  %call133 = call i32 @strcasecmp(ptr noundef %61, ptr noundef @.str.791) #12
  %tobool134 = icmp ne i32 %call133, 0
  br i1 %tobool134, label %if.end149, label %land.lhs.true135

land.lhs.true135:                                 ; preds = %land.lhs.true131
  %62 = load ptr, ptr %argv.addr, align 8
  %arrayidx136 = getelementptr inbounds ptr, ptr %62, i64 1
  %63 = load ptr, ptr %arrayidx136, align 8
  %call137 = call i32 @strcasecmp(ptr noundef %63, ptr noundef @.str.769) #12
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.end149, label %if.then139

if.then139:                                       ; preds = %land.lhs.true135
  %64 = load ptr, ptr %argv.addr, align 8
  %arrayidx140 = getelementptr inbounds ptr, ptr %64, i64 2
  %65 = load ptr, ptr %arrayidx140, align 8
  %call141 = call i32 @strcasecmp(ptr noundef %65, ptr noundef @.str.225) #12
  %tobool142 = icmp ne i32 %call141, 0
  br i1 %tobool142, label %lor.lhs.false143, label %if.then147

lor.lhs.false143:                                 ; preds = %if.then139
  %66 = load ptr, ptr %argv.addr, align 8
  %arrayidx144 = getelementptr inbounds ptr, ptr %66, i64 2
  %67 = load ptr, ptr %arrayidx144, align 8
  %call145 = call i32 @strcasecmp(ptr noundef %67, ptr noundef @.str.789) #12
  %tobool146 = icmp ne i32 %call145, 0
  br i1 %tobool146, label %if.else, label %if.then147

if.then147:                                       ; preds = %lor.lhs.false143, %if.then139
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 50), align 4
  br label %if.end148

if.else:                                          ; preds = %lor.lhs.false143
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 50), align 4
  br label %if.end148

if.end148:                                        ; preds = %if.else, %if.then147
  br label %if.end149

if.end149:                                        ; preds = %if.end148, %land.lhs.true135, %land.lhs.true131, %if.end129
  %68 = load ptr, ptr %command, align 8
  %call150 = call i32 @strcasecmp(ptr noundef %68, ptr noundef @.str.792) #12
  %tobool151 = icmp ne i32 %call150, 0
  br i1 %tobool151, label %if.end155, label %land.lhs.true152

land.lhs.true152:                                 ; preds = %if.end149
  %69 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 50), align 4
  %tobool153 = icmp ne i32 %69, 0
  br i1 %tobool153, label %if.then154, label %if.end155

if.then154:                                       ; preds = %land.lhs.true152
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 47), align 8
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 41), align 8
  br label %if.end155

if.end155:                                        ; preds = %if.then154, %land.lhs.true152, %if.end149
  %70 = load i32, ptr %argc.addr, align 4
  %conv = sext i32 %70 to i64
  %mul = mul i64 %conv, 8
  %call156 = call noalias ptr @zmalloc(i64 noundef %mul) #14
  store ptr %call156, ptr %argvlen, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end155
  %71 = load i32, ptr %j, align 4
  %72 = load i32, ptr %argc.addr, align 4
  %cmp157 = icmp slt i32 %71, %72
  br i1 %cmp157, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %73 = load ptr, ptr %argv.addr, align 8
  %74 = load i32, ptr %j, align 4
  %idxprom = sext i32 %74 to i64
  %arrayidx159 = getelementptr inbounds ptr, ptr %73, i64 %idxprom
  %75 = load ptr, ptr %arrayidx159, align 8
  %call160 = call i64 @hi_sdslen(ptr noundef %75)
  %76 = load ptr, ptr %argvlen, align 8
  %77 = load i32, ptr %j, align 4
  %idxprom161 = sext i32 %77 to i64
  %arrayidx162 = getelementptr inbounds i64, ptr %76, i64 %idxprom161
  store i64 %call160, ptr %arrayidx162, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %78 = load i32, ptr %j, align 4
  %inc = add nsw i32 %78, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !256

for.end:                                          ; preds = %for.cond
  br label %while.cond

while.cond:                                       ; preds = %if.end352, %for.end
  %79 = load i64, ptr %repeat.addr, align 8
  %cmp163 = icmp slt i64 %79, 0
  br i1 %cmp163, label %lor.end168, label %lor.rhs165

lor.rhs165:                                       ; preds = %while.cond
  %80 = load i64, ptr %repeat.addr, align 8
  %dec = add nsw i64 %80, -1
  store i64 %dec, ptr %repeat.addr, align 8
  %cmp166 = icmp sgt i64 %80, 0
  br label %lor.end168

lor.end168:                                       ; preds = %lor.rhs165, %while.cond
  %81 = phi i1 [ true, %while.cond ], [ %cmp166, %lor.rhs165 ]
  br i1 %81, label %while.body, label %while.end354

while.body:                                       ; preds = %lor.end168
  %82 = load ptr, ptr @context, align 8
  %83 = load i32, ptr %argc.addr, align 4
  %84 = load ptr, ptr %argv.addr, align 8
  %85 = load ptr, ptr %argvlen, align 8
  %call170 = call i32 @redisAppendCommandArgv(ptr noundef %82, i32 noundef %83, ptr noundef %84, ptr noundef %85)
  %86 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 9), align 4
  %tobool171 = icmp ne i32 %86, 0
  br i1 %tobool171, label %if.then172, label %if.end184

if.then172:                                       ; preds = %while.body
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then172
  %87 = load i32, ptr %output_raw, align 4
  %call173 = call i32 @cliReadReply(i32 noundef %87)
  %cmp174 = icmp ne i32 %call173, 0
  br i1 %cmp174, label %if.then176, label %if.end177

if.then176:                                       ; preds = %do.body
  call void @cliPrintContextError()
  call void @exit(i32 noundef 1) #17
  unreachable

if.end177:                                        ; preds = %do.body
  %88 = load ptr, ptr @stdout, align 8
  %call178 = call i32 @fflush(ptr noundef %88)
  %89 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp179 = icmp eq i32 %89, 6
  br i1 %cmp179, label %if.then181, label %if.end182

if.then181:                                       ; preds = %if.end177
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 9), align 4
  br label %if.end182

if.end182:                                        ; preds = %if.then181, %if.end177
  br label %do.cond

do.cond:                                          ; preds = %if.end182
  %90 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 9), align 4
  %tobool183 = icmp ne i32 %90, 0
  br i1 %tobool183, label %do.body, label %do.end, !llvm.loop !257

do.end:                                           ; preds = %do.cond
  %91 = load ptr, ptr %argvlen, align 8
  call void @zfree(ptr noundef %91)
  store i32 0, ptr %retval, align 4
  br label %return

if.end184:                                        ; preds = %while.body
  store i32 0, ptr %num_expected_pubsub_push, align 4
  %92 = load i32, ptr %is_subscribe, align 4
  %tobool185 = icmp ne i32 %92, 0
  br i1 %tobool185, label %if.then188, label %lor.lhs.false186

lor.lhs.false186:                                 ; preds = %if.end184
  %93 = load i32, ptr %is_unsubscribe, align 4
  %tobool187 = icmp ne i32 %93, 0
  br i1 %tobool187, label %if.then188, label %if.end192

if.then188:                                       ; preds = %lor.lhs.false186, %if.end184
  %94 = load i32, ptr %argc.addr, align 4
  %cmp189 = icmp sgt i32 %94, 1
  br i1 %cmp189, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then188
  %95 = load i32, ptr %argc.addr, align 4
  %sub = sub nsw i32 %95, 1
  br label %cond.end

cond.false:                                       ; preds = %if.then188
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ 1, %cond.false ]
  store i32 %cond, ptr %num_expected_pubsub_push, align 4
  %96 = load ptr, ptr @context, align 8
  %call191 = call ptr @redisSetPushCallback(ptr noundef %96, ptr noundef null)
  br label %if.end192

if.end192:                                        ; preds = %cond.end, %lor.lhs.false186
  %97 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 20), align 4
  %tobool193 = icmp ne i32 %97, 0
  br i1 %tobool193, label %if.then194, label %if.end196

if.then194:                                       ; preds = %if.end192
  %call195 = call i32 (ptr, ...) @printf(ptr noundef @.str.793)
  call void @slaveMode(i32 noundef 0)
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 20), align 4
  %98 = load ptr, ptr %argvlen, align 8
  call void @zfree(ptr noundef %98)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end196:                                        ; preds = %if.end192
  br label %while.body198

while.body198:                                    ; preds = %if.then235, %if.else230, %if.then228, %if.end196
  %99 = load i32, ptr %output_raw, align 4
  %call199 = call i32 @cliReadReply(i32 noundef %99)
  %cmp200 = icmp ne i32 %call199, 0
  br i1 %cmp200, label %if.then202, label %if.end203

if.then202:                                       ; preds = %while.body198
  %100 = load ptr, ptr %argvlen, align 8
  call void @zfree(ptr noundef %100)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end203:                                        ; preds = %while.body198
  %101 = load ptr, ptr @stdout, align 8
  %call204 = call i32 @fflush(ptr noundef %101)
  %102 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool205 = icmp ne i32 %102, 0
  br i1 %tobool205, label %if.then209, label %lor.lhs.false206

lor.lhs.false206:                                 ; preds = %if.end203
  %103 = load i32, ptr %num_expected_pubsub_push, align 4
  %cmp207 = icmp sgt i32 %103, 0
  br i1 %cmp207, label %if.then209, label %if.end238

if.then209:                                       ; preds = %lor.lhs.false206, %if.end203
  %104 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 52), align 8
  %call210 = call i32 @isPubsubPush(ptr noundef %104)
  %tobool211 = icmp ne i32 %call210, 0
  br i1 %tobool211, label %if.then212, label %if.else232

if.then212:                                       ; preds = %if.then209
  %105 = load i32, ptr %num_expected_pubsub_push, align 4
  %cmp213 = icmp sgt i32 %105, 0
  br i1 %cmp213, label %land.lhs.true215, label %if.else230

land.lhs.true215:                                 ; preds = %if.then212
  %106 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 52), align 8
  %element = getelementptr inbounds %struct.redisReply, ptr %106, i32 0, i32 7
  %107 = load ptr, ptr %element, align 8
  %arrayidx216 = getelementptr inbounds ptr, ptr %107, i64 0
  %108 = load ptr, ptr %arrayidx216, align 8
  %str = getelementptr inbounds %struct.redisReply, ptr %108, i32 0, i32 4
  %109 = load ptr, ptr %str, align 8
  %110 = load ptr, ptr %command, align 8
  %call217 = call i32 @strcasecmp(ptr noundef %109, ptr noundef %110) #12
  %tobool218 = icmp ne i32 %call217, 0
  br i1 %tobool218, label %if.else230, label %if.then219

if.then219:                                       ; preds = %land.lhs.true215
  %111 = load i32, ptr %is_subscribe, align 4
  %tobool220 = icmp ne i32 %111, 0
  br i1 %tobool220, label %land.lhs.true221, label %if.end224

land.lhs.true221:                                 ; preds = %if.then219
  %112 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool222 = icmp ne i32 %112, 0
  br i1 %tobool222, label %if.end224, label %if.then223

if.then223:                                       ; preds = %land.lhs.true221
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  call void @cliRefreshPrompt()
  br label %if.end224

if.end224:                                        ; preds = %if.then223, %land.lhs.true221, %if.then219
  %113 = load i32, ptr %num_expected_pubsub_push, align 4
  %dec225 = add nsw i32 %113, -1
  store i32 %dec225, ptr %num_expected_pubsub_push, align 4
  %cmp226 = icmp sgt i32 %dec225, 0
  br i1 %cmp226, label %if.then228, label %if.end229

if.then228:                                       ; preds = %if.end224
  br label %while.body198

if.end229:                                        ; preds = %if.end224
  br label %if.end231

if.else230:                                       ; preds = %land.lhs.true215, %if.then212
  br label %while.body198

if.end231:                                        ; preds = %if.end229
  br label %if.end237

if.else232:                                       ; preds = %if.then209
  %114 = load ptr, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 52), align 8
  %type = getelementptr inbounds %struct.redisReply, ptr %114, i32 0, i32 0
  %115 = load i32, ptr %type, align 8
  %cmp233 = icmp eq i32 %115, 12
  br i1 %cmp233, label %if.then235, label %if.end236

if.then235:                                       ; preds = %if.else232
  br label %while.body198

if.end236:                                        ; preds = %if.else232
  br label %if.end237

if.end237:                                        ; preds = %if.end236, %if.end231
  br label %if.end238

if.end238:                                        ; preds = %if.end237, %lor.lhs.false206
  %116 = load ptr, ptr %command, align 8
  %call239 = call i32 @strcasecmp(ptr noundef %116, ptr noundef @.str.794) #12
  %tobool240 = icmp ne i32 %call239, 0
  br i1 %tobool240, label %if.else250, label %land.lhs.true241

land.lhs.true241:                                 ; preds = %if.end238
  %117 = load i32, ptr %argc.addr, align 4
  %cmp242 = icmp eq i32 %117, 2
  br i1 %cmp242, label %land.lhs.true244, label %if.else250

land.lhs.true244:                                 ; preds = %land.lhs.true241
  %118 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp245 = icmp ne i32 %118, 6
  br i1 %cmp245, label %if.then247, label %if.else250

if.then247:                                       ; preds = %land.lhs.true244
  %119 = load ptr, ptr %argv.addr, align 8
  %arrayidx248 = getelementptr inbounds ptr, ptr %119, i64 1
  %120 = load ptr, ptr %arrayidx248, align 8
  %call249 = call i32 @atoi(ptr noundef %120) #12
  store i32 %call249, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  store i32 %call249, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  call void @cliRefreshPrompt()
  br label %if.end344

if.else250:                                       ; preds = %land.lhs.true244, %land.lhs.true241, %if.end238
  %121 = load ptr, ptr %command, align 8
  %call251 = call i32 @strcasecmp(ptr noundef %121, ptr noundef @.str.739) #12
  %tobool252 = icmp ne i32 %call251, 0
  br i1 %tobool252, label %if.else261, label %land.lhs.true253

land.lhs.true253:                                 ; preds = %if.else250
  %122 = load i32, ptr %argc.addr, align 4
  %cmp254 = icmp eq i32 %122, 2
  br i1 %cmp254, label %if.then259, label %lor.lhs.false256

lor.lhs.false256:                                 ; preds = %land.lhs.true253
  %123 = load i32, ptr %argc.addr, align 4
  %cmp257 = icmp eq i32 %123, 3
  br i1 %cmp257, label %if.then259, label %if.else261

if.then259:                                       ; preds = %lor.lhs.false256, %land.lhs.true253
  %call260 = call i32 @cliSelect()
  br label %if.end343

if.else261:                                       ; preds = %lor.lhs.false256, %if.else250
  %124 = load ptr, ptr %command, align 8
  %call262 = call i32 @strcasecmp(ptr noundef %124, ptr noundef @.str.795) #12
  %tobool263 = icmp ne i32 %call262, 0
  br i1 %tobool263, label %if.else271, label %land.lhs.true264

land.lhs.true264:                                 ; preds = %if.else261
  %125 = load i32, ptr %argc.addr, align 4
  %cmp265 = icmp eq i32 %125, 1
  br i1 %cmp265, label %land.lhs.true267, label %if.else271

land.lhs.true267:                                 ; preds = %land.lhs.true264
  %126 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp268 = icmp ne i32 %126, 6
  br i1 %cmp268, label %if.then270, label %if.else271

if.then270:                                       ; preds = %land.lhs.true267
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 60), align 8
  %127 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  store i32 %127, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 61), align 4
  call void @cliRefreshPrompt()
  br label %if.end342

if.else271:                                       ; preds = %land.lhs.true267, %land.lhs.true264, %if.else261
  %128 = load ptr, ptr %command, align 8
  %call272 = call i32 @strcasecmp(ptr noundef %128, ptr noundef @.str.796) #12
  %tobool273 = icmp ne i32 %call272, 0
  br i1 %tobool273, label %if.else287, label %land.lhs.true274

land.lhs.true274:                                 ; preds = %if.else271
  %129 = load i32, ptr %argc.addr, align 4
  %cmp275 = icmp eq i32 %129, 1
  br i1 %cmp275, label %land.lhs.true277, label %if.else287

land.lhs.true277:                                 ; preds = %land.lhs.true274
  %130 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 60), align 8
  %tobool278 = icmp ne i32 %130, 0
  br i1 %tobool278, label %if.then279, label %if.else287

if.then279:                                       ; preds = %land.lhs.true277
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 60), align 8
  %131 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp280 = icmp eq i32 %131, 6
  br i1 %cmp280, label %if.then285, label %lor.lhs.false282

lor.lhs.false282:                                 ; preds = %if.then279
  %132 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp283 = icmp eq i32 %132, 4
  br i1 %cmp283, label %if.then285, label %if.end286

if.then285:                                       ; preds = %lor.lhs.false282, %if.then279
  %133 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 61), align 4
  store i32 %133, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  store i32 %133, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  br label %if.end286

if.end286:                                        ; preds = %if.then285, %lor.lhs.false282
  call void @cliRefreshPrompt()
  br label %if.end341

if.else287:                                       ; preds = %land.lhs.true277, %land.lhs.true274, %if.else271
  %134 = load ptr, ptr %command, align 8
  %call288 = call i32 @strcasecmp(ptr noundef %134, ptr noundef @.str.797) #12
  %tobool289 = icmp ne i32 %call288, 0
  br i1 %tobool289, label %if.else297, label %land.lhs.true290

land.lhs.true290:                                 ; preds = %if.else287
  %135 = load i32, ptr %argc.addr, align 4
  %cmp291 = icmp eq i32 %135, 1
  br i1 %cmp291, label %land.lhs.true293, label %if.else297

land.lhs.true293:                                 ; preds = %land.lhs.true290
  %136 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp294 = icmp ne i32 %136, 6
  br i1 %cmp294, label %if.then296, label %if.else297

if.then296:                                       ; preds = %land.lhs.true293
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 60), align 8
  %137 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 61), align 4
  store i32 %137, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  store i32 %137, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  call void @cliRefreshPrompt()
  br label %if.end340

if.else297:                                       ; preds = %land.lhs.true293, %land.lhs.true290, %if.else287
  %138 = load ptr, ptr %command, align 8
  %call298 = call i32 @strcasecmp(ptr noundef %138, ptr noundef @.str.798) #12
  %tobool299 = icmp ne i32 %call298, 0
  br i1 %tobool299, label %if.else313, label %land.lhs.true300

land.lhs.true300:                                 ; preds = %if.else297
  %139 = load i32, ptr %argc.addr, align 4
  %cmp301 = icmp eq i32 %139, 1
  br i1 %cmp301, label %land.lhs.true303, label %if.else313

land.lhs.true303:                                 ; preds = %land.lhs.true300
  %140 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp304 = icmp ne i32 %140, 6
  br i1 %cmp304, label %if.then306, label %if.else313

if.then306:                                       ; preds = %land.lhs.true303
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 60), align 8
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 6), align 8
  store i32 0, ptr getelementptr inbounds (%struct.cliConnInfo, ptr @config, i32 0, i32 2), align 4
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 59), align 4
  %141 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool307 = icmp ne i32 %141, 0
  br i1 %tobool307, label %land.lhs.true308, label %if.end312

land.lhs.true308:                                 ; preds = %if.then306
  %142 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 42), align 4
  %tobool309 = icmp ne i32 %142, 0
  br i1 %tobool309, label %if.then310, label %if.end312

if.then310:                                       ; preds = %land.lhs.true308
  %143 = load ptr, ptr @context, align 8
  %call311 = call ptr @redisSetPushCallback(ptr noundef %143, ptr noundef @cliPushHandler)
  br label %if.end312

if.end312:                                        ; preds = %if.then310, %land.lhs.true308, %if.then306
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  call void @cliRefreshPrompt()
  br label %if.end339

if.else313:                                       ; preds = %land.lhs.true303, %land.lhs.true300, %if.else297
  %144 = load ptr, ptr %command, align 8
  %call314 = call i32 @strcasecmp(ptr noundef %144, ptr noundef @.str.750) #12
  %tobool315 = icmp ne i32 %call314, 0
  br i1 %tobool315, label %if.else326, label %if.then316

if.then316:                                       ; preds = %if.else313
  %145 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp317 = icmp eq i32 %145, 9
  br i1 %cmp317, label %if.then319, label %if.else320

if.then319:                                       ; preds = %if.then316
  store i32 1, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 59), align 4
  br label %if.end325

if.else320:                                       ; preds = %if.then316
  %146 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 51), align 8
  %cmp321 = icmp eq i32 %146, 2
  br i1 %cmp321, label %if.then323, label %if.end324

if.then323:                                       ; preds = %if.else320
  store i32 0, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 59), align 4
  br label %if.end324

if.end324:                                        ; preds = %if.then323, %if.else320
  br label %if.end325

if.end325:                                        ; preds = %if.end324, %if.then319
  br label %if.end338

if.else326:                                       ; preds = %if.else313
  %147 = load i32, ptr %is_subscribe, align 4
  %tobool327 = icmp ne i32 %147, 0
  br i1 %tobool327, label %land.lhs.true330, label %lor.lhs.false328

lor.lhs.false328:                                 ; preds = %if.else326
  %148 = load i32, ptr %is_unsubscribe, align 4
  %tobool329 = icmp ne i32 %148, 0
  br i1 %tobool329, label %land.lhs.true330, label %if.end337

land.lhs.true330:                                 ; preds = %lor.lhs.false328, %if.else326
  %149 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 10), align 8
  %tobool331 = icmp ne i32 %149, 0
  br i1 %tobool331, label %if.end337, label %if.then332

if.then332:                                       ; preds = %land.lhs.true330
  %150 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 42), align 4
  %tobool333 = icmp ne i32 %150, 0
  br i1 %tobool333, label %if.then334, label %if.end336

if.then334:                                       ; preds = %if.then332
  %151 = load ptr, ptr @context, align 8
  %call335 = call ptr @redisSetPushCallback(ptr noundef %151, ptr noundef @cliPushHandler)
  br label %if.end336

if.end336:                                        ; preds = %if.then334, %if.then332
  br label %if.end337

if.end337:                                        ; preds = %if.end336, %land.lhs.true330, %lor.lhs.false328
  br label %if.end338

if.end338:                                        ; preds = %if.end337, %if.end325
  br label %if.end339

if.end339:                                        ; preds = %if.end338, %if.end312
  br label %if.end340

if.end340:                                        ; preds = %if.end339, %if.then296
  br label %if.end341

if.end341:                                        ; preds = %if.end340, %if.end286
  br label %if.end342

if.end342:                                        ; preds = %if.end341, %if.then270
  br label %if.end343

if.end343:                                        ; preds = %if.end342, %if.then259
  br label %if.end344

if.end344:                                        ; preds = %if.end343, %if.then247
  br label %while.end

while.end:                                        ; preds = %if.end344
  %152 = load i32, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 18), align 4
  %tobool345 = icmp ne i32 %152, 0
  br i1 %tobool345, label %if.then346, label %if.end347

if.then346:                                       ; preds = %while.end
  br label %while.end354

if.end347:                                        ; preds = %while.end
  %153 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %tobool348 = icmp ne i64 %153, 0
  br i1 %tobool348, label %if.then349, label %if.end352

if.then349:                                       ; preds = %if.end347
  %154 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 5), align 8
  %conv350 = trunc i64 %154 to i32
  %call351 = call i32 @usleep(i32 noundef %conv350)
  br label %if.end352

if.end352:                                        ; preds = %if.then349, %if.end347
  %155 = load ptr, ptr @stdout, align 8
  %call353 = call i32 @fflush(ptr noundef %155)
  br label %while.cond, !llvm.loop !258

while.end354:                                     ; preds = %if.then346, %lor.end168
  %156 = load ptr, ptr %argvlen, align 8
  call void @zfree(ptr noundef %156)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end354, %if.then202, %if.then194, %do.end, %if.then
  %157 = load i32, ptr %retval, align 4
  ret i32 %157
}

; Function Attrs: nounwind uwtable
define internal void @cliOutputGenericHelp() #0 {
entry:
  %version = alloca ptr, align 8
  %call = call ptr @cliVersion()
  store ptr %call, ptr %version, align 8
  %0 = load ptr, ptr %version, align 8
  %call1 = call i32 (ptr, ...) @printf(ptr noundef @.str.761, ptr noundef %0)
  %1 = load ptr, ptr %version, align 8
  call void @hi_sdsfree(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cliOutputCommandHelp(ptr noundef %help, i32 noundef %group) #0 {
entry:
  %help.addr = alloca ptr, align 8
  %group.addr = alloca i32, align 4
  store ptr %help, ptr %help.addr, align 8
  store i32 %group, ptr %group.addr, align 4
  %0 = load ptr, ptr %help.addr, align 8
  %name = getelementptr inbounds %struct.commandDocs, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %name, align 8
  %2 = load ptr, ptr %help.addr, align 8
  %params = getelementptr inbounds %struct.commandDocs, ptr %2, i32 0, i32 7
  %3 = load ptr, ptr %params, align 8
  %call = call i32 (ptr, ...) @printf(ptr noundef @.str.762, ptr noundef %1, ptr noundef %3)
  %4 = load ptr, ptr %help.addr, align 8
  %summary = getelementptr inbounds %struct.commandDocs, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %summary, align 8
  %call1 = call i32 (ptr, ...) @printf(ptr noundef @.str.763, ptr noundef %5)
  %6 = load ptr, ptr %help.addr, align 8
  %since = getelementptr inbounds %struct.commandDocs, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %since, align 8
  %cmp = icmp ne ptr %7, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %help.addr, align 8
  %since2 = getelementptr inbounds %struct.commandDocs, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %since2, align 8
  %call3 = call i32 (ptr, ...) @printf(ptr noundef @.str.764, ptr noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load i32, ptr %group.addr, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %11 = load ptr, ptr %help.addr, align 8
  %group5 = getelementptr inbounds %struct.commandDocs, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %group5, align 8
  %call6 = call i32 (ptr, ...) @printf(ptr noundef @.str.765, ptr noundef %12)
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cliPressAnyKeyTTY() #0 {
entry:
  %mode = alloca %struct.termios, align 4
  %call = call i32 @isatty(i32 noundef 0) #15
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i32, ptr @orig_termios_saved, align 4
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.end7, label %if.then2

if.then2:                                         ; preds = %if.end
  %call3 = call i32 @tcgetattr(i32 noundef 0, ptr noundef @orig_termios) #15
  %cmp = icmp eq i32 %call3, -1
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then2
  br label %return

if.end5:                                          ; preds = %if.then2
  %call6 = call i32 @atexit(ptr noundef @cliRestoreTTY) #15
  store i32 1, ptr @orig_termios_saved, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.end5, %if.end
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %mode, ptr align 4 @orig_termios, i64 60, i1 false)
  %c_lflag = getelementptr inbounds %struct.termios, ptr %mode, i32 0, i32 3
  %1 = load i32, ptr %c_lflag, align 4
  %and = and i32 %1, -11
  store i32 %and, ptr %c_lflag, align 4
  %call8 = call i32 @tcsetattr(i32 noundef 0, i32 noundef 0, ptr noundef %mode) #15
  br label %return

return:                                           ; preds = %if.end7, %if.then4, %if.then
  ret void
}

declare i32 @redisGetReplyFromReader(ptr noundef, ptr noundef) #2

declare i32 @select(i32 noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @tcgetattr(i32 noundef, ptr noundef) #6

; Function Attrs: nounwind
declare i32 @atexit(ptr noundef) #6

declare i64 @fread(ptr noundef, i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @issueCommand(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  %0 = load i32, ptr %argc.addr, align 4
  %1 = load ptr, ptr %argv.addr, align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.config, ptr @config, i32 0, i32 4), align 8
  %call = call i32 @issueCommandRepeat(i32 noundef %0, ptr noundef %1, i64 noundef %2)
  ret i32 %call
}

; Function Attrs: nounwind
declare ptr @strncpy(ptr noundef, ptr noundef, i64 noundef) #6

declare ptr @getSdsArrayFromArgv(i32 noundef, ptr noundef, i32 noundef) #2

declare ptr @hi_sds_realloc(ptr noundef, i64 noundef) #2

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #6 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #9 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #11 = { nocallback nofree nosync nounwind willreturn }
attributes #12 = { nounwind willreturn memory(read) }
attributes #13 = { allocsize(1) }
attributes #14 = { allocsize(0) }
attributes #15 = { nounwind }
attributes #16 = { nounwind willreturn memory(none) }
attributes #17 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
!95 = distinct !{!95, !6}
!96 = distinct !{!96, !6}
!97 = distinct !{!97, !6}
!98 = distinct !{!98, !6}
!99 = distinct !{!99, !6}
!100 = distinct !{!100, !6}
!101 = distinct !{!101, !6}
!102 = distinct !{!102, !6}
!103 = distinct !{!103, !6}
!104 = distinct !{!104, !6}
!105 = distinct !{!105, !6}
!106 = distinct !{!106, !6}
!107 = distinct !{!107, !6}
!108 = distinct !{!108, !6}
!109 = distinct !{!109, !6}
!110 = distinct !{!110, !6}
!111 = distinct !{!111, !6}
!112 = distinct !{!112, !6}
!113 = distinct !{!113, !6}
!114 = distinct !{!114, !6}
!115 = distinct !{!115, !6}
!116 = distinct !{!116, !6}
!117 = distinct !{!117, !6}
!118 = distinct !{!118, !6}
!119 = distinct !{!119, !6}
!120 = distinct !{!120, !6}
!121 = distinct !{!121, !6}
!122 = distinct !{!122, !6}
!123 = distinct !{!123, !6}
!124 = distinct !{!124, !6}
!125 = distinct !{!125, !6}
!126 = distinct !{!126, !6}
!127 = distinct !{!127, !6}
!128 = distinct !{!128, !6}
!129 = distinct !{!129, !6}
!130 = distinct !{!130, !6}
!131 = distinct !{!131, !6}
!132 = distinct !{!132, !6}
!133 = distinct !{!133, !6}
!134 = distinct !{!134, !6}
!135 = distinct !{!135, !6}
!136 = distinct !{!136, !6}
!137 = distinct !{!137, !6}
!138 = distinct !{!138, !6}
!139 = distinct !{!139, !6}
!140 = distinct !{!140, !6}
!141 = distinct !{!141, !6}
!142 = distinct !{!142, !6}
!143 = distinct !{!143, !6}
!144 = distinct !{!144, !6}
!145 = distinct !{!145, !6}
!146 = distinct !{!146, !6}
!147 = distinct !{!147, !6}
!148 = distinct !{!148, !6}
!149 = distinct !{!149, !6}
!150 = distinct !{!150, !6}
!151 = distinct !{!151, !6}
!152 = distinct !{!152, !6}
!153 = distinct !{!153, !6}
!154 = distinct !{!154, !6}
!155 = distinct !{!155, !6}
!156 = distinct !{!156, !6}
!157 = distinct !{!157, !6}
!158 = distinct !{!158, !6}
!159 = distinct !{!159, !6}
!160 = distinct !{!160, !6}
!161 = distinct !{!161, !6}
!162 = distinct !{!162, !6}
!163 = distinct !{!163, !6}
!164 = distinct !{!164, !6}
!165 = distinct !{!165, !6}
!166 = distinct !{!166, !6}
!167 = distinct !{!167, !6}
!168 = distinct !{!168, !6}
!169 = distinct !{!169, !6}
!170 = distinct !{!170, !6}
!171 = distinct !{!171, !6}
!172 = distinct !{!172, !6}
!173 = distinct !{!173, !6}
!174 = distinct !{!174, !6}
!175 = distinct !{!175, !6}
!176 = distinct !{!176, !6}
!177 = distinct !{!177, !6}
!178 = distinct !{!178, !6}
!179 = distinct !{!179, !6}
!180 = distinct !{!180, !6}
!181 = distinct !{!181, !6}
!182 = distinct !{!182, !6}
!183 = distinct !{!183, !6}
!184 = distinct !{!184, !6}
!185 = distinct !{!185, !6}
!186 = distinct !{!186, !6}
!187 = distinct !{!187, !6}
!188 = distinct !{!188, !6}
!189 = distinct !{!189, !6}
!190 = distinct !{!190, !6}
!191 = distinct !{!191, !6}
!192 = distinct !{!192, !6}
!193 = distinct !{!193, !6}
!194 = distinct !{!194, !6}
!195 = distinct !{!195, !6}
!196 = distinct !{!196, !6}
!197 = distinct !{!197, !6}
!198 = distinct !{!198, !6}
!199 = distinct !{!199, !6}
!200 = distinct !{!200, !6}
!201 = distinct !{!201, !6}
!202 = distinct !{!202, !6}
!203 = distinct !{!203, !6}
!204 = distinct !{!204, !6}
!205 = distinct !{!205, !6}
!206 = distinct !{!206, !6}
!207 = distinct !{!207, !6}
!208 = distinct !{!208, !6}
!209 = distinct !{!209, !6}
!210 = distinct !{!210, !6}
!211 = distinct !{!211, !6}
!212 = distinct !{!212, !6}
!213 = distinct !{!213, !6}
!214 = distinct !{!214, !6}
!215 = distinct !{!215, !6}
!216 = distinct !{!216, !6}
!217 = distinct !{!217, !6}
!218 = distinct !{!218, !6}
!219 = distinct !{!219, !6}
!220 = distinct !{!220, !6}
!221 = distinct !{!221, !6}
!222 = distinct !{!222, !6}
!223 = distinct !{!223, !6}
!224 = distinct !{!224, !6}
!225 = distinct !{!225, !6}
!226 = distinct !{!226, !6}
!227 = distinct !{!227, !6}
!228 = distinct !{!228, !6}
!229 = distinct !{!229, !6}
!230 = distinct !{!230, !6}
!231 = distinct !{!231, !6}
!232 = distinct !{!232, !6}
!233 = distinct !{!233, !6}
!234 = distinct !{!234, !6}
!235 = distinct !{!235, !6}
!236 = distinct !{!236, !6}
!237 = distinct !{!237, !6}
!238 = distinct !{!238, !6}
!239 = distinct !{!239, !6}
!240 = distinct !{!240, !6}
!241 = distinct !{!241, !6}
!242 = distinct !{!242, !6}
!243 = distinct !{!243, !6}
!244 = distinct !{!244, !6}
!245 = distinct !{!245, !6}
!246 = distinct !{!246, !6}
!247 = distinct !{!247, !6}
!248 = distinct !{!248, !6}
!249 = distinct !{!249, !6}
!250 = distinct !{!250, !6}
!251 = distinct !{!251, !6}
!252 = distinct !{!252, !6}
!253 = distinct !{!253, !6}
!254 = distinct !{!254, !6}
!255 = distinct !{!255, !6}
!256 = distinct !{!256, !6}
!257 = distinct !{!257, !6}
!258 = distinct !{!258, !6}
