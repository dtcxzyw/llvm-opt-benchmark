target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.redisServer = type { i32, i64, ptr, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i32, i64, i32, i32, i32, ptr, ptr, i32, i32, i64, ptr, ptr, ptr, ptr, [2 x i32], i32, i32, i32, i32, i32, [16 x ptr], i32, ptr, ptr, i32, [8 x %struct.connListener], i32, %struct.connListener, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, ptr, i32, ptr, [3 x %struct.pause_event], [256 x i8], ptr, i64, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, i64, i64, i64, i64, i64, ptr, i64, i64, i64, %struct.malloc_stats, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, double, [4 x i64], i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [7 x %struct.anon], i64, i64, i64, i64, i64, i64, [4 x %struct.durationStats], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i32, ptr, [3 x %struct.clientBufferLimitsConfig], i32, i32, ptr, i32, i32, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, ptr, i32, i32, i64, i64, i64, i64, i64, i32, i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, ptr, i32, i64, i64, i64, i64, ptr, i32, ptr, i32, i32, i32, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, ptr, i32, i32, ptr, i32, i32, i32, [2 x i32], i32, %struct.redisOpArray, i32, ptr, i32, ptr, i32, i32, i32, i32, i32, i32, i32, [41 x i8], [41 x i8], i64, i64, i64, i64, i32, i32, ptr, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, ptr, ptr, i32, i32, ptr, ptr, i32, i32, i64, i64, i64, ptr, i32, ptr, i64, i32, i32, i32, i64, i32, i32, i32, i32, ptr, i32, i32, [41 x i8], i64, i32, ptr, i32, i32, i64, i64, i32, i32, i32, i32, i32, i64, [3 x i32], i32, i32, i32, [9 x i32], ptr, ptr, i32, i64, ptr, ptr, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i32, i64, i64, i64, i64, i64, ptr, ptr, i32, ptr, i32, i32, i32, i64, i64, ptr, ptr, i32, i32, i32, i32, i32, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i64, i32, i64, i32, i32, i32, i32, i32, i32, i32, i64, ptr, ptr, i64, ptr, i32, %struct.aclInfo, i32, i64, i32, i32, i32, %struct.redisTLSContextConfig, ptr, ptr, ptr, ptr, ptr, i64, i32, ptr, i32, i32, i32, i64, i32, ptr }
%struct.connListener = type { [16 x i32], i32, ptr, i32, i32, ptr, ptr }
%struct.pause_event = type { i32, i64 }
%struct.malloc_stats = type { i64, i64, i64, i64, i64 }
%struct.anon = type { i64, i64, [16 x i64], i32 }
%struct.durationStats = type { i64, i64, i64 }
%struct.clientBufferLimitsConfig = type { i64, i64, i64 }
%struct.redisOpArray = type { ptr, i32, i32 }
%struct.aclInfo = type { i64, i64, i64, i64 }
%struct.redisTLSContextConfig = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32 }
%struct.dictType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i8 }
%struct.sharedObjectsStruct = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [4 x ptr], [4 x ptr], [4 x ptr], [4 x ptr], ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr], [10000 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], [32 x ptr], ptr, ptr }
%struct.redisCommand = type { ptr, ptr, ptr, ptr, i32, ptr, ptr, i32, ptr, i32, ptr, i32, ptr, i32, i64, i64, ptr, i32, ptr, i32, ptr, ptr, i64, i64, i64, i64, i32, ptr, ptr, %struct.keySpec, ptr, ptr, ptr }
%struct.keySpec = type { ptr, i64, i32, %union.anon, i32, %union.anon.2 }
%union.anon = type { %struct.anon.1 }
%struct.anon.1 = type { ptr, i32 }
%union.anon.2 = type { %struct.anon.3 }
%struct.anon.3 = type { i32, i32, i32 }
%struct.replyFlagNames = type { i64, ptr }
%struct.utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.rdbSaveInfo = type { i32, i32, [41 x i8], i64 }
%struct.timeval = type { i64, i64 }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, ptr }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.sdshdr8 = type { i8, i8, i8, [0 x i8] }
%struct.sdshdr16 = type <{ i16, i16, i8, [0 x i8] }>
%struct.sdshdr32 = type <{ i32, i32, i8, [0 x i8] }>
%struct.sdshdr64 = type <{ i64, i64, i8, [0 x i8] }>
%struct.redisObject = type { i32, i32, ptr }
%struct.dict = type { ptr, [2 x ptr], [2 x i64], i64, i16, [2 x i8], [0 x ptr] }
%struct.list = type { ptr, ptr, ptr, ptr, ptr, i64 }
%struct.dbDictMetadata = type { ptr }
%struct.redisDb = type { ptr, ptr, ptr, ptr, ptr, ptr, i32, i64, i64, ptr, i32, [2 x %struct.dbDictState] }
%struct.dbDictState = type { i32, i32, i64, i64, ptr }
%struct.listNode = type { ptr, ptr, ptr }
%struct.client = type { i64, i64, ptr, i32, ptr, ptr, ptr, ptr, ptr, i64, i64, i32, ptr, i32, i32, ptr, i64, ptr, ptr, ptr, ptr, i32, i32, i64, ptr, i64, ptr, i64, i64, i64, i32, ptr, i64, i64, i32, i32, i32, i32, i64, i64, ptr, i64, i64, i64, i64, i64, i64, i64, i64, [41 x i8], i32, ptr, i32, i32, %struct.multiState, %struct.blockingState, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, i32, ptr, ptr, ptr, i64, %struct.listNode, i64, i64, i32, i64, ptr }
%struct.multiState = type { ptr, i32, i32, i32, i64, i32 }
%struct.blockingState = type { i32, i64, i32, ptr, i32, i32, i64, ptr, ptr }
%struct.clientMemUsageBucket = type { ptr, i64 }
%struct.RedisModuleCronLoopInfo = type { i64, i32 }
%struct.saveparam = type { i64, i32 }
%struct.listIter = type { ptr, i32 }
%struct.rlimit = type { i64, i64 }
%struct.sigaction = type { %union.anon.21, %struct.__sigset_t, i32, ptr }
%union.anon.21 = type { ptr }
%struct.__sigset_t = type { [16 x i64] }
%struct.ConnectionType = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.anon.0 = type { i32 }
%struct.redisOp = type { ptr, i32, i32, i32 }
%struct.redisError = type { i64 }
%struct.redisCommandArg = type { ptr, i32, i32, ptr, ptr, ptr, i32, ptr, i32, ptr, ptr }
%struct.commandHistory = type { ptr, ptr }
%struct.anon.4 = type { i32, i32, i32 }
%struct.getKeysResult = type { [256 x %struct.keyReference], ptr, i32, i32 }
%struct.keyReference = type { i32, i32 }
%struct.commandListFilter = type { i32, ptr, %struct.anon.5 }
%struct.anon.5 = type { i32, %union.anon.6 }
%union.anon.6 = type { i64 }
%struct.rusage = type { %struct.timeval, %struct.timeval, %union.anon.7, %union.anon.8, %union.anon.9, %union.anon.10, %union.anon.11, %union.anon.12, %union.anon.13, %union.anon.14, %union.anon.15, %union.anon.16, %union.anon.17, %union.anon.18, %union.anon.19, %union.anon.20 }
%union.anon.7 = type { i64 }
%union.anon.8 = type { i64 }
%union.anon.9 = type { i64 }
%union.anon.10 = type { i64 }
%union.anon.11 = type { i64 }
%union.anon.12 = type { i64 }
%union.anon.13 = type { i64 }
%union.anon.14 = type { i64 }
%union.anon.15 = type { i64 }
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.18 = type { i64 }
%union.anon.19 = type { i64 }
%union.anon.20 = type { i64 }
%struct.raxIterator = type { i32, ptr, ptr, ptr, i64, i64, [128 x i8], ptr, %struct.raxStack, ptr }
%struct.raxStack = type { ptr, i64, i64, [32 x ptr], i32 }
%struct.redisMemOverhead = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, float, float, float, i64, float, i64, float, i64, float, i64, i64, ptr }
%struct.replBacklog = type { ptr, i64, ptr, i64, i64 }
%struct.replBufBlock = type { i32, i64, i64, i64, i64, [0 x i8] }
%struct.clientReplyBlock = type { i64, i64, [0 x i8] }
%struct.connection = type { ptr, i32, i32, i32, i16, i16, i16, ptr, ptr, ptr, ptr }

@__const.serverLogRaw.syslogLevelMap = private unnamed_addr constant [4 x i32] [i32 7, i32 6, i32 5, i32 4], align 16
@.str = private unnamed_addr constant [5 x i8] c".-*#\00", align 1
@server = dso_local global %struct.redisServer zeroinitializer, align 8
@stdout = external global ptr, align 8
@.str.1 = private unnamed_addr constant [2 x i8] c"a\00", align 1
@.str.2 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.3 = private unnamed_addr constant [19 x i8] c"%d %b %Y %H:%M:%S.\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"%03d\00", align 1
@.str.5 = private unnamed_addr constant [16 x i8] c"%d:%c %s %c %s\0A\00", align 1
@.str.6 = private unnamed_addr constant [18 x i8] c":signal-handler (\00", align 1
@.str.7 = private unnamed_addr constant [3 x i8] c") \00", align 1
@.str.8 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.9 = private unnamed_addr constant [9 x i8] c"server.c\00", align 1
@.str.10 = private unnamed_addr constant [24 x i8] c"Unknown string encoding\00", align 1
@objectKeyPointerValueDictType = dso_local global %struct.dictType { ptr @dictEncObjHash, ptr null, ptr null, ptr @dictEncObjKeyCompare, ptr @dictObjectDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@objectKeyHeapPointerValueDictType = dso_local global %struct.dictType { ptr @dictEncObjHash, ptr null, ptr null, ptr @dictEncObjKeyCompare, ptr @dictObjectDestructor, ptr @dictVanillaFree, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@setDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 3 }, align 8
@zsetDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@dbDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr @dictObjectDestructor, ptr @dictExpandAllowed, ptr @dbDictRehashingStarted, ptr @dbDictRehashingCompleted, ptr @dbDictMetadataSize, i8 0 }, align 8
@dbExpiresDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr null, ptr null, ptr @dictExpandAllowed, ptr @dbExpiresRehashingStarted, ptr @dbExpiresRehashingCompleted, ptr @dbDictMetadataSize, i8 0 }, align 8
@commandTableDictType = dso_local global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@hashDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@sdsReplyDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@keylistDictType = dso_local global %struct.dictType { ptr @dictObjHash, ptr null, ptr null, ptr @dictObjKeyCompare, ptr @dictObjectDestructor, ptr @dictListDestructor, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@modulesDictType = dso_local global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@migrateCacheDictType = dso_local global %struct.dictType { ptr @dictSdsHash, ptr null, ptr null, ptr @dictSdsKeyCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@stringSetDictType = dso_local global %struct.dictType { ptr @dictCStrCaseHash, ptr null, ptr null, ptr @dictCStrKeyCaseCompare, ptr @dictSdsDestructor, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@externalStringType = dso_local global %struct.dictType { ptr @dictCStrCaseHash, ptr null, ptr null, ptr @dictCStrKeyCaseCompare, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@sdsHashDictType = dso_local global %struct.dictType { ptr @dictSdsCaseHash, ptr null, ptr null, ptr @dictSdsKeyCaseCompare, ptr @dictSdsDestructor, ptr @dictVanillaFree, ptr null, ptr null, ptr null, ptr null, i8 0 }, align 8
@.str.11 = private unnamed_addr constant [27 x i8] c"Rehashing list length: %lu\00", align 1
@.str.12 = private unnamed_addr constant [4 x i8] c"RDB\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"AOF\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"LDB\00", align 1
@.str.15 = private unnamed_addr constant [7 x i8] c"MODULE\00", align 1
@.str.16 = private unnamed_addr constant [8 x i8] c"Unknown\00", align 1
@.str.17 = private unnamed_addr constant [61 x i8] c"(!new_buffer_size) || (new_buffer_size >= (size_t)c->bufpos)\00", align 1
@ClientsPeakMemInput = dso_local global [8 x i64] zeroinitializer, align 16
@ClientsPeakMemOutput = dso_local global [8 x i64] zeroinitializer, align 16
@io_threads_op = external global i32, align 4
@.str.18 = private unnamed_addr constant [36 x i8] c"io_threads_op == IO_THREADS_OP_IDLE\00", align 1
@databasesCron.resize_db = internal global i32 0, align 4
@.str.19 = private unnamed_addr constant [64 x i8] c"waitpid() returned an error: %s. child_type: %s, child_pid = %d\00", align 1
@.str.20 = private unnamed_addr constant [39 x i8] c"Unknown child type %d for child pid %d\00", align 1
@.str.21 = private unnamed_addr constant [48 x i8] c"Warning, detected child with unmatched pid: %ld\00", align 1
@getMonotonicUs = external global ptr, align 8
@.str.22 = private unnamed_addr constant [51 x i8] c"DB %d: %lld keys (%lld volatile) in %lld slots HT.\00", align 1
@.str.23 = private unnamed_addr constant [55 x i8] c"%lu clients connected (%lu replicas), %zu bytes in use\00", align 1
@.str.24 = private unnamed_addr constant [36 x i8] c"%d changes in %d seconds. Saving...\00", align 1
@.str.25 = private unnamed_addr constant [53 x i8] c"Starting automatic rewriting of AOF on %lld%% growth\00", align 1
@.str.26 = private unnamed_addr constant [25 x i8] c"server.blocked_last_cron\00", align 1
@.str.27 = private unnamed_addr constant [19 x i8] c"while-blocked-cron\00", align 1
@.str.28 = private unnamed_addr constant [96 x i8] c"SIGTERM received but errors trying to shut down the server, check the logs for more information\00", align 1
@ProcessingEventsWhileBlocked = external global i32, align 4
@.str.29 = private unnamed_addr constant [46 x i8] c"listLength(server.tracking_pending_keys) == 0\00", align 1
@.str.30 = private unnamed_addr constant [46 x i8] c"listLength(server.pending_push_messages) == 0\00", align 1
@.str.31 = private unnamed_addr constant [19 x i8] c"module-acquire-GIL\00", align 1
@.str.32 = private unnamed_addr constant [6 x i8] c"+OK\0D\0A\00", align 1
@shared = dso_local global %struct.sharedObjectsStruct zeroinitializer, align 8
@.str.33 = private unnamed_addr constant [7 x i8] c"$0\0D\0A\0D\0A\00", align 1
@.str.34 = private unnamed_addr constant [5 x i8] c":0\0D\0A\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c":1\0D\0A\00", align 1
@.str.36 = private unnamed_addr constant [5 x i8] c"*0\0D\0A\00", align 1
@.str.37 = private unnamed_addr constant [8 x i8] c"+PONG\0D\0A\00", align 1
@.str.38 = private unnamed_addr constant [10 x i8] c"+QUEUED\0D\0A\00", align 1
@.str.39 = private unnamed_addr constant [16 x i8] c"*2\0D\0A$1\0D\0A0\0D\0A*0\0D\0A\00", align 1
@.str.40 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.41 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.42 = private unnamed_addr constant [69 x i8] c"-WRONGTYPE Operation against a key holding the wrong kind of value\0D\0A\00", align 1
@.str.43 = private unnamed_addr constant [7 x i8] c"-ERR\0D\0A\00", align 1
@.str.44 = private unnamed_addr constant [19 x i8] c"-ERR no such key\0D\0A\00", align 1
@.str.45 = private unnamed_addr constant [20 x i8] c"-ERR syntax error\0D\0A\00", align 1
@.str.46 = private unnamed_addr constant [51 x i8] c"-ERR source and destination objects are the same\0D\0A\00", align 1
@.str.47 = private unnamed_addr constant [26 x i8] c"-ERR index out of range\0D\0A\00", align 1
@.str.48 = private unnamed_addr constant [49 x i8] c"-NOSCRIPT No matching script. Please use EVAL.\0D\0A\00", align 1
@.str.49 = private unnamed_addr constant [50 x i8] c"-LOADING Redis is loading the dataset in memory\0D\0A\00", align 1
@.str.50 = private unnamed_addr constant [90 x i8] c"-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\0D\0A\00", align 1
@.str.51 = private unnamed_addr constant [92 x i8] c"-BUSY Redis is busy running a script. You can only call FUNCTION KILL or SHUTDOWN NOSAVE.\0D\0A\00", align 1
@.str.52 = private unnamed_addr constant [48 x i8] c"-BUSY Redis is busy running a module command.\0D\0A\00", align 1
@.str.53 = private unnamed_addr constant [84 x i8] c"-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\0D\0A\00", align 1
@.str.54 = private unnamed_addr constant [344 x i8] c"-MISCONF Redis is configured to save RDB snapshots, but it's currently unable to persist to disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\0D\0A\00", align 1
@.str.55 = private unnamed_addr constant [57 x i8] c"-READONLY You can't write against a read only replica.\0D\0A\00", align 1
@.str.56 = private unnamed_addr constant [35 x i8] c"-NOAUTH Authentication required.\0D\0A\00", align 1
@.str.57 = private unnamed_addr constant [59 x i8] c"-OOM command not allowed when used memory > 'maxmemory'.\0D\0A\00", align 1
@.str.58 = private unnamed_addr constant [63 x i8] c"-EXECABORT Transaction discarded because of previous errors.\0D\0A\00", align 1
@.str.59 = private unnamed_addr constant [49 x i8] c"-NOREPLICAS Not enough good replicas to write.\0D\0A\00", align 1
@.str.60 = private unnamed_addr constant [43 x i8] c"-BUSYKEY Target key name already exists.\0D\0A\00", align 1
@.str.61 = private unnamed_addr constant [6 x i8] c"$-1\0D\0A\00", align 1
@.str.62 = private unnamed_addr constant [4 x i8] c"_\0D\0A\00", align 1
@.str.63 = private unnamed_addr constant [6 x i8] c"*-1\0D\0A\00", align 1
@.str.64 = private unnamed_addr constant [5 x i8] c"%0\0D\0A\00", align 1
@.str.65 = private unnamed_addr constant [5 x i8] c"~0\0D\0A\00", align 1
@.str.66 = private unnamed_addr constant [26 x i8] c"*2\0D\0A$6\0D\0ASELECT\0D\0A$%d\0D\0A%s\0D\0A\00", align 1
@.str.67 = private unnamed_addr constant [14 x i8] c"$7\0D\0Amessage\0D\0A\00", align 1
@.str.68 = private unnamed_addr constant [15 x i8] c"$8\0D\0Apmessage\0D\0A\00", align 1
@.str.69 = private unnamed_addr constant [16 x i8] c"$9\0D\0Asubscribe\0D\0A\00", align 1
@.str.70 = private unnamed_addr constant [19 x i8] c"$11\0D\0Aunsubscribe\0D\0A\00", align 1
@.str.71 = private unnamed_addr constant [18 x i8] c"$10\0D\0Assubscribe\0D\0A\00", align 1
@.str.72 = private unnamed_addr constant [20 x i8] c"$12\0D\0Asunsubscribe\0D\0A\00", align 1
@.str.73 = private unnamed_addr constant [15 x i8] c"$8\0D\0Asmessage\0D\0A\00", align 1
@.str.74 = private unnamed_addr constant [18 x i8] c"$10\0D\0Apsubscribe\0D\0A\00", align 1
@.str.75 = private unnamed_addr constant [20 x i8] c"$12\0D\0Apunsubscribe\0D\0A\00", align 1
@.str.76 = private unnamed_addr constant [4 x i8] c"DEL\00", align 1
@.str.77 = private unnamed_addr constant [7 x i8] c"UNLINK\00", align 1
@.str.78 = private unnamed_addr constant [5 x i8] c"RPOP\00", align 1
@.str.79 = private unnamed_addr constant [5 x i8] c"LPOP\00", align 1
@.str.80 = private unnamed_addr constant [6 x i8] c"LPUSH\00", align 1
@.str.81 = private unnamed_addr constant [10 x i8] c"RPOPLPUSH\00", align 1
@.str.82 = private unnamed_addr constant [6 x i8] c"LMOVE\00", align 1
@.str.83 = private unnamed_addr constant [7 x i8] c"BLMOVE\00", align 1
@.str.84 = private unnamed_addr constant [8 x i8] c"ZPOPMIN\00", align 1
@.str.85 = private unnamed_addr constant [8 x i8] c"ZPOPMAX\00", align 1
@.str.86 = private unnamed_addr constant [6 x i8] c"MULTI\00", align 1
@.str.87 = private unnamed_addr constant [5 x i8] c"EXEC\00", align 1
@.str.88 = private unnamed_addr constant [5 x i8] c"HSET\00", align 1
@.str.89 = private unnamed_addr constant [5 x i8] c"SREM\00", align 1
@.str.90 = private unnamed_addr constant [7 x i8] c"XGROUP\00", align 1
@.str.91 = private unnamed_addr constant [7 x i8] c"XCLAIM\00", align 1
@.str.92 = private unnamed_addr constant [7 x i8] c"SCRIPT\00", align 1
@.str.93 = private unnamed_addr constant [9 x i8] c"REPLCONF\00", align 1
@.str.94 = private unnamed_addr constant [10 x i8] c"PEXPIREAT\00", align 1
@.str.95 = private unnamed_addr constant [8 x i8] c"PEXPIRE\00", align 1
@.str.96 = private unnamed_addr constant [8 x i8] c"PERSIST\00", align 1
@.str.97 = private unnamed_addr constant [4 x i8] c"SET\00", align 1
@.str.98 = private unnamed_addr constant [5 x i8] c"EVAL\00", align 1
@.str.99 = private unnamed_addr constant [5 x i8] c"left\00", align 1
@.str.100 = private unnamed_addr constant [6 x i8] c"right\00", align 1
@.str.101 = private unnamed_addr constant [5 x i8] c"PXAT\00", align 1
@.str.102 = private unnamed_addr constant [5 x i8] c"TIME\00", align 1
@.str.103 = private unnamed_addr constant [11 x i8] c"RETRYCOUNT\00", align 1
@.str.104 = private unnamed_addr constant [6 x i8] c"FORCE\00", align 1
@.str.105 = private unnamed_addr constant [7 x i8] c"JUSTID\00", align 1
@.str.106 = private unnamed_addr constant [12 x i8] c"ENTRIESREAD\00", align 1
@.str.107 = private unnamed_addr constant [7 x i8] c"LASTID\00", align 1
@.str.108 = private unnamed_addr constant [8 x i8] c"default\00", align 1
@.str.109 = private unnamed_addr constant [5 x i8] c"ping\00", align 1
@.str.110 = private unnamed_addr constant [6 x i8] c"SETID\00", align 1
@.str.111 = private unnamed_addr constant [8 x i8] c"KEEPTTL\00", align 1
@.str.112 = private unnamed_addr constant [7 x i8] c"ABSTTL\00", align 1
@.str.113 = private unnamed_addr constant [5 x i8] c"LOAD\00", align 1
@.str.114 = private unnamed_addr constant [15 x i8] c"CREATECONSUMER\00", align 1
@.str.115 = private unnamed_addr constant [7 x i8] c"GETACK\00", align 1
@.str.116 = private unnamed_addr constant [2 x i8] c"*\00", align 1
@.str.117 = private unnamed_addr constant [2 x i8] c"=\00", align 1
@.str.118 = private unnamed_addr constant [11 x i8] c"(redacted)\00", align 1
@.str.119 = private unnamed_addr constant [6 x i8] c"*%d\0D\0A\00", align 1
@.str.120 = private unnamed_addr constant [6 x i8] c"$%d\0D\0A\00", align 1
@.str.121 = private unnamed_addr constant [7 x i8] c"%%%d\0D\0A\00", align 1
@.str.122 = private unnamed_addr constant [6 x i8] c"~%d\0D\0A\00", align 1
@.str.123 = private unnamed_addr constant [10 x i8] c"minstring\00", align 1
@.str.124 = private unnamed_addr constant [10 x i8] c"maxstring\00", align 1
@.str.125 = private unnamed_addr constant [5 x i8] c"-::*\00", align 1
@__const.initServerConfig.default_bindaddr = private unnamed_addr constant [2 x ptr] [ptr @.str.116, ptr @.str.125], align 16
@clientBufferLimitsDefaults = external global [3 x %struct.clientBufferLimitsConfig], align 16
@configOOMScoreAdjValuesDefaults = external global [3 x i32], align 4
@R_Zero = dso_local global double 0.000000e+00, align 8
@R_PosInf = dso_local global double 0.000000e+00, align 8
@R_NegInf = dso_local global double 0.000000e+00, align 8
@R_Nan = dso_local global double 0.000000e+00, align 8
@.str.126 = private unnamed_addr constant [61 x i8] c"Can't restart: this process has no permissions to execute %s\00", align 1
@.str.127 = private unnamed_addr constant [56 x i8] c"Can't restart: configuration rewrite process failed: %s\00", align 1
@.str.128 = private unnamed_addr constant [44 x i8] c"Can't restart: error preparing for shutdown\00", align 1
@environ = external global ptr, align 8
@.str.129 = private unnamed_addr constant [55 x i8] c"process_class >= 0 && process_class < CONFIG_OOM_COUNT\00", align 1
@setOOMScoreAdj.oom_score_adjusted_by_redis = internal global i32 0, align 4
@setOOMScoreAdj.oom_score_adj_base = internal global i32 0, align 4
@.str.130 = private unnamed_addr constant [25 x i8] c"/proc/self/oom_score_adj\00", align 1
@.str.131 = private unnamed_addr constant [33 x i8] c"Unable to read oom_score_adj: %s\00", align 1
@.str.132 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.133 = private unnamed_addr constant [34 x i8] c"Unable to write oom_score_adj: %s\00", align 1
@.str.134 = private unnamed_addr constant [117 x i8] c"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.\00", align 1
@.str.135 = private unnamed_addr constant [136 x i8] c"Your current 'ulimit -n' of %llu is not enough for the server to start. Please increase your open file limit to at least %llu. Exiting.\00", align 1
@.str.136 = private unnamed_addr constant [77 x i8] c"You requested maxclients of %d requiring at least %llu max file descriptors.\00", align 1
@.str.137 = private unnamed_addr constant [69 x i8] c"Server can't set maximum open files to %llu because of OS error: %s.\00", align 1
@.str.138 = private unnamed_addr constant [152 x i8] c"Current maximum open files is %llu. maxclients has been reduced to %d to compensate for low ulimit. If you need higher maxclients increase 'ulimit -n'.\00", align 1
@.str.139 = private unnamed_addr constant [80 x i8] c"Increased maximum number of open files to %llu (it was originally set to %llu).\00", align 1
@.str.140 = private unnamed_addr constant [29 x i8] c"/proc/sys/net/core/somaxconn\00", align 1
@.str.141 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.142 = private unnamed_addr constant [128 x i8] c"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.\00", align 1
@.str.143 = private unnamed_addr constant [64 x i8] c"Warning: Could not create server TCP listening socket %s:%d: %s\00", align 1
@.str.144 = private unnamed_addr constant [52 x i8] c"Failed to configure LOCALE for invalid locale name.\00", align 1
@.str.145 = private unnamed_addr constant [20 x i8] c"monotonic clock: %s\00", align 1
@.str.146 = private unnamed_addr constant [52 x i8] c"Failed creating the event loop. Error message: '%s'\00", align 1
@.str.147 = private unnamed_addr constant [32 x i8] c"Can't create event loop timers.\00", align 1
@.str.148 = private unnamed_addr constant [58 x i8] c"Error registering the readable event for the module pipe.\00", align 1
@.str.149 = private unnamed_addr constant [118 x i8] c"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.\00", align 1
@.str.150 = private unnamed_addr constant [4 x i8] c"tcp\00", align 1
@.str.151 = private unnamed_addr constant [41 x i8] c"Failed finding connection listener of %s\00", align 1
@.str.152 = private unnamed_addr constant [28 x i8] c"Failed finding TLS support.\00", align 1
@.str.153 = private unnamed_addr constant [51 x i8] c"Failed to configure TLS. Check logs for more info.\00", align 1
@.str.154 = private unnamed_addr constant [4 x i8] c"tls\00", align 1
@.str.155 = private unnamed_addr constant [5 x i8] c"unix\00", align 1
@.str.156 = private unnamed_addr constant [44 x i8] c"Failed listening on port %u (%s), aborting.\00", align 1
@.str.157 = private unnamed_addr constant [57 x i8] c"Unrecoverable error creating %s listener accept handler.\00", align 1
@.str.158 = private unnamed_addr constant [44 x i8] c"Configured to not listen anywhere, exiting.\00", align 1
@.str.159 = private unnamed_addr constant [14 x i8] c"firstkey != 0\00", align 1
@.str.160 = private unnamed_addr constant [13 x i8] c"lastkey != 0\00", align 1
@.str.161 = private unnamed_addr constant [6 x i8] c"%s|%s\00", align 1
@.str.162 = private unnamed_addr constant [80 x i8] c"dictAdd(parent->subcommands_dict, sdsnew(declared_name), subcommand) == DICT_OK\00", align 1
@redisCommandTable = external global [0 x %struct.redisCommand], align 8
@.str.163 = private unnamed_addr constant [41 x i8] c"retval1 == DICT_OK && retval2 == DICT_OK\00", align 1
@.str.164 = private unnamed_addr constant [12 x i8] c"!oa->numops\00", align 1
@.str.165 = private unnamed_addr constant [2 x i8] c"|\00", align 1
@.str.166 = private unnamed_addr constant [9 x i8] c"argc > 0\00", align 1
@.str.167 = private unnamed_addr constant [48 x i8] c"c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)\00", align 1
@incrCommandStatsOnError.prev_err_count = internal global i64 0, align 8
@.str.168 = private unnamed_addr constant [13 x i8] c"fast-command\00", align 1
@.str.169 = private unnamed_addr constant [8 x i8] c"command\00", align 1
@.str.170 = private unnamed_addr constant [3 x i8] c"\0D\0A\00", align 1
@.str.171 = private unnamed_addr constant [3 x i8] c"  \00", align 1
@.str.172 = private unnamed_addr constant [42 x i8] c"unknown subcommand '%.128s'. Try %s HELP.\00", align 1
@.str.173 = private unnamed_addr constant [8 x i8] c"'%.*s' \00", align 1
@.str.174 = private unnamed_addr constant [55 x i8] c"unknown command '%.128s', with args beginning with: %s\00", align 1
@.str.175 = private unnamed_addr constant [43 x i8] c"wrong number of arguments for '%s' command\00", align 1
@.str.176 = private unnamed_addr constant [16 x i8] c"!server.in_exec\00", align 1
@.str.177 = private unnamed_addr constant [19 x i8] c"!scriptIsRunning()\00", align 1
@.str.178 = private unnamed_addr constant [6 x i8] c"host:\00", align 1
@.str.179 = private unnamed_addr constant [5 x i8] c"post\00", align 1
@.str.180 = private unnamed_addr constant [194 x i8] c"%s command not allowed. If the %s option is set to \22local\22, you can run it from a local connection, otherwise you need to set this option in the configuration file, and then restart the server.\00", align 1
@.str.181 = private unnamed_addr constant [6 x i8] c"DEBUG\00", align 1
@.str.182 = private unnamed_addr constant [21 x i8] c"enable-debug-command\00", align 1
@.str.183 = private unnamed_addr constant [22 x i8] c"enable-module-command\00", align 1
@.str.184 = private unnamed_addr constant [41 x i8] c"Command not allowed inside a transaction\00", align 1
@.str.185 = private unnamed_addr constant [11 x i8] c"-NOPERM %s\00", align 1
@.str.186 = private unnamed_addr constant [45 x i8] c"Replica was unable to write command to disk.\00", align 1
@processCommand.last_log_time_ms = internal global i64 0, align 8
@.str.187 = private unnamed_addr constant [73 x i8] c"Replica is applying a command even though it is unable to write to disk.\00", align 1
@.str.188 = private unnamed_addr constant [109 x i8] c"Can't execute '%s': only (P|S)SUBSCRIBE / (P|S)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context\00", align 1
@.str.189 = private unnamed_addr constant [9 x i8] c"-BUSY %s\00", align 1
@.str.190 = private unnamed_addr constant [41 x i8] c"Replica can't interact with the keyspace\00", align 1
@.str.191 = private unnamed_addr constant [31 x i8] c"Removing the unix socket file.\00", align 1
@.str.192 = private unnamed_addr constant [40 x i8] c"Error removing the unix socket file: %s\00", align 1
@.str.193 = private unnamed_addr constant [27 x i8] c"User requested shutdown...\00", align 1
@.str.194 = private unnamed_addr constant [12 x i8] c"STOPPING=1\0A\00", align 1
@.str.195 = private unnamed_addr constant [43 x i8] c"Waiting for replicas before shutting down.\00", align 1
@.str.196 = private unnamed_addr constant [27 x i8] c"Shutdown manually aborted.\00", align 1
@.str.197 = private unnamed_addr constant [74 x i8] c"Lagging replica %s reported offset %lld behind master, lag=%ld, state=%s.\00", align 1
@.str.198 = private unnamed_addr constant [50 x i8] c"%d of %d replicas are in sync when shutting down.\00", align 1
@.str.199 = private unnamed_addr constant [45 x i8] c"There is a child saving an .rdb. Killing it!\00", align 1
@.str.200 = private unnamed_addr constant [42 x i8] c"There is a module fork child. Killing it!\00", align 1
@.str.201 = private unnamed_addr constant [34 x i8] c"Writing initial AOF. Exit anyway.\00", align 1
@.str.202 = private unnamed_addr constant [33 x i8] c"Writing initial AOF, can't exit.\00", align 1
@.str.203 = private unnamed_addr constant [41 x i8] c"STATUS=Writing initial AOF, can't exit.\0A\00", align 1
@.str.204 = private unnamed_addr constant [48 x i8] c"There is a child rewriting the AOF. Killing it!\00", align 1
@.str.205 = private unnamed_addr constant [33 x i8] c"Calling fsync() on the AOF file.\00", align 1
@.str.206 = private unnamed_addr constant [32 x i8] c"Fail to fsync the AOF file: %s.\00", align 1
@.str.207 = private unnamed_addr constant [46 x i8] c"Saving the final RDB snapshot before exiting.\00", align 1
@.str.208 = private unnamed_addr constant [38 x i8] c"STATUS=Saving the final RDB snapshot\0A\00", align 1
@.str.209 = private unnamed_addr constant [42 x i8] c"Error trying to save the DB. Exit anyway.\00", align 1
@.str.210 = private unnamed_addr constant [41 x i8] c"Error trying to save the DB, can't exit.\00", align 1
@.str.211 = private unnamed_addr constant [49 x i8] c"STATUS=Error trying to save the DB, can't exit.\0A\00", align 1
@.str.212 = private unnamed_addr constant [23 x i8] c"Removing the pid file.\00", align 1
@.str.213 = private unnamed_addr constant [36 x i8] c"%s is now ready to exit, bye bye...\00", align 1
@.str.214 = private unnamed_addr constant [9 x i8] c"Sentinel\00", align 1
@.str.215 = private unnamed_addr constant [6 x i8] c"Redis\00", align 1
@.str.216 = private unnamed_addr constant [76 x i8] c"Errors trying to shut down the server. Check the logs for more information.\00", align 1
@.str.217 = private unnamed_addr constant [46 x i8] c"-MISCONF Errors writing to the AOF file: %s\0D\0A\00", align 1
@.str.218 = private unnamed_addr constant [5 x i8] c"pong\00", align 1
@.str.219 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.220 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.221 = private unnamed_addr constant [9 x i8] c"readonly\00", align 1
@.str.222 = private unnamed_addr constant [8 x i8] c"denyoom\00", align 1
@.str.223 = private unnamed_addr constant [7 x i8] c"module\00", align 1
@.str.224 = private unnamed_addr constant [6 x i8] c"admin\00", align 1
@.str.225 = private unnamed_addr constant [7 x i8] c"pubsub\00", align 1
@.str.226 = private unnamed_addr constant [9 x i8] c"noscript\00", align 1
@.str.227 = private unnamed_addr constant [9 x i8] c"blocking\00", align 1
@.str.228 = private unnamed_addr constant [8 x i8] c"loading\00", align 1
@.str.229 = private unnamed_addr constant [6 x i8] c"stale\00", align 1
@.str.230 = private unnamed_addr constant [13 x i8] c"skip_monitor\00", align 1
@.str.231 = private unnamed_addr constant [13 x i8] c"skip_slowlog\00", align 1
@.str.232 = private unnamed_addr constant [7 x i8] c"asking\00", align 1
@.str.233 = private unnamed_addr constant [5 x i8] c"fast\00", align 1
@.str.234 = private unnamed_addr constant [8 x i8] c"no_auth\00", align 1
@.str.235 = private unnamed_addr constant [18 x i8] c"no_mandatory_keys\00", align 1
@.str.236 = private unnamed_addr constant [17 x i8] c"no_async_loading\00", align 1
@.str.237 = private unnamed_addr constant [9 x i8] c"no_multi\00", align 1
@.str.238 = private unnamed_addr constant [12 x i8] c"movablekeys\00", align 1
@.str.239 = private unnamed_addr constant [11 x i8] c"allow_busy\00", align 1
@__const.addReplyFlagsForCommand.flagNames = private unnamed_addr constant [21 x %struct.replyFlagNames] [%struct.replyFlagNames { i64 1, ptr @.str.220 }, %struct.replyFlagNames { i64 2, ptr @.str.221 }, %struct.replyFlagNames { i64 4, ptr @.str.222 }, %struct.replyFlagNames { i64 8, ptr @.str.223 }, %struct.replyFlagNames { i64 16, ptr @.str.224 }, %struct.replyFlagNames { i64 32, ptr @.str.225 }, %struct.replyFlagNames { i64 64, ptr @.str.226 }, %struct.replyFlagNames { i64 256, ptr @.str.227 }, %struct.replyFlagNames { i64 512, ptr @.str.228 }, %struct.replyFlagNames { i64 1024, ptr @.str.229 }, %struct.replyFlagNames { i64 2048, ptr @.str.230 }, %struct.replyFlagNames { i64 4096, ptr @.str.231 }, %struct.replyFlagNames { i64 8192, ptr @.str.232 }, %struct.replyFlagNames { i64 16384, ptr @.str.233 }, %struct.replyFlagNames { i64 32768, ptr @.str.234 }, %struct.replyFlagNames { i64 524288, ptr @.str.235 }, %struct.replyFlagNames { i64 8388608, ptr @.str.236 }, %struct.replyFlagNames { i64 16777216, ptr @.str.237 }, %struct.replyFlagNames { i64 33554432, ptr @.str.238 }, %struct.replyFlagNames { i64 67108864, ptr @.str.239 }, %struct.replyFlagNames zeroinitializer], align 16
@.str.240 = private unnamed_addr constant [11 x i8] c"deprecated\00", align 1
@.str.241 = private unnamed_addr constant [7 x i8] c"syscmd\00", align 1
@__const.addReplyDocFlagsForCommand.docFlagNames = private unnamed_addr constant [3 x %struct.replyFlagNames] [%struct.replyFlagNames { i64 1, ptr @.str.240 }, %struct.replyFlagNames { i64 2, ptr @.str.241 }, %struct.replyFlagNames zeroinitializer], align 16
@.str.242 = private unnamed_addr constant [3 x i8] c"RO\00", align 1
@.str.243 = private unnamed_addr constant [3 x i8] c"RW\00", align 1
@.str.244 = private unnamed_addr constant [3 x i8] c"OW\00", align 1
@.str.245 = private unnamed_addr constant [3 x i8] c"RM\00", align 1
@.str.246 = private unnamed_addr constant [7 x i8] c"access\00", align 1
@.str.247 = private unnamed_addr constant [7 x i8] c"update\00", align 1
@.str.248 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str.249 = private unnamed_addr constant [7 x i8] c"delete\00", align 1
@.str.250 = private unnamed_addr constant [8 x i8] c"not_key\00", align 1
@.str.251 = private unnamed_addr constant [11 x i8] c"incomplete\00", align 1
@.str.252 = private unnamed_addr constant [15 x i8] c"variable_flags\00", align 1
@__const.addReplyFlagsForKeyArgs.docFlagNames = private unnamed_addr constant [12 x %struct.replyFlagNames] [%struct.replyFlagNames { i64 1, ptr @.str.242 }, %struct.replyFlagNames { i64 2, ptr @.str.243 }, %struct.replyFlagNames { i64 4, ptr @.str.244 }, %struct.replyFlagNames { i64 8, ptr @.str.245 }, %struct.replyFlagNames { i64 16, ptr @.str.246 }, %struct.replyFlagNames { i64 32, ptr @.str.247 }, %struct.replyFlagNames { i64 64, ptr @.str.248 }, %struct.replyFlagNames { i64 128, ptr @.str.249 }, %struct.replyFlagNames { i64 256, ptr @.str.250 }, %struct.replyFlagNames { i64 512, ptr @.str.251 }, %struct.replyFlagNames { i64 1024, ptr @.str.252 }, %struct.replyFlagNames zeroinitializer], align 16
@.str.253 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.254 = private unnamed_addr constant [8 x i8] c"integer\00", align 1
@.str.255 = private unnamed_addr constant [7 x i8] c"double\00", align 1
@.str.256 = private unnamed_addr constant [4 x i8] c"key\00", align 1
@.str.257 = private unnamed_addr constant [8 x i8] c"pattern\00", align 1
@.str.258 = private unnamed_addr constant [10 x i8] c"unix-time\00", align 1
@.str.259 = private unnamed_addr constant [11 x i8] c"pure-token\00", align 1
@.str.260 = private unnamed_addr constant [6 x i8] c"oneof\00", align 1
@.str.261 = private unnamed_addr constant [6 x i8] c"block\00", align 1
@ARG_TYPE_STR = dso_local global [9 x ptr] [ptr @.str.253, ptr @.str.254, ptr @.str.255, ptr @.str.256, ptr @.str.257, ptr @.str.258, ptr @.str.259, ptr @.str.260, ptr @.str.261], align 16
@.str.262 = private unnamed_addr constant [9 x i8] c"optional\00", align 1
@.str.263 = private unnamed_addr constant [9 x i8] c"multiple\00", align 1
@.str.264 = private unnamed_addr constant [15 x i8] c"multiple_token\00", align 1
@__const.addReplyFlagsForArg.argFlagNames = private unnamed_addr constant [4 x %struct.replyFlagNames] [%struct.replyFlagNames { i64 1, ptr @.str.262 }, %struct.replyFlagNames { i64 2, ptr @.str.263 }, %struct.replyFlagNames { i64 4, ptr @.str.264 }, %struct.replyFlagNames zeroinitializer], align 16
@.str.265 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.266 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.267 = private unnamed_addr constant [13 x i8] c"display_text\00", align 1
@.str.268 = private unnamed_addr constant [15 x i8] c"key_spec_index\00", align 1
@.str.269 = private unnamed_addr constant [6 x i8] c"token\00", align 1
@.str.270 = private unnamed_addr constant [8 x i8] c"summary\00", align 1
@.str.271 = private unnamed_addr constant [6 x i8] c"since\00", align 1
@.str.272 = private unnamed_addr constant [17 x i8] c"deprecated_since\00", align 1
@.str.273 = private unnamed_addr constant [6 x i8] c"flags\00", align 1
@.str.274 = private unnamed_addr constant [10 x i8] c"arguments\00", align 1
@.str.275 = private unnamed_addr constant [6 x i8] c"notes\00", align 1
@.str.276 = private unnamed_addr constant [13 x i8] c"begin_search\00", align 1
@.str.277 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.278 = private unnamed_addr constant [5 x i8] c"spec\00", align 1
@.str.279 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.280 = private unnamed_addr constant [8 x i8] c"keyword\00", align 1
@.str.281 = private unnamed_addr constant [10 x i8] c"startfrom\00", align 1
@.str.282 = private unnamed_addr constant [38 x i8] c"Invalid begin_search key spec type %d\00", align 1
@.str.283 = private unnamed_addr constant [10 x i8] c"find_keys\00", align 1
@.str.284 = private unnamed_addr constant [6 x i8] c"range\00", align 1
@.str.285 = private unnamed_addr constant [8 x i8] c"lastkey\00", align 1
@.str.286 = private unnamed_addr constant [8 x i8] c"keystep\00", align 1
@.str.287 = private unnamed_addr constant [6 x i8] c"limit\00", align 1
@.str.288 = private unnamed_addr constant [7 x i8] c"keynum\00", align 1
@.str.289 = private unnamed_addr constant [10 x i8] c"keynumidx\00", align 1
@.str.290 = private unnamed_addr constant [9 x i8] c"firstkey\00", align 1
@.str.291 = private unnamed_addr constant [35 x i8] c"Invalid find_keys key spec type %d\00", align 1
@.str.292 = private unnamed_addr constant [6 x i8] c"group\00", align 1
@.str.293 = private unnamed_addr constant [11 x i8] c"complexity\00", align 1
@.str.294 = private unnamed_addr constant [10 x i8] c"doc_flags\00", align 1
@.str.295 = private unnamed_addr constant [12 x i8] c"replaced_by\00", align 1
@.str.296 = private unnamed_addr constant [8 x i8] c"history\00", align 1
@.str.297 = private unnamed_addr constant [12 x i8] c"subcommands\00", align 1
@.str.298 = private unnamed_addr constant [26 x i8] c"Invalid command specified\00", align 1
@.str.299 = private unnamed_addr constant [33 x i8] c"The command has no key arguments\00", align 1
@.str.300 = private unnamed_addr constant [50 x i8] c"Invalid number of arguments specified for command\00", align 1
@.str.301 = private unnamed_addr constant [40 x i8] c"Invalid arguments specified for command\00", align 1
@.str.302 = private unnamed_addr constant [23 x i8] c"Invalid filter type %d\00", align 1
@.str.303 = private unnamed_addr constant [9 x i8] c"filterby\00", align 1
@.str.304 = private unnamed_addr constant [7 x i8] c"aclcat\00", align 1
@.str.305 = private unnamed_addr constant [16 x i8] c"(no subcommand)\00", align 1
@.str.306 = private unnamed_addr constant [45 x i8] c"    Return details about all Redis commands.\00", align 1
@.str.307 = private unnamed_addr constant [6 x i8] c"COUNT\00", align 1
@.str.308 = private unnamed_addr constant [62 x i8] c"    Return the total number of commands in this Redis server.\00", align 1
@.str.309 = private unnamed_addr constant [5 x i8] c"LIST\00", align 1
@.str.310 = private unnamed_addr constant [56 x i8] c"    Return a list of all commands in this Redis server.\00", align 1
@.str.311 = private unnamed_addr constant [26 x i8] c"INFO [<command-name> ...]\00", align 1
@.str.312 = private unnamed_addr constant [50 x i8] c"    Return details about multiple Redis commands.\00", align 1
@.str.313 = private unnamed_addr constant [65 x i8] c"    If no command names are given, documentation details for all\00", align 1
@.str.314 = private unnamed_addr constant [27 x i8] c"    commands are returned.\00", align 1
@.str.315 = private unnamed_addr constant [26 x i8] c"DOCS [<command-name> ...]\00", align 1
@.str.316 = private unnamed_addr constant [64 x i8] c"    Return documentation details about multiple Redis commands.\00", align 1
@.str.317 = private unnamed_addr constant [23 x i8] c"GETKEYS <full-command>\00", align 1
@.str.318 = private unnamed_addr constant [47 x i8] c"    Return the keys from a full Redis command.\00", align 1
@.str.319 = private unnamed_addr constant [31 x i8] c"GETKEYSANDFLAGS <full-command>\00", align 1
@.str.320 = private unnamed_addr constant [68 x i8] c"    Return the keys and the access flags from a full Redis command.\00", align 1
@__const.commandHelpCommand.help = private unnamed_addr constant [19 x ptr] [ptr @.str.305, ptr @.str.306, ptr @.str.307, ptr @.str.308, ptr @.str.309, ptr @.str.310, ptr @.str.311, ptr @.str.312, ptr @.str.313, ptr @.str.314, ptr @.str.315, ptr @.str.316, ptr @.str.313, ptr @.str.314, ptr @.str.317, ptr @.str.318, ptr @.str.319, ptr @.str.320, ptr null], align 16
@.str.321 = private unnamed_addr constant [6 x i8] c"%lluB\00", align 1
@.str.322 = private unnamed_addr constant [6 x i8] c"%.2fK\00", align 1
@.str.323 = private unnamed_addr constant [6 x i8] c"%.2fM\00", align 1
@.str.324 = private unnamed_addr constant [6 x i8] c"%.2fG\00", align 1
@.str.325 = private unnamed_addr constant [6 x i8] c"%.2fT\00", align 1
@.str.326 = private unnamed_addr constant [6 x i8] c"%.2fP\00", align 1
@.str.327 = private unnamed_addr constant [29 x i8] c"latency_percentiles_usec_%s:\00", align 1
@.str.328 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.329 = private unnamed_addr constant [9 x i8] c"p%s=%.3f\00", align 1
@.str.330 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.331 = private unnamed_addr constant [12 x i8] c"wait_bgsave\00", align 1
@.str.332 = private unnamed_addr constant [10 x i8] c"send_bulk\00", align 1
@.str.333 = private unnamed_addr constant [7 x i8] c"online\00", align 1
@unsafe_info_chars = internal global [5 x i8] c"#:\0A\0D\00", align 1
@unsafe_info_chars_substs = internal global [5 x i8] c"____\00", align 1
@.str.334 = private unnamed_addr constant [91 x i8] c"cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f,rejected_calls=%lld,failed_calls=%lld\0D\0A\00", align 1
@.str.335 = private unnamed_addr constant [118 x i8] c"acl_access_denied_auth:%lld\0D\0Aacl_access_denied_cmd:%lld\0D\0Aacl_access_denied_key:%lld\0D\0Aacl_access_denied_channel:%lld\0D\0A\00", align 1
@cached_default_info_sections = internal global ptr null, align 8
@.str.336 = private unnamed_addr constant [7 x i8] c"server\00", align 1
@.str.337 = private unnamed_addr constant [8 x i8] c"clients\00", align 1
@.str.338 = private unnamed_addr constant [7 x i8] c"memory\00", align 1
@.str.339 = private unnamed_addr constant [12 x i8] c"persistence\00", align 1
@.str.340 = private unnamed_addr constant [6 x i8] c"stats\00", align 1
@.str.341 = private unnamed_addr constant [12 x i8] c"replication\00", align 1
@.str.342 = private unnamed_addr constant [4 x i8] c"cpu\00", align 1
@.str.343 = private unnamed_addr constant [12 x i8] c"module_list\00", align 1
@.str.344 = private unnamed_addr constant [11 x i8] c"errorstats\00", align 1
@.str.345 = private unnamed_addr constant [8 x i8] c"cluster\00", align 1
@.str.346 = private unnamed_addr constant [9 x i8] c"keyspace\00", align 1
@__const.genInfoSectionDict.default_sections = private unnamed_addr constant [12 x ptr] [ptr @.str.336, ptr @.str.337, ptr @.str.338, ptr @.str.339, ptr @.str.340, ptr @.str.341, ptr @.str.342, ptr @.str.343, ptr @.str.344, ptr @.str.345, ptr @.str.346, ptr null], align 16
@.str.347 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.348 = private unnamed_addr constant [11 x i8] c"everything\00", align 1
@genRedisInfoString.call_uname = internal global i32 1, align 4
@genRedisInfoString.name = internal global %struct.utsname zeroinitializer, align 1
@.str.349 = private unnamed_addr constant [9 x i8] c"sentinel\00", align 1
@.str.350 = private unnamed_addr constant [11 x i8] c"standalone\00", align 1
@.str.351 = private unnamed_addr constant [8 x i8] c"upstart\00", align 1
@.str.352 = private unnamed_addr constant [8 x i8] c"systemd\00", align 1
@.str.353 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.354 = private unnamed_addr constant [420 x i8] c"# Server\0D\0Aredis_version:%s\0D\0Aredis_git_sha1:%s\0D\0Aredis_git_dirty:%i\0D\0Aredis_build_id:%s\0D\0Aredis_mode:%s\0D\0Aos:%s %s %s\0D\0Aarch_bits:%i\0D\0Amonotonic_clock:%s\0D\0Amultiplexing_api:%s\0D\0Aatomicvar_api:%s\0D\0Agcc_version:%s\0D\0Aprocess_id:%I\0D\0Aprocess_supervised:%s\0D\0Arun_id:%s\0D\0Atcp_port:%i\0D\0Aserver_time_usec:%I\0D\0Auptime_in_seconds:%I\0D\0Auptime_in_days:%I\0D\0Ahz:%i\0D\0Aconfigured_hz:%i\0D\0Alru_clock:%u\0D\0Aexecutable:%s\0D\0Aconfig_file:%s\0D\0Aio_threads_active:%i\0D\0A\00", align 1
@.str.355 = private unnamed_addr constant [12 x i8] c"255.255.255\00", align 1
@.str.356 = private unnamed_addr constant [12 x i8] c"c11-builtin\00", align 1
@.str.357 = private unnamed_addr constant [6 x i8] c"4.2.1\00", align 1
@.str.358 = private unnamed_addr constant [30 x i8] c"shutdown_in_milliseconds:%I\0D\0A\00", align 1
@.str.359 = private unnamed_addr constant [298 x i8] c"# Clients\0D\0Aconnected_clients:%lu\0D\0Acluster_connections:%lu\0D\0Amaxclients:%u\0D\0Aclient_recent_max_input_buffer:%zu\0D\0Aclient_recent_max_output_buffer:%zu\0D\0Ablocked_clients:%d\0D\0Atracking_clients:%d\0D\0Apubsub_clients:%d\0D\0Aclients_in_timeout_table:%llu\0D\0Atotal_blocking_keys:%lu\0D\0Atotal_blocking_keys_on_nokey:%lu\0D\0A\00", align 1
@.str.360 = private unnamed_addr constant [1321 x i8] c"# Memory\0D\0Aused_memory:%zu\0D\0Aused_memory_human:%s\0D\0Aused_memory_rss:%zu\0D\0Aused_memory_rss_human:%s\0D\0Aused_memory_peak:%zu\0D\0Aused_memory_peak_human:%s\0D\0Aused_memory_peak_perc:%.2f%%\0D\0Aused_memory_overhead:%zu\0D\0Aused_memory_startup:%zu\0D\0Aused_memory_dataset:%zu\0D\0Aused_memory_dataset_perc:%.2f%%\0D\0Aallocator_allocated:%zu\0D\0Aallocator_active:%zu\0D\0Aallocator_resident:%zu\0D\0Atotal_system_memory:%lu\0D\0Atotal_system_memory_human:%s\0D\0Aused_memory_lua:%lld\0D\0Aused_memory_vm_eval:%lld\0D\0Aused_memory_lua_human:%s\0D\0Aused_memory_scripts_eval:%lld\0D\0Anumber_of_cached_scripts:%lu\0D\0Anumber_of_functions:%lu\0D\0Anumber_of_libraries:%lu\0D\0Aused_memory_vm_functions:%lld\0D\0Aused_memory_vm_total:%lld\0D\0Aused_memory_vm_total_human:%s\0D\0Aused_memory_functions:%lld\0D\0Aused_memory_scripts:%lld\0D\0Aused_memory_scripts_human:%s\0D\0Amaxmemory:%lld\0D\0Amaxmemory_human:%s\0D\0Amaxmemory_policy:%s\0D\0Aallocator_frag_ratio:%.2f\0D\0Aallocator_frag_bytes:%zu\0D\0Aallocator_rss_ratio:%.2f\0D\0Aallocator_rss_bytes:%zd\0D\0Arss_overhead_ratio:%.2f\0D\0Arss_overhead_bytes:%zd\0D\0Amem_fragmentation_ratio:%.2f\0D\0Amem_fragmentation_bytes:%zd\0D\0Amem_not_counted_for_evict:%zu\0D\0Amem_replication_backlog:%zu\0D\0Amem_total_replication_buffers:%zu\0D\0Amem_clients_slaves:%zu\0D\0Amem_clients_normal:%zu\0D\0Amem_cluster_links:%zu\0D\0Amem_aof_buffer:%zu\0D\0Amem_allocator:%s\0D\0Aactive_defrag_running:%d\0D\0Alazyfree_pending_objects:%zu\0D\0Alazyfreed_objects:%zu\0D\0A\00", align 1
@.str.361 = private unnamed_addr constant [15 x i8] c"jemalloc-5.3.0\00", align 1
@.str.362 = private unnamed_addr constant [813 x i8] c"# Persistence\0D\0Aloading:%d\0D\0Aasync_loading:%d\0D\0Acurrent_cow_peak:%zu\0D\0Acurrent_cow_size:%zu\0D\0Acurrent_cow_size_age:%lu\0D\0Acurrent_fork_perc:%.2f\0D\0Acurrent_save_keys_processed:%zu\0D\0Acurrent_save_keys_total:%zu\0D\0Ardb_changes_since_last_save:%lld\0D\0Ardb_bgsave_in_progress:%d\0D\0Ardb_last_save_time:%jd\0D\0Ardb_last_bgsave_status:%s\0D\0Ardb_last_bgsave_time_sec:%jd\0D\0Ardb_current_bgsave_time_sec:%jd\0D\0Ardb_saves:%lld\0D\0Ardb_last_cow_size:%zu\0D\0Ardb_last_load_keys_expired:%lld\0D\0Ardb_last_load_keys_loaded:%lld\0D\0Aaof_enabled:%d\0D\0Aaof_rewrite_in_progress:%d\0D\0Aaof_rewrite_scheduled:%d\0D\0Aaof_last_rewrite_time_sec:%jd\0D\0Aaof_current_rewrite_time_sec:%jd\0D\0Aaof_last_bgrewrite_status:%s\0D\0Aaof_rewrites:%lld\0D\0Aaof_rewrites_consecutive_failures:%lld\0D\0Aaof_last_write_status:%s\0D\0Aaof_last_cow_size:%zu\0D\0Amodule_fork_in_progress:%d\0D\0Amodule_fork_last_cow_size:%zu\0D\0A\00", align 1
@.str.363 = private unnamed_addr constant [3 x i8] c"ok\00", align 1
@.str.364 = private unnamed_addr constant [4 x i8] c"err\00", align 1
@.str.365 = private unnamed_addr constant [141 x i8] c"aof_current_size:%lld\0D\0Aaof_base_size:%lld\0D\0Aaof_pending_rewrite:%d\0D\0Aaof_buffer_length:%zu\0D\0Aaof_pending_bio_fsync:%lu\0D\0Aaof_delayed_fsync:%lu\0D\0A\00", align 1
@.str.366 = private unnamed_addr constant [156 x i8] c"loading_start_time:%jd\0D\0Aloading_total_bytes:%llu\0D\0Aloading_rdb_used_mem:%llu\0D\0Aloading_loaded_bytes:%llu\0D\0Aloading_loaded_perc:%.2f\0D\0Aloading_eta_seconds:%jd\0D\0A\00", align 1
@.str.367 = private unnamed_addr constant [1693 x i8] c"# Stats\0D\0Atotal_connections_received:%lld\0D\0Atotal_commands_processed:%lld\0D\0Ainstantaneous_ops_per_sec:%lld\0D\0Atotal_net_input_bytes:%lld\0D\0Atotal_net_output_bytes:%lld\0D\0Atotal_net_repl_input_bytes:%lld\0D\0Atotal_net_repl_output_bytes:%lld\0D\0Ainstantaneous_input_kbps:%.2f\0D\0Ainstantaneous_output_kbps:%.2f\0D\0Ainstantaneous_input_repl_kbps:%.2f\0D\0Ainstantaneous_output_repl_kbps:%.2f\0D\0Arejected_connections:%lld\0D\0Async_full:%lld\0D\0Async_partial_ok:%lld\0D\0Async_partial_err:%lld\0D\0Aexpired_keys:%lld\0D\0Aexpired_stale_perc:%.2f\0D\0Aexpired_time_cap_reached_count:%lld\0D\0Aexpire_cycle_cpu_milliseconds:%lld\0D\0Aevicted_keys:%lld\0D\0Aevicted_clients:%lld\0D\0Atotal_eviction_exceeded_time:%lld\0D\0Acurrent_eviction_exceeded_time:%lld\0D\0Akeyspace_hits:%lld\0D\0Akeyspace_misses:%lld\0D\0Apubsub_channels:%ld\0D\0Apubsub_patterns:%lu\0D\0Apubsubshard_channels:%lu\0D\0Alatest_fork_usec:%lld\0D\0Atotal_forks:%lld\0D\0Amigrate_cached_sockets:%ld\0D\0Aslave_expires_tracked_keys:%zu\0D\0Aactive_defrag_hits:%lld\0D\0Aactive_defrag_misses:%lld\0D\0Aactive_defrag_key_hits:%lld\0D\0Aactive_defrag_key_misses:%lld\0D\0Atotal_active_defrag_time:%lld\0D\0Acurrent_active_defrag_time:%lld\0D\0Atracking_total_keys:%lld\0D\0Atracking_total_items:%lld\0D\0Atracking_total_prefixes:%lld\0D\0Aunexpected_error_replies:%lld\0D\0Atotal_error_replies:%lld\0D\0Adump_payload_sanitizations:%lld\0D\0Atotal_reads_processed:%lld\0D\0Atotal_writes_processed:%lld\0D\0Aio_threaded_reads_processed:%lld\0D\0Aio_threaded_writes_processed:%lld\0D\0Aclient_query_buffer_limit_disconnections:%lld\0D\0Aclient_output_buffer_limit_disconnections:%lld\0D\0Areply_buffer_shrinks:%lld\0D\0Areply_buffer_expands:%lld\0D\0Aeventloop_cycles:%llu\0D\0Aeventloop_duration_sum:%llu\0D\0Aeventloop_duration_cmd_sum:%llu\0D\0Ainstantaneous_eventloop_cycles_per_sec:%llu\0D\0Ainstantaneous_eventloop_duration_usec:%llu\0D\0A\00", align 1
@.str.368 = private unnamed_addr constant [25 x i8] c"# Replication\0D\0Arole:%s\0D\0A\00", align 1
@.str.369 = private unnamed_addr constant [7 x i8] c"master\00", align 1
@.str.370 = private unnamed_addr constant [6 x i8] c"slave\00", align 1
@.str.371 = private unnamed_addr constant [168 x i8] c"master_host:%s\0D\0Amaster_port:%d\0D\0Amaster_link_status:%s\0D\0Amaster_last_io_seconds_ago:%d\0D\0Amaster_sync_in_progress:%d\0D\0Aslave_read_repl_offset:%lld\0D\0Aslave_repl_offset:%lld\0D\0A\00", align 1
@.str.372 = private unnamed_addr constant [3 x i8] c"up\00", align 1
@.str.373 = private unnamed_addr constant [5 x i8] c"down\00", align 1
@.str.374 = private unnamed_addr constant [148 x i8] c"master_sync_total_bytes:%lld\0D\0Amaster_sync_read_bytes:%lld\0D\0Amaster_sync_left_bytes:%lld\0D\0Amaster_sync_perc:%.2f\0D\0Amaster_sync_last_io_seconds_ago:%d\0D\0A\00", align 1
@.str.375 = private unnamed_addr constant [37 x i8] c"master_link_down_since_seconds:%jd\0D\0A\00", align 1
@.str.376 = private unnamed_addr constant [62 x i8] c"slave_priority:%d\0D\0Aslave_read_only:%d\0D\0Areplica_announced:%d\0D\0A\00", align 1
@.str.377 = private unnamed_addr constant [23 x i8] c"connected_slaves:%lu\0D\0A\00", align 1
@.str.378 = private unnamed_addr constant [28 x i8] c"min_slaves_good_slaves:%d\0D\0A\00", align 1
@.str.379 = private unnamed_addr constant [53 x i8] c"slave%d:ip=%s,port=%d,state=%s,offset=%lld,lag=%ld\0D\0A\00", align 1
@.str.380 = private unnamed_addr constant [226 x i8] c"master_failover_state:%s\0D\0Amaster_replid:%s\0D\0Amaster_replid2:%s\0D\0Amaster_repl_offset:%lld\0D\0Asecond_repl_offset:%lld\0D\0Arepl_backlog_active:%d\0D\0Arepl_backlog_size:%lld\0D\0Arepl_backlog_first_byte_offset:%lld\0D\0Arepl_backlog_histlen:%lld\0D\0A\00", align 1
@.str.381 = private unnamed_addr constant [124 x i8] c"# CPU\0D\0Aused_cpu_sys:%ld.%06ld\0D\0Aused_cpu_user:%ld.%06ld\0D\0Aused_cpu_sys_children:%ld.%06ld\0D\0Aused_cpu_user_children:%ld.%06ld\0D\0A\00", align 1
@.str.382 = private unnamed_addr constant [74 x i8] c"used_cpu_sys_main_thread:%ld.%06ld\0D\0Aused_cpu_user_main_thread:%ld.%06ld\0D\0A\00", align 1
@.str.383 = private unnamed_addr constant [8 x i8] c"modules\00", align 1
@.str.384 = private unnamed_addr constant [12 x i8] c"# Modules\0D\0A\00", align 1
@.str.385 = private unnamed_addr constant [13 x i8] c"commandstats\00", align 1
@.str.386 = private unnamed_addr constant [17 x i8] c"# Commandstats\0D\0A\00", align 1
@.str.387 = private unnamed_addr constant [15 x i8] c"# Errorstats\0D\0A\00", align 1
@.str.388 = private unnamed_addr constant [2 x i8] c"^\00", align 1
@.str.389 = private unnamed_addr constant [28 x i8] c"errorstat_%.*s:count=%lld\0D\0A\00", align 1
@.str.390 = private unnamed_addr constant [13 x i8] c"latencystats\00", align 1
@.str.391 = private unnamed_addr constant [17 x i8] c"# Latencystats\0D\0A\00", align 1
@.str.392 = private unnamed_addr constant [32 x i8] c"# Cluster\0D\0Acluster_enabled:%d\0D\0A\00", align 1
@.str.393 = private unnamed_addr constant [13 x i8] c"# Keyspace\0D\0A\00", align 1
@.str.394 = private unnamed_addr constant [43 x i8] c"db%d:keys=%lld,expires=%lld,avg_ttl=%lld\0D\0A\00", align 1
@.str.395 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.396 = private unnamed_addr constant [140 x i8] c"# Debug\0D\0Aeventloop_duration_aof_sum:%llu\0D\0Aeventloop_duration_cron_sum:%llu\0D\0Aeventloop_duration_max:%llu\0D\0Aeventloop_cmd_per_cycle_max:%lld\0D\0A\00", align 1
@.str.397 = private unnamed_addr constant [4 x i8] c"txt\00", align 1
@.str.398 = private unnamed_addr constant [47 x i8] c"MONITOR isn't allowed for DENY BLOCKING client\00", align 1
@.str.399 = private unnamed_addr constant [11 x i8] c"WARNING %s\00", align 1
@.str.400 = private unnamed_addr constant [19 x i8] c"/var/run/redis.pid\00", align 1
@.str.401 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.402 = private unnamed_addr constant [29 x i8] c"Failed to write PID file: %s\00", align 1
@.str.403 = private unnamed_addr constant [10 x i8] c"/dev/null\00", align 1
@.str.404 = private unnamed_addr constant [58 x i8] c"Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\0A\00", align 1
@stderr = external global ptr, align 8
@.str.405 = private unnamed_addr constant [59 x i8] c"Usage: ./redis-server [/path/to/redis.conf] [options] [-]\0A\00", align 1
@.str.406 = private unnamed_addr constant [50 x i8] c"       ./redis-server - (read config from stdin)\0A\00", align 1
@.str.407 = private unnamed_addr constant [39 x i8] c"       ./redis-server -v or --version\0A\00", align 1
@.str.408 = private unnamed_addr constant [36 x i8] c"       ./redis-server -h or --help\0A\00", align 1
@.str.409 = private unnamed_addr constant [49 x i8] c"       ./redis-server --test-memory <megabytes>\0A\00", align 1
@.str.410 = private unnamed_addr constant [38 x i8] c"       ./redis-server --check-system\0A\00", align 1
@.str.411 = private unnamed_addr constant [11 x i8] c"Examples:\0A\00", align 1
@.str.412 = private unnamed_addr constant [58 x i8] c"       ./redis-server (run the server with default conf)\0A\00", align 1
@.str.413 = private unnamed_addr constant [50 x i8] c"       echo 'maxmemory 128mb' | ./redis-server -\0A\00", align 1
@.str.414 = private unnamed_addr constant [44 x i8] c"       ./redis-server /etc/redis/6379.conf\0A\00", align 1
@.str.415 = private unnamed_addr constant [35 x i8] c"       ./redis-server --port 7777\0A\00", align 1
@.str.416 = private unnamed_addr constant [62 x i8] c"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\0A\00", align 1
@.str.417 = private unnamed_addr constant [62 x i8] c"       ./redis-server /etc/myredis.conf --loglevel verbose -\0A\00", align 1
@.str.418 = private unnamed_addr constant [61 x i8] c"       ./redis-server /etc/myredis.conf --loglevel verbose\0A\0A\00", align 1
@.str.419 = private unnamed_addr constant [16 x i8] c"Sentinel mode:\0A\00", align 1
@.str.420 = private unnamed_addr constant [53 x i8] c"       ./redis-server /etc/sentinel.conf --sentinel\0A\00", align 1
@.str.421 = private unnamed_addr constant [1132 x i8] c"                _._                                                  \0A           _.-``__ ''-._                                             \0A      _.-``    `.  `_.  ''-._           Redis %s (%s/%d) %s bit\0A  .-`` .-```.  ```\\/    _.,_ ''-._                                  \0A (    '      ,       .-`  | `,    )     Running in %s mode\0A |`-._`-...-` __...-.``-._|'` _.-'|     Port: %d\0A |    `-._   `._    /     _.-'    |     PID: %ld\0A  `-._    `-._  `-./  _.-'    _.-'                                   \0A |`-._`-._    `-.__.-'    _.-'_.-'|                                  \0A |    `-._`-._        _.-'_.-'    |           https://redis.io       \0A  `-._    `-._`-.__.-'_.-'    _.-'                                   \0A |`-._`-._    `-.__.-'    _.-'_.-'|                                  \0A |    `-._`-._        _.-'_.-'    |                                  \0A  `-._    `-._`-.__.-'_.-'    _.-'                                   \0A      `-._    `-.__.-'    _.-'                                       \0A          `-._        _.-'                                           \0A              `-.__.-'                                               \0A\0A\00", align 1
@.str.422 = private unnamed_addr constant [26 x i8] c"Running mode=%s, port=%d.\00", align 1
@.str.423 = private unnamed_addr constant [3 x i8] c"64\00", align 1
@.str.424 = private unnamed_addr constant [48 x i8] c"Unrecoverable error creating %s accept handler.\00", align 1
@.str.425 = private unnamed_addr constant [5 x i8] c"fork\00", align 1
@.str.426 = private unnamed_addr constant [15 x i8] c"redis-sentinel\00", align 1
@.str.427 = private unnamed_addr constant [11 x i8] c"--sentinel\00", align 1
@.str.428 = private unnamed_addr constant [46 x i8] c"DB loaded from append only file: %.3f seconds\00", align 1
@__const.loadDataFromDisk.rsi = private unnamed_addr constant %struct.rdbSaveInfo { i32 -1, i32 0, [41 x i8] c"0000000000000000000000000000000000000000\00", i64 -1 }, align 8
@.str.429 = private unnamed_addr constant [34 x i8] c"DB loaded from disk: %.3f seconds\00", align 1
@.str.430 = private unnamed_addr constant [20 x i8] c"server.repl_backlog\00", align 1
@.str.431 = private unnamed_addr constant [56 x i8] c"Fatal error loading the DB, check server logs. Exiting.\00", align 1
@.str.432 = private unnamed_addr constant [36 x i8] c"Out Of Memory allocating %zu bytes!\00", align 1
@.str.433 = private unnamed_addr constant [56 x i8] c"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!\00", align 1
@.str.434 = private unnamed_addr constant [52 x i8] c"systemd supervision error: NOTIFY_SOCKET not found!\00", align 1
@.str.435 = private unnamed_addr constant [41 x i8] c"systemd supervision error: sd_notify: %d\00", align 1
@.str.436 = private unnamed_addr constant [12 x i8] c"UPSTART_JOB\00", align 1
@.str.437 = private unnamed_addr constant [30 x i8] c"Upstart supervision detected.\00", align 1
@.str.438 = private unnamed_addr constant [14 x i8] c"NOTIFY_SOCKET\00", align 1
@.str.439 = private unnamed_addr constant [30 x i8] c"Systemd supervision detected.\00", align 1
@.str.440 = private unnamed_addr constant [16 x i8] c"redis-check-rdb\00", align 1
@.str.441 = private unnamed_addr constant [16 x i8] c"redis-check-aof\00", align 1
@.str.442 = private unnamed_addr constant [3 x i8] c"-v\00", align 1
@.str.443 = private unnamed_addr constant [10 x i8] c"--version\00", align 1
@.str.444 = private unnamed_addr constant [7 x i8] c"--help\00", align 1
@.str.445 = private unnamed_addr constant [3 x i8] c"-h\00", align 1
@.str.446 = private unnamed_addr constant [14 x i8] c"--test-memory\00", align 1
@.str.447 = private unnamed_addr constant [59 x i8] c"Please specify the amount of memory to test in megabytes.\0A\00", align 1
@.str.448 = private unnamed_addr constant [45 x i8] c"Example: ./redis-server --test-memory 4096\0A\0A\00", align 1
@.str.449 = private unnamed_addr constant [15 x i8] c"--check-system\00", align 1
@.str.450 = private unnamed_addr constant [7 x i8] c"--save\00", align 1
@.str.451 = private unnamed_addr constant [3 x i8] c"\22\22\00", align 1
@.str.452 = private unnamed_addr constant [46 x i8] c"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\00", align 1
@.str.453 = private unnamed_addr constant [72 x i8] c"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started\00", align 1
@.str.454 = private unnamed_addr constant [122 x i8] c"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/redis.conf\00", align 1
@.str.455 = private unnamed_addr constant [21 x i8] c"Configuration loaded\00", align 1
@.str.456 = private unnamed_addr constant [19 x i8] c"Server initialized\00", align 1
@.str.457 = private unnamed_addr constant [38 x i8] c"verifyClusterConfigWithData() == C_OK\00", align 1
@.str.458 = private unnamed_addr constant [31 x i8] c"Ready to accept connections %s\00", align 1
@.str.459 = private unnamed_addr constant [36 x i8] c"STATUS=Ready to accept connections\0A\00", align 1
@.str.460 = private unnamed_addr constant [91 x i8] c"STATUS=Ready to accept connections in read-only mode. Waiting for MASTER <-> REPLICA sync\0A\00", align 1
@.str.461 = private unnamed_addr constant [9 x i8] c"READY=1\0A\00", align 1
@.str.462 = private unnamed_addr constant [137 x i8] c"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?\00", align 1
@.str.463 = private unnamed_addr constant [12 x i8] c"rop->target\00", align 1
@.str.464 = private unnamed_addr constant [82 x i8] c"!(isPausedActions(PAUSE_ACTION_REPLICA) && (!server.client_pause_in_transaction))\00", align 1
@.str.465 = private unnamed_addr constant [39 x i8] c"Received SIGINT scheduling shutdown...\00", align 1
@.str.466 = private unnamed_addr constant [40 x i8] c"Received SIGTERM scheduling shutdown...\00", align 1
@.str.467 = private unnamed_addr constant [49 x i8] c"Received shutdown signal, scheduling shutdown...\00", align 1
@.str.468 = private unnamed_addr constant [27 x i8] c"You insist... exiting now.\00", align 1
@.str.469 = private unnamed_addr constant [62 x i8] c"Received shutdown signal during loading, scheduling shutdown.\00", align 1
@.str.470 = private unnamed_addr constant [40 x i8] c"Received SIGUSR1 in child, exiting now.\00", align 1
@.str.471 = private unnamed_addr constant [6 x i8] c"title\00", align 1
@.str.472 = private unnamed_addr constant [12 x i8] c"listen-addr\00", align 1
@.str.473 = private unnamed_addr constant [6 x i8] c"%s:%u\00", align 1
@.str.474 = private unnamed_addr constant [14 x i8] c"unixsocket:%s\00", align 1
@.str.475 = private unnamed_addr constant [12 x i8] c"server-mode\00", align 1
@.str.476 = private unnamed_addr constant [10 x i8] c"[cluster]\00", align 1
@.str.477 = private unnamed_addr constant [11 x i8] c"[sentinel]\00", align 1
@.str.478 = private unnamed_addr constant [12 x i8] c"config-file\00", align 1
@.str.479 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.480 = private unnamed_addr constant [5 x i8] c"port\00", align 1
@.str.481 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@.str.482 = private unnamed_addr constant [9 x i8] c"tls-port\00", align 1
@.str.483 = private unnamed_addr constant [11 x i8] c"unixsocket\00", align 1
@.str.484 = private unnamed_addr constant [58 x i8] c"upstart supervision requested, but UPSTART_JOB not found!\00", align 1
@.str.485 = private unnamed_addr constant [54 x i8] c"supervised by upstart, will stop to signal readiness.\00", align 1
@.str.486 = private unnamed_addr constant [28 x i8] c"STATUS=Redis is loading...\0A\00", align 1
@.str.487 = private unnamed_addr constant [128 x i8] c"Supervised by systemd. Please make sure you set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit.\00", align 1

; Function Attrs: nounwind uwtable
define dso_local void @serverLogRaw(i32 noundef %level, ptr noundef %msg) #0 {
entry:
  %level.addr = alloca i32, align 4
  %msg.addr = alloca ptr, align 8
  %syslogLevelMap = alloca [4 x i32], align 16
  %c = alloca ptr, align 8
  %fp = alloca ptr, align 8
  %buf = alloca [64 x i8], align 16
  %rawmode = alloca i32, align 4
  %log_to_stdout = alloca i32, align 4
  %off = alloca i32, align 4
  %tv = alloca %struct.timeval, align 8
  %role_char = alloca i32, align 4
  %pid = alloca i32, align 4
  %tm = alloca %struct.tm, align 8
  store i32 %level, ptr %level.addr, align 4
  store ptr %msg, ptr %msg.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %syslogLevelMap, ptr align 16 @__const.serverLogRaw.syslogLevelMap, i64 16, i1 false)
  store ptr @.str, ptr %c, align 8
  %0 = load i32, ptr %level.addr, align 4
  %and = and i32 %0, 1024
  store i32 %and, ptr %rawmode, align 4
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 250), align 8
  %arrayidx = getelementptr inbounds i8, ptr %1, i64 0
  %2 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  store i32 %conv1, ptr %log_to_stdout, align 4
  %3 = load i32, ptr %level.addr, align 4
  %and2 = and i32 %3, 255
  store i32 %and2, ptr %level.addr, align 4
  %4 = load i32, ptr %level.addr, align 4
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp3 = icmp slt i32 %4, %5
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end45

if.end:                                           ; preds = %entry
  %6 = load i32, ptr %log_to_stdout, align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %7 = load ptr, ptr @stdout, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 250), align 8
  %call = call noalias ptr @fopen64(ptr noundef %8, ptr noundef @.str.1)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %7, %cond.true ], [ %call, %cond.false ]
  store ptr %cond, ptr %fp, align 8
  %9 = load ptr, ptr %fp, align 8
  %tobool5 = icmp ne ptr %9, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %cond.end
  br label %if.end45

if.end7:                                          ; preds = %cond.end
  %10 = load i32, ptr %rawmode, align 4
  %tobool8 = icmp ne i32 %10, 0
  br i1 %tobool8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end7
  %11 = load ptr, ptr %fp, align 8
  %12 = load ptr, ptr %msg.addr, align 8
  %call10 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %11, ptr noundef @.str.2, ptr noundef %12)
  br label %if.end35

if.else:                                          ; preds = %if.end7
  %call11 = call i32 @getpid() #13
  store i32 %call11, ptr %pid, align 4
  %call12 = call i32 @gettimeofday(ptr noundef %tv, ptr noundef null) #13
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 0
  %13 = load i64, ptr %tv_sec, align 8
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 350), align 8
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 351), align 8
  call void @nolocks_localtime(ptr noundef %tm, i64 noundef %13, i64 noundef %14, i32 noundef %15)
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call13 = call i64 @strftime(ptr noundef %arraydecay, i64 noundef 64, ptr noundef @.str.3, ptr noundef %tm) #13
  %conv14 = trunc i64 %call13 to i32
  store i32 %conv14, ptr %off, align 4
  %arraydecay15 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %16 = load i32, ptr %off, align 4
  %idx.ext = sext i32 %16 to i64
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay15, i64 %idx.ext
  %17 = load i32, ptr %off, align 4
  %conv16 = sext i32 %17 to i64
  %sub = sub i64 64, %conv16
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 1
  %18 = load i64, ptr %tv_usec, align 8
  %conv17 = trunc i64 %18 to i32
  %div = sdiv i32 %conv17, 1000
  %call18 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %add.ptr, i64 noundef %sub, ptr noundef @.str.4, i32 noundef %div) #13
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool19 = icmp ne i32 %19, 0
  br i1 %tobool19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.else
  store i32 88, ptr %role_char, align 4
  br label %if.end29

if.else21:                                        ; preds = %if.else
  %20 = load i32, ptr %pid, align 4
  %21 = load i32, ptr @server, align 8
  %cmp22 = icmp ne i32 %20, %21
  br i1 %cmp22, label %if.then24, label %if.else25

if.then24:                                        ; preds = %if.else21
  store i32 67, ptr %role_char, align 4
  br label %if.end28

if.else25:                                        ; preds = %if.else21
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool26 = icmp ne ptr %22, null
  %cond27 = select i1 %tobool26, i32 83, i32 77
  store i32 %cond27, ptr %role_char, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.else25, %if.then24
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then20
  %23 = load ptr, ptr %fp, align 8
  %call30 = call i32 @getpid() #13
  %24 = load i32, ptr %role_char, align 4
  %arraydecay31 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %25 = load ptr, ptr %c, align 8
  %26 = load i32, ptr %level.addr, align 4
  %idxprom = sext i32 %26 to i64
  %arrayidx32 = getelementptr inbounds i8, ptr %25, i64 %idxprom
  %27 = load i8, ptr %arrayidx32, align 1
  %conv33 = sext i8 %27 to i32
  %28 = load ptr, ptr %msg.addr, align 8
  %call34 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %23, ptr noundef @.str.5, i32 noundef %call30, i32 noundef %24, ptr noundef %arraydecay31, i32 noundef %conv33, ptr noundef %28)
  br label %if.end35

if.end35:                                         ; preds = %if.end29, %if.then9
  %29 = load ptr, ptr %fp, align 8
  %call36 = call i32 @fflush(ptr noundef %29)
  %30 = load i32, ptr %log_to_stdout, align 4
  %tobool37 = icmp ne i32 %30, 0
  br i1 %tobool37, label %if.end40, label %if.then38

if.then38:                                        ; preds = %if.end35
  %31 = load ptr, ptr %fp, align 8
  %call39 = call i32 @fclose(ptr noundef %31)
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.end35
  %32 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 251), align 8
  %tobool41 = icmp ne i32 %32, 0
  br i1 %tobool41, label %if.then42, label %if.end45

if.then42:                                        ; preds = %if.end40
  %33 = load i32, ptr %level.addr, align 4
  %idxprom43 = sext i32 %33 to i64
  %arrayidx44 = getelementptr inbounds [4 x i32], ptr %syslogLevelMap, i64 0, i64 %idxprom43
  %34 = load i32, ptr %arrayidx44, align 4
  %35 = load ptr, ptr %msg.addr, align 8
  call void (i32, ptr, ...) @syslog(i32 noundef %34, ptr noundef @.str.2, ptr noundef %35)
  br label %if.end45

if.end45:                                         ; preds = %if.then42, %if.end40, %if.then6, %if.then
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1

declare noalias ptr @fopen64(ptr noundef, ptr noundef) #2

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #2

; Function Attrs: nounwind
declare i32 @getpid() #3

; Function Attrs: nounwind
declare i32 @gettimeofday(ptr noundef, ptr noundef) #3

declare void @nolocks_localtime(ptr noundef, i64 noundef, i64 noundef, i32 noundef) #2

; Function Attrs: nounwind
declare i64 @strftime(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #3

declare i32 @fflush(ptr noundef) #2

declare i32 @fclose(ptr noundef) #2

declare void @syslog(i32 noundef, ptr noundef, ...) #2

; Function Attrs: nounwind uwtable
define dso_local void @_serverLog(i32 noundef %level, ptr noundef %fmt, ...) #0 {
entry:
  %level.addr = alloca i32, align 4
  %fmt.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %msg = alloca [1024 x i8], align 16
  store i32 %level, ptr %level.addr, align 4
  store ptr %fmt, ptr %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %arraydecay1 = getelementptr inbounds [1024 x i8], ptr %msg, i64 0, i64 0
  %0 = load ptr, ptr %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call = call i32 @vsnprintf(ptr noundef %arraydecay1, i64 noundef 1024, ptr noundef %0, ptr noundef %arraydecay2) #13
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay3)
  %1 = load i32, ptr %level.addr, align 4
  %arraydecay4 = getelementptr inbounds [1024 x i8], ptr %msg, i64 0, i64 0
  call void @serverLogRaw(i32 noundef %1, ptr noundef %arraydecay4)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #4

; Function Attrs: nounwind
declare i32 @vsnprintf(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #3

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #4

; Function Attrs: nounwind uwtable
define dso_local void @serverLogRawFromHandler(i32 noundef %level, ptr noundef %msg) #0 {
entry:
  %level.addr = alloca i32, align 4
  %msg.addr = alloca ptr, align 8
  %fd = alloca i32, align 4
  %log_to_stdout = alloca i32, align 4
  %buf = alloca [64 x i8], align 16
  store i32 %level, ptr %level.addr, align 4
  store ptr %msg, ptr %msg.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 250), align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  store i32 %conv1, ptr %log_to_stdout, align 4
  %2 = load i32, ptr %level.addr, align 4
  %and = and i32 %2, 255
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp2 = icmp slt i32 %and, %3
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i32, ptr %log_to_stdout, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 176), align 4
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %if.end66

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %6 = load i32, ptr %log_to_stdout, align 4
  %tobool5 = icmp ne i32 %6, 0
  br i1 %tobool5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 250), align 8
  %call = call i32 (ptr, i32, ...) @open64(ptr noundef %7, i32 noundef 1089, i32 noundef 420)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 1, %cond.true ], [ %call, %cond.false ]
  store i32 %cond, ptr %fd, align 4
  %8 = load i32, ptr %fd, align 4
  %cmp6 = icmp eq i32 %8, -1
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %cond.end
  br label %if.end66

if.end9:                                          ; preds = %cond.end
  %9 = load i32, ptr %level.addr, align 4
  %and10 = and i32 %9, 1024
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end9
  %10 = load i32, ptr %fd, align 4
  %11 = load ptr, ptr %msg.addr, align 8
  %12 = load ptr, ptr %msg.addr, align 8
  %call13 = call i64 @strlen(ptr noundef %12) #14
  %call14 = call i64 @write(i32 noundef %10, ptr noundef %11, i64 noundef %call13)
  %cmp15 = icmp eq i64 %call14, -1
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then12
  br label %err

if.end18:                                         ; preds = %if.then12
  br label %if.end62

if.else:                                          ; preds = %if.end9
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call19 = call i32 @getpid() #13
  %conv20 = sext i32 %call19 to i64
  %call21 = call i32 @ll2string(ptr noundef %arraydecay, i64 noundef 64, i64 noundef %conv20)
  %13 = load i32, ptr %fd, align 4
  %arraydecay22 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %arraydecay23 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call24 = call i64 @strlen(ptr noundef %arraydecay23) #14
  %call25 = call i64 @write(i32 noundef %13, ptr noundef %arraydecay22, i64 noundef %call24)
  %cmp26 = icmp eq i64 %call25, -1
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.else
  br label %err

if.end29:                                         ; preds = %if.else
  %14 = load i32, ptr %fd, align 4
  %call30 = call i64 @write(i32 noundef %14, ptr noundef @.str.6, i64 noundef 17)
  %cmp31 = icmp eq i64 %call30, -1
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end29
  br label %err

if.end34:                                         ; preds = %if.end29
  %arraydecay35 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call36 = call i64 @time(ptr noundef null) #13
  %call37 = call i32 @ll2string(ptr noundef %arraydecay35, i64 noundef 64, i64 noundef %call36)
  %15 = load i32, ptr %fd, align 4
  %arraydecay38 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %arraydecay39 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call40 = call i64 @strlen(ptr noundef %arraydecay39) #14
  %call41 = call i64 @write(i32 noundef %15, ptr noundef %arraydecay38, i64 noundef %call40)
  %cmp42 = icmp eq i64 %call41, -1
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end34
  br label %err

if.end45:                                         ; preds = %if.end34
  %16 = load i32, ptr %fd, align 4
  %call46 = call i64 @write(i32 noundef %16, ptr noundef @.str.7, i64 noundef 2)
  %cmp47 = icmp eq i64 %call46, -1
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end45
  br label %err

if.end50:                                         ; preds = %if.end45
  %17 = load i32, ptr %fd, align 4
  %18 = load ptr, ptr %msg.addr, align 8
  %19 = load ptr, ptr %msg.addr, align 8
  %call51 = call i64 @strlen(ptr noundef %19) #14
  %call52 = call i64 @write(i32 noundef %17, ptr noundef %18, i64 noundef %call51)
  %cmp53 = icmp eq i64 %call52, -1
  br i1 %cmp53, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end50
  br label %err

if.end56:                                         ; preds = %if.end50
  %20 = load i32, ptr %fd, align 4
  %call57 = call i64 @write(i32 noundef %20, ptr noundef @.str.8, i64 noundef 1)
  %cmp58 = icmp eq i64 %call57, -1
  br i1 %cmp58, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end56
  br label %err

if.end61:                                         ; preds = %if.end56
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %if.end18
  br label %err

err:                                              ; preds = %if.end62, %if.then60, %if.then55, %if.then49, %if.then44, %if.then33, %if.then28, %if.then17
  %21 = load i32, ptr %log_to_stdout, align 4
  %tobool63 = icmp ne i32 %21, 0
  br i1 %tobool63, label %if.end66, label %if.then64

if.then64:                                        ; preds = %err
  %22 = load i32, ptr %fd, align 4
  %call65 = call i32 @close(i32 noundef %22)
  br label %if.end66

if.end66:                                         ; preds = %if.then64, %err, %if.then8, %if.then
  ret void
}

declare i32 @open64(ptr noundef, i32 noundef, ...) #2

declare i64 @write(i32 noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #5

declare i32 @ll2string(ptr noundef, i64 noundef, i64 noundef) #2

; Function Attrs: nounwind
declare i64 @time(ptr noundef) #3

declare i32 @close(i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @serverLogFromHandler(i32 noundef %level, ptr noundef %fmt, ...) #0 {
entry:
  %level.addr = alloca i32, align 4
  %fmt.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %msg = alloca [1024 x i8], align 16
  store i32 %level, ptr %level.addr, align 4
  store ptr %fmt, ptr %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %arraydecay1 = getelementptr inbounds [1024 x i8], ptr %msg, i64 0, i64 0
  %0 = load ptr, ptr %fmt.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call = call i32 @vsnprintf_async_signal_safe(ptr noundef %arraydecay1, i64 noundef 1024, ptr noundef %0, ptr noundef %arraydecay2)
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay3)
  %1 = load i32, ptr %level.addr, align 4
  %arraydecay4 = getelementptr inbounds [1024 x i8], ptr %msg, i64 0, i64 0
  call void @serverLogRawFromHandler(i32 noundef %1, ptr noundef %arraydecay4)
  ret void
}

declare i32 @vsnprintf_async_signal_safe(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i64 @ustime() #0 {
entry:
  %tv = alloca %struct.timeval, align 8
  %ust = alloca i64, align 8
  %call = call i32 @gettimeofday(ptr noundef %tv, ptr noundef null) #13
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 0
  %0 = load i64, ptr %tv_sec, align 8
  %mul = mul nsw i64 %0, 1000000
  store i64 %mul, ptr %ust, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 1
  %1 = load i64, ptr %tv_usec, align 8
  %2 = load i64, ptr %ust, align 8
  %add = add nsw i64 %2, %1
  store i64 %add, ptr %ust, align 8
  %3 = load i64, ptr %ust, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define dso_local i64 @mstime() #0 {
entry:
  %call = call i64 @ustime()
  %div = sdiv i64 %call, 1000
  ret i64 %div
}

; Function Attrs: nounwind uwtable
define dso_local i64 @commandTimeSnapshot() #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 354), align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define dso_local void @exitFromChild(i32 noundef %retcode) #0 {
entry:
  %retcode.addr = alloca i32, align 4
  store i32 %retcode, ptr %retcode.addr, align 4
  %0 = load i32, ptr %retcode.addr, align 4
  call void @_exit(i32 noundef %0) #15
  unreachable
}

; Function Attrs: noreturn
declare void @_exit(i32 noundef) #6

; Function Attrs: nounwind uwtable
define dso_local void @dictVanillaFree(ptr noundef %d, ptr noundef %val) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %val.addr, align 8
  call void @zfree(ptr noundef %0)
  ret void
}

declare void @zfree(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @dictListDestructor(ptr noundef %d, ptr noundef %val) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %val.addr, align 8
  call void @listRelease(ptr noundef %0)
  ret void
}

declare void @listRelease(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @dictSdsKeyCompare(ptr noundef %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %retval = alloca i32, align 4
  %d.addr = alloca ptr, align 8
  %key1.addr = alloca ptr, align 8
  %key2.addr = alloca ptr, align 8
  %l1 = alloca i32, align 4
  %l2 = alloca i32, align 4
  store ptr %d, ptr %d.addr, align 8
  store ptr %key1, ptr %key1.addr, align 8
  store ptr %key2, ptr %key2.addr, align 8
  %0 = load ptr, ptr %key1.addr, align 8
  %call = call i64 @sdslen(ptr noundef %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %l1, align 4
  %1 = load ptr, ptr %key2.addr, align 8
  %call1 = call i64 @sdslen(ptr noundef %1)
  %conv2 = trunc i64 %call1 to i32
  store i32 %conv2, ptr %l2, align 4
  %2 = load i32, ptr %l1, align 4
  %3 = load i32, ptr %l2, align 4
  %cmp = icmp ne i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %key1.addr, align 8
  %5 = load ptr, ptr %key2.addr, align 8
  %6 = load i32, ptr %l1, align 4
  %conv4 = sext i32 %6 to i64
  %call5 = call i32 @memcmp(ptr noundef %4, ptr noundef %5, i64 noundef %conv4) #14
  %cmp6 = icmp eq i32 %call5, 0
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i64 @sdslen(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %flags = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %flags, align 1
  %2 = load i8, ptr %flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %3 = load i8, ptr %flags, align 1
  %conv1 = zext i8 %3 to i32
  %shr = ashr i32 %conv1, 3
  %conv2 = sext i32 %shr to i64
  store i64 %conv2, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 -3
  %len = getelementptr inbounds %struct.sdshdr8, ptr %add.ptr, i32 0, i32 0
  %5 = load i8, ptr %len, align 1
  %conv4 = zext i8 %5 to i64
  store i64 %conv4, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  %6 = load ptr, ptr %s.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, ptr %6, i64 -5
  %len7 = getelementptr inbounds %struct.sdshdr16, ptr %add.ptr6, i32 0, i32 0
  %7 = load i16, ptr %len7, align 1
  %conv8 = zext i16 %7 to i64
  store i64 %conv8, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, ptr %8, i64 -9
  %len11 = getelementptr inbounds %struct.sdshdr32, ptr %add.ptr10, i32 0, i32 0
  %9 = load i32, ptr %len11, align 1
  %conv12 = zext i32 %9 to i64
  store i64 %conv12, ptr %retval, align 8
  br label %return

sw.bb13:                                          ; preds = %entry
  %10 = load ptr, ptr %s.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, ptr %10, i64 -17
  %len15 = getelementptr inbounds %struct.sdshdr64, ptr %add.ptr14, i32 0, i32 0
  %11 = load i64, ptr %len15, align 1
  store i64 %11, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #5

; Function Attrs: nounwind uwtable
define dso_local i32 @dictSdsKeyCaseCompare(ptr noundef %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key1.addr = alloca ptr, align 8
  %key2.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key1, ptr %key1.addr, align 8
  store ptr %key2, ptr %key2.addr, align 8
  %0 = load ptr, ptr %key1.addr, align 8
  %1 = load ptr, ptr %key2.addr, align 8
  %call = call i32 @strcasecmp(ptr noundef %0, ptr noundef %1) #14
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcasecmp(ptr noundef, ptr noundef) #5

; Function Attrs: nounwind uwtable
define dso_local void @dictObjectDestructor(ptr noundef %d, ptr noundef %val) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %val.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %val.addr, align 8
  call void @decrRefCount(ptr noundef %1)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @decrRefCount(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @dictSdsDestructor(ptr noundef %d, ptr noundef %val) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %val.addr, align 8
  call void @sdsfree(ptr noundef %0)
  ret void
}

declare void @sdsfree(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @dictSdsDup(ptr noundef %d, ptr noundef %key) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %call = call ptr @sdsdup(ptr noundef %0)
  ret ptr %call
}

declare ptr @sdsdup(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @dictObjKeyCompare(ptr noundef %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key1.addr = alloca ptr, align 8
  %key2.addr = alloca ptr, align 8
  %o1 = alloca ptr, align 8
  %o2 = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key1, ptr %key1.addr, align 8
  store ptr %key2, ptr %key2.addr, align 8
  %0 = load ptr, ptr %key1.addr, align 8
  store ptr %0, ptr %o1, align 8
  %1 = load ptr, ptr %key2.addr, align 8
  store ptr %1, ptr %o2, align 8
  %2 = load ptr, ptr %d.addr, align 8
  %3 = load ptr, ptr %o1, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ptr, align 8
  %5 = load ptr, ptr %o2, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ptr1, align 8
  %call = call i32 @dictSdsKeyCompare(ptr noundef %2, ptr noundef %4, ptr noundef %6)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dictObjHash(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %o = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  store ptr %0, ptr %o, align 8
  %1 = load ptr, ptr %o, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %3 = load ptr, ptr %o, align 8
  %ptr1 = getelementptr inbounds %struct.redisObject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ptr1, align 8
  %call = call i64 @sdslen(ptr noundef %4)
  %call2 = call i64 @dictGenHashFunction(ptr noundef %2, i64 noundef %call)
  ret i64 %call2
}

declare i64 @dictGenHashFunction(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i64 @dictSdsHash(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %call = call i64 @sdslen(ptr noundef %1)
  %call1 = call i64 @dictGenHashFunction(ptr noundef %0, i64 noundef %call)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dictSdsCaseHash(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %call = call i64 @sdslen(ptr noundef %1)
  %call1 = call i64 @dictGenCaseHashFunction(ptr noundef %0, i64 noundef %call)
  ret i64 %call1
}

declare i64 @dictGenCaseHashFunction(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i64 @dictCStrHash(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #14
  %call1 = call i64 @dictGenHashFunction(ptr noundef %0, i64 noundef %call)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dictCStrCaseHash(ptr noundef %key) #0 {
entry:
  %key.addr = alloca ptr, align 8
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %key.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #14
  %call1 = call i64 @dictGenCaseHashFunction(ptr noundef %0, i64 noundef %call)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define dso_local i32 @dictCStrKeyCompare(ptr noundef %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %retval = alloca i32, align 4
  %d.addr = alloca ptr, align 8
  %key1.addr = alloca ptr, align 8
  %key2.addr = alloca ptr, align 8
  %l1 = alloca i32, align 4
  %l2 = alloca i32, align 4
  store ptr %d, ptr %d.addr, align 8
  store ptr %key1, ptr %key1.addr, align 8
  store ptr %key2, ptr %key2.addr, align 8
  %0 = load ptr, ptr %key1.addr, align 8
  %call = call i64 @strlen(ptr noundef %0) #14
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %l1, align 4
  %1 = load ptr, ptr %key2.addr, align 8
  %call1 = call i64 @strlen(ptr noundef %1) #14
  %conv2 = trunc i64 %call1 to i32
  store i32 %conv2, ptr %l2, align 4
  %2 = load i32, ptr %l1, align 4
  %3 = load i32, ptr %l2, align 4
  %cmp = icmp ne i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %key1.addr, align 8
  %5 = load ptr, ptr %key2.addr, align 8
  %6 = load i32, ptr %l1, align 4
  %conv4 = sext i32 %6 to i64
  %call5 = call i32 @memcmp(ptr noundef %4, ptr noundef %5, i64 noundef %conv4) #14
  %cmp6 = icmp eq i32 %call5, 0
  %conv7 = zext i1 %cmp6 to i32
  store i32 %conv7, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define dso_local i32 @dictCStrKeyCaseCompare(ptr noundef %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %key1.addr = alloca ptr, align 8
  %key2.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %key1, ptr %key1.addr, align 8
  store ptr %key2, ptr %key2.addr, align 8
  %0 = load ptr, ptr %key1.addr, align 8
  %1 = load ptr, ptr %key2.addr, align 8
  %call = call i32 @strcasecmp(ptr noundef %0, ptr noundef %1) #14
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @dictEncObjKeyCompare(ptr noundef %d, ptr noundef %key1, ptr noundef %key2) #0 {
entry:
  %retval = alloca i32, align 4
  %d.addr = alloca ptr, align 8
  %key1.addr = alloca ptr, align 8
  %key2.addr = alloca ptr, align 8
  %o1 = alloca ptr, align 8
  %o2 = alloca ptr, align 8
  %cmp = alloca i32, align 4
  store ptr %d, ptr %d.addr, align 8
  store ptr %key1, ptr %key1.addr, align 8
  store ptr %key2, ptr %key2.addr, align 8
  %0 = load ptr, ptr %key1.addr, align 8
  store ptr %0, ptr %o1, align 8
  %1 = load ptr, ptr %key2.addr, align 8
  store ptr %1, ptr %o2, align 8
  %2 = load ptr, ptr %o1, align 8
  %bf.load = load i32, ptr %2, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  %cmp1 = icmp eq i32 %bf.clear, 1
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %o2, align 8
  %bf.load2 = load i32, ptr %3, align 8
  %bf.lshr3 = lshr i32 %bf.load2, 4
  %bf.clear4 = and i32 %bf.lshr3, 15
  %cmp5 = icmp eq i32 %bf.clear4, 1
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load ptr, ptr %o1, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %ptr, align 8
  %6 = load ptr, ptr %o2, align 8
  %ptr6 = getelementptr inbounds %struct.redisObject, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %ptr6, align 8
  %cmp7 = icmp eq ptr %5, %7
  %conv = zext i1 %cmp7 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %8 = load ptr, ptr %o1, align 8
  %refcount = getelementptr inbounds %struct.redisObject, ptr %8, i32 0, i32 1
  %9 = load i32, ptr %refcount, align 4
  %cmp8 = icmp ne i32 %9, 2147483646
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  %10 = load ptr, ptr %o1, align 8
  %call = call ptr @getDecodedObject(ptr noundef %10)
  store ptr %call, ptr %o1, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end
  %11 = load ptr, ptr %o2, align 8
  %refcount12 = getelementptr inbounds %struct.redisObject, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %refcount12, align 4
  %cmp13 = icmp ne i32 %12, 2147483646
  br i1 %cmp13, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end11
  %13 = load ptr, ptr %o2, align 8
  %call16 = call ptr @getDecodedObject(ptr noundef %13)
  store ptr %call16, ptr %o2, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.end11
  %14 = load ptr, ptr %d.addr, align 8
  %15 = load ptr, ptr %o1, align 8
  %ptr18 = getelementptr inbounds %struct.redisObject, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %ptr18, align 8
  %17 = load ptr, ptr %o2, align 8
  %ptr19 = getelementptr inbounds %struct.redisObject, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %ptr19, align 8
  %call20 = call i32 @dictSdsKeyCompare(ptr noundef %14, ptr noundef %16, ptr noundef %18)
  store i32 %call20, ptr %cmp, align 4
  %19 = load ptr, ptr %o1, align 8
  %refcount21 = getelementptr inbounds %struct.redisObject, ptr %19, i32 0, i32 1
  %20 = load i32, ptr %refcount21, align 4
  %cmp22 = icmp ne i32 %20, 2147483646
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end17
  %21 = load ptr, ptr %o1, align 8
  call void @decrRefCount(ptr noundef %21)
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.end17
  %22 = load ptr, ptr %o2, align 8
  %refcount26 = getelementptr inbounds %struct.redisObject, ptr %22, i32 0, i32 1
  %23 = load i32, ptr %refcount26, align 4
  %cmp27 = icmp ne i32 %23, 2147483646
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.end25
  %24 = load ptr, ptr %o2, align 8
  call void @decrRefCount(ptr noundef %24)
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end25
  %25 = load i32, ptr %cmp, align 4
  store i32 %25, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end30, %if.then
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

declare ptr @getDecodedObject(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i64 @dictEncObjHash(ptr noundef %key) #0 {
entry:
  %retval = alloca i64, align 8
  %key.addr = alloca ptr, align 8
  %o = alloca ptr, align 8
  %buf = alloca [32 x i8], align 16
  %len = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  %0 = load ptr, ptr %key.addr, align 8
  store ptr %0, ptr %o, align 8
  %1 = load ptr, ptr %o, align 8
  %bf.load = load i32, ptr %1, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  %cmp = icmp eq i32 %bf.clear, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %o, align 8
  %bf.load1 = load i32, ptr %2, align 8
  %bf.lshr2 = lshr i32 %bf.load1, 4
  %bf.clear3 = and i32 %bf.lshr2, 15
  %cmp4 = icmp eq i32 %bf.clear3, 8
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load ptr, ptr %o, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ptr, align 8
  %5 = load ptr, ptr %o, align 8
  %ptr5 = getelementptr inbounds %struct.redisObject, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ptr5, align 8
  %call = call i64 @sdslen(ptr noundef %6)
  %call6 = call i64 @dictGenHashFunction(ptr noundef %4, i64 noundef %call)
  store i64 %call6, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %7 = load ptr, ptr %o, align 8
  %bf.load7 = load i32, ptr %7, align 8
  %bf.lshr8 = lshr i32 %bf.load7, 4
  %bf.clear9 = and i32 %bf.lshr8, 15
  %cmp10 = icmp eq i32 %bf.clear9, 1
  br i1 %cmp10, label %if.then11, label %if.else16

if.then11:                                        ; preds = %if.else
  %arraydecay = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 0
  %8 = load ptr, ptr %o, align 8
  %ptr12 = getelementptr inbounds %struct.redisObject, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %ptr12, align 8
  %10 = ptrtoint ptr %9 to i64
  %call13 = call i32 @ll2string(ptr noundef %arraydecay, i64 noundef 32, i64 noundef %10)
  store i32 %call13, ptr %len, align 4
  %arraydecay14 = getelementptr inbounds [32 x i8], ptr %buf, i64 0, i64 0
  %11 = load i32, ptr %len, align 4
  %conv = sext i32 %11 to i64
  %call15 = call i64 @dictGenHashFunction(ptr noundef %arraydecay14, i64 noundef %conv)
  store i64 %call15, ptr %retval, align 8
  br label %return

if.else16:                                        ; preds = %if.else
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 404, ptr noundef @.str.10)
  call void @abort() #16
  unreachable

return:                                           ; preds = %if.then11, %if.then
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

declare void @_serverPanic(ptr noundef, i32 noundef, ptr noundef, ...) #2

; Function Attrs: noreturn nounwind
declare void @abort() #7

; Function Attrs: nounwind uwtable
define dso_local i32 @dictExpandAllowed(i64 noundef %moreMem, double noundef %usedRatio) #0 {
entry:
  %retval = alloca i32, align 4
  %moreMem.addr = alloca i64, align 8
  %usedRatio.addr = alloca double, align 8
  store i64 %moreMem, ptr %moreMem.addr, align 8
  store double %usedRatio, ptr %usedRatio.addr, align 8
  %0 = load double, ptr %usedRatio.addr, align 8
  %cmp = fcmp ole double %0, 1.618000e+00
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %moreMem.addr, align 8
  %call = call i32 @overMaxmemoryAfterAlloc(i64 noundef %1)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

declare i32 @overMaxmemoryAfterAlloc(i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @dictRehashingStarted(ptr noundef %d, i32 noundef %keyType) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %keyType.addr = alloca i32, align 4
  %metadata = alloca ptr, align 8
  %from = alloca i64, align 8
  %to = alloca i64, align 8
  store ptr %d, ptr %d.addr, align 8
  store i32 %keyType, ptr %keyType.addr, align 4
  %0 = load ptr, ptr %d.addr, align 8
  %metadata1 = getelementptr inbounds %struct.dict, ptr %0, i32 0, i32 6
  store ptr %metadata1, ptr %metadata, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 11), align 8
  %2 = load ptr, ptr %d.addr, align 8
  %call = call ptr @listAddNodeTail(ptr noundef %1, ptr noundef %2)
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 11), align 8
  %tail = getelementptr inbounds %struct.list, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %tail, align 8
  %5 = load ptr, ptr %metadata, align 8
  %rehashing_node = getelementptr inbounds %struct.dbDictMetadata, ptr %5, i32 0, i32 0
  store ptr %4, ptr %rehashing_node, align 8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %7 = load ptr, ptr %d.addr, align 8
  call void @dictRehashingInfo(ptr noundef %7, ptr noundef %from, ptr noundef %to)
  %8 = load i64, ptr %to, align 8
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %9, i64 0
  %sub_dict = getelementptr inbounds %struct.redisDb, ptr %arrayidx, i32 0, i32 11
  %10 = load i32, ptr %keyType.addr, align 4
  %idxprom = zext i32 %10 to i64
  %arrayidx2 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict, i64 0, i64 %idxprom
  %bucket_count = getelementptr inbounds %struct.dbDictState, ptr %arrayidx2, i32 0, i32 3
  %11 = load i64, ptr %bucket_count, align 8
  %add = add i64 %11, %8
  store i64 %add, ptr %bucket_count, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare ptr @listAddNodeTail(ptr noundef, ptr noundef) #2

declare void @dictRehashingInfo(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @dictRehashingCompleted(ptr noundef %d, i32 noundef %keyType) #0 {
entry:
  %d.addr = alloca ptr, align 8
  %keyType.addr = alloca i32, align 4
  %metadata = alloca ptr, align 8
  %from = alloca i64, align 8
  %to = alloca i64, align 8
  store ptr %d, ptr %d.addr, align 8
  store i32 %keyType, ptr %keyType.addr, align 4
  %0 = load ptr, ptr %d.addr, align 8
  %metadata1 = getelementptr inbounds %struct.dict, ptr %0, i32 0, i32 6
  store ptr %metadata1, ptr %metadata, align 8
  %1 = load ptr, ptr %metadata, align 8
  %rehashing_node = getelementptr inbounds %struct.dbDictMetadata, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %rehashing_node, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 11), align 8
  %4 = load ptr, ptr %metadata, align 8
  %rehashing_node2 = getelementptr inbounds %struct.dbDictMetadata, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %rehashing_node2, align 8
  call void @listDelNode(ptr noundef %3, ptr noundef %5)
  %6 = load ptr, ptr %metadata, align 8
  %rehashing_node3 = getelementptr inbounds %struct.dbDictMetadata, ptr %6, i32 0, i32 0
  store ptr null, ptr %rehashing_node3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool4 = icmp ne i32 %7, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %d.addr, align 8
  call void @dictRehashingInfo(ptr noundef %8, ptr noundef %from, ptr noundef %to)
  %9 = load i64, ptr %from, align 8
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %10, i64 0
  %sub_dict = getelementptr inbounds %struct.redisDb, ptr %arrayidx, i32 0, i32 11
  %11 = load i32, ptr %keyType.addr, align 4
  %idxprom = zext i32 %11 to i64
  %arrayidx7 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict, i64 0, i64 %idxprom
  %bucket_count = getelementptr inbounds %struct.dbDictState, ptr %arrayidx7, i32 0, i32 3
  %12 = load i64, ptr %bucket_count, align 8
  %sub = sub i64 %12, %9
  store i64 %sub, ptr %bucket_count, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then5
  ret void
}

declare void @listDelNode(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @dbDictRehashingStarted(ptr noundef %d) #0 {
entry:
  %d.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  call void @dictRehashingStarted(ptr noundef %0, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @dbDictRehashingCompleted(ptr noundef %d) #0 {
entry:
  %d.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  call void @dictRehashingCompleted(ptr noundef %0, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @dbExpiresRehashingStarted(ptr noundef %d) #0 {
entry:
  %d.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  call void @dictRehashingStarted(ptr noundef %0, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @dbExpiresRehashingCompleted(ptr noundef %d) #0 {
entry:
  %d.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %d.addr, align 8
  call void @dictRehashingCompleted(ptr noundef %0, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @dbDictMetadataSize(ptr noundef %d) #0 {
entry:
  %d.addr = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  ret i64 8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @htNeedsResize(ptr noundef %dict) #0 {
entry:
  %dict.addr = alloca ptr, align 8
  %size = alloca i64, align 8
  %used = alloca i64, align 8
  store ptr %dict, ptr %dict.addr, align 8
  %0 = load ptr, ptr %dict.addr, align 8
  %ht_size_exp = getelementptr inbounds %struct.dict, ptr %0, i32 0, i32 5
  %arrayidx = getelementptr inbounds [2 x i8], ptr %ht_size_exp, i64 0, i64 0
  %1 = load i8, ptr %arrayidx, align 2
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, -1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load ptr, ptr %dict.addr, align 8
  %ht_size_exp2 = getelementptr inbounds %struct.dict, ptr %2, i32 0, i32 5
  %arrayidx3 = getelementptr inbounds [2 x i8], ptr %ht_size_exp2, i64 0, i64 0
  %3 = load i8, ptr %arrayidx3, align 2
  %conv4 = sext i8 %3 to i32
  %sh_prom = zext i32 %conv4 to i64
  %shl = shl i64 1, %sh_prom
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %shl, %cond.false ]
  %4 = load ptr, ptr %dict.addr, align 8
  %ht_size_exp5 = getelementptr inbounds %struct.dict, ptr %4, i32 0, i32 5
  %arrayidx6 = getelementptr inbounds [2 x i8], ptr %ht_size_exp5, i64 0, i64 1
  %5 = load i8, ptr %arrayidx6, align 1
  %conv7 = sext i8 %5 to i32
  %cmp8 = icmp eq i32 %conv7, -1
  br i1 %cmp8, label %cond.true10, label %cond.false11

cond.true10:                                      ; preds = %cond.end
  br label %cond.end17

cond.false11:                                     ; preds = %cond.end
  %6 = load ptr, ptr %dict.addr, align 8
  %ht_size_exp12 = getelementptr inbounds %struct.dict, ptr %6, i32 0, i32 5
  %arrayidx13 = getelementptr inbounds [2 x i8], ptr %ht_size_exp12, i64 0, i64 1
  %7 = load i8, ptr %arrayidx13, align 1
  %conv14 = sext i8 %7 to i32
  %sh_prom15 = zext i32 %conv14 to i64
  %shl16 = shl i64 1, %sh_prom15
  br label %cond.end17

cond.end17:                                       ; preds = %cond.false11, %cond.true10
  %cond18 = phi i64 [ 0, %cond.true10 ], [ %shl16, %cond.false11 ]
  %add = add i64 %cond, %cond18
  store i64 %add, ptr %size, align 8
  %8 = load ptr, ptr %dict.addr, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %8, i32 0, i32 2
  %arrayidx19 = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %9 = load i64, ptr %arrayidx19, align 8
  %10 = load ptr, ptr %dict.addr, align 8
  %ht_used20 = getelementptr inbounds %struct.dict, ptr %10, i32 0, i32 2
  %arrayidx21 = getelementptr inbounds [2 x i64], ptr %ht_used20, i64 0, i64 1
  %11 = load i64, ptr %arrayidx21, align 8
  %add22 = add i64 %9, %11
  store i64 %add22, ptr %used, align 8
  %12 = load i64, ptr %size, align 8
  %cmp23 = icmp sgt i64 %12, 4
  br i1 %cmp23, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.end17
  %13 = load i64, ptr %used, align 8
  %mul = mul nsw i64 %13, 100
  %14 = load i64, ptr %size, align 8
  %div = sdiv i64 %mul, %14
  %cmp25 = icmp slt i64 %div, 10
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.end17
  %15 = phi i1 [ false, %cond.end17 ], [ %cmp25, %land.rhs ]
  %land.ext = zext i1 %15 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define dso_local void @tryResizeHashTables(i32 noundef %dbid) #0 {
entry:
  %dbid.addr = alloca i32, align 4
  %db = alloca ptr, align 8
  %subdict = alloca i32, align 4
  %i = alloca i32, align 4
  %slot = alloca i32, align 4
  %d = alloca ptr, align 8
  store i32 %dbid, ptr %dbid.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %1 = load i32, ptr %dbid.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %0, i64 %idxprom
  store ptr %arrayidx, ptr %db, align 8
  store i32 0, ptr %subdict, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc38, %entry
  %2 = load i32, ptr %subdict, align 4
  %cmp = icmp ule i32 %2, 1
  br i1 %cmp, label %for.body, label %for.end40

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %db, align 8
  %4 = load i32, ptr %subdict, align 4
  %call = call i64 @dbSize(ptr noundef %3, i32 noundef %4)
  %cmp1 = icmp eq i64 %call, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc38

if.end:                                           ; preds = %for.body
  %5 = load ptr, ptr %db, align 8
  %sub_dict = getelementptr inbounds %struct.redisDb, ptr %5, i32 0, i32 11
  %6 = load i32, ptr %subdict, align 4
  %idxprom2 = zext i32 %6 to i64
  %arrayidx3 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict, i64 0, i64 %idxprom2
  %resize_cursor = getelementptr inbounds %struct.dbDictState, ptr %arrayidx3, i32 0, i32 0
  %7 = load i32, ptr %resize_cursor, align 8
  %cmp4 = icmp eq i32 %7, -1
  br i1 %cmp4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end
  %8 = load ptr, ptr %db, align 8
  %9 = load i32, ptr %subdict, align 4
  %call6 = call i32 @findSlotByKeyIndex(ptr noundef %8, i64 noundef 1, i32 noundef %9)
  %10 = load ptr, ptr %db, align 8
  %sub_dict7 = getelementptr inbounds %struct.redisDb, ptr %10, i32 0, i32 11
  %11 = load i32, ptr %subdict, align 4
  %idxprom8 = zext i32 %11 to i64
  %arrayidx9 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict7, i64 0, i64 %idxprom8
  %resize_cursor10 = getelementptr inbounds %struct.dbDictState, ptr %arrayidx9, i32 0, i32 0
  store i32 %call6, ptr %resize_cursor10, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then5, %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond12

for.cond12:                                       ; preds = %for.inc, %if.end11
  %12 = load i32, ptr %i, align 4
  %cmp13 = icmp slt i32 %12, 16
  br i1 %cmp13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond12
  %13 = load ptr, ptr %db, align 8
  %sub_dict14 = getelementptr inbounds %struct.redisDb, ptr %13, i32 0, i32 11
  %14 = load i32, ptr %subdict, align 4
  %idxprom15 = zext i32 %14 to i64
  %arrayidx16 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict14, i64 0, i64 %idxprom15
  %resize_cursor17 = getelementptr inbounds %struct.dbDictState, ptr %arrayidx16, i32 0, i32 0
  %15 = load i32, ptr %resize_cursor17, align 8
  %cmp18 = icmp ne i32 %15, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond12
  %16 = phi i1 [ false, %for.cond12 ], [ %cmp18, %land.rhs ]
  br i1 %16, label %for.body19, label %for.end

for.body19:                                       ; preds = %land.end
  %17 = load ptr, ptr %db, align 8
  %sub_dict20 = getelementptr inbounds %struct.redisDb, ptr %17, i32 0, i32 11
  %18 = load i32, ptr %subdict, align 4
  %idxprom21 = zext i32 %18 to i64
  %arrayidx22 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict20, i64 0, i64 %idxprom21
  %resize_cursor23 = getelementptr inbounds %struct.dbDictState, ptr %arrayidx22, i32 0, i32 0
  %19 = load i32, ptr %resize_cursor23, align 8
  store i32 %19, ptr %slot, align 4
  %20 = load i32, ptr %subdict, align 4
  %cmp24 = icmp eq i32 %20, 0
  br i1 %cmp24, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body19
  %21 = load ptr, ptr %db, align 8
  %dict = getelementptr inbounds %struct.redisDb, ptr %21, i32 0, i32 0
  %22 = load ptr, ptr %dict, align 8
  %23 = load i32, ptr %slot, align 4
  %idxprom25 = sext i32 %23 to i64
  %arrayidx26 = getelementptr inbounds ptr, ptr %22, i64 %idxprom25
  %24 = load ptr, ptr %arrayidx26, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body19
  %25 = load ptr, ptr %db, align 8
  %expires = getelementptr inbounds %struct.redisDb, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %expires, align 8
  %27 = load i32, ptr %slot, align 4
  %idxprom27 = sext i32 %27 to i64
  %arrayidx28 = getelementptr inbounds ptr, ptr %26, i64 %idxprom27
  %28 = load ptr, ptr %arrayidx28, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %24, %cond.true ], [ %28, %cond.false ]
  store ptr %cond, ptr %d, align 8
  %29 = load ptr, ptr %d, align 8
  %call29 = call i32 @htNeedsResize(ptr noundef %29)
  %tobool = icmp ne i32 %call29, 0
  br i1 %tobool, label %if.then30, label %if.end32

if.then30:                                        ; preds = %cond.end
  %30 = load ptr, ptr %d, align 8
  %call31 = call i32 @dictResize(ptr noundef %30)
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %cond.end
  %31 = load ptr, ptr %db, align 8
  %32 = load i32, ptr %slot, align 4
  %33 = load i32, ptr %subdict, align 4
  %call33 = call i32 @dbGetNextNonEmptySlot(ptr noundef %31, i32 noundef %32, i32 noundef %33)
  %34 = load ptr, ptr %db, align 8
  %sub_dict34 = getelementptr inbounds %struct.redisDb, ptr %34, i32 0, i32 11
  %35 = load i32, ptr %subdict, align 4
  %idxprom35 = zext i32 %35 to i64
  %arrayidx36 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict34, i64 0, i64 %idxprom35
  %resize_cursor37 = getelementptr inbounds %struct.dbDictState, ptr %arrayidx36, i32 0, i32 0
  store i32 %call33, ptr %resize_cursor37, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end32
  %36 = load i32, ptr %i, align 4
  %inc = add nsw i32 %36, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond12, !llvm.loop !5

for.end:                                          ; preds = %land.end
  br label %for.inc38

for.inc38:                                        ; preds = %for.end, %if.then
  %37 = load i32, ptr %subdict, align 4
  %inc39 = add i32 %37, 1
  store i32 %inc39, ptr %subdict, align 4
  br label %for.cond, !llvm.loop !7

for.end40:                                        ; preds = %for.cond
  ret void
}

declare i64 @dbSize(ptr noundef, i32 noundef) #2

declare i32 @findSlotByKeyIndex(ptr noundef, i64 noundef, i32 noundef) #2

declare i32 @dictResize(ptr noundef) #2

declare i32 @dbGetNextNonEmptySlot(ptr noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @incrementallyRehash() #0 {
entry:
  %retval = alloca i32, align 4
  %node = alloca ptr, align 8
  %timer = alloca i64, align 8
  %elapsed_us = alloca i64, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 11), align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 0, %2
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end3:                                          ; preds = %do.body
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 11), align 8
  %len4 = getelementptr inbounds %struct.list, ptr %3, i32 0, i32 5
  %4 = load i64, ptr %len4, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.11, i64 noundef %4)
  br label %do.end

do.end:                                           ; preds = %if.end3, %if.then2
  call void @elapsedStart(ptr noundef %timer)
  br label %while.cond

while.cond:                                       ; preds = %if.end7, %do.end
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 11), align 8
  %head = getelementptr inbounds %struct.list, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %head, align 8
  store ptr %6, ptr %node, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i64, ptr %timer, align 8
  %call = call i64 @elapsedUs(i64 noundef %7)
  store i64 %call, ptr %elapsed_us, align 8
  %8 = load i64, ptr %elapsed_us, align 8
  %cmp5 = icmp uge i64 %8, 1000
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %while.body
  br label %while.end

if.end7:                                          ; preds = %while.body
  %9 = load ptr, ptr %node, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %value, align 8
  %11 = load i64, ptr %elapsed_us, align 8
  %sub = sub i64 1000, %11
  %call8 = call i32 @dictRehashMicroseconds(ptr noundef %10, i64 noundef %sub)
  br label %while.cond, !llvm.loop !8

while.end:                                        ; preds = %if.then6, %while.cond
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal void @elapsedStart(ptr noundef %start_time) #0 {
entry:
  %start_time.addr = alloca ptr, align 8
  store ptr %start_time, ptr %start_time.addr, align 8
  %0 = load ptr, ptr @getMonotonicUs, align 8
  %call = call i64 %0()
  %1 = load ptr, ptr %start_time.addr, align 8
  store i64 %call, ptr %1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @elapsedUs(i64 noundef %start_time) #0 {
entry:
  %start_time.addr = alloca i64, align 8
  store i64 %start_time, ptr %start_time.addr, align 8
  %0 = load ptr, ptr @getMonotonicUs, align 8
  %call = call i64 %0()
  %1 = load i64, ptr %start_time.addr, align 8
  %sub = sub i64 %call, %1
  ret i64 %sub
}

declare i32 @dictRehashMicroseconds(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @updateDictResizePolicy() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 9), align 8
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @dictSetResizeEnabled(i32 noundef 2)
  br label %if.end3

if.else:                                          ; preds = %entry
  %call = call i32 @hasActiveChildProcess()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then1, label %if.else2

if.then1:                                         ; preds = %if.else
  call void @dictSetResizeEnabled(i32 noundef 1)
  br label %if.end

if.else2:                                         ; preds = %if.else
  call void @dictSetResizeEnabled(i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.else2, %if.then1
  br label %if.end3

if.end3:                                          ; preds = %if.end, %if.then
  ret void
}

declare void @dictSetResizeEnabled(i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @hasActiveChildProcess() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %cmp = icmp ne i32 %0, -1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local ptr @strChildType(i32 noundef %type) #0 {
entry:
  %retval = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb1
    i32 3, label %sw.bb2
    i32 4, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  store ptr @.str.12, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  store ptr @.str.13, ptr %retval, align 8
  br label %return

sw.bb2:                                           ; preds = %entry
  store ptr @.str.14, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  store ptr @.str.15, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  store ptr @.str.16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define dso_local void @resetChildState() #0 {
entry:
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 128), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 129), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 130), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 131), align 8
  store double 0.000000e+00, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 136), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 132), align 8
  call void @updateDictResizePolicy()
  call void @closeChildInfoPipe()
  call void @moduleFireServerEvent(i64 noundef 13, i32 noundef 1, ptr noundef null)
  ret void
}

declare void @closeChildInfoPipe() #2

declare void @moduleFireServerEvent(i64 noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @isMutuallyExclusiveChildType(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 2
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32, ptr %type.addr, align 4
  %cmp2 = icmp eq i32 %2, 4
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isInsideYieldingLongCommand() #0 {
entry:
  %call = call i32 @scriptIsTimedout()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %tobool1 = icmp ne i32 %0, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %tobool1, %lor.rhs ]
  %lor.ext = zext i1 %1 to i32
  ret i32 %lor.ext
}

declare i32 @scriptIsTimedout() #2

; Function Attrs: nounwind uwtable
define dso_local i32 @allPersistenceDisabled() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 224), align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp1 = icmp eq i32 %1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define dso_local void @trackInstantaneousMetric(i32 noundef %metric, i64 noundef %current_value, i64 noundef %current_base, i64 noundef %factor) #0 {
entry:
  %metric.addr = alloca i32, align 4
  %current_value.addr = alloca i64, align 8
  %current_base.addr = alloca i64, align 8
  %factor.addr = alloca i64, align 8
  %base = alloca i64, align 8
  %value = alloca i64, align 8
  %avg = alloca i64, align 8
  store i32 %metric, ptr %metric.addr, align 4
  store i64 %current_value, ptr %current_value.addr, align 8
  store i64 %current_base, ptr %current_base.addr, align 8
  store i64 %factor, ptr %factor.addr, align 8
  %0 = load i32, ptr %metric.addr, align 4
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom
  %last_sample_base = getelementptr inbounds %struct.anon, ptr %arrayidx, i32 0, i32 0
  %1 = load i64, ptr %last_sample_base, align 8
  %cmp = icmp sgt i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %current_base.addr, align 8
  %3 = load i32, ptr %metric.addr, align 4
  %idxprom1 = sext i32 %3 to i64
  %arrayidx2 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom1
  %last_sample_base3 = getelementptr inbounds %struct.anon, ptr %arrayidx2, i32 0, i32 0
  %4 = load i64, ptr %last_sample_base3, align 8
  %sub = sub nsw i64 %2, %4
  store i64 %sub, ptr %base, align 8
  %5 = load i64, ptr %current_value.addr, align 8
  %6 = load i32, ptr %metric.addr, align 4
  %idxprom4 = sext i32 %6 to i64
  %arrayidx5 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom4
  %last_sample_value = getelementptr inbounds %struct.anon, ptr %arrayidx5, i32 0, i32 1
  %7 = load i64, ptr %last_sample_value, align 8
  %sub6 = sub nsw i64 %5, %7
  store i64 %sub6, ptr %value, align 8
  %8 = load i64, ptr %base, align 8
  %cmp7 = icmp sgt i64 %8, 0
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %9 = load i64, ptr %value, align 8
  %10 = load i64, ptr %factor.addr, align 8
  %mul = mul nsw i64 %9, %10
  %11 = load i64, ptr %base, align 8
  %div = sdiv i64 %mul, %11
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %div, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %avg, align 8
  %12 = load i64, ptr %avg, align 8
  %13 = load i32, ptr %metric.addr, align 4
  %idxprom8 = sext i32 %13 to i64
  %arrayidx9 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom8
  %samples = getelementptr inbounds %struct.anon, ptr %arrayidx9, i32 0, i32 2
  %14 = load i32, ptr %metric.addr, align 4
  %idxprom10 = sext i32 %14 to i64
  %arrayidx11 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom10
  %idx = getelementptr inbounds %struct.anon, ptr %arrayidx11, i32 0, i32 3
  %15 = load i32, ptr %idx, align 8
  %idxprom12 = sext i32 %15 to i64
  %arrayidx13 = getelementptr inbounds [16 x i64], ptr %samples, i64 0, i64 %idxprom12
  store i64 %12, ptr %arrayidx13, align 8
  %16 = load i32, ptr %metric.addr, align 4
  %idxprom14 = sext i32 %16 to i64
  %arrayidx15 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom14
  %idx16 = getelementptr inbounds %struct.anon, ptr %arrayidx15, i32 0, i32 3
  %17 = load i32, ptr %idx16, align 8
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %idx16, align 8
  %18 = load i32, ptr %metric.addr, align 4
  %idxprom17 = sext i32 %18 to i64
  %arrayidx18 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom17
  %idx19 = getelementptr inbounds %struct.anon, ptr %arrayidx18, i32 0, i32 3
  %19 = load i32, ptr %idx19, align 8
  %rem = srem i32 %19, 16
  store i32 %rem, ptr %idx19, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %20 = load i64, ptr %current_base.addr, align 8
  %21 = load i32, ptr %metric.addr, align 4
  %idxprom20 = sext i32 %21 to i64
  %arrayidx21 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom20
  %last_sample_base22 = getelementptr inbounds %struct.anon, ptr %arrayidx21, i32 0, i32 0
  store i64 %20, ptr %last_sample_base22, align 8
  %22 = load i64, ptr %current_value.addr, align 8
  %23 = load i32, ptr %metric.addr, align 4
  %idxprom23 = sext i32 %23 to i64
  %arrayidx24 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom23
  %last_sample_value25 = getelementptr inbounds %struct.anon, ptr %arrayidx24, i32 0, i32 1
  store i64 %22, ptr %last_sample_value25, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i64 @getInstantaneousMetric(i32 noundef %metric) #0 {
entry:
  %metric.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %sum = alloca i64, align 8
  store i32 %metric, ptr %metric.addr, align 4
  store i64 0, ptr %sum, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %metric.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom
  %samples = getelementptr inbounds %struct.anon, ptr %arrayidx, i32 0, i32 2
  %2 = load i32, ptr %j, align 4
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [16 x i64], ptr %samples, i64 0, i64 %idxprom1
  %3 = load i64, ptr %arrayidx2, align 8
  %4 = load i64, ptr %sum, align 8
  %add = add nsw i64 %4, %3
  store i64 %add, ptr %sum, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %j, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !9

for.end:                                          ; preds = %for.cond
  %6 = load i64, ptr %sum, align 8
  %div = sdiv i64 %6, 16
  ret i64 %div
}

; Function Attrs: nounwind uwtable
define dso_local i32 @clientsCronResizeQueryBuffer(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %querybuf_size = alloca i64, align 8
  %idletime = alloca i64, align 8
  %resize = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %querybuf = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %querybuf, align 8
  %call = call i64 @sdsalloc(ptr noundef %1)
  store i64 %call, ptr %querybuf_size, align 8
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %lastinteraction = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 32
  %3 = load i64, ptr %lastinteraction, align 8
  %sub = sub nsw i64 %atomic-load, %3
  store i64 %sub, ptr %idletime, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %querybuf1 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 8
  %5 = load ptr, ptr %querybuf1, align 8
  %call2 = call i64 @sdsavail(ptr noundef %5)
  %cmp = icmp ugt i64 %call2, 4096
  br i1 %cmp, label %if.then, label %if.end30

if.then:                                          ; preds = %entry
  %6 = load i64, ptr %idletime, align 8
  %cmp3 = icmp sgt i64 %6, 2
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  %7 = load ptr, ptr %c.addr, align 8
  %querybuf5 = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 8
  %8 = load ptr, ptr %querybuf5, align 8
  %call6 = call ptr @sdsRemoveFreeSpace(ptr noundef %8, i32 noundef 1)
  %9 = load ptr, ptr %c.addr, align 8
  %querybuf7 = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 8
  store ptr %call6, ptr %querybuf7, align 8
  br label %if.end29

if.else:                                          ; preds = %if.then
  %10 = load i64, ptr %querybuf_size, align 8
  %cmp8 = icmp ugt i64 %10, 32768
  br i1 %cmp8, label %land.lhs.true, label %if.end28

land.lhs.true:                                    ; preds = %if.else
  %11 = load i64, ptr %querybuf_size, align 8
  %div = udiv i64 %11, 2
  %12 = load ptr, ptr %c.addr, align 8
  %querybuf_peak = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 10
  %13 = load i64, ptr %querybuf_peak, align 8
  %cmp9 = icmp ugt i64 %div, %13
  br i1 %cmp9, label %if.then10, label %if.end28

if.then10:                                        ; preds = %land.lhs.true
  %14 = load ptr, ptr %c.addr, align 8
  %querybuf11 = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 8
  %15 = load ptr, ptr %querybuf11, align 8
  %call12 = call i64 @sdslen(ptr noundef %15)
  store i64 %call12, ptr %resize, align 8
  %16 = load i64, ptr %resize, align 8
  %17 = load ptr, ptr %c.addr, align 8
  %querybuf_peak13 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 10
  %18 = load i64, ptr %querybuf_peak13, align 8
  %cmp14 = icmp ult i64 %16, %18
  br i1 %cmp14, label %if.then15, label %if.end

if.then15:                                        ; preds = %if.then10
  %19 = load ptr, ptr %c.addr, align 8
  %querybuf_peak16 = getelementptr inbounds %struct.client, ptr %19, i32 0, i32 10
  %20 = load i64, ptr %querybuf_peak16, align 8
  store i64 %20, ptr %resize, align 8
  br label %if.end

if.end:                                           ; preds = %if.then15, %if.then10
  %21 = load ptr, ptr %c.addr, align 8
  %bulklen = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 23
  %22 = load i64, ptr %bulklen, align 8
  %cmp17 = icmp ne i64 %22, -1
  br i1 %cmp17, label %land.lhs.true18, label %if.end24

land.lhs.true18:                                  ; preds = %if.end
  %23 = load i64, ptr %resize, align 8
  %24 = load ptr, ptr %c.addr, align 8
  %bulklen19 = getelementptr inbounds %struct.client, ptr %24, i32 0, i32 23
  %25 = load i64, ptr %bulklen19, align 8
  %add = add i64 %25, 2
  %cmp20 = icmp ult i64 %23, %add
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %land.lhs.true18
  %26 = load ptr, ptr %c.addr, align 8
  %bulklen22 = getelementptr inbounds %struct.client, ptr %26, i32 0, i32 23
  %27 = load i64, ptr %bulklen22, align 8
  %add23 = add nsw i64 %27, 2
  store i64 %add23, ptr %resize, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %land.lhs.true18, %if.end
  %28 = load ptr, ptr %c.addr, align 8
  %querybuf25 = getelementptr inbounds %struct.client, ptr %28, i32 0, i32 8
  %29 = load ptr, ptr %querybuf25, align 8
  %30 = load i64, ptr %resize, align 8
  %call26 = call ptr @sdsResize(ptr noundef %29, i64 noundef %30, i32 noundef 1)
  %31 = load ptr, ptr %c.addr, align 8
  %querybuf27 = getelementptr inbounds %struct.client, ptr %31, i32 0, i32 8
  store ptr %call26, ptr %querybuf27, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.end24, %land.lhs.true, %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then4
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %entry
  %32 = load ptr, ptr %c.addr, align 8
  %querybuf31 = getelementptr inbounds %struct.client, ptr %32, i32 0, i32 8
  %33 = load ptr, ptr %querybuf31, align 8
  %call32 = call i64 @sdslen(ptr noundef %33)
  %34 = load ptr, ptr %c.addr, align 8
  %querybuf_peak33 = getelementptr inbounds %struct.client, ptr %34, i32 0, i32 10
  store i64 %call32, ptr %querybuf_peak33, align 8
  %35 = load ptr, ptr %c.addr, align 8
  %bulklen34 = getelementptr inbounds %struct.client, ptr %35, i32 0, i32 23
  %36 = load i64, ptr %bulklen34, align 8
  %cmp35 = icmp ne i64 %36, -1
  br i1 %cmp35, label %land.lhs.true36, label %if.end45

land.lhs.true36:                                  ; preds = %if.end30
  %37 = load ptr, ptr %c.addr, align 8
  %bulklen37 = getelementptr inbounds %struct.client, ptr %37, i32 0, i32 23
  %38 = load i64, ptr %bulklen37, align 8
  %add38 = add i64 %38, 2
  %39 = load ptr, ptr %c.addr, align 8
  %querybuf_peak39 = getelementptr inbounds %struct.client, ptr %39, i32 0, i32 10
  %40 = load i64, ptr %querybuf_peak39, align 8
  %cmp40 = icmp ugt i64 %add38, %40
  br i1 %cmp40, label %if.then41, label %if.end45

if.then41:                                        ; preds = %land.lhs.true36
  %41 = load ptr, ptr %c.addr, align 8
  %bulklen42 = getelementptr inbounds %struct.client, ptr %41, i32 0, i32 23
  %42 = load i64, ptr %bulklen42, align 8
  %add43 = add nsw i64 %42, 2
  %43 = load ptr, ptr %c.addr, align 8
  %querybuf_peak44 = getelementptr inbounds %struct.client, ptr %43, i32 0, i32 10
  store i64 %add43, ptr %querybuf_peak44, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then41, %land.lhs.true36, %if.end30
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i64 @sdsalloc(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %flags = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %flags, align 1
  %2 = load i8, ptr %flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb5
    i32 3, label %sw.bb9
    i32 4, label %sw.bb13
  ]

sw.bb:                                            ; preds = %entry
  %3 = load i8, ptr %flags, align 1
  %conv1 = zext i8 %3 to i32
  %shr = ashr i32 %conv1, 3
  %conv2 = sext i32 %shr to i64
  store i64 %conv2, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 -3
  %alloc = getelementptr inbounds %struct.sdshdr8, ptr %add.ptr, i32 0, i32 1
  %5 = load i8, ptr %alloc, align 1
  %conv4 = zext i8 %5 to i64
  store i64 %conv4, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  %6 = load ptr, ptr %s.addr, align 8
  %add.ptr6 = getelementptr inbounds i8, ptr %6, i64 -5
  %alloc7 = getelementptr inbounds %struct.sdshdr16, ptr %add.ptr6, i32 0, i32 1
  %7 = load i16, ptr %alloc7, align 1
  %conv8 = zext i16 %7 to i64
  store i64 %conv8, ptr %retval, align 8
  br label %return

sw.bb9:                                           ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, ptr %8, i64 -9
  %alloc11 = getelementptr inbounds %struct.sdshdr32, ptr %add.ptr10, i32 0, i32 1
  %9 = load i32, ptr %alloc11, align 1
  %conv12 = zext i32 %9 to i64
  store i64 %conv12, ptr %retval, align 8
  br label %return

sw.bb13:                                          ; preds = %entry
  %10 = load ptr, ptr %s.addr, align 8
  %add.ptr14 = getelementptr inbounds i8, ptr %10, i64 -17
  %alloc15 = getelementptr inbounds %struct.sdshdr64, ptr %add.ptr14, i32 0, i32 1
  %11 = load i64, ptr %alloc15, align 1
  store i64 %11, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb13, %sw.bb9, %sw.bb5, %sw.bb3, %sw.bb
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define internal i64 @sdsavail(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %flags = alloca i8, align 1
  %sh = alloca ptr, align 8
  %sh6 = alloca ptr, align 8
  %sh15 = alloca ptr, align 8
  %sh22 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 -1
  %1 = load i8, ptr %arrayidx, align 1
  store i8 %1, ptr %flags, align 1
  %2 = load i8, ptr %flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 7
  switch i32 %and, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb5
    i32 3, label %sw.bb14
    i32 4, label %sw.bb21
  ]

sw.bb:                                            ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 -3
  store ptr %add.ptr, ptr %sh, align 8
  %4 = load ptr, ptr %sh, align 8
  %alloc = getelementptr inbounds %struct.sdshdr8, ptr %4, i32 0, i32 1
  %5 = load i8, ptr %alloc, align 1
  %conv2 = zext i8 %5 to i32
  %6 = load ptr, ptr %sh, align 8
  %len = getelementptr inbounds %struct.sdshdr8, ptr %6, i32 0, i32 0
  %7 = load i8, ptr %len, align 1
  %conv3 = zext i8 %7 to i32
  %sub = sub nsw i32 %conv2, %conv3
  %conv4 = sext i32 %sub to i64
  store i64 %conv4, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  %add.ptr7 = getelementptr inbounds i8, ptr %8, i64 -5
  store ptr %add.ptr7, ptr %sh6, align 8
  %9 = load ptr, ptr %sh6, align 8
  %alloc8 = getelementptr inbounds %struct.sdshdr16, ptr %9, i32 0, i32 1
  %10 = load i16, ptr %alloc8, align 1
  %conv9 = zext i16 %10 to i32
  %11 = load ptr, ptr %sh6, align 8
  %len10 = getelementptr inbounds %struct.sdshdr16, ptr %11, i32 0, i32 0
  %12 = load i16, ptr %len10, align 1
  %conv11 = zext i16 %12 to i32
  %sub12 = sub nsw i32 %conv9, %conv11
  %conv13 = sext i32 %sub12 to i64
  store i64 %conv13, ptr %retval, align 8
  br label %return

sw.bb14:                                          ; preds = %entry
  %13 = load ptr, ptr %s.addr, align 8
  %add.ptr16 = getelementptr inbounds i8, ptr %13, i64 -9
  store ptr %add.ptr16, ptr %sh15, align 8
  %14 = load ptr, ptr %sh15, align 8
  %alloc17 = getelementptr inbounds %struct.sdshdr32, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %alloc17, align 1
  %16 = load ptr, ptr %sh15, align 8
  %len18 = getelementptr inbounds %struct.sdshdr32, ptr %16, i32 0, i32 0
  %17 = load i32, ptr %len18, align 1
  %sub19 = sub i32 %15, %17
  %conv20 = zext i32 %sub19 to i64
  store i64 %conv20, ptr %retval, align 8
  br label %return

sw.bb21:                                          ; preds = %entry
  %18 = load ptr, ptr %s.addr, align 8
  %add.ptr23 = getelementptr inbounds i8, ptr %18, i64 -17
  store ptr %add.ptr23, ptr %sh22, align 8
  %19 = load ptr, ptr %sh22, align 8
  %alloc24 = getelementptr inbounds %struct.sdshdr64, ptr %19, i32 0, i32 1
  %20 = load i64, ptr %alloc24, align 1
  %21 = load ptr, ptr %sh22, align 8
  %len25 = getelementptr inbounds %struct.sdshdr64, ptr %21, i32 0, i32 0
  %22 = load i64, ptr %len25, align 1
  %sub26 = sub i64 %20, %22
  store i64 %sub26, ptr %retval, align 8
  br label %return

sw.epilog:                                        ; preds = %entry
  store i64 0, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb21, %sw.bb14, %sw.bb5, %sw.bb1, %sw.bb
  %23 = load i64, ptr %retval, align 8
  ret i64 %23
}

declare ptr @sdsRemoveFreeSpace(ptr noundef, i32 noundef) #2

declare ptr @sdsResize(ptr noundef, i64 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @clientsCronResizeOutputBuffer(ptr noundef %c, i64 noundef %now_ms) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %now_ms.addr = alloca i64, align 8
  %new_buffer_size = alloca i64, align 8
  %oldbuf = alloca ptr, align 8
  %buffer_target_shrink_size = alloca i64, align 8
  %buffer_target_expand_size = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  store i64 %now_ms, ptr %now_ms.addr, align 8
  store i64 0, ptr %new_buffer_size, align 8
  store ptr null, ptr %oldbuf, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %buf_usable_size = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 83
  %1 = load i64, ptr %buf_usable_size, align 8
  %div = udiv i64 %1, 2
  store i64 %div, ptr %buffer_target_shrink_size, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %buf_usable_size1 = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 83
  %3 = load i64, ptr %buf_usable_size1, align 8
  %mul = mul i64 %3, 2
  store i64 %mul, ptr %buffer_target_expand_size, align 8
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 418), align 8
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, ptr %buffer_target_shrink_size, align 8
  %cmp = icmp uge i64 %5, 1024
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %6 = load ptr, ptr %c.addr, align 8
  %buf_peak = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 80
  %7 = load i64, ptr %buf_peak, align 8
  %8 = load i64, ptr %buffer_target_shrink_size, align 8
  %cmp2 = icmp ult i64 %7, %8
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %land.lhs.true
  %9 = load ptr, ptr %c.addr, align 8
  %buf_peak4 = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 80
  %10 = load i64, ptr %buf_peak4, align 8
  %add = add i64 %10, 1
  %cmp5 = icmp ugt i64 1024, %add
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then3
  br label %cond.end

cond.false:                                       ; preds = %if.then3
  %11 = load ptr, ptr %c.addr, align 8
  %buf_peak6 = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 80
  %12 = load i64, ptr %buf_peak6, align 8
  %add7 = add i64 %12, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 1024, %cond.true ], [ %add7, %cond.false ]
  store i64 %cond, ptr %new_buffer_size, align 8
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 149), align 8
  %inc = add nsw i64 %13, 1
  store i64 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 149), align 8
  br label %if.end21

if.else:                                          ; preds = %land.lhs.true, %if.end
  %14 = load i64, ptr %buffer_target_expand_size, align 8
  %cmp8 = icmp ult i64 %14, 32768
  br i1 %cmp8, label %land.lhs.true9, label %if.end20

land.lhs.true9:                                   ; preds = %if.else
  %15 = load ptr, ptr %c.addr, align 8
  %buf_peak10 = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 80
  %16 = load i64, ptr %buf_peak10, align 8
  %17 = load ptr, ptr %c.addr, align 8
  %buf_usable_size11 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 83
  %18 = load i64, ptr %buf_usable_size11, align 8
  %cmp12 = icmp eq i64 %16, %18
  br i1 %cmp12, label %if.then13, label %if.end20

if.then13:                                        ; preds = %land.lhs.true9
  %19 = load i64, ptr %buffer_target_expand_size, align 8
  %cmp14 = icmp ult i64 16384, %19
  br i1 %cmp14, label %cond.true15, label %cond.false16

cond.true15:                                      ; preds = %if.then13
  br label %cond.end17

cond.false16:                                     ; preds = %if.then13
  %20 = load i64, ptr %buffer_target_expand_size, align 8
  br label %cond.end17

cond.end17:                                       ; preds = %cond.false16, %cond.true15
  %cond18 = phi i64 [ 16384, %cond.true15 ], [ %20, %cond.false16 ]
  store i64 %cond18, ptr %new_buffer_size, align 8
  %21 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 150), align 8
  %inc19 = add nsw i64 %21, 1
  store i64 %inc19, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 150), align 8
  br label %if.end20

if.end20:                                         ; preds = %cond.end17, %land.lhs.true9, %if.else
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %cond.end
  %22 = load i64, ptr %new_buffer_size, align 8
  %tobool22 = icmp ne i64 %22, 0
  br i1 %tobool22, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %if.end21
  %23 = load i64, ptr %new_buffer_size, align 8
  %24 = load ptr, ptr %c.addr, align 8
  %bufpos = getelementptr inbounds %struct.client, ptr %24, i32 0, i32 82
  %25 = load i32, ptr %bufpos, align 8
  %conv = sext i32 %25 to i64
  %cmp23 = icmp uge i64 %23, %conv
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end21
  %26 = phi i1 [ true, %if.end21 ], [ %cmp23, %lor.rhs ]
  %lnot = xor i1 %26, true
  %lnot25 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot25 to i32
  %conv26 = sext i32 %lnot.ext to i64
  %tobool27 = icmp ne i64 %conv26, 0
  br i1 %tobool27, label %cond.true28, label %cond.false29

cond.true28:                                      ; preds = %lor.end
  br label %cond.end30

cond.false29:                                     ; preds = %lor.end
  %27 = load ptr, ptr %c.addr, align 8
  call void @_serverAssertWithInfo(ptr noundef %27, ptr noundef null, ptr noundef @.str.17, ptr noundef @.str.9, i32 noundef 878)
  call void @abort() #16
  unreachable

28:                                               ; No predecessors!
  br label %cond.end30

cond.end30:                                       ; preds = %28, %cond.true28
  %29 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 417), align 8
  %cmp31 = icmp sge i64 %29, 0
  br i1 %cmp31, label %land.lhs.true33, label %if.end41

land.lhs.true33:                                  ; preds = %cond.end30
  %30 = load i64, ptr %now_ms.addr, align 8
  %31 = load ptr, ptr %c.addr, align 8
  %buf_peak_last_reset_time = getelementptr inbounds %struct.client, ptr %31, i32 0, i32 81
  %32 = load i64, ptr %buf_peak_last_reset_time, align 8
  %sub = sub nsw i64 %30, %32
  %33 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 417), align 8
  %cmp34 = icmp sge i64 %sub, %33
  br i1 %cmp34, label %if.then36, label %if.end41

if.then36:                                        ; preds = %land.lhs.true33
  %34 = load ptr, ptr %c.addr, align 8
  %bufpos37 = getelementptr inbounds %struct.client, ptr %34, i32 0, i32 82
  %35 = load i32, ptr %bufpos37, align 8
  %conv38 = sext i32 %35 to i64
  %36 = load ptr, ptr %c.addr, align 8
  %buf_peak39 = getelementptr inbounds %struct.client, ptr %36, i32 0, i32 80
  store i64 %conv38, ptr %buf_peak39, align 8
  %37 = load i64, ptr %now_ms.addr, align 8
  %38 = load ptr, ptr %c.addr, align 8
  %buf_peak_last_reset_time40 = getelementptr inbounds %struct.client, ptr %38, i32 0, i32 81
  store i64 %37, ptr %buf_peak_last_reset_time40, align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then36, %land.lhs.true33, %cond.end30
  %39 = load i64, ptr %new_buffer_size, align 8
  %tobool42 = icmp ne i64 %39, 0
  br i1 %tobool42, label %if.then43, label %if.end49

if.then43:                                        ; preds = %if.end41
  %40 = load ptr, ptr %c.addr, align 8
  %buf = getelementptr inbounds %struct.client, ptr %40, i32 0, i32 84
  %41 = load ptr, ptr %buf, align 8
  store ptr %41, ptr %oldbuf, align 8
  %42 = load i64, ptr %new_buffer_size, align 8
  %43 = load ptr, ptr %c.addr, align 8
  %buf_usable_size44 = getelementptr inbounds %struct.client, ptr %43, i32 0, i32 83
  %call = call ptr @zmalloc_usable(i64 noundef %42, ptr noundef %buf_usable_size44)
  %44 = load ptr, ptr %c.addr, align 8
  %buf45 = getelementptr inbounds %struct.client, ptr %44, i32 0, i32 84
  store ptr %call, ptr %buf45, align 8
  %45 = load ptr, ptr %c.addr, align 8
  %buf46 = getelementptr inbounds %struct.client, ptr %45, i32 0, i32 84
  %46 = load ptr, ptr %buf46, align 8
  %47 = load ptr, ptr %oldbuf, align 8
  %48 = load ptr, ptr %c.addr, align 8
  %bufpos47 = getelementptr inbounds %struct.client, ptr %48, i32 0, i32 82
  %49 = load i32, ptr %bufpos47, align 8
  %conv48 = sext i32 %49 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %46, ptr align 1 %47, i64 %conv48, i1 false)
  %50 = load ptr, ptr %oldbuf, align 8
  call void @zfree(ptr noundef %50)
  br label %if.end49

if.end49:                                         ; preds = %if.then43, %if.end41
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end49, %if.then
  %51 = load i32, ptr %retval, align 4
  ret i32 %51
}

declare void @_serverAssertWithInfo(ptr noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) #2

declare ptr @zmalloc_usable(i64 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @clientsCronTrackExpansiveClients(ptr noundef %c, i32 noundef %time_idx) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %time_idx.addr = alloca i32, align 4
  %in_usage = alloca i64, align 8
  %out_usage = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %time_idx, ptr %time_idx.addr, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %querybuf = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 8
  %1 = load ptr, ptr %querybuf, align 8
  %call = call i64 @sdsZmallocSize(ptr noundef %1)
  %2 = load ptr, ptr %c.addr, align 8
  %argv_len_sum = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 16
  %3 = load i64, ptr %argv_len_sum, align 8
  %add = add i64 %call, %3
  %4 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 12
  %5 = load ptr, ptr %argv, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load ptr, ptr %c.addr, align 8
  %argv1 = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 12
  %7 = load ptr, ptr %argv1, align 8
  %call2 = call i64 @je_malloc_usable_size(ptr noundef %7) #13
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ 0, %cond.false ]
  %add3 = add i64 %add, %cond
  store i64 %add3, ptr %in_usage, align 8
  %8 = load ptr, ptr %c.addr, align 8
  %call4 = call i64 @getClientOutputBufferMemoryUsage(ptr noundef %8)
  store i64 %call4, ptr %out_usage, align 8
  %9 = load i64, ptr %in_usage, align 8
  %10 = load i32, ptr %time_idx.addr, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %idxprom
  %11 = load i64, ptr %arrayidx, align 8
  %cmp = icmp ugt i64 %9, %11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %12 = load i64, ptr %in_usage, align 8
  %13 = load i32, ptr %time_idx.addr, align 4
  %idxprom5 = sext i32 %13 to i64
  %arrayidx6 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %idxprom5
  store i64 %12, ptr %arrayidx6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %14 = load i64, ptr %out_usage, align 8
  %15 = load i32, ptr %time_idx.addr, align 4
  %idxprom7 = sext i32 %15 to i64
  %arrayidx8 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %idxprom7
  %16 = load i64, ptr %arrayidx8, align 8
  %cmp9 = icmp ugt i64 %14, %16
  br i1 %cmp9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end
  %17 = load i64, ptr %out_usage, align 8
  %18 = load i32, ptr %time_idx.addr, align 4
  %idxprom11 = sext i32 %18 to i64
  %arrayidx12 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %idxprom11
  store i64 %17, ptr %arrayidx12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.end
  ret i32 0
}

declare i64 @sdsZmallocSize(ptr noundef) #2

; Function Attrs: nounwind
declare i64 @je_malloc_usable_size(ptr noundef) #3

declare i64 @getClientOutputBufferMemoryUsage(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @updateClientMemoryUsage(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %mem = alloca i64, align 8
  %type = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %call = call i64 @getClientMemoryUsage(ptr noundef %0, ptr noundef null)
  store i64 %call, ptr %mem, align 8
  %1 = load ptr, ptr %c.addr, align 8
  %call1 = call i32 @getClientType(ptr noundef %1)
  store i32 %call1, ptr %type, align 4
  %2 = load ptr, ptr %c.addr, align 8
  %last_memory_usage = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 73
  %3 = load i64, ptr %last_memory_usage, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %last_memory_type = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 74
  %5 = load i32, ptr %last_memory_type, align 8
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [4 x i64], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 137), i64 0, i64 %idxprom
  %6 = load i64, ptr %arrayidx, align 8
  %sub = sub i64 %6, %3
  store i64 %sub, ptr %arrayidx, align 8
  %7 = load i64, ptr %mem, align 8
  %8 = load i32, ptr %type, align 4
  %idxprom2 = sext i32 %8 to i64
  %arrayidx3 = getelementptr inbounds [4 x i64], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 137), i64 0, i64 %idxprom2
  %9 = load i64, ptr %arrayidx3, align 8
  %add = add i64 %9, %7
  store i64 %add, ptr %arrayidx3, align 8
  %10 = load i32, ptr %type, align 4
  %11 = load ptr, ptr %c.addr, align 8
  %last_memory_type4 = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 74
  store i32 %10, ptr %last_memory_type4, align 8
  %12 = load i64, ptr %mem, align 8
  %13 = load ptr, ptr %c.addr, align 8
  %last_memory_usage5 = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 73
  store i64 %12, ptr %last_memory_usage5, align 8
  ret void
}

declare i64 @getClientMemoryUsage(ptr noundef, ptr noundef) #2

declare i32 @getClientType(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @clientEvictionAllowed(ptr noundef %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %type = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 315), align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %flags, align 8
  %and = and i64 %2, 8796093022208
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %c.addr, align 8
  %call = call i32 @getClientType(ptr noundef %3)
  store i32 %call, ptr %type, align 4
  %4 = load i32, ptr %type, align 4
  %cmp1 = icmp eq i32 %4, 0
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end
  %5 = load i32, ptr %type, align 4
  %cmp2 = icmp eq i32 %5, 2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %6 = phi i1 [ true, %if.end ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %6 to i32
  store i32 %lor.ext, ptr %retval, align 4
  br label %return

return:                                           ; preds = %lor.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define dso_local void @removeClientFromMemUsageBucket(ptr noundef %c, i32 noundef %allow_eviction) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %allow_eviction.addr = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i32 %allow_eviction, ptr %allow_eviction.addr, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 76
  %1 = load ptr, ptr %mem_usage_bucket, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %last_memory_usage = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 73
  %3 = load i64, ptr %last_memory_usage, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket1 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 76
  %5 = load ptr, ptr %mem_usage_bucket1, align 8
  %mem_usage_sum = getelementptr inbounds %struct.clientMemUsageBucket, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %mem_usage_sum, align 8
  %sub = sub i64 %6, %3
  store i64 %sub, ptr %mem_usage_sum, align 8
  %7 = load i32, ptr %allow_eviction.addr, align 4
  %tobool2 = icmp ne i32 %7, 0
  br i1 %tobool2, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  %8 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket4 = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 76
  %9 = load ptr, ptr %mem_usage_bucket4, align 8
  %clients = getelementptr inbounds %struct.clientMemUsageBucket, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %clients, align 8
  %11 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket_node = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 75
  %12 = load ptr, ptr %mem_usage_bucket_node, align 8
  call void @listDelNode(ptr noundef %10, ptr noundef %12)
  %13 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket5 = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 76
  store ptr null, ptr %mem_usage_bucket5, align 8
  %14 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket_node6 = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 75
  store ptr null, ptr %mem_usage_bucket_node6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @updateClientMemUsageAndBucket(ptr noundef %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %allow_eviction = alloca i32, align 4
  %bucket = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load i32, ptr @io_threads_op, align 4
  %cmp = icmp eq i32 %0, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.18, ptr noundef @.str.9, i32 noundef 1011)
  call void @abort() #16
  unreachable

1:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %1, %cond.true
  %2 = load ptr, ptr %c.addr, align 8
  %call = call i32 @clientEvictionAllowed(ptr noundef %2)
  store i32 %call, ptr %allow_eviction, align 4
  %3 = load ptr, ptr %c.addr, align 8
  %4 = load i32, ptr %allow_eviction, align 4
  call void @removeClientFromMemUsageBucket(ptr noundef %3, i32 noundef %4)
  %5 = load i32, ptr %allow_eviction, align 4
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end
  %6 = load ptr, ptr %c.addr, align 8
  call void @updateClientMemoryUsage(ptr noundef %6)
  %7 = load ptr, ptr %c.addr, align 8
  %last_memory_usage = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 73
  %8 = load i64, ptr %last_memory_usage, align 8
  %call3 = call ptr @getMemUsageBucket(i64 noundef %8)
  store ptr %call3, ptr %bucket, align 8
  %9 = load ptr, ptr %c.addr, align 8
  %last_memory_usage4 = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 73
  %10 = load i64, ptr %last_memory_usage4, align 8
  %11 = load ptr, ptr %bucket, align 8
  %mem_usage_sum = getelementptr inbounds %struct.clientMemUsageBucket, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %mem_usage_sum, align 8
  %add = add i64 %12, %10
  store i64 %add, ptr %mem_usage_sum, align 8
  %13 = load ptr, ptr %bucket, align 8
  %14 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 76
  %15 = load ptr, ptr %mem_usage_bucket, align 8
  %cmp5 = icmp ne ptr %13, %15
  br i1 %cmp5, label %if.then7, label %if.end18

if.then7:                                         ; preds = %if.end
  %16 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket8 = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 76
  %17 = load ptr, ptr %mem_usage_bucket8, align 8
  %tobool9 = icmp ne ptr %17, null
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.then7
  %18 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket11 = getelementptr inbounds %struct.client, ptr %18, i32 0, i32 76
  %19 = load ptr, ptr %mem_usage_bucket11, align 8
  %clients = getelementptr inbounds %struct.clientMemUsageBucket, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %clients, align 8
  %21 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket_node = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 75
  %22 = load ptr, ptr %mem_usage_bucket_node, align 8
  call void @listDelNode(ptr noundef %20, ptr noundef %22)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.then7
  %23 = load ptr, ptr %bucket, align 8
  %24 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket13 = getelementptr inbounds %struct.client, ptr %24, i32 0, i32 76
  store ptr %23, ptr %mem_usage_bucket13, align 8
  %25 = load ptr, ptr %bucket, align 8
  %clients14 = getelementptr inbounds %struct.clientMemUsageBucket, ptr %25, i32 0, i32 0
  %26 = load ptr, ptr %clients14, align 8
  %27 = load ptr, ptr %c.addr, align 8
  %call15 = call ptr @listAddNodeTail(ptr noundef %26, ptr noundef %27)
  %28 = load ptr, ptr %bucket, align 8
  %clients16 = getelementptr inbounds %struct.clientMemUsageBucket, ptr %28, i32 0, i32 0
  %29 = load ptr, ptr %clients16, align 8
  %tail = getelementptr inbounds %struct.list, ptr %29, i32 0, i32 1
  %30 = load ptr, ptr %tail, align 8
  %31 = load ptr, ptr %c.addr, align 8
  %mem_usage_bucket_node17 = getelementptr inbounds %struct.client, ptr %31, i32 0, i32 75
  store ptr %30, ptr %mem_usage_bucket_node17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.end12, %if.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then
  %32 = load i32, ptr %retval, align 4
  ret i32 %32
}

declare void @_serverAssert(ptr noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @getMemUsageBucket(i64 noundef %mem) #0 {
entry:
  %mem.addr = alloca i64, align 8
  %size_in_bits = alloca i32, align 4
  %clz = alloca i32, align 4
  %bucket_idx = alloca i32, align 4
  store i64 %mem, ptr %mem.addr, align 8
  store i32 64, ptr %size_in_bits, align 4
  %0 = load i64, ptr %mem.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %mem.addr, align 8
  %2 = call i64 @llvm.ctlz.i64(i64 %1, i1 true)
  %cast = trunc i64 %2 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i32, ptr %size_in_bits, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %cast, %cond.true ], [ %3, %cond.false ]
  store i32 %cond, ptr %clz, align 4
  %4 = load i32, ptr %size_in_bits, align 4
  %5 = load i32, ptr %clz, align 4
  %sub = sub nsw i32 %4, %5
  store i32 %sub, ptr %bucket_idx, align 4
  %6 = load i32, ptr %bucket_idx, align 4
  %cmp1 = icmp sgt i32 %6, 33
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  store i32 33, ptr %bucket_idx, align 4
  br label %if.end4

if.else:                                          ; preds = %cond.end
  %7 = load i32, ptr %bucket_idx, align 4
  %cmp2 = icmp slt i32 %7, 15
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  store i32 15, ptr %bucket_idx, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then
  %8 = load i32, ptr %bucket_idx, align 4
  %sub5 = sub nsw i32 %8, 15
  store i32 %sub5, ptr %bucket_idx, align 4
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  %10 = load i32, ptr %bucket_idx, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds %struct.clientMemUsageBucket, ptr %9, i64 %idxprom
  ret ptr %arrayidx
}

; Function Attrs: nounwind uwtable
define dso_local void @getExpansiveClientsInfo(ptr noundef %in_usage, ptr noundef %out_usage) #0 {
entry:
  %in_usage.addr = alloca ptr, align 8
  %out_usage.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %o = alloca i64, align 8
  %j = alloca i32, align 4
  store ptr %in_usage, ptr %in_usage.addr, align 8
  store ptr %out_usage, ptr %out_usage.addr, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %o, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %j, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %idxprom
  %2 = load i64, ptr %arrayidx, align 8
  %3 = load i64, ptr %i, align 8
  %cmp1 = icmp ugt i64 %2, %3
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %4 = load i32, ptr %j, align 4
  %idxprom2 = sext i32 %4 to i64
  %arrayidx3 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %idxprom2
  %5 = load i64, ptr %arrayidx3, align 8
  store i64 %5, ptr %i, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %6 = load i32, ptr %j, align 4
  %idxprom4 = sext i32 %6 to i64
  %arrayidx5 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %idxprom4
  %7 = load i64, ptr %arrayidx5, align 8
  %8 = load i64, ptr %o, align 8
  %cmp6 = icmp ugt i64 %7, %8
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end
  %9 = load i32, ptr %j, align 4
  %idxprom8 = sext i32 %9 to i64
  %arrayidx9 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %idxprom8
  %10 = load i64, ptr %arrayidx9, align 8
  store i64 %10, ptr %o, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %11 = load i32, ptr %j, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  %12 = load i64, ptr %i, align 8
  %13 = load ptr, ptr %in_usage.addr, align 8
  store i64 %12, ptr %13, align 8
  %14 = load i64, ptr %o, align 8
  %15 = load ptr, ptr %out_usage.addr, align 8
  store i64 %14, ptr %15, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @clientsCron() #0 {
entry:
  %numclients = alloca i32, align 4
  %iterations = alloca i32, align 4
  %now = alloca i64, align 8
  %curr_peak_mem_usage_slot = alloca i32, align 4
  %zeroidx = alloca i32, align 4
  %c = alloca ptr, align 8
  %head = alloca ptr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %conv = trunc i64 %1 to i32
  store i32 %conv, ptr %numclients, align 4
  %2 = load i32, ptr %numclients, align 4
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div = sdiv i32 %2, %3
  store i32 %div, ptr %iterations, align 4
  %call = call i64 @mstime()
  store i64 %call, ptr %now, align 8
  %4 = load i32, ptr %iterations, align 4
  %cmp = icmp slt i32 %4, 5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, ptr %numclients, align 4
  %cmp2 = icmp slt i32 %5, 5
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %6 = load i32, ptr %numclients, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %6, %cond.true ], [ 5, %cond.false ]
  store i32 %cond, ptr %iterations, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %rem = srem i64 %atomic-load, 8
  %conv4 = trunc i64 %rem to i32
  store i32 %conv4, ptr %curr_peak_mem_usage_slot, align 4
  %7 = load i32, ptr %curr_peak_mem_usage_slot, align 4
  %add = add nsw i32 %7, 1
  %rem5 = srem i32 %add, 8
  store i32 %rem5, ptr %zeroidx, align 4
  %8 = load i32, ptr %zeroidx, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemInput, i64 0, i64 %idxprom
  store i64 0, ptr %arrayidx, align 8
  %9 = load i32, ptr %zeroidx, align 4
  %idxprom6 = sext i32 %9 to i64
  %arrayidx7 = getelementptr inbounds [8 x i64], ptr @ClientsPeakMemOutput, i64 0, i64 %idxprom6
  store i64 0, ptr %arrayidx7, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end34, %if.then33, %if.then25, %if.then21, %if.then17, %if.then13, %if.end
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  %len8 = getelementptr inbounds %struct.list, ptr %10, i32 0, i32 5
  %11 = load i64, ptr %len8, align 8
  %tobool = icmp ne i64 %11, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %12 = load i32, ptr %iterations, align 4
  %dec = add nsw i32 %12, -1
  store i32 %dec, ptr %iterations, align 4
  %tobool9 = icmp ne i32 %12, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %13 = phi i1 [ false, %while.cond ], [ %tobool9, %land.rhs ]
  br i1 %13, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %14 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  %head10 = getelementptr inbounds %struct.list, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %head10, align 8
  store ptr %15, ptr %head, align 8
  %16 = load ptr, ptr %head, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %value, align 8
  store ptr %17, ptr %c, align 8
  %18 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  call void @listRotateHeadToTail(ptr noundef %18)
  %19 = load ptr, ptr %c, align 8
  %20 = load i64, ptr %now, align 8
  %call11 = call i32 @clientsCronHandleTimeout(ptr noundef %19, i64 noundef %20)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %while.body
  br label %while.cond, !llvm.loop !11

if.end14:                                         ; preds = %while.body
  %21 = load ptr, ptr %c, align 8
  %call15 = call i32 @clientsCronResizeQueryBuffer(ptr noundef %21)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  br label %while.cond, !llvm.loop !11

if.end18:                                         ; preds = %if.end14
  %22 = load ptr, ptr %c, align 8
  %23 = load i64, ptr %now, align 8
  %call19 = call i32 @clientsCronResizeOutputBuffer(ptr noundef %22, i64 noundef %23)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  br label %while.cond, !llvm.loop !11

if.end22:                                         ; preds = %if.end18
  %24 = load ptr, ptr %c, align 8
  %25 = load i32, ptr %curr_peak_mem_usage_slot, align 4
  %call23 = call i32 @clientsCronTrackExpansiveClients(ptr noundef %24, i32 noundef %25)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end22
  br label %while.cond, !llvm.loop !11

if.end26:                                         ; preds = %if.end22
  %26 = load ptr, ptr %c, align 8
  %call27 = call i32 @updateClientMemUsageAndBucket(ptr noundef %26)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %if.end26
  %27 = load ptr, ptr %c, align 8
  call void @updateClientMemoryUsage(ptr noundef %27)
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.end26
  %28 = load ptr, ptr %c, align 8
  %call31 = call i32 @closeClientOnOutputBufferLimitReached(ptr noundef %28, i32 noundef 0)
  %tobool32 = icmp ne i32 %call31, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  br label %while.cond, !llvm.loop !11

if.end34:                                         ; preds = %if.end30
  br label %while.cond, !llvm.loop !11

while.end:                                        ; preds = %land.end
  ret void
}

declare void @listRotateHeadToTail(ptr noundef) #2

declare i32 @clientsCronHandleTimeout(ptr noundef, i64 noundef) #2

declare i32 @closeClientOnOutputBufferLimitReached(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @databasesCron() #0 {
entry:
  %dbs_per_call = alloca i32, align 4
  %j = alloca i32, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 159), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %call = call i32 @iAmMaster()
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  call void @activeExpireCycle(i32 noundef 0)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @expireSlaveKeys()
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  call void @activeDefragCycle()
  %call4 = call i32 @hasActiveChildProcess()
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end15, label %if.then6

if.then6:                                         ; preds = %if.end3
  store i32 16, ptr %dbs_per_call, align 4
  %1 = load i32, ptr %dbs_per_call, align 4
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 173), align 8
  %cmp = icmp sgt i32 %1, %2
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then6
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 173), align 8
  store i32 %3, ptr %dbs_per_call, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then6
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end8
  %4 = load i32, ptr %j, align 4
  %5 = load i32, ptr %dbs_per_call, align 4
  %cmp9 = icmp slt i32 %4, %5
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32, ptr @databasesCron.resize_db, align 4
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 173), align 8
  %rem = urem i32 %6, %7
  call void @tryResizeHashTables(i32 noundef %rem)
  %8 = load i32, ptr @databasesCron.resize_db, align 4
  %inc = add i32 %8, 1
  store i32 %inc, ptr @databasesCron.resize_db, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i32, ptr %j, align 4
  %inc10 = add nsw i32 %9, 1
  store i32 %inc10, ptr %j, align 4
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 21), align 8
  %tobool11 = icmp ne i32 %10, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %for.end
  %call13 = call i32 @incrementallyRehash()
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %for.end
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.end3
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @iAmMaster() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %lor.rhs, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %call = call ptr @getMyClusterNode()
  %call2 = call i32 @clusterNodeIsMaster(ptr noundef %call)
  %tobool3 = icmp ne i32 %call2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %3 = phi i1 [ false, %lor.rhs ], [ %tobool3, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.lhs.true
  %4 = phi i1 [ true, %land.lhs.true ], [ %3, %land.end ]
  %lor.ext = zext i1 %4 to i32
  ret i32 %lor.ext
}

declare void @activeExpireCycle(i32 noundef) #2

declare void @expireSlaveKeys() #2

declare void @activeDefragCycle() #2

; Function Attrs: nounwind uwtable
define dso_local void @updateCachedTime(i32 noundef %update_daylight_info) #0 {
entry:
  %update_daylight_info.addr = alloca i32, align 4
  %us = alloca i64, align 8
  store i32 %update_daylight_info, ptr %update_daylight_info.addr, align 4
  %call = call i64 @ustime()
  store i64 %call, ptr %us, align 8
  %0 = load i32, ptr %update_daylight_info.addr, align 4
  %1 = load i64, ptr %us, align 8
  call void @updateCachedTimeWithUs(i32 noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @updateCachedTimeWithUs(i32 noundef %update_daylight_info, i64 noundef %ustime) #0 {
entry:
  %update_daylight_info.addr = alloca i32, align 4
  %ustime.addr = alloca i64, align 8
  %unixtime = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %tm = alloca %struct.tm, align 8
  %ut = alloca i64, align 8
  store i32 %update_daylight_info, ptr %update_daylight_info.addr, align 4
  store i64 %ustime, ptr %ustime.addr, align 8
  %0 = load i64, ptr %ustime.addr, align 8
  store i64 %0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 353), align 8
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 353), align 8
  %div = sdiv i64 %1, 1000
  store i64 %div, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  %div1 = sdiv i64 %2, 1000
  store i64 %div1, ptr %unixtime, align 8
  %3 = load i64, ptr %unixtime, align 8
  store i64 %3, ptr %.atomictmp, align 8
  %4 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) monotonic, align 8
  %5 = load i32, ptr %update_daylight_info.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  store i64 %atomic-load, ptr %ut, align 8
  %call = call ptr @localtime_r(ptr noundef %ut, ptr noundef %tm) #13
  %tm_isdst = getelementptr inbounds %struct.tm, ptr %tm, i32 0, i32 8
  %6 = load i32, ptr %tm_isdst, align 8
  store i32 %6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 351), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @enterExecutionUnit(i32 noundef %update_cached_time, i64 noundef %us) #0 {
entry:
  %update_cached_time.addr = alloca i32, align 4
  %us.addr = alloca i64, align 8
  store i32 %update_cached_time, ptr %update_cached_time.addr, align 4
  store i64 %us, ptr %us.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %inc = add nsw i32 %0, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %update_cached_time.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %land.lhs.true
  %2 = load i64, ptr %us.addr, align 8
  %cmp1 = icmp eq i64 %2, 0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %call = call i64 @ustime()
  store i64 %call, ptr %us.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %3 = load i64, ptr %us.addr, align 8
  call void @updateCachedTimeWithUs(i32 noundef 0, i64 noundef %3)
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  store i64 %4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 354), align 8
  br label %if.end3

if.end3:                                          ; preds = %if.end, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @exitExecutionUnit() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %dec = add nsw i32 %0, -1
  store i32 %dec, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @checkChildrenDone() #0 {
entry:
  %statloc = alloca i32, align 4
  %pid = alloca i32, align 4
  %exitcode = alloca i32, align 4
  %bysignal = alloca i32, align 4
  store i32 0, ptr %statloc, align 4
  %call = call i32 @waitpid(i32 noundef -1, ptr noundef %statloc, i32 noundef 1)
  store i32 %call, ptr %pid, align 4
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end60

if.then:                                          ; preds = %entry
  %0 = load i32, ptr %statloc, align 4
  %and = and i32 %0, 127
  %cmp1 = icmp eq i32 %and, 0
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %1 = load i32, ptr %statloc, align 4
  %and2 = and i32 %1, 65280
  %shr = ashr i32 %and2, 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shr, %cond.true ], [ -1, %cond.false ]
  store i32 %cond, ptr %exitcode, align 4
  store i32 0, ptr %bysignal, align 4
  %2 = load i32, ptr %statloc, align 4
  %and3 = and i32 %2, 127
  %add = add nsw i32 %and3, 1
  %conv = trunc i32 %add to i8
  %conv4 = sext i8 %conv to i32
  %shr5 = ashr i32 %conv4, 1
  %cmp6 = icmp sgt i32 %shr5, 0
  br i1 %cmp6, label %if.then8, label %if.end

if.then8:                                         ; preds = %cond.end
  %3 = load i32, ptr %statloc, align 4
  %and9 = and i32 %3, 127
  store i32 %and9, ptr %bysignal, align 4
  br label %if.end

if.end:                                           ; preds = %if.then8, %cond.end
  %4 = load i32, ptr %exitcode, align 4
  %cmp10 = icmp eq i32 %4, 255
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  store i32 10, ptr %bysignal, align 4
  store i32 1, ptr %exitcode, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end
  %5 = load i32, ptr %pid, align 4
  %cmp14 = icmp eq i32 %5, -1
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end13
  br label %do.body

do.body:                                          ; preds = %if.then16
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp17 = icmp slt i32 3, %6
  br i1 %cmp17, label %if.then19, label %if.end20

if.then19:                                        ; preds = %do.body
  br label %do.end

if.end20:                                         ; preds = %do.body
  %call21 = call ptr @__errno_location() #17
  %7 = load i32, ptr %call21, align 4
  %call22 = call ptr @strerror(i32 noundef %7) #13
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %call23 = call ptr @strChildType(i32 noundef %8)
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.19, ptr noundef %call22, ptr noundef %call23, i32 noundef %9)
  br label %do.end

do.end:                                           ; preds = %if.end20, %if.then19
  br label %if.end59

if.else:                                          ; preds = %if.end13
  %10 = load i32, ptr %pid, align 4
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %cmp24 = icmp eq i32 %10, %11
  br i1 %cmp24, label %if.then26, label %if.else46

if.then26:                                        ; preds = %if.else
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp27 = icmp eq i32 %12, 1
  br i1 %cmp27, label %if.then29, label %if.else30

if.then29:                                        ; preds = %if.then26
  %13 = load i32, ptr %exitcode, align 4
  %14 = load i32, ptr %bysignal, align 4
  call void @backgroundSaveDoneHandler(i32 noundef %13, i32 noundef %14)
  br label %if.end41

if.else30:                                        ; preds = %if.then26
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp31 = icmp eq i32 %15, 2
  br i1 %cmp31, label %if.then33, label %if.else34

if.then33:                                        ; preds = %if.else30
  %16 = load i32, ptr %exitcode, align 4
  %17 = load i32, ptr %bysignal, align 4
  call void @backgroundRewriteDoneHandler(i32 noundef %16, i32 noundef %17)
  br label %if.end40

if.else34:                                        ; preds = %if.else30
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp35 = icmp eq i32 %18, 4
  br i1 %cmp35, label %if.then37, label %if.else38

if.then37:                                        ; preds = %if.else34
  %19 = load i32, ptr %exitcode, align 4
  %20 = load i32, ptr %bysignal, align 4
  call void @ModuleForkDoneHandler(i32 noundef %19, i32 noundef %20)
  br label %if.end39

if.else38:                                        ; preds = %if.else34
  %21 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 1260, ptr noundef @.str.20, i32 noundef %21, i32 noundef %22)
  call void @abort() #16
  unreachable

if.end39:                                         ; preds = %if.then37
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then33
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then29
  %23 = load i32, ptr %bysignal, align 4
  %tobool = icmp ne i32 %23, 0
  br i1 %tobool, label %if.end45, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end41
  %24 = load i32, ptr %exitcode, align 4
  %cmp42 = icmp eq i32 %24, 0
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %land.lhs.true
  call void @receiveChildInfo()
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %land.lhs.true, %if.end41
  call void @resetChildState()
  br label %if.end58

if.else46:                                        ; preds = %if.else
  %25 = load i32, ptr %pid, align 4
  %call47 = call i32 @ldbRemoveChild(i32 noundef %25)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.end57, label %if.then49

if.then49:                                        ; preds = %if.else46
  br label %do.body50

do.body50:                                        ; preds = %if.then49
  %26 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp51 = icmp slt i32 3, %26
  br i1 %cmp51, label %if.then53, label %if.end54

if.then53:                                        ; preds = %do.body50
  br label %do.end56

if.end54:                                         ; preds = %do.body50
  %27 = load i32, ptr %pid, align 4
  %conv55 = sext i32 %27 to i64
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.21, i64 noundef %conv55)
  br label %do.end56

do.end56:                                         ; preds = %if.end54, %if.then53
  br label %if.end57

if.end57:                                         ; preds = %do.end56, %if.else46
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end45
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %do.end
  call void @replicationStartPendingFork()
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %entry
  ret void
}

declare i32 @waitpid(i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind
declare ptr @strerror(i32 noundef) #3

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #8

declare void @backgroundSaveDoneHandler(i32 noundef, i32 noundef) #2

declare void @backgroundRewriteDoneHandler(i32 noundef, i32 noundef) #2

declare void @ModuleForkDoneHandler(i32 noundef, i32 noundef) #2

declare void @receiveChildInfo() #2

declare i32 @ldbRemoveChild(i32 noundef) #2

declare void @replicationStartPendingFork() #2

; Function Attrs: nounwind uwtable
define dso_local void @cronUpdateMemoryStats() #0 {
entry:
  %lua_memory = alloca i64, align 8
  %call = call i64 @zmalloc_used_memory()
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  %cmp = icmp ugt i64 %call, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @zmalloc_used_memory()
  store i64 %call1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div = sdiv i32 1000, %1
  %cmp2 = icmp sle i32 100, %div
  br i1 %cmp2, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div3 = sdiv i32 1000, %3
  %div4 = sdiv i32 100, %div3
  %rem = srem i32 %2, %div4
  %tobool = icmp ne i32 %rem, 0
  br i1 %tobool, label %if.end19, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  %call6 = call i64 @zmalloc_get_rss()
  store i64 %call6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 1), align 8
  %call7 = call i64 @zmalloc_used_memory()
  store i64 %call7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123), align 8
  %call8 = call i32 @zmalloc_get_allocator_info(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 2), ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 3), ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 4))
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 4), align 8
  %tobool9 = icmp ne i64 %4, 0
  br i1 %tobool9, label %if.end12, label %if.then10

if.then10:                                        ; preds = %if.then5
  %call11 = call i64 @evalMemory()
  store i64 %call11, ptr %lua_memory, align 8
  %5 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 1), align 8
  %6 = load i64, ptr %lua_memory, align 8
  %sub = sub i64 %5, %6
  store i64 %sub, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 4), align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.then5
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 3), align 8
  %tobool13 = icmp ne i64 %7, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end12
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 4), align 8
  store i64 %8, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 3), align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end12
  %9 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 2), align 8
  %tobool16 = icmp ne i64 %9, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123), align 8
  store i64 %10, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 2), align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %lor.lhs.false
  ret void
}

declare i64 @zmalloc_used_memory() #2

declare i64 @zmalloc_get_rss() #2

declare i32 @zmalloc_get_allocator_info(ptr noundef, ptr noundef, ptr noundef) #2

declare i64 @evalMemory() #2

; Function Attrs: nounwind uwtable
define dso_local i32 @serverCron(ptr noundef %eventLoop, i64 noundef %id, ptr noundef %clientData) #0 {
entry:
  %retval = alloca i32, align 4
  %eventLoop.addr = alloca ptr, align 8
  %id.addr = alloca i64, align 8
  %clientData.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %cron_start = alloca i64, align 8
  %stat_net_input_bytes = alloca i64, align 8
  %stat_net_output_bytes = alloca i64, align 8
  %stat_net_repl_input_bytes = alloca i64, align 8
  %stat_net_repl_output_bytes = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %atomic-temp21 = alloca i64, align 8
  %atomic-temp24 = alloca i64, align 8
  %atomic-temp27 = alloca i64, align 8
  %current_time = alloca i64, align 8
  %factor = alloca i64, align 8
  %shutdownFlags = alloca i32, align 4
  %size = alloca i64, align 8
  %used = alloca i64, align 8
  %vkeys = alloca i64, align 8
  %sp = alloca ptr, align 8
  %rsi = alloca %struct.rdbSaveInfo, align 8
  %rsiptr = alloca ptr, align 8
  %base = alloca i64, align 8
  %growth = alloca i64, align 8
  %rsi320 = alloca %struct.rdbSaveInfo, align 8
  %rsiptr321 = alloca ptr, align 8
  %ei = alloca %struct.RedisModuleCronLoopInfo, align 8
  store ptr %eventLoop, ptr %eventLoop.addr, align 8
  store i64 %id, ptr %id.addr, align 8
  store ptr %clientData, ptr %clientData.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 400), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 400), align 8
  call void @watchdogScheduleSignal(i32 noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 6), align 4
  store i32 %2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 5), align 8
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end7, %if.then2
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  %len = getelementptr inbounds %struct.list, ptr %4, i32 0, i32 5
  %5 = load i64, ptr %len, align 8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %conv = sext i32 %6 to i64
  %div = udiv i64 %5, %conv
  %cmp = icmp ugt i64 %div, 200
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %mul = mul nsw i32 %7, 2
  store i32 %mul, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %cmp4 = icmp sgt i32 %8, 500
  br i1 %cmp4, label %if.then6, label %if.end7

if.then6:                                         ; preds = %while.body
  store i32 500, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  br label %while.end

if.end7:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !13

while.end:                                        ; preds = %if.then6, %while.cond
  br label %if.end8

if.end8:                                          ; preds = %while.end, %if.end
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 180), align 8
  %tobool9 = icmp ne i32 %9, 0
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div11 = sdiv i32 1000, %10
  store i32 %div11, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end8
  %11 = load ptr, ptr @getMonotonicUs, align 8
  %call = call i64 %11()
  store i64 %call, ptr %cron_start, align 8
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div13 = sdiv i32 1000, %12
  %cmp14 = icmp sle i32 100, %div13
  br i1 %cmp14, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end12
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div16 = sdiv i32 1000, %14
  %div17 = sdiv i32 100, %div16
  %rem = srem i32 %13, %div17
  %tobool18 = icmp ne i32 %rem, 0
  br i1 %tobool18, label %if.end31, label %if.then19

if.then19:                                        ; preds = %lor.lhs.false, %if.end12
  br label %do.body

do.body:                                          ; preds = %if.then19
  %15 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 124) monotonic, align 8
  store i64 %15, ptr %atomic-temp, align 8
  %16 = load i64, ptr %atomic-temp, align 8
  store i64 %16, ptr %stat_net_input_bytes, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body20

do.body20:                                        ; preds = %do.end
  %17 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 125) monotonic, align 8
  store i64 %17, ptr %atomic-temp21, align 8
  %18 = load i64, ptr %atomic-temp21, align 8
  store i64 %18, ptr %stat_net_output_bytes, align 8
  br label %do.end22

do.end22:                                         ; preds = %do.body20
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  %19 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 126) monotonic, align 8
  store i64 %19, ptr %atomic-temp24, align 8
  %20 = load i64, ptr %atomic-temp24, align 8
  store i64 %20, ptr %stat_net_repl_input_bytes, align 8
  br label %do.end25

do.end25:                                         ; preds = %do.body23
  br label %do.body26

do.body26:                                        ; preds = %do.end25
  %21 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 127) monotonic, align 8
  store i64 %21, ptr %atomic-temp27, align 8
  %22 = load i64, ptr %atomic-temp27, align 8
  store i64 %22, ptr %stat_net_repl_output_bytes, align 8
  br label %do.end28

do.end28:                                         ; preds = %do.body26
  %23 = load ptr, ptr @getMonotonicUs, align 8
  %call29 = call i64 %23()
  store i64 %call29, ptr %current_time, align 8
  store i64 1000000, ptr %factor, align 8
  %24 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 89), align 8
  %25 = load i64, ptr %current_time, align 8
  %26 = load i64, ptr %factor, align 8
  call void @trackInstantaneousMetric(i32 noundef 0, i64 noundef %24, i64 noundef %25, i64 noundef %26)
  %27 = load i64, ptr %stat_net_input_bytes, align 8
  %28 = load i64, ptr %stat_net_repl_input_bytes, align 8
  %add = add nsw i64 %27, %28
  %29 = load i64, ptr %current_time, align 8
  %30 = load i64, ptr %factor, align 8
  call void @trackInstantaneousMetric(i32 noundef 1, i64 noundef %add, i64 noundef %29, i64 noundef %30)
  %31 = load i64, ptr %stat_net_output_bytes, align 8
  %32 = load i64, ptr %stat_net_repl_output_bytes, align 8
  %add30 = add nsw i64 %31, %32
  %33 = load i64, ptr %current_time, align 8
  %34 = load i64, ptr %factor, align 8
  call void @trackInstantaneousMetric(i32 noundef 2, i64 noundef %add30, i64 noundef %33, i64 noundef %34)
  %35 = load i64, ptr %stat_net_repl_input_bytes, align 8
  %36 = load i64, ptr %current_time, align 8
  %37 = load i64, ptr %factor, align 8
  call void @trackInstantaneousMetric(i32 noundef 3, i64 noundef %35, i64 noundef %36, i64 noundef %37)
  %38 = load i64, ptr %stat_net_repl_output_bytes, align 8
  %39 = load i64, ptr %current_time, align 8
  %40 = load i64, ptr %factor, align 8
  call void @trackInstantaneousMetric(i32 noundef 4, i64 noundef %38, i64 noundef %39, i64 noundef %40)
  %41 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155), align 8
  %42 = load i64, ptr %current_time, align 8
  %43 = load i64, ptr %factor, align 8
  call void @trackInstantaneousMetric(i32 noundef 5, i64 noundef %41, i64 noundef %42, i64 noundef %43)
  %44 = load i64, ptr getelementptr inbounds (%struct.durationStats, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155), i32 0, i32 1), align 8
  %45 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155), align 8
  call void @trackInstantaneousMetric(i32 noundef 6, i64 noundef %44, i64 noundef %45, i64 noundef 1)
  br label %if.end31

if.end31:                                         ; preds = %do.end28, %lor.lhs.false
  %call32 = call i32 @getLRUClock()
  store i32 %call32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 16), align 8
  call void @cronUpdateMemoryStats()
  %46 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  %tobool33 = icmp ne i32 %46, 0
  br i1 %tobool33, label %land.lhs.true, label %if.else54

land.lhs.true:                                    ; preds = %if.end31
  %call34 = call i32 @isShutdownInitiated()
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.else54, label %if.then36

if.then36:                                        ; preds = %land.lhs.true
  store i32 0, ptr %shutdownFlags, align 4
  %47 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 19), align 8
  %cmp37 = icmp eq i32 %47, 2
  br i1 %cmp37, label %land.lhs.true39, label %if.else

land.lhs.true39:                                  ; preds = %if.then36
  %48 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 258), align 4
  %tobool40 = icmp ne i32 %48, 0
  br i1 %tobool40, label %if.then41, label %if.else

if.then41:                                        ; preds = %land.lhs.true39
  %49 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 258), align 4
  store i32 %49, ptr %shutdownFlags, align 4
  br label %if.end48

if.else:                                          ; preds = %land.lhs.true39, %if.then36
  %50 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 19), align 8
  %cmp42 = icmp eq i32 %50, 15
  br i1 %cmp42, label %land.lhs.true44, label %if.end47

land.lhs.true44:                                  ; preds = %if.else
  %51 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 259), align 8
  %tobool45 = icmp ne i32 %51, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %land.lhs.true44
  %52 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 259), align 8
  store i32 %52, ptr %shutdownFlags, align 4
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %land.lhs.true44, %if.else
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.then41
  %53 = load i32, ptr %shutdownFlags, align 4
  %call49 = call i32 @prepareForShutdown(i32 noundef %53)
  %cmp50 = icmp eq i32 %call49, 0
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.end48
  call void @exit(i32 noundef 0) #16
  unreachable

if.end53:                                         ; preds = %if.end48
  br label %if.end71

if.else54:                                        ; preds = %land.lhs.true, %if.end31
  %call55 = call i32 @isShutdownInitiated()
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.then57, label %if.end70

if.then57:                                        ; preds = %if.else54
  %54 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  %55 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 18), align 8
  %cmp58 = icmp sge i64 %54, %55
  br i1 %cmp58, label %if.then63, label %lor.lhs.false60

lor.lhs.false60:                                  ; preds = %if.then57
  %call61 = call i32 @isReadyToShutdown()
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.then63, label %if.end69

if.then63:                                        ; preds = %lor.lhs.false60, %if.then57
  %call64 = call i32 @finishShutdown()
  %cmp65 = icmp eq i32 %call64, 0
  br i1 %cmp65, label %if.then67, label %if.end68

if.then67:                                        ; preds = %if.then63
  call void @exit(i32 noundef 0) #16
  unreachable

if.end68:                                         ; preds = %if.then63
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %lor.lhs.false60
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %if.else54
  br label %if.end71

if.end71:                                         ; preds = %if.end70, %if.end53
  %56 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp72 = icmp sle i32 %56, 1
  br i1 %cmp72, label %if.then74, label %if.end105

if.then74:                                        ; preds = %if.end71
  %57 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div75 = sdiv i32 1000, %57
  %cmp76 = icmp sle i32 5000, %div75
  br i1 %cmp76, label %if.then83, label %lor.lhs.false78

lor.lhs.false78:                                  ; preds = %if.then74
  %58 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %59 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div79 = sdiv i32 1000, %59
  %div80 = sdiv i32 5000, %div79
  %rem81 = srem i32 %58, %div80
  %tobool82 = icmp ne i32 %rem81, 0
  br i1 %tobool82, label %if.end104, label %if.then83

if.then83:                                        ; preds = %lor.lhs.false78, %if.then74
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then83
  %60 = load i32, ptr %j, align 4
  %61 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 173), align 8
  %cmp84 = icmp slt i32 %60, %61
  br i1 %cmp84, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %62 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %63 = load i32, ptr %j, align 4
  %idxprom = sext i32 %63 to i64
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %62, i64 %idxprom
  %call86 = call i64 @dbBuckets(ptr noundef %arrayidx, i32 noundef 0)
  store i64 %call86, ptr %size, align 8
  %64 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %65 = load i32, ptr %j, align 4
  %idxprom87 = sext i32 %65 to i64
  %arrayidx88 = getelementptr inbounds %struct.redisDb, ptr %64, i64 %idxprom87
  %call89 = call i64 @dbSize(ptr noundef %arrayidx88, i32 noundef 0)
  store i64 %call89, ptr %used, align 8
  %66 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %67 = load i32, ptr %j, align 4
  %idxprom90 = sext i32 %67 to i64
  %arrayidx91 = getelementptr inbounds %struct.redisDb, ptr %66, i64 %idxprom90
  %call92 = call i64 @dbSize(ptr noundef %arrayidx91, i32 noundef 1)
  store i64 %call92, ptr %vkeys, align 8
  %68 = load i64, ptr %used, align 8
  %tobool93 = icmp ne i64 %68, 0
  br i1 %tobool93, label %if.then96, label %lor.lhs.false94

lor.lhs.false94:                                  ; preds = %for.body
  %69 = load i64, ptr %vkeys, align 8
  %tobool95 = icmp ne i64 %69, 0
  br i1 %tobool95, label %if.then96, label %if.end103

if.then96:                                        ; preds = %lor.lhs.false94, %for.body
  br label %do.body97

do.body97:                                        ; preds = %if.then96
  %70 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp98 = icmp slt i32 1, %70
  br i1 %cmp98, label %if.then100, label %if.end101

if.then100:                                       ; preds = %do.body97
  br label %do.end102

if.end101:                                        ; preds = %do.body97
  %71 = load i32, ptr %j, align 4
  %72 = load i64, ptr %used, align 8
  %73 = load i64, ptr %vkeys, align 8
  %74 = load i64, ptr %size, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.22, i32 noundef %71, i64 noundef %72, i64 noundef %73, i64 noundef %74)
  br label %do.end102

do.end102:                                        ; preds = %if.end101, %if.then100
  br label %if.end103

if.end103:                                        ; preds = %do.end102, %lor.lhs.false94
  br label %for.inc

for.inc:                                          ; preds = %if.end103
  %75 = load i32, ptr %j, align 4
  %inc = add nsw i32 %75, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  br label %if.end104

if.end104:                                        ; preds = %for.end, %lor.lhs.false78
  br label %if.end105

if.end105:                                        ; preds = %if.end104, %if.end71
  %76 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool106 = icmp ne i32 %76, 0
  br i1 %tobool106, label %if.end128, label %if.then107

if.then107:                                       ; preds = %if.end105
  %77 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div108 = sdiv i32 1000, %77
  %cmp109 = icmp sle i32 5000, %div108
  br i1 %cmp109, label %if.then116, label %lor.lhs.false111

lor.lhs.false111:                                 ; preds = %if.then107
  %78 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %79 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div112 = sdiv i32 1000, %79
  %div113 = sdiv i32 5000, %div112
  %rem114 = srem i32 %78, %div113
  %tobool115 = icmp ne i32 %rem114, 0
  br i1 %tobool115, label %if.end127, label %if.then116

if.then116:                                       ; preds = %lor.lhs.false111, %if.then107
  br label %do.body117

do.body117:                                       ; preds = %if.then116
  %80 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp118 = icmp slt i32 0, %80
  br i1 %cmp118, label %if.then120, label %if.end121

if.then120:                                       ; preds = %do.body117
  br label %do.end126

if.end121:                                        ; preds = %do.body117
  %81 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  %len122 = getelementptr inbounds %struct.list, ptr %81, i32 0, i32 5
  %82 = load i64, ptr %len122, align 8
  %83 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %len123 = getelementptr inbounds %struct.list, ptr %83, i32 0, i32 5
  %84 = load i64, ptr %len123, align 8
  %sub = sub i64 %82, %84
  %85 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %len124 = getelementptr inbounds %struct.list, ptr %85, i32 0, i32 5
  %86 = load i64, ptr %len124, align 8
  %call125 = call i64 @zmalloc_used_memory()
  call void (i32, ptr, ...) @_serverLog(i32 noundef 0, ptr noundef @.str.23, i64 noundef %sub, i64 noundef %86, i64 noundef %call125)
  br label %do.end126

do.end126:                                        ; preds = %if.end121, %if.then120
  br label %if.end127

if.end127:                                        ; preds = %do.end126, %lor.lhs.false111
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.end105
  call void @clientsCron()
  call void @databasesCron()
  %call129 = call i32 @hasActiveChildProcess()
  %tobool130 = icmp ne i32 %call129, 0
  br i1 %tobool130, label %if.end138, label %land.lhs.true131

land.lhs.true131:                                 ; preds = %if.end128
  %87 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 197), align 4
  %tobool132 = icmp ne i32 %87, 0
  br i1 %tobool132, label %land.lhs.true133, label %if.end138

land.lhs.true133:                                 ; preds = %land.lhs.true131
  %call134 = call i32 @aofRewriteLimited()
  %tobool135 = icmp ne i32 %call134, 0
  br i1 %tobool135, label %if.end138, label %if.then136

if.then136:                                       ; preds = %land.lhs.true133
  %call137 = call i32 @rewriteAppendOnlyFileBackground()
  br label %if.end138

if.end138:                                        ; preds = %if.then136, %land.lhs.true133, %land.lhs.true131, %if.end128
  %call139 = call i32 @hasActiveChildProcess()
  %tobool140 = icmp ne i32 %call139, 0
  br i1 %tobool140, label %if.then144, label %lor.lhs.false141

lor.lhs.false141:                                 ; preds = %if.end138
  %call142 = call i32 @ldbPendingChildren()
  %tobool143 = icmp ne i32 %call142, 0
  br i1 %tobool143, label %if.then144, label %if.else155

if.then144:                                       ; preds = %lor.lhs.false141, %if.end138
  %88 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div145 = sdiv i32 1000, %88
  %cmp146 = icmp sle i32 1000, %div145
  br i1 %cmp146, label %if.then153, label %lor.lhs.false148

lor.lhs.false148:                                 ; preds = %if.then144
  %89 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %90 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div149 = sdiv i32 1000, %90
  %div150 = sdiv i32 1000, %div149
  %rem151 = srem i32 %89, %div150
  %tobool152 = icmp ne i32 %rem151, 0
  br i1 %tobool152, label %if.end154, label %if.then153

if.then153:                                       ; preds = %lor.lhs.false148, %if.then144
  call void @receiveChildInfo()
  br label %if.end154

if.end154:                                        ; preds = %if.then153, %lor.lhs.false148
  call void @checkChildrenDone()
  br label %if.end222

if.else155:                                       ; preds = %lor.lhs.false141
  store i32 0, ptr %j, align 4
  br label %for.cond156

for.cond156:                                      ; preds = %for.inc188, %if.else155
  %91 = load i32, ptr %j, align 4
  %92 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 224), align 8
  %cmp157 = icmp slt i32 %91, %92
  br i1 %cmp157, label %for.body159, label %for.end190

for.body159:                                      ; preds = %for.cond156
  %93 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 223), align 8
  %94 = load i32, ptr %j, align 4
  %idx.ext = sext i32 %94 to i64
  %add.ptr = getelementptr inbounds %struct.saveparam, ptr %93, i64 %idx.ext
  store ptr %add.ptr, ptr %sp, align 8
  %95 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  %96 = load ptr, ptr %sp, align 8
  %changes = getelementptr inbounds %struct.saveparam, ptr %96, i32 0, i32 1
  %97 = load i32, ptr %changes, align 8
  %conv160 = sext i32 %97 to i64
  %cmp161 = icmp sge i64 %95, %conv160
  br i1 %cmp161, label %land.lhs.true163, label %if.end187

land.lhs.true163:                                 ; preds = %for.body159
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %98 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 229), align 8
  %sub164 = sub nsw i64 %atomic-load, %98
  %99 = load ptr, ptr %sp, align 8
  %seconds = getelementptr inbounds %struct.saveparam, ptr %99, i32 0, i32 0
  %100 = load i64, ptr %seconds, align 8
  %cmp165 = icmp sgt i64 %sub164, %100
  br i1 %cmp165, label %land.lhs.true167, label %if.end187

land.lhs.true167:                                 ; preds = %land.lhs.true163
  %atomic-load168 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %101 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 230), align 8
  %sub169 = sub nsw i64 %atomic-load168, %101
  %cmp170 = icmp sgt i64 %sub169, 5
  br i1 %cmp170, label %if.then175, label %lor.lhs.false172

lor.lhs.false172:                                 ; preds = %land.lhs.true167
  %102 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 235), align 8
  %cmp173 = icmp eq i32 %102, 0
  br i1 %cmp173, label %if.then175, label %if.end187

if.then175:                                       ; preds = %lor.lhs.false172, %land.lhs.true167
  br label %do.body176

do.body176:                                       ; preds = %if.then175
  %103 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp177 = icmp slt i32 2, %103
  br i1 %cmp177, label %if.then179, label %if.end180

if.then179:                                       ; preds = %do.body176
  br label %do.end184

if.end180:                                        ; preds = %do.body176
  %104 = load ptr, ptr %sp, align 8
  %changes181 = getelementptr inbounds %struct.saveparam, ptr %104, i32 0, i32 1
  %105 = load i32, ptr %changes181, align 8
  %106 = load ptr, ptr %sp, align 8
  %seconds182 = getelementptr inbounds %struct.saveparam, ptr %106, i32 0, i32 0
  %107 = load i64, ptr %seconds182, align 8
  %conv183 = trunc i64 %107 to i32
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.24, i32 noundef %105, i32 noundef %conv183)
  br label %do.end184

do.end184:                                        ; preds = %if.end180, %if.then179
  %call185 = call ptr @rdbPopulateSaveInfo(ptr noundef %rsi)
  store ptr %call185, ptr %rsiptr, align 8
  %108 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 225), align 8
  %109 = load ptr, ptr %rsiptr, align 8
  %call186 = call i32 @rdbSaveBackground(i32 noundef 0, ptr noundef %108, ptr noundef %109, i32 noundef 0)
  br label %for.end190

if.end187:                                        ; preds = %lor.lhs.false172, %land.lhs.true163, %for.body159
  br label %for.inc188

for.inc188:                                       ; preds = %if.end187
  %110 = load i32, ptr %j, align 4
  %inc189 = add nsw i32 %110, 1
  store i32 %inc189, ptr %j, align 4
  br label %for.cond156, !llvm.loop !15

for.end190:                                       ; preds = %do.end184, %for.cond156
  %111 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp191 = icmp eq i32 %111, 1
  br i1 %cmp191, label %land.lhs.true193, label %if.end221

land.lhs.true193:                                 ; preds = %for.end190
  %call194 = call i32 @hasActiveChildProcess()
  %tobool195 = icmp ne i32 %call194, 0
  br i1 %tobool195, label %if.end221, label %land.lhs.true196

land.lhs.true196:                                 ; preds = %land.lhs.true193
  %112 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 190), align 4
  %tobool197 = icmp ne i32 %112, 0
  br i1 %tobool197, label %land.lhs.true198, label %if.end221

land.lhs.true198:                                 ; preds = %land.lhs.true196
  %113 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 193), align 8
  %114 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 191), align 8
  %cmp199 = icmp sgt i64 %113, %114
  br i1 %cmp199, label %if.then201, label %if.end221

if.then201:                                       ; preds = %land.lhs.true198
  %115 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 192), align 8
  %tobool202 = icmp ne i64 %115, 0
  br i1 %tobool202, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then201
  %116 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 192), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then201
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %116, %cond.true ], [ 1, %cond.false ]
  store i64 %cond, ptr %base, align 8
  %117 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 193), align 8
  %mul203 = mul nsw i64 %117, 100
  %118 = load i64, ptr %base, align 8
  %div204 = sdiv i64 %mul203, %118
  %sub205 = sub nsw i64 %div204, 100
  store i64 %sub205, ptr %growth, align 8
  %119 = load i64, ptr %growth, align 8
  %120 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 190), align 4
  %conv206 = sext i32 %120 to i64
  %cmp207 = icmp sge i64 %119, %conv206
  br i1 %cmp207, label %land.lhs.true209, label %if.end220

land.lhs.true209:                                 ; preds = %cond.end
  %call210 = call i32 @aofRewriteLimited()
  %tobool211 = icmp ne i32 %call210, 0
  br i1 %tobool211, label %if.end220, label %if.then212

if.then212:                                       ; preds = %land.lhs.true209
  br label %do.body213

do.body213:                                       ; preds = %if.then212
  %121 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp214 = icmp slt i32 2, %121
  br i1 %cmp214, label %if.then216, label %if.end217

if.then216:                                       ; preds = %do.body213
  br label %do.end218

if.end217:                                        ; preds = %do.body213
  %122 = load i64, ptr %growth, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.25, i64 noundef %122)
  br label %do.end218

do.end218:                                        ; preds = %if.end217, %if.then216
  %call219 = call i32 @rewriteAppendOnlyFileBackground()
  br label %if.end220

if.end220:                                        ; preds = %do.end218, %land.lhs.true209, %cond.end
  br label %if.end221

if.end221:                                        ; preds = %if.end220, %land.lhs.true198, %land.lhs.true196, %land.lhs.true193, %for.end190
  br label %if.end222

if.end222:                                        ; preds = %if.end221, %if.end154
  call void @updateDictResizePolicy()
  %123 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp223 = icmp eq i32 %123, 1
  br i1 %cmp223, label %land.lhs.true228, label %lor.lhs.false225

lor.lhs.false225:                                 ; preds = %if.end222
  %124 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp226 = icmp eq i32 %124, 2
  br i1 %cmp226, label %land.lhs.true228, label %if.end231

land.lhs.true228:                                 ; preds = %lor.lhs.false225, %if.end222
  %125 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 201), align 8
  %tobool229 = icmp ne i64 %125, 0
  br i1 %tobool229, label %if.then230, label %if.end231

if.then230:                                       ; preds = %land.lhs.true228
  call void @flushAppendOnlyFile(i32 noundef 0)
  br label %if.end231

if.end231:                                        ; preds = %if.then230, %land.lhs.true228, %lor.lhs.false225
  %126 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div232 = sdiv i32 1000, %126
  %cmp233 = icmp sle i32 1000, %div232
  br i1 %cmp233, label %if.then240, label %lor.lhs.false235

lor.lhs.false235:                                 ; preds = %if.end231
  %127 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %128 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div236 = sdiv i32 1000, %128
  %div237 = sdiv i32 1000, %div236
  %rem238 = srem i32 %127, %div237
  %tobool239 = icmp ne i32 %rem238, 0
  br i1 %tobool239, label %if.end251, label %if.then240

if.then240:                                       ; preds = %lor.lhs.false235, %if.end231
  %129 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp241 = icmp eq i32 %129, 1
  br i1 %cmp241, label %land.lhs.true246, label %lor.lhs.false243

lor.lhs.false243:                                 ; preds = %if.then240
  %130 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp244 = icmp eq i32 %130, 2
  br i1 %cmp244, label %land.lhs.true246, label %if.end250

land.lhs.true246:                                 ; preds = %lor.lhs.false243, %if.then240
  %131 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 211), align 8
  %cmp247 = icmp eq i32 %131, -1
  br i1 %cmp247, label %if.then249, label %if.end250

if.then249:                                       ; preds = %land.lhs.true246
  call void @flushAppendOnlyFile(i32 noundef 0)
  br label %if.end250

if.end250:                                        ; preds = %if.then249, %land.lhs.true246, %lor.lhs.false243
  br label %if.end251

if.end251:                                        ; preds = %if.end250, %lor.lhs.false235
  call void @updatePausedActions()
  %132 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 415), align 4
  %cmp252 = icmp ne i32 %132, 0
  br i1 %cmp252, label %if.then254, label %if.else265

if.then254:                                       ; preds = %if.end251
  %133 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div255 = sdiv i32 1000, %133
  %cmp256 = icmp sle i32 100, %div255
  br i1 %cmp256, label %if.then263, label %lor.lhs.false258

lor.lhs.false258:                                 ; preds = %if.then254
  %134 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %135 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div259 = sdiv i32 1000, %135
  %div260 = sdiv i32 100, %div259
  %rem261 = srem i32 %134, %div260
  %tobool262 = icmp ne i32 %rem261, 0
  br i1 %tobool262, label %if.end264, label %if.then263

if.then263:                                       ; preds = %lor.lhs.false258, %if.then254
  call void @replicationCron()
  br label %if.end264

if.end264:                                        ; preds = %if.then263, %lor.lhs.false258
  br label %if.end276

if.else265:                                       ; preds = %if.end251
  %136 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div266 = sdiv i32 1000, %136
  %cmp267 = icmp sle i32 1000, %div266
  br i1 %cmp267, label %if.then274, label %lor.lhs.false269

lor.lhs.false269:                                 ; preds = %if.else265
  %137 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %138 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div270 = sdiv i32 1000, %138
  %div271 = sdiv i32 1000, %div270
  %rem272 = srem i32 %137, %div271
  %tobool273 = icmp ne i32 %rem272, 0
  br i1 %tobool273, label %if.end275, label %if.then274

if.then274:                                       ; preds = %lor.lhs.false269, %if.else265
  call void @replicationCron()
  br label %if.end275

if.end275:                                        ; preds = %if.then274, %lor.lhs.false269
  br label %if.end276

if.end276:                                        ; preds = %if.end275, %if.end264
  %139 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div277 = sdiv i32 1000, %139
  %cmp278 = icmp sle i32 100, %div277
  br i1 %cmp278, label %if.then285, label %lor.lhs.false280

lor.lhs.false280:                                 ; preds = %if.end276
  %140 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %141 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div281 = sdiv i32 1000, %141
  %div282 = sdiv i32 100, %div281
  %rem283 = srem i32 %140, %div282
  %tobool284 = icmp ne i32 %rem283, 0
  br i1 %tobool284, label %if.end289, label %if.then285

if.then285:                                       ; preds = %lor.lhs.false280, %if.end276
  %142 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool286 = icmp ne i32 %142, 0
  br i1 %tobool286, label %if.then287, label %if.end288

if.then287:                                       ; preds = %if.then285
  call void @clusterCron()
  br label %if.end288

if.end288:                                        ; preds = %if.then287, %if.then285
  br label %if.end289

if.end289:                                        ; preds = %if.end288, %lor.lhs.false280
  %143 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool290 = icmp ne i32 %143, 0
  br i1 %tobool290, label %if.then291, label %if.end292

if.then291:                                       ; preds = %if.end289
  call void @sentinelTimer()
  br label %if.end292

if.end292:                                        ; preds = %if.then291, %if.end289
  %144 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div293 = sdiv i32 1000, %144
  %cmp294 = icmp sle i32 1000, %div293
  br i1 %cmp294, label %if.then301, label %lor.lhs.false296

lor.lhs.false296:                                 ; preds = %if.end292
  %145 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %146 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div297 = sdiv i32 1000, %146
  %div298 = sdiv i32 1000, %div297
  %rem299 = srem i32 %145, %div298
  %tobool300 = icmp ne i32 %rem299, 0
  br i1 %tobool300, label %if.end302, label %if.then301

if.then301:                                       ; preds = %lor.lhs.false296, %if.end292
  call void @migrateCloseTimedoutSockets()
  br label %if.end302

if.end302:                                        ; preds = %if.then301, %lor.lhs.false296
  %call303 = call i32 @stopThreadedIOIfNeeded()
  %147 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 329), align 8
  %tobool304 = icmp ne i32 %147, 0
  br i1 %tobool304, label %if.then305, label %if.end306

if.then305:                                       ; preds = %if.end302
  call void @trackingLimitUsedSlots()
  br label %if.end306

if.end306:                                        ; preds = %if.then305, %if.end302
  %call307 = call i32 @hasActiveChildProcess()
  %tobool308 = icmp ne i32 %call307, 0
  br i1 %tobool308, label %if.end328, label %land.lhs.true309

land.lhs.true309:                                 ; preds = %if.end306
  %148 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 233), align 8
  %tobool310 = icmp ne i32 %148, 0
  br i1 %tobool310, label %land.lhs.true311, label %if.end328

land.lhs.true311:                                 ; preds = %land.lhs.true309
  %atomic-load312 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %149 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 230), align 8
  %sub313 = sub nsw i64 %atomic-load312, %149
  %cmp314 = icmp sgt i64 %sub313, 5
  br i1 %cmp314, label %if.then319, label %lor.lhs.false316

lor.lhs.false316:                                 ; preds = %land.lhs.true311
  %150 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 235), align 8
  %cmp317 = icmp eq i32 %150, 0
  br i1 %cmp317, label %if.then319, label %if.end328

if.then319:                                       ; preds = %lor.lhs.false316, %land.lhs.true311
  %call322 = call ptr @rdbPopulateSaveInfo(ptr noundef %rsi320)
  store ptr %call322, ptr %rsiptr321, align 8
  %151 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 225), align 8
  %152 = load ptr, ptr %rsiptr321, align 8
  %call323 = call i32 @rdbSaveBackground(i32 noundef 0, ptr noundef %151, ptr noundef %152, i32 noundef 0)
  %cmp324 = icmp eq i32 %call323, 0
  br i1 %cmp324, label %if.then326, label %if.end327

if.then326:                                       ; preds = %if.then319
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 233), align 8
  br label %if.end327

if.end327:                                        ; preds = %if.then326, %if.then319
  br label %if.end328

if.end328:                                        ; preds = %if.end327, %lor.lhs.false316, %land.lhs.true309, %if.end306
  %153 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div329 = sdiv i32 1000, %153
  %cmp330 = icmp sle i32 100, %div329
  br i1 %cmp330, label %if.then337, label %lor.lhs.false332

lor.lhs.false332:                                 ; preds = %if.end328
  %154 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %155 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div333 = sdiv i32 1000, %155
  %div334 = sdiv i32 100, %div333
  %rem335 = srem i32 %154, %div334
  %tobool336 = icmp ne i32 %rem335, 0
  br i1 %tobool336, label %if.end342, label %if.then337

if.then337:                                       ; preds = %lor.lhs.false332, %if.end328
  %call338 = call i64 @moduleCount()
  %tobool339 = icmp ne i64 %call338, 0
  br i1 %tobool339, label %if.then340, label %if.end341

if.then340:                                       ; preds = %if.then337
  call void @modulesCron()
  br label %if.end341

if.end341:                                        ; preds = %if.then340, %if.then337
  br label %if.end342

if.end342:                                        ; preds = %if.end341, %lor.lhs.false332
  %version = getelementptr inbounds %struct.RedisModuleCronLoopInfo, ptr %ei, i32 0, i32 0
  store i64 1, ptr %version, align 8
  %hz = getelementptr inbounds %struct.RedisModuleCronLoopInfo, ptr %ei, i32 0, i32 1
  %156 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  store i32 %156, ptr %hz, align 8
  call void @moduleFireServerEvent(i64 noundef 8, i32 noundef 0, ptr noundef %ei)
  %157 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %inc343 = add nsw i32 %157, 1
  store i32 %inc343, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %158 = load ptr, ptr @getMonotonicUs, align 8
  %call344 = call i64 %158()
  %159 = load i64, ptr %cron_start, align 8
  %sub345 = sub i64 %call344, %159
  store i64 %sub345, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 154), align 8
  %160 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div346 = sdiv i32 1000, %160
  store i32 %div346, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end342, %if.then10
  %161 = load i32, ptr %retval, align 4
  ret i32 %161
}

declare void @watchdogScheduleSignal(i32 noundef) #2

declare i32 @getLRUClock() #2

; Function Attrs: nounwind uwtable
define internal i32 @isShutdownInitiated() #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 18), align 8
  %cmp = icmp ne i64 %0, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define dso_local i32 @prepareForShutdown(i32 noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  %call = call i32 @isShutdownInitiated()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %0 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool2 = icmp ne i32 %1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  %2 = load i32, ptr %flags.addr, align 4
  %and = and i32 %2, -2
  %or = or i32 %and, 2
  store i32 %or, ptr %flags.addr, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %lor.lhs.false
  %3 = load i32, ptr %flags.addr, align 4
  store i32 %3, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 20), align 4
  br label %do.body

do.body:                                          ; preds = %if.end4
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 2, %4
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %do.body
  br label %do.end

if.end6:                                          ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.193)
  br label %do.end

do.end:                                           ; preds = %if.end6, %if.then5
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %cmp7 = icmp eq i32 %5, 2
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %do.end
  %call9 = call i32 @redisCommunicateSystemd(ptr noundef @.str.194)
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %do.end
  %6 = load i32, ptr %flags.addr, align 4
  %and11 = and i32 %6, 4
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.end28, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end10
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 257), align 8
  %cmp13 = icmp ne i32 %7, 0
  br i1 %cmp13, label %land.lhs.true14, label %if.end28

land.lhs.true14:                                  ; preds = %land.lhs.true
  %call15 = call i32 @isReadyToShutdown()
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end28, label %if.then17

if.then17:                                        ; preds = %land.lhs.true14
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 257), align 8
  %mul = mul nsw i32 %9, 1000
  %conv = sext i32 %mul to i64
  %add = add nsw i64 %8, %conv
  store i64 %add, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 18), align 8
  %call18 = call i32 @isPausedActions(i32 noundef 16)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.then17
  call void @sendGetackToReplicas()
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %if.then17
  call void @pauseActions(i32 noundef 1, i64 noundef 9223372036854775807, i32 noundef 29)
  br label %do.body22

do.body22:                                        ; preds = %if.end21
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp23 = icmp slt i32 2, %10
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %do.body22
  br label %do.end27

if.end26:                                         ; preds = %do.body22
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.195)
  br label %do.end27

do.end27:                                         ; preds = %if.end26, %if.then25
  store i32 -1, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %land.lhs.true14, %land.lhs.true, %if.end10
  %call29 = call i32 @finishShutdown()
  store i32 %call29, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end28, %do.end27, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) #7

; Function Attrs: nounwind uwtable
define dso_local i32 @isReadyToShutdown() #0 {
entry:
  %retval = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %replica = alloca ptr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %len = getelementptr inbounds %struct.list, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %len, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  call void @listRewind(ptr noundef %2, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end4, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %cmp1 = icmp ne ptr %call, null
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %value, align 8
  store ptr %4, ptr %replica, align 8
  %5 = load ptr, ptr %replica, align 8
  %repl_ack_off = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 44
  %6 = load i64, ptr %repl_ack_off, align 8
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %cmp2 = icmp ne i64 %6, %7
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %while.body
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %while.body
  br label %while.cond, !llvm.loop !16

while.end:                                        ; preds = %while.cond
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then3, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define dso_local i32 @finishShutdown() #0 {
entry:
  %retval = alloca i32, align 4
  %save = alloca i32, align 4
  %nosave = alloca i32, align 4
  %force = alloca i32, align 4
  %replicas_iter = alloca %struct.listIter, align 8
  %replicas_list_node = alloca ptr, align 8
  %num_replicas = alloca i32, align 4
  %num_lagging_replicas = alloca i32, align 4
  %replica = alloca ptr, align 8
  %lag = alloca i64, align 8
  %rsi = alloca %struct.rdbSaveInfo, align 8
  %rsiptr = alloca ptr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 20), align 4
  %and = and i32 %0, 1
  store i32 %and, ptr %save, align 4
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 20), align 4
  %and1 = and i32 %1, 2
  store i32 %and1, ptr %nosave, align 4
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 20), align 4
  %and2 = and i32 %2, 8
  store i32 %and2, ptr %force, align 4
  store i32 0, ptr %num_replicas, align 4
  store i32 0, ptr %num_lagging_replicas, align 4
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  call void @listRewind(ptr noundef %3, ptr noundef %replicas_iter)
  br label %while.cond

while.cond:                                       ; preds = %if.end14, %entry
  %call = call ptr @listNext(ptr noundef %replicas_iter)
  store ptr %call, ptr %replicas_list_node, align 8
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load ptr, ptr %replicas_list_node, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %value, align 8
  store ptr %5, ptr %replica, align 8
  %6 = load i32, ptr %num_replicas, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %num_replicas, align 4
  %7 = load ptr, ptr %replica, align 8
  %repl_ack_off = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 44
  %8 = load i64, ptr %repl_ack_off, align 8
  %9 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %cmp3 = icmp ne i64 %8, %9
  br i1 %cmp3, label %if.then, label %if.end14

if.then:                                          ; preds = %while.body
  %10 = load i32, ptr %num_lagging_replicas, align 4
  %inc4 = add nsw i32 %10, 1
  store i32 %inc4, ptr %num_lagging_replicas, align 4
  %11 = load ptr, ptr %replica, align 8
  %replstate = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 35
  %12 = load i32, ptr %replstate, align 4
  %cmp5 = icmp eq i32 %12, 9
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %call6 = call i64 @time(ptr noundef null) #13
  %13 = load ptr, ptr %replica, align 8
  %repl_ack_time = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 46
  %14 = load i64, ptr %repl_ack_time, align 8
  %sub = sub nsw i64 %call6, %14
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, ptr %lag, align 8
  br label %do.body

do.body:                                          ; preds = %cond.end
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp7 = icmp slt i32 2, %15
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %16 = load ptr, ptr %replica, align 8
  %call9 = call ptr @replicationGetSlaveName(ptr noundef %16)
  %17 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %18 = load ptr, ptr %replica, align 8
  %repl_ack_off10 = getelementptr inbounds %struct.client, ptr %18, i32 0, i32 44
  %19 = load i64, ptr %repl_ack_off10, align 8
  %sub11 = sub nsw i64 %17, %19
  %20 = load i64, ptr %lag, align 8
  %21 = load ptr, ptr %replica, align 8
  %replstate12 = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 35
  %22 = load i32, ptr %replstate12, align 4
  %call13 = call ptr @replstateToString(i32 noundef %22)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.197, ptr noundef %call9, i64 noundef %sub11, i64 noundef %20, ptr noundef %call13)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then8
  br label %if.end14

if.end14:                                         ; preds = %do.end, %while.body
  br label %while.cond, !llvm.loop !17

while.end:                                        ; preds = %while.cond
  %23 = load i32, ptr %num_replicas, align 4
  %cmp15 = icmp sgt i32 %23, 0
  br i1 %cmp15, label %if.then16, label %if.end23

if.then16:                                        ; preds = %while.end
  br label %do.body17

do.body17:                                        ; preds = %if.then16
  %24 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp18 = icmp slt i32 2, %24
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %do.body17
  br label %do.end22

if.end20:                                         ; preds = %do.body17
  %25 = load i32, ptr %num_replicas, align 4
  %26 = load i32, ptr %num_lagging_replicas, align 4
  %sub21 = sub nsw i32 %25, %26
  %27 = load i32, ptr %num_replicas, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.198, i32 noundef %sub21, i32 noundef %27)
  br label %do.end22

do.end22:                                         ; preds = %if.end20, %if.then19
  br label %if.end23

if.end23:                                         ; preds = %do.end22, %while.end
  call void @ldbKillForkedSessions()
  %28 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp24 = icmp eq i32 %28, 1
  br i1 %cmp24, label %if.then25, label %if.end31

if.then25:                                        ; preds = %if.end23
  br label %do.body26

do.body26:                                        ; preds = %if.then25
  %29 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp27 = icmp slt i32 3, %29
  br i1 %cmp27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %do.body26
  br label %do.end30

if.end29:                                         ; preds = %do.body26
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.199)
  br label %do.end30

do.end30:                                         ; preds = %if.end29, %if.then28
  call void @killRDBChild()
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  call void @rdbRemoveTempFile(i32 noundef %30, i32 noundef 0)
  br label %if.end31

if.end31:                                         ; preds = %do.end30, %if.end23
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp32 = icmp eq i32 %31, 4
  br i1 %cmp32, label %if.then33, label %if.end40

if.then33:                                        ; preds = %if.end31
  br label %do.body34

do.body34:                                        ; preds = %if.then33
  %32 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp35 = icmp slt i32 3, %32
  br i1 %cmp35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %do.body34
  br label %do.end38

if.end37:                                         ; preds = %do.body34
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.200)
  br label %do.end38

do.end38:                                         ; preds = %if.end37, %if.then36
  %33 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %call39 = call i32 @TerminateModuleForkChild(i32 noundef %33, i32 noundef 0)
  br label %if.end40

if.end40:                                         ; preds = %do.end38, %if.end31
  %34 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp41 = icmp eq i32 %34, 2
  br i1 %cmp41, label %if.then42, label %if.end67

if.then42:                                        ; preds = %if.end40
  %35 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp43 = icmp eq i32 %35, 2
  br i1 %cmp43, label %if.then44, label %if.end61

if.then44:                                        ; preds = %if.then42
  %36 = load i32, ptr %force, align 4
  %tobool = icmp ne i32 %36, 0
  br i1 %tobool, label %if.then45, label %if.else

if.then45:                                        ; preds = %if.then44
  br label %do.body46

do.body46:                                        ; preds = %if.then45
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp47 = icmp slt i32 3, %37
  br i1 %cmp47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %do.body46
  br label %do.end50

if.end49:                                         ; preds = %do.body46
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.201)
  br label %do.end50

do.end50:                                         ; preds = %if.end49, %if.then48
  br label %if.end60

if.else:                                          ; preds = %if.then44
  br label %do.body51

do.body51:                                        ; preds = %if.else
  %38 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp52 = icmp slt i32 3, %38
  br i1 %cmp52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %do.body51
  br label %do.end55

if.end54:                                         ; preds = %do.body51
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.202)
  br label %do.end55

do.end55:                                         ; preds = %if.end54, %if.then53
  %39 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %cmp56 = icmp eq i32 %39, 2
  br i1 %cmp56, label %if.then57, label %if.end59

if.then57:                                        ; preds = %do.end55
  %call58 = call i32 @redisCommunicateSystemd(ptr noundef @.str.203)
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %do.end55
  br label %error

if.end60:                                         ; preds = %do.end50
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.then42
  br label %do.body62

do.body62:                                        ; preds = %if.end61
  %40 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp63 = icmp slt i32 3, %40
  br i1 %cmp63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %do.body62
  br label %do.end66

if.end65:                                         ; preds = %do.body62
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.204)
  br label %do.end66

do.end66:                                         ; preds = %if.end65, %if.then64
  call void @killAppendOnlyChild()
  br label %if.end67

if.end67:                                         ; preds = %do.end66, %if.end40
  %41 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp68 = icmp ne i32 %41, 0
  br i1 %cmp68, label %if.then69, label %if.end86

if.then69:                                        ; preds = %if.end67
  br label %do.body70

do.body70:                                        ; preds = %if.then69
  %42 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp71 = icmp slt i32 2, %42
  br i1 %cmp71, label %if.then72, label %if.end73

if.then72:                                        ; preds = %do.body70
  br label %do.end74

if.end73:                                         ; preds = %do.body70
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.205)
  br label %do.end74

do.end74:                                         ; preds = %if.end73, %if.then72
  call void @flushAppendOnlyFile(i32 noundef 1)
  %43 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 199), align 8
  %call75 = call i32 @fdatasync(i32 noundef %43)
  %cmp76 = icmp eq i32 %call75, -1
  br i1 %cmp76, label %if.then77, label %if.end85

if.then77:                                        ; preds = %do.end74
  br label %do.body78

do.body78:                                        ; preds = %if.then77
  %44 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp79 = icmp slt i32 3, %44
  br i1 %cmp79, label %if.then80, label %if.end81

if.then80:                                        ; preds = %do.body78
  br label %do.end84

if.end81:                                         ; preds = %do.body78
  %call82 = call ptr @__errno_location() #17
  %45 = load i32, ptr %call82, align 4
  %call83 = call ptr @strerror(i32 noundef %45) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.206, ptr noundef %call83)
  br label %do.end84

do.end84:                                         ; preds = %if.end81, %if.then80
  br label %if.end85

if.end85:                                         ; preds = %do.end84, %do.end74
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.end67
  %46 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 224), align 8
  %cmp87 = icmp sgt i32 %46, 0
  br i1 %cmp87, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end86
  %47 = load i32, ptr %nosave, align 4
  %tobool88 = icmp ne i32 %47, 0
  br i1 %tobool88, label %lor.lhs.false, label %if.then90

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end86
  %48 = load i32, ptr %save, align 4
  %tobool89 = icmp ne i32 %48, 0
  br i1 %tobool89, label %if.then90, label %if.end123

if.then90:                                        ; preds = %lor.lhs.false, %land.lhs.true
  br label %do.body91

do.body91:                                        ; preds = %if.then90
  %49 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp92 = icmp slt i32 2, %49
  br i1 %cmp92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %do.body91
  br label %do.end95

if.end94:                                         ; preds = %do.body91
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.207)
  br label %do.end95

do.end95:                                         ; preds = %if.end94, %if.then93
  %50 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %cmp96 = icmp eq i32 %50, 2
  br i1 %cmp96, label %if.then97, label %if.end99

if.then97:                                        ; preds = %do.end95
  %call98 = call i32 @redisCommunicateSystemd(ptr noundef @.str.208)
  br label %if.end99

if.end99:                                         ; preds = %if.then97, %do.end95
  %call100 = call ptr @rdbPopulateSaveInfo(ptr noundef %rsi)
  store ptr %call100, ptr %rsiptr, align 8
  %51 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 225), align 8
  %52 = load ptr, ptr %rsiptr, align 8
  %call101 = call i32 @rdbSave(i32 noundef 0, ptr noundef %51, ptr noundef %52, i32 noundef 16)
  %cmp102 = icmp ne i32 %call101, 0
  br i1 %cmp102, label %if.then103, label %if.end122

if.then103:                                       ; preds = %if.end99
  %53 = load i32, ptr %force, align 4
  %tobool104 = icmp ne i32 %53, 0
  br i1 %tobool104, label %if.then105, label %if.else111

if.then105:                                       ; preds = %if.then103
  br label %do.body106

do.body106:                                       ; preds = %if.then105
  %54 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp107 = icmp slt i32 3, %54
  br i1 %cmp107, label %if.then108, label %if.end109

if.then108:                                       ; preds = %do.body106
  br label %do.end110

if.end109:                                        ; preds = %do.body106
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.209)
  br label %do.end110

do.end110:                                        ; preds = %if.end109, %if.then108
  br label %if.end121

if.else111:                                       ; preds = %if.then103
  br label %do.body112

do.body112:                                       ; preds = %if.else111
  %55 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp113 = icmp slt i32 3, %55
  br i1 %cmp113, label %if.then114, label %if.end115

if.then114:                                       ; preds = %do.body112
  br label %do.end116

if.end115:                                        ; preds = %do.body112
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.210)
  br label %do.end116

do.end116:                                        ; preds = %if.end115, %if.then114
  %56 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %cmp117 = icmp eq i32 %56, 2
  br i1 %cmp117, label %if.then118, label %if.end120

if.then118:                                       ; preds = %do.end116
  %call119 = call i32 @redisCommunicateSystemd(ptr noundef @.str.211)
  br label %if.end120

if.end120:                                        ; preds = %if.then118, %do.end116
  br label %error

if.end121:                                        ; preds = %do.end110
  br label %if.end122

if.end122:                                        ; preds = %if.end121, %if.end99
  br label %if.end123

if.end123:                                        ; preds = %if.end122, %lor.lhs.false
  %57 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 217), align 8
  %tobool124 = icmp ne ptr %57, null
  br i1 %tobool124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %if.end123
  %58 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 217), align 8
  call void @aofManifestFree(ptr noundef %58)
  br label %if.end126

if.end126:                                        ; preds = %if.then125, %if.end123
  call void @moduleFireServerEvent(i64 noundef 5, i32 noundef 0, ptr noundef null)
  %59 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 176), align 4
  %tobool127 = icmp ne i32 %59, 0
  br i1 %tobool127, label %if.then130, label %lor.lhs.false128

lor.lhs.false128:                                 ; preds = %if.end126
  %60 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 23), align 8
  %tobool129 = icmp ne ptr %60, null
  br i1 %tobool129, label %if.then130, label %if.end137

if.then130:                                       ; preds = %lor.lhs.false128, %if.end126
  br label %do.body131

do.body131:                                       ; preds = %if.then130
  %61 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp132 = icmp slt i32 2, %61
  br i1 %cmp132, label %if.then133, label %if.end134

if.then133:                                       ; preds = %do.body131
  br label %do.end135

if.end134:                                        ; preds = %do.body131
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.212)
  br label %do.end135

do.end135:                                        ; preds = %if.end134, %if.then133
  %62 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 23), align 8
  %call136 = call i32 @unlink(ptr noundef %62) #13
  br label %if.end137

if.end137:                                        ; preds = %do.end135, %lor.lhs.false128
  call void @flushSlavesOutputBuffers()
  call void @closeListeningSockets(i32 noundef 1)
  %63 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool138 = icmp ne i32 %63, 0
  br i1 %tobool138, label %land.lhs.true139, label %if.end143

land.lhs.true139:                                 ; preds = %if.end137
  %64 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 382), align 8
  %cmp140 = icmp ne i32 %64, -1
  br i1 %cmp140, label %if.then141, label %if.end143

if.then141:                                       ; preds = %land.lhs.true139
  %65 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 382), align 8
  %call142 = call i32 @flock(i32 noundef %65, i32 noundef 12) #13
  br label %if.end143

if.end143:                                        ; preds = %if.then141, %land.lhs.true139, %if.end137
  br label %do.body144

do.body144:                                       ; preds = %if.end143
  %66 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp145 = icmp slt i32 3, %66
  br i1 %cmp145, label %if.then146, label %if.end147

if.then146:                                       ; preds = %do.body144
  br label %do.end150

if.end147:                                        ; preds = %do.body144
  %67 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool148 = icmp ne i32 %67, 0
  %cond149 = select i1 %tobool148, ptr @.str.214, ptr @.str.215
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.213, ptr noundef %cond149)
  br label %do.end150

do.end150:                                        ; preds = %if.end147, %if.then146
  store i32 0, ptr %retval, align 4
  br label %return

error:                                            ; preds = %if.end120, %if.end59
  br label %do.body151

do.body151:                                       ; preds = %error
  %68 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp152 = icmp slt i32 3, %68
  br i1 %cmp152, label %if.then153, label %if.end154

if.then153:                                       ; preds = %do.body151
  br label %do.end155

if.end154:                                        ; preds = %do.body151
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.216)
  br label %do.end155

do.end155:                                        ; preds = %if.end154, %if.then153
  call void @cancelShutdown()
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end155, %do.end150
  %69 = load i32, ptr %retval, align 4
  ret i32 %69
}

declare i64 @dbBuckets(ptr noundef, i32 noundef) #2

declare i32 @aofRewriteLimited() #2

declare i32 @rewriteAppendOnlyFileBackground() #2

declare i32 @ldbPendingChildren() #2

declare ptr @rdbPopulateSaveInfo(ptr noundef) #2

declare i32 @rdbSaveBackground(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #2

declare void @flushAppendOnlyFile(i32 noundef) #2

declare void @updatePausedActions() #2

declare void @replicationCron() #2

declare void @clusterCron() #2

declare void @sentinelTimer() #2

declare void @migrateCloseTimedoutSockets() #2

declare i32 @stopThreadedIOIfNeeded() #2

declare void @trackingLimitUsedSlots() #2

declare i64 @moduleCount() #2

declare void @modulesCron() #2

; Function Attrs: nounwind uwtable
define dso_local void @blockingOperationStarts() #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 355), align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 355), align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @updateCachedTime(i32 noundef 0)
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  store i64 %1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 356), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @blockingOperationEnds() #0 {
entry:
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 355), align 8
  %dec = add i64 %0, -1
  store i64 %dec, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 355), align 8
  %tobool = icmp ne i64 %dec, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 356), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @whileBlockedCron() #0 {
entry:
  %latency = alloca i64, align 8
  %hz_ms = alloca i64, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 356), align 8
  %tobool = icmp ne i64 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.26, ptr noundef @.str.9, i32 noundef 1625)
  call void @abort() #16
  unreachable

1:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %1, %cond.true
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 356), align 8
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  %cmp = icmp sge i64 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  br label %if.end35

if.end:                                           ; preds = %cond.end
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %tobool4 = icmp ne i64 %4, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end
  %call = call i64 @mstime()
  store i64 %call, ptr %latency, align 8
  br label %if.end6

if.else:                                          ; preds = %if.end
  store i64 0, ptr %latency, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then5
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %div = sdiv i32 1000, %5
  %conv7 = sext i32 %div to i64
  store i64 %conv7, ptr %hz_ms, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end6
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 356), align 8
  %7 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  %cmp8 = icmp slt i64 %6, %7
  br i1 %cmp8, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @activeDefragCycle()
  %8 = load i64, ptr %hz_ms, align 8
  %9 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 356), align 8
  %add = add nsw i64 %9, %8
  store i64 %add, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 356), align 8
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  br label %while.cond, !llvm.loop !18

while.end:                                        ; preds = %while.cond
  %11 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool10 = icmp ne i32 %11, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %while.end
  call void @cronUpdateMemoryStats()
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %while.end
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %tobool13 = icmp ne i64 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %call15 = call i64 @mstime()
  %13 = load i64, ptr %latency, align 8
  %sub = sub nsw i64 %call15, %13
  store i64 %sub, ptr %latency, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %tobool17 = icmp ne i64 %14, 0
  br i1 %tobool17, label %land.lhs.true, label %if.end21

land.lhs.true:                                    ; preds = %if.end16
  %15 = load i64, ptr %latency, align 8
  %16 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %cmp18 = icmp sge i64 %15, %16
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true
  %17 = load i64, ptr %latency, align 8
  call void @latencyAddSample(ptr noundef @.str.27, i64 noundef %17)
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %land.lhs.true, %if.end16
  %18 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  %tobool22 = icmp ne i32 %18, 0
  br i1 %tobool22, label %land.lhs.true23, label %if.end35

land.lhs.true23:                                  ; preds = %if.end21
  %19 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool24 = icmp ne i32 %19, 0
  br i1 %tobool24, label %if.then25, label %if.end35

if.then25:                                        ; preds = %land.lhs.true23
  %call26 = call i32 @prepareForShutdown(i32 noundef 2)
  %cmp27 = icmp eq i32 %call26, 0
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.then25
  call void @exit(i32 noundef 0) #16
  unreachable

if.end30:                                         ; preds = %if.then25
  br label %do.body

do.body:                                          ; preds = %if.end30
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp31 = icmp slt i32 3, %20
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %do.body
  br label %do.end

if.end34:                                         ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.28)
  br label %do.end

do.end:                                           ; preds = %if.end34, %if.then33
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 19), align 8
  br label %if.end35

if.end35:                                         ; preds = %do.end, %land.lhs.true23, %if.end21, %if.then
  ret void
}

declare void @latencyAddSample(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @beforeSleep(ptr noundef %eventLoop) #0 {
entry:
  %eventLoop.addr = alloca ptr, align 8
  %zmalloc_used = alloca i64, align 8
  %processed = alloca i64, align 8
  %cron_start_time_before_aof = alloca i64, align 8
  %aof_start_time = alloca i64, align 8
  %duration_before_aof = alloca i64, align 8
  %fsynced_reploff_pending = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %cron_start_time_after_write = alloca i64, align 8
  %duration_after_write = alloca i64, align 8
  %el_duration = alloca i64, align 8
  %el_command_cnt = alloca i64, align 8
  store ptr %eventLoop, ptr %eventLoop.addr, align 8
  %call = call i64 @zmalloc_used_memory()
  store i64 %call, ptr %zmalloc_used, align 8
  %0 = load i64, ptr %zmalloc_used, align 8
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  %cmp = icmp ugt i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %zmalloc_used, align 8
  store i64 %2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr @ProcessingEventsWhileBlocked, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then1, label %if.end19

if.then1:                                         ; preds = %if.end
  store i64 0, ptr %processed, align 8
  %call2 = call i32 @handleClientsWithPendingReadsUsingThreads()
  %conv = sext i32 %call2 to i64
  %4 = load i64, ptr %processed, align 8
  %add = add i64 %4, %conv
  store i64 %add, ptr %processed, align 8
  %call3 = call i32 @connTypeProcessPendingData()
  %conv4 = sext i32 %call3 to i64
  %5 = load i64, ptr %processed, align 8
  %add5 = add i64 %5, %conv4
  store i64 %add5, ptr %processed, align 8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp6 = icmp eq i32 %6, 1
  br i1 %cmp6, label %if.then10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then1
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp8 = icmp eq i32 %7, 2
  br i1 %cmp8, label %if.then10, label %if.end11

if.then10:                                        ; preds = %lor.lhs.false, %if.then1
  call void @flushAppendOnlyFile(i32 noundef 0)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %lor.lhs.false
  %call12 = call i32 @handleClientsWithPendingWrites()
  %conv13 = sext i32 %call12 to i64
  %8 = load i64, ptr %processed, align 8
  %add14 = add i64 %8, %conv13
  store i64 %add14, ptr %processed, align 8
  %call15 = call i32 @freeClientsInAsyncFreeQueue()
  %conv16 = sext i32 %call15 to i64
  %9 = load i64, ptr %processed, align 8
  %add17 = add i64 %9, %conv16
  store i64 %add17, ptr %processed, align 8
  %10 = load i64, ptr %processed, align 8
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 77), align 8
  %add18 = add i64 %11, %10
  store i64 %add18, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 77), align 8
  br label %if.end104

if.end19:                                         ; preds = %if.end
  %call20 = call i32 @handleClientsWithPendingReadsUsingThreads()
  %call21 = call i32 @connTypeProcessPendingData()
  %12 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %call22 = call i32 @connTypeHasPendingData()
  call void @aeSetDontWait(ptr noundef %12, i32 noundef %call22)
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool23 = icmp ne i32 %13, 0
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end19
  call void @clusterBeforeSleep()
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.end19
  call void @blockedBeforeSleep()
  %14 = load ptr, ptr @getMonotonicUs, align 8
  %call26 = call i64 %14()
  store i64 %call26, ptr %cron_start_time_before_aof, align 8
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 159), align 4
  %tobool27 = icmp ne i32 %15, 0
  br i1 %tobool27, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %if.end25
  %call28 = call i32 @iAmMaster()
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %land.lhs.true
  call void @activeExpireCycle(i32 noundef 1)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %land.lhs.true, %if.end25
  %call32 = call i64 @moduleCount()
  %tobool33 = icmp ne i64 %call32, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  call void @moduleFireServerEvent(i64 noundef 15, i32 noundef 0, ptr noundef null)
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.end31
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 312), align 8
  %tobool36 = icmp ne i32 %16, 0
  br i1 %tobool36, label %land.lhs.true37, label %if.end41

land.lhs.true37:                                  ; preds = %if.end35
  %call38 = call i32 @isPausedActionsWithUpdate(i32 noundef 16)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %land.lhs.true37
  call void @sendGetackToReplicas()
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 312), align 8
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %land.lhs.true37, %if.end35
  call void @updateFailoverStatus()
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 331), align 8
  %len = getelementptr inbounds %struct.list, ptr %17, i32 0, i32 5
  %18 = load i64, ptr %len, align 8
  %cmp42 = icmp eq i64 %18, 0
  %lnot = xor i1 %cmp42, true
  %lnot44 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot44 to i32
  %conv45 = sext i32 %lnot.ext to i64
  %tobool46 = icmp ne i64 %conv45, 0
  br i1 %tobool46, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end41
  br label %cond.end

cond.false:                                       ; preds = %if.end41
  call void @_serverAssert(ptr noundef @.str.29, ptr noundef @.str.9, i32 noundef 1778)
  call void @abort() #16
  unreachable

19:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %19, %cond.true
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 332), align 8
  %len47 = getelementptr inbounds %struct.list, ptr %20, i32 0, i32 5
  %21 = load i64, ptr %len47, align 8
  %cmp48 = icmp eq i64 %21, 0
  %lnot50 = xor i1 %cmp48, true
  %lnot52 = xor i1 %lnot50, true
  %lnot.ext53 = zext i1 %lnot52 to i32
  %conv54 = sext i32 %lnot.ext53 to i64
  %tobool55 = icmp ne i64 %conv54, 0
  br i1 %tobool55, label %cond.true56, label %cond.false57

cond.true56:                                      ; preds = %cond.end
  br label %cond.end58

cond.false57:                                     ; preds = %cond.end
  call void @_serverAssert(ptr noundef @.str.30, ptr noundef @.str.9, i32 noundef 1779)
  call void @abort() #16
  unreachable

22:                                               ; No predecessors!
  br label %cond.end58

cond.end58:                                       ; preds = %22, %cond.true56
  call void @trackingBroadcastInvalidationMessages()
  %23 = load ptr, ptr @getMonotonicUs, align 8
  %call59 = call i64 %23()
  store i64 %call59, ptr %aof_start_time, align 8
  %24 = load i64, ptr %aof_start_time, align 8
  %25 = load i64, ptr %cron_start_time_before_aof, align 8
  %sub = sub i64 %24, %25
  store i64 %sub, ptr %duration_before_aof, align 8
  %26 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp60 = icmp eq i32 %26, 1
  br i1 %cmp60, label %if.then65, label %lor.lhs.false62

lor.lhs.false62:                                  ; preds = %cond.end58
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp63 = icmp eq i32 %27, 2
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %lor.lhs.false62, %cond.end58
  call void @flushAppendOnlyFile(i32 noundef 0)
  br label %if.end66

if.end66:                                         ; preds = %if.then65, %lor.lhs.false62
  %28 = load ptr, ptr @getMonotonicUs, align 8
  %call67 = call i64 %28()
  %29 = load i64, ptr %aof_start_time, align 8
  %sub68 = sub i64 %call67, %29
  call void @durationAddSample(i32 noundef 2, i64 noundef %sub68)
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp69 = icmp eq i32 %30, 1
  br i1 %cmp69, label %land.lhs.true71, label %if.end75

land.lhs.true71:                                  ; preds = %if.end66
  %31 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 265), align 8
  %cmp72 = icmp ne i64 %31, -1
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %land.lhs.true71
  br label %do.body

do.body:                                          ; preds = %if.then74
  %32 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 264) monotonic, align 8
  store i64 %32, ptr %atomic-temp, align 8
  %33 = load i64, ptr %atomic-temp, align 8
  store i64 %33, ptr %fsynced_reploff_pending, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %34 = load i64, ptr %fsynced_reploff_pending, align 8
  store i64 %34, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 265), align 8
  br label %if.end75

if.end75:                                         ; preds = %do.end, %land.lhs.true71, %if.end66
  %call76 = call i32 @handleClientsWithPendingWritesUsingThreads()
  %35 = load ptr, ptr @getMonotonicUs, align 8
  %call77 = call i64 %35()
  store i64 %call77, ptr %cron_start_time_after_write, align 8
  %call78 = call i32 @freeClientsInAsyncFreeQueue()
  %36 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %tobool79 = icmp ne ptr %36, null
  br i1 %tobool79, label %if.then80, label %if.end81

if.then80:                                        ; preds = %if.end75
  call void @incrementalTrimReplicationBacklog(i64 noundef 640)
  br label %if.end81

if.end81:                                         ; preds = %if.then80, %if.end75
  call void @evictClients()
  %37 = load ptr, ptr @getMonotonicUs, align 8
  %call82 = call i64 %37()
  %38 = load i64, ptr %cron_start_time_after_write, align 8
  %sub83 = sub i64 %call82, %38
  store i64 %sub83, ptr %duration_after_write, align 8
  %39 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 151), align 8
  %cmp84 = icmp ugt i64 %39, 0
  br i1 %cmp84, label %if.then86, label %if.end89

if.then86:                                        ; preds = %if.end81
  %40 = load ptr, ptr @getMonotonicUs, align 8
  %call87 = call i64 %40()
  %41 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 151), align 8
  %sub88 = sub i64 %call87, %41
  store i64 %sub88, ptr %el_duration, align 8
  %42 = load i64, ptr %el_duration, align 8
  call void @durationAddSample(i32 noundef 0, i64 noundef %42)
  br label %if.end89

if.end89:                                         ; preds = %if.then86, %if.end81
  %43 = load i64, ptr %duration_before_aof, align 8
  %44 = load i64, ptr %duration_after_write, align 8
  %add90 = add i64 %43, %44
  %45 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 154), align 8
  %add91 = add i64 %45, %add90
  store i64 %add91, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 154), align 8
  %46 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 154), align 8
  call void @durationAddSample(i32 noundef 3, i64 noundef %46)
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 154), align 8
  %47 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 89), align 8
  %48 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 152), align 8
  %cmp92 = icmp sgt i64 %47, %48
  br i1 %cmp92, label %if.then94, label %if.end100

if.then94:                                        ; preds = %if.end89
  %49 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 89), align 8
  %50 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 152), align 8
  %sub95 = sub nsw i64 %49, %50
  store i64 %sub95, ptr %el_command_cnt, align 8
  %51 = load i64, ptr %el_command_cnt, align 8
  %52 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 153), align 8
  %cmp96 = icmp sgt i64 %51, %52
  br i1 %cmp96, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.then94
  %53 = load i64, ptr %el_command_cnt, align 8
  store i64 %53, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 153), align 8
  br label %if.end99

if.end99:                                         ; preds = %if.then98, %if.then94
  br label %if.end100

if.end100:                                        ; preds = %if.end99, %if.end89
  %call101 = call i64 @moduleCount()
  %tobool102 = icmp ne i64 %call101, 0
  br i1 %tobool102, label %if.then103, label %if.end104

if.then103:                                       ; preds = %if.end100
  call void @moduleReleaseGIL()
  br label %if.end104

if.end104:                                        ; preds = %if.then103, %if.end100, %if.end11
  ret void
}

declare i32 @handleClientsWithPendingReadsUsingThreads() #2

declare i32 @connTypeProcessPendingData() #2

declare i32 @handleClientsWithPendingWrites() #2

declare i32 @freeClientsInAsyncFreeQueue() #2

declare void @aeSetDontWait(ptr noundef, i32 noundef) #2

declare i32 @connTypeHasPendingData() #2

declare void @clusterBeforeSleep() #2

declare void @blockedBeforeSleep() #2

declare i32 @isPausedActionsWithUpdate(i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal void @sendGetackToReplicas() #0 {
entry:
  %argv = alloca [3 x ptr], align 16
  %0 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 58), align 8
  %arrayidx = getelementptr inbounds [3 x ptr], ptr %argv, i64 0, i64 0
  store ptr %0, ptr %arrayidx, align 16
  %1 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 77), align 8
  %arrayidx1 = getelementptr inbounds [3 x ptr], ptr %argv, i64 0, i64 1
  store ptr %1, ptr %arrayidx1, align 8
  %2 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 78), align 8
  %arrayidx2 = getelementptr inbounds [3 x ptr], ptr %argv, i64 0, i64 2
  store ptr %2, ptr %arrayidx2, align 16
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %argv, i64 0, i64 0
  call void @replicationFeedSlaves(ptr noundef %3, i32 noundef -1, ptr noundef %arraydecay, i32 noundef 3)
  ret void
}

declare void @updateFailoverStatus() #2

declare void @trackingBroadcastInvalidationMessages() #2

declare void @durationAddSample(i32 noundef, i64 noundef) #2

declare i32 @handleClientsWithPendingWritesUsingThreads() #2

declare void @incrementalTrimReplicationBacklog(i64 noundef) #2

declare void @evictClients() #2

declare void @moduleReleaseGIL() #2

; Function Attrs: nounwind uwtable
define dso_local void @afterSleep(ptr noundef %eventLoop) #0 {
entry:
  %eventLoop.addr = alloca ptr, align 8
  %latency = alloca i64, align 8
  store ptr %eventLoop, ptr %eventLoop.addr, align 8
  %0 = load i32, ptr @ProcessingEventsWhileBlocked, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end15, label %if.then

if.then:                                          ; preds = %entry
  %call = call i64 @moduleCount()
  %tobool1 = icmp ne i64 %call, 0
  br i1 %tobool1, label %if.then2, label %if.end13

if.then2:                                         ; preds = %if.then
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %tobool3 = icmp ne i64 %1, 0
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then2
  %call5 = call i64 @mstime()
  store i64 %call5, ptr %latency, align 8
  br label %if.end

if.else:                                          ; preds = %if.then2
  store i64 0, ptr %latency, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then4
  call void @moduleAcquireGIL()
  call void @moduleFireServerEvent(i64 noundef 15, i32 noundef 1, ptr noundef null)
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %tobool6 = icmp ne i64 %2, 0
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %call8 = call i64 @mstime()
  %3 = load i64, ptr %latency, align 8
  %sub = sub nsw i64 %call8, %3
  store i64 %sub, ptr %latency, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %tobool10 = icmp ne i64 %4, 0
  br i1 %tobool10, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end9
  %5 = load i64, ptr %latency, align 8
  %6 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %cmp = icmp sge i64 %5, %6
  br i1 %cmp, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true
  %7 = load i64, ptr %latency, align 8
  call void @latencyAddSample(ptr noundef @.str.31, i64 noundef %7)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %land.lhs.true, %if.end9
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.then
  %8 = load ptr, ptr @getMonotonicUs, align 8
  %call14 = call i64 %8()
  store i64 %call14, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 151), align 8
  %9 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 89), align 8
  store i64 %9, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 152), align 8
  br label %if.end15

if.end15:                                         ; preds = %if.end13, %entry
  call void @updateCachedTime(i32 noundef 1)
  %10 = load i32, ptr @ProcessingEventsWhileBlocked, align 4
  %tobool16 = icmp ne i32 %10, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  store i64 %11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 354), align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  ret void
}

declare void @moduleAcquireGIL() #2

; Function Attrs: nounwind uwtable
define dso_local void @createSharedObjects() #0 {
entry:
  %j = alloca i32, align 4
  %dictid_str = alloca [64 x i8], align 16
  %dictid_len = alloca i32, align 4
  %call = call ptr @sdsnew(ptr noundef @.str.32)
  %call1 = call ptr @createObject(i32 noundef 0, ptr noundef %call)
  store ptr %call1, ptr @shared, align 8
  %call2 = call ptr @sdsnew(ptr noundef @.str.33)
  %call3 = call ptr @createObject(i32 noundef 0, ptr noundef %call2)
  store ptr %call3, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 2), align 8
  %call4 = call ptr @sdsnew(ptr noundef @.str.34)
  %call5 = call ptr @createObject(i32 noundef 0, ptr noundef %call4)
  store ptr %call5, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 3), align 8
  %call6 = call ptr @sdsnew(ptr noundef @.str.35)
  %call7 = call ptr @createObject(i32 noundef 0, ptr noundef %call6)
  store ptr %call7, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 4), align 8
  %call8 = call ptr @sdsnew(ptr noundef @.str.36)
  %call9 = call ptr @createObject(i32 noundef 0, ptr noundef %call8)
  store ptr %call9, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 12), align 8
  %call10 = call ptr @sdsnew(ptr noundef @.str.37)
  %call11 = call ptr @createObject(i32 noundef 0, ptr noundef %call10)
  store ptr %call11, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 5), align 8
  %call12 = call ptr @sdsnew(ptr noundef @.str.38)
  %call13 = call ptr @createObject(i32 noundef 0, ptr noundef %call12)
  store ptr %call13, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 7), align 8
  %call14 = call ptr @sdsnew(ptr noundef @.str.39)
  %call15 = call ptr @createObject(i32 noundef 0, ptr noundef %call14)
  store ptr %call15, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 48), align 8
  %call16 = call ptr @sdsnew(ptr noundef @.str.40)
  %call17 = call ptr @createObject(i32 noundef 0, ptr noundef %call16)
  store ptr %call17, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 6), align 8
  %call18 = call ptr @sdsnew(ptr noundef @.str.41)
  %call19 = call ptr @createObject(i32 noundef 0, ptr noundef %call18)
  store ptr %call19, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 31), align 8
  %call20 = call ptr @sdsnew(ptr noundef @.str.42)
  %call21 = call ptr @createObject(i32 noundef 0, ptr noundef %call20)
  store ptr %call21, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 13), align 8
  %call22 = call ptr @sdsnew(ptr noundef @.str.43)
  %call23 = call ptr @createObject(i32 noundef 0, ptr noundef %call22)
  store ptr %call23, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 1), align 8
  %call24 = call ptr @sdsnew(ptr noundef @.str.44)
  %call25 = call ptr @createObject(i32 noundef 0, ptr noundef %call24)
  store ptr %call25, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 14), align 8
  %call26 = call ptr @sdsnew(ptr noundef @.str.45)
  %call27 = call ptr @createObject(i32 noundef 0, ptr noundef %call26)
  store ptr %call27, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 15), align 8
  %call28 = call ptr @sdsnew(ptr noundef @.str.46)
  %call29 = call ptr @createObject(i32 noundef 0, ptr noundef %call28)
  store ptr %call29, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 16), align 8
  %call30 = call ptr @sdsnew(ptr noundef @.str.47)
  %call31 = call ptr @createObject(i32 noundef 0, ptr noundef %call30)
  store ptr %call31, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 17), align 8
  %call32 = call ptr @sdsnew(ptr noundef @.str.48)
  %call33 = call ptr @createObject(i32 noundef 0, ptr noundef %call32)
  store ptr %call33, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 18), align 8
  %call34 = call ptr @sdsnew(ptr noundef @.str.49)
  %call35 = call ptr @createObject(i32 noundef 0, ptr noundef %call34)
  store ptr %call35, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 19), align 8
  %call36 = call ptr @sdsnew(ptr noundef @.str.50)
  %call37 = call ptr @createObject(i32 noundef 0, ptr noundef %call36)
  store ptr %call37, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 20), align 8
  %call38 = call ptr @sdsnew(ptr noundef @.str.51)
  %call39 = call ptr @createObject(i32 noundef 0, ptr noundef %call38)
  store ptr %call39, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 21), align 8
  %call40 = call ptr @sdsnew(ptr noundef @.str.52)
  %call41 = call ptr @createObject(i32 noundef 0, ptr noundef %call40)
  store ptr %call41, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 22), align 8
  %call42 = call ptr @sdsnew(ptr noundef @.str.53)
  %call43 = call ptr @createObject(i32 noundef 0, ptr noundef %call42)
  store ptr %call43, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 24), align 8
  %call44 = call ptr @sdsnew(ptr noundef @.str.54)
  %call45 = call ptr @createObject(i32 noundef 0, ptr noundef %call44)
  store ptr %call45, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 23), align 8
  %call46 = call ptr @sdsnew(ptr noundef @.str.55)
  %call47 = call ptr @createObject(i32 noundef 0, ptr noundef %call46)
  store ptr %call47, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 25), align 8
  %call48 = call ptr @sdsnew(ptr noundef @.str.56)
  %call49 = call ptr @createObject(i32 noundef 0, ptr noundef %call48)
  store ptr %call49, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 27), align 8
  %call50 = call ptr @sdsnew(ptr noundef @.str.57)
  %call51 = call ptr @createObject(i32 noundef 0, ptr noundef %call50)
  store ptr %call51, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 30), align 8
  %call52 = call ptr @sdsnew(ptr noundef @.str.58)
  %call53 = call ptr @createObject(i32 noundef 0, ptr noundef %call52)
  store ptr %call53, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 26), align 8
  %call54 = call ptr @sdsnew(ptr noundef @.str.59)
  %call55 = call ptr @createObject(i32 noundef 0, ptr noundef %call54)
  store ptr %call55, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 28), align 8
  %call56 = call ptr @sdsnew(ptr noundef @.str.60)
  %call57 = call ptr @createObject(i32 noundef 0, ptr noundef %call56)
  store ptr %call57, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 29), align 8
  store ptr null, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 8), align 8
  store ptr null, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 8, i64 1), align 8
  %call58 = call ptr @sdsnew(ptr noundef @.str.61)
  %call59 = call ptr @createObject(i32 noundef 0, ptr noundef %call58)
  store ptr %call59, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 8, i64 2), align 8
  %call60 = call ptr @sdsnew(ptr noundef @.str.62)
  %call61 = call ptr @createObject(i32 noundef 0, ptr noundef %call60)
  store ptr %call61, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 8, i64 3), align 8
  store ptr null, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 9), align 8
  store ptr null, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 9, i64 1), align 8
  %call62 = call ptr @sdsnew(ptr noundef @.str.63)
  %call63 = call ptr @createObject(i32 noundef 0, ptr noundef %call62)
  store ptr %call63, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 9, i64 2), align 8
  %call64 = call ptr @sdsnew(ptr noundef @.str.62)
  %call65 = call ptr @createObject(i32 noundef 0, ptr noundef %call64)
  store ptr %call65, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 9, i64 3), align 8
  store ptr null, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 10), align 8
  store ptr null, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 10, i64 1), align 8
  %call66 = call ptr @sdsnew(ptr noundef @.str.36)
  %call67 = call ptr @createObject(i32 noundef 0, ptr noundef %call66)
  store ptr %call67, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 10, i64 2), align 8
  %call68 = call ptr @sdsnew(ptr noundef @.str.64)
  %call69 = call ptr @createObject(i32 noundef 0, ptr noundef %call68)
  store ptr %call69, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 10, i64 3), align 8
  store ptr null, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 11), align 8
  store ptr null, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 11, i64 1), align 8
  %call70 = call ptr @sdsnew(ptr noundef @.str.36)
  %call71 = call ptr @createObject(i32 noundef 0, ptr noundef %call70)
  store ptr %call71, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 11, i64 2), align 8
  %call72 = call ptr @sdsnew(ptr noundef @.str.65)
  %call73 = call ptr @createObject(i32 noundef 0, ptr noundef %call72)
  store ptr %call73, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 11, i64 3), align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %0, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [64 x i8], ptr %dictid_str, i64 0, i64 0
  %1 = load i32, ptr %j, align 4
  %conv = sext i32 %1 to i64
  %call74 = call i32 @ll2string(ptr noundef %arraydecay, i64 noundef 64, i64 noundef %conv)
  store i32 %call74, ptr %dictid_len, align 4
  %call75 = call ptr @sdsempty()
  %2 = load i32, ptr %dictid_len, align 4
  %arraydecay76 = getelementptr inbounds [64 x i8], ptr %dictid_str, i64 0, i64 0
  %call77 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call75, ptr noundef @.str.66, i32 noundef %2, ptr noundef %arraydecay76)
  %call78 = call ptr @createObject(i32 noundef 0, ptr noundef %call77)
  %3 = load i32, ptr %j, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [10 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 85), i64 0, i64 %idxprom
  store ptr %call78, ptr %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, ptr %j, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %for.cond
  %call79 = call ptr @createStringObject(ptr noundef @.str.67, i64 noundef 13)
  store ptr %call79, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 32), align 8
  %call80 = call ptr @createStringObject(ptr noundef @.str.68, i64 noundef 14)
  store ptr %call80, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 33), align 8
  %call81 = call ptr @createStringObject(ptr noundef @.str.69, i64 noundef 15)
  store ptr %call81, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 34), align 8
  %call82 = call ptr @createStringObject(ptr noundef @.str.70, i64 noundef 18)
  store ptr %call82, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 35), align 8
  %call83 = call ptr @createStringObject(ptr noundef @.str.71, i64 noundef 17)
  store ptr %call83, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 82), align 8
  %call84 = call ptr @createStringObject(ptr noundef @.str.72, i64 noundef 19)
  store ptr %call84, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 83), align 8
  %call85 = call ptr @createStringObject(ptr noundef @.str.73, i64 noundef 14)
  store ptr %call85, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 84), align 8
  %call86 = call ptr @createStringObject(ptr noundef @.str.74, i64 noundef 17)
  store ptr %call86, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 36), align 8
  %call87 = call ptr @createStringObject(ptr noundef @.str.75, i64 noundef 19)
  store ptr %call87, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 37), align 8
  %call88 = call ptr @createStringObject(ptr noundef @.str.76, i64 noundef 3)
  store ptr %call88, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 38), align 8
  %call89 = call ptr @createStringObject(ptr noundef @.str.77, i64 noundef 6)
  store ptr %call89, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 39), align 8
  %call90 = call ptr @createStringObject(ptr noundef @.str.78, i64 noundef 4)
  store ptr %call90, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 40), align 8
  %call91 = call ptr @createStringObject(ptr noundef @.str.79, i64 noundef 4)
  store ptr %call91, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 41), align 8
  %call92 = call ptr @createStringObject(ptr noundef @.str.80, i64 noundef 5)
  store ptr %call92, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 42), align 8
  %call93 = call ptr @createStringObject(ptr noundef @.str.81, i64 noundef 9)
  store ptr %call93, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 43), align 8
  %call94 = call ptr @createStringObject(ptr noundef @.str.82, i64 noundef 5)
  store ptr %call94, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 44), align 8
  %call95 = call ptr @createStringObject(ptr noundef @.str.83, i64 noundef 6)
  store ptr %call95, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 45), align 8
  %call96 = call ptr @createStringObject(ptr noundef @.str.84, i64 noundef 7)
  store ptr %call96, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 46), align 8
  %call97 = call ptr @createStringObject(ptr noundef @.str.85, i64 noundef 7)
  store ptr %call97, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 47), align 8
  %call98 = call ptr @createStringObject(ptr noundef @.str.86, i64 noundef 5)
  store ptr %call98, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 49), align 8
  %call99 = call ptr @createStringObject(ptr noundef @.str.87, i64 noundef 4)
  store ptr %call99, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 50), align 8
  %call100 = call ptr @createStringObject(ptr noundef @.str.88, i64 noundef 4)
  store ptr %call100, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 53), align 8
  %call101 = call ptr @createStringObject(ptr noundef @.str.89, i64 noundef 4)
  store ptr %call101, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 54), align 8
  %call102 = call ptr @createStringObject(ptr noundef @.str.90, i64 noundef 6)
  store ptr %call102, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 55), align 8
  %call103 = call ptr @createStringObject(ptr noundef @.str.91, i64 noundef 6)
  store ptr %call103, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 56), align 8
  %call104 = call ptr @createStringObject(ptr noundef @.str.92, i64 noundef 6)
  store ptr %call104, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 57), align 8
  %call105 = call ptr @createStringObject(ptr noundef @.str.93, i64 noundef 8)
  store ptr %call105, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 58), align 8
  %call106 = call ptr @createStringObject(ptr noundef @.str.94, i64 noundef 9)
  store ptr %call106, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 62), align 8
  %call107 = call ptr @createStringObject(ptr noundef @.str.95, i64 noundef 7)
  store ptr %call107, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 63), align 8
  %call108 = call ptr @createStringObject(ptr noundef @.str.96, i64 noundef 7)
  store ptr %call108, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 60), align 8
  %call109 = call ptr @createStringObject(ptr noundef @.str.97, i64 noundef 3)
  store ptr %call109, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 61), align 8
  %call110 = call ptr @createStringObject(ptr noundef @.str.98, i64 noundef 4)
  store ptr %call110, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 59), align 8
  %call111 = call ptr @createStringObject(ptr noundef @.str.99, i64 noundef 4)
  store ptr %call111, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 51), align 8
  %call112 = call ptr @createStringObject(ptr noundef @.str.100, i64 noundef 5)
  store ptr %call112, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 52), align 8
  %call113 = call ptr @createStringObject(ptr noundef @.str.101, i64 noundef 4)
  store ptr %call113, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 65), align 8
  %call114 = call ptr @createStringObject(ptr noundef @.str.102, i64 noundef 4)
  store ptr %call114, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 64), align 8
  %call115 = call ptr @createStringObject(ptr noundef @.str.103, i64 noundef 10)
  store ptr %call115, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 67), align 8
  %call116 = call ptr @createStringObject(ptr noundef @.str.104, i64 noundef 5)
  store ptr %call116, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 68), align 8
  %call117 = call ptr @createStringObject(ptr noundef @.str.105, i64 noundef 6)
  store ptr %call117, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 69), align 8
  %call118 = call ptr @createStringObject(ptr noundef @.str.106, i64 noundef 11)
  store ptr %call118, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 70), align 8
  %call119 = call ptr @createStringObject(ptr noundef @.str.107, i64 noundef 6)
  store ptr %call119, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 71), align 8
  %call120 = call ptr @createStringObject(ptr noundef @.str.108, i64 noundef 7)
  store ptr %call120, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 80), align 8
  %call121 = call ptr @createStringObject(ptr noundef @.str.109, i64 noundef 4)
  store ptr %call121, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 72), align 8
  %call122 = call ptr @createStringObject(ptr noundef @.str.110, i64 noundef 5)
  store ptr %call122, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 73), align 8
  %call123 = call ptr @createStringObject(ptr noundef @.str.111, i64 noundef 7)
  store ptr %call123, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 74), align 8
  %call124 = call ptr @createStringObject(ptr noundef @.str.112, i64 noundef 6)
  store ptr %call124, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 66), align 8
  %call125 = call ptr @createStringObject(ptr noundef @.str.113, i64 noundef 4)
  store ptr %call125, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 75), align 8
  %call126 = call ptr @createStringObject(ptr noundef @.str.114, i64 noundef 14)
  store ptr %call126, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 76), align 8
  %call127 = call ptr @createStringObject(ptr noundef @.str.115, i64 noundef 6)
  store ptr %call127, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 77), align 8
  %call128 = call ptr @createStringObject(ptr noundef @.str.116, i64 noundef 1)
  store ptr %call128, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 78), align 8
  %call129 = call ptr @createStringObject(ptr noundef @.str.117, i64 noundef 1)
  store ptr %call129, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 79), align 8
  %call130 = call ptr @createStringObject(ptr noundef @.str.118, i64 noundef 10)
  %call131 = call ptr @makeObjectShared(ptr noundef %call130)
  store ptr %call131, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 81), align 8
  store i32 0, ptr %j, align 4
  br label %for.cond132

for.cond132:                                      ; preds = %for.inc145, %for.end
  %5 = load i32, ptr %j, align 4
  %cmp133 = icmp slt i32 %5, 10000
  br i1 %cmp133, label %for.body135, label %for.end147

for.body135:                                      ; preds = %for.cond132
  %6 = load i32, ptr %j, align 4
  %conv136 = sext i32 %6 to i64
  %7 = inttoptr i64 %conv136 to ptr
  %call137 = call ptr @createObject(i32 noundef 0, ptr noundef %7)
  %call138 = call ptr @makeObjectShared(ptr noundef %call137)
  %8 = load i32, ptr %j, align 4
  %idxprom139 = sext i32 %8 to i64
  %arrayidx140 = getelementptr inbounds [10000 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 86), i64 0, i64 %idxprom139
  store ptr %call138, ptr %arrayidx140, align 8
  %9 = load i32, ptr %j, align 4
  %idxprom141 = sext i32 %9 to i64
  %arrayidx142 = getelementptr inbounds [10000 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 86), i64 0, i64 %idxprom141
  %10 = load ptr, ptr %arrayidx142, align 8
  call void @initObjectLRUOrLFU(ptr noundef %10)
  %11 = load i32, ptr %j, align 4
  %idxprom143 = sext i32 %11 to i64
  %arrayidx144 = getelementptr inbounds [10000 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 86), i64 0, i64 %idxprom143
  %12 = load ptr, ptr %arrayidx144, align 8
  %bf.load = load i32, ptr %12, align 8
  %bf.clear = and i32 %bf.load, -241
  %bf.set = or i32 %bf.clear, 16
  store i32 %bf.set, ptr %12, align 8
  br label %for.inc145

for.inc145:                                       ; preds = %for.body135
  %13 = load i32, ptr %j, align 4
  %inc146 = add nsw i32 %13, 1
  store i32 %inc146, ptr %j, align 4
  br label %for.cond132, !llvm.loop !20

for.end147:                                       ; preds = %for.cond132
  store i32 0, ptr %j, align 4
  br label %for.cond148

for.cond148:                                      ; preds = %for.inc172, %for.end147
  %14 = load i32, ptr %j, align 4
  %cmp149 = icmp slt i32 %14, 32
  br i1 %cmp149, label %for.body151, label %for.end174

for.body151:                                      ; preds = %for.cond148
  %call152 = call ptr @sdsempty()
  %15 = load i32, ptr %j, align 4
  %call153 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call152, ptr noundef @.str.119, i32 noundef %15)
  %call154 = call ptr @createObject(i32 noundef 0, ptr noundef %call153)
  %16 = load i32, ptr %j, align 4
  %idxprom155 = sext i32 %16 to i64
  %arrayidx156 = getelementptr inbounds [32 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 87), i64 0, i64 %idxprom155
  store ptr %call154, ptr %arrayidx156, align 8
  %call157 = call ptr @sdsempty()
  %17 = load i32, ptr %j, align 4
  %call158 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call157, ptr noundef @.str.120, i32 noundef %17)
  %call159 = call ptr @createObject(i32 noundef 0, ptr noundef %call158)
  %18 = load i32, ptr %j, align 4
  %idxprom160 = sext i32 %18 to i64
  %arrayidx161 = getelementptr inbounds [32 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 88), i64 0, i64 %idxprom160
  store ptr %call159, ptr %arrayidx161, align 8
  %call162 = call ptr @sdsempty()
  %19 = load i32, ptr %j, align 4
  %call163 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call162, ptr noundef @.str.121, i32 noundef %19)
  %call164 = call ptr @createObject(i32 noundef 0, ptr noundef %call163)
  %20 = load i32, ptr %j, align 4
  %idxprom165 = sext i32 %20 to i64
  %arrayidx166 = getelementptr inbounds [32 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 89), i64 0, i64 %idxprom165
  store ptr %call164, ptr %arrayidx166, align 8
  %call167 = call ptr @sdsempty()
  %21 = load i32, ptr %j, align 4
  %call168 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call167, ptr noundef @.str.122, i32 noundef %21)
  %call169 = call ptr @createObject(i32 noundef 0, ptr noundef %call168)
  %22 = load i32, ptr %j, align 4
  %idxprom170 = sext i32 %22 to i64
  %arrayidx171 = getelementptr inbounds [32 x ptr], ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 90), i64 0, i64 %idxprom170
  store ptr %call169, ptr %arrayidx171, align 8
  br label %for.inc172

for.inc172:                                       ; preds = %for.body151
  %23 = load i32, ptr %j, align 4
  %inc173 = add nsw i32 %23, 1
  store i32 %inc173, ptr %j, align 4
  br label %for.cond148, !llvm.loop !21

for.end174:                                       ; preds = %for.cond148
  %call175 = call ptr @sdsnew(ptr noundef @.str.123)
  store ptr %call175, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 91), align 8
  %call176 = call ptr @sdsnew(ptr noundef @.str.124)
  store ptr %call176, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 92), align 8
  ret void
}

declare ptr @createObject(i32 noundef, ptr noundef) #2

declare ptr @sdsnew(ptr noundef) #2

declare ptr @sdscatprintf(ptr noundef, ptr noundef, ...) #2

declare ptr @sdsempty() #2

declare ptr @createStringObject(ptr noundef, i64 noundef) #2

declare ptr @makeObjectShared(ptr noundef) #2

declare void @initObjectLRUOrLFU(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @initServerClientMemUsageBuckets() #0 {
entry:
  %j = alloca i32, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  %call = call noalias ptr @zmalloc(i64 noundef 304) #18
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %1, 19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  %3 = load i32, ptr %j, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.clientMemUsageBucket, ptr %2, i64 %idxprom
  %mem_usage_sum = getelementptr inbounds %struct.clientMemUsageBucket, ptr %arrayidx, i32 0, i32 1
  store i64 0, ptr %mem_usage_sum, align 8
  %call1 = call ptr @listCreate()
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  %5 = load i32, ptr %j, align 4
  %idxprom2 = sext i32 %5 to i64
  %arrayidx3 = getelementptr inbounds %struct.clientMemUsageBucket, ptr %4, i64 %idxprom2
  %clients = getelementptr inbounds %struct.clientMemUsageBucket, ptr %arrayidx3, i32 0, i32 0
  store ptr %call1, ptr %clients, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, ptr %j, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %for.cond, %if.then
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @zmalloc(i64 noundef) #9

declare ptr @listCreate() #2

; Function Attrs: nounwind uwtable
define dso_local void @freeServerClientMemUsageBuckets() #0 {
entry:
  %j = alloca i32, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %1, 19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  %3 = load i32, ptr %j, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.clientMemUsageBucket, ptr %2, i64 %idxprom
  %clients = getelementptr inbounds %struct.clientMemUsageBucket, ptr %arrayidx, i32 0, i32 0
  %4 = load ptr, ptr %clients, align 8
  call void @listRelease(ptr noundef %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %j, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  call void @zfree(ptr noundef %6)
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @initServerConfig() #0 {
entry:
  %j = alloca i32, align 4
  %default_bindaddr = alloca [2 x ptr], align 16
  %.atomictmp = alloca i32, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %default_bindaddr, ptr align 16 @__const.initServerConfig.default_bindaddr, i64 16, i1 false)
  call void @initConfigValues()
  call void @updateCachedTime(i32 noundef 1)
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  store i64 %0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 354), align 8
  call void @getRandomHexChars(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 26), i64 noundef 40)
  store i8 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 26, i64 40), align 8
  call void @changeReplicationId()
  call void @clearReplicationId2()
  store i32 10, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %call = call i64 @getTimeZone()
  store i64 %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 350), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 3), align 8
  store i32 64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 24), align 8
  store i32 2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 48), align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %1, 2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, ptr %j, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x ptr], ptr %default_bindaddr, i64 0, i64 %idxprom
  %3 = load ptr, ptr %arrayidx, align 8
  %call1 = call noalias ptr @zstrdup(ptr noundef %3)
  %4 = load i32, ptr %j, align 4
  %idxprom2 = sext i32 %4 to i64
  %arrayidx3 = getelementptr inbounds [16 x ptr], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 47), i64 0, i64 %idxprom2
  store ptr %call1, ptr %arrayidx3, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %j, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %for.cond
  call void @llvm.memset.p0.i64(ptr align 8 getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 52), i8 0, i64 832, i1 false)
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 159), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 161), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 164), align 8
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 82), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 84), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 192), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 197), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 196), align 8
  %call4 = call i64 @time(ptr noundef null) #13
  store i64 %call4, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 202), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 205), align 8
  store i32 0, ptr %.atomictmp, align 4
  %6 = load i32, ptr %.atomictmp, align 4
  store atomic i32 %6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 215) monotonic, align 8
  store i64 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 203), align 8
  store i64 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 204), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 207), align 4
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 208), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 199), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 200), align 4
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 201), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 194), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 195), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 22), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 359), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 325), align 4
  call void @llvm.memset.p0.i64(ptr align 8 getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 326), i8 0, i64 36, i1 false)
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 20), align 4
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 18), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 380), align 8
  %call5 = call ptr @dictCreate(ptr noundef @migrateCacheDictType)
  store ptr %call5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 71), align 8
  store atomic i64 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 72) seq_cst, align 8
  %call6 = call i64 @sysconf(i32 noundef 30) #13
  store i64 %call6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 36), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 180), align 8
  store i32 3, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 183), align 8
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 183), align 8
  %conv = sext i32 %7 to i64
  %mul = mul i64 8, %conv
  %call7 = call noalias ptr @zmalloc(i64 noundef %mul) #18
  store ptr %call7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 182), align 8
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 182), align 8
  %arrayidx8 = getelementptr inbounds double, ptr %8, i64 0
  store double 5.000000e+01, ptr %arrayidx8, align 8
  %9 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 182), align 8
  %arrayidx9 = getelementptr inbounds double, ptr %9, i64 1
  store double 9.900000e+01, ptr %arrayidx9, align 8
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 182), align 8
  %arrayidx10 = getelementptr inbounds double, ptr %10, i64 2
  store double 9.990000e+01, ptr %arrayidx10, align 8
  %call11 = call i32 @getLRUClock()
  store i32 %call11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 16), align 8
  call void @resetServerSaveParams()
  call void @appendServerSaveParams(i64 noundef 3600, i32 noundef 1)
  call void @appendServerSaveParams(i64 noundef 300, i32 noundef 100)
  call void @appendServerSaveParams(i64 noundef 60, i32 noundef 10000)
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  store i32 6379, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 284), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 286), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 287), align 8
  store i64 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 309), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 295), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 294), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 293), align 8
  store i32 5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 288), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 300), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  store atomic i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 264) seq_cst, align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %call12 = call i64 @time(ptr noundef null) #13
  store i64 %call12, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 271), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 411), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 412), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 413), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 414), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 415), align 4
  store i32 0, ptr %j, align 4
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc21, %for.end
  %11 = load i32, ptr %j, align 4
  %cmp14 = icmp slt i32 %11, 3
  br i1 %cmp14, label %for.body16, label %for.end23

for.body16:                                       ; preds = %for.cond13
  %12 = load i32, ptr %j, align 4
  %idxprom17 = sext i32 %12 to i64
  %arrayidx18 = getelementptr inbounds [3 x %struct.clientBufferLimitsConfig], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 179), i64 0, i64 %idxprom17
  %13 = load i32, ptr %j, align 4
  %idxprom19 = sext i32 %13 to i64
  %arrayidx20 = getelementptr inbounds [3 x %struct.clientBufferLimitsConfig], ptr @clientBufferLimitsDefaults, i64 0, i64 %idxprom19
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arrayidx18, ptr align 8 %arrayidx20, i64 24, i1 false)
  br label %for.inc21

for.inc21:                                        ; preds = %for.body16
  %14 = load i32, ptr %j, align 4
  %inc22 = add nsw i32 %14, 1
  store i32 %inc22, ptr %j, align 4
  br label %for.cond13, !llvm.loop !25

for.end23:                                        ; preds = %for.cond13
  store i32 0, ptr %j, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc32, %for.end23
  %15 = load i32, ptr %j, align 4
  %cmp25 = icmp slt i32 %15, 3
  br i1 %cmp25, label %for.body27, label %for.end34

for.body27:                                       ; preds = %for.cond24
  %16 = load i32, ptr %j, align 4
  %idxprom28 = sext i32 %16 to i64
  %arrayidx29 = getelementptr inbounds [3 x i32], ptr @configOOMScoreAdjValuesDefaults, i64 0, i64 %idxprom28
  %17 = load i32, ptr %arrayidx29, align 4
  %18 = load i32, ptr %j, align 4
  %idxprom30 = sext i32 %18 to i64
  %arrayidx31 = getelementptr inbounds [3 x i32], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 322), i64 0, i64 %idxprom30
  store i32 %17, ptr %arrayidx31, align 4
  br label %for.inc32

for.inc32:                                        ; preds = %for.body27
  %19 = load i32, ptr %j, align 4
  %inc33 = add nsw i32 %19, 1
  store i32 %inc33, ptr %j, align 4
  br label %for.cond24, !llvm.loop !26

for.end34:                                        ; preds = %for.cond24
  store double 0.000000e+00, ptr @R_Zero, align 8
  %20 = load double, ptr @R_Zero, align 8
  %div = fdiv double 1.000000e+00, %20
  store double %div, ptr @R_PosInf, align 8
  %21 = load double, ptr @R_Zero, align 8
  %div35 = fdiv double -1.000000e+00, %21
  store double %div35, ptr @R_NegInf, align 8
  %22 = load double, ptr @R_Zero, align 8
  %23 = load double, ptr @R_Zero, align 8
  %div36 = fdiv double %22, %23
  store double %div36, ptr @R_Nan, align 8
  %call37 = call ptr @dictCreate(ptr noundef @commandTableDictType)
  store ptr %call37, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %call38 = call ptr @dictCreate(ptr noundef @commandTableDictType)
  store ptr %call38, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 13), align 8
  call void @populateCommandTable()
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 400), align 8
  ret void
}

declare void @initConfigValues() #2

declare void @getRandomHexChars(ptr noundef, i64 noundef) #2

declare void @changeReplicationId() #2

declare void @clearReplicationId2() #2

declare i64 @getTimeZone() #2

declare noalias ptr @zstrdup(ptr noundef) #2

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #10

declare ptr @dictCreate(ptr noundef) #2

; Function Attrs: nounwind
declare i64 @sysconf(i32 noundef) #3

declare void @resetServerSaveParams() #2

declare void @appendServerSaveParams(i64 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @populateCommandTable() #0 {
entry:
  %j = alloca i32, align 4
  %c = alloca ptr, align 8
  %retval1 = alloca i32, align 4
  %retval2 = alloca i32, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %idx.ext = sext i32 %0 to i64
  %add.ptr = getelementptr inbounds %struct.redisCommand, ptr @redisCommandTable, i64 %idx.ext
  store ptr %add.ptr, ptr %c, align 8
  %1 = load ptr, ptr %c, align 8
  %declared_name = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %declared_name, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  %3 = load ptr, ptr %c, align 8
  %declared_name1 = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %declared_name1, align 8
  %call = call ptr @sdsnew(ptr noundef %4)
  %5 = load ptr, ptr %c, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 27
  store ptr %call, ptr %fullname, align 8
  %6 = load ptr, ptr %c, align 8
  %call2 = call i32 @populateCommandStructure(ptr noundef %6)
  %cmp3 = icmp eq i32 %call2, -1
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %for.inc

if.end5:                                          ; preds = %if.end
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %8 = load ptr, ptr %c, align 8
  %fullname6 = getelementptr inbounds %struct.redisCommand, ptr %8, i32 0, i32 27
  %9 = load ptr, ptr %fullname6, align 8
  %call7 = call ptr @sdsdup(ptr noundef %9)
  %10 = load ptr, ptr %c, align 8
  %call8 = call i32 @dictAdd(ptr noundef %7, ptr noundef %call7, ptr noundef %10)
  store i32 %call8, ptr %retval1, align 4
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 13), align 8
  %12 = load ptr, ptr %c, align 8
  %fullname9 = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 27
  %13 = load ptr, ptr %fullname9, align 8
  %call10 = call ptr @sdsdup(ptr noundef %13)
  %14 = load ptr, ptr %c, align 8
  %call11 = call i32 @dictAdd(ptr noundef %11, ptr noundef %call10, ptr noundef %14)
  store i32 %call11, ptr %retval2, align 4
  %15 = load i32, ptr %retval1, align 4
  %cmp12 = icmp eq i32 %15, 0
  br i1 %cmp12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end5
  %16 = load i32, ptr %retval2, align 4
  %cmp13 = icmp eq i32 %16, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end5
  %17 = phi i1 [ false, %if.end5 ], [ %cmp13, %land.rhs ]
  %lnot = xor i1 %17, true
  %lnot14 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot14 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  br label %cond.end

cond.false:                                       ; preds = %land.end
  call void @_serverAssert(ptr noundef @.str.163, ptr noundef @.str.9, i32 noundef 3133)
  call void @abort() #16
  unreachable

18:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %18, %cond.true
  br label %for.inc

for.inc:                                          ; preds = %cond.end, %if.then4
  %19 = load i32, ptr %j, align 4
  %inc = add nsw i32 %19, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @restartServer(i32 noundef %flags, i64 noundef %delay) #0 {
entry:
  %retval = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %delay.addr = alloca i64, align 8
  %j = alloca i32, align 4
  store i32 %flags, ptr %flags.addr, align 4
  store i64 %delay, ptr %delay.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 3), align 8
  %call = call i32 @access(ptr noundef %0, i32 noundef 1) #13
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 3, %1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 3), align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.126, ptr noundef %2)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  store i32 -1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %entry
  %3 = load i32, ptr %flags.addr, align 4
  %and = and i32 %3, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end3
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  %tobool4 = icmp ne ptr %4, null
  br i1 %tobool4, label %land.lhs.true5, label %if.end16

land.lhs.true5:                                   ; preds = %land.lhs.true
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  %call6 = call i32 @rewriteConfig(ptr noundef %5, i32 noundef 0)
  %cmp7 = icmp eq i32 %call6, -1
  br i1 %cmp7, label %if.then8, label %if.end16

if.then8:                                         ; preds = %land.lhs.true5
  br label %do.body9

do.body9:                                         ; preds = %if.then8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp10 = icmp slt i32 3, %6
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.body9
  br label %do.end15

if.end12:                                         ; preds = %do.body9
  %call13 = call ptr @__errno_location() #17
  %7 = load i32, ptr %call13, align 4
  %call14 = call ptr @strerror(i32 noundef %7) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.127, ptr noundef %call14)
  br label %do.end15

do.end15:                                         ; preds = %if.end12, %if.then11
  store i32 -1, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true5, %land.lhs.true, %if.end3
  %8 = load i32, ptr %flags.addr, align 4
  %and17 = and i32 %8, 1
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %land.lhs.true19, label %if.end28

land.lhs.true19:                                  ; preds = %if.end16
  %call20 = call i32 @prepareForShutdown(i32 noundef 4)
  %cmp21 = icmp ne i32 %call20, 0
  br i1 %cmp21, label %if.then22, label %if.end28

if.then22:                                        ; preds = %land.lhs.true19
  br label %do.body23

do.body23:                                        ; preds = %if.then22
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp24 = icmp slt i32 3, %9
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %do.body23
  br label %do.end27

if.end26:                                         ; preds = %do.body23
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.128)
  br label %do.end27

do.end27:                                         ; preds = %if.end26, %if.then25
  store i32 -1, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %land.lhs.true19, %if.end16
  store i32 3, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end28
  %10 = load i32, ptr %j, align 4
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 313), align 4
  %add = add nsw i32 %11, 1024
  %cmp29 = icmp slt i32 %10, %add
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %j, align 4
  %call30 = call i32 (i32, i32, ...) @fcntl64(i32 noundef %12, i32 noundef 1)
  %cmp31 = icmp ne i32 %call30, -1
  br i1 %cmp31, label %if.then32, label %if.end34

if.then32:                                        ; preds = %for.body
  %13 = load i32, ptr %j, align 4
  %call33 = call i32 @close(i32 noundef %13)
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end34
  %14 = load i32, ptr %j, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  %15 = load i64, ptr %delay.addr, align 8
  %tobool35 = icmp ne i64 %15, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %for.end
  %16 = load i64, ptr %delay.addr, align 8
  %mul = mul nsw i64 %16, 1000
  %conv = trunc i64 %mul to i32
  %call37 = call i32 @usleep(i32 noundef %conv)
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %for.end
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %arrayidx = getelementptr inbounds ptr, ptr %17, i64 0
  %18 = load ptr, ptr %arrayidx, align 8
  call void @zfree(ptr noundef %18)
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 3), align 8
  %call39 = call noalias ptr @zstrdup(ptr noundef %19)
  %20 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %arrayidx40 = getelementptr inbounds ptr, ptr %20, i64 0
  store ptr %call39, ptr %arrayidx40, align 8
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 3), align 8
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %23 = load ptr, ptr @environ, align 8
  %call41 = call i32 @execve(ptr noundef %21, ptr noundef %22, ptr noundef %23) #13
  call void @_exit(i32 noundef 1) #15
  unreachable

return:                                           ; preds = %do.end27, %do.end15, %do.end
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind
declare i32 @access(ptr noundef, i32 noundef) #3

declare i32 @rewriteConfig(ptr noundef, i32 noundef) #2

declare i32 @fcntl64(i32 noundef, i32 noundef, ...) #2

declare i32 @usleep(i32 noundef) #2

; Function Attrs: nounwind
declare i32 @execve(ptr noundef, ptr noundef, ptr noundef) #3

; Function Attrs: nounwind uwtable
define dso_local i32 @setOOMScoreAdj(i32 noundef %process_class) #0 {
entry:
  %retval = alloca i32, align 4
  %process_class.addr = alloca i32, align 4
  %fd = alloca i32, align 4
  %val = alloca i32, align 4
  %buf = alloca [64 x i8], align 16
  store i32 %process_class, ptr %process_class.addr, align 4
  %0 = load i32, ptr %process_class.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool = icmp ne ptr %1, null
  %cond = select i1 %tobool, i32 1, i32 0
  store i32 %cond, ptr %process_class.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %process_class.addr, align 4
  %cmp1 = icmp sge i32 %2, 0
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %3 = load i32, ptr %process_class.addr, align 4
  %cmp2 = icmp slt i32 %3, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %4 = phi i1 [ false, %if.end ], [ %cmp2, %land.rhs ]
  %lnot = xor i1 %4, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool4 = icmp ne i64 %conv, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  br label %cond.end

cond.false:                                       ; preds = %land.end
  call void @_serverAssert(ptr noundef @.str.129, ptr noundef @.str.9, i32 noundef 2278)
  call void @abort() #16
  unreachable

5:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %5, %cond.true
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 323), align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %if.then7, label %if.else

if.then7:                                         ; preds = %cond.end
  %7 = load i32, ptr @setOOMScoreAdj.oom_score_adjusted_by_redis, align 4
  %tobool8 = icmp ne i32 %7, 0
  br i1 %tobool8, label %if.end31, label %if.then9

if.then9:                                         ; preds = %if.then7
  store i32 1, ptr @setOOMScoreAdj.oom_score_adjusted_by_redis, align 4
  %call = call i32 (ptr, i32, ...) @open64(ptr noundef @.str.130, i32 noundef 0)
  store i32 %call, ptr %fd, align 4
  %8 = load i32, ptr %fd, align 4
  %cmp10 = icmp slt i32 %8, 0
  br i1 %cmp10, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then9
  %9 = load i32, ptr %fd, align 4
  %arraydecay = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call12 = call i64 @read(i32 noundef %9, ptr noundef %arraydecay, i64 noundef 64)
  %cmp13 = icmp slt i64 %call12, 0
  br i1 %cmp13, label %if.then15, label %if.end27

if.then15:                                        ; preds = %lor.lhs.false, %if.then9
  br label %do.body

do.body:                                          ; preds = %if.then15
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp16 = icmp slt i32 3, %10
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %do.body
  br label %do.end

if.end19:                                         ; preds = %do.body
  %call20 = call ptr @__errno_location() #17
  %11 = load i32, ptr %call20, align 4
  %call21 = call ptr @strerror(i32 noundef %11) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.131, ptr noundef %call21)
  br label %do.end

do.end:                                           ; preds = %if.end19, %if.then18
  %12 = load i32, ptr %fd, align 4
  %cmp22 = icmp ne i32 %12, -1
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %do.end
  %13 = load i32, ptr %fd, align 4
  %call25 = call i32 @close(i32 noundef %13)
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %do.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %lor.lhs.false
  %arraydecay28 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call29 = call i32 @atoi(ptr noundef %arraydecay28) #14
  store i32 %call29, ptr @setOOMScoreAdj.oom_score_adj_base, align 4
  %14 = load i32, ptr %fd, align 4
  %call30 = call i32 @close(i32 noundef %14)
  br label %if.end31

if.end31:                                         ; preds = %if.end27, %if.then7
  %15 = load i32, ptr %process_class.addr, align 4
  %idxprom = sext i32 %15 to i64
  %arrayidx = getelementptr inbounds [3 x i32], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 322), i64 0, i64 %idxprom
  %16 = load i32, ptr %arrayidx, align 4
  store i32 %16, ptr %val, align 4
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 323), align 4
  %cmp32 = icmp eq i32 %17, 1
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  %18 = load i32, ptr @setOOMScoreAdj.oom_score_adj_base, align 4
  %19 = load i32, ptr %val, align 4
  %add = add nsw i32 %19, %18
  store i32 %add, ptr %val, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.then34, %if.end31
  %20 = load i32, ptr %val, align 4
  %cmp36 = icmp sgt i32 %20, 1000
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end35
  store i32 1000, ptr %val, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %if.end35
  %21 = load i32, ptr %val, align 4
  %cmp40 = icmp slt i32 %21, -1000
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end39
  store i32 -1000, ptr %val, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.end39
  br label %if.end48

if.else:                                          ; preds = %cond.end
  %22 = load i32, ptr @setOOMScoreAdj.oom_score_adjusted_by_redis, align 4
  %tobool44 = icmp ne i32 %22, 0
  br i1 %tobool44, label %if.then45, label %if.else46

if.then45:                                        ; preds = %if.else
  store i32 0, ptr @setOOMScoreAdj.oom_score_adjusted_by_redis, align 4
  %23 = load i32, ptr @setOOMScoreAdj.oom_score_adj_base, align 4
  store i32 %23, ptr %val, align 4
  br label %if.end47

if.else46:                                        ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.then45
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end43
  %arraydecay49 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %24 = load i32, ptr %val, align 4
  %call50 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay49, i64 noundef 63, ptr noundef @.str.132, i32 noundef %24) #13
  %call51 = call i32 (ptr, i32, ...) @open64(ptr noundef @.str.130, i32 noundef 1)
  store i32 %call51, ptr %fd, align 4
  %25 = load i32, ptr %fd, align 4
  %cmp52 = icmp slt i32 %25, 0
  br i1 %cmp52, label %if.then61, label %lor.lhs.false54

lor.lhs.false54:                                  ; preds = %if.end48
  %26 = load i32, ptr %fd, align 4
  %arraydecay55 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %arraydecay56 = getelementptr inbounds [64 x i8], ptr %buf, i64 0, i64 0
  %call57 = call i64 @strlen(ptr noundef %arraydecay56) #14
  %call58 = call i64 @write(i32 noundef %26, ptr noundef %arraydecay55, i64 noundef %call57)
  %cmp59 = icmp slt i64 %call58, 0
  br i1 %cmp59, label %if.then61, label %if.end75

if.then61:                                        ; preds = %lor.lhs.false54, %if.end48
  br label %do.body62

do.body62:                                        ; preds = %if.then61
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp63 = icmp slt i32 3, %27
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %do.body62
  br label %do.end69

if.end66:                                         ; preds = %do.body62
  %call67 = call ptr @__errno_location() #17
  %28 = load i32, ptr %call67, align 4
  %call68 = call ptr @strerror(i32 noundef %28) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.133, ptr noundef %call68)
  br label %do.end69

do.end69:                                         ; preds = %if.end66, %if.then65
  %29 = load i32, ptr %fd, align 4
  %cmp70 = icmp ne i32 %29, -1
  br i1 %cmp70, label %if.then72, label %if.end74

if.then72:                                        ; preds = %do.end69
  %30 = load i32, ptr %fd, align 4
  %call73 = call i32 @close(i32 noundef %30)
  br label %if.end74

if.end74:                                         ; preds = %if.then72, %do.end69
  store i32 -1, ptr %retval, align 4
  br label %return

if.end75:                                         ; preds = %lor.lhs.false54
  %31 = load i32, ptr %fd, align 4
  %call76 = call i32 @close(i32 noundef %31)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end75, %if.end74, %if.else46, %if.end26
  %32 = load i32, ptr %retval, align 4
  ret i32 %32
}

declare i64 @read(i32 noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind willreturn memory(read)
declare i32 @atoi(ptr noundef) #5

; Function Attrs: nounwind uwtable
define dso_local void @adjustOpenFilesLimit() #0 {
entry:
  %maxfiles = alloca i64, align 8
  %limit = alloca %struct.rlimit, align 8
  %oldlimit = alloca i64, align 8
  %bestlimit = alloca i64, align 8
  %setrlimit_error = alloca i32, align 4
  %decr_step = alloca i64, align 8
  %old_maxclients = alloca i32, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 313), align 4
  %add = add i32 %0, 32
  %conv = zext i32 %add to i64
  store i64 %conv, ptr %maxfiles, align 8
  %call = call i32 @getrlimit64(i32 noundef 7, ptr noundef %limit) #13
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp2 = icmp slt i32 3, %1
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %call5 = call ptr @__errno_location() #17
  %2 = load i32, ptr %call5, align 4
  %call6 = call ptr @strerror(i32 noundef %2) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.134, ptr noundef %call6)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then4
  store i32 992, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 313), align 4
  br label %if.end70

if.else:                                          ; preds = %entry
  %rlim_cur = getelementptr inbounds %struct.rlimit, ptr %limit, i32 0, i32 0
  %3 = load i64, ptr %rlim_cur, align 8
  store i64 %3, ptr %oldlimit, align 8
  %4 = load i64, ptr %oldlimit, align 8
  %5 = load i64, ptr %maxfiles, align 8
  %cmp7 = icmp ult i64 %4, %5
  br i1 %cmp7, label %if.then9, label %if.end69

if.then9:                                         ; preds = %if.else
  store i32 0, ptr %setrlimit_error, align 4
  %6 = load i64, ptr %maxfiles, align 8
  store i64 %6, ptr %bestlimit, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end22, %if.then9
  %7 = load i64, ptr %bestlimit, align 8
  %8 = load i64, ptr %oldlimit, align 8
  %cmp10 = icmp ugt i64 %7, %8
  br i1 %cmp10, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i64 16, ptr %decr_step, align 8
  %9 = load i64, ptr %bestlimit, align 8
  %rlim_cur12 = getelementptr inbounds %struct.rlimit, ptr %limit, i32 0, i32 0
  store i64 %9, ptr %rlim_cur12, align 8
  %10 = load i64, ptr %bestlimit, align 8
  %rlim_max = getelementptr inbounds %struct.rlimit, ptr %limit, i32 0, i32 1
  store i64 %10, ptr %rlim_max, align 8
  %call13 = call i32 @setrlimit64(i32 noundef 7, ptr noundef %limit) #13
  %cmp14 = icmp ne i32 %call13, -1
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %while.body
  br label %while.end

if.end17:                                         ; preds = %while.body
  %call18 = call ptr @__errno_location() #17
  %11 = load i32, ptr %call18, align 4
  store i32 %11, ptr %setrlimit_error, align 4
  %12 = load i64, ptr %bestlimit, align 8
  %13 = load i64, ptr %decr_step, align 8
  %cmp19 = icmp ult i64 %12, %13
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end17
  %14 = load i64, ptr %oldlimit, align 8
  store i64 %14, ptr %bestlimit, align 8
  br label %while.end

if.end22:                                         ; preds = %if.end17
  %15 = load i64, ptr %decr_step, align 8
  %16 = load i64, ptr %bestlimit, align 8
  %sub = sub i64 %16, %15
  store i64 %sub, ptr %bestlimit, align 8
  br label %while.cond, !llvm.loop !28

while.end:                                        ; preds = %if.then21, %if.then16, %while.cond
  %17 = load i64, ptr %bestlimit, align 8
  %18 = load i64, ptr %oldlimit, align 8
  %cmp23 = icmp ult i64 %17, %18
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %while.end
  %19 = load i64, ptr %oldlimit, align 8
  store i64 %19, ptr %bestlimit, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %while.end
  %20 = load i64, ptr %bestlimit, align 8
  %21 = load i64, ptr %maxfiles, align 8
  %cmp27 = icmp ult i64 %20, %21
  br i1 %cmp27, label %if.then29, label %if.else61

if.then29:                                        ; preds = %if.end26
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 313), align 4
  store i32 %22, ptr %old_maxclients, align 4
  %23 = load i64, ptr %bestlimit, align 8
  %sub30 = sub i64 %23, 32
  %conv31 = trunc i64 %sub30 to i32
  store i32 %conv31, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 313), align 4
  %24 = load i64, ptr %bestlimit, align 8
  %cmp32 = icmp ule i64 %24, 32
  br i1 %cmp32, label %if.then34, label %if.end41

if.then34:                                        ; preds = %if.then29
  br label %do.body35

do.body35:                                        ; preds = %if.then34
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp36 = icmp slt i32 3, %25
  br i1 %cmp36, label %if.then38, label %if.end39

if.then38:                                        ; preds = %do.body35
  br label %do.end40

if.end39:                                         ; preds = %do.body35
  %26 = load i64, ptr %oldlimit, align 8
  %27 = load i64, ptr %maxfiles, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.135, i64 noundef %26, i64 noundef %27)
  br label %do.end40

do.end40:                                         ; preds = %if.end39, %if.then38
  call void @exit(i32 noundef 1) #16
  unreachable

if.end41:                                         ; preds = %if.then29
  br label %do.body42

do.body42:                                        ; preds = %if.end41
  %28 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp43 = icmp slt i32 3, %28
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %do.body42
  br label %do.end47

if.end46:                                         ; preds = %do.body42
  %29 = load i32, ptr %old_maxclients, align 4
  %30 = load i64, ptr %maxfiles, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.136, i32 noundef %29, i64 noundef %30)
  br label %do.end47

do.end47:                                         ; preds = %if.end46, %if.then45
  br label %do.body48

do.body48:                                        ; preds = %do.end47
  %31 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp49 = icmp slt i32 3, %31
  br i1 %cmp49, label %if.then51, label %if.end52

if.then51:                                        ; preds = %do.body48
  br label %do.end54

if.end52:                                         ; preds = %do.body48
  %32 = load i64, ptr %maxfiles, align 8
  %33 = load i32, ptr %setrlimit_error, align 4
  %call53 = call ptr @strerror(i32 noundef %33) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.137, i64 noundef %32, ptr noundef %call53)
  br label %do.end54

do.end54:                                         ; preds = %if.end52, %if.then51
  br label %do.body55

do.body55:                                        ; preds = %do.end54
  %34 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp56 = icmp slt i32 3, %34
  br i1 %cmp56, label %if.then58, label %if.end59

if.then58:                                        ; preds = %do.body55
  br label %do.end60

if.end59:                                         ; preds = %do.body55
  %35 = load i64, ptr %bestlimit, align 8
  %36 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 313), align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.138, i64 noundef %35, i32 noundef %36)
  br label %do.end60

do.end60:                                         ; preds = %if.end59, %if.then58
  br label %if.end68

if.else61:                                        ; preds = %if.end26
  br label %do.body62

do.body62:                                        ; preds = %if.else61
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp63 = icmp slt i32 2, %37
  br i1 %cmp63, label %if.then65, label %if.end66

if.then65:                                        ; preds = %do.body62
  br label %do.end67

if.end66:                                         ; preds = %do.body62
  %38 = load i64, ptr %maxfiles, align 8
  %39 = load i64, ptr %oldlimit, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.139, i64 noundef %38, i64 noundef %39)
  br label %do.end67

do.end67:                                         ; preds = %if.end66, %if.then65
  br label %if.end68

if.end68:                                         ; preds = %do.end67, %do.end60
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %if.else
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %do.end
  ret void
}

; Function Attrs: nounwind
declare i32 @getrlimit64(i32 noundef, ptr noundef) #3

; Function Attrs: nounwind
declare i32 @setrlimit64(i32 noundef, ptr noundef) #3

; Function Attrs: nounwind uwtable
define dso_local void @checkTcpBacklogSettings() #0 {
entry:
  %fp = alloca ptr, align 8
  %buf = alloca [1024 x i8], align 16
  %somaxconn = alloca i32, align 4
  %call = call noalias ptr @fopen64(ptr noundef @.str.140, ptr noundef @.str.141)
  store ptr %call, ptr %fp, align 8
  %0 = load ptr, ptr %fp, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %1 = load ptr, ptr %fp, align 8
  %call1 = call ptr @fgets(ptr noundef %arraydecay, i32 noundef 1024, ptr noundef %1)
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %if.then2, label %if.end12

if.then2:                                         ; preds = %if.end
  %arraydecay3 = getelementptr inbounds [1024 x i8], ptr %buf, i64 0, i64 0
  %call4 = call i32 @atoi(ptr noundef %arraydecay3) #14
  store i32 %call4, ptr %somaxconn, align 4
  %2 = load i32, ptr %somaxconn, align 4
  %cmp5 = icmp sgt i32 %2, 0
  br i1 %cmp5, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.then2
  %3 = load i32, ptr %somaxconn, align 4
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 46), align 8
  %cmp6 = icmp slt i32 %3, %4
  br i1 %cmp6, label %if.then7, label %if.end11

if.then7:                                         ; preds = %land.lhs.true
  br label %do.body

do.body:                                          ; preds = %if.then7
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp8 = icmp slt i32 3, %5
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.body
  br label %do.end

if.end10:                                         ; preds = %do.body
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 46), align 8
  %7 = load i32, ptr %somaxconn, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.142, i32 noundef %6, i32 noundef %7)
  br label %do.end

do.end:                                           ; preds = %if.end10, %if.then9
  br label %if.end11

if.end11:                                         ; preds = %do.end, %land.lhs.true, %if.then2
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  %8 = load ptr, ptr %fp, align 8
  %call13 = call i32 @fclose(ptr noundef %8)
  br label %return

return:                                           ; preds = %if.end12, %if.then
  ret void
}

declare ptr @fgets(ptr noundef, i32 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @closeListener(ptr noundef %sfd) #0 {
entry:
  %sfd.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  store ptr %sfd, ptr %sfd.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %j, align 4
  %1 = load ptr, ptr %sfd.addr, align 8
  %count = getelementptr inbounds %struct.connListener, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %count, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %sfd.addr, align 8
  %fd = getelementptr inbounds %struct.connListener, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %j, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [16 x i32], ptr %fd, i64 0, i64 %idxprom
  %5 = load i32, ptr %arrayidx, align 4
  %cmp1 = icmp eq i32 %5, -1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %7 = load ptr, ptr %sfd.addr, align 8
  %fd2 = getelementptr inbounds %struct.connListener, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %j, align 4
  %idxprom3 = sext i32 %8 to i64
  %arrayidx4 = getelementptr inbounds [16 x i32], ptr %fd2, i64 0, i64 %idxprom3
  %9 = load i32, ptr %arrayidx4, align 4
  call void @aeDeleteFileEvent(ptr noundef %6, i32 noundef %9, i32 noundef 1)
  %10 = load ptr, ptr %sfd.addr, align 8
  %fd5 = getelementptr inbounds %struct.connListener, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %j, align 4
  %idxprom6 = sext i32 %11 to i64
  %arrayidx7 = getelementptr inbounds [16 x i32], ptr %fd5, i64 0, i64 %idxprom6
  %12 = load i32, ptr %arrayidx7, align 4
  %call = call i32 @close(i32 noundef %12)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then
  %13 = load i32, ptr %j, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !29

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %sfd.addr, align 8
  %count8 = getelementptr inbounds %struct.connListener, ptr %14, i32 0, i32 1
  store i32 0, ptr %count8, align 8
  ret void
}

declare void @aeDeleteFileEvent(ptr noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @createSocketAcceptHandler(ptr noundef %sfd, ptr noundef %accept_handler) #0 {
entry:
  %retval = alloca i32, align 4
  %sfd.addr = alloca ptr, align 8
  %accept_handler.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  store ptr %sfd, ptr %sfd.addr, align 8
  store ptr %accept_handler, ptr %accept_handler.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc8, %entry
  %0 = load i32, ptr %j, align 4
  %1 = load ptr, ptr %sfd.addr, align 8
  %count = getelementptr inbounds %struct.connListener, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %count, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end9

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %4 = load ptr, ptr %sfd.addr, align 8
  %fd = getelementptr inbounds %struct.connListener, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [16 x i32], ptr %fd, i64 0, i64 %idxprom
  %6 = load i32, ptr %arrayidx, align 4
  %7 = load ptr, ptr %accept_handler.addr, align 8
  %8 = load ptr, ptr %sfd.addr, align 8
  %call = call i32 @aeCreateFileEvent(ptr noundef %3, i32 noundef %6, i32 noundef 1, ptr noundef %7, ptr noundef %8)
  %cmp1 = icmp eq i32 %call, -1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %9 = load i32, ptr %j, align 4
  %sub = sub nsw i32 %9, 1
  store i32 %sub, ptr %j, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %if.then
  %10 = load i32, ptr %j, align 4
  %cmp3 = icmp sge i32 %10, 0
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %12 = load ptr, ptr %sfd.addr, align 8
  %fd5 = getelementptr inbounds %struct.connListener, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %j, align 4
  %idxprom6 = sext i32 %13 to i64
  %arrayidx7 = getelementptr inbounds [16 x i32], ptr %fd5, i64 0, i64 %idxprom6
  %14 = load i32, ptr %arrayidx7, align 4
  call void @aeDeleteFileEvent(ptr noundef %11, i32 noundef %14, i32 noundef 1)
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %15 = load i32, ptr %j, align 4
  %dec = add nsw i32 %15, -1
  store i32 %dec, ptr %j, align 4
  br label %for.cond2, !llvm.loop !30

for.end:                                          ; preds = %for.cond2
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc8

for.inc8:                                         ; preds = %if.end
  %16 = load i32, ptr %j, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !31

for.end9:                                         ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end9, %for.end
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare i32 @aeCreateFileEvent(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @listenToPort(ptr noundef %sfd) #0 {
entry:
  %retval = alloca i32, align 4
  %sfd.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %port = alloca i32, align 4
  %bindaddr = alloca ptr, align 8
  %addr = alloca ptr, align 8
  %optional = alloca i32, align 4
  %net_errno = alloca i32, align 4
  store ptr %sfd, ptr %sfd.addr, align 8
  %0 = load ptr, ptr %sfd.addr, align 8
  %port1 = getelementptr inbounds %struct.connListener, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %port1, align 4
  store i32 %1, ptr %port, align 4
  %2 = load ptr, ptr %sfd.addr, align 8
  %bindaddr2 = getelementptr inbounds %struct.connListener, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %bindaddr2, align 8
  store ptr %3, ptr %bindaddr, align 8
  %4 = load ptr, ptr %sfd.addr, align 8
  %bindaddr_count = getelementptr inbounds %struct.connListener, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %bindaddr_count, align 8
  %cmp = icmp eq i32 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, ptr %j, align 4
  %7 = load ptr, ptr %sfd.addr, align 8
  %bindaddr_count3 = getelementptr inbounds %struct.connListener, ptr %7, i32 0, i32 3
  %8 = load i32, ptr %bindaddr_count3, align 8
  %cmp4 = icmp slt i32 %6, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %bindaddr, align 8
  %10 = load i32, ptr %j, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %9, i64 %idxprom
  %11 = load ptr, ptr %arrayidx, align 8
  store ptr %11, ptr %addr, align 8
  %12 = load ptr, ptr %addr, align 8
  %13 = load i8, ptr %12, align 1
  %conv = sext i8 %13 to i32
  %cmp5 = icmp eq i32 %conv, 45
  %conv6 = zext i1 %cmp5 to i32
  store i32 %conv6, ptr %optional, align 4
  %14 = load i32, ptr %optional, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then7, label %if.end8

if.then7:                                         ; preds = %for.body
  %15 = load ptr, ptr %addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %15, i32 1
  store ptr %incdec.ptr, ptr %addr, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %for.body
  %16 = load ptr, ptr %addr, align 8
  %call = call ptr @strchr(ptr noundef %16, i32 noundef 58) #14
  %tobool9 = icmp ne ptr %call, null
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end8
  %17 = load i32, ptr %port, align 4
  %18 = load ptr, ptr %addr, align 8
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 46), align 8
  %call11 = call i32 @anetTcp6Server(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 70), i32 noundef %17, ptr noundef %18, i32 noundef %19)
  %20 = load ptr, ptr %sfd.addr, align 8
  %fd = getelementptr inbounds %struct.connListener, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %sfd.addr, align 8
  %count = getelementptr inbounds %struct.connListener, ptr %21, i32 0, i32 1
  %22 = load i32, ptr %count, align 8
  %idxprom12 = sext i32 %22 to i64
  %arrayidx13 = getelementptr inbounds [16 x i32], ptr %fd, i64 0, i64 %idxprom12
  store i32 %call11, ptr %arrayidx13, align 4
  br label %if.end19

if.else:                                          ; preds = %if.end8
  %23 = load i32, ptr %port, align 4
  %24 = load ptr, ptr %addr, align 8
  %25 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 46), align 8
  %call14 = call i32 @anetTcpServer(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 70), i32 noundef %23, ptr noundef %24, i32 noundef %25)
  %26 = load ptr, ptr %sfd.addr, align 8
  %fd15 = getelementptr inbounds %struct.connListener, ptr %26, i32 0, i32 0
  %27 = load ptr, ptr %sfd.addr, align 8
  %count16 = getelementptr inbounds %struct.connListener, ptr %27, i32 0, i32 1
  %28 = load i32, ptr %count16, align 8
  %idxprom17 = sext i32 %28 to i64
  %arrayidx18 = getelementptr inbounds [16 x i32], ptr %fd15, i64 0, i64 %idxprom17
  store i32 %call14, ptr %arrayidx18, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then10
  %29 = load ptr, ptr %sfd.addr, align 8
  %fd20 = getelementptr inbounds %struct.connListener, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %sfd.addr, align 8
  %count21 = getelementptr inbounds %struct.connListener, ptr %30, i32 0, i32 1
  %31 = load i32, ptr %count21, align 8
  %idxprom22 = sext i32 %31 to i64
  %arrayidx23 = getelementptr inbounds [16 x i32], ptr %fd20, i64 0, i64 %idxprom22
  %32 = load i32, ptr %arrayidx23, align 4
  %cmp24 = icmp eq i32 %32, -1
  br i1 %cmp24, label %if.then26, label %if.end52

if.then26:                                        ; preds = %if.end19
  %call27 = call ptr @__errno_location() #17
  %33 = load i32, ptr %call27, align 4
  store i32 %33, ptr %net_errno, align 4
  br label %do.body

do.body:                                          ; preds = %if.then26
  %34 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp28 = icmp slt i32 3, %34
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %do.body
  br label %do.end

if.end31:                                         ; preds = %do.body
  %35 = load ptr, ptr %addr, align 8
  %36 = load i32, ptr %port, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.143, ptr noundef %35, i32 noundef %36, ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 70))
  br label %do.end

do.end:                                           ; preds = %if.end31, %if.then30
  %37 = load i32, ptr %net_errno, align 4
  %cmp32 = icmp eq i32 %37, 99
  br i1 %cmp32, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %do.end
  %38 = load i32, ptr %optional, align 4
  %tobool34 = icmp ne i32 %38, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %land.lhs.true
  br label %for.inc

if.end36:                                         ; preds = %land.lhs.true, %do.end
  %39 = load i32, ptr %net_errno, align 4
  %cmp37 = icmp eq i32 %39, 92
  br i1 %cmp37, label %if.then50, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end36
  %40 = load i32, ptr %net_errno, align 4
  %cmp39 = icmp eq i32 %40, 93
  br i1 %cmp39, label %if.then50, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false
  %41 = load i32, ptr %net_errno, align 4
  %cmp42 = icmp eq i32 %41, 94
  br i1 %cmp42, label %if.then50, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %lor.lhs.false41
  %42 = load i32, ptr %net_errno, align 4
  %cmp45 = icmp eq i32 %42, 96
  br i1 %cmp45, label %if.then50, label %lor.lhs.false47

lor.lhs.false47:                                  ; preds = %lor.lhs.false44
  %43 = load i32, ptr %net_errno, align 4
  %cmp48 = icmp eq i32 %43, 97
  br i1 %cmp48, label %if.then50, label %if.end51

if.then50:                                        ; preds = %lor.lhs.false47, %lor.lhs.false44, %lor.lhs.false41, %lor.lhs.false, %if.end36
  br label %for.inc

if.end51:                                         ; preds = %lor.lhs.false47
  %44 = load ptr, ptr %sfd.addr, align 8
  call void @closeListener(ptr noundef %44)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end19
  %45 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 53), align 8
  %cmp53 = icmp ugt i32 %45, 0
  br i1 %cmp53, label %if.then55, label %if.end61

if.then55:                                        ; preds = %if.end52
  %46 = load ptr, ptr %sfd.addr, align 8
  %fd56 = getelementptr inbounds %struct.connListener, ptr %46, i32 0, i32 0
  %47 = load ptr, ptr %sfd.addr, align 8
  %count57 = getelementptr inbounds %struct.connListener, ptr %47, i32 0, i32 1
  %48 = load i32, ptr %count57, align 8
  %idxprom58 = sext i32 %48 to i64
  %arrayidx59 = getelementptr inbounds [16 x i32], ptr %fd56, i64 0, i64 %idxprom58
  %49 = load i32, ptr %arrayidx59, align 4
  %50 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 53), align 8
  %call60 = call i32 @anetSetSockMarkId(ptr noundef null, i32 noundef %49, i32 noundef %50)
  br label %if.end61

if.end61:                                         ; preds = %if.then55, %if.end52
  %51 = load ptr, ptr %sfd.addr, align 8
  %fd62 = getelementptr inbounds %struct.connListener, ptr %51, i32 0, i32 0
  %52 = load ptr, ptr %sfd.addr, align 8
  %count63 = getelementptr inbounds %struct.connListener, ptr %52, i32 0, i32 1
  %53 = load i32, ptr %count63, align 8
  %idxprom64 = sext i32 %53 to i64
  %arrayidx65 = getelementptr inbounds [16 x i32], ptr %fd62, i64 0, i64 %idxprom64
  %54 = load i32, ptr %arrayidx65, align 4
  %call66 = call i32 @anetNonBlock(ptr noundef null, i32 noundef %54)
  %55 = load ptr, ptr %sfd.addr, align 8
  %fd67 = getelementptr inbounds %struct.connListener, ptr %55, i32 0, i32 0
  %56 = load ptr, ptr %sfd.addr, align 8
  %count68 = getelementptr inbounds %struct.connListener, ptr %56, i32 0, i32 1
  %57 = load i32, ptr %count68, align 8
  %idxprom69 = sext i32 %57 to i64
  %arrayidx70 = getelementptr inbounds [16 x i32], ptr %fd67, i64 0, i64 %idxprom69
  %58 = load i32, ptr %arrayidx70, align 4
  %call71 = call i32 @anetCloexec(i32 noundef %58)
  %59 = load ptr, ptr %sfd.addr, align 8
  %count72 = getelementptr inbounds %struct.connListener, ptr %59, i32 0, i32 1
  %60 = load i32, ptr %count72, align 8
  %inc = add nsw i32 %60, 1
  store i32 %inc, ptr %count72, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end61, %if.then50, %if.then35
  %61 = load i32, ptr %j, align 4
  %inc73 = add nsw i32 %61, 1
  store i32 %inc73, ptr %j, align 4
  br label %for.cond, !llvm.loop !32

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end51, %if.then
  %62 = load i32, ptr %retval, align 4
  ret i32 %62
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strchr(ptr noundef, i32 noundef) #5

declare i32 @anetTcp6Server(ptr noundef, i32 noundef, ptr noundef, i32 noundef) #2

declare i32 @anetTcpServer(ptr noundef, i32 noundef, ptr noundef, i32 noundef) #2

declare i32 @anetSetSockMarkId(ptr noundef, i32 noundef, i32 noundef) #2

declare i32 @anetNonBlock(ptr noundef, i32 noundef) #2

declare i32 @anetCloexec(i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @resetServerStats() #0 {
entry:
  %j = alloca i32, align 4
  %.atomictmp = alloca i64, align 8
  %.atomictmp1 = alloca i64, align 8
  %.atomictmp2 = alloca i64, align 8
  %.atomictmp9 = alloca i64, align 8
  %.atomictmp10 = alloca i64, align 8
  %.atomictmp11 = alloca i64, align 8
  %.atomictmp12 = alloca i64, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 89), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 90), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 91), align 8
  store double 0.000000e+00, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 92), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 93), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 94), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 95), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 96), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 97), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 98), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 100), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 99), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 101), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 102), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 103), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 104), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 105), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 106), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 107), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 112), align 8
  store double 0.000000e+00, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 113), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 114), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 115), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 116), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 117), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 118), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 142), align 8
  store i64 0, ptr %.atomictmp, align 8
  %0 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 144) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 143), align 8
  store i64 0, ptr %.atomictmp1, align 8
  %1 = load i64, ptr %.atomictmp1, align 8
  store atomic i64 %1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 145) monotonic, align 8
  store i64 0, ptr %.atomictmp2, align 8
  %2 = load i64, ptr %.atomictmp2, align 8
  store atomic i64 %2, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 146) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 147), align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %j, align 4
  %cmp = icmp slt i32 %3, 7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %j, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom
  %idx = getelementptr inbounds %struct.anon, ptr %arrayidx, i32 0, i32 3
  store i32 0, ptr %idx, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom3 = sext i32 %5 to i64
  %arrayidx4 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom3
  %last_sample_base = getelementptr inbounds %struct.anon, ptr %arrayidx4, i32 0, i32 0
  store i64 0, ptr %last_sample_base, align 8
  %6 = load i32, ptr %j, align 4
  %idxprom5 = sext i32 %6 to i64
  %arrayidx6 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom5
  %last_sample_value = getelementptr inbounds %struct.anon, ptr %arrayidx6, i32 0, i32 1
  store i64 0, ptr %last_sample_value, align 8
  %7 = load i32, ptr %j, align 4
  %idxprom7 = sext i32 %7 to i64
  %arrayidx8 = getelementptr inbounds [7 x %struct.anon], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 148), i64 0, i64 %idxprom7
  %samples = getelementptr inbounds %struct.anon, ptr %arrayidx8, i32 0, i32 2
  %arraydecay = getelementptr inbounds [16 x i64], ptr %samples, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay, i8 0, i64 128, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, ptr %j, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %for.cond
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 109), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 111), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 110), align 8
  store i64 0, ptr %.atomictmp9, align 8
  %9 = load i64, ptr %.atomictmp9, align 8
  store atomic i64 %9, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 124) monotonic, align 8
  store i64 0, ptr %.atomictmp10, align 8
  %10 = load i64, ptr %.atomictmp10, align 8
  store atomic i64 %10, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 125) monotonic, align 8
  store i64 0, ptr %.atomictmp11, align 8
  %11 = load i64, ptr %.atomictmp11, align 8
  store atomic i64 %11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 126) monotonic, align 8
  store i64 0, ptr %.atomictmp12, align 8
  %12 = load i64, ptr %.atomictmp12, align 8
  store atomic i64 %12, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 127) monotonic, align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 139), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 140), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 141), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 208), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 149), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 150), align 8
  call void @llvm.memset.p0.i64(ptr align 8 getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155), i8 0, i64 96, i1 false)
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 153), align 8
  call void @lazyfreeResetStats()
  ret void
}

declare void @lazyfreeResetStats() #2

; Function Attrs: nounwind uwtable
define dso_local void @makeThreadKillable() #0 {
entry:
  %call = call i32 @pthread_setcancelstate(i32 noundef 0, ptr noundef null)
  %call1 = call i32 @pthread_setcanceltype(i32 noundef 1, ptr noundef null)
  ret void
}

declare i32 @pthread_setcancelstate(i32 noundef, ptr noundef) #2

declare i32 @pthread_setcanceltype(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @initDbState(ptr noundef %db) #0 {
entry:
  %db.addr = alloca ptr, align 8
  %subdict = alloca i32, align 4
  store ptr %db, ptr %db.addr, align 8
  store i32 0, ptr %subdict, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %subdict, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %db.addr, align 8
  %sub_dict = getelementptr inbounds %struct.redisDb, ptr %1, i32 0, i32 11
  %2 = load i32, ptr %subdict, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict, i64 0, i64 %idxprom
  %non_empty_slots = getelementptr inbounds %struct.dbDictState, ptr %arrayidx, i32 0, i32 1
  store i32 0, ptr %non_empty_slots, align 4
  %3 = load ptr, ptr %db.addr, align 8
  %sub_dict1 = getelementptr inbounds %struct.redisDb, ptr %3, i32 0, i32 11
  %4 = load i32, ptr %subdict, align 4
  %idxprom2 = zext i32 %4 to i64
  %arrayidx3 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict1, i64 0, i64 %idxprom2
  %key_count = getelementptr inbounds %struct.dbDictState, ptr %arrayidx3, i32 0, i32 2
  store i64 0, ptr %key_count, align 8
  %5 = load ptr, ptr %db.addr, align 8
  %sub_dict4 = getelementptr inbounds %struct.redisDb, ptr %5, i32 0, i32 11
  %6 = load i32, ptr %subdict, align 4
  %idxprom5 = zext i32 %6 to i64
  %arrayidx6 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict4, i64 0, i64 %idxprom5
  %resize_cursor = getelementptr inbounds %struct.dbDictState, ptr %arrayidx6, i32 0, i32 0
  store i32 -1, ptr %resize_cursor, align 8
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %call = call noalias ptr @zcalloc(i64 noundef 131080) #18
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ null, %cond.false ]
  %8 = load ptr, ptr %db.addr, align 8
  %sub_dict7 = getelementptr inbounds %struct.redisDb, ptr %8, i32 0, i32 11
  %9 = load i32, ptr %subdict, align 4
  %idxprom8 = zext i32 %9 to i64
  %arrayidx9 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict7, i64 0, i64 %idxprom8
  %slot_size_index = getelementptr inbounds %struct.dbDictState, ptr %arrayidx9, i32 0, i32 4
  store ptr %cond, ptr %slot_size_index, align 8
  %10 = load ptr, ptr %db.addr, align 8
  %sub_dict10 = getelementptr inbounds %struct.redisDb, ptr %10, i32 0, i32 11
  %11 = load i32, ptr %subdict, align 4
  %idxprom11 = zext i32 %11 to i64
  %arrayidx12 = getelementptr inbounds [2 x %struct.dbDictState], ptr %sub_dict10, i64 0, i64 %idxprom11
  %bucket_count = getelementptr inbounds %struct.dbDictState, ptr %arrayidx12, i32 0, i32 3
  store i64 0, ptr %bucket_count, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %12 = load i32, ptr %subdict, align 4
  %inc = add i32 %12, 1
  store i32 %inc, ptr %subdict, align 4
  br label %for.cond, !llvm.loop !34

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @zcalloc(i64 noundef) #9

; Function Attrs: nounwind uwtable
define dso_local void @initServer() #0 {
entry:
  %j = alloca i32, align 4
  %clk_msg = alloca ptr, align 8
  %slotCount = alloca i32, align 4
  %j96 = alloca i32, align 4
  %call = call ptr @signal(i32 noundef 1, ptr noundef inttoptr (i64 1 to ptr)) #13
  %call1 = call ptr @signal(i32 noundef 13, ptr noundef inttoptr (i64 1 to ptr)) #13
  call void @setupSignalHandlers()
  call void @ThreadsManager_init()
  call void @makeThreadKillable()
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 251), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 252), align 8
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 253), align 8
  call void @openlog(ptr noundef %1, i32 noundef 25, i32 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 184), align 4
  %tobool2 = icmp ne i32 %3, 0
  %cond = select i1 %tobool2, i32 1, i32 0
  store i32 %cond, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 184), align 4
  %tobool3 = icmp ne i32 %4, 0
  %cond4 = select i1 %tobool3, i32 0, i32 -1
  %conv = sext i32 %cond4 to i64
  store i64 %conv, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 265), align 8
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 6), align 4
  store i32 %5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %call5 = call i32 @getpid() #13
  store i32 %call5, ptr @server, align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 9), align 8
  %call6 = call i64 @pthread_self() #17
  store i64 %call6, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 1), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %call7 = call ptr @raxNew()
  store ptr %call7, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 15), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %call8 = call ptr @listCreate()
  store ptr %call8, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  %call9 = call ptr @raxNew()
  store ptr %call9, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 66), align 8
  %call10 = call ptr @listCreate()
  store ptr %call10, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 56), align 8
  %call11 = call ptr @listCreate()
  store ptr %call11, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %call12 = call ptr @listCreate()
  store ptr %call12, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 60), align 8
  %call13 = call ptr @listCreate()
  store ptr %call13, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 57), align 8
  %call14 = call ptr @listCreate()
  store ptr %call14, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 58), align 8
  %call15 = call ptr @raxNew()
  store ptr %call15, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 64), align 8
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 249), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 266), align 8
  %call16 = call ptr @listCreate()
  store ptr %call16, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 327), align 8
  %call17 = call ptr @listCreate()
  store ptr %call17, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 328), align 8
  %call18 = call ptr @listCreate()
  store ptr %call18, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 331), align 8
  %call19 = call ptr @listCreate()
  store ptr %call19, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 332), align 8
  %call20 = call ptr @listCreate()
  store ptr %call20, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 311), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 312), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 67), align 8
  call void @llvm.memset.p0.i64(ptr align 8 getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 69), i8 0, i64 48, i1 false)
  %call21 = call ptr @listCreate()
  store ptr %call21, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 68), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 77), align 8
  %call22 = call i64 @zmalloc_get_memory_size()
  store i64 %call22, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 401), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 356), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 355), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 35), align 4
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 384), align 8
  store i64 5000, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 417), align 8
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 418), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 63), align 8
  call void @resetReplicationBuffer()
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 419), align 8
  %call23 = call ptr @setlocale(i32 noundef 3, ptr noundef %6) #13
  %cmp = icmp eq ptr %call23, null
  br i1 %cmp, label %if.then25, label %if.end30

if.then25:                                        ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then25
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp26 = icmp slt i32 3, %7
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %do.body
  br label %do.end

if.end29:                                         ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.144)
  br label %do.end

do.end:                                           ; preds = %if.end29, %if.then28
  call void @exit(i32 noundef 1) #16
  unreachable

if.end30:                                         ; preds = %if.end
  call void @createSharedObjects()
  call void @adjustOpenFilesLimit()
  %call31 = call ptr @monotonicInit()
  store ptr %call31, ptr %clk_msg, align 8
  br label %do.body32

do.body32:                                        ; preds = %if.end30
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp33 = icmp slt i32 2, %8
  br i1 %cmp33, label %if.then35, label %if.end36

if.then35:                                        ; preds = %do.body32
  br label %do.end37

if.end36:                                         ; preds = %do.body32
  %9 = load ptr, ptr %clk_msg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.145, ptr noundef %9)
  br label %do.end37

do.end37:                                         ; preds = %if.end36, %if.then35
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 313), align 4
  %add = add i32 %10, 128
  %call38 = call ptr @aeCreateEventLoop(i32 noundef %add)
  store ptr %call38, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %cmp39 = icmp eq ptr %11, null
  br i1 %cmp39, label %if.then41, label %if.end50

if.then41:                                        ; preds = %do.end37
  br label %do.body42

do.body42:                                        ; preds = %if.then41
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp43 = icmp slt i32 3, %12
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %do.body42
  br label %do.end49

if.end46:                                         ; preds = %do.body42
  %call47 = call ptr @__errno_location() #17
  %13 = load i32, ptr %call47, align 4
  %call48 = call ptr @strerror(i32 noundef %13) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.146, ptr noundef %call48)
  br label %do.end49

do.end49:                                         ; preds = %if.end46, %if.then45
  call void @exit(i32 noundef 1) #16
  unreachable

if.end50:                                         ; preds = %do.end37
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 173), align 8
  %conv51 = sext i32 %14 to i64
  %mul = mul i64 152, %conv51
  %call52 = call noalias ptr @zmalloc(i64 noundef %mul) #18
  store ptr %call52, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end50
  %15 = load i32, ptr %j, align 4
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 173), align 8
  %cmp53 = icmp slt i32 %15, %16
  br i1 %cmp53, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool55 = icmp ne i32 %17, 0
  %cond56 = select i1 %tobool55, i32 16384, i32 1
  store i32 %cond56, ptr %slotCount, align 4
  %18 = load i32, ptr %slotCount, align 4
  %call57 = call ptr @dictCreateMultiple(ptr noundef @dbDictType, i32 noundef %18)
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %20 = load i32, ptr %j, align 4
  %idxprom = sext i32 %20 to i64
  %arrayidx = getelementptr inbounds %struct.redisDb, ptr %19, i64 %idxprom
  %dict = getelementptr inbounds %struct.redisDb, ptr %arrayidx, i32 0, i32 0
  store ptr %call57, ptr %dict, align 8
  %21 = load i32, ptr %slotCount, align 4
  %call58 = call ptr @dictCreateMultiple(ptr noundef @dbExpiresDictType, i32 noundef %21)
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %23 = load i32, ptr %j, align 4
  %idxprom59 = sext i32 %23 to i64
  %arrayidx60 = getelementptr inbounds %struct.redisDb, ptr %22, i64 %idxprom59
  %expires = getelementptr inbounds %struct.redisDb, ptr %arrayidx60, i32 0, i32 1
  store ptr %call58, ptr %expires, align 8
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %25 = load i32, ptr %j, align 4
  %idxprom61 = sext i32 %25 to i64
  %arrayidx62 = getelementptr inbounds %struct.redisDb, ptr %24, i64 %idxprom61
  %expires_cursor = getelementptr inbounds %struct.redisDb, ptr %arrayidx62, i32 0, i32 8
  store i64 0, ptr %expires_cursor, align 8
  %call63 = call ptr @dictCreate(ptr noundef @keylistDictType)
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %27 = load i32, ptr %j, align 4
  %idxprom64 = sext i32 %27 to i64
  %arrayidx65 = getelementptr inbounds %struct.redisDb, ptr %26, i64 %idxprom64
  %blocking_keys = getelementptr inbounds %struct.redisDb, ptr %arrayidx65, i32 0, i32 2
  store ptr %call63, ptr %blocking_keys, align 8
  %call66 = call ptr @dictCreate(ptr noundef @objectKeyPointerValueDictType)
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %29 = load i32, ptr %j, align 4
  %idxprom67 = sext i32 %29 to i64
  %arrayidx68 = getelementptr inbounds %struct.redisDb, ptr %28, i64 %idxprom67
  %blocking_keys_unblock_on_nokey = getelementptr inbounds %struct.redisDb, ptr %arrayidx68, i32 0, i32 3
  store ptr %call66, ptr %blocking_keys_unblock_on_nokey, align 8
  %call69 = call ptr @dictCreate(ptr noundef @objectKeyPointerValueDictType)
  %30 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %31 = load i32, ptr %j, align 4
  %idxprom70 = sext i32 %31 to i64
  %arrayidx71 = getelementptr inbounds %struct.redisDb, ptr %30, i64 %idxprom70
  %ready_keys = getelementptr inbounds %struct.redisDb, ptr %arrayidx71, i32 0, i32 4
  store ptr %call69, ptr %ready_keys, align 8
  %call72 = call ptr @dictCreate(ptr noundef @keylistDictType)
  %32 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %33 = load i32, ptr %j, align 4
  %idxprom73 = sext i32 %33 to i64
  %arrayidx74 = getelementptr inbounds %struct.redisDb, ptr %32, i64 %idxprom73
  %watched_keys = getelementptr inbounds %struct.redisDb, ptr %arrayidx74, i32 0, i32 5
  store ptr %call72, ptr %watched_keys, align 8
  %34 = load i32, ptr %j, align 4
  %35 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %36 = load i32, ptr %j, align 4
  %idxprom75 = sext i32 %36 to i64
  %arrayidx76 = getelementptr inbounds %struct.redisDb, ptr %35, i64 %idxprom75
  %id = getelementptr inbounds %struct.redisDb, ptr %arrayidx76, i32 0, i32 6
  store i32 %34, ptr %id, align 8
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %38 = load i32, ptr %j, align 4
  %idxprom77 = sext i32 %38 to i64
  %arrayidx78 = getelementptr inbounds %struct.redisDb, ptr %37, i64 %idxprom77
  %avg_ttl = getelementptr inbounds %struct.redisDb, ptr %arrayidx78, i32 0, i32 7
  store i64 0, ptr %avg_ttl, align 8
  %call79 = call ptr @listCreate()
  %39 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %40 = load i32, ptr %j, align 4
  %idxprom80 = sext i32 %40 to i64
  %arrayidx81 = getelementptr inbounds %struct.redisDb, ptr %39, i64 %idxprom80
  %defrag_later = getelementptr inbounds %struct.redisDb, ptr %arrayidx81, i32 0, i32 9
  store ptr %call79, ptr %defrag_later, align 8
  %41 = load i32, ptr %slotCount, align 4
  %42 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %43 = load i32, ptr %j, align 4
  %idxprom82 = sext i32 %43 to i64
  %arrayidx83 = getelementptr inbounds %struct.redisDb, ptr %42, i64 %idxprom82
  %dict_count = getelementptr inbounds %struct.redisDb, ptr %arrayidx83, i32 0, i32 10
  store i32 %41, ptr %dict_count, align 8
  %44 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %45 = load i32, ptr %j, align 4
  %idxprom84 = sext i32 %45 to i64
  %arrayidx85 = getelementptr inbounds %struct.redisDb, ptr %44, i64 %idxprom84
  call void @initDbState(ptr noundef %arrayidx85)
  %46 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %47 = load i32, ptr %j, align 4
  %idxprom86 = sext i32 %47 to i64
  %arrayidx87 = getelementptr inbounds %struct.redisDb, ptr %46, i64 %idxprom86
  %defrag_later88 = getelementptr inbounds %struct.redisDb, ptr %arrayidx87, i32 0, i32 9
  %48 = load ptr, ptr %defrag_later88, align 8
  %free = getelementptr inbounds %struct.list, ptr %48, i32 0, i32 3
  store ptr @sdsfree, ptr %free, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %49 = load i32, ptr %j, align 4
  %inc = add nsw i32 %49, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !35

for.end:                                          ; preds = %for.cond
  %call89 = call ptr @listCreate()
  store ptr %call89, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 11), align 8
  call void @evictionPoolAlloc()
  %call90 = call ptr @dictCreate(ptr noundef @keylistDictType)
  store ptr %call90, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 357), align 8
  %call91 = call ptr @dictCreate(ptr noundef @keylistDictType)
  store ptr %call91, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 358), align 8
  %call92 = call ptr @dictCreate(ptr noundef @keylistDictType)
  store ptr %call92, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 360), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 361), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 25), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 30), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 32), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 34), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 234), align 4
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 239), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 240), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 241), align 4
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 242), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 243), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 233), align 8
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 246), align 4
  store i32 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 246, i64 1), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 247), align 4
  %call93 = call ptr @sdsempty()
  store ptr %call93, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 198), align 8
  %call94 = call i64 @time(ptr noundef null) #13
  store i64 %call94, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 229), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 230), align 8
  store i64 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 231), align 8
  store i64 -1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 232), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 221), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 222), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  call void @resetServerStats()
  %call95 = call i64 @time(ptr noundef null) #13
  store i64 %call95, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 88), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 128), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 129), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 130), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 131), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 132), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 133), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 134), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 135), align 8
  store double 0.000000e+00, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 136), align 8
  store i32 0, ptr %j96, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc103, %for.end
  %50 = load i32, ptr %j96, align 4
  %cmp98 = icmp slt i32 %50, 4
  br i1 %cmp98, label %for.body100, label %for.end105

for.body100:                                      ; preds = %for.cond97
  %51 = load i32, ptr %j96, align 4
  %idxprom101 = sext i32 %51 to i64
  %arrayidx102 = getelementptr inbounds [4 x i64], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 137), i64 0, i64 %idxprom101
  store i64 0, ptr %arrayidx102, align 8
  br label %for.inc103

for.inc103:                                       ; preds = %for.body100
  %52 = load i32, ptr %j96, align 4
  %inc104 = add nsw i32 %52, 1
  store i32 %inc104, ptr %j96, align 4
  br label %for.cond97, !llvm.loop !36

for.end105:                                       ; preds = %for.cond97
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 138), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 1), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 2), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 3), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 4), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 235), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 211), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 212), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 274), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 19), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 399, i32 1), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 399, i32 2), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 399), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 399, i32 3), align 8
  %53 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %call106 = call i64 @aeCreateTimeEvent(ptr noundef %53, i64 noundef 1, ptr noundef @serverCron, ptr noundef null, ptr noundef null)
  %cmp107 = icmp eq i64 %call106, -1
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %for.end105
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 2801, ptr noundef @.str.147)
  call void @abort() #16
  unreachable

if.end110:                                        ; preds = %for.end105
  %54 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  %55 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 41), align 8
  %call111 = call i32 @aeCreateFileEvent(ptr noundef %54, i32 noundef %55, i32 noundef 1, ptr noundef @modulePipeReadable, ptr noundef null)
  %cmp112 = icmp eq i32 %call111, -1
  br i1 %cmp112, label %if.then114, label %if.end115

if.then114:                                       ; preds = %if.end110
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 2810, ptr noundef @.str.148)
  call void @abort() #16
  unreachable

if.end115:                                        ; preds = %if.end110
  %56 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  call void @aeSetBeforeSleepProc(ptr noundef %56, ptr noundef @beforeSleep)
  %57 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  call void @aeSetAfterSleepProc(ptr noundef %57, ptr noundef @afterSleep)
  %58 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 24), align 8
  %cmp116 = icmp eq i32 %58, 32
  br i1 %cmp116, label %land.lhs.true, label %if.end127

land.lhs.true:                                    ; preds = %if.end115
  %59 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  %cmp118 = icmp eq i64 %59, 0
  br i1 %cmp118, label %if.then120, label %if.end127

if.then120:                                       ; preds = %land.lhs.true
  br label %do.body121

do.body121:                                       ; preds = %if.then120
  %60 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp122 = icmp slt i32 3, %60
  br i1 %cmp122, label %if.then124, label %if.end125

if.then124:                                       ; preds = %do.body121
  br label %do.end126

if.end125:                                        ; preds = %do.body121
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.149)
  br label %do.end126

do.end126:                                        ; preds = %if.end125, %if.then124
  store i64 3221225472, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  store i32 1792, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 316), align 8
  br label %if.end127

if.end127:                                        ; preds = %do.end126, %land.lhs.true, %if.end115
  call void @scriptingInit(i32 noundef 1)
  %call128 = call i32 @functionsInit()
  call void @slowlogInit()
  call void @latencyMonitorInit()
  %61 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 397), align 8
  call void @ACLUpdateDefaultUserPassword(ptr noundef %61)
  call void @applyWatchdogPeriod()
  %62 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 315), align 8
  %cmp129 = icmp ne i64 %62, 0
  br i1 %cmp129, label %if.then131, label %if.end132

if.then131:                                       ; preds = %if.end127
  call void @initServerClientMemUsageBuckets()
  br label %if.end132

if.end132:                                        ; preds = %if.then131, %if.end127
  ret void
}

; Function Attrs: nounwind
declare ptr @signal(i32 noundef, ptr noundef) #3

; Function Attrs: nounwind uwtable
define dso_local void @setupSignalHandlers() #0 {
entry:
  %act = alloca %struct.sigaction, align 8
  %sa_mask = getelementptr inbounds %struct.sigaction, ptr %act, i32 0, i32 1
  %call = call i32 @sigemptyset(ptr noundef %sa_mask) #13
  %sa_flags = getelementptr inbounds %struct.sigaction, ptr %act, i32 0, i32 2
  store i32 0, ptr %sa_flags, align 8
  %__sigaction_handler = getelementptr inbounds %struct.sigaction, ptr %act, i32 0, i32 0
  store ptr @sigShutdownHandler, ptr %__sigaction_handler, align 8
  %call1 = call i32 @sigaction(i32 noundef 15, ptr noundef %act, ptr noundef null) #13
  %call2 = call i32 @sigaction(i32 noundef 2, ptr noundef %act, ptr noundef null) #13
  call void @setupDebugSigHandlers()
  ret void
}

declare void @ThreadsManager_init() #2

declare void @openlog(ptr noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind willreturn memory(none)
declare i64 @pthread_self() #8

declare ptr @raxNew() #2

declare i64 @zmalloc_get_memory_size() #2

declare void @resetReplicationBuffer() #2

; Function Attrs: nounwind
declare ptr @setlocale(i32 noundef, ptr noundef) #3

declare ptr @monotonicInit() #2

declare ptr @aeCreateEventLoop(i32 noundef) #2

declare ptr @dictCreateMultiple(ptr noundef, i32 noundef) #2

declare void @evictionPoolAlloc() #2

declare i64 @aeCreateTimeEvent(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef) #2

declare void @modulePipeReadable(ptr noundef, i32 noundef, ptr noundef, i32 noundef) #2

declare void @aeSetBeforeSleepProc(ptr noundef, ptr noundef) #2

declare void @aeSetAfterSleepProc(ptr noundef, ptr noundef) #2

declare void @scriptingInit(i32 noundef) #2

declare i32 @functionsInit() #2

declare void @slowlogInit() #2

declare void @latencyMonitorInit() #2

declare void @ACLUpdateDefaultUserPassword(ptr noundef) #2

declare void @applyWatchdogPeriod() #2

; Function Attrs: nounwind uwtable
define dso_local void @initListeners() #0 {
entry:
  %conn_index = alloca i32, align 4
  %listener = alloca ptr, align 8
  %ct_tls = alloca ptr, align 8
  %listen_fds = alloca i32, align 4
  %j = alloca i32, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %call = call i32 @connectionIndexByType(ptr noundef @.str.150)
  store i32 %call, ptr %conn_index, align 4
  %1 = load i32, ptr %conn_index, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 2849, ptr noundef @.str.151, ptr noundef @.str.150)
  call void @abort() #16
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load i32, ptr %conn_index, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [8 x %struct.connListener], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 52), i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %listener, align 8
  %3 = load ptr, ptr %listener, align 8
  %bindaddr = getelementptr inbounds %struct.connListener, ptr %3, i32 0, i32 2
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 47), ptr %bindaddr, align 8
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 48), align 8
  %5 = load ptr, ptr %listener, align 8
  %bindaddr_count = getelementptr inbounds %struct.connListener, ptr %5, i32 0, i32 3
  store i32 %4, ptr %bindaddr_count, align 8
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  %7 = load ptr, ptr %listener, align 8
  %port = getelementptr inbounds %struct.connListener, ptr %7, i32 0, i32 4
  store i32 %6, ptr %port, align 4
  %call3 = call ptr @connectionByType(ptr noundef @.str.150)
  %8 = load ptr, ptr %listener, align 8
  %ct = getelementptr inbounds %struct.connListener, ptr %8, i32 0, i32 5
  store ptr %call3, ptr %ct, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end4
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 403), align 4
  %tobool5 = icmp ne i32 %10, 0
  br i1 %tobool5, label %if.then8, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.lhs.false
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 402), align 8
  %tobool7 = icmp ne i32 %11, 0
  br i1 %tobool7, label %if.then8, label %if.end25

if.then8:                                         ; preds = %lor.lhs.false6, %lor.lhs.false, %if.end4
  %call9 = call ptr @connectionTypeTls()
  store ptr %call9, ptr %ct_tls, align 8
  %12 = load ptr, ptr %ct_tls, align 8
  %tobool10 = icmp ne ptr %12, null
  br i1 %tobool10, label %if.end15, label %if.then11

if.then11:                                        ; preds = %if.then8
  br label %do.body

do.body:                                          ; preds = %if.then11
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp12 = icmp slt i32 3, %13
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %do.body
  br label %do.end

if.end14:                                         ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.152)
  br label %do.end

do.end:                                           ; preds = %if.end14, %if.then13
  call void @exit(i32 noundef 1) #16
  unreachable

if.end15:                                         ; preds = %if.then8
  %14 = load ptr, ptr %ct_tls, align 8
  %call16 = call i32 @connTypeConfigure(ptr noundef %14, ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 405), i32 noundef 1)
  %cmp17 = icmp eq i32 %call16, -1
  br i1 %cmp17, label %if.then18, label %if.end24

if.then18:                                        ; preds = %if.end15
  br label %do.body19

do.body19:                                        ; preds = %if.then18
  %15 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp20 = icmp slt i32 3, %15
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %do.body19
  br label %do.end23

if.end22:                                         ; preds = %do.body19
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.153)
  br label %do.end23

do.end23:                                         ; preds = %if.end22, %if.then21
  call void @exit(i32 noundef 1) #16
  unreachable

if.end24:                                         ; preds = %if.end15
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %lor.lhs.false6
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  %cmp26 = icmp ne i32 %16, 0
  br i1 %cmp26, label %if.then27, label %if.end39

if.then27:                                        ; preds = %if.end25
  %call28 = call i32 @connectionIndexByType(ptr noundef @.str.154)
  store i32 %call28, ptr %conn_index, align 4
  %17 = load i32, ptr %conn_index, align 4
  %cmp29 = icmp slt i32 %17, 0
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.then27
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 2872, ptr noundef @.str.151, ptr noundef @.str.154)
  call void @abort() #16
  unreachable

if.end31:                                         ; preds = %if.then27
  %18 = load i32, ptr %conn_index, align 4
  %idxprom32 = sext i32 %18 to i64
  %arrayidx33 = getelementptr inbounds [8 x %struct.connListener], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 52), i64 0, i64 %idxprom32
  store ptr %arrayidx33, ptr %listener, align 8
  %19 = load ptr, ptr %listener, align 8
  %bindaddr34 = getelementptr inbounds %struct.connListener, ptr %19, i32 0, i32 2
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 47), ptr %bindaddr34, align 8
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 48), align 8
  %21 = load ptr, ptr %listener, align 8
  %bindaddr_count35 = getelementptr inbounds %struct.connListener, ptr %21, i32 0, i32 3
  store i32 %20, ptr %bindaddr_count35, align 8
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  %23 = load ptr, ptr %listener, align 8
  %port36 = getelementptr inbounds %struct.connListener, ptr %23, i32 0, i32 4
  store i32 %22, ptr %port36, align 4
  %call37 = call ptr @connectionByType(ptr noundef @.str.154)
  %24 = load ptr, ptr %listener, align 8
  %ct38 = getelementptr inbounds %struct.connListener, ptr %24, i32 0, i32 5
  store ptr %call37, ptr %ct38, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.end31, %if.end25
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 50), align 8
  %cmp40 = icmp ne ptr %25, null
  br i1 %cmp40, label %if.then41, label %if.end52

if.then41:                                        ; preds = %if.end39
  %call42 = call i32 @connectionIndexByType(ptr noundef @.str.155)
  store i32 %call42, ptr %conn_index, align 4
  %26 = load i32, ptr %conn_index, align 4
  %cmp43 = icmp slt i32 %26, 0
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.then41
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 2882, ptr noundef @.str.151, ptr noundef @.str.155)
  call void @abort() #16
  unreachable

if.end45:                                         ; preds = %if.then41
  %27 = load i32, ptr %conn_index, align 4
  %idxprom46 = sext i32 %27 to i64
  %arrayidx47 = getelementptr inbounds [8 x %struct.connListener], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 52), i64 0, i64 %idxprom46
  store ptr %arrayidx47, ptr %listener, align 8
  %28 = load ptr, ptr %listener, align 8
  %bindaddr48 = getelementptr inbounds %struct.connListener, ptr %28, i32 0, i32 2
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 50), ptr %bindaddr48, align 8
  %29 = load ptr, ptr %listener, align 8
  %bindaddr_count49 = getelementptr inbounds %struct.connListener, ptr %29, i32 0, i32 3
  store i32 1, ptr %bindaddr_count49, align 8
  %call50 = call ptr @connectionByType(ptr noundef @.str.155)
  %30 = load ptr, ptr %listener, align 8
  %ct51 = getelementptr inbounds %struct.connListener, ptr %30, i32 0, i32 5
  store ptr %call50, ptr %ct51, align 8
  %31 = load ptr, ptr %listener, align 8
  %priv = getelementptr inbounds %struct.connListener, ptr %31, i32 0, i32 6
  store ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 51), ptr %priv, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.end45, %if.end39
  store i32 0, ptr %listen_fds, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end52
  %32 = load i32, ptr %j, align 4
  %cmp53 = icmp slt i32 %32, 8
  br i1 %cmp53, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %33 = load i32, ptr %j, align 4
  %idxprom54 = sext i32 %33 to i64
  %arrayidx55 = getelementptr inbounds [8 x %struct.connListener], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 52), i64 0, i64 %idxprom54
  store ptr %arrayidx55, ptr %listener, align 8
  %34 = load ptr, ptr %listener, align 8
  %ct56 = getelementptr inbounds %struct.connListener, ptr %34, i32 0, i32 5
  %35 = load ptr, ptr %ct56, align 8
  %cmp57 = icmp eq ptr %35, null
  br i1 %cmp57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %for.body
  br label %for.inc

if.end59:                                         ; preds = %for.body
  %36 = load ptr, ptr %listener, align 8
  %call60 = call i32 @connListen(ptr noundef %36)
  %cmp61 = icmp eq i32 %call60, -1
  br i1 %cmp61, label %if.then62, label %if.end71

if.then62:                                        ; preds = %if.end59
  br label %do.body63

do.body63:                                        ; preds = %if.then62
  %37 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp64 = icmp slt i32 3, %37
  br i1 %cmp64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %do.body63
  br label %do.end70

if.end66:                                         ; preds = %do.body63
  %38 = load ptr, ptr %listener, align 8
  %port67 = getelementptr inbounds %struct.connListener, ptr %38, i32 0, i32 4
  %39 = load i32, ptr %port67, align 4
  %40 = load ptr, ptr %listener, align 8
  %ct68 = getelementptr inbounds %struct.connListener, ptr %40, i32 0, i32 5
  %41 = load ptr, ptr %ct68, align 8
  %get_type = getelementptr inbounds %struct.ConnectionType, ptr %41, i32 0, i32 0
  %42 = load ptr, ptr %get_type, align 8
  %call69 = call ptr %42(ptr noundef null)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.156, i32 noundef %39, ptr noundef %call69)
  br label %do.end70

do.end70:                                         ; preds = %if.end66, %if.then65
  call void @exit(i32 noundef 1) #16
  unreachable

if.end71:                                         ; preds = %if.end59
  %43 = load ptr, ptr %listener, align 8
  %44 = load ptr, ptr %listener, align 8
  %ct72 = getelementptr inbounds %struct.connListener, ptr %44, i32 0, i32 5
  %45 = load ptr, ptr %ct72, align 8
  %call73 = call ptr @connAcceptHandler(ptr noundef %45)
  %call74 = call i32 @createSocketAcceptHandler(ptr noundef %43, ptr noundef %call73)
  %cmp75 = icmp ne i32 %call74, 0
  br i1 %cmp75, label %if.then76, label %if.end80

if.then76:                                        ; preds = %if.end71
  %46 = load ptr, ptr %listener, align 8
  %ct77 = getelementptr inbounds %struct.connListener, ptr %46, i32 0, i32 5
  %47 = load ptr, ptr %ct77, align 8
  %get_type78 = getelementptr inbounds %struct.ConnectionType, ptr %47, i32 0, i32 0
  %48 = load ptr, ptr %get_type78, align 8
  %call79 = call ptr %48(ptr noundef null)
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 2903, ptr noundef @.str.157, ptr noundef %call79)
  call void @abort() #16
  unreachable

if.end80:                                         ; preds = %if.end71
  %49 = load ptr, ptr %listener, align 8
  %count = getelementptr inbounds %struct.connListener, ptr %49, i32 0, i32 1
  %50 = load i32, ptr %count, align 8
  %51 = load i32, ptr %listen_fds, align 4
  %add = add nsw i32 %51, %50
  store i32 %add, ptr %listen_fds, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end80, %if.then58
  %52 = load i32, ptr %j, align 4
  %inc = add nsw i32 %52, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !37

for.end:                                          ; preds = %for.cond
  %53 = load i32, ptr %listen_fds, align 4
  %cmp81 = icmp eq i32 %53, 0
  br i1 %cmp81, label %if.then82, label %if.end88

if.then82:                                        ; preds = %for.end
  br label %do.body83

do.body83:                                        ; preds = %if.then82
  %54 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp84 = icmp slt i32 3, %54
  br i1 %cmp84, label %if.then85, label %if.end86

if.then85:                                        ; preds = %do.body83
  br label %do.end87

if.end86:                                         ; preds = %do.body83
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.158)
  br label %do.end87

do.end87:                                         ; preds = %if.end86, %if.then85
  call void @exit(i32 noundef 1) #16
  unreachable

if.end88:                                         ; preds = %for.end
  ret void
}

declare i32 @connectionIndexByType(ptr noundef) #2

declare ptr @connectionByType(ptr noundef) #2

declare ptr @connectionTypeTls() #2

; Function Attrs: nounwind uwtable
define internal i32 @connTypeConfigure(ptr noundef %ct, ptr noundef %priv, i32 noundef %reconfigure) #0 {
entry:
  %ct.addr = alloca ptr, align 8
  %priv.addr = alloca ptr, align 8
  %reconfigure.addr = alloca i32, align 4
  store ptr %ct, ptr %ct.addr, align 8
  store ptr %priv, ptr %priv.addr, align 8
  store i32 %reconfigure, ptr %reconfigure.addr, align 4
  %0 = load ptr, ptr %ct.addr, align 8
  %configure = getelementptr inbounds %struct.ConnectionType, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %configure, align 8
  %2 = load ptr, ptr %priv.addr, align 8
  %3 = load i32, ptr %reconfigure.addr, align 4
  %call = call i32 %1(ptr noundef %2, i32 noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @connListen(ptr noundef %listener) #0 {
entry:
  %listener.addr = alloca ptr, align 8
  store ptr %listener, ptr %listener.addr, align 8
  %0 = load ptr, ptr %listener.addr, align 8
  %ct = getelementptr inbounds %struct.connListener, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %ct, align 8
  %listen = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 8
  %2 = load ptr, ptr %listen, align 8
  %3 = load ptr, ptr %listener.addr, align 8
  %call = call i32 %2(ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal ptr @connAcceptHandler(ptr noundef %ct) #0 {
entry:
  %retval = alloca ptr, align 8
  %ct.addr = alloca ptr, align 8
  store ptr %ct, ptr %ct.addr, align 8
  %0 = load ptr, ptr %ct.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ct.addr, align 8
  %accept_handler = getelementptr inbounds %struct.ConnectionType, ptr %1, i32 0, i32 5
  %2 = load ptr, ptr %accept_handler, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define dso_local void @InitServerLast() #0 {
entry:
  call void @bioInit()
  call void @initThreadedIO()
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 165), align 4
  call void @set_jemalloc_bg_thread(i32 noundef %0)
  %call = call i64 @zmalloc_used_memory()
  store i64 %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 28), align 8
  ret void
}

declare void @bioInit() #2

declare void @initThreadedIO() #2

declare void @set_jemalloc_bg_thread(i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @populateCommandLegacyRangeSpec(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %firstkey = alloca i32, align 4
  %lastkey = alloca i32, align 4
  %prev_lastkey = alloca i32, align 4
  %i = alloca i32, align 4
  %lastkey_abs_index = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %legacy_range_key_spec = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 29
  call void @llvm.memset.p0.i64(ptr align 8 %legacy_range_key_spec, i8 0, i64 56, i1 false)
  %1 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 14
  %2 = load i64, ptr %flags, align 8
  %and = and i64 %2, 2097152
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %c.addr, align 8
  %flags1 = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 14
  %4 = load i64, ptr %flags1, align 8
  %or = or i64 %4, 33554432
  store i64 %or, ptr %flags1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %c.addr, align 8
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 17
  %6 = load i32, ptr %key_specs_num, align 8
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %return

if.end3:                                          ; preds = %if.end
  %7 = load ptr, ptr %c.addr, align 8
  %key_specs_num4 = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 17
  %8 = load i32, ptr %key_specs_num4, align 8
  %cmp5 = icmp eq i32 %8, 1
  br i1 %cmp5, label %land.lhs.true, label %if.end24

land.lhs.true:                                    ; preds = %if.end3
  %9 = load ptr, ptr %c.addr, align 8
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %9, i32 0, i32 16
  %10 = load ptr, ptr %key_specs, align 8
  %arrayidx = getelementptr inbounds %struct.keySpec, ptr %10, i64 0
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx, i32 0, i32 2
  %11 = load i32, ptr %begin_search_type, align 8
  %cmp6 = icmp eq i32 %11, 2
  br i1 %cmp6, label %land.lhs.true7, label %if.end24

land.lhs.true7:                                   ; preds = %land.lhs.true
  %12 = load ptr, ptr %c.addr, align 8
  %key_specs8 = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 16
  %13 = load ptr, ptr %key_specs8, align 8
  %arrayidx9 = getelementptr inbounds %struct.keySpec, ptr %13, i64 0
  %find_keys_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx9, i32 0, i32 4
  %14 = load i32, ptr %find_keys_type, align 8
  %cmp10 = icmp eq i32 %14, 2
  br i1 %cmp10, label %if.then11, label %if.end24

if.then11:                                        ; preds = %land.lhs.true7
  %15 = load ptr, ptr %c.addr, align 8
  %legacy_range_key_spec12 = getelementptr inbounds %struct.redisCommand, ptr %15, i32 0, i32 29
  %16 = load ptr, ptr %c.addr, align 8
  %key_specs13 = getelementptr inbounds %struct.redisCommand, ptr %16, i32 0, i32 16
  %17 = load ptr, ptr %key_specs13, align 8
  %arrayidx14 = getelementptr inbounds %struct.keySpec, ptr %17, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %legacy_range_key_spec12, ptr align 8 %arrayidx14, i64 56, i1 false)
  %18 = load ptr, ptr %c.addr, align 8
  %key_specs15 = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 16
  %19 = load ptr, ptr %key_specs15, align 8
  %arrayidx16 = getelementptr inbounds %struct.keySpec, ptr %19, i64 0
  %flags17 = getelementptr inbounds %struct.keySpec, ptr %arrayidx16, i32 0, i32 1
  %20 = load i64, ptr %flags17, align 8
  %and18 = and i64 %20, 512
  %tobool19 = icmp ne i64 %and18, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.then11
  %21 = load ptr, ptr %c.addr, align 8
  %flags21 = getelementptr inbounds %struct.redisCommand, ptr %21, i32 0, i32 14
  %22 = load i64, ptr %flags21, align 8
  %or22 = or i64 %22, 33554432
  store i64 %or22, ptr %flags21, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then20, %if.then11
  br label %return

if.end24:                                         ; preds = %land.lhs.true7, %land.lhs.true, %if.end3
  store i32 2147483647, ptr %firstkey, align 4
  store i32 0, ptr %lastkey, align 4
  store i32 0, ptr %prev_lastkey, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end24
  %23 = load i32, ptr %i, align 4
  %24 = load ptr, ptr %c.addr, align 8
  %key_specs_num25 = getelementptr inbounds %struct.redisCommand, ptr %24, i32 0, i32 17
  %25 = load i32, ptr %key_specs_num25, align 8
  %cmp26 = icmp slt i32 %23, %25
  br i1 %cmp26, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %26 = load ptr, ptr %c.addr, align 8
  %key_specs27 = getelementptr inbounds %struct.redisCommand, ptr %26, i32 0, i32 16
  %27 = load ptr, ptr %key_specs27, align 8
  %28 = load i32, ptr %i, align 4
  %idxprom = sext i32 %28 to i64
  %arrayidx28 = getelementptr inbounds %struct.keySpec, ptr %27, i64 %idxprom
  %begin_search_type29 = getelementptr inbounds %struct.keySpec, ptr %arrayidx28, i32 0, i32 2
  %29 = load i32, ptr %begin_search_type29, align 8
  %cmp30 = icmp ne i32 %29, 2
  br i1 %cmp30, label %if.then36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %30 = load ptr, ptr %c.addr, align 8
  %key_specs31 = getelementptr inbounds %struct.redisCommand, ptr %30, i32 0, i32 16
  %31 = load ptr, ptr %key_specs31, align 8
  %32 = load i32, ptr %i, align 4
  %idxprom32 = sext i32 %32 to i64
  %arrayidx33 = getelementptr inbounds %struct.keySpec, ptr %31, i64 %idxprom32
  %find_keys_type34 = getelementptr inbounds %struct.keySpec, ptr %arrayidx33, i32 0, i32 4
  %33 = load i32, ptr %find_keys_type34, align 8
  %cmp35 = icmp ne i32 %33, 2
  br i1 %cmp35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %lor.lhs.false, %for.body
  %34 = load ptr, ptr %c.addr, align 8
  %flags37 = getelementptr inbounds %struct.redisCommand, ptr %34, i32 0, i32 14
  %35 = load i64, ptr %flags37, align 8
  %or38 = or i64 %35, 33554432
  store i64 %or38, ptr %flags37, align 8
  br label %for.inc

if.end39:                                         ; preds = %lor.lhs.false
  %36 = load ptr, ptr %c.addr, align 8
  %key_specs40 = getelementptr inbounds %struct.redisCommand, ptr %36, i32 0, i32 16
  %37 = load ptr, ptr %key_specs40, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom41 = sext i32 %38 to i64
  %arrayidx42 = getelementptr inbounds %struct.keySpec, ptr %37, i64 %idxprom41
  %fk = getelementptr inbounds %struct.keySpec, ptr %arrayidx42, i32 0, i32 5
  %keystep = getelementptr inbounds %struct.anon.3, ptr %fk, i32 0, i32 1
  %39 = load i32, ptr %keystep, align 4
  %cmp43 = icmp ne i32 %39, 1
  br i1 %cmp43, label %if.then51, label %lor.lhs.false44

lor.lhs.false44:                                  ; preds = %if.end39
  %40 = load i32, ptr %prev_lastkey, align 4
  %tobool45 = icmp ne i32 %40, 0
  br i1 %tobool45, label %land.lhs.true46, label %if.end54

land.lhs.true46:                                  ; preds = %lor.lhs.false44
  %41 = load i32, ptr %prev_lastkey, align 4
  %42 = load ptr, ptr %c.addr, align 8
  %key_specs47 = getelementptr inbounds %struct.redisCommand, ptr %42, i32 0, i32 16
  %43 = load ptr, ptr %key_specs47, align 8
  %44 = load i32, ptr %i, align 4
  %idxprom48 = sext i32 %44 to i64
  %arrayidx49 = getelementptr inbounds %struct.keySpec, ptr %43, i64 %idxprom48
  %bs = getelementptr inbounds %struct.keySpec, ptr %arrayidx49, i32 0, i32 3
  %pos = getelementptr inbounds %struct.anon.0, ptr %bs, i32 0, i32 0
  %45 = load i32, ptr %pos, align 8
  %sub = sub nsw i32 %45, 1
  %cmp50 = icmp ne i32 %41, %sub
  br i1 %cmp50, label %if.then51, label %if.end54

if.then51:                                        ; preds = %land.lhs.true46, %if.end39
  %46 = load ptr, ptr %c.addr, align 8
  %flags52 = getelementptr inbounds %struct.redisCommand, ptr %46, i32 0, i32 14
  %47 = load i64, ptr %flags52, align 8
  %or53 = or i64 %47, 33554432
  store i64 %or53, ptr %flags52, align 8
  br label %for.inc

if.end54:                                         ; preds = %land.lhs.true46, %lor.lhs.false44
  %48 = load ptr, ptr %c.addr, align 8
  %key_specs55 = getelementptr inbounds %struct.redisCommand, ptr %48, i32 0, i32 16
  %49 = load ptr, ptr %key_specs55, align 8
  %50 = load i32, ptr %i, align 4
  %idxprom56 = sext i32 %50 to i64
  %arrayidx57 = getelementptr inbounds %struct.keySpec, ptr %49, i64 %idxprom56
  %flags58 = getelementptr inbounds %struct.keySpec, ptr %arrayidx57, i32 0, i32 1
  %51 = load i64, ptr %flags58, align 8
  %and59 = and i64 %51, 512
  %tobool60 = icmp ne i64 %and59, 0
  br i1 %tobool60, label %if.then61, label %if.end64

if.then61:                                        ; preds = %if.end54
  %52 = load ptr, ptr %c.addr, align 8
  %flags62 = getelementptr inbounds %struct.redisCommand, ptr %52, i32 0, i32 14
  %53 = load i64, ptr %flags62, align 8
  %or63 = or i64 %53, 33554432
  store i64 %or63, ptr %flags62, align 8
  br label %if.end64

if.end64:                                         ; preds = %if.then61, %if.end54
  %54 = load i32, ptr %firstkey, align 4
  %55 = load ptr, ptr %c.addr, align 8
  %key_specs65 = getelementptr inbounds %struct.redisCommand, ptr %55, i32 0, i32 16
  %56 = load ptr, ptr %key_specs65, align 8
  %57 = load i32, ptr %i, align 4
  %idxprom66 = sext i32 %57 to i64
  %arrayidx67 = getelementptr inbounds %struct.keySpec, ptr %56, i64 %idxprom66
  %bs68 = getelementptr inbounds %struct.keySpec, ptr %arrayidx67, i32 0, i32 3
  %pos69 = getelementptr inbounds %struct.anon.0, ptr %bs68, i32 0, i32 0
  %58 = load i32, ptr %pos69, align 8
  %cmp70 = icmp slt i32 %54, %58
  br i1 %cmp70, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end64
  %59 = load i32, ptr %firstkey, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end64
  %60 = load ptr, ptr %c.addr, align 8
  %key_specs71 = getelementptr inbounds %struct.redisCommand, ptr %60, i32 0, i32 16
  %61 = load ptr, ptr %key_specs71, align 8
  %62 = load i32, ptr %i, align 4
  %idxprom72 = sext i32 %62 to i64
  %arrayidx73 = getelementptr inbounds %struct.keySpec, ptr %61, i64 %idxprom72
  %bs74 = getelementptr inbounds %struct.keySpec, ptr %arrayidx73, i32 0, i32 3
  %pos75 = getelementptr inbounds %struct.anon.0, ptr %bs74, i32 0, i32 0
  %63 = load i32, ptr %pos75, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %59, %cond.true ], [ %63, %cond.false ]
  store i32 %cond, ptr %firstkey, align 4
  %64 = load ptr, ptr %c.addr, align 8
  %key_specs76 = getelementptr inbounds %struct.redisCommand, ptr %64, i32 0, i32 16
  %65 = load ptr, ptr %key_specs76, align 8
  %66 = load i32, ptr %i, align 4
  %idxprom77 = sext i32 %66 to i64
  %arrayidx78 = getelementptr inbounds %struct.keySpec, ptr %65, i64 %idxprom77
  %fk79 = getelementptr inbounds %struct.keySpec, ptr %arrayidx78, i32 0, i32 5
  %lastkey80 = getelementptr inbounds %struct.anon.3, ptr %fk79, i32 0, i32 0
  %67 = load i32, ptr %lastkey80, align 4
  store i32 %67, ptr %lastkey_abs_index, align 4
  %68 = load i32, ptr %lastkey_abs_index, align 4
  %cmp81 = icmp sge i32 %68, 0
  br i1 %cmp81, label %if.then82, label %if.end88

if.then82:                                        ; preds = %cond.end
  %69 = load ptr, ptr %c.addr, align 8
  %key_specs83 = getelementptr inbounds %struct.redisCommand, ptr %69, i32 0, i32 16
  %70 = load ptr, ptr %key_specs83, align 8
  %71 = load i32, ptr %i, align 4
  %idxprom84 = sext i32 %71 to i64
  %arrayidx85 = getelementptr inbounds %struct.keySpec, ptr %70, i64 %idxprom84
  %bs86 = getelementptr inbounds %struct.keySpec, ptr %arrayidx85, i32 0, i32 3
  %pos87 = getelementptr inbounds %struct.anon.0, ptr %bs86, i32 0, i32 0
  %72 = load i32, ptr %pos87, align 8
  %73 = load i32, ptr %lastkey_abs_index, align 4
  %add = add nsw i32 %73, %72
  store i32 %add, ptr %lastkey_abs_index, align 4
  br label %if.end88

if.end88:                                         ; preds = %if.then82, %cond.end
  %74 = load i32, ptr %lastkey, align 4
  %75 = load i32, ptr %lastkey_abs_index, align 4
  %cmp89 = icmp ugt i32 %74, %75
  br i1 %cmp89, label %cond.true90, label %cond.false91

cond.true90:                                      ; preds = %if.end88
  %76 = load i32, ptr %lastkey, align 4
  br label %cond.end92

cond.false91:                                     ; preds = %if.end88
  %77 = load i32, ptr %lastkey_abs_index, align 4
  br label %cond.end92

cond.end92:                                       ; preds = %cond.false91, %cond.true90
  %cond93 = phi i32 [ %76, %cond.true90 ], [ %77, %cond.false91 ]
  store i32 %cond93, ptr %lastkey, align 4
  %78 = load i32, ptr %lastkey, align 4
  store i32 %78, ptr %prev_lastkey, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end92, %if.then51, %if.then36
  %79 = load i32, ptr %i, align 4
  %inc = add nsw i32 %79, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !38

for.end:                                          ; preds = %for.cond
  %80 = load i32, ptr %firstkey, align 4
  %cmp94 = icmp eq i32 %80, 2147483647
  br i1 %cmp94, label %if.then95, label %if.end98

if.then95:                                        ; preds = %for.end
  %81 = load ptr, ptr %c.addr, align 8
  %flags96 = getelementptr inbounds %struct.redisCommand, ptr %81, i32 0, i32 14
  %82 = load i64, ptr %flags96, align 8
  %or97 = or i64 %82, 33554432
  store i64 %or97, ptr %flags96, align 8
  br label %return

if.end98:                                         ; preds = %for.end
  %83 = load i32, ptr %firstkey, align 4
  %cmp99 = icmp ne i32 %83, 0
  %lnot = xor i1 %cmp99, true
  %lnot100 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot100 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool101 = icmp ne i64 %conv, 0
  br i1 %tobool101, label %cond.true102, label %cond.false103

cond.true102:                                     ; preds = %if.end98
  br label %cond.end104

cond.false103:                                    ; preds = %if.end98
  call void @_serverAssert(ptr noundef @.str.159, ptr noundef @.str.9, i32 noundef 3020)
  call void @abort() #16
  unreachable

84:                                               ; No predecessors!
  br label %cond.end104

cond.end104:                                      ; preds = %84, %cond.true102
  %85 = load i32, ptr %lastkey, align 4
  %cmp105 = icmp ne i32 %85, 0
  %lnot107 = xor i1 %cmp105, true
  %lnot109 = xor i1 %lnot107, true
  %lnot.ext110 = zext i1 %lnot109 to i32
  %conv111 = sext i32 %lnot.ext110 to i64
  %tobool112 = icmp ne i64 %conv111, 0
  br i1 %tobool112, label %cond.true113, label %cond.false114

cond.true113:                                     ; preds = %cond.end104
  br label %cond.end115

cond.false114:                                    ; preds = %cond.end104
  call void @_serverAssert(ptr noundef @.str.160, ptr noundef @.str.9, i32 noundef 3021)
  call void @abort() #16
  unreachable

86:                                               ; No predecessors!
  br label %cond.end115

cond.end115:                                      ; preds = %86, %cond.true113
  %87 = load ptr, ptr %c.addr, align 8
  %legacy_range_key_spec116 = getelementptr inbounds %struct.redisCommand, ptr %87, i32 0, i32 29
  %begin_search_type117 = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec116, i32 0, i32 2
  store i32 2, ptr %begin_search_type117, align 8
  %88 = load i32, ptr %firstkey, align 4
  %89 = load ptr, ptr %c.addr, align 8
  %legacy_range_key_spec118 = getelementptr inbounds %struct.redisCommand, ptr %89, i32 0, i32 29
  %bs119 = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec118, i32 0, i32 3
  %pos120 = getelementptr inbounds %struct.anon.0, ptr %bs119, i32 0, i32 0
  store i32 %88, ptr %pos120, align 8
  %90 = load ptr, ptr %c.addr, align 8
  %legacy_range_key_spec121 = getelementptr inbounds %struct.redisCommand, ptr %90, i32 0, i32 29
  %find_keys_type122 = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec121, i32 0, i32 4
  store i32 2, ptr %find_keys_type122, align 8
  %91 = load i32, ptr %lastkey, align 4
  %cmp123 = icmp slt i32 %91, 0
  br i1 %cmp123, label %cond.true125, label %cond.false126

cond.true125:                                     ; preds = %cond.end115
  %92 = load i32, ptr %lastkey, align 4
  br label %cond.end128

cond.false126:                                    ; preds = %cond.end115
  %93 = load i32, ptr %lastkey, align 4
  %94 = load i32, ptr %firstkey, align 4
  %sub127 = sub nsw i32 %93, %94
  br label %cond.end128

cond.end128:                                      ; preds = %cond.false126, %cond.true125
  %cond129 = phi i32 [ %92, %cond.true125 ], [ %sub127, %cond.false126 ]
  %95 = load ptr, ptr %c.addr, align 8
  %legacy_range_key_spec130 = getelementptr inbounds %struct.redisCommand, ptr %95, i32 0, i32 29
  %fk131 = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec130, i32 0, i32 5
  %lastkey132 = getelementptr inbounds %struct.anon.3, ptr %fk131, i32 0, i32 0
  store i32 %cond129, ptr %lastkey132, align 4
  %96 = load ptr, ptr %c.addr, align 8
  %legacy_range_key_spec133 = getelementptr inbounds %struct.redisCommand, ptr %96, i32 0, i32 29
  %fk134 = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec133, i32 0, i32 5
  %keystep135 = getelementptr inbounds %struct.anon.3, ptr %fk134, i32 0, i32 1
  store i32 1, ptr %keystep135, align 4
  %97 = load ptr, ptr %c.addr, align 8
  %legacy_range_key_spec136 = getelementptr inbounds %struct.redisCommand, ptr %97, i32 0, i32 29
  %fk137 = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec136, i32 0, i32 5
  %limit = getelementptr inbounds %struct.anon.3, ptr %fk137, i32 0, i32 2
  store i32 0, ptr %limit, align 4
  br label %return

return:                                           ; preds = %cond.end128, %if.then95, %if.end23, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @catSubCommandFullname(ptr noundef %parent_name, ptr noundef %sub_name) #0 {
entry:
  %parent_name.addr = alloca ptr, align 8
  %sub_name.addr = alloca ptr, align 8
  store ptr %parent_name, ptr %parent_name.addr, align 8
  store ptr %sub_name, ptr %sub_name.addr, align 8
  %call = call ptr @sdsempty()
  %0 = load ptr, ptr %parent_name.addr, align 8
  %1 = load ptr, ptr %sub_name.addr, align 8
  %call1 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call, ptr noundef @.str.161, ptr noundef %0, ptr noundef %1)
  ret ptr %call1
}

declare ptr @sdscatfmt(ptr noundef, ptr noundef, ...) #2

; Function Attrs: nounwind uwtable
define dso_local void @commandAddSubcommand(ptr noundef %parent, ptr noundef %subcommand, ptr noundef %declared_name) #0 {
entry:
  %parent.addr = alloca ptr, align 8
  %subcommand.addr = alloca ptr, align 8
  %declared_name.addr = alloca ptr, align 8
  store ptr %parent, ptr %parent.addr, align 8
  store ptr %subcommand, ptr %subcommand.addr, align 8
  store ptr %declared_name, ptr %declared_name.addr, align 8
  %0 = load ptr, ptr %parent.addr, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 30
  %1 = load ptr, ptr %subcommands_dict, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call ptr @dictCreate(ptr noundef @commandTableDictType)
  %2 = load ptr, ptr %parent.addr, align 8
  %subcommands_dict1 = getelementptr inbounds %struct.redisCommand, ptr %2, i32 0, i32 30
  store ptr %call, ptr %subcommands_dict1, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %parent.addr, align 8
  %4 = load ptr, ptr %subcommand.addr, align 8
  %parent2 = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 31
  store ptr %3, ptr %parent2, align 8
  %5 = load ptr, ptr %subcommand.addr, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 27
  %6 = load ptr, ptr %fullname, align 8
  %call3 = call i64 @ACLGetCommandID(ptr noundef %6)
  %conv = trunc i64 %call3 to i32
  %7 = load ptr, ptr %subcommand.addr, align 8
  %id = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 26
  store i32 %conv, ptr %id, align 8
  %8 = load ptr, ptr %parent.addr, align 8
  %subcommands_dict4 = getelementptr inbounds %struct.redisCommand, ptr %8, i32 0, i32 30
  %9 = load ptr, ptr %subcommands_dict4, align 8
  %10 = load ptr, ptr %declared_name.addr, align 8
  %call5 = call ptr @sdsnew(ptr noundef %10)
  %11 = load ptr, ptr %subcommand.addr, align 8
  %call6 = call i32 @dictAdd(ptr noundef %9, ptr noundef %call5, ptr noundef %11)
  %cmp = icmp eq i32 %call6, 0
  %lnot = xor i1 %cmp, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv9 = sext i32 %lnot.ext to i64
  %tobool10 = icmp ne i64 %conv9, 0
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  call void @_serverAssert(ptr noundef @.str.162, ptr noundef @.str.9, i32 noundef 3042)
  call void @abort() #16
  unreachable

12:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %12, %cond.true
  ret void
}

declare i64 @ACLGetCommandID(ptr noundef) #2

declare i32 @dictAdd(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @setImplicitACLCategories(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 14
  %1 = load i64, ptr %flags, align 8
  %and = and i64 %1, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %acl_categories = getelementptr inbounds %struct.redisCommand, ptr %2, i32 0, i32 15
  %3 = load i64, ptr %acl_categories, align 8
  %or = or i64 %3, 4
  store i64 %or, ptr %acl_categories, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load ptr, ptr %c.addr, align 8
  %flags1 = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 14
  %5 = load i64, ptr %flags1, align 8
  %and2 = and i64 %5, 2
  %tobool3 = icmp ne i64 %and2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %if.end
  %6 = load ptr, ptr %c.addr, align 8
  %acl_categories4 = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 15
  %7 = load i64, ptr %acl_categories4, align 8
  %and5 = and i64 %7, 1048576
  %tobool6 = icmp ne i64 %and5, 0
  br i1 %tobool6, label %if.end10, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  %8 = load ptr, ptr %c.addr, align 8
  %acl_categories8 = getelementptr inbounds %struct.redisCommand, ptr %8, i32 0, i32 15
  %9 = load i64, ptr %acl_categories8, align 8
  %or9 = or i64 %9, 2
  store i64 %or9, ptr %acl_categories8, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %land.lhs.true, %if.end
  %10 = load ptr, ptr %c.addr, align 8
  %flags11 = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 14
  %11 = load i64, ptr %flags11, align 8
  %and12 = and i64 %11, 16
  %tobool13 = icmp ne i64 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end10
  %12 = load ptr, ptr %c.addr, align 8
  %acl_categories15 = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 15
  %13 = load i64, ptr %acl_categories15, align 8
  %or16 = or i64 %13, 139264
  store i64 %or16, ptr %acl_categories15, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %if.end10
  %14 = load ptr, ptr %c.addr, align 8
  %flags18 = getelementptr inbounds %struct.redisCommand, ptr %14, i32 0, i32 14
  %15 = load i64, ptr %flags18, align 8
  %and19 = and i64 %15, 32
  %tobool20 = icmp ne i64 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end17
  %16 = load ptr, ptr %c.addr, align 8
  %acl_categories22 = getelementptr inbounds %struct.redisCommand, ptr %16, i32 0, i32 15
  %17 = load i64, ptr %acl_categories22, align 8
  %or23 = or i64 %17, 4096
  store i64 %or23, ptr %acl_categories22, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end17
  %18 = load ptr, ptr %c.addr, align 8
  %flags25 = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 14
  %19 = load i64, ptr %flags25, align 8
  %and26 = and i64 %19, 16384
  %tobool27 = icmp ne i64 %and26, 0
  br i1 %tobool27, label %if.then28, label %if.end31

if.then28:                                        ; preds = %if.end24
  %20 = load ptr, ptr %c.addr, align 8
  %acl_categories29 = getelementptr inbounds %struct.redisCommand, ptr %20, i32 0, i32 15
  %21 = load i64, ptr %acl_categories29, align 8
  %or30 = or i64 %21, 16384
  store i64 %or30, ptr %acl_categories29, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then28, %if.end24
  %22 = load ptr, ptr %c.addr, align 8
  %flags32 = getelementptr inbounds %struct.redisCommand, ptr %22, i32 0, i32 14
  %23 = load i64, ptr %flags32, align 8
  %and33 = and i64 %23, 256
  %tobool34 = icmp ne i64 %and33, 0
  br i1 %tobool34, label %if.then35, label %if.end38

if.then35:                                        ; preds = %if.end31
  %24 = load ptr, ptr %c.addr, align 8
  %acl_categories36 = getelementptr inbounds %struct.redisCommand, ptr %24, i32 0, i32 15
  %25 = load i64, ptr %acl_categories36, align 8
  %or37 = or i64 %25, 65536
  store i64 %or37, ptr %acl_categories36, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.then35, %if.end31
  %26 = load ptr, ptr %c.addr, align 8
  %acl_categories39 = getelementptr inbounds %struct.redisCommand, ptr %26, i32 0, i32 15
  %27 = load i64, ptr %acl_categories39, align 8
  %and40 = and i64 %27, 16384
  %tobool41 = icmp ne i64 %and40, 0
  br i1 %tobool41, label %if.end45, label %if.then42

if.then42:                                        ; preds = %if.end38
  %28 = load ptr, ptr %c.addr, align 8
  %acl_categories43 = getelementptr inbounds %struct.redisCommand, ptr %28, i32 0, i32 15
  %29 = load i64, ptr %acl_categories43, align 8
  %or44 = or i64 %29, 32768
  store i64 %or44, ptr %acl_categories43, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then42, %if.end38
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @populateCommandStructure(ptr noundef %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %sub = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 14
  %1 = load i64, ptr %flags, align 8
  %and = and i64 %1, 131072
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load ptr, ptr %c.addr, align 8
  %flags2 = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 14
  %4 = load i64, ptr %flags2, align 8
  %and3 = and i64 %4, 262144
  %tobool4 = icmp ne i64 %and3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end8

land.lhs.true5:                                   ; preds = %if.end
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool6 = icmp ne i32 %5, 0
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %land.lhs.true5
  store i32 -1, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %land.lhs.true5, %if.end
  %6 = load ptr, ptr %c.addr, align 8
  call void @setImplicitACLCategories(ptr noundef %6)
  %7 = load ptr, ptr %c.addr, align 8
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 28
  store ptr null, ptr %latency_histogram, align 8
  %8 = load ptr, ptr %c.addr, align 8
  call void @populateCommandLegacyRangeSpec(ptr noundef %8)
  %9 = load ptr, ptr %c.addr, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %9, i32 0, i32 27
  %10 = load ptr, ptr %fullname, align 8
  %call = call i64 @ACLGetCommandID(ptr noundef %10)
  %conv = trunc i64 %call to i32
  %11 = load ptr, ptr %c.addr, align 8
  %id = getelementptr inbounds %struct.redisCommand, ptr %11, i32 0, i32 26
  store i32 %conv, ptr %id, align 8
  %12 = load ptr, ptr %c.addr, align 8
  %subcommands = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 20
  %13 = load ptr, ptr %subcommands, align 8
  %tobool9 = icmp ne ptr %13, null
  br i1 %tobool9, label %if.then10, label %if.end23

if.then10:                                        ; preds = %if.end8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then10
  %14 = load ptr, ptr %c.addr, align 8
  %subcommands11 = getelementptr inbounds %struct.redisCommand, ptr %14, i32 0, i32 20
  %15 = load ptr, ptr %subcommands11, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr inbounds %struct.redisCommand, ptr %15, i64 %idxprom
  %declared_name = getelementptr inbounds %struct.redisCommand, ptr %arrayidx, i32 0, i32 0
  %17 = load ptr, ptr %declared_name, align 8
  %tobool12 = icmp ne ptr %17, null
  br i1 %tobool12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %c.addr, align 8
  %subcommands13 = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 20
  %19 = load ptr, ptr %subcommands13, align 8
  %20 = load i32, ptr %j, align 4
  %idx.ext = sext i32 %20 to i64
  %add.ptr = getelementptr inbounds %struct.redisCommand, ptr %19, i64 %idx.ext
  store ptr %add.ptr, ptr %sub, align 8
  %21 = load ptr, ptr %c.addr, align 8
  %declared_name14 = getelementptr inbounds %struct.redisCommand, ptr %21, i32 0, i32 0
  %22 = load ptr, ptr %declared_name14, align 8
  %23 = load ptr, ptr %sub, align 8
  %declared_name15 = getelementptr inbounds %struct.redisCommand, ptr %23, i32 0, i32 0
  %24 = load ptr, ptr %declared_name15, align 8
  %call16 = call ptr @catSubCommandFullname(ptr noundef %22, ptr noundef %24)
  %25 = load ptr, ptr %sub, align 8
  %fullname17 = getelementptr inbounds %struct.redisCommand, ptr %25, i32 0, i32 27
  store ptr %call16, ptr %fullname17, align 8
  %26 = load ptr, ptr %sub, align 8
  %call18 = call i32 @populateCommandStructure(ptr noundef %26)
  %cmp = icmp eq i32 %call18, -1
  br i1 %cmp, label %if.then20, label %if.end21

if.then20:                                        ; preds = %for.body
  br label %for.inc

if.end21:                                         ; preds = %for.body
  %27 = load ptr, ptr %c.addr, align 8
  %28 = load ptr, ptr %sub, align 8
  %29 = load ptr, ptr %sub, align 8
  %declared_name22 = getelementptr inbounds %struct.redisCommand, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %declared_name22, align 8
  call void @commandAddSubcommand(ptr noundef %27, ptr noundef %28, ptr noundef %30)
  br label %for.inc

for.inc:                                          ; preds = %if.end21, %if.then20
  %31 = load i32, ptr %j, align 4
  %inc = add nsw i32 %31, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !39

for.end:                                          ; preds = %for.cond
  br label %if.end23

if.end23:                                         ; preds = %for.end, %if.end8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.then7, %if.then
  %32 = load i32, ptr %retval, align 4
  ret i32 %32
}

; Function Attrs: nounwind uwtable
define dso_local void @resetCommandTableStats(ptr noundef %commands) #0 {
entry:
  %commands.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %de = alloca ptr, align 8
  %di = alloca ptr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  %0 = load ptr, ptr %commands.addr, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end8, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %c, align 8
  %3 = load ptr, ptr %c, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 22
  store i64 0, ptr %microseconds, align 8
  %4 = load ptr, ptr %c, align 8
  %calls = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 23
  store i64 0, ptr %calls, align 8
  %5 = load ptr, ptr %c, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 24
  store i64 0, ptr %rejected_calls, align 8
  %6 = load ptr, ptr %c, align 8
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 25
  store i64 0, ptr %failed_calls, align 8
  %7 = load ptr, ptr %c, align 8
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 28
  %8 = load ptr, ptr %latency_histogram, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %9 = load ptr, ptr %c, align 8
  %latency_histogram3 = getelementptr inbounds %struct.redisCommand, ptr %9, i32 0, i32 28
  %10 = load ptr, ptr %latency_histogram3, align 8
  call void @hdr_close(ptr noundef %10)
  %11 = load ptr, ptr %c, align 8
  %latency_histogram4 = getelementptr inbounds %struct.redisCommand, ptr %11, i32 0, i32 28
  store ptr null, ptr %latency_histogram4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %12 = load ptr, ptr %c, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 30
  %13 = load ptr, ptr %subcommands_dict, align 8
  %tobool5 = icmp ne ptr %13, null
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %14 = load ptr, ptr %c, align 8
  %subcommands_dict7 = getelementptr inbounds %struct.redisCommand, ptr %14, i32 0, i32 30
  %15 = load ptr, ptr %subcommands_dict7, align 8
  call void @resetCommandTableStats(ptr noundef %15)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  br label %while.cond, !llvm.loop !40

while.end:                                        ; preds = %while.cond
  %16 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %16)
  ret void
}

declare ptr @dictGetSafeIterator(ptr noundef) #2

declare ptr @dictNext(ptr noundef) #2

declare ptr @dictGetVal(ptr noundef) #2

declare void @hdr_close(ptr noundef) #2

declare void @dictReleaseIterator(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @resetErrorTableStats() #0 {
entry:
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 15), align 8
  call void @raxFreeWithCallback(ptr noundef %0, ptr noundef @zfree)
  %call = call ptr @raxNew()
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 15), align 8
  ret void
}

declare void @raxFreeWithCallback(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @redisOpArrayAppend(ptr noundef %oa, i32 noundef %dbid, ptr noundef %argv, i32 noundef %argc, i32 noundef %target) #0 {
entry:
  %oa.addr = alloca ptr, align 8
  %dbid.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %target.addr = alloca i32, align 4
  %op = alloca ptr, align 8
  %prev_capacity = alloca i32, align 4
  store ptr %oa, ptr %oa.addr, align 8
  store i32 %dbid, ptr %dbid.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store i32 %target, ptr %target.addr, align 4
  %0 = load ptr, ptr %oa.addr, align 8
  %capacity = getelementptr inbounds %struct.redisOpArray, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %capacity, align 4
  store i32 %1, ptr %prev_capacity, align 4
  %2 = load ptr, ptr %oa.addr, align 8
  %numops = getelementptr inbounds %struct.redisOpArray, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %numops, align 8
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %oa.addr, align 8
  %capacity1 = getelementptr inbounds %struct.redisOpArray, ptr %4, i32 0, i32 2
  store i32 16, ptr %capacity1, align 4
  br label %if.end7

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %oa.addr, align 8
  %numops2 = getelementptr inbounds %struct.redisOpArray, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %numops2, align 8
  %7 = load ptr, ptr %oa.addr, align 8
  %capacity3 = getelementptr inbounds %struct.redisOpArray, ptr %7, i32 0, i32 2
  %8 = load i32, ptr %capacity3, align 4
  %cmp4 = icmp sge i32 %6, %8
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  %9 = load ptr, ptr %oa.addr, align 8
  %capacity6 = getelementptr inbounds %struct.redisOpArray, ptr %9, i32 0, i32 2
  %10 = load i32, ptr %capacity6, align 4
  %mul = mul nsw i32 %10, 2
  store i32 %mul, ptr %capacity6, align 4
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then
  %11 = load i32, ptr %prev_capacity, align 4
  %12 = load ptr, ptr %oa.addr, align 8
  %capacity8 = getelementptr inbounds %struct.redisOpArray, ptr %12, i32 0, i32 2
  %13 = load i32, ptr %capacity8, align 4
  %cmp9 = icmp ne i32 %11, %13
  br i1 %cmp9, label %if.then10, label %if.end14

if.then10:                                        ; preds = %if.end7
  %14 = load ptr, ptr %oa.addr, align 8
  %ops = getelementptr inbounds %struct.redisOpArray, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %ops, align 8
  %16 = load ptr, ptr %oa.addr, align 8
  %capacity11 = getelementptr inbounds %struct.redisOpArray, ptr %16, i32 0, i32 2
  %17 = load i32, ptr %capacity11, align 4
  %conv = sext i32 %17 to i64
  %mul12 = mul i64 24, %conv
  %call = call ptr @zrealloc(ptr noundef %15, i64 noundef %mul12) #19
  %18 = load ptr, ptr %oa.addr, align 8
  %ops13 = getelementptr inbounds %struct.redisOpArray, ptr %18, i32 0, i32 0
  store ptr %call, ptr %ops13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then10, %if.end7
  %19 = load ptr, ptr %oa.addr, align 8
  %ops15 = getelementptr inbounds %struct.redisOpArray, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %ops15, align 8
  %21 = load ptr, ptr %oa.addr, align 8
  %numops16 = getelementptr inbounds %struct.redisOpArray, ptr %21, i32 0, i32 1
  %22 = load i32, ptr %numops16, align 8
  %idx.ext = sext i32 %22 to i64
  %add.ptr = getelementptr inbounds %struct.redisOp, ptr %20, i64 %idx.ext
  store ptr %add.ptr, ptr %op, align 8
  %23 = load i32, ptr %dbid.addr, align 4
  %24 = load ptr, ptr %op, align 8
  %dbid17 = getelementptr inbounds %struct.redisOp, ptr %24, i32 0, i32 2
  store i32 %23, ptr %dbid17, align 4
  %25 = load ptr, ptr %argv.addr, align 8
  %26 = load ptr, ptr %op, align 8
  %argv18 = getelementptr inbounds %struct.redisOp, ptr %26, i32 0, i32 0
  store ptr %25, ptr %argv18, align 8
  %27 = load i32, ptr %argc.addr, align 4
  %28 = load ptr, ptr %op, align 8
  %argc19 = getelementptr inbounds %struct.redisOp, ptr %28, i32 0, i32 1
  store i32 %27, ptr %argc19, align 8
  %29 = load i32, ptr %target.addr, align 4
  %30 = load ptr, ptr %op, align 8
  %target20 = getelementptr inbounds %struct.redisOp, ptr %30, i32 0, i32 3
  store i32 %29, ptr %target20, align 8
  %31 = load ptr, ptr %oa.addr, align 8
  %numops21 = getelementptr inbounds %struct.redisOpArray, ptr %31, i32 0, i32 1
  %32 = load i32, ptr %numops21, align 8
  %inc = add nsw i32 %32, 1
  store i32 %inc, ptr %numops21, align 8
  %33 = load ptr, ptr %oa.addr, align 8
  %numops22 = getelementptr inbounds %struct.redisOpArray, ptr %33, i32 0, i32 1
  %34 = load i32, ptr %numops22, align 8
  ret i32 %34
}

; Function Attrs: allocsize(1)
declare ptr @zrealloc(ptr noundef, i64 noundef) #11

; Function Attrs: nounwind uwtable
define dso_local void @redisOpArrayFree(ptr noundef %oa) #0 {
entry:
  %oa.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %op = alloca ptr, align 8
  store ptr %oa, ptr %oa.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %for.end, %entry
  %0 = load ptr, ptr %oa.addr, align 8
  %numops = getelementptr inbounds %struct.redisOpArray, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %numops, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %oa.addr, align 8
  %numops1 = getelementptr inbounds %struct.redisOpArray, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %numops1, align 8
  %dec = add nsw i32 %3, -1
  store i32 %dec, ptr %numops1, align 8
  %4 = load ptr, ptr %oa.addr, align 8
  %ops = getelementptr inbounds %struct.redisOpArray, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %ops, align 8
  %6 = load ptr, ptr %oa.addr, align 8
  %numops2 = getelementptr inbounds %struct.redisOpArray, ptr %6, i32 0, i32 1
  %7 = load i32, ptr %numops2, align 8
  %idx.ext = sext i32 %7 to i64
  %add.ptr = getelementptr inbounds %struct.redisOp, ptr %5, i64 %idx.ext
  store ptr %add.ptr, ptr %op, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %8 = load i32, ptr %j, align 4
  %9 = load ptr, ptr %op, align 8
  %argc = getelementptr inbounds %struct.redisOp, ptr %9, i32 0, i32 1
  %10 = load i32, ptr %argc, align 8
  %cmp = icmp slt i32 %8, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr %op, align 8
  %argv = getelementptr inbounds %struct.redisOp, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %argv, align 8
  %13 = load i32, ptr %j, align 4
  %idxprom = sext i32 %13 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %12, i64 %idxprom
  %14 = load ptr, ptr %arrayidx, align 8
  call void @decrRefCount(ptr noundef %14)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32, ptr %j, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !41

for.end:                                          ; preds = %for.cond
  %16 = load ptr, ptr %op, align 8
  %argv3 = getelementptr inbounds %struct.redisOp, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %argv3, align 8
  call void @zfree(ptr noundef %17)
  br label %while.cond, !llvm.loop !42

while.end:                                        ; preds = %while.cond
  %18 = load ptr, ptr %oa.addr, align 8
  %numops4 = getelementptr inbounds %struct.redisOpArray, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %numops4, align 8
  %tobool5 = icmp ne i32 %19, 0
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot7 = xor i1 %lnot6, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool8 = icmp ne i64 %conv, 0
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.end
  br label %cond.end

cond.false:                                       ; preds = %while.end
  call void @_serverAssert(ptr noundef @.str.164, ptr noundef @.str.9, i32 noundef 3199)
  call void @abort() #16
  unreachable

20:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %20, %cond.true
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @isContainerCommandBySds(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %base_cmd = alloca ptr, align 8
  %has_subcommands = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %1 = load ptr, ptr %s.addr, align 8
  %call = call ptr @dictFetchValue(ptr noundef %0, ptr noundef %1)
  store ptr %call, ptr %base_cmd, align 8
  %2 = load ptr, ptr %base_cmd, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %3 = load ptr, ptr %base_cmd, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 30
  %4 = load ptr, ptr %subcommands_dict, align 8
  %tobool1 = icmp ne ptr %4, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %tobool1, %land.rhs ]
  %land.ext = zext i1 %5 to i32
  store i32 %land.ext, ptr %has_subcommands, align 4
  %6 = load i32, ptr %has_subcommands, align 4
  ret i32 %6
}

declare ptr @dictFetchValue(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupSubcommand(ptr noundef %container, ptr noundef %sub_name) #0 {
entry:
  %container.addr = alloca ptr, align 8
  %sub_name.addr = alloca ptr, align 8
  store ptr %container, ptr %container.addr, align 8
  store ptr %sub_name, ptr %sub_name.addr, align 8
  %0 = load ptr, ptr %container.addr, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 30
  %1 = load ptr, ptr %subcommands_dict, align 8
  %2 = load ptr, ptr %sub_name.addr, align 8
  %call = call ptr @dictFetchValue(ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandLogic(ptr noundef %commands, ptr noundef %argv, i32 noundef %argc, i32 noundef %strict) #0 {
entry:
  %retval = alloca ptr, align 8
  %commands.addr = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %strict.addr = alloca i32, align 4
  %base_cmd = alloca ptr, align 8
  %has_subcommands = alloca i32, align 4
  store ptr %commands, ptr %commands.addr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store i32 %strict, ptr %strict.addr, align 4
  %0 = load ptr, ptr %commands.addr, align 8
  %1 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 0
  %2 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %ptr, align 8
  %call = call ptr @dictFetchValue(ptr noundef %0, ptr noundef %3)
  store ptr %call, ptr %base_cmd, align 8
  %4 = load ptr, ptr %base_cmd, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %5 = load ptr, ptr %base_cmd, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 30
  %6 = load ptr, ptr %subcommands_dict, align 8
  %tobool1 = icmp ne ptr %6, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %7 = phi i1 [ false, %entry ], [ %tobool1, %land.rhs ]
  %land.ext = zext i1 %7 to i32
  store i32 %land.ext, ptr %has_subcommands, align 4
  %8 = load i32, ptr %argc.addr, align 4
  %cmp = icmp eq i32 %8, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.end
  %9 = load i32, ptr %has_subcommands, align 4
  %tobool2 = icmp ne i32 %9, 0
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.end
  %10 = load i32, ptr %strict.addr, align 4
  %tobool3 = icmp ne i32 %10, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %11 = load i32, ptr %argc.addr, align 4
  %cmp4 = icmp ne i32 %11, 1
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %land.lhs.true
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  %12 = load ptr, ptr %base_cmd, align 8
  store ptr %12, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %13 = load i32, ptr %strict.addr, align 4
  %tobool6 = icmp ne i32 %13, 0
  br i1 %tobool6, label %land.lhs.true7, label %if.end10

land.lhs.true7:                                   ; preds = %if.else
  %14 = load i32, ptr %argc.addr, align 4
  %cmp8 = icmp ne i32 %14, 2
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true7
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %land.lhs.true7, %if.else
  %15 = load ptr, ptr %base_cmd, align 8
  %16 = load ptr, ptr %argv.addr, align 8
  %arrayidx11 = getelementptr inbounds ptr, ptr %16, i64 1
  %17 = load ptr, ptr %arrayidx11, align 8
  %ptr12 = getelementptr inbounds %struct.redisObject, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %ptr12, align 8
  %call13 = call ptr @lookupSubcommand(ptr noundef %15, ptr noundef %18)
  store ptr %call13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end10, %if.then9, %if.end, %if.then5
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommand(ptr noundef %argv, i32 noundef %argc) #0 {
entry:
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %1 = load ptr, ptr %argv.addr, align 8
  %2 = load i32, ptr %argc.addr, align 4
  %call = call ptr @lookupCommandLogic(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandBySdsLogic(ptr noundef %commands, ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %commands.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %argc = alloca i32, align 4
  %j = alloca i32, align 4
  %strings = alloca ptr, align 8
  %saved_stack = alloca ptr, align 8
  %__vla_expr0 = alloca i64, align 8
  %__vla_expr1 = alloca i64, align 8
  %cmd = alloca ptr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i64 @sdslen(ptr noundef %1)
  %call1 = call ptr @sdssplitlen(ptr noundef %0, i64 noundef %call, ptr noundef @.str.165, i32 noundef 1, ptr noundef %argc)
  store ptr %call1, ptr %strings, align 8
  %2 = load ptr, ptr %strings, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %argc, align 4
  %cmp2 = icmp slt i32 %3, 1
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %4 = load i32, ptr %argc, align 4
  %cmp3 = icmp sgt i32 %4, 2
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  %5 = load ptr, ptr %strings, align 8
  %6 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %5, i32 noundef %6)
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  %7 = load i32, ptr %argc, align 4
  %cmp6 = icmp sgt i32 %7, 0
  %lnot = xor i1 %cmp6, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end5
  br label %cond.end

cond.false:                                       ; preds = %if.end5
  call void @_serverAssert(ptr noundef @.str.166, ptr noundef @.str.9, i32 noundef 3253)
  call void @abort() #16
  unreachable

8:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %8, %cond.true
  %9 = load i32, ptr %argc, align 4
  %10 = zext i32 %9 to i64
  %11 = call ptr @llvm.stacksave.p0()
  store ptr %11, ptr %saved_stack, align 8
  %vla = alloca %struct.redisObject, i64 %10, align 16
  store i64 %10, ptr %__vla_expr0, align 8
  %12 = load i32, ptr %argc, align 4
  %13 = zext i32 %12 to i64
  %vla8 = alloca ptr, i64 %13, align 16
  store i64 %13, ptr %__vla_expr1, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %14 = load i32, ptr %j, align 4
  %15 = load i32, ptr %argc, align 4
  %cmp9 = icmp slt i32 %14, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %16 = load i32, ptr %j, align 4
  %idxprom = sext i32 %16 to i64
  %arrayidx = getelementptr inbounds %struct.redisObject, ptr %vla, i64 %idxprom
  %refcount = getelementptr inbounds %struct.redisObject, ptr %arrayidx, i32 0, i32 1
  store i32 2147483646, ptr %refcount, align 4
  %17 = load i32, ptr %j, align 4
  %idxprom11 = sext i32 %17 to i64
  %arrayidx12 = getelementptr inbounds %struct.redisObject, ptr %vla, i64 %idxprom11
  %bf.load = load i32, ptr %arrayidx12, align 16
  %bf.clear = and i32 %bf.load, -16
  %bf.set = or i32 %bf.clear, 0
  store i32 %bf.set, ptr %arrayidx12, align 16
  %18 = load i32, ptr %j, align 4
  %idxprom13 = sext i32 %18 to i64
  %arrayidx14 = getelementptr inbounds %struct.redisObject, ptr %vla, i64 %idxprom13
  %bf.load15 = load i32, ptr %arrayidx14, align 16
  %bf.clear16 = and i32 %bf.load15, -241
  %bf.set17 = or i32 %bf.clear16, 0
  store i32 %bf.set17, ptr %arrayidx14, align 16
  %19 = load ptr, ptr %strings, align 8
  %20 = load i32, ptr %j, align 4
  %idxprom18 = sext i32 %20 to i64
  %arrayidx19 = getelementptr inbounds ptr, ptr %19, i64 %idxprom18
  %21 = load ptr, ptr %arrayidx19, align 8
  %22 = load i32, ptr %j, align 4
  %idxprom20 = sext i32 %22 to i64
  %arrayidx21 = getelementptr inbounds %struct.redisObject, ptr %vla, i64 %idxprom20
  %ptr = getelementptr inbounds %struct.redisObject, ptr %arrayidx21, i32 0, i32 2
  store ptr %21, ptr %ptr, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %do.cond
  %23 = load i32, ptr %j, align 4
  %idxprom22 = sext i32 %23 to i64
  %arrayidx23 = getelementptr inbounds %struct.redisObject, ptr %vla, i64 %idxprom22
  %24 = load i32, ptr %j, align 4
  %idxprom24 = sext i32 %24 to i64
  %arrayidx25 = getelementptr inbounds ptr, ptr %vla8, i64 %idxprom24
  store ptr %arrayidx23, ptr %arrayidx25, align 8
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %25 = load i32, ptr %j, align 4
  %inc = add nsw i32 %25, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !43

for.end:                                          ; preds = %for.cond
  %26 = load ptr, ptr %commands.addr, align 8
  %27 = load i32, ptr %argc, align 4
  %call26 = call ptr @lookupCommandLogic(ptr noundef %26, ptr noundef %vla8, i32 noundef %27, i32 noundef 1)
  store ptr %call26, ptr %cmd, align 8
  %28 = load ptr, ptr %strings, align 8
  %29 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %28, i32 noundef %29)
  %30 = load ptr, ptr %cmd, align 8
  store ptr %30, ptr %retval, align 8
  %31 = load ptr, ptr %saved_stack, align 8
  call void @llvm.stackrestore.p0(ptr %31)
  br label %return

return:                                           ; preds = %for.end, %if.then4, %if.then
  %32 = load ptr, ptr %retval, align 8
  ret ptr %32
}

declare ptr @sdssplitlen(ptr noundef, i64 noundef, ptr noundef, i32 noundef, ptr noundef) #2

declare void @sdsfreesplitres(ptr noundef, i32 noundef) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #4

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore.p0(ptr) #4

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandBySds(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %1 = load ptr, ptr %s.addr, align 8
  %call = call ptr @lookupCommandBySdsLogic(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandByCStringLogic(ptr noundef %commands, ptr noundef %s) #0 {
entry:
  %commands.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %name = alloca ptr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @sdsnew(ptr noundef %0)
  store ptr %call, ptr %name, align 8
  %1 = load ptr, ptr %commands.addr, align 8
  %2 = load ptr, ptr %name, align 8
  %call1 = call ptr @lookupCommandBySdsLogic(ptr noundef %1, ptr noundef %2)
  store ptr %call1, ptr %cmd, align 8
  %3 = load ptr, ptr %name, align 8
  call void @sdsfree(ptr noundef %3)
  %4 = load ptr, ptr %cmd, align 8
  ret ptr %4
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandByCString(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %1 = load ptr, ptr %s.addr, align 8
  %call = call ptr @lookupCommandByCStringLogic(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define dso_local ptr @lookupCommandOrOriginal(ptr noundef %argv, i32 noundef %argc) #0 {
entry:
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %cmd = alloca ptr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %1 = load ptr, ptr %argv.addr, align 8
  %2 = load i32, ptr %argc.addr, align 4
  %call = call ptr @lookupCommandLogic(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef 0)
  store ptr %call, ptr %cmd, align 8
  %3 = load ptr, ptr %cmd, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 13), align 8
  %5 = load ptr, ptr %argv.addr, align 8
  %6 = load i32, ptr %argc.addr, align 4
  %call1 = call ptr @lookupCommandLogic(ptr noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef 0)
  store ptr %call1, ptr %cmd, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %cmd, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define dso_local i32 @mustObeyClient(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %id = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 0
  %1 = load i64, ptr %id, align 8
  %cmp = icmp eq i64 %1, -1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 1
  %3 = load i64, ptr %flags, align 8
  %and = and i64 %3, 2
  %tobool = icmp ne i64 %and, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %4 = phi i1 [ true, %entry ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %4 to i32
  ret i32 %lor.ext
}

; Function Attrs: nounwind uwtable
define dso_local void @alsoPropagate(i32 noundef %dbid, ptr noundef %argv, i32 noundef %argc, i32 noundef %target) #0 {
entry:
  %dbid.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %target.addr = alloca i32, align 4
  %argvcopy = alloca ptr, align 8
  %j = alloca i32, align 4
  store i32 %dbid, ptr %dbid.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store i32 %target, ptr %target.addr, align 4
  %0 = load i32, ptr %target.addr, align 4
  %call = call i32 @shouldPropagate(i32 noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %argc.addr, align 4
  %conv = sext i32 %1 to i64
  %mul = mul i64 8, %conv
  %call1 = call noalias ptr @zmalloc(i64 noundef %mul) #18
  store ptr %call1, ptr %argvcopy, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr %argc.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %argv.addr, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  %7 = load ptr, ptr %argvcopy, align 8
  %8 = load i32, ptr %j, align 4
  %idxprom3 = sext i32 %8 to i64
  %arrayidx4 = getelementptr inbounds ptr, ptr %7, i64 %idxprom3
  store ptr %6, ptr %arrayidx4, align 8
  %9 = load ptr, ptr %argv.addr, align 8
  %10 = load i32, ptr %j, align 4
  %idxprom5 = sext i32 %10 to i64
  %arrayidx6 = getelementptr inbounds ptr, ptr %9, i64 %idxprom5
  %11 = load ptr, ptr %arrayidx6, align 8
  call void @incrRefCount(ptr noundef %11)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, ptr %j, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !44

for.end:                                          ; preds = %for.cond
  %13 = load i32, ptr %dbid.addr, align 4
  %14 = load ptr, ptr %argvcopy, align 8
  %15 = load i32, ptr %argc.addr, align 4
  %16 = load i32, ptr %target.addr, align 4
  %call7 = call i32 @redisOpArrayAppend(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 248), i32 noundef %13, ptr noundef %14, i32 noundef %15, i32 noundef %16)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @shouldPropagate(i32 noundef %target) #0 {
entry:
  %retval = alloca i32, align 4
  %target.addr = alloca i32, align 4
  store i32 %target, ptr %target.addr, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 249), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %target.addr, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false1

lor.lhs.false1:                                   ; preds = %lor.lhs.false
  %2 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false1, %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false1
  %3 = load i32, ptr %target.addr, align 4
  %and = and i32 %3, 1
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp5 = icmp ne i32 %4, 0
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then4
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.then4
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.end
  %5 = load i32, ptr %target.addr, align 4
  %and9 = and i32 %5, 2
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end18

if.then11:                                        ; preds = %if.end8
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %cmp12 = icmp eq ptr %6, null
  br i1 %cmp12, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then11
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %tobool13 = icmp ne ptr %7, null
  br i1 %tobool13, label %if.then16, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %land.lhs.true
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %len = getelementptr inbounds %struct.list, ptr %8, i32 0, i32 5
  %9 = load i64, ptr %len, align 8
  %cmp15 = icmp ne i64 %9, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false14, %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %lor.lhs.false14, %if.then11
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then16, %if.then6, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

declare void @incrRefCount(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @forceCommandPropagation(ptr noundef %c, i32 noundef %flags) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 17
  %1 = load ptr, ptr %cmd, align 8
  %flags1 = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 14
  %2 = load i64, ptr %flags1, align 8
  %and = and i64 %2, 65537
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool3 = icmp ne i64 %conv, 0
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @_serverAssert(ptr noundef @.str.167, ptr noundef @.str.9, i32 noundef 3378)
  call void @abort() #16
  unreachable

3:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i32, ptr %flags.addr, align 4
  %and4 = and i32 %4, 2
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %5 = load ptr, ptr %c.addr, align 8
  %flags6 = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %flags6, align 8
  %or = or i64 %6, 32768
  store i64 %or, ptr %flags6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %7 = load i32, ptr %flags.addr, align 4
  %and7 = and i32 %7, 1
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end
  %8 = load ptr, ptr %c.addr, align 8
  %flags10 = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 1
  %9 = load i64, ptr %flags10, align 8
  %or11 = or i64 %9, 16384
  store i64 %or11, ptr %flags10, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @preventCommandPropagation(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %or = or i64 %1, 1572864
  store i64 %or, ptr %flags, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @preventCommandAOF(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %or = or i64 %1, 524288
  store i64 %or, ptr %flags, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @preventCommandReplication(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %or = or i64 %1, 1048576
  store i64 %or, ptr %flags, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @slowlogPushCurrentCommand(ptr noundef %c, ptr noundef %cmd, i64 noundef %duration) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %duration.addr = alloca i64, align 8
  %argv = alloca ptr, align 8
  %argc = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  store i64 %duration, ptr %duration.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 14
  %1 = load i64, ptr %flags, align 8
  %and = and i64 %1, 4096
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %original_argv = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 15
  %3 = load ptr, ptr %original_argv, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %4 = load ptr, ptr %c.addr, align 8
  %original_argv2 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 15
  %5 = load ptr, ptr %original_argv2, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %6 = load ptr, ptr %c.addr, align 8
  %argv3 = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 12
  %7 = load ptr, ptr %argv3, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %5, %cond.true ], [ %7, %cond.false ]
  store ptr %cond, ptr %argv, align 8
  %8 = load ptr, ptr %c.addr, align 8
  %original_argv4 = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 15
  %9 = load ptr, ptr %original_argv4, align 8
  %tobool5 = icmp ne ptr %9, null
  br i1 %tobool5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.end
  %10 = load ptr, ptr %c.addr, align 8
  %original_argc = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 14
  %11 = load i32, ptr %original_argc, align 4
  br label %cond.end9

cond.false7:                                      ; preds = %cond.end
  %12 = load ptr, ptr %c.addr, align 8
  %argc8 = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 11
  %13 = load i32, ptr %argc8, align 8
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false7, %cond.true6
  %cond10 = phi i32 [ %11, %cond.true6 ], [ %13, %cond.false7 ]
  store i32 %cond10, ptr %argc, align 4
  %14 = load ptr, ptr %c.addr, align 8
  %15 = load ptr, ptr %argv, align 8
  %16 = load i32, ptr %argc, align 4
  %17 = load i64, ptr %duration.addr, align 8
  call void @slowlogPushEntryIfNeeded(ptr noundef %14, ptr noundef %15, i32 noundef %16, i64 noundef %17)
  br label %return

return:                                           ; preds = %cond.end9, %if.then
  ret void
}

declare void @slowlogPushEntryIfNeeded(ptr noundef, ptr noundef, i32 noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @updateCommandLatencyHistogram(ptr noundef %latency_histogram, i64 noundef %duration_hist) #0 {
entry:
  %latency_histogram.addr = alloca ptr, align 8
  %duration_hist.addr = alloca i64, align 8
  store ptr %latency_histogram, ptr %latency_histogram.addr, align 8
  store i64 %duration_hist, ptr %duration_hist.addr, align 8
  %0 = load i64, ptr %duration_hist.addr, align 8
  %cmp = icmp slt i64 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 1, ptr %duration_hist.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, ptr %duration_hist.addr, align 8
  %cmp1 = icmp sgt i64 %1, 1000000000
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 1000000000, ptr %duration_hist.addr, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %2 = load ptr, ptr %latency_histogram.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %cmp4 = icmp eq ptr %3, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %4 = load ptr, ptr %latency_histogram.addr, align 8
  %call = call i32 @hdr_init(i64 noundef 1, i64 noundef 1000000000, i32 noundef 2, ptr noundef %4)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %5 = load ptr, ptr %latency_histogram.addr, align 8
  %6 = load ptr, ptr %5, align 8
  %7 = load i64, ptr %duration_hist.addr, align 8
  %call7 = call zeroext i1 @hdr_record_value(ptr noundef %6, i64 noundef %7)
  ret void
}

declare i32 @hdr_init(i64 noundef, i64 noundef, i32 noundef, ptr noundef) #2

declare zeroext i1 @hdr_record_value(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @postExecutionUnitOperations() #0 {
entry:
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  call void @firePostExecutionUnitJobs()
  call void @propagatePendingCommands()
  call void @modulePostExecutionUnitOperations()
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @firePostExecutionUnitJobs() #2

; Function Attrs: nounwind uwtable
define internal void @propagatePendingCommands() #0 {
entry:
  %j = alloca i32, align 4
  %rop = alloca ptr, align 8
  %transaction = alloca i32, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 248, i32 1), align 8
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 248, i32 1), align 8
  %cmp1 = icmp sgt i32 %1, 1
  %conv = zext i1 %cmp1 to i32
  store i32 %conv, ptr %transaction, align 4
  %2 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %cmd = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 17
  %4 = load ptr, ptr %cmd, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %land.lhs.true3, label %if.end7

land.lhs.true3:                                   ; preds = %land.lhs.true
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %cmd4 = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 17
  %6 = load ptr, ptr %cmd4, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 14
  %7 = load i64, ptr %flags, align 8
  %and = and i64 %7, 268435456
  %tobool5 = icmp ne i64 %and, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true3
  store i32 0, ptr %transaction, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %land.lhs.true3, %land.lhs.true, %if.end
  %8 = load i32, ptr %transaction, align 4
  %tobool8 = icmp ne i32 %8, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end7
  call void @propagateNow(i32 noundef -1, ptr noundef getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 49), i32 noundef 1, i32 noundef 3)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end7
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %9 = load i32, ptr %j, align 4
  %10 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 248, i32 1), align 8
  %cmp11 = icmp slt i32 %9, %10
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 248), align 8
  %12 = load i32, ptr %j, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds %struct.redisOp, ptr %11, i64 %idxprom
  store ptr %arrayidx, ptr %rop, align 8
  %13 = load ptr, ptr %rop, align 8
  %target = getelementptr inbounds %struct.redisOp, ptr %13, i32 0, i32 3
  %14 = load i32, ptr %target, align 8
  %tobool13 = icmp ne i32 %14, 0
  %lnot = xor i1 %tobool13, true
  %lnot14 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot14 to i32
  %conv15 = sext i32 %lnot.ext to i64
  %tobool16 = icmp ne i64 %conv15, 0
  br i1 %tobool16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  call void @_serverAssert(ptr noundef @.str.463, ptr noundef @.str.9, i32 noundef 3459)
  call void @abort() #16
  unreachable

15:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %15, %cond.true
  %16 = load ptr, ptr %rop, align 8
  %dbid = getelementptr inbounds %struct.redisOp, ptr %16, i32 0, i32 2
  %17 = load i32, ptr %dbid, align 4
  %18 = load ptr, ptr %rop, align 8
  %argv = getelementptr inbounds %struct.redisOp, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %argv, align 8
  %20 = load ptr, ptr %rop, align 8
  %argc = getelementptr inbounds %struct.redisOp, ptr %20, i32 0, i32 1
  %21 = load i32, ptr %argc, align 8
  %22 = load ptr, ptr %rop, align 8
  %target17 = getelementptr inbounds %struct.redisOp, ptr %22, i32 0, i32 3
  %23 = load i32, ptr %target17, align 8
  call void @propagateNow(i32 noundef %17, ptr noundef %19, i32 noundef %21, i32 noundef %23)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %24 = load i32, ptr %j, align 4
  %inc = add nsw i32 %24, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !45

for.end:                                          ; preds = %for.cond
  %25 = load i32, ptr %transaction, align 4
  %tobool18 = icmp ne i32 %25, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %for.end
  call void @propagateNow(i32 noundef -1, ptr noundef getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 50), i32 noundef 1, i32 noundef 3)
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %for.end
  call void @redisOpArrayFree(ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 248))
  br label %return

return:                                           ; preds = %if.end20, %if.then
  ret void
}

declare void @modulePostExecutionUnitOperations() #2

; Function Attrs: nounwind uwtable
define dso_local i32 @incrCommandStatsOnError(ptr noundef %cmd, i32 noundef %flags) #0 {
entry:
  %cmd.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store ptr %cmd, ptr %cmd.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store i32 0, ptr %res, align 4
  %0 = load ptr, ptr %cmd.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 140), align 8
  %2 = load i64, ptr @incrCommandStatsOnError.prev_err_count, align 8
  %sub = sub nsw i64 %1, %2
  %cmp = icmp sgt i64 %sub, 0
  br i1 %cmp, label %if.then1, label %if.end9

if.then1:                                         ; preds = %if.then
  %3 = load i32, ptr %flags.addr, align 4
  %and = and i32 %3, 1
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.then1
  %4 = load ptr, ptr %cmd.addr, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 24
  %5 = load i64, ptr %rejected_calls, align 8
  %inc = add nsw i64 %5, 1
  store i64 %inc, ptr %rejected_calls, align 8
  store i32 1, ptr %res, align 4
  br label %if.end8

if.else:                                          ; preds = %if.then1
  %6 = load i32, ptr %flags.addr, align 4
  %and4 = and i32 %6, 2
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.else
  %7 = load ptr, ptr %cmd.addr, align 8
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 25
  %8 = load i64, ptr %failed_calls, align 8
  %inc7 = add nsw i64 %8, 1
  store i64 %inc7, ptr %failed_calls, align 8
  store i32 1, ptr %res, align 4
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end, %if.then3
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.then
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %entry
  %9 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 140), align 8
  store i64 %9, ptr @incrCommandStatsOnError.prev_err_count, align 8
  %10 = load i32, ptr %res, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define dso_local void @call(ptr noundef %c, i32 noundef %flags) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %dirty = alloca i64, align 8
  %client_old_flags = alloca i64, align 8
  %real_cmd = alloca ptr, align 8
  %prev_client = alloca ptr, align 8
  %update_command_stats = alloca i32, align 4
  %reprocessing_command = alloca i32, align 4
  %old_master_repl_offset = alloca i64, align 8
  %call_timer = alloca i64, align 8
  %monotonic_start = alloca i64, align 8
  %duration = alloca i64, align 8
  %latency_event = alloca ptr, align 8
  %argv = alloca ptr, align 8
  %argc = alloca i32, align 4
  %propagate_flags = alloca i32, align 4
  %zmalloc_used = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %flags1 = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %flags1, align 8
  store i64 %1, ptr %client_old_flags, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %realcmd = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 19
  %3 = load ptr, ptr %realcmd, align 8
  store ptr %3, ptr %real_cmd, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 62), align 8
  store ptr %4, ptr %prev_client, align 8
  %5 = load ptr, ptr %c.addr, align 8
  store ptr %5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 62), align 8
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %id = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 0
  %8 = load i64, ptr %id, align 8
  %cmp = icmp eq i64 %8, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %9 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %cond = select i1 %9, i32 1, i32 0
  %tobool2 = icmp ne i32 %cond, 0
  %lnot = xor i1 %tobool2, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %update_command_stats, align 4
  %10 = load i32, ptr %flags.addr, align 4
  %and = and i32 %10, 4
  store i32 %and, ptr %reprocessing_command, align 4
  %11 = load ptr, ptr %c.addr, align 8
  %flags3 = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %flags3, align 8
  %and4 = and i64 %12, -1622017
  store i64 %and4, ptr %flags3, align 8
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  store i64 %13, ptr %dirty, align 8
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  store i64 %14, ptr %old_master_repl_offset, align 8
  %call = call i32 @incrCommandStatsOnError(ptr noundef null, i32 noundef 0)
  %call5 = call i64 @ustime()
  store i64 %call5, ptr %call_timer, align 8
  %15 = load i64, ptr %call_timer, align 8
  call void @enterExecutionUnit(i32 noundef 1, i64 noundef %15)
  %16 = load ptr, ptr %c.addr, align 8
  %flags6 = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 1
  %17 = load i64, ptr %flags6, align 8
  %or = or i64 %17, 536870912
  store i64 %or, ptr %flags6, align 8
  store i64 0, ptr %monotonic_start, align 8
  %call7 = call i32 @monotonicGetType()
  %cmp8 = icmp eq i32 %call7, 1
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  %18 = load ptr, ptr @getMonotonicUs, align 8
  %call9 = call i64 %18()
  store i64 %call9, ptr %monotonic_start, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %19 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %19, i32 0, i32 17
  %20 = load ptr, ptr %cmd, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %20, i32 0, i32 12
  %21 = load ptr, ptr %proc, align 8
  %22 = load ptr, ptr %c.addr, align 8
  call void %21(ptr noundef %22)
  call void @exitExecutionUnit()
  %23 = load ptr, ptr %c.addr, align 8
  %flags10 = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 1
  %24 = load i64, ptr %flags10, align 8
  %and11 = and i64 %24, 16
  %tobool12 = icmp ne i64 %and11, 0
  br i1 %tobool12, label %if.end16, label %if.then13

if.then13:                                        ; preds = %if.end
  %25 = load ptr, ptr %c.addr, align 8
  %flags14 = getelementptr inbounds %struct.client, ptr %25, i32 0, i32 1
  %26 = load i64, ptr %flags14, align 8
  %and15 = and i64 %26, -536870913
  store i64 %and15, ptr %flags14, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end
  %call17 = call i32 @monotonicGetType()
  %cmp18 = icmp eq i32 %call17, 1
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.end16
  %27 = load ptr, ptr @getMonotonicUs, align 8
  %call20 = call i64 %27()
  %28 = load i64, ptr %monotonic_start, align 8
  %sub = sub i64 %call20, %28
  store i64 %sub, ptr %duration, align 8
  br label %if.end23

if.else:                                          ; preds = %if.end16
  %call21 = call i64 @ustime()
  %29 = load i64, ptr %call_timer, align 8
  %sub22 = sub nsw i64 %call21, %29
  store i64 %sub22, ptr %duration, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.else, %if.then19
  %30 = load i64, ptr %duration, align 8
  %31 = load ptr, ptr %c.addr, align 8
  %duration24 = getelementptr inbounds %struct.client, ptr %31, i32 0, i32 29
  %32 = load i64, ptr %duration24, align 8
  %add = add nsw i64 %32, %30
  store i64 %add, ptr %duration24, align 8
  %33 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  %34 = load i64, ptr %dirty, align 8
  %sub25 = sub nsw i64 %33, %34
  store i64 %sub25, ptr %dirty, align 8
  %35 = load i64, ptr %dirty, align 8
  %cmp26 = icmp slt i64 %35, 0
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end23
  store i64 0, ptr %dirty, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.end23
  %36 = load ptr, ptr %real_cmd, align 8
  %call29 = call i32 @incrCommandStatsOnError(ptr noundef %36, i32 noundef 2)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.end33, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end28
  %37 = load ptr, ptr %c.addr, align 8
  %deferred_reply_errors = getelementptr inbounds %struct.client, ptr %37, i32 0, i32 26
  %38 = load ptr, ptr %deferred_reply_errors, align 8
  %tobool31 = icmp ne ptr %38, null
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true
  %39 = load ptr, ptr %real_cmd, align 8
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %39, i32 0, i32 25
  %40 = load i64, ptr %failed_calls, align 8
  %inc = add nsw i64 %40, 1
  store i64 %inc, ptr %failed_calls, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %land.lhs.true, %if.end28
  %41 = load ptr, ptr %c.addr, align 8
  %flags34 = getelementptr inbounds %struct.client, ptr %41, i32 0, i32 1
  %42 = load i64, ptr %flags34, align 8
  %and35 = and i64 %42, 1099511627776
  %tobool36 = icmp ne i64 %and35, 0
  br i1 %tobool36, label %if.then37, label %if.end42

if.then37:                                        ; preds = %if.end33
  %43 = load ptr, ptr %c.addr, align 8
  %flags38 = getelementptr inbounds %struct.client, ptr %43, i32 0, i32 1
  %44 = load i64, ptr %flags38, align 8
  %and39 = and i64 %44, -1099511627777
  store i64 %and39, ptr %flags38, align 8
  %45 = load ptr, ptr %c.addr, align 8
  %flags40 = getelementptr inbounds %struct.client, ptr %45, i32 0, i32 1
  %46 = load i64, ptr %flags40, align 8
  %or41 = or i64 %46, 64
  store i64 %or41, ptr %flags40, align 8
  br label %if.end42

if.end42:                                         ; preds = %if.then37, %if.end33
  %47 = load i32, ptr %update_command_stats, align 4
  %tobool43 = icmp ne i32 %47, 0
  br i1 %tobool43, label %if.then44, label %if.end58

if.then44:                                        ; preds = %if.end42
  %48 = load ptr, ptr %real_cmd, align 8
  %flags45 = getelementptr inbounds %struct.redisCommand, ptr %48, i32 0, i32 14
  %49 = load i64, ptr %flags45, align 8
  %and46 = and i64 %49, 16384
  %tobool47 = icmp ne i64 %and46, 0
  %cond48 = select i1 %tobool47, ptr @.str.168, ptr @.str.169
  store ptr %cond48, ptr %latency_event, align 8
  %50 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %tobool49 = icmp ne i64 %50, 0
  br i1 %tobool49, label %land.lhs.true50, label %if.end54

land.lhs.true50:                                  ; preds = %if.then44
  %51 = load i64, ptr %duration, align 8
  %div = sdiv i64 %51, 1000
  %52 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %cmp51 = icmp sge i64 %div, %52
  br i1 %cmp51, label %if.then52, label %if.end54

if.then52:                                        ; preds = %land.lhs.true50
  %53 = load ptr, ptr %latency_event, align 8
  %54 = load i64, ptr %duration, align 8
  %div53 = sdiv i64 %54, 1000
  call void @latencyAddSample(ptr noundef %53, i64 noundef %div53)
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %land.lhs.true50, %if.then44
  %55 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %cmp55 = icmp eq i32 %55, 0
  br i1 %cmp55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end54
  %56 = load i64, ptr %duration, align 8
  call void @durationAddSample(i32 noundef 1, i64 noundef %56)
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.end54
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.end42
  %57 = load i32, ptr %update_command_stats, align 4
  %tobool59 = icmp ne i32 %57, 0
  br i1 %tobool59, label %land.lhs.true60, label %if.end66

land.lhs.true60:                                  ; preds = %if.end58
  %58 = load ptr, ptr %c.addr, align 8
  %flags61 = getelementptr inbounds %struct.client, ptr %58, i32 0, i32 1
  %59 = load i64, ptr %flags61, align 8
  %and62 = and i64 %59, 16
  %tobool63 = icmp ne i64 %and62, 0
  br i1 %tobool63, label %if.end66, label %if.then64

if.then64:                                        ; preds = %land.lhs.true60
  %60 = load ptr, ptr %c.addr, align 8
  %61 = load ptr, ptr %real_cmd, align 8
  %62 = load ptr, ptr %c.addr, align 8
  %duration65 = getelementptr inbounds %struct.client, ptr %62, i32 0, i32 29
  %63 = load i64, ptr %duration65, align 8
  call void @slowlogPushCurrentCommand(ptr noundef %60, ptr noundef %61, i64 noundef %63)
  br label %if.end66

if.end66:                                         ; preds = %if.then64, %land.lhs.true60, %if.end58
  %64 = load i32, ptr %update_command_stats, align 4
  %tobool67 = icmp ne i32 %64, 0
  br i1 %tobool67, label %land.lhs.true68, label %if.end88

land.lhs.true68:                                  ; preds = %if.end66
  %65 = load i32, ptr %reprocessing_command, align 4
  %tobool69 = icmp ne i32 %65, 0
  br i1 %tobool69, label %if.end88, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %land.lhs.true68
  %66 = load ptr, ptr %c.addr, align 8
  %cmd71 = getelementptr inbounds %struct.client, ptr %66, i32 0, i32 17
  %67 = load ptr, ptr %cmd71, align 8
  %flags72 = getelementptr inbounds %struct.redisCommand, ptr %67, i32 0, i32 14
  %68 = load i64, ptr %flags72, align 8
  %and73 = and i64 %68, 2064
  %tobool74 = icmp ne i64 %and73, 0
  br i1 %tobool74, label %if.end88, label %if.then75

if.then75:                                        ; preds = %land.lhs.true70
  %69 = load ptr, ptr %c.addr, align 8
  %original_argv = getelementptr inbounds %struct.client, ptr %69, i32 0, i32 15
  %70 = load ptr, ptr %original_argv, align 8
  %tobool76 = icmp ne ptr %70, null
  br i1 %tobool76, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then75
  %71 = load ptr, ptr %c.addr, align 8
  %original_argv77 = getelementptr inbounds %struct.client, ptr %71, i32 0, i32 15
  %72 = load ptr, ptr %original_argv77, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then75
  %73 = load ptr, ptr %c.addr, align 8
  %argv78 = getelementptr inbounds %struct.client, ptr %73, i32 0, i32 12
  %74 = load ptr, ptr %argv78, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond79 = phi ptr [ %72, %cond.true ], [ %74, %cond.false ]
  store ptr %cond79, ptr %argv, align 8
  %75 = load ptr, ptr %c.addr, align 8
  %original_argv80 = getelementptr inbounds %struct.client, ptr %75, i32 0, i32 15
  %76 = load ptr, ptr %original_argv80, align 8
  %tobool81 = icmp ne ptr %76, null
  br i1 %tobool81, label %cond.true82, label %cond.false83

cond.true82:                                      ; preds = %cond.end
  %77 = load ptr, ptr %c.addr, align 8
  %original_argc = getelementptr inbounds %struct.client, ptr %77, i32 0, i32 14
  %78 = load i32, ptr %original_argc, align 4
  br label %cond.end85

cond.false83:                                     ; preds = %cond.end
  %79 = load ptr, ptr %c.addr, align 8
  %argc84 = getelementptr inbounds %struct.client, ptr %79, i32 0, i32 11
  %80 = load i32, ptr %argc84, align 8
  br label %cond.end85

cond.end85:                                       ; preds = %cond.false83, %cond.true82
  %cond86 = phi i32 [ %78, %cond.true82 ], [ %80, %cond.false83 ]
  store i32 %cond86, ptr %argc, align 4
  %81 = load ptr, ptr %c.addr, align 8
  %82 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 60), align 8
  %83 = load ptr, ptr %c.addr, align 8
  %db = getelementptr inbounds %struct.client, ptr %83, i32 0, i32 4
  %84 = load ptr, ptr %db, align 8
  %id87 = getelementptr inbounds %struct.redisDb, ptr %84, i32 0, i32 6
  %85 = load i32, ptr %id87, align 8
  %86 = load ptr, ptr %argv, align 8
  %87 = load i32, ptr %argc, align 4
  call void @replicationFeedMonitors(ptr noundef %81, ptr noundef %82, i32 noundef %85, ptr noundef %86, i32 noundef %87)
  br label %if.end88

if.end88:                                         ; preds = %cond.end85, %land.lhs.true70, %land.lhs.true68, %if.end66
  %88 = load ptr, ptr %c.addr, align 8
  %flags89 = getelementptr inbounds %struct.client, ptr %88, i32 0, i32 1
  %89 = load i64, ptr %flags89, align 8
  %and90 = and i64 %89, 16
  %tobool91 = icmp ne i64 %and90, 0
  br i1 %tobool91, label %if.end93, label %if.then92

if.then92:                                        ; preds = %if.end88
  %90 = load ptr, ptr %c.addr, align 8
  call void @freeClientOriginalArgv(ptr noundef %90)
  br label %if.end93

if.end93:                                         ; preds = %if.then92, %if.end88
  %91 = load i32, ptr %update_command_stats, align 4
  %tobool94 = icmp ne i32 %91, 0
  br i1 %tobool94, label %land.lhs.true95, label %if.end111

land.lhs.true95:                                  ; preds = %if.end93
  %92 = load ptr, ptr %c.addr, align 8
  %flags96 = getelementptr inbounds %struct.client, ptr %92, i32 0, i32 1
  %93 = load i64, ptr %flags96, align 8
  %and97 = and i64 %93, 16
  %tobool98 = icmp ne i64 %and97, 0
  br i1 %tobool98, label %if.end111, label %if.then99

if.then99:                                        ; preds = %land.lhs.true95
  %94 = load ptr, ptr %real_cmd, align 8
  %calls = getelementptr inbounds %struct.redisCommand, ptr %94, i32 0, i32 23
  %95 = load i64, ptr %calls, align 8
  %inc100 = add nsw i64 %95, 1
  store i64 %inc100, ptr %calls, align 8
  %96 = load ptr, ptr %c.addr, align 8
  %duration101 = getelementptr inbounds %struct.client, ptr %96, i32 0, i32 29
  %97 = load i64, ptr %duration101, align 8
  %98 = load ptr, ptr %real_cmd, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %98, i32 0, i32 22
  %99 = load i64, ptr %microseconds, align 8
  %add102 = add nsw i64 %99, %97
  store i64 %add102, ptr %microseconds, align 8
  %100 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 181), align 4
  %tobool103 = icmp ne i32 %100, 0
  br i1 %tobool103, label %land.lhs.true104, label %if.end110

land.lhs.true104:                                 ; preds = %if.then99
  %101 = load ptr, ptr %c.addr, align 8
  %flags105 = getelementptr inbounds %struct.client, ptr %101, i32 0, i32 1
  %102 = load i64, ptr %flags105, align 8
  %and106 = and i64 %102, 16
  %tobool107 = icmp ne i64 %and106, 0
  br i1 %tobool107, label %if.end110, label %if.then108

if.then108:                                       ; preds = %land.lhs.true104
  %103 = load ptr, ptr %real_cmd, align 8
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %103, i32 0, i32 28
  %104 = load ptr, ptr %c.addr, align 8
  %duration109 = getelementptr inbounds %struct.client, ptr %104, i32 0, i32 29
  %105 = load i64, ptr %duration109, align 8
  %mul = mul nsw i64 %105, 1000
  call void @updateCommandLatencyHistogram(ptr noundef %latency_histogram, i64 noundef %mul)
  br label %if.end110

if.end110:                                        ; preds = %if.then108, %land.lhs.true104, %if.then99
  br label %if.end111

if.end111:                                        ; preds = %if.end110, %land.lhs.true95, %if.end93
  %106 = load ptr, ptr %c.addr, align 8
  %flags112 = getelementptr inbounds %struct.client, ptr %106, i32 0, i32 1
  %107 = load i64, ptr %flags112, align 8
  %and113 = and i64 %107, 16
  %tobool114 = icmp ne i64 %and113, 0
  br i1 %tobool114, label %if.end117, label %if.then115

if.then115:                                       ; preds = %if.end111
  %108 = load ptr, ptr %c.addr, align 8
  %duration116 = getelementptr inbounds %struct.client, ptr %108, i32 0, i32 29
  store i64 0, ptr %duration116, align 8
  br label %if.end117

if.end117:                                        ; preds = %if.then115, %if.end111
  %109 = load i32, ptr %flags.addr, align 4
  %and118 = and i32 %109, 3
  %tobool119 = icmp ne i32 %and118, 0
  br i1 %tobool119, label %land.lhs.true120, label %if.end182

land.lhs.true120:                                 ; preds = %if.end117
  %110 = load ptr, ptr %c.addr, align 8
  %flags121 = getelementptr inbounds %struct.client, ptr %110, i32 0, i32 1
  %111 = load i64, ptr %flags121, align 8
  %and122 = and i64 %111, 1572864
  %cmp123 = icmp ne i64 %and122, 1572864
  br i1 %cmp123, label %land.lhs.true124, label %if.end182

land.lhs.true124:                                 ; preds = %land.lhs.true120
  %112 = load ptr, ptr %c.addr, align 8
  %cmd125 = getelementptr inbounds %struct.client, ptr %112, i32 0, i32 17
  %113 = load ptr, ptr %cmd125, align 8
  %proc126 = getelementptr inbounds %struct.redisCommand, ptr %113, i32 0, i32 12
  %114 = load ptr, ptr %proc126, align 8
  %cmp127 = icmp ne ptr %114, @execCommand
  br i1 %cmp127, label %land.lhs.true128, label %if.end182

land.lhs.true128:                                 ; preds = %land.lhs.true124
  %115 = load ptr, ptr %c.addr, align 8
  %cmd129 = getelementptr inbounds %struct.client, ptr %115, i32 0, i32 17
  %116 = load ptr, ptr %cmd129, align 8
  %flags130 = getelementptr inbounds %struct.redisCommand, ptr %116, i32 0, i32 14
  %117 = load i64, ptr %flags130, align 8
  %and131 = and i64 %117, 8
  %tobool132 = icmp ne i64 %and131, 0
  br i1 %tobool132, label %if.end182, label %if.then133

if.then133:                                       ; preds = %land.lhs.true128
  store i32 0, ptr %propagate_flags, align 4
  %118 = load i64, ptr %dirty, align 8
  %tobool134 = icmp ne i64 %118, 0
  br i1 %tobool134, label %if.then135, label %if.end137

if.then135:                                       ; preds = %if.then133
  %119 = load i32, ptr %propagate_flags, align 4
  %or136 = or i32 %119, 3
  store i32 %or136, ptr %propagate_flags, align 4
  br label %if.end137

if.end137:                                        ; preds = %if.then135, %if.then133
  %120 = load ptr, ptr %c.addr, align 8
  %flags138 = getelementptr inbounds %struct.client, ptr %120, i32 0, i32 1
  %121 = load i64, ptr %flags138, align 8
  %and139 = and i64 %121, 32768
  %tobool140 = icmp ne i64 %and139, 0
  br i1 %tobool140, label %if.then141, label %if.end143

if.then141:                                       ; preds = %if.end137
  %122 = load i32, ptr %propagate_flags, align 4
  %or142 = or i32 %122, 2
  store i32 %or142, ptr %propagate_flags, align 4
  br label %if.end143

if.end143:                                        ; preds = %if.then141, %if.end137
  %123 = load ptr, ptr %c.addr, align 8
  %flags144 = getelementptr inbounds %struct.client, ptr %123, i32 0, i32 1
  %124 = load i64, ptr %flags144, align 8
  %and145 = and i64 %124, 16384
  %tobool146 = icmp ne i64 %and145, 0
  br i1 %tobool146, label %if.then147, label %if.end149

if.then147:                                       ; preds = %if.end143
  %125 = load i32, ptr %propagate_flags, align 4
  %or148 = or i32 %125, 1
  store i32 %or148, ptr %propagate_flags, align 4
  br label %if.end149

if.end149:                                        ; preds = %if.then147, %if.end143
  %126 = load ptr, ptr %c.addr, align 8
  %flags150 = getelementptr inbounds %struct.client, ptr %126, i32 0, i32 1
  %127 = load i64, ptr %flags150, align 8
  %and151 = and i64 %127, 1048576
  %tobool152 = icmp ne i64 %and151, 0
  br i1 %tobool152, label %if.then159, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end149
  %128 = load ptr, ptr %c.addr, align 8
  %flags153 = getelementptr inbounds %struct.client, ptr %128, i32 0, i32 1
  %129 = load i64, ptr %flags153, align 8
  %and154 = and i64 %129, 562949953421312
  %tobool155 = icmp ne i64 %and154, 0
  br i1 %tobool155, label %if.then159, label %lor.lhs.false156

lor.lhs.false156:                                 ; preds = %lor.lhs.false
  %130 = load i32, ptr %flags.addr, align 4
  %and157 = and i32 %130, 2
  %tobool158 = icmp ne i32 %and157, 0
  br i1 %tobool158, label %if.end161, label %if.then159

if.then159:                                       ; preds = %lor.lhs.false156, %lor.lhs.false, %if.end149
  %131 = load i32, ptr %propagate_flags, align 4
  %and160 = and i32 %131, -3
  store i32 %and160, ptr %propagate_flags, align 4
  br label %if.end161

if.end161:                                        ; preds = %if.then159, %lor.lhs.false156
  %132 = load ptr, ptr %c.addr, align 8
  %flags162 = getelementptr inbounds %struct.client, ptr %132, i32 0, i32 1
  %133 = load i64, ptr %flags162, align 8
  %and163 = and i64 %133, 524288
  %tobool164 = icmp ne i64 %and163, 0
  br i1 %tobool164, label %if.then172, label %lor.lhs.false165

lor.lhs.false165:                                 ; preds = %if.end161
  %134 = load ptr, ptr %c.addr, align 8
  %flags166 = getelementptr inbounds %struct.client, ptr %134, i32 0, i32 1
  %135 = load i64, ptr %flags166, align 8
  %and167 = and i64 %135, 281474976710656
  %tobool168 = icmp ne i64 %and167, 0
  br i1 %tobool168, label %if.then172, label %lor.lhs.false169

lor.lhs.false169:                                 ; preds = %lor.lhs.false165
  %136 = load i32, ptr %flags.addr, align 4
  %and170 = and i32 %136, 1
  %tobool171 = icmp ne i32 %and170, 0
  br i1 %tobool171, label %if.end174, label %if.then172

if.then172:                                       ; preds = %lor.lhs.false169, %lor.lhs.false165, %if.end161
  %137 = load i32, ptr %propagate_flags, align 4
  %and173 = and i32 %137, -2
  store i32 %and173, ptr %propagate_flags, align 4
  br label %if.end174

if.end174:                                        ; preds = %if.then172, %lor.lhs.false169
  %138 = load i32, ptr %propagate_flags, align 4
  %cmp175 = icmp ne i32 %138, 0
  br i1 %cmp175, label %if.then176, label %if.end181

if.then176:                                       ; preds = %if.end174
  %139 = load ptr, ptr %c.addr, align 8
  %db177 = getelementptr inbounds %struct.client, ptr %139, i32 0, i32 4
  %140 = load ptr, ptr %db177, align 8
  %id178 = getelementptr inbounds %struct.redisDb, ptr %140, i32 0, i32 6
  %141 = load i32, ptr %id178, align 8
  %142 = load ptr, ptr %c.addr, align 8
  %argv179 = getelementptr inbounds %struct.client, ptr %142, i32 0, i32 12
  %143 = load ptr, ptr %argv179, align 8
  %144 = load ptr, ptr %c.addr, align 8
  %argc180 = getelementptr inbounds %struct.client, ptr %144, i32 0, i32 11
  %145 = load i32, ptr %argc180, align 8
  %146 = load i32, ptr %propagate_flags, align 4
  call void @alsoPropagate(i32 noundef %141, ptr noundef %143, i32 noundef %145, i32 noundef %146)
  br label %if.end181

if.end181:                                        ; preds = %if.then176, %if.end174
  br label %if.end182

if.end182:                                        ; preds = %if.end181, %land.lhs.true128, %land.lhs.true124, %land.lhs.true120, %if.end117
  %147 = load ptr, ptr %c.addr, align 8
  %flags183 = getelementptr inbounds %struct.client, ptr %147, i32 0, i32 1
  %148 = load i64, ptr %flags183, align 8
  %and184 = and i64 %148, -1622017
  store i64 %and184, ptr %flags183, align 8
  %149 = load i64, ptr %client_old_flags, align 8
  %and185 = and i64 %149, 1622016
  %150 = load ptr, ptr %c.addr, align 8
  %flags186 = getelementptr inbounds %struct.client, ptr %150, i32 0, i32 1
  %151 = load i64, ptr %flags186, align 8
  %or187 = or i64 %151, %and185
  store i64 %or187, ptr %flags186, align 8
  %152 = load ptr, ptr %c.addr, align 8
  %cmd188 = getelementptr inbounds %struct.client, ptr %152, i32 0, i32 17
  %153 = load ptr, ptr %cmd188, align 8
  %flags189 = getelementptr inbounds %struct.redisCommand, ptr %153, i32 0, i32 14
  %154 = load i64, ptr %flags189, align 8
  %and190 = and i64 %154, 2
  %tobool191 = icmp ne i64 %and190, 0
  br i1 %tobool191, label %land.lhs.true192, label %if.end216

land.lhs.true192:                                 ; preds = %if.end182
  %155 = load ptr, ptr %c.addr, align 8
  %cmd193 = getelementptr inbounds %struct.client, ptr %155, i32 0, i32 17
  %156 = load ptr, ptr %cmd193, align 8
  %proc194 = getelementptr inbounds %struct.redisCommand, ptr %156, i32 0, i32 12
  %157 = load ptr, ptr %proc194, align 8
  %cmp195 = icmp ne ptr %157, @evalRoCommand
  br i1 %cmp195, label %land.lhs.true196, label %if.end216

land.lhs.true196:                                 ; preds = %land.lhs.true192
  %158 = load ptr, ptr %c.addr, align 8
  %cmd197 = getelementptr inbounds %struct.client, ptr %158, i32 0, i32 17
  %159 = load ptr, ptr %cmd197, align 8
  %proc198 = getelementptr inbounds %struct.redisCommand, ptr %159, i32 0, i32 12
  %160 = load ptr, ptr %proc198, align 8
  %cmp199 = icmp ne ptr %160, @evalShaRoCommand
  br i1 %cmp199, label %land.lhs.true200, label %if.end216

land.lhs.true200:                                 ; preds = %land.lhs.true196
  %161 = load ptr, ptr %c.addr, align 8
  %cmd201 = getelementptr inbounds %struct.client, ptr %161, i32 0, i32 17
  %162 = load ptr, ptr %cmd201, align 8
  %proc202 = getelementptr inbounds %struct.redisCommand, ptr %162, i32 0, i32 12
  %163 = load ptr, ptr %proc202, align 8
  %cmp203 = icmp ne ptr %163, @fcallroCommand
  br i1 %cmp203, label %if.then204, label %if.end216

if.then204:                                       ; preds = %land.lhs.true200
  %164 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %tobool205 = icmp ne ptr %164, null
  br i1 %tobool205, label %land.lhs.true206, label %if.end215

land.lhs.true206:                                 ; preds = %if.then204
  %165 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %flags207 = getelementptr inbounds %struct.client, ptr %165, i32 0, i32 1
  %166 = load i64, ptr %flags207, align 8
  %and208 = and i64 %166, 2147483648
  %tobool209 = icmp ne i64 %and208, 0
  br i1 %tobool209, label %land.lhs.true210, label %if.end215

land.lhs.true210:                                 ; preds = %land.lhs.true206
  %167 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %flags211 = getelementptr inbounds %struct.client, ptr %167, i32 0, i32 1
  %168 = load i64, ptr %flags211, align 8
  %and212 = and i64 %168, 8589934592
  %tobool213 = icmp ne i64 %and212, 0
  br i1 %tobool213, label %if.end215, label %if.then214

if.then214:                                       ; preds = %land.lhs.true210
  %169 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %170 = load ptr, ptr %c.addr, align 8
  call void @trackingRememberKeys(ptr noundef %169, ptr noundef %170)
  br label %if.end215

if.end215:                                        ; preds = %if.then214, %land.lhs.true210, %land.lhs.true206, %if.then204
  br label %if.end216

if.end216:                                        ; preds = %if.end215, %land.lhs.true200, %land.lhs.true196, %land.lhs.true192, %if.end182
  %171 = load ptr, ptr %c.addr, align 8
  %flags217 = getelementptr inbounds %struct.client, ptr %171, i32 0, i32 1
  %172 = load i64, ptr %flags217, align 8
  %and218 = and i64 %172, 16
  %tobool219 = icmp ne i64 %and218, 0
  br i1 %tobool219, label %if.end222, label %if.then220

if.then220:                                       ; preds = %if.end216
  %173 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 89), align 8
  %inc221 = add nsw i64 %173, 1
  store i64 %inc221, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 89), align 8
  br label %if.end222

if.end222:                                        ; preds = %if.then220, %if.end216
  %call223 = call i64 @zmalloc_used_memory()
  store i64 %call223, ptr %zmalloc_used, align 8
  %174 = load i64, ptr %zmalloc_used, align 8
  %175 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  %cmp224 = icmp ugt i64 %174, %175
  br i1 %cmp224, label %if.then225, label %if.end226

if.then225:                                       ; preds = %if.end222
  %176 = load i64, ptr %zmalloc_used, align 8
  store i64 %176, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  br label %if.end226

if.end226:                                        ; preds = %if.then225, %if.end222
  %177 = load ptr, ptr %c.addr, align 8
  call void @afterCommand(ptr noundef %177)
  %178 = load i64, ptr %old_master_repl_offset, align 8
  %179 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %cmp227 = icmp ne i64 %178, %179
  br i1 %cmp227, label %if.then228, label %if.end229

if.then228:                                       ; preds = %if.end226
  %180 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %181 = load ptr, ptr %c.addr, align 8
  %woff = getelementptr inbounds %struct.client, ptr %181, i32 0, i32 56
  store i64 %180, ptr %woff, align 8
  br label %if.end229

if.end229:                                        ; preds = %if.then228, %if.end226
  %182 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 30), align 4
  %tobool230 = icmp ne i32 %182, 0
  br i1 %tobool230, label %if.end234, label %land.lhs.true231

land.lhs.true231:                                 ; preds = %if.end229
  %183 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 34), align 8
  %tobool232 = icmp ne i32 %183, 0
  br i1 %tobool232, label %if.then233, label %if.end234

if.then233:                                       ; preds = %land.lhs.true231
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 34), align 8
  br label %if.end234

if.end234:                                        ; preds = %if.then233, %land.lhs.true231, %if.end229
  %184 = load ptr, ptr %prev_client, align 8
  store ptr %184, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 62), align 8
  ret void
}

declare i32 @monotonicGetType() #2

declare void @replicationFeedMonitors(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef) #2

declare void @freeClientOriginalArgv(ptr noundef) #2

declare void @execCommand(ptr noundef) #2

declare void @evalRoCommand(ptr noundef) #2

declare void @evalShaRoCommand(ptr noundef) #2

declare void @fcallroCommand(ptr noundef) #2

declare void @trackingRememberKeys(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @afterCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  call void @postExecutionUnitOperations()
  call void @trackingHandlePendingKeyInvalidations()
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 65), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %c.addr, align 8
  %reply = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 24
  %2 = load ptr, ptr %reply, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 332), align 8
  call void @listJoin(ptr noundef %2, ptr noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @rejectCommand(ptr noundef %c, ptr noundef %reply) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %reply.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %reply, ptr %reply.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @flagTransaction(ptr noundef %0)
  %1 = load ptr, ptr %c.addr, align 8
  %duration = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 29
  store i64 0, ptr %duration, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 17
  %3 = load ptr, ptr %cmd, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %c.addr, align 8
  %cmd1 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 17
  %5 = load ptr, ptr %cmd1, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 24
  %6 = load i64, ptr %rejected_calls, align 8
  %inc = add nsw i64 %6, 1
  store i64 %inc, ptr %rejected_calls, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %c.addr, align 8
  %cmd2 = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 17
  %8 = load ptr, ptr %cmd2, align 8
  %tobool3 = icmp ne ptr %8, null
  br i1 %tobool3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %9 = load ptr, ptr %c.addr, align 8
  %cmd4 = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 17
  %10 = load ptr, ptr %cmd4, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 12
  %11 = load ptr, ptr %proc, align 8
  %cmp = icmp eq ptr %11, @execCommand
  br i1 %cmp, label %if.then5, label %if.else

if.then5:                                         ; preds = %land.lhs.true
  %12 = load ptr, ptr %c.addr, align 8
  %13 = load ptr, ptr %reply.addr, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %ptr, align 8
  call void @execCommandAbort(ptr noundef %12, ptr noundef %14)
  br label %if.end6

if.else:                                          ; preds = %land.lhs.true, %if.end
  %15 = load ptr, ptr %c.addr, align 8
  %16 = load ptr, ptr %reply.addr, align 8
  call void @addReplyErrorObject(ptr noundef %15, ptr noundef %16)
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then5
  ret void
}

declare void @flagTransaction(ptr noundef) #2

declare void @execCommandAbort(ptr noundef, ptr noundef) #2

declare void @addReplyErrorObject(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @rejectCommandSds(ptr noundef %c, ptr noundef %s) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @flagTransaction(ptr noundef %0)
  %1 = load ptr, ptr %c.addr, align 8
  %duration = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 29
  store i64 0, ptr %duration, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 17
  %3 = load ptr, ptr %cmd, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %c.addr, align 8
  %cmd1 = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 17
  %5 = load ptr, ptr %cmd1, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 24
  %6 = load i64, ptr %rejected_calls, align 8
  %inc = add nsw i64 %6, 1
  store i64 %inc, ptr %rejected_calls, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %c.addr, align 8
  %cmd2 = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 17
  %8 = load ptr, ptr %cmd2, align 8
  %tobool3 = icmp ne ptr %8, null
  br i1 %tobool3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %9 = load ptr, ptr %c.addr, align 8
  %cmd4 = getelementptr inbounds %struct.client, ptr %9, i32 0, i32 17
  %10 = load ptr, ptr %cmd4, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 12
  %11 = load ptr, ptr %proc, align 8
  %cmp = icmp eq ptr %11, @execCommand
  br i1 %cmp, label %if.then5, label %if.else

if.then5:                                         ; preds = %land.lhs.true
  %12 = load ptr, ptr %c.addr, align 8
  %13 = load ptr, ptr %s.addr, align 8
  call void @execCommandAbort(ptr noundef %12, ptr noundef %13)
  %14 = load ptr, ptr %s.addr, align 8
  call void @sdsfree(ptr noundef %14)
  br label %if.end6

if.else:                                          ; preds = %land.lhs.true, %if.end
  %15 = load ptr, ptr %c.addr, align 8
  %16 = load ptr, ptr %s.addr, align 8
  call void @addReplyErrorSds(ptr noundef %15, ptr noundef %16)
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then5
  ret void
}

declare void @addReplyErrorSds(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @rejectCommandFormat(ptr noundef %c, ptr noundef %fmt, ...) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %s = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %call = call ptr @sdsempty()
  %0 = load ptr, ptr %fmt.addr, align 8
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call2 = call ptr @sdscatvprintf(ptr noundef %call, ptr noundef %0, ptr noundef %arraydecay1)
  store ptr %call2, ptr %s, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay3)
  %1 = load ptr, ptr %s, align 8
  %call4 = call ptr @sdsmapchars(ptr noundef %1, ptr noundef @.str.170, ptr noundef @.str.171, i64 noundef 2)
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load ptr, ptr %s, align 8
  call void @rejectCommandSds(ptr noundef %2, ptr noundef %3)
  ret void
}

declare ptr @sdscatvprintf(ptr noundef, ptr noundef, ptr noundef) #2

declare ptr @sdsmapchars(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #2

declare void @trackingHandlePendingKeyInvalidations() #2

declare void @listJoin(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @commandCheckExistence(ptr noundef %c, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  %cmd6 = alloca ptr, align 8
  %args = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 17
  %1 = load ptr, ptr %cmd, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %err.addr, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 12
  %4 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 0
  %5 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %ptr, align 8
  %call = call i32 @isContainerCommandBySds(ptr noundef %6)
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.end3
  %7 = load ptr, ptr %c.addr, align 8
  %argv7 = getelementptr inbounds %struct.client, ptr %7, i32 0, i32 12
  %8 = load ptr, ptr %argv7, align 8
  %arrayidx8 = getelementptr inbounds ptr, ptr %8, i64 0
  %9 = load ptr, ptr %arrayidx8, align 8
  %ptr9 = getelementptr inbounds %struct.redisObject, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %ptr9, align 8
  %call10 = call ptr @sdsnew(ptr noundef %10)
  store ptr %call10, ptr %cmd6, align 8
  %11 = load ptr, ptr %cmd6, align 8
  call void @sdstoupper(ptr noundef %11)
  %call11 = call ptr @sdsnew(ptr noundef null)
  %12 = load ptr, ptr %err.addr, align 8
  store ptr %call11, ptr %12, align 8
  %13 = load ptr, ptr %err.addr, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %c.addr, align 8
  %argv12 = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 12
  %16 = load ptr, ptr %argv12, align 8
  %arrayidx13 = getelementptr inbounds ptr, ptr %16, i64 1
  %17 = load ptr, ptr %arrayidx13, align 8
  %ptr14 = getelementptr inbounds %struct.redisObject, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %ptr14, align 8
  %19 = load ptr, ptr %cmd6, align 8
  %call15 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %14, ptr noundef @.str.172, ptr noundef %18, ptr noundef %19)
  %20 = load ptr, ptr %err.addr, align 8
  store ptr %call15, ptr %20, align 8
  %21 = load ptr, ptr %cmd6, align 8
  call void @sdsfree(ptr noundef %21)
  br label %if.end29

if.else:                                          ; preds = %if.end3
  %call16 = call ptr @sdsempty()
  store ptr %call16, ptr %args, align 8
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %22 = load i32, ptr %i, align 4
  %23 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 11
  %24 = load i32, ptr %argc, align 8
  %cmp = icmp slt i32 %22, %24
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %25 = load ptr, ptr %args, align 8
  %call17 = call i64 @sdslen(ptr noundef %25)
  %cmp18 = icmp ult i64 %call17, 128
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %26 = phi i1 [ false, %for.cond ], [ %cmp18, %land.rhs ]
  br i1 %26, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %27 = load ptr, ptr %args, align 8
  %28 = load ptr, ptr %args, align 8
  %call19 = call i64 @sdslen(ptr noundef %28)
  %conv = trunc i64 %call19 to i32
  %sub = sub nsw i32 128, %conv
  %29 = load ptr, ptr %c.addr, align 8
  %argv20 = getelementptr inbounds %struct.client, ptr %29, i32 0, i32 12
  %30 = load ptr, ptr %argv20, align 8
  %31 = load i32, ptr %i, align 4
  %idxprom = sext i32 %31 to i64
  %arrayidx21 = getelementptr inbounds ptr, ptr %30, i64 %idxprom
  %32 = load ptr, ptr %arrayidx21, align 8
  %ptr22 = getelementptr inbounds %struct.redisObject, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %ptr22, align 8
  %call23 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %27, ptr noundef @.str.173, i32 noundef %sub, ptr noundef %33)
  store ptr %call23, ptr %args, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %34 = load i32, ptr %i, align 4
  %inc = add nsw i32 %34, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !46

for.end:                                          ; preds = %land.end
  %call24 = call ptr @sdsnew(ptr noundef null)
  %35 = load ptr, ptr %err.addr, align 8
  store ptr %call24, ptr %35, align 8
  %36 = load ptr, ptr %err.addr, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = load ptr, ptr %c.addr, align 8
  %argv25 = getelementptr inbounds %struct.client, ptr %38, i32 0, i32 12
  %39 = load ptr, ptr %argv25, align 8
  %arrayidx26 = getelementptr inbounds ptr, ptr %39, i64 0
  %40 = load ptr, ptr %arrayidx26, align 8
  %ptr27 = getelementptr inbounds %struct.redisObject, ptr %40, i32 0, i32 2
  %41 = load ptr, ptr %ptr27, align 8
  %42 = load ptr, ptr %args, align 8
  %call28 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %37, ptr noundef @.str.174, ptr noundef %41, ptr noundef %42)
  %43 = load ptr, ptr %err.addr, align 8
  store ptr %call28, ptr %43, align 8
  %44 = load ptr, ptr %args, align 8
  call void @sdsfree(ptr noundef %44)
  br label %if.end29

if.end29:                                         ; preds = %for.end, %if.then5
  %45 = load ptr, ptr %err.addr, align 8
  %46 = load ptr, ptr %45, align 8
  %call30 = call ptr @sdsmapchars(ptr noundef %46, ptr noundef @.str.170, ptr noundef @.str.171, i64 noundef 2)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.then2, %if.then
  %47 = load i32, ptr %retval, align 4
  ret i32 %47
}

declare void @sdstoupper(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @commandCheckArity(ptr noundef %c, ptr noundef %err) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %err.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 17
  %1 = load ptr, ptr %cmd, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 13
  %2 = load i32, ptr %arity, align 8
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %3 = load ptr, ptr %c.addr, align 8
  %cmd1 = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 17
  %4 = load ptr, ptr %cmd1, align 8
  %arity2 = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 13
  %5 = load i32, ptr %arity2, align 8
  %6 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 11
  %7 = load i32, ptr %argc, align 8
  %cmp3 = icmp ne i32 %5, %7
  br i1 %cmp3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %8 = load ptr, ptr %c.addr, align 8
  %argc4 = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 11
  %9 = load i32, ptr %argc4, align 8
  %10 = load ptr, ptr %c.addr, align 8
  %cmd5 = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 17
  %11 = load ptr, ptr %cmd5, align 8
  %arity6 = getelementptr inbounds %struct.redisCommand, ptr %11, i32 0, i32 13
  %12 = load i32, ptr %arity6, align 8
  %sub = sub nsw i32 0, %12
  %cmp7 = icmp slt i32 %9, %sub
  br i1 %cmp7, label %if.then, label %if.end11

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %err.addr, align 8
  %tobool = icmp ne ptr %13, null
  br i1 %tobool, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.then
  %call = call ptr @sdsnew(ptr noundef null)
  %14 = load ptr, ptr %err.addr, align 8
  store ptr %call, ptr %14, align 8
  %15 = load ptr, ptr %err.addr, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %c.addr, align 8
  %cmd9 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 17
  %18 = load ptr, ptr %cmd9, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 27
  %19 = load ptr, ptr %fullname, align 8
  %call10 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %16, ptr noundef @.str.175, ptr noundef %19)
  %20 = load ptr, ptr %err.addr, align 8
  store ptr %call10, ptr %20, align 8
  br label %if.end

if.end:                                           ; preds = %if.then8, %if.then
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %lor.lhs.false
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.end
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define dso_local i64 @getCommandFlags(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd_flags = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 17
  %1 = load ptr, ptr %cmd, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 14
  %2 = load i64, ptr %flags, align 8
  store i64 %2, ptr %cmd_flags, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %cmd1 = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 17
  %4 = load ptr, ptr %cmd1, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 12
  %5 = load ptr, ptr %proc, align 8
  %cmp = icmp eq ptr %5, @fcallCommand
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load ptr, ptr %c.addr, align 8
  %cmd2 = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 17
  %7 = load ptr, ptr %cmd2, align 8
  %proc3 = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 12
  %8 = load ptr, ptr %proc3, align 8
  %cmp4 = icmp eq ptr %8, @fcallroCommand
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %9 = load ptr, ptr %c.addr, align 8
  %10 = load i64, ptr %cmd_flags, align 8
  %call = call i64 @fcallGetCommandFlags(ptr noundef %9, i64 noundef %10)
  store i64 %call, ptr %cmd_flags, align 8
  br label %if.end22

if.else:                                          ; preds = %lor.lhs.false
  %11 = load ptr, ptr %c.addr, align 8
  %cmd5 = getelementptr inbounds %struct.client, ptr %11, i32 0, i32 17
  %12 = load ptr, ptr %cmd5, align 8
  %proc6 = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 12
  %13 = load ptr, ptr %proc6, align 8
  %cmp7 = icmp eq ptr %13, @evalCommand
  br i1 %cmp7, label %if.then20, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %if.else
  %14 = load ptr, ptr %c.addr, align 8
  %cmd9 = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 17
  %15 = load ptr, ptr %cmd9, align 8
  %proc10 = getelementptr inbounds %struct.redisCommand, ptr %15, i32 0, i32 12
  %16 = load ptr, ptr %proc10, align 8
  %cmp11 = icmp eq ptr %16, @evalRoCommand
  br i1 %cmp11, label %if.then20, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %lor.lhs.false8
  %17 = load ptr, ptr %c.addr, align 8
  %cmd13 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 17
  %18 = load ptr, ptr %cmd13, align 8
  %proc14 = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 12
  %19 = load ptr, ptr %proc14, align 8
  %cmp15 = icmp eq ptr %19, @evalShaCommand
  br i1 %cmp15, label %if.then20, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %lor.lhs.false12
  %20 = load ptr, ptr %c.addr, align 8
  %cmd17 = getelementptr inbounds %struct.client, ptr %20, i32 0, i32 17
  %21 = load ptr, ptr %cmd17, align 8
  %proc18 = getelementptr inbounds %struct.redisCommand, ptr %21, i32 0, i32 12
  %22 = load ptr, ptr %proc18, align 8
  %cmp19 = icmp eq ptr %22, @evalShaRoCommand
  br i1 %cmp19, label %if.then20, label %if.end

if.then20:                                        ; preds = %lor.lhs.false16, %lor.lhs.false12, %lor.lhs.false8, %if.else
  %23 = load ptr, ptr %c.addr, align 8
  %24 = load i64, ptr %cmd_flags, align 8
  %call21 = call i64 @evalGetCommandFlags(ptr noundef %23, i64 noundef %24)
  store i64 %call21, ptr %cmd_flags, align 8
  br label %if.end

if.end:                                           ; preds = %if.then20, %lor.lhs.false16
  br label %if.end22

if.end22:                                         ; preds = %if.end, %if.then
  %25 = load i64, ptr %cmd_flags, align 8
  ret i64 %25
}

declare void @fcallCommand(ptr noundef) #2

declare i64 @fcallGetCommandFlags(ptr noundef, i64 noundef) #2

declare void @evalCommand(ptr noundef) #2

declare void @evalShaCommand(ptr noundef) #2

declare i64 @evalGetCommandFlags(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @processCommand(ptr noundef %c) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %client_reprocessing_command = alloca i32, align 4
  %err = alloca ptr, align 8
  %cmd_flags = alloca i64, align 8
  %is_read_command = alloca i32, align 4
  %is_write_command = alloca i32, align 4
  %is_denyoom_command = alloca i32, align 4
  %is_denystale_command = alloca i32, align 4
  %is_denyloading_command = alloca i32, align 4
  %is_may_replicate_command = alloca i32, align 4
  %is_deny_async_loading_command = alloca i32, align 4
  %obey_client = alloca i32, align 4
  %acl_errpos = alloca i32, align 4
  %acl_retval = alloca i32, align 4
  %msg = alloca ptr, align 8
  %error_code = alloca i32, align 4
  %n = alloca ptr, align 8
  %out_of_memory = alloca i32, align 4
  %reject_cmd_on_oom = alloca i32, align 4
  %deny_write_type = alloca i32, align 4
  %log_interval_ms = alloca i64, align 8
  %err342 = alloca ptr, align 8
  %flags522 = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  %call = call i32 @scriptIsTimedout()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 30), align 4
  %tobool1 = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool4 = icmp ne i64 %conv, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  call void @_serverAssert(ptr noundef @.str.176, ptr noundef @.str.9, i32 noundef 3920)
  call void @abort() #16
  unreachable

1:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %1, %cond.true
  %call5 = call i32 @scriptIsRunning()
  %tobool6 = icmp ne i32 %call5, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %tobool14 = icmp ne i64 %conv13, 0
  br i1 %tobool14, label %cond.true15, label %cond.false16

cond.true15:                                      ; preds = %cond.end
  br label %cond.end17

cond.false16:                                     ; preds = %cond.end
  call void @_serverAssert(ptr noundef @.str.177, ptr noundef @.str.9, i32 noundef 3921)
  call void @abort() #16
  unreachable

2:                                                ; No predecessors!
  br label %cond.end17

cond.end17:                                       ; preds = %2, %cond.true15
  br label %if.end

if.end:                                           ; preds = %cond.end17, %entry
  %3 = load ptr, ptr %c.addr, align 8
  %cmd = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 17
  %4 = load ptr, ptr %cmd, align 8
  %tobool18 = icmp ne ptr %4, null
  %cond = select i1 %tobool18, i32 1, i32 0
  store i32 %cond, ptr %client_reprocessing_command, align 4
  %5 = load i32, ptr %client_reprocessing_command, align 4
  %tobool19 = icmp ne i32 %5, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.end
  %6 = load ptr, ptr %c.addr, align 8
  call void @moduleCallCommandFilters(ptr noundef %6)
  %7 = load ptr, ptr %c.addr, align 8
  %call21 = call i64 @reqresAppendRequest(ptr noundef %7)
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end
  %8 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 12
  %9 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %ptr, align 8
  %call23 = call i32 @strcasecmp(ptr noundef %11, ptr noundef @.str.178) #14
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %lor.lhs.false, label %if.then30

lor.lhs.false:                                    ; preds = %if.end22
  %12 = load ptr, ptr %c.addr, align 8
  %argv25 = getelementptr inbounds %struct.client, ptr %12, i32 0, i32 12
  %13 = load ptr, ptr %argv25, align 8
  %arrayidx26 = getelementptr inbounds ptr, ptr %13, i64 0
  %14 = load ptr, ptr %arrayidx26, align 8
  %ptr27 = getelementptr inbounds %struct.redisObject, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %ptr27, align 8
  %call28 = call i32 @strcasecmp(ptr noundef %15, ptr noundef @.str.179) #14
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %lor.lhs.false, %if.end22
  %16 = load ptr, ptr %c.addr, align 8
  call void @securityWarningCommand(ptr noundef %16)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %lor.lhs.false
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %cmp = icmp ne i32 %17, 0
  br i1 %cmp, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.end31
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %and = and i32 %18, 2
  %tobool33 = icmp ne i32 %and, 0
  br i1 %tobool33, label %if.end35, label %if.then34

if.then34:                                        ; preds = %land.lhs.true
  %19 = load ptr, ptr %c.addr, align 8
  call void @blockPostponeClient(ptr noundef %19)
  store i32 0, ptr %retval, align 4
  br label %return

if.end35:                                         ; preds = %land.lhs.true, %if.end31
  %20 = load i32, ptr %client_reprocessing_command, align 4
  %tobool36 = icmp ne i32 %20, 0
  br i1 %tobool36, label %if.end80, label %if.then37

if.then37:                                        ; preds = %if.end35
  %21 = load ptr, ptr %c.addr, align 8
  %argv38 = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 12
  %22 = load ptr, ptr %argv38, align 8
  %23 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 11
  %24 = load i32, ptr %argc, align 8
  %call39 = call ptr @lookupCommand(ptr noundef %22, i32 noundef %24)
  %25 = load ptr, ptr %c.addr, align 8
  %realcmd = getelementptr inbounds %struct.client, ptr %25, i32 0, i32 19
  store ptr %call39, ptr %realcmd, align 8
  %26 = load ptr, ptr %c.addr, align 8
  %lastcmd = getelementptr inbounds %struct.client, ptr %26, i32 0, i32 18
  store ptr %call39, ptr %lastcmd, align 8
  %27 = load ptr, ptr %c.addr, align 8
  %cmd40 = getelementptr inbounds %struct.client, ptr %27, i32 0, i32 17
  store ptr %call39, ptr %cmd40, align 8
  %28 = load ptr, ptr %c.addr, align 8
  %call41 = call i32 @commandCheckExistence(ptr noundef %28, ptr noundef %err)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.end44, label %if.then43

if.then43:                                        ; preds = %if.then37
  %29 = load ptr, ptr %c.addr, align 8
  %30 = load ptr, ptr %err, align 8
  call void @rejectCommandSds(ptr noundef %29, ptr noundef %30)
  store i32 0, ptr %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.then37
  %31 = load ptr, ptr %c.addr, align 8
  %call45 = call i32 @commandCheckArity(ptr noundef %31, ptr noundef %err)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %if.end44
  %32 = load ptr, ptr %c.addr, align 8
  %33 = load ptr, ptr %err, align 8
  call void @rejectCommandSds(ptr noundef %32, ptr noundef %33)
  store i32 0, ptr %retval, align 4
  br label %return

if.end48:                                         ; preds = %if.end44
  %34 = load ptr, ptr %c.addr, align 8
  %cmd49 = getelementptr inbounds %struct.client, ptr %34, i32 0, i32 17
  %35 = load ptr, ptr %cmd49, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %35, i32 0, i32 14
  %36 = load i64, ptr %flags, align 8
  %and50 = and i64 %36, 1048576
  %tobool51 = icmp ne i64 %and50, 0
  br i1 %tobool51, label %if.then52, label %if.end79

if.then52:                                        ; preds = %if.end48
  %37 = load ptr, ptr %c.addr, align 8
  %cmd53 = getelementptr inbounds %struct.client, ptr %37, i32 0, i32 17
  %38 = load ptr, ptr %cmd53, align 8
  %proc = getelementptr inbounds %struct.redisCommand, ptr %38, i32 0, i32 12
  %39 = load ptr, ptr %proc, align 8
  %cmp54 = icmp eq ptr %39, @debugCommand
  br i1 %cmp54, label %land.lhs.true56, label %lor.lhs.false59

land.lhs.true56:                                  ; preds = %if.then52
  %40 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 79), align 4
  %41 = load ptr, ptr %c.addr, align 8
  %call57 = call i32 @allowProtectedAction(i32 noundef %40, ptr noundef %41)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %lor.lhs.false59, label %if.then67

lor.lhs.false59:                                  ; preds = %land.lhs.true56, %if.then52
  %42 = load ptr, ptr %c.addr, align 8
  %cmd60 = getelementptr inbounds %struct.client, ptr %42, i32 0, i32 17
  %43 = load ptr, ptr %cmd60, align 8
  %proc61 = getelementptr inbounds %struct.redisCommand, ptr %43, i32 0, i32 12
  %44 = load ptr, ptr %proc61, align 8
  %cmp62 = icmp eq ptr %44, @moduleCommand
  br i1 %cmp62, label %land.lhs.true64, label %if.end78

land.lhs.true64:                                  ; preds = %lor.lhs.false59
  %45 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 80), align 8
  %46 = load ptr, ptr %c.addr, align 8
  %call65 = call i32 @allowProtectedAction(i32 noundef %45, ptr noundef %46)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.end78, label %if.then67

if.then67:                                        ; preds = %land.lhs.true64, %land.lhs.true56
  %47 = load ptr, ptr %c.addr, align 8
  %48 = load ptr, ptr %c.addr, align 8
  %cmd68 = getelementptr inbounds %struct.client, ptr %48, i32 0, i32 17
  %49 = load ptr, ptr %cmd68, align 8
  %proc69 = getelementptr inbounds %struct.redisCommand, ptr %49, i32 0, i32 12
  %50 = load ptr, ptr %proc69, align 8
  %cmp70 = icmp eq ptr %50, @debugCommand
  %cond72 = select i1 %cmp70, ptr @.str.181, ptr @.str.15
  %51 = load ptr, ptr %c.addr, align 8
  %cmd73 = getelementptr inbounds %struct.client, ptr %51, i32 0, i32 17
  %52 = load ptr, ptr %cmd73, align 8
  %proc74 = getelementptr inbounds %struct.redisCommand, ptr %52, i32 0, i32 12
  %53 = load ptr, ptr %proc74, align 8
  %cmp75 = icmp eq ptr %53, @debugCommand
  %cond77 = select i1 %cmp75, ptr @.str.182, ptr @.str.183
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef %47, ptr noundef @.str.180, ptr noundef %cond72, ptr noundef %cond77)
  store i32 0, ptr %retval, align 4
  br label %return

if.end78:                                         ; preds = %land.lhs.true64, %lor.lhs.false59
  br label %if.end79

if.end79:                                         ; preds = %if.end78, %if.end48
  br label %if.end80

if.end80:                                         ; preds = %if.end79, %if.end35
  %54 = load ptr, ptr %c.addr, align 8
  %call81 = call i64 @getCommandFlags(ptr noundef %54)
  store i64 %call81, ptr %cmd_flags, align 8
  %55 = load i64, ptr %cmd_flags, align 8
  %and82 = and i64 %55, 2
  %tobool83 = icmp ne i64 %and82, 0
  br i1 %tobool83, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end80
  %56 = load ptr, ptr %c.addr, align 8
  %cmd84 = getelementptr inbounds %struct.client, ptr %56, i32 0, i32 17
  %57 = load ptr, ptr %cmd84, align 8
  %proc85 = getelementptr inbounds %struct.redisCommand, ptr %57, i32 0, i32 12
  %58 = load ptr, ptr %proc85, align 8
  %cmp86 = icmp eq ptr %58, @execCommand
  br i1 %cmp86, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %59 = load ptr, ptr %c.addr, align 8
  %mstate = getelementptr inbounds %struct.client, ptr %59, i32 0, i32 54
  %cmd_flags88 = getelementptr inbounds %struct.multiState, ptr %mstate, i32 0, i32 2
  %60 = load i32, ptr %cmd_flags88, align 4
  %conv89 = sext i32 %60 to i64
  %and90 = and i64 %conv89, 2
  %tobool91 = icmp ne i64 %and90, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %61 = phi i1 [ false, %lor.rhs ], [ %tobool91, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %if.end80
  %62 = phi i1 [ true, %if.end80 ], [ %61, %land.end ]
  %lor.ext = zext i1 %62 to i32
  store i32 %lor.ext, ptr %is_read_command, align 4
  %63 = load i64, ptr %cmd_flags, align 8
  %and92 = and i64 %63, 1
  %tobool93 = icmp ne i64 %and92, 0
  br i1 %tobool93, label %lor.end106, label %lor.rhs94

lor.rhs94:                                        ; preds = %lor.end
  %64 = load ptr, ptr %c.addr, align 8
  %cmd95 = getelementptr inbounds %struct.client, ptr %64, i32 0, i32 17
  %65 = load ptr, ptr %cmd95, align 8
  %proc96 = getelementptr inbounds %struct.redisCommand, ptr %65, i32 0, i32 12
  %66 = load ptr, ptr %proc96, align 8
  %cmp97 = icmp eq ptr %66, @execCommand
  br i1 %cmp97, label %land.rhs99, label %land.end105

land.rhs99:                                       ; preds = %lor.rhs94
  %67 = load ptr, ptr %c.addr, align 8
  %mstate100 = getelementptr inbounds %struct.client, ptr %67, i32 0, i32 54
  %cmd_flags101 = getelementptr inbounds %struct.multiState, ptr %mstate100, i32 0, i32 2
  %68 = load i32, ptr %cmd_flags101, align 4
  %conv102 = sext i32 %68 to i64
  %and103 = and i64 %conv102, 1
  %tobool104 = icmp ne i64 %and103, 0
  br label %land.end105

land.end105:                                      ; preds = %land.rhs99, %lor.rhs94
  %69 = phi i1 [ false, %lor.rhs94 ], [ %tobool104, %land.rhs99 ]
  br label %lor.end106

lor.end106:                                       ; preds = %land.end105, %lor.end
  %70 = phi i1 [ true, %lor.end ], [ %69, %land.end105 ]
  %lor.ext107 = zext i1 %70 to i32
  store i32 %lor.ext107, ptr %is_write_command, align 4
  %71 = load i64, ptr %cmd_flags, align 8
  %and108 = and i64 %71, 4
  %tobool109 = icmp ne i64 %and108, 0
  br i1 %tobool109, label %lor.end122, label %lor.rhs110

lor.rhs110:                                       ; preds = %lor.end106
  %72 = load ptr, ptr %c.addr, align 8
  %cmd111 = getelementptr inbounds %struct.client, ptr %72, i32 0, i32 17
  %73 = load ptr, ptr %cmd111, align 8
  %proc112 = getelementptr inbounds %struct.redisCommand, ptr %73, i32 0, i32 12
  %74 = load ptr, ptr %proc112, align 8
  %cmp113 = icmp eq ptr %74, @execCommand
  br i1 %cmp113, label %land.rhs115, label %land.end121

land.rhs115:                                      ; preds = %lor.rhs110
  %75 = load ptr, ptr %c.addr, align 8
  %mstate116 = getelementptr inbounds %struct.client, ptr %75, i32 0, i32 54
  %cmd_flags117 = getelementptr inbounds %struct.multiState, ptr %mstate116, i32 0, i32 2
  %76 = load i32, ptr %cmd_flags117, align 4
  %conv118 = sext i32 %76 to i64
  %and119 = and i64 %conv118, 4
  %tobool120 = icmp ne i64 %and119, 0
  br label %land.end121

land.end121:                                      ; preds = %land.rhs115, %lor.rhs110
  %77 = phi i1 [ false, %lor.rhs110 ], [ %tobool120, %land.rhs115 ]
  br label %lor.end122

lor.end122:                                       ; preds = %land.end121, %lor.end106
  %78 = phi i1 [ true, %lor.end106 ], [ %77, %land.end121 ]
  %lor.ext123 = zext i1 %78 to i32
  store i32 %lor.ext123, ptr %is_denyoom_command, align 4
  %79 = load i64, ptr %cmd_flags, align 8
  %and124 = and i64 %79, 1024
  %tobool125 = icmp ne i64 %and124, 0
  br i1 %tobool125, label %lor.rhs126, label %lor.end137

lor.rhs126:                                       ; preds = %lor.end122
  %80 = load ptr, ptr %c.addr, align 8
  %cmd127 = getelementptr inbounds %struct.client, ptr %80, i32 0, i32 17
  %81 = load ptr, ptr %cmd127, align 8
  %proc128 = getelementptr inbounds %struct.redisCommand, ptr %81, i32 0, i32 12
  %82 = load ptr, ptr %proc128, align 8
  %cmp129 = icmp eq ptr %82, @execCommand
  br i1 %cmp129, label %land.rhs131, label %land.end136

land.rhs131:                                      ; preds = %lor.rhs126
  %83 = load ptr, ptr %c.addr, align 8
  %mstate132 = getelementptr inbounds %struct.client, ptr %83, i32 0, i32 54
  %cmd_inv_flags = getelementptr inbounds %struct.multiState, ptr %mstate132, i32 0, i32 3
  %84 = load i32, ptr %cmd_inv_flags, align 8
  %conv133 = sext i32 %84 to i64
  %and134 = and i64 %conv133, 1024
  %tobool135 = icmp ne i64 %and134, 0
  br label %land.end136

land.end136:                                      ; preds = %land.rhs131, %lor.rhs126
  %85 = phi i1 [ false, %lor.rhs126 ], [ %tobool135, %land.rhs131 ]
  br label %lor.end137

lor.end137:                                       ; preds = %land.end136, %lor.end122
  %86 = phi i1 [ true, %lor.end122 ], [ %85, %land.end136 ]
  %lor.ext138 = zext i1 %86 to i32
  store i32 %lor.ext138, ptr %is_denystale_command, align 4
  %87 = load i64, ptr %cmd_flags, align 8
  %and139 = and i64 %87, 512
  %tobool140 = icmp ne i64 %and139, 0
  br i1 %tobool140, label %lor.rhs141, label %lor.end153

lor.rhs141:                                       ; preds = %lor.end137
  %88 = load ptr, ptr %c.addr, align 8
  %cmd142 = getelementptr inbounds %struct.client, ptr %88, i32 0, i32 17
  %89 = load ptr, ptr %cmd142, align 8
  %proc143 = getelementptr inbounds %struct.redisCommand, ptr %89, i32 0, i32 12
  %90 = load ptr, ptr %proc143, align 8
  %cmp144 = icmp eq ptr %90, @execCommand
  br i1 %cmp144, label %land.rhs146, label %land.end152

land.rhs146:                                      ; preds = %lor.rhs141
  %91 = load ptr, ptr %c.addr, align 8
  %mstate147 = getelementptr inbounds %struct.client, ptr %91, i32 0, i32 54
  %cmd_inv_flags148 = getelementptr inbounds %struct.multiState, ptr %mstate147, i32 0, i32 3
  %92 = load i32, ptr %cmd_inv_flags148, align 8
  %conv149 = sext i32 %92 to i64
  %and150 = and i64 %conv149, 512
  %tobool151 = icmp ne i64 %and150, 0
  br label %land.end152

land.end152:                                      ; preds = %land.rhs146, %lor.rhs141
  %93 = phi i1 [ false, %lor.rhs141 ], [ %tobool151, %land.rhs146 ]
  br label %lor.end153

lor.end153:                                       ; preds = %land.end152, %lor.end137
  %94 = phi i1 [ true, %lor.end137 ], [ %93, %land.end152 ]
  %lor.ext154 = zext i1 %94 to i32
  store i32 %lor.ext154, ptr %is_denyloading_command, align 4
  %95 = load i64, ptr %cmd_flags, align 8
  %and155 = and i64 %95, 65537
  %tobool156 = icmp ne i64 %and155, 0
  br i1 %tobool156, label %lor.end169, label %lor.rhs157

lor.rhs157:                                       ; preds = %lor.end153
  %96 = load ptr, ptr %c.addr, align 8
  %cmd158 = getelementptr inbounds %struct.client, ptr %96, i32 0, i32 17
  %97 = load ptr, ptr %cmd158, align 8
  %proc159 = getelementptr inbounds %struct.redisCommand, ptr %97, i32 0, i32 12
  %98 = load ptr, ptr %proc159, align 8
  %cmp160 = icmp eq ptr %98, @execCommand
  br i1 %cmp160, label %land.rhs162, label %land.end168

land.rhs162:                                      ; preds = %lor.rhs157
  %99 = load ptr, ptr %c.addr, align 8
  %mstate163 = getelementptr inbounds %struct.client, ptr %99, i32 0, i32 54
  %cmd_flags164 = getelementptr inbounds %struct.multiState, ptr %mstate163, i32 0, i32 2
  %100 = load i32, ptr %cmd_flags164, align 4
  %conv165 = sext i32 %100 to i64
  %and166 = and i64 %conv165, 65537
  %tobool167 = icmp ne i64 %and166, 0
  br label %land.end168

land.end168:                                      ; preds = %land.rhs162, %lor.rhs157
  %101 = phi i1 [ false, %lor.rhs157 ], [ %tobool167, %land.rhs162 ]
  br label %lor.end169

lor.end169:                                       ; preds = %land.end168, %lor.end153
  %102 = phi i1 [ true, %lor.end153 ], [ %101, %land.end168 ]
  %lor.ext170 = zext i1 %102 to i32
  store i32 %lor.ext170, ptr %is_may_replicate_command, align 4
  %103 = load i64, ptr %cmd_flags, align 8
  %and171 = and i64 %103, 8388608
  %tobool172 = icmp ne i64 %and171, 0
  br i1 %tobool172, label %lor.end185, label %lor.rhs173

lor.rhs173:                                       ; preds = %lor.end169
  %104 = load ptr, ptr %c.addr, align 8
  %cmd174 = getelementptr inbounds %struct.client, ptr %104, i32 0, i32 17
  %105 = load ptr, ptr %cmd174, align 8
  %proc175 = getelementptr inbounds %struct.redisCommand, ptr %105, i32 0, i32 12
  %106 = load ptr, ptr %proc175, align 8
  %cmp176 = icmp eq ptr %106, @execCommand
  br i1 %cmp176, label %land.rhs178, label %land.end184

land.rhs178:                                      ; preds = %lor.rhs173
  %107 = load ptr, ptr %c.addr, align 8
  %mstate179 = getelementptr inbounds %struct.client, ptr %107, i32 0, i32 54
  %cmd_flags180 = getelementptr inbounds %struct.multiState, ptr %mstate179, i32 0, i32 2
  %108 = load i32, ptr %cmd_flags180, align 4
  %conv181 = sext i32 %108 to i64
  %and182 = and i64 %conv181, 8388608
  %tobool183 = icmp ne i64 %and182, 0
  br label %land.end184

land.end184:                                      ; preds = %land.rhs178, %lor.rhs173
  %109 = phi i1 [ false, %lor.rhs173 ], [ %tobool183, %land.rhs178 ]
  br label %lor.end185

lor.end185:                                       ; preds = %land.end184, %lor.end169
  %110 = phi i1 [ true, %lor.end169 ], [ %109, %land.end184 ]
  %lor.ext186 = zext i1 %110 to i32
  store i32 %lor.ext186, ptr %is_deny_async_loading_command, align 4
  %111 = load ptr, ptr %c.addr, align 8
  %call187 = call i32 @mustObeyClient(ptr noundef %111)
  store i32 %call187, ptr %obey_client, align 4
  %112 = load ptr, ptr %c.addr, align 8
  %call188 = call i32 @authRequired(ptr noundef %112)
  %tobool189 = icmp ne i32 %call188, 0
  br i1 %tobool189, label %if.then190, label %if.end197

if.then190:                                       ; preds = %lor.end185
  %113 = load ptr, ptr %c.addr, align 8
  %cmd191 = getelementptr inbounds %struct.client, ptr %113, i32 0, i32 17
  %114 = load ptr, ptr %cmd191, align 8
  %flags192 = getelementptr inbounds %struct.redisCommand, ptr %114, i32 0, i32 14
  %115 = load i64, ptr %flags192, align 8
  %and193 = and i64 %115, 32768
  %tobool194 = icmp ne i64 %and193, 0
  br i1 %tobool194, label %if.end196, label %if.then195

if.then195:                                       ; preds = %if.then190
  %116 = load ptr, ptr %c.addr, align 8
  %117 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 27), align 8
  call void @rejectCommand(ptr noundef %116, ptr noundef %117)
  store i32 0, ptr %retval, align 4
  br label %return

if.end196:                                        ; preds = %if.then190
  br label %if.end197

if.end197:                                        ; preds = %if.end196, %lor.end185
  %118 = load ptr, ptr %c.addr, align 8
  %flags198 = getelementptr inbounds %struct.client, ptr %118, i32 0, i32 1
  %119 = load i64, ptr %flags198, align 8
  %and199 = and i64 %119, 8
  %tobool200 = icmp ne i64 %and199, 0
  br i1 %tobool200, label %land.lhs.true201, label %if.end207

land.lhs.true201:                                 ; preds = %if.end197
  %120 = load ptr, ptr %c.addr, align 8
  %cmd202 = getelementptr inbounds %struct.client, ptr %120, i32 0, i32 17
  %121 = load ptr, ptr %cmd202, align 8
  %flags203 = getelementptr inbounds %struct.redisCommand, ptr %121, i32 0, i32 14
  %122 = load i64, ptr %flags203, align 8
  %and204 = and i64 %122, 16777216
  %tobool205 = icmp ne i64 %and204, 0
  br i1 %tobool205, label %if.then206, label %if.end207

if.then206:                                       ; preds = %land.lhs.true201
  %123 = load ptr, ptr %c.addr, align 8
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef %123, ptr noundef @.str.184)
  store i32 0, ptr %retval, align 4
  br label %return

if.end207:                                        ; preds = %land.lhs.true201, %if.end197
  %124 = load ptr, ptr %c.addr, align 8
  %call208 = call i32 @ACLCheckAllPerm(ptr noundef %124, ptr noundef %acl_errpos)
  store i32 %call208, ptr %acl_retval, align 4
  %125 = load i32, ptr %acl_retval, align 4
  %cmp209 = icmp ne i32 %125, 0
  br i1 %cmp209, label %if.then211, label %if.end221

if.then211:                                       ; preds = %if.end207
  %126 = load ptr, ptr %c.addr, align 8
  %127 = load i32, ptr %acl_retval, align 4
  %128 = load ptr, ptr %c.addr, align 8
  %flags212 = getelementptr inbounds %struct.client, ptr %128, i32 0, i32 1
  %129 = load i64, ptr %flags212, align 8
  %and213 = and i64 %129, 8
  %tobool214 = icmp ne i64 %and213, 0
  %cond215 = select i1 %tobool214, i32 2, i32 0
  %130 = load i32, ptr %acl_errpos, align 4
  call void @addACLLogEntry(ptr noundef %126, i32 noundef %127, i32 noundef %cond215, i32 noundef %130, ptr noundef null, ptr noundef null)
  %131 = load i32, ptr %acl_retval, align 4
  %132 = load ptr, ptr %c.addr, align 8
  %user = getelementptr inbounds %struct.client, ptr %132, i32 0, i32 20
  %133 = load ptr, ptr %user, align 8
  %134 = load ptr, ptr %c.addr, align 8
  %cmd216 = getelementptr inbounds %struct.client, ptr %134, i32 0, i32 17
  %135 = load ptr, ptr %cmd216, align 8
  %136 = load ptr, ptr %c.addr, align 8
  %argv217 = getelementptr inbounds %struct.client, ptr %136, i32 0, i32 12
  %137 = load ptr, ptr %argv217, align 8
  %138 = load i32, ptr %acl_errpos, align 4
  %idxprom = sext i32 %138 to i64
  %arrayidx218 = getelementptr inbounds ptr, ptr %137, i64 %idxprom
  %139 = load ptr, ptr %arrayidx218, align 8
  %ptr219 = getelementptr inbounds %struct.redisObject, ptr %139, i32 0, i32 2
  %140 = load ptr, ptr %ptr219, align 8
  %call220 = call ptr @getAclErrorMessage(i32 noundef %131, ptr noundef %133, ptr noundef %135, ptr noundef %140, i32 noundef 0)
  store ptr %call220, ptr %msg, align 8
  %141 = load ptr, ptr %c.addr, align 8
  %142 = load ptr, ptr %msg, align 8
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef %141, ptr noundef @.str.185, ptr noundef %142)
  %143 = load ptr, ptr %msg, align 8
  call void @sdsfree(ptr noundef %143)
  store i32 0, ptr %retval, align 4
  br label %return

if.end221:                                        ; preds = %if.end207
  %144 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool222 = icmp ne i32 %144, 0
  br i1 %tobool222, label %land.lhs.true223, label %if.end260

land.lhs.true223:                                 ; preds = %if.end221
  %145 = load ptr, ptr %c.addr, align 8
  %call224 = call i32 @mustObeyClient(ptr noundef %145)
  %tobool225 = icmp ne i32 %call224, 0
  br i1 %tobool225, label %if.end260, label %land.lhs.true226

land.lhs.true226:                                 ; preds = %land.lhs.true223
  %146 = load ptr, ptr %c.addr, align 8
  %cmd227 = getelementptr inbounds %struct.client, ptr %146, i32 0, i32 17
  %147 = load ptr, ptr %cmd227, align 8
  %flags228 = getelementptr inbounds %struct.redisCommand, ptr %147, i32 0, i32 14
  %148 = load i64, ptr %flags228, align 8
  %and229 = and i64 %148, 33554432
  %tobool230 = icmp ne i64 %and229, 0
  br i1 %tobool230, label %if.then240, label %land.lhs.true231

land.lhs.true231:                                 ; preds = %land.lhs.true226
  %149 = load ptr, ptr %c.addr, align 8
  %cmd232 = getelementptr inbounds %struct.client, ptr %149, i32 0, i32 17
  %150 = load ptr, ptr %cmd232, align 8
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %150, i32 0, i32 17
  %151 = load i32, ptr %key_specs_num, align 8
  %cmp233 = icmp eq i32 %151, 0
  br i1 %cmp233, label %land.lhs.true235, label %if.then240

land.lhs.true235:                                 ; preds = %land.lhs.true231
  %152 = load ptr, ptr %c.addr, align 8
  %cmd236 = getelementptr inbounds %struct.client, ptr %152, i32 0, i32 17
  %153 = load ptr, ptr %cmd236, align 8
  %proc237 = getelementptr inbounds %struct.redisCommand, ptr %153, i32 0, i32 12
  %154 = load ptr, ptr %proc237, align 8
  %cmp238 = icmp ne ptr %154, @execCommand
  br i1 %cmp238, label %if.end260, label %if.then240

if.then240:                                       ; preds = %land.lhs.true235, %land.lhs.true231, %land.lhs.true226
  %155 = load ptr, ptr %c.addr, align 8
  %156 = load ptr, ptr %c.addr, align 8
  %cmd241 = getelementptr inbounds %struct.client, ptr %156, i32 0, i32 17
  %157 = load ptr, ptr %cmd241, align 8
  %158 = load ptr, ptr %c.addr, align 8
  %argv242 = getelementptr inbounds %struct.client, ptr %158, i32 0, i32 12
  %159 = load ptr, ptr %argv242, align 8
  %160 = load ptr, ptr %c.addr, align 8
  %argc243 = getelementptr inbounds %struct.client, ptr %160, i32 0, i32 11
  %161 = load i32, ptr %argc243, align 8
  %162 = load ptr, ptr %c.addr, align 8
  %slot = getelementptr inbounds %struct.client, ptr %162, i32 0, i32 30
  %call244 = call ptr @getNodeByQuery(ptr noundef %155, ptr noundef %157, ptr noundef %159, i32 noundef %161, ptr noundef %slot, ptr noundef %error_code)
  store ptr %call244, ptr %n, align 8
  %163 = load ptr, ptr %n, align 8
  %cmp245 = icmp eq ptr %163, null
  br i1 %cmp245, label %if.then250, label %lor.lhs.false247

lor.lhs.false247:                                 ; preds = %if.then240
  %164 = load ptr, ptr %n, align 8
  %call248 = call i32 @clusterNodeIsMyself(ptr noundef %164)
  %tobool249 = icmp ne i32 %call248, 0
  br i1 %tobool249, label %if.end259, label %if.then250

if.then250:                                       ; preds = %lor.lhs.false247, %if.then240
  %165 = load ptr, ptr %c.addr, align 8
  %cmd251 = getelementptr inbounds %struct.client, ptr %165, i32 0, i32 17
  %166 = load ptr, ptr %cmd251, align 8
  %proc252 = getelementptr inbounds %struct.redisCommand, ptr %166, i32 0, i32 12
  %167 = load ptr, ptr %proc252, align 8
  %cmp253 = icmp eq ptr %167, @execCommand
  br i1 %cmp253, label %if.then255, label %if.else

if.then255:                                       ; preds = %if.then250
  %168 = load ptr, ptr %c.addr, align 8
  call void @discardTransaction(ptr noundef %168)
  br label %if.end256

if.else:                                          ; preds = %if.then250
  %169 = load ptr, ptr %c.addr, align 8
  call void @flagTransaction(ptr noundef %169)
  br label %if.end256

if.end256:                                        ; preds = %if.else, %if.then255
  %170 = load ptr, ptr %c.addr, align 8
  %171 = load ptr, ptr %n, align 8
  %172 = load ptr, ptr %c.addr, align 8
  %slot257 = getelementptr inbounds %struct.client, ptr %172, i32 0, i32 30
  %173 = load i32, ptr %slot257, align 8
  %174 = load i32, ptr %error_code, align 4
  call void @clusterRedirectClient(ptr noundef %170, ptr noundef %171, i32 noundef %173, i32 noundef %174)
  %175 = load ptr, ptr %c.addr, align 8
  %cmd258 = getelementptr inbounds %struct.client, ptr %175, i32 0, i32 17
  %176 = load ptr, ptr %cmd258, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %176, i32 0, i32 24
  %177 = load i64, ptr %rejected_calls, align 8
  %inc = add nsw i64 %177, 1
  store i64 %inc, ptr %rejected_calls, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end259:                                        ; preds = %lor.lhs.false247
  br label %if.end260

if.end260:                                        ; preds = %if.end259, %land.lhs.true235, %land.lhs.true223, %if.end221
  call void @evictClients()
  %178 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %cmp261 = icmp eq ptr %178, null
  br i1 %cmp261, label %if.then263, label %if.end264

if.then263:                                       ; preds = %if.end260
  store i32 -1, ptr %retval, align 4
  br label %return

if.end264:                                        ; preds = %if.end260
  %179 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  %tobool265 = icmp ne i64 %179, 0
  br i1 %tobool265, label %land.lhs.true266, label %if.end307

land.lhs.true266:                                 ; preds = %if.end264
  %call267 = call i32 @isInsideYieldingLongCommand()
  %tobool268 = icmp ne i32 %call267, 0
  br i1 %tobool268, label %if.end307, label %if.then269

if.then269:                                       ; preds = %land.lhs.true266
  %call270 = call i32 @performEvictions()
  %cmp271 = icmp eq i32 %call270, 2
  %conv272 = zext i1 %cmp271 to i32
  store i32 %conv272, ptr %out_of_memory, align 4
  call void @trackingHandlePendingKeyInvalidations()
  %180 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 61), align 8
  %cmp273 = icmp eq ptr %180, null
  br i1 %cmp273, label %if.then275, label %if.end276

if.then275:                                       ; preds = %if.then269
  store i32 -1, ptr %retval, align 4
  br label %return

if.end276:                                        ; preds = %if.then269
  %181 = load i32, ptr %is_denyoom_command, align 4
  store i32 %181, ptr %reject_cmd_on_oom, align 4
  %182 = load ptr, ptr %c.addr, align 8
  %flags277 = getelementptr inbounds %struct.client, ptr %182, i32 0, i32 1
  %183 = load i64, ptr %flags277, align 8
  %and278 = and i64 %183, 8
  %tobool279 = icmp ne i64 %and278, 0
  br i1 %tobool279, label %land.lhs.true280, label %if.end301

land.lhs.true280:                                 ; preds = %if.end276
  %184 = load ptr, ptr %c.addr, align 8
  %cmd281 = getelementptr inbounds %struct.client, ptr %184, i32 0, i32 17
  %185 = load ptr, ptr %cmd281, align 8
  %proc282 = getelementptr inbounds %struct.redisCommand, ptr %185, i32 0, i32 12
  %186 = load ptr, ptr %proc282, align 8
  %cmp283 = icmp ne ptr %186, @execCommand
  br i1 %cmp283, label %land.lhs.true285, label %if.end301

land.lhs.true285:                                 ; preds = %land.lhs.true280
  %187 = load ptr, ptr %c.addr, align 8
  %cmd286 = getelementptr inbounds %struct.client, ptr %187, i32 0, i32 17
  %188 = load ptr, ptr %cmd286, align 8
  %proc287 = getelementptr inbounds %struct.redisCommand, ptr %188, i32 0, i32 12
  %189 = load ptr, ptr %proc287, align 8
  %cmp288 = icmp ne ptr %189, @discardCommand
  br i1 %cmp288, label %land.lhs.true290, label %if.end301

land.lhs.true290:                                 ; preds = %land.lhs.true285
  %190 = load ptr, ptr %c.addr, align 8
  %cmd291 = getelementptr inbounds %struct.client, ptr %190, i32 0, i32 17
  %191 = load ptr, ptr %cmd291, align 8
  %proc292 = getelementptr inbounds %struct.redisCommand, ptr %191, i32 0, i32 12
  %192 = load ptr, ptr %proc292, align 8
  %cmp293 = icmp ne ptr %192, @quitCommand
  br i1 %cmp293, label %land.lhs.true295, label %if.end301

land.lhs.true295:                                 ; preds = %land.lhs.true290
  %193 = load ptr, ptr %c.addr, align 8
  %cmd296 = getelementptr inbounds %struct.client, ptr %193, i32 0, i32 17
  %194 = load ptr, ptr %cmd296, align 8
  %proc297 = getelementptr inbounds %struct.redisCommand, ptr %194, i32 0, i32 12
  %195 = load ptr, ptr %proc297, align 8
  %cmp298 = icmp ne ptr %195, @resetCommand
  br i1 %cmp298, label %if.then300, label %if.end301

if.then300:                                       ; preds = %land.lhs.true295
  store i32 1, ptr %reject_cmd_on_oom, align 4
  br label %if.end301

if.end301:                                        ; preds = %if.then300, %land.lhs.true295, %land.lhs.true290, %land.lhs.true285, %land.lhs.true280, %if.end276
  %196 = load i32, ptr %out_of_memory, align 4
  %tobool302 = icmp ne i32 %196, 0
  br i1 %tobool302, label %land.lhs.true303, label %if.end306

land.lhs.true303:                                 ; preds = %if.end301
  %197 = load i32, ptr %reject_cmd_on_oom, align 4
  %tobool304 = icmp ne i32 %197, 0
  br i1 %tobool304, label %if.then305, label %if.end306

if.then305:                                       ; preds = %land.lhs.true303
  %198 = load ptr, ptr %c.addr, align 8
  %199 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 30), align 8
  call void @rejectCommand(ptr noundef %198, ptr noundef %199)
  store i32 0, ptr %retval, align 4
  br label %return

if.end306:                                        ; preds = %land.lhs.true303, %if.end301
  %200 = load i32, ptr %out_of_memory, align 4
  store i32 %200, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 386), align 8
  br label %if.end307

if.end307:                                        ; preds = %if.end306, %land.lhs.true266, %if.end264
  %201 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 329), align 8
  %tobool308 = icmp ne i32 %201, 0
  br i1 %tobool308, label %if.then309, label %if.end310

if.then309:                                       ; preds = %if.end307
  call void @trackingLimitUsedSlots()
  br label %if.end310

if.end310:                                        ; preds = %if.then309, %if.end307
  %call311 = call i32 @writeCommandsDeniedByDiskError()
  store i32 %call311, ptr %deny_write_type, align 4
  %202 = load i32, ptr %deny_write_type, align 4
  %cmp312 = icmp ne i32 %202, 0
  br i1 %cmp312, label %land.lhs.true314, label %if.end346

land.lhs.true314:                                 ; preds = %if.end310
  %203 = load i32, ptr %is_write_command, align 4
  %tobool315 = icmp ne i32 %203, 0
  br i1 %tobool315, label %if.then321, label %lor.lhs.false316

lor.lhs.false316:                                 ; preds = %land.lhs.true314
  %204 = load ptr, ptr %c.addr, align 8
  %cmd317 = getelementptr inbounds %struct.client, ptr %204, i32 0, i32 17
  %205 = load ptr, ptr %cmd317, align 8
  %proc318 = getelementptr inbounds %struct.redisCommand, ptr %205, i32 0, i32 12
  %206 = load ptr, ptr %proc318, align 8
  %cmp319 = icmp eq ptr %206, @pingCommand
  br i1 %cmp319, label %if.then321, label %if.end346

if.then321:                                       ; preds = %lor.lhs.false316, %land.lhs.true314
  %207 = load i32, ptr %obey_client, align 4
  %tobool322 = icmp ne i32 %207, 0
  br i1 %tobool322, label %if.then323, label %if.else341

if.then323:                                       ; preds = %if.then321
  %208 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 307), align 4
  %tobool324 = icmp ne i32 %208, 0
  br i1 %tobool324, label %if.else331, label %land.lhs.true325

land.lhs.true325:                                 ; preds = %if.then323
  %209 = load ptr, ptr %c.addr, align 8
  %cmd326 = getelementptr inbounds %struct.client, ptr %209, i32 0, i32 17
  %210 = load ptr, ptr %cmd326, align 8
  %proc327 = getelementptr inbounds %struct.redisCommand, ptr %210, i32 0, i32 12
  %211 = load ptr, ptr %proc327, align 8
  %cmp328 = icmp ne ptr %211, @pingCommand
  br i1 %cmp328, label %if.then330, label %if.else331

if.then330:                                       ; preds = %land.lhs.true325
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 4118, ptr noundef @.str.186)
  call void @abort() #16
  unreachable

if.else331:                                       ; preds = %land.lhs.true325, %if.then323
  store i64 10000, ptr %log_interval_ms, align 8
  %212 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  %213 = load i64, ptr @processCommand.last_log_time_ms, align 8
  %add = add nsw i64 %213, 10000
  %cmp332 = icmp sgt i64 %212, %add
  br i1 %cmp332, label %if.then334, label %if.end339

if.then334:                                       ; preds = %if.else331
  %214 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 352), align 8
  store i64 %214, ptr @processCommand.last_log_time_ms, align 8
  br label %do.body

do.body:                                          ; preds = %if.then334
  %215 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp335 = icmp slt i32 3, %215
  br i1 %cmp335, label %if.then337, label %if.end338

if.then337:                                       ; preds = %do.body
  br label %do.end

if.end338:                                        ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.187)
  br label %do.end

do.end:                                           ; preds = %if.end338, %if.then337
  br label %if.end339

if.end339:                                        ; preds = %do.end, %if.else331
  br label %if.end340

if.end340:                                        ; preds = %if.end339
  br label %if.end345

if.else341:                                       ; preds = %if.then321
  %216 = load i32, ptr %deny_write_type, align 4
  %call343 = call ptr @writeCommandsGetDiskErrorMessage(i32 noundef %216)
  store ptr %call343, ptr %err342, align 8
  %217 = load ptr, ptr %err342, align 8
  %218 = load ptr, ptr %err342, align 8
  %call344 = call i64 @sdslen(ptr noundef %218)
  %sub = sub i64 %call344, 2
  call void @sdssubstr(ptr noundef %217, i64 noundef 0, i64 noundef %sub)
  %219 = load ptr, ptr %c.addr, align 8
  %220 = load ptr, ptr %err342, align 8
  call void @rejectCommandSds(ptr noundef %219, ptr noundef %220)
  store i32 0, ptr %retval, align 4
  br label %return

if.end345:                                        ; preds = %if.end340
  br label %if.end346

if.end346:                                        ; preds = %if.end345, %lor.lhs.false316, %if.end310
  %221 = load i32, ptr %is_write_command, align 4
  %tobool347 = icmp ne i32 %221, 0
  br i1 %tobool347, label %land.lhs.true348, label %if.end352

land.lhs.true348:                                 ; preds = %if.end346
  %call349 = call i32 @checkGoodReplicasStatus()
  %tobool350 = icmp ne i32 %call349, 0
  br i1 %tobool350, label %if.end352, label %if.then351

if.then351:                                       ; preds = %land.lhs.true348
  %222 = load ptr, ptr %c.addr, align 8
  %223 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 28), align 8
  call void @rejectCommand(ptr noundef %222, ptr noundef %223)
  store i32 0, ptr %retval, align 4
  br label %return

if.end352:                                        ; preds = %land.lhs.true348, %if.end346
  %224 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool353 = icmp ne ptr %224, null
  br i1 %tobool353, label %land.lhs.true354, label %if.end361

land.lhs.true354:                                 ; preds = %if.end352
  %225 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 298), align 4
  %tobool355 = icmp ne i32 %225, 0
  br i1 %tobool355, label %land.lhs.true356, label %if.end361

land.lhs.true356:                                 ; preds = %land.lhs.true354
  %226 = load i32, ptr %obey_client, align 4
  %tobool357 = icmp ne i32 %226, 0
  br i1 %tobool357, label %if.end361, label %land.lhs.true358

land.lhs.true358:                                 ; preds = %land.lhs.true356
  %227 = load i32, ptr %is_write_command, align 4
  %tobool359 = icmp ne i32 %227, 0
  br i1 %tobool359, label %if.then360, label %if.end361

if.then360:                                       ; preds = %land.lhs.true358
  %228 = load ptr, ptr %c.addr, align 8
  %229 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 25), align 8
  call void @rejectCommand(ptr noundef %228, ptr noundef %229)
  store i32 0, ptr %retval, align 4
  br label %return

if.end361:                                        ; preds = %land.lhs.true358, %land.lhs.true356, %land.lhs.true354, %if.end352
  %230 = load ptr, ptr %c.addr, align 8
  %flags362 = getelementptr inbounds %struct.client, ptr %230, i32 0, i32 1
  %231 = load i64, ptr %flags362, align 8
  %and363 = and i64 %231, 262144
  %tobool364 = icmp ne i64 %and363, 0
  br i1 %tobool364, label %land.lhs.true365, label %if.end415

land.lhs.true365:                                 ; preds = %if.end361
  %232 = load ptr, ptr %c.addr, align 8
  %resp = getelementptr inbounds %struct.client, ptr %232, i32 0, i32 3
  %233 = load i32, ptr %resp, align 8
  %cmp366 = icmp eq i32 %233, 2
  br i1 %cmp366, label %land.lhs.true368, label %if.end415

land.lhs.true368:                                 ; preds = %land.lhs.true365
  %234 = load ptr, ptr %c.addr, align 8
  %cmd369 = getelementptr inbounds %struct.client, ptr %234, i32 0, i32 17
  %235 = load ptr, ptr %cmd369, align 8
  %proc370 = getelementptr inbounds %struct.redisCommand, ptr %235, i32 0, i32 12
  %236 = load ptr, ptr %proc370, align 8
  %cmp371 = icmp ne ptr %236, @pingCommand
  br i1 %cmp371, label %land.lhs.true373, label %if.end415

land.lhs.true373:                                 ; preds = %land.lhs.true368
  %237 = load ptr, ptr %c.addr, align 8
  %cmd374 = getelementptr inbounds %struct.client, ptr %237, i32 0, i32 17
  %238 = load ptr, ptr %cmd374, align 8
  %proc375 = getelementptr inbounds %struct.redisCommand, ptr %238, i32 0, i32 12
  %239 = load ptr, ptr %proc375, align 8
  %cmp376 = icmp ne ptr %239, @subscribeCommand
  br i1 %cmp376, label %land.lhs.true378, label %if.end415

land.lhs.true378:                                 ; preds = %land.lhs.true373
  %240 = load ptr, ptr %c.addr, align 8
  %cmd379 = getelementptr inbounds %struct.client, ptr %240, i32 0, i32 17
  %241 = load ptr, ptr %cmd379, align 8
  %proc380 = getelementptr inbounds %struct.redisCommand, ptr %241, i32 0, i32 12
  %242 = load ptr, ptr %proc380, align 8
  %cmp381 = icmp ne ptr %242, @ssubscribeCommand
  br i1 %cmp381, label %land.lhs.true383, label %if.end415

land.lhs.true383:                                 ; preds = %land.lhs.true378
  %243 = load ptr, ptr %c.addr, align 8
  %cmd384 = getelementptr inbounds %struct.client, ptr %243, i32 0, i32 17
  %244 = load ptr, ptr %cmd384, align 8
  %proc385 = getelementptr inbounds %struct.redisCommand, ptr %244, i32 0, i32 12
  %245 = load ptr, ptr %proc385, align 8
  %cmp386 = icmp ne ptr %245, @unsubscribeCommand
  br i1 %cmp386, label %land.lhs.true388, label %if.end415

land.lhs.true388:                                 ; preds = %land.lhs.true383
  %246 = load ptr, ptr %c.addr, align 8
  %cmd389 = getelementptr inbounds %struct.client, ptr %246, i32 0, i32 17
  %247 = load ptr, ptr %cmd389, align 8
  %proc390 = getelementptr inbounds %struct.redisCommand, ptr %247, i32 0, i32 12
  %248 = load ptr, ptr %proc390, align 8
  %cmp391 = icmp ne ptr %248, @sunsubscribeCommand
  br i1 %cmp391, label %land.lhs.true393, label %if.end415

land.lhs.true393:                                 ; preds = %land.lhs.true388
  %249 = load ptr, ptr %c.addr, align 8
  %cmd394 = getelementptr inbounds %struct.client, ptr %249, i32 0, i32 17
  %250 = load ptr, ptr %cmd394, align 8
  %proc395 = getelementptr inbounds %struct.redisCommand, ptr %250, i32 0, i32 12
  %251 = load ptr, ptr %proc395, align 8
  %cmp396 = icmp ne ptr %251, @psubscribeCommand
  br i1 %cmp396, label %land.lhs.true398, label %if.end415

land.lhs.true398:                                 ; preds = %land.lhs.true393
  %252 = load ptr, ptr %c.addr, align 8
  %cmd399 = getelementptr inbounds %struct.client, ptr %252, i32 0, i32 17
  %253 = load ptr, ptr %cmd399, align 8
  %proc400 = getelementptr inbounds %struct.redisCommand, ptr %253, i32 0, i32 12
  %254 = load ptr, ptr %proc400, align 8
  %cmp401 = icmp ne ptr %254, @punsubscribeCommand
  br i1 %cmp401, label %land.lhs.true403, label %if.end415

land.lhs.true403:                                 ; preds = %land.lhs.true398
  %255 = load ptr, ptr %c.addr, align 8
  %cmd404 = getelementptr inbounds %struct.client, ptr %255, i32 0, i32 17
  %256 = load ptr, ptr %cmd404, align 8
  %proc405 = getelementptr inbounds %struct.redisCommand, ptr %256, i32 0, i32 12
  %257 = load ptr, ptr %proc405, align 8
  %cmp406 = icmp ne ptr %257, @quitCommand
  br i1 %cmp406, label %land.lhs.true408, label %if.end415

land.lhs.true408:                                 ; preds = %land.lhs.true403
  %258 = load ptr, ptr %c.addr, align 8
  %cmd409 = getelementptr inbounds %struct.client, ptr %258, i32 0, i32 17
  %259 = load ptr, ptr %cmd409, align 8
  %proc410 = getelementptr inbounds %struct.redisCommand, ptr %259, i32 0, i32 12
  %260 = load ptr, ptr %proc410, align 8
  %cmp411 = icmp ne ptr %260, @resetCommand
  br i1 %cmp411, label %if.then413, label %if.end415

if.then413:                                       ; preds = %land.lhs.true408
  %261 = load ptr, ptr %c.addr, align 8
  %262 = load ptr, ptr %c.addr, align 8
  %cmd414 = getelementptr inbounds %struct.client, ptr %262, i32 0, i32 17
  %263 = load ptr, ptr %cmd414, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %263, i32 0, i32 27
  %264 = load ptr, ptr %fullname, align 8
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef %261, ptr noundef @.str.188, ptr noundef %264)
  store i32 0, ptr %retval, align 4
  br label %return

if.end415:                                        ; preds = %land.lhs.true408, %land.lhs.true403, %land.lhs.true398, %land.lhs.true393, %land.lhs.true388, %land.lhs.true383, %land.lhs.true378, %land.lhs.true373, %land.lhs.true368, %land.lhs.true365, %if.end361
  %265 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool416 = icmp ne ptr %265, null
  br i1 %tobool416, label %land.lhs.true417, label %if.end426

land.lhs.true417:                                 ; preds = %if.end415
  %266 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp418 = icmp ne i32 %266, 12
  br i1 %cmp418, label %land.lhs.true420, label %if.end426

land.lhs.true420:                                 ; preds = %land.lhs.true417
  %267 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 297), align 8
  %cmp421 = icmp eq i32 %267, 0
  br i1 %cmp421, label %land.lhs.true423, label %if.end426

land.lhs.true423:                                 ; preds = %land.lhs.true420
  %268 = load i32, ptr %is_denystale_command, align 4
  %tobool424 = icmp ne i32 %268, 0
  br i1 %tobool424, label %if.then425, label %if.end426

if.then425:                                       ; preds = %land.lhs.true423
  %269 = load ptr, ptr %c.addr, align 8
  %270 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 24), align 8
  call void @rejectCommand(ptr noundef %269, ptr noundef %270)
  store i32 0, ptr %retval, align 4
  br label %return

if.end426:                                        ; preds = %land.lhs.true423, %land.lhs.true420, %land.lhs.true417, %if.end415
  %271 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool427 = icmp ne i32 %271, 0
  br i1 %tobool427, label %land.lhs.true428, label %if.end433

land.lhs.true428:                                 ; preds = %if.end426
  %272 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 82), align 8
  %tobool429 = icmp ne i32 %272, 0
  br i1 %tobool429, label %if.end433, label %land.lhs.true430

land.lhs.true430:                                 ; preds = %land.lhs.true428
  %273 = load i32, ptr %is_denyloading_command, align 4
  %tobool431 = icmp ne i32 %273, 0
  br i1 %tobool431, label %if.then432, label %if.end433

if.then432:                                       ; preds = %land.lhs.true430
  %274 = load ptr, ptr %c.addr, align 8
  %275 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 19), align 8
  call void @rejectCommand(ptr noundef %274, ptr noundef %275)
  store i32 0, ptr %retval, align 4
  br label %return

if.end433:                                        ; preds = %land.lhs.true430, %land.lhs.true428, %if.end426
  %276 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 82), align 8
  %tobool434 = icmp ne i32 %276, 0
  br i1 %tobool434, label %land.lhs.true435, label %if.end438

land.lhs.true435:                                 ; preds = %if.end433
  %277 = load i32, ptr %is_deny_async_loading_command, align 4
  %tobool436 = icmp ne i32 %277, 0
  br i1 %tobool436, label %if.then437, label %if.end438

if.then437:                                       ; preds = %land.lhs.true435
  %278 = load ptr, ptr %c.addr, align 8
  %279 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 19), align 8
  call void @rejectCommand(ptr noundef %278, ptr noundef %279)
  store i32 0, ptr %retval, align 4
  br label %return

if.end438:                                        ; preds = %land.lhs.true435, %if.end433
  %call439 = call i32 @isInsideYieldingLongCommand()
  %tobool440 = icmp ne i32 %call439, 0
  br i1 %tobool440, label %land.lhs.true441, label %if.end462

land.lhs.true441:                                 ; preds = %if.end438
  %280 = load ptr, ptr %c.addr, align 8
  %cmd442 = getelementptr inbounds %struct.client, ptr %280, i32 0, i32 17
  %281 = load ptr, ptr %cmd442, align 8
  %flags443 = getelementptr inbounds %struct.redisCommand, ptr %281, i32 0, i32 14
  %282 = load i64, ptr %flags443, align 8
  %and444 = and i64 %282, 67108864
  %tobool445 = icmp ne i64 %and444, 0
  br i1 %tobool445, label %if.end462, label %if.then446

if.then446:                                       ; preds = %land.lhs.true441
  %283 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %tobool447 = icmp ne i32 %283, 0
  br i1 %tobool447, label %land.lhs.true448, label %if.else451

land.lhs.true448:                                 ; preds = %if.then446
  %284 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 32), align 8
  %tobool449 = icmp ne ptr %284, null
  br i1 %tobool449, label %if.then450, label %if.else451

if.then450:                                       ; preds = %land.lhs.true448
  %285 = load ptr, ptr %c.addr, align 8
  %286 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 32), align 8
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef %285, ptr noundef @.str.189, ptr noundef %286)
  br label %if.end461

if.else451:                                       ; preds = %land.lhs.true448, %if.then446
  %287 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 31), align 8
  %tobool452 = icmp ne i32 %287, 0
  br i1 %tobool452, label %if.then453, label %if.else454

if.then453:                                       ; preds = %if.else451
  %288 = load ptr, ptr %c.addr, align 8
  %289 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 22), align 8
  call void @rejectCommand(ptr noundef %288, ptr noundef %289)
  br label %if.end460

if.else454:                                       ; preds = %if.else451
  %call455 = call i32 @scriptIsEval()
  %tobool456 = icmp ne i32 %call455, 0
  br i1 %tobool456, label %if.then457, label %if.else458

if.then457:                                       ; preds = %if.else454
  %290 = load ptr, ptr %c.addr, align 8
  %291 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 20), align 8
  call void @rejectCommand(ptr noundef %290, ptr noundef %291)
  br label %if.end459

if.else458:                                       ; preds = %if.else454
  %292 = load ptr, ptr %c.addr, align 8
  %293 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 21), align 8
  call void @rejectCommand(ptr noundef %292, ptr noundef %293)
  br label %if.end459

if.end459:                                        ; preds = %if.else458, %if.then457
  br label %if.end460

if.end460:                                        ; preds = %if.end459, %if.then453
  br label %if.end461

if.end461:                                        ; preds = %if.end460, %if.then450
  store i32 0, ptr %retval, align 4
  br label %return

if.end462:                                        ; preds = %land.lhs.true441, %if.end438
  %294 = load ptr, ptr %c.addr, align 8
  %flags463 = getelementptr inbounds %struct.client, ptr %294, i32 0, i32 1
  %295 = load i64, ptr %flags463, align 8
  %and464 = and i64 %295, 1
  %tobool465 = icmp ne i64 %and464, 0
  br i1 %tobool465, label %land.lhs.true466, label %if.end473

land.lhs.true466:                                 ; preds = %if.end462
  %296 = load i32, ptr %is_may_replicate_command, align 4
  %tobool467 = icmp ne i32 %296, 0
  br i1 %tobool467, label %if.then472, label %lor.lhs.false468

lor.lhs.false468:                                 ; preds = %land.lhs.true466
  %297 = load i32, ptr %is_write_command, align 4
  %tobool469 = icmp ne i32 %297, 0
  br i1 %tobool469, label %if.then472, label %lor.lhs.false470

lor.lhs.false470:                                 ; preds = %lor.lhs.false468
  %298 = load i32, ptr %is_read_command, align 4
  %tobool471 = icmp ne i32 %298, 0
  br i1 %tobool471, label %if.then472, label %if.end473

if.then472:                                       ; preds = %lor.lhs.false470, %lor.lhs.false468, %land.lhs.true466
  %299 = load ptr, ptr %c.addr, align 8
  call void (ptr, ptr, ...) @rejectCommandFormat(ptr noundef %299, ptr noundef @.str.190)
  store i32 0, ptr %retval, align 4
  br label %return

if.end473:                                        ; preds = %lor.lhs.false470, %if.end462
  %300 = load ptr, ptr %c.addr, align 8
  %flags474 = getelementptr inbounds %struct.client, ptr %300, i32 0, i32 1
  %301 = load i64, ptr %flags474, align 8
  %and475 = and i64 %301, 1
  %tobool476 = icmp ne i64 %and475, 0
  br i1 %tobool476, label %if.end486, label %land.lhs.true477

land.lhs.true477:                                 ; preds = %if.end473
  %call478 = call i32 @isPausedActions(i32 noundef 2)
  %tobool479 = icmp ne i32 %call478, 0
  br i1 %tobool479, label %if.then485, label %lor.lhs.false480

lor.lhs.false480:                                 ; preds = %land.lhs.true477
  %call481 = call i32 @isPausedActions(i32 noundef 1)
  %tobool482 = icmp ne i32 %call481, 0
  br i1 %tobool482, label %land.lhs.true483, label %if.end486

land.lhs.true483:                                 ; preds = %lor.lhs.false480
  %302 = load i32, ptr %is_may_replicate_command, align 4
  %tobool484 = icmp ne i32 %302, 0
  br i1 %tobool484, label %if.then485, label %if.end486

if.then485:                                       ; preds = %land.lhs.true483, %land.lhs.true477
  %303 = load ptr, ptr %c.addr, align 8
  call void @blockPostponeClient(ptr noundef %303)
  store i32 0, ptr %retval, align 4
  br label %return

if.end486:                                        ; preds = %land.lhs.true483, %lor.lhs.false480, %if.end473
  %304 = load ptr, ptr %c.addr, align 8
  %flags487 = getelementptr inbounds %struct.client, ptr %304, i32 0, i32 1
  %305 = load i64, ptr %flags487, align 8
  %and488 = and i64 %305, 8
  %tobool489 = icmp ne i64 %and488, 0
  br i1 %tobool489, label %land.lhs.true490, label %if.else521

land.lhs.true490:                                 ; preds = %if.end486
  %306 = load ptr, ptr %c.addr, align 8
  %cmd491 = getelementptr inbounds %struct.client, ptr %306, i32 0, i32 17
  %307 = load ptr, ptr %cmd491, align 8
  %proc492 = getelementptr inbounds %struct.redisCommand, ptr %307, i32 0, i32 12
  %308 = load ptr, ptr %proc492, align 8
  %cmp493 = icmp ne ptr %308, @execCommand
  br i1 %cmp493, label %land.lhs.true495, label %if.else521

land.lhs.true495:                                 ; preds = %land.lhs.true490
  %309 = load ptr, ptr %c.addr, align 8
  %cmd496 = getelementptr inbounds %struct.client, ptr %309, i32 0, i32 17
  %310 = load ptr, ptr %cmd496, align 8
  %proc497 = getelementptr inbounds %struct.redisCommand, ptr %310, i32 0, i32 12
  %311 = load ptr, ptr %proc497, align 8
  %cmp498 = icmp ne ptr %311, @discardCommand
  br i1 %cmp498, label %land.lhs.true500, label %if.else521

land.lhs.true500:                                 ; preds = %land.lhs.true495
  %312 = load ptr, ptr %c.addr, align 8
  %cmd501 = getelementptr inbounds %struct.client, ptr %312, i32 0, i32 17
  %313 = load ptr, ptr %cmd501, align 8
  %proc502 = getelementptr inbounds %struct.redisCommand, ptr %313, i32 0, i32 12
  %314 = load ptr, ptr %proc502, align 8
  %cmp503 = icmp ne ptr %314, @multiCommand
  br i1 %cmp503, label %land.lhs.true505, label %if.else521

land.lhs.true505:                                 ; preds = %land.lhs.true500
  %315 = load ptr, ptr %c.addr, align 8
  %cmd506 = getelementptr inbounds %struct.client, ptr %315, i32 0, i32 17
  %316 = load ptr, ptr %cmd506, align 8
  %proc507 = getelementptr inbounds %struct.redisCommand, ptr %316, i32 0, i32 12
  %317 = load ptr, ptr %proc507, align 8
  %cmp508 = icmp ne ptr %317, @watchCommand
  br i1 %cmp508, label %land.lhs.true510, label %if.else521

land.lhs.true510:                                 ; preds = %land.lhs.true505
  %318 = load ptr, ptr %c.addr, align 8
  %cmd511 = getelementptr inbounds %struct.client, ptr %318, i32 0, i32 17
  %319 = load ptr, ptr %cmd511, align 8
  %proc512 = getelementptr inbounds %struct.redisCommand, ptr %319, i32 0, i32 12
  %320 = load ptr, ptr %proc512, align 8
  %cmp513 = icmp ne ptr %320, @quitCommand
  br i1 %cmp513, label %land.lhs.true515, label %if.else521

land.lhs.true515:                                 ; preds = %land.lhs.true510
  %321 = load ptr, ptr %c.addr, align 8
  %cmd516 = getelementptr inbounds %struct.client, ptr %321, i32 0, i32 17
  %322 = load ptr, ptr %cmd516, align 8
  %proc517 = getelementptr inbounds %struct.redisCommand, ptr %322, i32 0, i32 12
  %323 = load ptr, ptr %proc517, align 8
  %cmp518 = icmp ne ptr %323, @resetCommand
  br i1 %cmp518, label %if.then520, label %if.else521

if.then520:                                       ; preds = %land.lhs.true515
  %324 = load ptr, ptr %c.addr, align 8
  %325 = load i64, ptr %cmd_flags, align 8
  call void @queueMultiCommand(ptr noundef %324, i64 noundef %325)
  %326 = load ptr, ptr %c.addr, align 8
  %327 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 7), align 8
  call void @addReply(ptr noundef %326, ptr noundef %327)
  br label %if.end532

if.else521:                                       ; preds = %land.lhs.true515, %land.lhs.true510, %land.lhs.true505, %land.lhs.true500, %land.lhs.true495, %land.lhs.true490, %if.end486
  store i32 3, ptr %flags522, align 4
  %328 = load i32, ptr %client_reprocessing_command, align 4
  %tobool523 = icmp ne i32 %328, 0
  br i1 %tobool523, label %if.then524, label %if.end525

if.then524:                                       ; preds = %if.else521
  %329 = load i32, ptr %flags522, align 4
  %or = or i32 %329, 4
  store i32 %or, ptr %flags522, align 4
  br label %if.end525

if.end525:                                        ; preds = %if.then524, %if.else521
  %330 = load ptr, ptr %c.addr, align 8
  %331 = load i32, ptr %flags522, align 4
  call void @call(ptr noundef %330, i32 noundef %331)
  %332 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 328), align 8
  %len = getelementptr inbounds %struct.list, ptr %332, i32 0, i32 5
  %333 = load i64, ptr %len, align 8
  %tobool526 = icmp ne i64 %333, 0
  br i1 %tobool526, label %land.lhs.true527, label %if.end531

land.lhs.true527:                                 ; preds = %if.end525
  %call528 = call i32 @isInsideYieldingLongCommand()
  %tobool529 = icmp ne i32 %call528, 0
  br i1 %tobool529, label %if.end531, label %if.then530

if.then530:                                       ; preds = %land.lhs.true527
  call void @handleClientsBlockedOnKeys()
  br label %if.end531

if.end531:                                        ; preds = %if.then530, %land.lhs.true527, %if.end525
  br label %if.end532

if.end532:                                        ; preds = %if.end531, %if.then520
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end532, %if.then485, %if.then472, %if.end461, %if.then437, %if.then432, %if.then425, %if.then413, %if.then360, %if.then351, %if.else341, %if.then305, %if.then275, %if.then263, %if.end256, %if.then211, %if.then206, %if.then195, %if.then67, %if.then47, %if.then43, %if.then34, %if.then30
  %334 = load i32, ptr %retval, align 4
  ret i32 %334
}

declare i32 @scriptIsRunning() #2

declare void @moduleCallCommandFilters(ptr noundef) #2

declare i64 @reqresAppendRequest(ptr noundef) #2

declare void @securityWarningCommand(ptr noundef) #2

declare void @blockPostponeClient(ptr noundef) #2

declare void @debugCommand(ptr noundef) #2

declare i32 @allowProtectedAction(i32 noundef, ptr noundef) #2

declare void @moduleCommand(ptr noundef) #2

declare i32 @authRequired(ptr noundef) #2

declare i32 @ACLCheckAllPerm(ptr noundef, ptr noundef) #2

declare void @addACLLogEntry(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, ptr noundef) #2

declare ptr @getAclErrorMessage(i32 noundef, ptr noundef, ptr noundef, ptr noundef, i32 noundef) #2

declare ptr @getNodeByQuery(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #2

declare i32 @clusterNodeIsMyself(ptr noundef) #2

declare void @discardTransaction(ptr noundef) #2

declare void @clusterRedirectClient(ptr noundef, ptr noundef, i32 noundef, i32 noundef) #2

declare i32 @performEvictions() #2

declare void @discardCommand(ptr noundef) #2

declare void @quitCommand(ptr noundef) #2

declare void @resetCommand(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @writeCommandsDeniedByDiskError() #0 {
entry:
  %retval = alloca i32, align 4
  %aof_bio_fsync_status = alloca i32, align 4
  %atomic-temp = alloca i32, align 4
  %atomic-temp10 = alloca i32, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 236), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 224), align 8
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %land.lhs.true1, label %if.else

land.lhs.true1:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 235), align 8
  %cmp2 = icmp eq i32 %2, -1
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true1
  store i32 2, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true1, %land.lhs.true, %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp3 = icmp ne i32 %3, 0
  br i1 %cmp3, label %if.then4, label %if.end13

if.then4:                                         ; preds = %if.else
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 211), align 8
  %cmp5 = icmp eq i32 %4, -1
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then4
  br label %do.body

do.body:                                          ; preds = %if.end
  %5 = load atomic i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 215) monotonic, align 8
  store i32 %5, ptr %atomic-temp, align 4
  %6 = load i32, ptr %atomic-temp, align 4
  store i32 %6, ptr %aof_bio_fsync_status, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %7 = load i32, ptr %aof_bio_fsync_status, align 4
  %cmp7 = icmp eq i32 %7, -1
  br i1 %cmp7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %do.end
  br label %do.body9

do.body9:                                         ; preds = %if.then8
  %8 = load atomic i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 216) monotonic, align 4
  store i32 %8, ptr %atomic-temp10, align 4
  %9 = load i32, ptr %atomic-temp10, align 4
  store i32 %9, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 212), align 4
  br label %do.end11

do.end11:                                         ; preds = %do.body9
  store i32 1, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %do.end
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.else
  br label %if.end14

if.end14:                                         ; preds = %if.end13
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %do.end11, %if.then6, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define dso_local void @pingCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %argc, align 8
  %cmp = icmp sgt i32 %1, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  call void @addReplyErrorArity(ptr noundef %2)
  br label %if.end15

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 1
  %4 = load i64, ptr %flags, align 8
  %and = and i64 %4, 262144
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.else7

land.lhs.true:                                    ; preds = %if.end
  %5 = load ptr, ptr %c.addr, align 8
  %resp = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 3
  %6 = load i32, ptr %resp, align 8
  %cmp1 = icmp eq i32 %6, 2
  br i1 %cmp1, label %if.then2, label %if.else7

if.then2:                                         ; preds = %land.lhs.true
  %7 = load ptr, ptr %c.addr, align 8
  %8 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 87, i64 2), align 8
  call void @addReply(ptr noundef %7, ptr noundef %8)
  %9 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCBuffer(ptr noundef %9, ptr noundef @.str.218, i64 noundef 4)
  %10 = load ptr, ptr %c.addr, align 8
  %argc3 = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 11
  %11 = load i32, ptr %argc3, align 8
  %cmp4 = icmp eq i32 %11, 1
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then2
  %12 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCBuffer(ptr noundef %12, ptr noundef @.str.219, i64 noundef 0)
  br label %if.end6

if.else:                                          ; preds = %if.then2
  %13 = load ptr, ptr %c.addr, align 8
  %14 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 12
  %15 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx, align 8
  call void @addReplyBulk(ptr noundef %13, ptr noundef %16)
  br label %if.end6

if.end6:                                          ; preds = %if.else, %if.then5
  br label %if.end15

if.else7:                                         ; preds = %land.lhs.true, %if.end
  %17 = load ptr, ptr %c.addr, align 8
  %argc8 = getelementptr inbounds %struct.client, ptr %17, i32 0, i32 11
  %18 = load i32, ptr %argc8, align 8
  %cmp9 = icmp eq i32 %18, 1
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else7
  %19 = load ptr, ptr %c.addr, align 8
  %20 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 5), align 8
  call void @addReply(ptr noundef %19, ptr noundef %20)
  br label %if.end14

if.else11:                                        ; preds = %if.else7
  %21 = load ptr, ptr %c.addr, align 8
  %22 = load ptr, ptr %c.addr, align 8
  %argv12 = getelementptr inbounds %struct.client, ptr %22, i32 0, i32 12
  %23 = load ptr, ptr %argv12, align 8
  %arrayidx13 = getelementptr inbounds ptr, ptr %23, i64 1
  %24 = load ptr, ptr %arrayidx13, align 8
  call void @addReplyBulk(ptr noundef %21, ptr noundef %24)
  br label %if.end14

if.end14:                                         ; preds = %if.else11, %if.then10
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.end6, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @writeCommandsGetDiskErrorMessage(i32 noundef %error_code) #0 {
entry:
  %error_code.addr = alloca i32, align 4
  %ret = alloca ptr, align 8
  store i32 %error_code, ptr %error_code.addr, align 4
  store ptr null, ptr %ret, align 8
  %0 = load i32, ptr %error_code.addr, align 4
  %cmp = icmp eq i32 %0, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 23), align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %ptr, align 8
  %call = call ptr @sdsdup(ptr noundef %2)
  store ptr %call, ptr %ret, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call ptr @sdsempty()
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 212), align 4
  %call2 = call ptr @strerror(i32 noundef %3) #13
  %call3 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %call1, ptr noundef @.str.217, ptr noundef %call2)
  store ptr %call3, ptr %ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %ret, align 8
  ret ptr %4
}

declare void @sdssubstr(ptr noundef, i64 noundef, i64 noundef) #2

declare i32 @checkGoodReplicasStatus() #2

declare void @subscribeCommand(ptr noundef) #2

declare void @ssubscribeCommand(ptr noundef) #2

declare void @unsubscribeCommand(ptr noundef) #2

declare void @sunsubscribeCommand(ptr noundef) #2

declare void @psubscribeCommand(ptr noundef) #2

declare void @punsubscribeCommand(ptr noundef) #2

declare i32 @scriptIsEval() #2

declare i32 @isPausedActions(i32 noundef) #2

declare void @multiCommand(ptr noundef) #2

declare void @watchCommand(ptr noundef) #2

declare void @queueMultiCommand(ptr noundef, i64 noundef) #2

declare void @addReply(ptr noundef, ptr noundef) #2

declare void @handleClientsBlockedOnKeys() #2

; Function Attrs: nounwind uwtable
define dso_local void @incrementErrorCount(ptr noundef %fullerr, i64 noundef %namelen) #0 {
entry:
  %fullerr.addr = alloca ptr, align 8
  %namelen.addr = alloca i64, align 8
  %result = alloca ptr, align 8
  %error = alloca ptr, align 8
  %error3 = alloca ptr, align 8
  store ptr %fullerr, ptr %fullerr.addr, align 8
  store i64 %namelen, ptr %namelen.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 15), align 8
  %1 = load ptr, ptr %fullerr.addr, align 8
  %2 = load i64, ptr %namelen.addr, align 8
  %call = call i32 @raxFind(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %result)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call noalias ptr @zmalloc(i64 noundef 8) #18
  store ptr %call1, ptr %error, align 8
  %3 = load ptr, ptr %error, align 8
  %count = getelementptr inbounds %struct.redisError, ptr %3, i32 0, i32 0
  store i64 1, ptr %count, align 8
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 15), align 8
  %5 = load ptr, ptr %fullerr.addr, align 8
  %6 = load i64, ptr %namelen.addr, align 8
  %7 = load ptr, ptr %error, align 8
  %call2 = call i32 @raxInsert(ptr noundef %4, ptr noundef %5, i64 noundef %6, ptr noundef %7, ptr noundef null)
  br label %if.end

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %result, align 8
  store ptr %8, ptr %error3, align 8
  %9 = load ptr, ptr %error3, align 8
  %count4 = getelementptr inbounds %struct.redisError, ptr %9, i32 0, i32 0
  %10 = load i64, ptr %count4, align 8
  %inc = add nsw i64 %10, 1
  store i64 %inc, ptr %count4, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare i32 @raxFind(ptr noundef, ptr noundef, i64 noundef, ptr noundef) #2

declare i32 @raxInsert(ptr noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @closeListeningSockets(i32 noundef %unlink_unix_socket) #0 {
entry:
  %unlink_unix_socket.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  %listener = alloca ptr, align 8
  store i32 %unlink_unix_socket, ptr %unlink_unix_socket.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc7, %entry
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 8
  br i1 %cmp, label %for.body, label %for.end9

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %i, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [8 x %struct.connListener], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 52), i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %listener, align 8
  %2 = load ptr, ptr %listener, align 8
  %ct = getelementptr inbounds %struct.connListener, ptr %2, i32 0, i32 5
  %3 = load ptr, ptr %ct, align 8
  %cmp1 = icmp eq ptr %3, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc7

if.end:                                           ; preds = %for.body
  store i32 0, ptr %j, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %if.end
  %4 = load i32, ptr %j, align 4
  %5 = load ptr, ptr %listener, align 8
  %count = getelementptr inbounds %struct.connListener, ptr %5, i32 0, i32 1
  %6 = load i32, ptr %count, align 8
  %cmp3 = icmp slt i32 %4, %6
  br i1 %cmp3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  %7 = load ptr, ptr %listener, align 8
  %fd = getelementptr inbounds %struct.connListener, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %j, align 4
  %idxprom5 = sext i32 %8 to i64
  %arrayidx6 = getelementptr inbounds [16 x i32], ptr %fd, i64 0, i64 %idxprom5
  %9 = load i32, ptr %arrayidx6, align 4
  %call = call i32 @close(i32 noundef %9)
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %10 = load i32, ptr %j, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond2, !llvm.loop !47

for.end:                                          ; preds = %for.cond2
  br label %for.inc7

for.inc7:                                         ; preds = %for.end, %if.then
  %11 = load i32, ptr %i, align 4
  %inc8 = add nsw i32 %11, 1
  store i32 %inc8, ptr %i, align 4
  br label %for.cond, !llvm.loop !48

for.end9:                                         ; preds = %for.cond
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then10, label %if.end20

if.then10:                                        ; preds = %for.end9
  store i32 0, ptr %j, align 4
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc17, %if.then10
  %13 = load i32, ptr %j, align 4
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 54, i32 1), align 8
  %cmp12 = icmp slt i32 %13, %14
  br i1 %cmp12, label %for.body13, label %for.end19

for.body13:                                       ; preds = %for.cond11
  %15 = load i32, ptr %j, align 4
  %idxprom14 = sext i32 %15 to i64
  %arrayidx15 = getelementptr inbounds [16 x i32], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 54), i64 0, i64 %idxprom14
  %16 = load i32, ptr %arrayidx15, align 4
  %call16 = call i32 @close(i32 noundef %16)
  br label %for.inc17

for.inc17:                                        ; preds = %for.body13
  %17 = load i32, ptr %j, align 4
  %inc18 = add nsw i32 %17, 1
  store i32 %inc18, ptr %j, align 4
  br label %for.cond11, !llvm.loop !49

for.end19:                                        ; preds = %for.cond11
  br label %if.end20

if.end20:                                         ; preds = %for.end19, %for.end9
  %18 = load i32, ptr %unlink_unix_socket.addr, align 4
  %tobool21 = icmp ne i32 %18, 0
  br i1 %tobool21, label %land.lhs.true, label %if.end38

land.lhs.true:                                    ; preds = %if.end20
  %19 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 50), align 8
  %tobool22 = icmp ne ptr %19, null
  br i1 %tobool22, label %if.then23, label %if.end38

if.then23:                                        ; preds = %land.lhs.true
  br label %do.body

do.body:                                          ; preds = %if.then23
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp24 = icmp slt i32 2, %20
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %do.body
  br label %do.end

if.end26:                                         ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.191)
  br label %do.end

do.end:                                           ; preds = %if.end26, %if.then25
  %21 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 50), align 8
  %call27 = call i32 @unlink(ptr noundef %21) #13
  %cmp28 = icmp ne i32 %call27, 0
  br i1 %cmp28, label %if.then29, label %if.end37

if.then29:                                        ; preds = %do.end
  br label %do.body30

do.body30:                                        ; preds = %if.then29
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp31 = icmp slt i32 3, %22
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %do.body30
  br label %do.end36

if.end33:                                         ; preds = %do.body30
  %call34 = call ptr @__errno_location() #17
  %23 = load i32, ptr %call34, align 4
  %call35 = call ptr @strerror(i32 noundef %23) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.192, ptr noundef %call35)
  br label %do.end36

do.end36:                                         ; preds = %if.end33, %if.then32
  br label %if.end37

if.end37:                                         ; preds = %do.end36, %do.end
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %land.lhs.true, %if.end20
  ret void
}

; Function Attrs: nounwind
declare i32 @unlink(ptr noundef) #3

; Function Attrs: nounwind uwtable
define dso_local i32 @redisCommunicateSystemd(ptr noundef %sd_notify_msg) #0 {
entry:
  %sd_notify_msg.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %sd_notify_msg, ptr %sd_notify_msg.addr, align 8
  %0 = load ptr, ptr %sd_notify_msg.addr, align 8
  %call = call i32 @sd_notify(i32 noundef 0, ptr noundef %0)
  store i32 %call, ptr %ret, align 4
  %1 = load i32, ptr %ret, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 3, %2
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.434)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  br label %if.end11

if.else:                                          ; preds = %entry
  %3 = load i32, ptr %ret, align 4
  %cmp3 = icmp slt i32 %3, 0
  br i1 %cmp3, label %if.then4, label %if.end10

if.then4:                                         ; preds = %if.else
  br label %do.body5

do.body5:                                         ; preds = %if.then4
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp6 = icmp slt i32 3, %4
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %do.body5
  br label %do.end9

if.end8:                                          ; preds = %do.body5
  %5 = load i32, ptr %ret, align 4
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.435, i32 noundef %5)
  br label %do.end9

do.end9:                                          ; preds = %if.end8, %if.then7
  br label %if.end10

if.end10:                                         ; preds = %do.end9, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %do.end
  %6 = load i32, ptr %ret, align 4
  ret i32 %6
}

declare void @pauseActions(i32 noundef, i64 noundef, i32 noundef) #2

declare void @listRewind(ptr noundef, ptr noundef) #2

declare ptr @listNext(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @abortShutdown() #0 {
entry:
  %retval = alloca i32, align 4
  %call = call i32 @isShutdownInitiated()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @cancelShutdown()
  br label %if.end4

if.else:                                          ; preds = %entry
  %0 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  %tobool1 = icmp ne i32 %0, 0
  br i1 %tobool1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  br label %if.end

if.else3:                                         ; preds = %if.else
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then2
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then
  br label %do.body

do.body:                                          ; preds = %if.end4
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 2, %1
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %do.body
  br label %do.end

if.end6:                                          ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.196)
  br label %do.end

do.end:                                           ; preds = %if.end6, %if.then5
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end, %if.else3
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal void @cancelShutdown() #0 {
entry:
  store volatile i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 20), align 4
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 18), align 8
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 19), align 8
  call void @replyToClientsBlockedOnShutdown()
  call void @unpauseActions(i32 noundef 1)
  ret void
}

declare ptr @replicationGetSlaveName(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @replstateToString(i32 noundef %replstate) #0 {
entry:
  %retval = alloca ptr, align 8
  %replstate.addr = alloca i32, align 4
  store i32 %replstate, ptr %replstate.addr, align 4
  %0 = load i32, ptr %replstate.addr, align 4
  switch i32 %0, label %sw.default [
    i32 6, label %sw.bb
    i32 7, label %sw.bb
    i32 8, label %sw.bb1
    i32 9, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry, %entry
  store ptr @.str.331, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  store ptr @.str.332, ptr %retval, align 8
  br label %return

sw.bb2:                                           ; preds = %entry
  store ptr @.str.333, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  store ptr @.str.219, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

declare void @ldbKillForkedSessions() #2

declare void @killRDBChild() #2

declare void @rdbRemoveTempFile(i32 noundef, i32 noundef) #2

declare i32 @TerminateModuleForkChild(i32 noundef, i32 noundef) #2

declare void @killAppendOnlyChild() #2

declare i32 @fdatasync(i32 noundef) #2

declare i32 @rdbSave(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #2

declare void @aofManifestFree(ptr noundef) #2

declare void @flushSlavesOutputBuffers() #2

; Function Attrs: nounwind
declare i32 @flock(i32 noundef, i32 noundef) #3

declare void @addReplyErrorArity(ptr noundef) #2

declare void @addReplyBulkCBuffer(ptr noundef, ptr noundef, i64 noundef) #2

declare void @addReplyBulk(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @echoCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 12
  %2 = load ptr, ptr %argv, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %2, i64 1
  %3 = load ptr, ptr %arrayidx, align 8
  call void @addReplyBulk(ptr noundef %0, ptr noundef %3)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @timeCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @addReplyArrayLen(ptr noundef %0, i64 noundef 2)
  %1 = load ptr, ptr %c.addr, align 8
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  call void @addReplyBulkLongLong(ptr noundef %1, i64 noundef %atomic-load)
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 353), align 8
  %atomic-load1 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %mul = mul nsw i64 %atomic-load1, 1000000
  %sub = sub nsw i64 %3, %mul
  call void @addReplyBulkLongLong(ptr noundef %2, i64 noundef %sub)
  ret void
}

declare void @addReplyArrayLen(ptr noundef, i64 noundef) #2

declare void @addReplyBulkLongLong(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandFlags(ptr noundef %c, i64 noundef %flags, ptr noundef %replyFlags) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %replyFlags.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  %j = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  store ptr %replyFlags, ptr %replyFlags.addr, align 8
  store i32 0, ptr %count, align 4
  store i32 0, ptr %j, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load ptr, ptr %replyFlags.addr, align 8
  %1 = load i32, ptr %j, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds %struct.replyFlagNames, ptr %0, i64 %idxprom
  %name = getelementptr inbounds %struct.replyFlagNames, ptr %arrayidx, i32 0, i32 1
  %2 = load ptr, ptr %name, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i64, ptr %flags.addr, align 8
  %4 = load ptr, ptr %replyFlags.addr, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds %struct.replyFlagNames, ptr %4, i64 %idxprom1
  %flag = getelementptr inbounds %struct.replyFlagNames, ptr %arrayidx2, i32 0, i32 0
  %6 = load i64, ptr %flag, align 8
  %and = and i64 %3, %6
  %tobool3 = icmp ne i64 %and, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %7 = load i32, ptr %count, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %8 = load i32, ptr %j, align 4
  %inc4 = add nsw i32 %8, 1
  store i32 %inc4, ptr %j, align 4
  br label %while.cond, !llvm.loop !50

while.end:                                        ; preds = %while.cond
  %9 = load ptr, ptr %c.addr, align 8
  %10 = load i32, ptr %count, align 4
  %conv = sext i32 %10 to i64
  call void @addReplySetLen(ptr noundef %9, i64 noundef %conv)
  store i32 0, ptr %j, align 4
  br label %while.cond5

while.cond5:                                      ; preds = %if.end20, %while.end
  %11 = load ptr, ptr %replyFlags.addr, align 8
  %12 = load i32, ptr %j, align 4
  %idxprom6 = sext i32 %12 to i64
  %arrayidx7 = getelementptr inbounds %struct.replyFlagNames, ptr %11, i64 %idxprom6
  %name8 = getelementptr inbounds %struct.replyFlagNames, ptr %arrayidx7, i32 0, i32 1
  %13 = load ptr, ptr %name8, align 8
  %tobool9 = icmp ne ptr %13, null
  br i1 %tobool9, label %while.body10, label %while.end22

while.body10:                                     ; preds = %while.cond5
  %14 = load i64, ptr %flags.addr, align 8
  %15 = load ptr, ptr %replyFlags.addr, align 8
  %16 = load i32, ptr %j, align 4
  %idxprom11 = sext i32 %16 to i64
  %arrayidx12 = getelementptr inbounds %struct.replyFlagNames, ptr %15, i64 %idxprom11
  %flag13 = getelementptr inbounds %struct.replyFlagNames, ptr %arrayidx12, i32 0, i32 0
  %17 = load i64, ptr %flag13, align 8
  %and14 = and i64 %14, %17
  %tobool15 = icmp ne i64 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.end20

if.then16:                                        ; preds = %while.body10
  %18 = load ptr, ptr %c.addr, align 8
  %19 = load ptr, ptr %replyFlags.addr, align 8
  %20 = load i32, ptr %j, align 4
  %idxprom17 = sext i32 %20 to i64
  %arrayidx18 = getelementptr inbounds %struct.replyFlagNames, ptr %19, i64 %idxprom17
  %name19 = getelementptr inbounds %struct.replyFlagNames, ptr %arrayidx18, i32 0, i32 1
  %21 = load ptr, ptr %name19, align 8
  call void @addReplyStatus(ptr noundef %18, ptr noundef %21)
  br label %if.end20

if.end20:                                         ; preds = %if.then16, %while.body10
  %22 = load i32, ptr %j, align 4
  %inc21 = add nsw i32 %22, 1
  store i32 %inc21, ptr %j, align 4
  br label %while.cond5, !llvm.loop !51

while.end22:                                      ; preds = %while.cond5
  ret void
}

declare void @addReplySetLen(ptr noundef, i64 noundef) #2

declare void @addReplyStatus(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @addReplyFlagsForCommand(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %flagNames = alloca [21 x %struct.replyFlagNames], align 16
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %flagNames, ptr align 16 @__const.addReplyFlagsForCommand.flagNames, i64 336, i1 false)
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr %cmd.addr, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 14
  %2 = load i64, ptr %flags, align 8
  %arraydecay = getelementptr inbounds [21 x %struct.replyFlagNames], ptr %flagNames, i64 0, i64 0
  call void @addReplyCommandFlags(ptr noundef %0, i64 noundef %2, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyDocFlagsForCommand(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %docFlagNames = alloca [3 x %struct.replyFlagNames], align 16
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %docFlagNames, ptr align 16 @__const.addReplyDocFlagsForCommand.docFlagNames, i64 48, i1 false)
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr %cmd.addr, align 8
  %doc_flags = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 4
  %2 = load i32, ptr %doc_flags, align 8
  %conv = sext i32 %2 to i64
  %arraydecay = getelementptr inbounds [3 x %struct.replyFlagNames], ptr %docFlagNames, i64 0, i64 0
  call void @addReplyCommandFlags(ptr noundef %0, i64 noundef %conv, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyFlagsForKeyArgs(ptr noundef %c, i64 noundef %flags) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %docFlagNames = alloca [12 x %struct.replyFlagNames], align 16
  store ptr %c, ptr %c.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %docFlagNames, ptr align 16 @__const.addReplyFlagsForKeyArgs.docFlagNames, i64 192, i1 false)
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load i64, ptr %flags.addr, align 8
  %arraydecay = getelementptr inbounds [12 x %struct.replyFlagNames], ptr %docFlagNames, i64 0, i64 0
  call void @addReplyCommandFlags(ptr noundef %0, i64 noundef %1, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyFlagsForArg(ptr noundef %c, i64 noundef %flags) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %argFlagNames = alloca [4 x %struct.replyFlagNames], align 16
  store ptr %c, ptr %c.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %argFlagNames, ptr align 16 @__const.addReplyFlagsForArg.argFlagNames, i64 64, i1 false)
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load i64, ptr %flags.addr, align 8
  %arraydecay = getelementptr inbounds [4 x %struct.replyFlagNames], ptr %argFlagNames, i64 0, i64 0
  call void @addReplyCommandFlags(ptr noundef %0, i64 noundef %1, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandArgList(ptr noundef %c, ptr noundef %args, i32 noundef %num_args) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %num_args.addr = alloca i32, align 4
  %j = alloca i32, align 4
  %has_display_text = alloca i32, align 4
  %maplen = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i32 %num_args, ptr %num_args.addr, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load i32, ptr %num_args.addr, align 4
  %conv = sext i32 %1 to i64
  call void @addReplyArrayLen(ptr noundef %0, i64 noundef %conv)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr %num_args.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 1, ptr %has_display_text, align 4
  store i64 2, ptr %maplen, align 8
  %4 = load ptr, ptr %args.addr, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds %struct.redisCommandArg, ptr %4, i64 %idxprom
  %key_spec_index = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx, i32 0, i32 2
  %6 = load i32, ptr %key_spec_index, align 4
  %cmp2 = icmp ne i32 %6, -1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load i64, ptr %maplen, align 8
  %inc = add nsw i64 %7, 1
  store i64 %inc, ptr %maplen, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i32, ptr %j, align 4
  %idxprom4 = sext i32 %9 to i64
  %arrayidx5 = getelementptr inbounds %struct.redisCommandArg, ptr %8, i64 %idxprom4
  %token = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx5, i32 0, i32 3
  %10 = load ptr, ptr %token, align 8
  %tobool = icmp ne ptr %10, null
  br i1 %tobool, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %11 = load i64, ptr %maplen, align 8
  %inc7 = add nsw i64 %11, 1
  store i64 %inc7, ptr %maplen, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  %12 = load ptr, ptr %args.addr, align 8
  %13 = load i32, ptr %j, align 4
  %idxprom9 = sext i32 %13 to i64
  %arrayidx10 = getelementptr inbounds %struct.redisCommandArg, ptr %12, i64 %idxprom9
  %summary = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx10, i32 0, i32 4
  %14 = load ptr, ptr %summary, align 8
  %tobool11 = icmp ne ptr %14, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end8
  %15 = load i64, ptr %maplen, align 8
  %inc13 = add nsw i64 %15, 1
  store i64 %inc13, ptr %maplen, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end8
  %16 = load ptr, ptr %args.addr, align 8
  %17 = load i32, ptr %j, align 4
  %idxprom15 = sext i32 %17 to i64
  %arrayidx16 = getelementptr inbounds %struct.redisCommandArg, ptr %16, i64 %idxprom15
  %since = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx16, i32 0, i32 5
  %18 = load ptr, ptr %since, align 8
  %tobool17 = icmp ne ptr %18, null
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end14
  %19 = load i64, ptr %maplen, align 8
  %inc19 = add nsw i64 %19, 1
  store i64 %inc19, ptr %maplen, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end14
  %20 = load ptr, ptr %args.addr, align 8
  %21 = load i32, ptr %j, align 4
  %idxprom21 = sext i32 %21 to i64
  %arrayidx22 = getelementptr inbounds %struct.redisCommandArg, ptr %20, i64 %idxprom21
  %deprecated_since = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx22, i32 0, i32 7
  %22 = load ptr, ptr %deprecated_since, align 8
  %tobool23 = icmp ne ptr %22, null
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end20
  %23 = load i64, ptr %maplen, align 8
  %inc25 = add nsw i64 %23, 1
  store i64 %inc25, ptr %maplen, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end20
  %24 = load ptr, ptr %args.addr, align 8
  %25 = load i32, ptr %j, align 4
  %idxprom27 = sext i32 %25 to i64
  %arrayidx28 = getelementptr inbounds %struct.redisCommandArg, ptr %24, i64 %idxprom27
  %flags = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx28, i32 0, i32 6
  %26 = load i32, ptr %flags, align 8
  %tobool29 = icmp ne i32 %26, 0
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end26
  %27 = load i64, ptr %maplen, align 8
  %inc31 = add nsw i64 %27, 1
  store i64 %inc31, ptr %maplen, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end26
  %28 = load ptr, ptr %args.addr, align 8
  %29 = load i32, ptr %j, align 4
  %idxprom33 = sext i32 %29 to i64
  %arrayidx34 = getelementptr inbounds %struct.redisCommandArg, ptr %28, i64 %idxprom33
  %type = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx34, i32 0, i32 1
  %30 = load i32, ptr %type, align 8
  %cmp35 = icmp eq i32 %30, 7
  br i1 %cmp35, label %if.then42, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end32
  %31 = load ptr, ptr %args.addr, align 8
  %32 = load i32, ptr %j, align 4
  %idxprom37 = sext i32 %32 to i64
  %arrayidx38 = getelementptr inbounds %struct.redisCommandArg, ptr %31, i64 %idxprom37
  %type39 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx38, i32 0, i32 1
  %33 = load i32, ptr %type39, align 8
  %cmp40 = icmp eq i32 %33, 8
  br i1 %cmp40, label %if.then42, label %if.end44

if.then42:                                        ; preds = %lor.lhs.false, %if.end32
  store i32 0, ptr %has_display_text, align 4
  %34 = load i64, ptr %maplen, align 8
  %inc43 = add nsw i64 %34, 1
  store i64 %inc43, ptr %maplen, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then42, %lor.lhs.false
  %35 = load i32, ptr %has_display_text, align 4
  %tobool45 = icmp ne i32 %35, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %if.end44
  %36 = load i64, ptr %maplen, align 8
  %inc47 = add nsw i64 %36, 1
  store i64 %inc47, ptr %maplen, align 8
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %if.end44
  %37 = load ptr, ptr %c.addr, align 8
  %38 = load i64, ptr %maplen, align 8
  call void @addReplyMapLen(ptr noundef %37, i64 noundef %38)
  %39 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %39, ptr noundef @.str.265)
  %40 = load ptr, ptr %c.addr, align 8
  %41 = load ptr, ptr %args.addr, align 8
  %42 = load i32, ptr %j, align 4
  %idxprom49 = sext i32 %42 to i64
  %arrayidx50 = getelementptr inbounds %struct.redisCommandArg, ptr %41, i64 %idxprom49
  %name = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx50, i32 0, i32 0
  %43 = load ptr, ptr %name, align 8
  call void @addReplyBulkCString(ptr noundef %40, ptr noundef %43)
  %44 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %44, ptr noundef @.str.266)
  %45 = load ptr, ptr %c.addr, align 8
  %46 = load ptr, ptr %args.addr, align 8
  %47 = load i32, ptr %j, align 4
  %idxprom51 = sext i32 %47 to i64
  %arrayidx52 = getelementptr inbounds %struct.redisCommandArg, ptr %46, i64 %idxprom51
  %type53 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx52, i32 0, i32 1
  %48 = load i32, ptr %type53, align 8
  %idxprom54 = zext i32 %48 to i64
  %arrayidx55 = getelementptr inbounds [9 x ptr], ptr @ARG_TYPE_STR, i64 0, i64 %idxprom54
  %49 = load ptr, ptr %arrayidx55, align 8
  call void @addReplyBulkCString(ptr noundef %45, ptr noundef %49)
  %50 = load i32, ptr %has_display_text, align 4
  %tobool56 = icmp ne i32 %50, 0
  br i1 %tobool56, label %if.then57, label %if.end67

if.then57:                                        ; preds = %if.end48
  %51 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %51, ptr noundef @.str.267)
  %52 = load ptr, ptr %c.addr, align 8
  %53 = load ptr, ptr %args.addr, align 8
  %54 = load i32, ptr %j, align 4
  %idxprom58 = sext i32 %54 to i64
  %arrayidx59 = getelementptr inbounds %struct.redisCommandArg, ptr %53, i64 %idxprom58
  %display_text = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx59, i32 0, i32 10
  %55 = load ptr, ptr %display_text, align 8
  %tobool60 = icmp ne ptr %55, null
  br i1 %tobool60, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then57
  %56 = load ptr, ptr %args.addr, align 8
  %57 = load i32, ptr %j, align 4
  %idxprom61 = sext i32 %57 to i64
  %arrayidx62 = getelementptr inbounds %struct.redisCommandArg, ptr %56, i64 %idxprom61
  %display_text63 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx62, i32 0, i32 10
  %58 = load ptr, ptr %display_text63, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then57
  %59 = load ptr, ptr %args.addr, align 8
  %60 = load i32, ptr %j, align 4
  %idxprom64 = sext i32 %60 to i64
  %arrayidx65 = getelementptr inbounds %struct.redisCommandArg, ptr %59, i64 %idxprom64
  %name66 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx65, i32 0, i32 0
  %61 = load ptr, ptr %name66, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %58, %cond.true ], [ %61, %cond.false ]
  call void @addReplyBulkCString(ptr noundef %52, ptr noundef %cond)
  br label %if.end67

if.end67:                                         ; preds = %cond.end, %if.end48
  %62 = load ptr, ptr %args.addr, align 8
  %63 = load i32, ptr %j, align 4
  %idxprom68 = sext i32 %63 to i64
  %arrayidx69 = getelementptr inbounds %struct.redisCommandArg, ptr %62, i64 %idxprom68
  %key_spec_index70 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx69, i32 0, i32 2
  %64 = load i32, ptr %key_spec_index70, align 4
  %cmp71 = icmp ne i32 %64, -1
  br i1 %cmp71, label %if.then73, label %if.end78

if.then73:                                        ; preds = %if.end67
  %65 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %65, ptr noundef @.str.268)
  %66 = load ptr, ptr %c.addr, align 8
  %67 = load ptr, ptr %args.addr, align 8
  %68 = load i32, ptr %j, align 4
  %idxprom74 = sext i32 %68 to i64
  %arrayidx75 = getelementptr inbounds %struct.redisCommandArg, ptr %67, i64 %idxprom74
  %key_spec_index76 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx75, i32 0, i32 2
  %69 = load i32, ptr %key_spec_index76, align 4
  %conv77 = sext i32 %69 to i64
  call void @addReplyLongLong(ptr noundef %66, i64 noundef %conv77)
  br label %if.end78

if.end78:                                         ; preds = %if.then73, %if.end67
  %70 = load ptr, ptr %args.addr, align 8
  %71 = load i32, ptr %j, align 4
  %idxprom79 = sext i32 %71 to i64
  %arrayidx80 = getelementptr inbounds %struct.redisCommandArg, ptr %70, i64 %idxprom79
  %token81 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx80, i32 0, i32 3
  %72 = load ptr, ptr %token81, align 8
  %tobool82 = icmp ne ptr %72, null
  br i1 %tobool82, label %if.then83, label %if.end87

if.then83:                                        ; preds = %if.end78
  %73 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %73, ptr noundef @.str.269)
  %74 = load ptr, ptr %c.addr, align 8
  %75 = load ptr, ptr %args.addr, align 8
  %76 = load i32, ptr %j, align 4
  %idxprom84 = sext i32 %76 to i64
  %arrayidx85 = getelementptr inbounds %struct.redisCommandArg, ptr %75, i64 %idxprom84
  %token86 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx85, i32 0, i32 3
  %77 = load ptr, ptr %token86, align 8
  call void @addReplyBulkCString(ptr noundef %74, ptr noundef %77)
  br label %if.end87

if.end87:                                         ; preds = %if.then83, %if.end78
  %78 = load ptr, ptr %args.addr, align 8
  %79 = load i32, ptr %j, align 4
  %idxprom88 = sext i32 %79 to i64
  %arrayidx89 = getelementptr inbounds %struct.redisCommandArg, ptr %78, i64 %idxprom88
  %summary90 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx89, i32 0, i32 4
  %80 = load ptr, ptr %summary90, align 8
  %tobool91 = icmp ne ptr %80, null
  br i1 %tobool91, label %if.then92, label %if.end96

if.then92:                                        ; preds = %if.end87
  %81 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %81, ptr noundef @.str.270)
  %82 = load ptr, ptr %c.addr, align 8
  %83 = load ptr, ptr %args.addr, align 8
  %84 = load i32, ptr %j, align 4
  %idxprom93 = sext i32 %84 to i64
  %arrayidx94 = getelementptr inbounds %struct.redisCommandArg, ptr %83, i64 %idxprom93
  %summary95 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx94, i32 0, i32 4
  %85 = load ptr, ptr %summary95, align 8
  call void @addReplyBulkCString(ptr noundef %82, ptr noundef %85)
  br label %if.end96

if.end96:                                         ; preds = %if.then92, %if.end87
  %86 = load ptr, ptr %args.addr, align 8
  %87 = load i32, ptr %j, align 4
  %idxprom97 = sext i32 %87 to i64
  %arrayidx98 = getelementptr inbounds %struct.redisCommandArg, ptr %86, i64 %idxprom97
  %since99 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx98, i32 0, i32 5
  %88 = load ptr, ptr %since99, align 8
  %tobool100 = icmp ne ptr %88, null
  br i1 %tobool100, label %if.then101, label %if.end105

if.then101:                                       ; preds = %if.end96
  %89 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %89, ptr noundef @.str.271)
  %90 = load ptr, ptr %c.addr, align 8
  %91 = load ptr, ptr %args.addr, align 8
  %92 = load i32, ptr %j, align 4
  %idxprom102 = sext i32 %92 to i64
  %arrayidx103 = getelementptr inbounds %struct.redisCommandArg, ptr %91, i64 %idxprom102
  %since104 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx103, i32 0, i32 5
  %93 = load ptr, ptr %since104, align 8
  call void @addReplyBulkCString(ptr noundef %90, ptr noundef %93)
  br label %if.end105

if.end105:                                        ; preds = %if.then101, %if.end96
  %94 = load ptr, ptr %args.addr, align 8
  %95 = load i32, ptr %j, align 4
  %idxprom106 = sext i32 %95 to i64
  %arrayidx107 = getelementptr inbounds %struct.redisCommandArg, ptr %94, i64 %idxprom106
  %deprecated_since108 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx107, i32 0, i32 7
  %96 = load ptr, ptr %deprecated_since108, align 8
  %tobool109 = icmp ne ptr %96, null
  br i1 %tobool109, label %if.then110, label %if.end114

if.then110:                                       ; preds = %if.end105
  %97 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %97, ptr noundef @.str.272)
  %98 = load ptr, ptr %c.addr, align 8
  %99 = load ptr, ptr %args.addr, align 8
  %100 = load i32, ptr %j, align 4
  %idxprom111 = sext i32 %100 to i64
  %arrayidx112 = getelementptr inbounds %struct.redisCommandArg, ptr %99, i64 %idxprom111
  %deprecated_since113 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx112, i32 0, i32 7
  %101 = load ptr, ptr %deprecated_since113, align 8
  call void @addReplyBulkCString(ptr noundef %98, ptr noundef %101)
  br label %if.end114

if.end114:                                        ; preds = %if.then110, %if.end105
  %102 = load ptr, ptr %args.addr, align 8
  %103 = load i32, ptr %j, align 4
  %idxprom115 = sext i32 %103 to i64
  %arrayidx116 = getelementptr inbounds %struct.redisCommandArg, ptr %102, i64 %idxprom115
  %flags117 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx116, i32 0, i32 6
  %104 = load i32, ptr %flags117, align 8
  %tobool118 = icmp ne i32 %104, 0
  br i1 %tobool118, label %if.then119, label %if.end124

if.then119:                                       ; preds = %if.end114
  %105 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %105, ptr noundef @.str.273)
  %106 = load ptr, ptr %c.addr, align 8
  %107 = load ptr, ptr %args.addr, align 8
  %108 = load i32, ptr %j, align 4
  %idxprom120 = sext i32 %108 to i64
  %arrayidx121 = getelementptr inbounds %struct.redisCommandArg, ptr %107, i64 %idxprom120
  %flags122 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx121, i32 0, i32 6
  %109 = load i32, ptr %flags122, align 8
  %conv123 = sext i32 %109 to i64
  call void @addReplyFlagsForArg(ptr noundef %106, i64 noundef %conv123)
  br label %if.end124

if.end124:                                        ; preds = %if.then119, %if.end114
  %110 = load ptr, ptr %args.addr, align 8
  %111 = load i32, ptr %j, align 4
  %idxprom125 = sext i32 %111 to i64
  %arrayidx126 = getelementptr inbounds %struct.redisCommandArg, ptr %110, i64 %idxprom125
  %type127 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx126, i32 0, i32 1
  %112 = load i32, ptr %type127, align 8
  %cmp128 = icmp eq i32 %112, 7
  br i1 %cmp128, label %if.then136, label %lor.lhs.false130

lor.lhs.false130:                                 ; preds = %if.end124
  %113 = load ptr, ptr %args.addr, align 8
  %114 = load i32, ptr %j, align 4
  %idxprom131 = sext i32 %114 to i64
  %arrayidx132 = getelementptr inbounds %struct.redisCommandArg, ptr %113, i64 %idxprom131
  %type133 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx132, i32 0, i32 1
  %115 = load i32, ptr %type133, align 8
  %cmp134 = icmp eq i32 %115, 8
  br i1 %cmp134, label %if.then136, label %if.end142

if.then136:                                       ; preds = %lor.lhs.false130, %if.end124
  %116 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %116, ptr noundef @.str.274)
  %117 = load ptr, ptr %c.addr, align 8
  %118 = load ptr, ptr %args.addr, align 8
  %119 = load i32, ptr %j, align 4
  %idxprom137 = sext i32 %119 to i64
  %arrayidx138 = getelementptr inbounds %struct.redisCommandArg, ptr %118, i64 %idxprom137
  %subargs = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx138, i32 0, i32 9
  %120 = load ptr, ptr %subargs, align 8
  %121 = load ptr, ptr %args.addr, align 8
  %122 = load i32, ptr %j, align 4
  %idxprom139 = sext i32 %122 to i64
  %arrayidx140 = getelementptr inbounds %struct.redisCommandArg, ptr %121, i64 %idxprom139
  %num_args141 = getelementptr inbounds %struct.redisCommandArg, ptr %arrayidx140, i32 0, i32 8
  %123 = load i32, ptr %num_args141, align 8
  call void @addReplyCommandArgList(ptr noundef %117, ptr noundef %120, i32 noundef %123)
  br label %if.end142

if.end142:                                        ; preds = %if.then136, %lor.lhs.false130
  br label %for.inc

for.inc:                                          ; preds = %if.end142
  %124 = load i32, ptr %j, align 4
  %inc143 = add nsw i32 %124, 1
  store i32 %inc143, ptr %j, align 4
  br label %for.cond, !llvm.loop !52

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @addReplyMapLen(ptr noundef, i64 noundef) #2

declare void @addReplyBulkCString(ptr noundef, ptr noundef) #2

declare void @addReplyLongLong(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandHistory(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr %cmd.addr, align 8
  %num_history = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 9
  %2 = load i32, ptr %num_history, align 8
  %conv = sext i32 %2 to i64
  call void @addReplySetLen(ptr noundef %0, i64 noundef %conv)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %j, align 4
  %4 = load ptr, ptr %cmd.addr, align 8
  %num_history1 = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 9
  %5 = load i32, ptr %num_history1, align 8
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %c.addr, align 8
  call void @addReplyArrayLen(ptr noundef %6, i64 noundef 2)
  %7 = load ptr, ptr %c.addr, align 8
  %8 = load ptr, ptr %cmd.addr, align 8
  %history = getelementptr inbounds %struct.redisCommand, ptr %8, i32 0, i32 8
  %9 = load ptr, ptr %history, align 8
  %10 = load i32, ptr %j, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr inbounds %struct.commandHistory, ptr %9, i64 %idxprom
  %since = getelementptr inbounds %struct.commandHistory, ptr %arrayidx, i32 0, i32 0
  %11 = load ptr, ptr %since, align 8
  call void @addReplyBulkCString(ptr noundef %7, ptr noundef %11)
  %12 = load ptr, ptr %c.addr, align 8
  %13 = load ptr, ptr %cmd.addr, align 8
  %history3 = getelementptr inbounds %struct.redisCommand, ptr %13, i32 0, i32 8
  %14 = load ptr, ptr %history3, align 8
  %15 = load i32, ptr %j, align 4
  %idxprom4 = sext i32 %15 to i64
  %arrayidx5 = getelementptr inbounds %struct.commandHistory, ptr %14, i64 %idxprom4
  %changes = getelementptr inbounds %struct.commandHistory, ptr %arrayidx5, i32 0, i32 1
  %16 = load ptr, ptr %changes, align 8
  call void @addReplyBulkCString(ptr noundef %12, ptr noundef %16)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, ptr %j, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !53

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandTips(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr %cmd.addr, align 8
  %num_tips = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 11
  %2 = load i32, ptr %num_tips, align 8
  %conv = sext i32 %2 to i64
  call void @addReplySetLen(ptr noundef %0, i64 noundef %conv)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %j, align 4
  %4 = load ptr, ptr %cmd.addr, align 8
  %num_tips1 = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 11
  %5 = load i32, ptr %num_tips1, align 8
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %c.addr, align 8
  %7 = load ptr, ptr %cmd.addr, align 8
  %tips = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 10
  %8 = load ptr, ptr %tips, align 8
  %9 = load i32, ptr %j, align 4
  %idxprom = sext i32 %9 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %8, i64 %idxprom
  %10 = load ptr, ptr %arrayidx, align 8
  call void @addReplyBulkCString(ptr noundef %6, ptr noundef %10)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, ptr %j, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !54

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandKeySpecs(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %maplen = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr %cmd.addr, align 8
  %key_specs_num = getelementptr inbounds %struct.redisCommand, ptr %1, i32 0, i32 17
  %2 = load i32, ptr %key_specs_num, align 8
  %conv = sext i32 %2 to i64
  call void @addReplySetLen(ptr noundef %0, i64 noundef %conv)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %i, align 4
  %4 = load ptr, ptr %cmd.addr, align 8
  %key_specs_num1 = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 17
  %5 = load i32, ptr %key_specs_num1, align 8
  %cmp = icmp slt i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 3, ptr %maplen, align 4
  %6 = load ptr, ptr %cmd.addr, align 8
  %key_specs = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 16
  %7 = load ptr, ptr %key_specs, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds %struct.keySpec, ptr %7, i64 %idxprom
  %notes = getelementptr inbounds %struct.keySpec, ptr %arrayidx, i32 0, i32 0
  %9 = load ptr, ptr %notes, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load i32, ptr %maplen, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %maplen, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %11 = load ptr, ptr %c.addr, align 8
  %12 = load i32, ptr %maplen, align 4
  %conv3 = sext i32 %12 to i64
  call void @addReplyMapLen(ptr noundef %11, i64 noundef %conv3)
  %13 = load ptr, ptr %cmd.addr, align 8
  %key_specs4 = getelementptr inbounds %struct.redisCommand, ptr %13, i32 0, i32 16
  %14 = load ptr, ptr %key_specs4, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom5 = sext i32 %15 to i64
  %arrayidx6 = getelementptr inbounds %struct.keySpec, ptr %14, i64 %idxprom5
  %notes7 = getelementptr inbounds %struct.keySpec, ptr %arrayidx6, i32 0, i32 0
  %16 = load ptr, ptr %notes7, align 8
  %tobool8 = icmp ne ptr %16, null
  br i1 %tobool8, label %if.then9, label %if.end14

if.then9:                                         ; preds = %if.end
  %17 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %17, ptr noundef @.str.275)
  %18 = load ptr, ptr %c.addr, align 8
  %19 = load ptr, ptr %cmd.addr, align 8
  %key_specs10 = getelementptr inbounds %struct.redisCommand, ptr %19, i32 0, i32 16
  %20 = load ptr, ptr %key_specs10, align 8
  %21 = load i32, ptr %i, align 4
  %idxprom11 = sext i32 %21 to i64
  %arrayidx12 = getelementptr inbounds %struct.keySpec, ptr %20, i64 %idxprom11
  %notes13 = getelementptr inbounds %struct.keySpec, ptr %arrayidx12, i32 0, i32 0
  %22 = load ptr, ptr %notes13, align 8
  call void @addReplyBulkCString(ptr noundef %18, ptr noundef %22)
  br label %if.end14

if.end14:                                         ; preds = %if.then9, %if.end
  %23 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %23, ptr noundef @.str.273)
  %24 = load ptr, ptr %c.addr, align 8
  %25 = load ptr, ptr %cmd.addr, align 8
  %key_specs15 = getelementptr inbounds %struct.redisCommand, ptr %25, i32 0, i32 16
  %26 = load ptr, ptr %key_specs15, align 8
  %27 = load i32, ptr %i, align 4
  %idxprom16 = sext i32 %27 to i64
  %arrayidx17 = getelementptr inbounds %struct.keySpec, ptr %26, i64 %idxprom16
  %flags = getelementptr inbounds %struct.keySpec, ptr %arrayidx17, i32 0, i32 1
  %28 = load i64, ptr %flags, align 8
  call void @addReplyFlagsForKeyArgs(ptr noundef %24, i64 noundef %28)
  %29 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %29, ptr noundef @.str.276)
  %30 = load ptr, ptr %cmd.addr, align 8
  %key_specs18 = getelementptr inbounds %struct.redisCommand, ptr %30, i32 0, i32 16
  %31 = load ptr, ptr %key_specs18, align 8
  %32 = load i32, ptr %i, align 4
  %idxprom19 = sext i32 %32 to i64
  %arrayidx20 = getelementptr inbounds %struct.keySpec, ptr %31, i64 %idxprom19
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx20, i32 0, i32 2
  %33 = load i32, ptr %begin_search_type, align 8
  switch i32 %33, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb21
    i32 3, label %sw.bb26
  ]

sw.bb:                                            ; preds = %if.end14
  %34 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %34, i64 noundef 2)
  %35 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %35, ptr noundef @.str.266)
  %36 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %36, ptr noundef @.str.277)
  %37 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %37, ptr noundef @.str.278)
  %38 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %38, i64 noundef 0)
  br label %sw.epilog

sw.bb21:                                          ; preds = %if.end14
  %39 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %39, i64 noundef 2)
  %40 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %40, ptr noundef @.str.266)
  %41 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %41, ptr noundef @.str.279)
  %42 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %42, ptr noundef @.str.278)
  %43 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %43, i64 noundef 1)
  %44 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %44, ptr noundef @.str.279)
  %45 = load ptr, ptr %c.addr, align 8
  %46 = load ptr, ptr %cmd.addr, align 8
  %key_specs22 = getelementptr inbounds %struct.redisCommand, ptr %46, i32 0, i32 16
  %47 = load ptr, ptr %key_specs22, align 8
  %48 = load i32, ptr %i, align 4
  %idxprom23 = sext i32 %48 to i64
  %arrayidx24 = getelementptr inbounds %struct.keySpec, ptr %47, i64 %idxprom23
  %bs = getelementptr inbounds %struct.keySpec, ptr %arrayidx24, i32 0, i32 3
  %pos = getelementptr inbounds %struct.anon.0, ptr %bs, i32 0, i32 0
  %49 = load i32, ptr %pos, align 8
  %conv25 = sext i32 %49 to i64
  call void @addReplyLongLong(ptr noundef %45, i64 noundef %conv25)
  br label %sw.epilog

sw.bb26:                                          ; preds = %if.end14
  %50 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %50, i64 noundef 2)
  %51 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %51, ptr noundef @.str.266)
  %52 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %52, ptr noundef @.str.280)
  %53 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %53, ptr noundef @.str.278)
  %54 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %54, i64 noundef 2)
  %55 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %55, ptr noundef @.str.280)
  %56 = load ptr, ptr %c.addr, align 8
  %57 = load ptr, ptr %cmd.addr, align 8
  %key_specs27 = getelementptr inbounds %struct.redisCommand, ptr %57, i32 0, i32 16
  %58 = load ptr, ptr %key_specs27, align 8
  %59 = load i32, ptr %i, align 4
  %idxprom28 = sext i32 %59 to i64
  %arrayidx29 = getelementptr inbounds %struct.keySpec, ptr %58, i64 %idxprom28
  %bs30 = getelementptr inbounds %struct.keySpec, ptr %arrayidx29, i32 0, i32 3
  %keyword = getelementptr inbounds %struct.anon.1, ptr %bs30, i32 0, i32 0
  %60 = load ptr, ptr %keyword, align 8
  call void @addReplyBulkCString(ptr noundef %56, ptr noundef %60)
  %61 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %61, ptr noundef @.str.281)
  %62 = load ptr, ptr %c.addr, align 8
  %63 = load ptr, ptr %cmd.addr, align 8
  %key_specs31 = getelementptr inbounds %struct.redisCommand, ptr %63, i32 0, i32 16
  %64 = load ptr, ptr %key_specs31, align 8
  %65 = load i32, ptr %i, align 4
  %idxprom32 = sext i32 %65 to i64
  %arrayidx33 = getelementptr inbounds %struct.keySpec, ptr %64, i64 %idxprom32
  %bs34 = getelementptr inbounds %struct.keySpec, ptr %arrayidx33, i32 0, i32 3
  %startfrom = getelementptr inbounds %struct.anon.1, ptr %bs34, i32 0, i32 1
  %66 = load i32, ptr %startfrom, align 8
  %conv35 = sext i32 %66 to i64
  call void @addReplyLongLong(ptr noundef %62, i64 noundef %conv35)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end14
  %67 = load ptr, ptr %cmd.addr, align 8
  %key_specs36 = getelementptr inbounds %struct.redisCommand, ptr %67, i32 0, i32 16
  %68 = load ptr, ptr %key_specs36, align 8
  %69 = load i32, ptr %i, align 4
  %idxprom37 = sext i32 %69 to i64
  %arrayidx38 = getelementptr inbounds %struct.keySpec, ptr %68, i64 %idxprom37
  %begin_search_type39 = getelementptr inbounds %struct.keySpec, ptr %arrayidx38, i32 0, i32 2
  %70 = load i32, ptr %begin_search_type39, align 8
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 4898, ptr noundef @.str.282, i32 noundef %70)
  call void @abort() #16
  unreachable

sw.epilog:                                        ; preds = %sw.bb26, %sw.bb21, %sw.bb
  %71 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %71, ptr noundef @.str.283)
  %72 = load ptr, ptr %cmd.addr, align 8
  %key_specs40 = getelementptr inbounds %struct.redisCommand, ptr %72, i32 0, i32 16
  %73 = load ptr, ptr %key_specs40, align 8
  %74 = load i32, ptr %i, align 4
  %idxprom41 = sext i32 %74 to i64
  %arrayidx42 = getelementptr inbounds %struct.keySpec, ptr %73, i64 %idxprom41
  %find_keys_type = getelementptr inbounds %struct.keySpec, ptr %arrayidx42, i32 0, i32 4
  %75 = load i32, ptr %find_keys_type, align 8
  switch i32 %75, label %sw.default76 [
    i32 1, label %sw.bb43
    i32 2, label %sw.bb44
    i32 3, label %sw.bb59
  ]

sw.bb43:                                          ; preds = %sw.epilog
  %76 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %76, i64 noundef 2)
  %77 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %77, ptr noundef @.str.266)
  %78 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %78, ptr noundef @.str.277)
  %79 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %79, ptr noundef @.str.278)
  %80 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %80, i64 noundef 0)
  br label %sw.epilog81

sw.bb44:                                          ; preds = %sw.epilog
  %81 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %81, i64 noundef 2)
  %82 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %82, ptr noundef @.str.266)
  %83 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %83, ptr noundef @.str.284)
  %84 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %84, ptr noundef @.str.278)
  %85 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %85, i64 noundef 3)
  %86 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %86, ptr noundef @.str.285)
  %87 = load ptr, ptr %c.addr, align 8
  %88 = load ptr, ptr %cmd.addr, align 8
  %key_specs45 = getelementptr inbounds %struct.redisCommand, ptr %88, i32 0, i32 16
  %89 = load ptr, ptr %key_specs45, align 8
  %90 = load i32, ptr %i, align 4
  %idxprom46 = sext i32 %90 to i64
  %arrayidx47 = getelementptr inbounds %struct.keySpec, ptr %89, i64 %idxprom46
  %fk = getelementptr inbounds %struct.keySpec, ptr %arrayidx47, i32 0, i32 5
  %lastkey = getelementptr inbounds %struct.anon.3, ptr %fk, i32 0, i32 0
  %91 = load i32, ptr %lastkey, align 4
  %conv48 = sext i32 %91 to i64
  call void @addReplyLongLong(ptr noundef %87, i64 noundef %conv48)
  %92 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %92, ptr noundef @.str.286)
  %93 = load ptr, ptr %c.addr, align 8
  %94 = load ptr, ptr %cmd.addr, align 8
  %key_specs49 = getelementptr inbounds %struct.redisCommand, ptr %94, i32 0, i32 16
  %95 = load ptr, ptr %key_specs49, align 8
  %96 = load i32, ptr %i, align 4
  %idxprom50 = sext i32 %96 to i64
  %arrayidx51 = getelementptr inbounds %struct.keySpec, ptr %95, i64 %idxprom50
  %fk52 = getelementptr inbounds %struct.keySpec, ptr %arrayidx51, i32 0, i32 5
  %keystep = getelementptr inbounds %struct.anon.3, ptr %fk52, i32 0, i32 1
  %97 = load i32, ptr %keystep, align 4
  %conv53 = sext i32 %97 to i64
  call void @addReplyLongLong(ptr noundef %93, i64 noundef %conv53)
  %98 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %98, ptr noundef @.str.287)
  %99 = load ptr, ptr %c.addr, align 8
  %100 = load ptr, ptr %cmd.addr, align 8
  %key_specs54 = getelementptr inbounds %struct.redisCommand, ptr %100, i32 0, i32 16
  %101 = load ptr, ptr %key_specs54, align 8
  %102 = load i32, ptr %i, align 4
  %idxprom55 = sext i32 %102 to i64
  %arrayidx56 = getelementptr inbounds %struct.keySpec, ptr %101, i64 %idxprom55
  %fk57 = getelementptr inbounds %struct.keySpec, ptr %arrayidx56, i32 0, i32 5
  %limit = getelementptr inbounds %struct.anon.3, ptr %fk57, i32 0, i32 2
  %103 = load i32, ptr %limit, align 4
  %conv58 = sext i32 %103 to i64
  call void @addReplyLongLong(ptr noundef %99, i64 noundef %conv58)
  br label %sw.epilog81

sw.bb59:                                          ; preds = %sw.epilog
  %104 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %104, i64 noundef 2)
  %105 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %105, ptr noundef @.str.266)
  %106 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %106, ptr noundef @.str.288)
  %107 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %107, ptr noundef @.str.278)
  %108 = load ptr, ptr %c.addr, align 8
  call void @addReplyMapLen(ptr noundef %108, i64 noundef 3)
  %109 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %109, ptr noundef @.str.289)
  %110 = load ptr, ptr %c.addr, align 8
  %111 = load ptr, ptr %cmd.addr, align 8
  %key_specs60 = getelementptr inbounds %struct.redisCommand, ptr %111, i32 0, i32 16
  %112 = load ptr, ptr %key_specs60, align 8
  %113 = load i32, ptr %i, align 4
  %idxprom61 = sext i32 %113 to i64
  %arrayidx62 = getelementptr inbounds %struct.keySpec, ptr %112, i64 %idxprom61
  %fk63 = getelementptr inbounds %struct.keySpec, ptr %arrayidx62, i32 0, i32 5
  %keynumidx = getelementptr inbounds %struct.anon.4, ptr %fk63, i32 0, i32 0
  %114 = load i32, ptr %keynumidx, align 4
  %conv64 = sext i32 %114 to i64
  call void @addReplyLongLong(ptr noundef %110, i64 noundef %conv64)
  %115 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %115, ptr noundef @.str.290)
  %116 = load ptr, ptr %c.addr, align 8
  %117 = load ptr, ptr %cmd.addr, align 8
  %key_specs65 = getelementptr inbounds %struct.redisCommand, ptr %117, i32 0, i32 16
  %118 = load ptr, ptr %key_specs65, align 8
  %119 = load i32, ptr %i, align 4
  %idxprom66 = sext i32 %119 to i64
  %arrayidx67 = getelementptr inbounds %struct.keySpec, ptr %118, i64 %idxprom66
  %fk68 = getelementptr inbounds %struct.keySpec, ptr %arrayidx67, i32 0, i32 5
  %firstkey = getelementptr inbounds %struct.anon.4, ptr %fk68, i32 0, i32 1
  %120 = load i32, ptr %firstkey, align 4
  %conv69 = sext i32 %120 to i64
  call void @addReplyLongLong(ptr noundef %116, i64 noundef %conv69)
  %121 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %121, ptr noundef @.str.286)
  %122 = load ptr, ptr %c.addr, align 8
  %123 = load ptr, ptr %cmd.addr, align 8
  %key_specs70 = getelementptr inbounds %struct.redisCommand, ptr %123, i32 0, i32 16
  %124 = load ptr, ptr %key_specs70, align 8
  %125 = load i32, ptr %i, align 4
  %idxprom71 = sext i32 %125 to i64
  %arrayidx72 = getelementptr inbounds %struct.keySpec, ptr %124, i64 %idxprom71
  %fk73 = getelementptr inbounds %struct.keySpec, ptr %arrayidx72, i32 0, i32 5
  %keystep74 = getelementptr inbounds %struct.anon.4, ptr %fk73, i32 0, i32 2
  %126 = load i32, ptr %keystep74, align 4
  %conv75 = sext i32 %126 to i64
  call void @addReplyLongLong(ptr noundef %122, i64 noundef %conv75)
  br label %sw.epilog81

sw.default76:                                     ; preds = %sw.epilog
  %127 = load ptr, ptr %cmd.addr, align 8
  %key_specs77 = getelementptr inbounds %struct.redisCommand, ptr %127, i32 0, i32 16
  %128 = load ptr, ptr %key_specs77, align 8
  %129 = load i32, ptr %i, align 4
  %idxprom78 = sext i32 %129 to i64
  %arrayidx79 = getelementptr inbounds %struct.keySpec, ptr %128, i64 %idxprom78
  %begin_search_type80 = getelementptr inbounds %struct.keySpec, ptr %arrayidx79, i32 0, i32 2
  %130 = load i32, ptr %begin_search_type80, align 8
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 4940, ptr noundef @.str.291, i32 noundef %130)
  call void @abort() #16
  unreachable

sw.epilog81:                                      ; preds = %sw.bb59, %sw.bb44, %sw.bb43
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog81
  %131 = load i32, ptr %i, align 4
  %inc82 = add nsw i32 %131, 1
  store i32 %inc82, ptr %i, align 4
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandSubCommands(ptr noundef %c, ptr noundef %cmd, ptr noundef %reply_function, i32 noundef %use_map) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %reply_function.addr = alloca ptr, align 8
  %use_map.addr = alloca i32, align 4
  %de = alloca ptr, align 8
  %di = alloca ptr, align 8
  %sub = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  store ptr %reply_function, ptr %reply_function.addr, align 8
  store i32 %use_map, ptr %use_map.addr, align 4
  %0 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 30
  %1 = load ptr, ptr %subcommands_dict, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  call void @addReplySetLen(ptr noundef %2, i64 noundef 0)
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %use_map.addr, align 4
  %tobool1 = icmp ne i32 %3, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %4 = load ptr, ptr %c.addr, align 8
  %5 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict3 = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 30
  %6 = load ptr, ptr %subcommands_dict3, align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %6, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %7 = load i64, ptr %arrayidx, align 8
  %8 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict4 = getelementptr inbounds %struct.redisCommand, ptr %8, i32 0, i32 30
  %9 = load ptr, ptr %subcommands_dict4, align 8
  %ht_used5 = getelementptr inbounds %struct.dict, ptr %9, i32 0, i32 2
  %arrayidx6 = getelementptr inbounds [2 x i64], ptr %ht_used5, i64 0, i64 1
  %10 = load i64, ptr %arrayidx6, align 8
  %add = add i64 %7, %10
  call void @addReplyMapLen(ptr noundef %4, i64 noundef %add)
  br label %if.end14

if.else:                                          ; preds = %if.end
  %11 = load ptr, ptr %c.addr, align 8
  %12 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict7 = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 30
  %13 = load ptr, ptr %subcommands_dict7, align 8
  %ht_used8 = getelementptr inbounds %struct.dict, ptr %13, i32 0, i32 2
  %arrayidx9 = getelementptr inbounds [2 x i64], ptr %ht_used8, i64 0, i64 0
  %14 = load i64, ptr %arrayidx9, align 8
  %15 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict10 = getelementptr inbounds %struct.redisCommand, ptr %15, i32 0, i32 30
  %16 = load ptr, ptr %subcommands_dict10, align 8
  %ht_used11 = getelementptr inbounds %struct.dict, ptr %16, i32 0, i32 2
  %arrayidx12 = getelementptr inbounds [2 x i64], ptr %ht_used11, i64 0, i64 1
  %17 = load i64, ptr %arrayidx12, align 8
  %add13 = add i64 %14, %17
  call void @addReplyArrayLen(ptr noundef %11, i64 noundef %add13)
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then2
  %18 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict15 = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 30
  %19 = load ptr, ptr %subcommands_dict15, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %19)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end22, %if.end14
  %20 = load ptr, ptr %di, align 8
  %call16 = call ptr @dictNext(ptr noundef %20)
  store ptr %call16, ptr %de, align 8
  %cmp = icmp ne ptr %call16, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %de, align 8
  %call17 = call ptr @dictGetVal(ptr noundef %21)
  store ptr %call17, ptr %sub, align 8
  %22 = load i32, ptr %use_map.addr, align 4
  %tobool18 = icmp ne i32 %22, 0
  br i1 %tobool18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %while.body
  %23 = load ptr, ptr %c.addr, align 8
  %24 = load ptr, ptr %sub, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %24, i32 0, i32 27
  %25 = load ptr, ptr %fullname, align 8
  %26 = load ptr, ptr %sub, align 8
  %fullname20 = getelementptr inbounds %struct.redisCommand, ptr %26, i32 0, i32 27
  %27 = load ptr, ptr %fullname20, align 8
  %call21 = call i64 @sdslen(ptr noundef %27)
  call void @addReplyBulkCBuffer(ptr noundef %23, ptr noundef %25, i64 noundef %call21)
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %while.body
  %28 = load ptr, ptr %reply_function.addr, align 8
  %29 = load ptr, ptr %c.addr, align 8
  %30 = load ptr, ptr %sub, align 8
  call void %28(ptr noundef %29, ptr noundef %30)
  br label %while.cond, !llvm.loop !56

while.end:                                        ; preds = %while.cond
  %31 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %31)
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandInfo(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %firstkey = alloca i32, align 4
  %lastkey = alloca i32, align 4
  %keystep = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %c.addr, align 8
  call void @addReplyNull(ptr noundef %1)
  br label %if.end15

if.else:                                          ; preds = %entry
  store i32 0, ptr %firstkey, align 4
  store i32 0, ptr %lastkey, align 4
  store i32 0, ptr %keystep, align 4
  %2 = load ptr, ptr %cmd.addr, align 8
  %legacy_range_key_spec = getelementptr inbounds %struct.redisCommand, ptr %2, i32 0, i32 29
  %begin_search_type = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec, i32 0, i32 2
  %3 = load i32, ptr %begin_search_type, align 8
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then1, label %if.end10

if.then1:                                         ; preds = %if.else
  %4 = load ptr, ptr %cmd.addr, align 8
  %legacy_range_key_spec2 = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 29
  %bs = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec2, i32 0, i32 3
  %pos = getelementptr inbounds %struct.anon.0, ptr %bs, i32 0, i32 0
  %5 = load i32, ptr %pos, align 8
  store i32 %5, ptr %firstkey, align 4
  %6 = load ptr, ptr %cmd.addr, align 8
  %legacy_range_key_spec3 = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 29
  %fk = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec3, i32 0, i32 5
  %lastkey4 = getelementptr inbounds %struct.anon.3, ptr %fk, i32 0, i32 0
  %7 = load i32, ptr %lastkey4, align 4
  store i32 %7, ptr %lastkey, align 4
  %8 = load i32, ptr %lastkey, align 4
  %cmp5 = icmp sge i32 %8, 0
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then1
  %9 = load i32, ptr %firstkey, align 4
  %10 = load i32, ptr %lastkey, align 4
  %add = add nsw i32 %10, %9
  store i32 %add, ptr %lastkey, align 4
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then1
  %11 = load ptr, ptr %cmd.addr, align 8
  %legacy_range_key_spec7 = getelementptr inbounds %struct.redisCommand, ptr %11, i32 0, i32 29
  %fk8 = getelementptr inbounds %struct.keySpec, ptr %legacy_range_key_spec7, i32 0, i32 5
  %keystep9 = getelementptr inbounds %struct.anon.3, ptr %fk8, i32 0, i32 1
  %12 = load i32, ptr %keystep9, align 4
  store i32 %12, ptr %keystep, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.else
  %13 = load ptr, ptr %c.addr, align 8
  call void @addReplyArrayLen(ptr noundef %13, i64 noundef 10)
  %14 = load ptr, ptr %c.addr, align 8
  %15 = load ptr, ptr %cmd.addr, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %15, i32 0, i32 27
  %16 = load ptr, ptr %fullname, align 8
  %17 = load ptr, ptr %cmd.addr, align 8
  %fullname11 = getelementptr inbounds %struct.redisCommand, ptr %17, i32 0, i32 27
  %18 = load ptr, ptr %fullname11, align 8
  %call = call i64 @sdslen(ptr noundef %18)
  call void @addReplyBulkCBuffer(ptr noundef %14, ptr noundef %16, i64 noundef %call)
  %19 = load ptr, ptr %c.addr, align 8
  %20 = load ptr, ptr %cmd.addr, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %20, i32 0, i32 13
  %21 = load i32, ptr %arity, align 8
  %conv = sext i32 %21 to i64
  call void @addReplyLongLong(ptr noundef %19, i64 noundef %conv)
  %22 = load ptr, ptr %c.addr, align 8
  %23 = load ptr, ptr %cmd.addr, align 8
  call void @addReplyFlagsForCommand(ptr noundef %22, ptr noundef %23)
  %24 = load ptr, ptr %c.addr, align 8
  %25 = load i32, ptr %firstkey, align 4
  %conv12 = sext i32 %25 to i64
  call void @addReplyLongLong(ptr noundef %24, i64 noundef %conv12)
  %26 = load ptr, ptr %c.addr, align 8
  %27 = load i32, ptr %lastkey, align 4
  %conv13 = sext i32 %27 to i64
  call void @addReplyLongLong(ptr noundef %26, i64 noundef %conv13)
  %28 = load ptr, ptr %c.addr, align 8
  %29 = load i32, ptr %keystep, align 4
  %conv14 = sext i32 %29 to i64
  call void @addReplyLongLong(ptr noundef %28, i64 noundef %conv14)
  %30 = load ptr, ptr %c.addr, align 8
  %31 = load ptr, ptr %cmd.addr, align 8
  call void @addReplyCommandCategories(ptr noundef %30, ptr noundef %31)
  %32 = load ptr, ptr %c.addr, align 8
  %33 = load ptr, ptr %cmd.addr, align 8
  call void @addReplyCommandTips(ptr noundef %32, ptr noundef %33)
  %34 = load ptr, ptr %c.addr, align 8
  %35 = load ptr, ptr %cmd.addr, align 8
  call void @addReplyCommandKeySpecs(ptr noundef %34, ptr noundef %35)
  %36 = load ptr, ptr %c.addr, align 8
  %37 = load ptr, ptr %cmd.addr, align 8
  call void @addReplyCommandSubCommands(ptr noundef %36, ptr noundef %37, ptr noundef @addReplyCommandInfo, i32 noundef 0)
  br label %if.end15

if.end15:                                         ; preds = %if.end10, %if.then
  ret void
}

declare void @addReplyNull(ptr noundef) #2

declare void @addReplyCommandCategories(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @addReplyCommandDocs(ptr noundef %c, ptr noundef %cmd) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cmd.addr = alloca ptr, align 8
  %maplen = alloca i64, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  store i64 1, ptr %maplen, align 8
  %0 = load ptr, ptr %cmd.addr, align 8
  %summary = getelementptr inbounds %struct.redisCommand, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %summary, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %maplen, align 8
  %inc = add nsw i64 %2, 1
  store i64 %inc, ptr %maplen, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %cmd.addr, align 8
  %since = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %since, align 8
  %tobool1 = icmp ne ptr %4, null
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %5 = load i64, ptr %maplen, align 8
  %inc3 = add nsw i64 %5, 1
  store i64 %inc3, ptr %maplen, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %6 = load ptr, ptr %cmd.addr, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 14
  %7 = load i64, ptr %flags, align 8
  %and = and i64 %7, 8
  %tobool5 = icmp ne i64 %and, 0
  br i1 %tobool5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %8 = load i64, ptr %maplen, align 8
  %inc7 = add nsw i64 %8, 1
  store i64 %inc7, ptr %maplen, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %9 = load ptr, ptr %cmd.addr, align 8
  %complexity = getelementptr inbounds %struct.redisCommand, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %complexity, align 8
  %tobool9 = icmp ne ptr %10, null
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end8
  %11 = load i64, ptr %maplen, align 8
  %inc11 = add nsw i64 %11, 1
  store i64 %inc11, ptr %maplen, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end8
  %12 = load ptr, ptr %cmd.addr, align 8
  %doc_flags = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 4
  %13 = load i32, ptr %doc_flags, align 8
  %tobool13 = icmp ne i32 %13, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %14 = load i64, ptr %maplen, align 8
  %inc15 = add nsw i64 %14, 1
  store i64 %inc15, ptr %maplen, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %15 = load ptr, ptr %cmd.addr, align 8
  %deprecated_since = getelementptr inbounds %struct.redisCommand, ptr %15, i32 0, i32 6
  %16 = load ptr, ptr %deprecated_since, align 8
  %tobool17 = icmp ne ptr %16, null
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end16
  %17 = load i64, ptr %maplen, align 8
  %inc19 = add nsw i64 %17, 1
  store i64 %inc19, ptr %maplen, align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end16
  %18 = load ptr, ptr %cmd.addr, align 8
  %replaced_by = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 5
  %19 = load ptr, ptr %replaced_by, align 8
  %tobool21 = icmp ne ptr %19, null
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.end20
  %20 = load i64, ptr %maplen, align 8
  %inc23 = add nsw i64 %20, 1
  store i64 %inc23, ptr %maplen, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %if.end20
  %21 = load ptr, ptr %cmd.addr, align 8
  %history = getelementptr inbounds %struct.redisCommand, ptr %21, i32 0, i32 8
  %22 = load ptr, ptr %history, align 8
  %tobool25 = icmp ne ptr %22, null
  br i1 %tobool25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end24
  %23 = load i64, ptr %maplen, align 8
  %inc27 = add nsw i64 %23, 1
  store i64 %inc27, ptr %maplen, align 8
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end24
  %24 = load ptr, ptr %cmd.addr, align 8
  %args = getelementptr inbounds %struct.redisCommand, ptr %24, i32 0, i32 21
  %25 = load ptr, ptr %args, align 8
  %tobool29 = icmp ne ptr %25, null
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end28
  %26 = load i64, ptr %maplen, align 8
  %inc31 = add nsw i64 %26, 1
  store i64 %inc31, ptr %maplen, align 8
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end28
  %27 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %27, i32 0, i32 30
  %28 = load ptr, ptr %subcommands_dict, align 8
  %tobool33 = icmp ne ptr %28, null
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end32
  %29 = load i64, ptr %maplen, align 8
  %inc35 = add nsw i64 %29, 1
  store i64 %inc35, ptr %maplen, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end32
  %30 = load ptr, ptr %c.addr, align 8
  %31 = load i64, ptr %maplen, align 8
  call void @addReplyMapLen(ptr noundef %30, i64 noundef %31)
  %32 = load ptr, ptr %cmd.addr, align 8
  %summary37 = getelementptr inbounds %struct.redisCommand, ptr %32, i32 0, i32 1
  %33 = load ptr, ptr %summary37, align 8
  %tobool38 = icmp ne ptr %33, null
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %34 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %34, ptr noundef @.str.270)
  %35 = load ptr, ptr %c.addr, align 8
  %36 = load ptr, ptr %cmd.addr, align 8
  %summary40 = getelementptr inbounds %struct.redisCommand, ptr %36, i32 0, i32 1
  %37 = load ptr, ptr %summary40, align 8
  call void @addReplyBulkCString(ptr noundef %35, ptr noundef %37)
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %38 = load ptr, ptr %cmd.addr, align 8
  %since42 = getelementptr inbounds %struct.redisCommand, ptr %38, i32 0, i32 3
  %39 = load ptr, ptr %since42, align 8
  %tobool43 = icmp ne ptr %39, null
  br i1 %tobool43, label %if.then44, label %if.end46

if.then44:                                        ; preds = %if.end41
  %40 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %40, ptr noundef @.str.271)
  %41 = load ptr, ptr %c.addr, align 8
  %42 = load ptr, ptr %cmd.addr, align 8
  %since45 = getelementptr inbounds %struct.redisCommand, ptr %42, i32 0, i32 3
  %43 = load ptr, ptr %since45, align 8
  call void @addReplyBulkCString(ptr noundef %41, ptr noundef %43)
  br label %if.end46

if.end46:                                         ; preds = %if.then44, %if.end41
  %44 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %44, ptr noundef @.str.292)
  %45 = load ptr, ptr %c.addr, align 8
  %46 = load ptr, ptr %cmd.addr, align 8
  %group = getelementptr inbounds %struct.redisCommand, ptr %46, i32 0, i32 7
  %47 = load i32, ptr %group, align 8
  %call = call ptr @commandGroupStr(i32 noundef %47)
  call void @addReplyBulkCString(ptr noundef %45, ptr noundef %call)
  %48 = load ptr, ptr %cmd.addr, align 8
  %complexity47 = getelementptr inbounds %struct.redisCommand, ptr %48, i32 0, i32 2
  %49 = load ptr, ptr %complexity47, align 8
  %tobool48 = icmp ne ptr %49, null
  br i1 %tobool48, label %if.then49, label %if.end51

if.then49:                                        ; preds = %if.end46
  %50 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %50, ptr noundef @.str.293)
  %51 = load ptr, ptr %c.addr, align 8
  %52 = load ptr, ptr %cmd.addr, align 8
  %complexity50 = getelementptr inbounds %struct.redisCommand, ptr %52, i32 0, i32 2
  %53 = load ptr, ptr %complexity50, align 8
  call void @addReplyBulkCString(ptr noundef %51, ptr noundef %53)
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %if.end46
  %54 = load ptr, ptr %cmd.addr, align 8
  %flags52 = getelementptr inbounds %struct.redisCommand, ptr %54, i32 0, i32 14
  %55 = load i64, ptr %flags52, align 8
  %and53 = and i64 %55, 8
  %tobool54 = icmp ne i64 %and53, 0
  br i1 %tobool54, label %if.then55, label %if.end57

if.then55:                                        ; preds = %if.end51
  %56 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %56, ptr noundef @.str.223)
  %57 = load ptr, ptr %c.addr, align 8
  %58 = load ptr, ptr %cmd.addr, align 8
  %call56 = call ptr @moduleNameFromCommand(ptr noundef %58)
  call void @addReplyBulkCString(ptr noundef %57, ptr noundef %call56)
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %if.end51
  %59 = load ptr, ptr %cmd.addr, align 8
  %doc_flags58 = getelementptr inbounds %struct.redisCommand, ptr %59, i32 0, i32 4
  %60 = load i32, ptr %doc_flags58, align 8
  %tobool59 = icmp ne i32 %60, 0
  br i1 %tobool59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end57
  %61 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %61, ptr noundef @.str.294)
  %62 = load ptr, ptr %c.addr, align 8
  %63 = load ptr, ptr %cmd.addr, align 8
  call void @addReplyDocFlagsForCommand(ptr noundef %62, ptr noundef %63)
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.end57
  %64 = load ptr, ptr %cmd.addr, align 8
  %deprecated_since62 = getelementptr inbounds %struct.redisCommand, ptr %64, i32 0, i32 6
  %65 = load ptr, ptr %deprecated_since62, align 8
  %tobool63 = icmp ne ptr %65, null
  br i1 %tobool63, label %if.then64, label %if.end66

if.then64:                                        ; preds = %if.end61
  %66 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %66, ptr noundef @.str.272)
  %67 = load ptr, ptr %c.addr, align 8
  %68 = load ptr, ptr %cmd.addr, align 8
  %deprecated_since65 = getelementptr inbounds %struct.redisCommand, ptr %68, i32 0, i32 6
  %69 = load ptr, ptr %deprecated_since65, align 8
  call void @addReplyBulkCString(ptr noundef %67, ptr noundef %69)
  br label %if.end66

if.end66:                                         ; preds = %if.then64, %if.end61
  %70 = load ptr, ptr %cmd.addr, align 8
  %replaced_by67 = getelementptr inbounds %struct.redisCommand, ptr %70, i32 0, i32 5
  %71 = load ptr, ptr %replaced_by67, align 8
  %tobool68 = icmp ne ptr %71, null
  br i1 %tobool68, label %if.then69, label %if.end71

if.then69:                                        ; preds = %if.end66
  %72 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %72, ptr noundef @.str.295)
  %73 = load ptr, ptr %c.addr, align 8
  %74 = load ptr, ptr %cmd.addr, align 8
  %replaced_by70 = getelementptr inbounds %struct.redisCommand, ptr %74, i32 0, i32 5
  %75 = load ptr, ptr %replaced_by70, align 8
  call void @addReplyBulkCString(ptr noundef %73, ptr noundef %75)
  br label %if.end71

if.end71:                                         ; preds = %if.then69, %if.end66
  %76 = load ptr, ptr %cmd.addr, align 8
  %history72 = getelementptr inbounds %struct.redisCommand, ptr %76, i32 0, i32 8
  %77 = load ptr, ptr %history72, align 8
  %tobool73 = icmp ne ptr %77, null
  br i1 %tobool73, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.end71
  %78 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %78, ptr noundef @.str.296)
  %79 = load ptr, ptr %c.addr, align 8
  %80 = load ptr, ptr %cmd.addr, align 8
  call void @addReplyCommandHistory(ptr noundef %79, ptr noundef %80)
  br label %if.end75

if.end75:                                         ; preds = %if.then74, %if.end71
  %81 = load ptr, ptr %cmd.addr, align 8
  %args76 = getelementptr inbounds %struct.redisCommand, ptr %81, i32 0, i32 21
  %82 = load ptr, ptr %args76, align 8
  %tobool77 = icmp ne ptr %82, null
  br i1 %tobool77, label %if.then78, label %if.end80

if.then78:                                        ; preds = %if.end75
  %83 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %83, ptr noundef @.str.274)
  %84 = load ptr, ptr %c.addr, align 8
  %85 = load ptr, ptr %cmd.addr, align 8
  %args79 = getelementptr inbounds %struct.redisCommand, ptr %85, i32 0, i32 21
  %86 = load ptr, ptr %args79, align 8
  %87 = load ptr, ptr %cmd.addr, align 8
  %num_args = getelementptr inbounds %struct.redisCommand, ptr %87, i32 0, i32 19
  %88 = load i32, ptr %num_args, align 8
  call void @addReplyCommandArgList(ptr noundef %84, ptr noundef %86, i32 noundef %88)
  br label %if.end80

if.end80:                                         ; preds = %if.then78, %if.end75
  %89 = load ptr, ptr %cmd.addr, align 8
  %subcommands_dict81 = getelementptr inbounds %struct.redisCommand, ptr %89, i32 0, i32 30
  %90 = load ptr, ptr %subcommands_dict81, align 8
  %tobool82 = icmp ne ptr %90, null
  br i1 %tobool82, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.end80
  %91 = load ptr, ptr %c.addr, align 8
  call void @addReplyBulkCString(ptr noundef %91, ptr noundef @.str.297)
  %92 = load ptr, ptr %c.addr, align 8
  %93 = load ptr, ptr %cmd.addr, align 8
  call void @addReplyCommandSubCommands(ptr noundef %92, ptr noundef %93, ptr noundef @addReplyCommandDocs, i32 noundef 1)
  br label %if.end84

if.end84:                                         ; preds = %if.then83, %if.end80
  ret void
}

declare ptr @commandGroupStr(i32 noundef) #2

declare ptr @moduleNameFromCommand(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @getKeysSubcommandImpl(ptr noundef %c, i32 noundef %with_flags) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %with_flags.addr = alloca i32, align 4
  %cmd = alloca ptr, align 8
  %result = alloca %struct.getKeysResult, align 8
  %j = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i32 %with_flags, ptr %with_flags.addr, align 4
  %0 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 12
  %1 = load ptr, ptr %argv, align 8
  %add.ptr = getelementptr inbounds ptr, ptr %1, i64 2
  %2 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 11
  %3 = load i32, ptr %argc, align 8
  %sub = sub nsw i32 %3, 2
  %call = call ptr @lookupCommand(ptr noundef %add.ptr, i32 noundef %sub)
  store ptr %call, ptr %cmd, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %result, i8 0, i64 2064, i1 false)
  %4 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 3
  store i32 256, ptr %4, align 4
  %5 = load ptr, ptr %cmd, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %6, ptr noundef @.str.298)
  br label %return

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr %cmd, align 8
  %call1 = call i32 @doesCommandHaveKeys(ptr noundef %7)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.else4, label %if.then3

if.then3:                                         ; preds = %if.else
  %8 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %8, ptr noundef @.str.299)
  br label %return

if.else4:                                         ; preds = %if.else
  %9 = load ptr, ptr %cmd, align 8
  %arity = getelementptr inbounds %struct.redisCommand, ptr %9, i32 0, i32 13
  %10 = load i32, ptr %arity, align 8
  %cmp = icmp sgt i32 %10, 0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.else4
  %11 = load ptr, ptr %cmd, align 8
  %arity5 = getelementptr inbounds %struct.redisCommand, ptr %11, i32 0, i32 13
  %12 = load i32, ptr %arity5, align 8
  %13 = load ptr, ptr %c.addr, align 8
  %argc6 = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 11
  %14 = load i32, ptr %argc6, align 8
  %sub7 = sub nsw i32 %14, 2
  %cmp8 = icmp ne i32 %12, %sub7
  br i1 %cmp8, label %if.then14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.else4
  %15 = load ptr, ptr %c.addr, align 8
  %argc9 = getelementptr inbounds %struct.client, ptr %15, i32 0, i32 11
  %16 = load i32, ptr %argc9, align 8
  %sub10 = sub nsw i32 %16, 2
  %17 = load ptr, ptr %cmd, align 8
  %arity11 = getelementptr inbounds %struct.redisCommand, ptr %17, i32 0, i32 13
  %18 = load i32, ptr %arity11, align 8
  %sub12 = sub nsw i32 0, %18
  %cmp13 = icmp slt i32 %sub10, %sub12
  br i1 %cmp13, label %if.then14, label %if.end

if.then14:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %19 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %19, ptr noundef @.str.300)
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  br label %if.end15

if.end15:                                         ; preds = %if.end
  br label %if.end16

if.end16:                                         ; preds = %if.end15
  %20 = load ptr, ptr %cmd, align 8
  %21 = load ptr, ptr %c.addr, align 8
  %argv17 = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 12
  %22 = load ptr, ptr %argv17, align 8
  %add.ptr18 = getelementptr inbounds ptr, ptr %22, i64 2
  %23 = load ptr, ptr %c.addr, align 8
  %argc19 = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 11
  %24 = load i32, ptr %argc19, align 8
  %sub20 = sub nsw i32 %24, 2
  %call21 = call i32 @getKeysFromCommandWithSpecs(ptr noundef %20, ptr noundef %add.ptr18, i32 noundef %sub20, i32 noundef 0, ptr noundef %result)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.else28, label %if.then23

if.then23:                                        ; preds = %if.end16
  %25 = load ptr, ptr %cmd, align 8
  %flags = getelementptr inbounds %struct.redisCommand, ptr %25, i32 0, i32 14
  %26 = load i64, ptr %flags, align 8
  %and = and i64 %26, 524288
  %tobool24 = icmp ne i64 %and, 0
  br i1 %tobool24, label %if.then25, label %if.else26

if.then25:                                        ; preds = %if.then23
  %27 = load ptr, ptr %c.addr, align 8
  call void @addReplyArrayLen(ptr noundef %27, i64 noundef 0)
  br label %if.end27

if.else26:                                        ; preds = %if.then23
  %28 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %28, ptr noundef @.str.301)
  br label %if.end27

if.end27:                                         ; preds = %if.else26, %if.then25
  br label %if.end52

if.else28:                                        ; preds = %if.end16
  %29 = load ptr, ptr %c.addr, align 8
  %numkeys = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 2
  %30 = load i32, ptr %numkeys, align 8
  %conv = sext i32 %30 to i64
  call void @addReplyArrayLen(ptr noundef %29, i64 noundef %conv)
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else28
  %31 = load i32, ptr %j, align 4
  %numkeys29 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 2
  %32 = load i32, ptr %numkeys29, align 8
  %cmp30 = icmp slt i32 %31, %32
  br i1 %cmp30, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %33 = load i32, ptr %with_flags.addr, align 4
  %tobool32 = icmp ne i32 %33, 0
  br i1 %tobool32, label %if.else37, label %if.then33

if.then33:                                        ; preds = %for.body
  %34 = load ptr, ptr %c.addr, align 8
  %35 = load ptr, ptr %c.addr, align 8
  %argv34 = getelementptr inbounds %struct.client, ptr %35, i32 0, i32 12
  %36 = load ptr, ptr %argv34, align 8
  %keys = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 1
  %37 = load ptr, ptr %keys, align 8
  %38 = load i32, ptr %j, align 4
  %idxprom = sext i32 %38 to i64
  %arrayidx = getelementptr inbounds %struct.keyReference, ptr %37, i64 %idxprom
  %pos = getelementptr inbounds %struct.keyReference, ptr %arrayidx, i32 0, i32 0
  %39 = load i32, ptr %pos, align 4
  %add = add nsw i32 %39, 2
  %idxprom35 = sext i32 %add to i64
  %arrayidx36 = getelementptr inbounds ptr, ptr %36, i64 %idxprom35
  %40 = load ptr, ptr %arrayidx36, align 8
  call void @addReplyBulk(ptr noundef %34, ptr noundef %40)
  br label %if.end51

if.else37:                                        ; preds = %for.body
  %41 = load ptr, ptr %c.addr, align 8
  call void @addReplyArrayLen(ptr noundef %41, i64 noundef 2)
  %42 = load ptr, ptr %c.addr, align 8
  %43 = load ptr, ptr %c.addr, align 8
  %argv38 = getelementptr inbounds %struct.client, ptr %43, i32 0, i32 12
  %44 = load ptr, ptr %argv38, align 8
  %keys39 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 1
  %45 = load ptr, ptr %keys39, align 8
  %46 = load i32, ptr %j, align 4
  %idxprom40 = sext i32 %46 to i64
  %arrayidx41 = getelementptr inbounds %struct.keyReference, ptr %45, i64 %idxprom40
  %pos42 = getelementptr inbounds %struct.keyReference, ptr %arrayidx41, i32 0, i32 0
  %47 = load i32, ptr %pos42, align 4
  %add43 = add nsw i32 %47, 2
  %idxprom44 = sext i32 %add43 to i64
  %arrayidx45 = getelementptr inbounds ptr, ptr %44, i64 %idxprom44
  %48 = load ptr, ptr %arrayidx45, align 8
  call void @addReplyBulk(ptr noundef %42, ptr noundef %48)
  %49 = load ptr, ptr %c.addr, align 8
  %keys46 = getelementptr inbounds %struct.getKeysResult, ptr %result, i32 0, i32 1
  %50 = load ptr, ptr %keys46, align 8
  %51 = load i32, ptr %j, align 4
  %idxprom47 = sext i32 %51 to i64
  %arrayidx48 = getelementptr inbounds %struct.keyReference, ptr %50, i64 %idxprom47
  %flags49 = getelementptr inbounds %struct.keyReference, ptr %arrayidx48, i32 0, i32 1
  %52 = load i32, ptr %flags49, align 4
  %conv50 = sext i32 %52 to i64
  call void @addReplyFlagsForKeyArgs(ptr noundef %49, i64 noundef %conv50)
  br label %if.end51

if.end51:                                         ; preds = %if.else37, %if.then33
  br label %for.inc

for.inc:                                          ; preds = %if.end51
  %53 = load i32, ptr %j, align 4
  %inc = add nsw i32 %53, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !57

for.end:                                          ; preds = %for.cond
  br label %if.end52

if.end52:                                         ; preds = %for.end, %if.end27
  call void @getKeysFreeResult(ptr noundef %result)
  br label %return

return:                                           ; preds = %if.end52, %if.then14, %if.then3, %if.then
  ret void
}

declare void @addReplyError(ptr noundef, ptr noundef) #2

declare i32 @doesCommandHaveKeys(ptr noundef) #2

declare i32 @getKeysFromCommandWithSpecs(ptr noundef, ptr noundef, i32 noundef, i32 noundef, ptr noundef) #2

declare void @getKeysFreeResult(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @commandGetKeysAndFlagsCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @getKeysSubcommandImpl(ptr noundef %0, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @getKeysSubcommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @getKeysSubcommandImpl(ptr noundef %0, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %2 = load i64, ptr %arrayidx, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %ht_used1 = getelementptr inbounds %struct.dict, ptr %3, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [2 x i64], ptr %ht_used1, i64 0, i64 1
  %4 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %2, %4
  call void @addReplyArrayLen(ptr noundef %0, i64 noundef %add)
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %call = call ptr @dictGetIterator(ptr noundef %5)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %6 = load ptr, ptr %di, align 8
  %call3 = call ptr @dictNext(ptr noundef %6)
  store ptr %call3, ptr %de, align 8
  %cmp = icmp ne ptr %call3, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load ptr, ptr %c.addr, align 8
  %8 = load ptr, ptr %de, align 8
  %call4 = call ptr @dictGetVal(ptr noundef %8)
  call void @addReplyCommandInfo(ptr noundef %7, ptr noundef %call4)
  br label %while.cond, !llvm.loop !58

while.end:                                        ; preds = %while.cond
  %9 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %9)
  ret void
}

declare ptr @dictGetIterator(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @commandCountCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %1, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %2 = load i64, ptr %arrayidx, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %ht_used1 = getelementptr inbounds %struct.dict, ptr %3, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [2 x i64], ptr %ht_used1, i64 0, i64 1
  %4 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %2, %4
  call void @addReplyLongLong(ptr noundef %0, i64 noundef %add)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @shouldFilterFromCommandList(ptr noundef %cmd, ptr noundef %filter) #0 {
entry:
  %retval = alloca i32, align 4
  %cmd.addr = alloca ptr, align 8
  %filter.addr = alloca ptr, align 8
  %cat = alloca i64, align 8
  store ptr %cmd, ptr %cmd.addr, align 8
  store ptr %filter, ptr %filter.addr, align 8
  %0 = load ptr, ptr %filter.addr, align 8
  %type = getelementptr inbounds %struct.commandListFilter, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  switch i32 %1, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb8
    i32 2, label %sw.bb27
  ]

sw.bb:                                            ; preds = %entry
  %2 = load ptr, ptr %filter.addr, align 8
  %cache = getelementptr inbounds %struct.commandListFilter, ptr %2, i32 0, i32 2
  %valid = getelementptr inbounds %struct.anon.5, ptr %cache, i32 0, i32 0
  %3 = load i32, ptr %valid, align 8
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %sw.bb
  %4 = load ptr, ptr %filter.addr, align 8
  %arg = getelementptr inbounds %struct.commandListFilter, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %arg, align 8
  %call = call ptr @moduleGetHandleByName(ptr noundef %5)
  %6 = load ptr, ptr %filter.addr, align 8
  %cache1 = getelementptr inbounds %struct.commandListFilter, ptr %6, i32 0, i32 2
  %u = getelementptr inbounds %struct.anon.5, ptr %cache1, i32 0, i32 1
  store ptr %call, ptr %u, align 8
  %7 = load ptr, ptr %filter.addr, align 8
  %cache2 = getelementptr inbounds %struct.commandListFilter, ptr %7, i32 0, i32 2
  %valid3 = getelementptr inbounds %struct.anon.5, ptr %cache2, i32 0, i32 0
  store i32 1, ptr %valid3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %8 = load ptr, ptr %filter.addr, align 8
  %cache4 = getelementptr inbounds %struct.commandListFilter, ptr %8, i32 0, i32 2
  %u5 = getelementptr inbounds %struct.anon.5, ptr %cache4, i32 0, i32 1
  %9 = load ptr, ptr %u5, align 8
  %10 = load ptr, ptr %cmd.addr, align 8
  %call6 = call i32 @moduleIsModuleCommand(ptr noundef %9, ptr noundef %10)
  %tobool7 = icmp ne i32 %call6, 0
  %lnot = xor i1 %tobool7, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %retval, align 4
  br label %return

sw.bb8:                                           ; preds = %entry
  %11 = load ptr, ptr %filter.addr, align 8
  %cache9 = getelementptr inbounds %struct.commandListFilter, ptr %11, i32 0, i32 2
  %valid10 = getelementptr inbounds %struct.anon.5, ptr %cache9, i32 0, i32 0
  %12 = load i32, ptr %valid10, align 8
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %if.end19, label %if.then12

if.then12:                                        ; preds = %sw.bb8
  %13 = load ptr, ptr %filter.addr, align 8
  %arg13 = getelementptr inbounds %struct.commandListFilter, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %arg13, align 8
  %call14 = call i64 @ACLGetCommandCategoryFlagByName(ptr noundef %14)
  %15 = load ptr, ptr %filter.addr, align 8
  %cache15 = getelementptr inbounds %struct.commandListFilter, ptr %15, i32 0, i32 2
  %u16 = getelementptr inbounds %struct.anon.5, ptr %cache15, i32 0, i32 1
  store i64 %call14, ptr %u16, align 8
  %16 = load ptr, ptr %filter.addr, align 8
  %cache17 = getelementptr inbounds %struct.commandListFilter, ptr %16, i32 0, i32 2
  %valid18 = getelementptr inbounds %struct.anon.5, ptr %cache17, i32 0, i32 0
  store i32 1, ptr %valid18, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then12, %sw.bb8
  %17 = load ptr, ptr %filter.addr, align 8
  %cache20 = getelementptr inbounds %struct.commandListFilter, ptr %17, i32 0, i32 2
  %u21 = getelementptr inbounds %struct.anon.5, ptr %cache20, i32 0, i32 1
  %18 = load i64, ptr %u21, align 8
  store i64 %18, ptr %cat, align 8
  %19 = load i64, ptr %cat, align 8
  %cmp = icmp eq i64 %19, 0
  br i1 %cmp, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end19
  store i32 1, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.end19
  %20 = load ptr, ptr %cmd.addr, align 8
  %acl_categories = getelementptr inbounds %struct.redisCommand, ptr %20, i32 0, i32 15
  %21 = load i64, ptr %acl_categories, align 8
  %22 = load i64, ptr %cat, align 8
  %and = and i64 %21, %22
  %tobool24 = icmp ne i64 %and, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  store i32 %lnot.ext26, ptr %retval, align 4
  br label %return

sw.bb27:                                          ; preds = %entry
  %23 = load ptr, ptr %filter.addr, align 8
  %arg28 = getelementptr inbounds %struct.commandListFilter, ptr %23, i32 0, i32 1
  %24 = load ptr, ptr %arg28, align 8
  %25 = load ptr, ptr %filter.addr, align 8
  %arg29 = getelementptr inbounds %struct.commandListFilter, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %arg29, align 8
  %call30 = call i64 @sdslen(ptr noundef %26)
  %conv = trunc i64 %call30 to i32
  %27 = load ptr, ptr %cmd.addr, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %27, i32 0, i32 27
  %28 = load ptr, ptr %fullname, align 8
  %29 = load ptr, ptr %cmd.addr, align 8
  %fullname31 = getelementptr inbounds %struct.redisCommand, ptr %29, i32 0, i32 27
  %30 = load ptr, ptr %fullname31, align 8
  %call32 = call i64 @sdslen(ptr noundef %30)
  %conv33 = trunc i64 %call32 to i32
  %call34 = call i32 @stringmatchlen(ptr noundef %24, i32 noundef %conv, ptr noundef %28, i32 noundef %conv33, i32 noundef 1)
  %tobool35 = icmp ne i32 %call34, 0
  %lnot36 = xor i1 %tobool35, true
  %lnot.ext37 = zext i1 %lnot36 to i32
  store i32 %lnot.ext37, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  %31 = load ptr, ptr %filter.addr, align 8
  %type38 = getelementptr inbounds %struct.commandListFilter, ptr %31, i32 0, i32 0
  %32 = load i32, ptr %type38, align 8
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 5175, ptr noundef @.str.302, i32 noundef %32)
  call void @abort() #16
  unreachable

return:                                           ; preds = %sw.bb27, %if.end23, %if.then22, %if.end
  %33 = load i32, ptr %retval, align 4
  ret i32 %33
}

declare ptr @moduleGetHandleByName(ptr noundef) #2

declare i32 @moduleIsModuleCommand(ptr noundef, ptr noundef) #2

declare i64 @ACLGetCommandCategoryFlagByName(ptr noundef) #2

declare i32 @stringmatchlen(ptr noundef, i32 noundef, ptr noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @commandListWithFilter(ptr noundef %c, ptr noundef %commands, ptr noundef byval(%struct.commandListFilter) align 8 %filter, ptr noundef %numcmds) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %commands.addr = alloca ptr, align 8
  %numcmds.addr = alloca ptr, align 8
  %de = alloca ptr, align 8
  %di = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store ptr %numcmds, ptr %numcmds.addr, align 8
  %0 = load ptr, ptr %commands.addr, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end9, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %cmd, align 8
  %3 = load ptr, ptr %cmd, align 8
  %call3 = call i32 @shouldFilterFromCommandList(ptr noundef %3, ptr noundef %filter)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  %4 = load ptr, ptr %c.addr, align 8
  %5 = load ptr, ptr %cmd, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 27
  %6 = load ptr, ptr %fullname, align 8
  %7 = load ptr, ptr %cmd, align 8
  %fullname4 = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 27
  %8 = load ptr, ptr %fullname4, align 8
  %call5 = call i64 @sdslen(ptr noundef %8)
  call void @addReplyBulkCBuffer(ptr noundef %4, ptr noundef %6, i64 noundef %call5)
  %9 = load ptr, ptr %numcmds.addr, align 8
  %10 = load i32, ptr %9, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, ptr %9, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %11 = load ptr, ptr %cmd, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %11, i32 0, i32 30
  %12 = load ptr, ptr %subcommands_dict, align 8
  %tobool6 = icmp ne ptr %12, null
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %13 = load ptr, ptr %c.addr, align 8
  %14 = load ptr, ptr %cmd, align 8
  %subcommands_dict8 = getelementptr inbounds %struct.redisCommand, ptr %14, i32 0, i32 30
  %15 = load ptr, ptr %subcommands_dict8, align 8
  %16 = load ptr, ptr %numcmds.addr, align 8
  call void @commandListWithFilter(ptr noundef %13, ptr noundef %15, ptr noundef byval(%struct.commandListFilter) align 8 %filter, ptr noundef %16)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.end
  br label %while.cond, !llvm.loop !59

while.end:                                        ; preds = %while.cond
  %17 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %17)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandListWithoutFilter(ptr noundef %c, ptr noundef %commands, ptr noundef %numcmds) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %commands.addr = alloca ptr, align 8
  %numcmds.addr = alloca ptr, align 8
  %de = alloca ptr, align 8
  %di = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store ptr %numcmds, ptr %numcmds.addr, align 8
  %0 = load ptr, ptr %commands.addr, align 8
  %call = call ptr @dictGetIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %cmd, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %4 = load ptr, ptr %cmd, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %4, i32 0, i32 27
  %5 = load ptr, ptr %fullname, align 8
  %6 = load ptr, ptr %cmd, align 8
  %fullname3 = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 27
  %7 = load ptr, ptr %fullname3, align 8
  %call4 = call i64 @sdslen(ptr noundef %7)
  call void @addReplyBulkCBuffer(ptr noundef %3, ptr noundef %5, i64 noundef %call4)
  %8 = load ptr, ptr %numcmds.addr, align 8
  %9 = load i32, ptr %8, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %8, align 4
  %10 = load ptr, ptr %cmd, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 30
  %11 = load ptr, ptr %subcommands_dict, align 8
  %tobool = icmp ne ptr %11, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %12 = load ptr, ptr %c.addr, align 8
  %13 = load ptr, ptr %cmd, align 8
  %subcommands_dict5 = getelementptr inbounds %struct.redisCommand, ptr %13, i32 0, i32 30
  %14 = load ptr, ptr %subcommands_dict5, align 8
  %15 = load ptr, ptr %numcmds.addr, align 8
  call void @commandListWithoutFilter(ptr noundef %12, ptr noundef %14, ptr noundef %15)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond, !llvm.loop !60

while.end:                                        ; preds = %while.cond
  %16 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %16)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandListCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %got_filter = alloca i32, align 4
  %filter = alloca %struct.commandListFilter, align 8
  %moreargs = alloca i32, align 4
  %opt = alloca ptr, align 8
  %filtertype = alloca ptr, align 8
  %numcmds = alloca i32, align 4
  %replylen = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 2, ptr %i, align 4
  store i32 0, ptr %got_filter, align 4
  call void @llvm.memset.p0.i64(ptr align 8 %filter, i8 0, i64 32, i1 false)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %1, i32 0, i32 11
  %2 = load i32, ptr %argc, align 8
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %c.addr, align 8
  %argc1 = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 11
  %4 = load i32, ptr %argc1, align 8
  %sub = sub nsw i32 %4, 1
  %5 = load i32, ptr %i, align 4
  %sub2 = sub nsw i32 %sub, %5
  store i32 %sub2, ptr %moreargs, align 4
  %6 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 12
  %7 = load ptr, ptr %argv, align 8
  %8 = load i32, ptr %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %7, i64 %idxprom
  %9 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %ptr, align 8
  store ptr %10, ptr %opt, align 8
  %11 = load ptr, ptr %opt, align 8
  %call = call i32 @strcasecmp(ptr noundef %11, ptr noundef @.str.303) #14
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else29, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %12 = load i32, ptr %moreargs, align 4
  %cmp3 = icmp eq i32 %12, 2
  br i1 %cmp3, label %if.then, label %if.else29

if.then:                                          ; preds = %land.lhs.true
  %13 = load ptr, ptr %c.addr, align 8
  %argv4 = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 12
  %14 = load ptr, ptr %argv4, align 8
  %15 = load i32, ptr %i, align 4
  %add = add nsw i32 %15, 1
  %idxprom5 = sext i32 %add to i64
  %arrayidx6 = getelementptr inbounds ptr, ptr %14, i64 %idxprom5
  %16 = load ptr, ptr %arrayidx6, align 8
  %ptr7 = getelementptr inbounds %struct.redisObject, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %ptr7, align 8
  store ptr %17, ptr %filtertype, align 8
  %18 = load ptr, ptr %filtertype, align 8
  %call8 = call i32 @strcasecmp(ptr noundef %18, ptr noundef @.str.223) #14
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.else, label %if.then10

if.then10:                                        ; preds = %if.then
  %type = getelementptr inbounds %struct.commandListFilter, ptr %filter, i32 0, i32 0
  store i32 0, ptr %type, align 8
  br label %if.end22

if.else:                                          ; preds = %if.then
  %19 = load ptr, ptr %filtertype, align 8
  %call11 = call i32 @strcasecmp(ptr noundef %19, ptr noundef @.str.304) #14
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.else15, label %if.then13

if.then13:                                        ; preds = %if.else
  %type14 = getelementptr inbounds %struct.commandListFilter, ptr %filter, i32 0, i32 0
  store i32 1, ptr %type14, align 8
  br label %if.end21

if.else15:                                        ; preds = %if.else
  %20 = load ptr, ptr %filtertype, align 8
  %call16 = call i32 @strcasecmp(ptr noundef %20, ptr noundef @.str.257) #14
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.else20, label %if.then18

if.then18:                                        ; preds = %if.else15
  %type19 = getelementptr inbounds %struct.commandListFilter, ptr %filter, i32 0, i32 0
  store i32 2, ptr %type19, align 8
  br label %if.end

if.else20:                                        ; preds = %if.else15
  %21 = load ptr, ptr %c.addr, align 8
  %22 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 15), align 8
  call void @addReplyErrorObject(ptr noundef %21, ptr noundef %22)
  br label %return

if.end:                                           ; preds = %if.then18
  br label %if.end21

if.end21:                                         ; preds = %if.end, %if.then13
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then10
  store i32 1, ptr %got_filter, align 4
  %23 = load ptr, ptr %c.addr, align 8
  %argv23 = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 12
  %24 = load ptr, ptr %argv23, align 8
  %25 = load i32, ptr %i, align 4
  %add24 = add nsw i32 %25, 2
  %idxprom25 = sext i32 %add24 to i64
  %arrayidx26 = getelementptr inbounds ptr, ptr %24, i64 %idxprom25
  %26 = load ptr, ptr %arrayidx26, align 8
  %ptr27 = getelementptr inbounds %struct.redisObject, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %ptr27, align 8
  %arg = getelementptr inbounds %struct.commandListFilter, ptr %filter, i32 0, i32 1
  store ptr %27, ptr %arg, align 8
  %28 = load i32, ptr %i, align 4
  %add28 = add nsw i32 %28, 2
  store i32 %add28, ptr %i, align 4
  br label %if.end30

if.else29:                                        ; preds = %land.lhs.true, %for.body
  %29 = load ptr, ptr %c.addr, align 8
  %30 = load ptr, ptr getelementptr inbounds (%struct.sharedObjectsStruct, ptr @shared, i32 0, i32 15), align 8
  call void @addReplyErrorObject(ptr noundef %29, ptr noundef %30)
  br label %return

if.end30:                                         ; preds = %if.end22
  br label %for.inc

for.inc:                                          ; preds = %if.end30
  %31 = load i32, ptr %i, align 4
  %inc = add nsw i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !61

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %numcmds, align 4
  %32 = load ptr, ptr %c.addr, align 8
  %call31 = call ptr @addReplyDeferredLen(ptr noundef %32)
  store ptr %call31, ptr %replylen, align 8
  %33 = load i32, ptr %got_filter, align 4
  %tobool32 = icmp ne i32 %33, 0
  br i1 %tobool32, label %if.then33, label %if.else34

if.then33:                                        ; preds = %for.end
  %34 = load ptr, ptr %c.addr, align 8
  %35 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  call void @commandListWithFilter(ptr noundef %34, ptr noundef %35, ptr noundef byval(%struct.commandListFilter) align 8 %filter, ptr noundef %numcmds)
  br label %if.end35

if.else34:                                        ; preds = %for.end
  %36 = load ptr, ptr %c.addr, align 8
  %37 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  call void @commandListWithoutFilter(ptr noundef %36, ptr noundef %37, ptr noundef %numcmds)
  br label %if.end35

if.end35:                                         ; preds = %if.else34, %if.then33
  %38 = load ptr, ptr %c.addr, align 8
  %39 = load ptr, ptr %replylen, align 8
  %40 = load i32, ptr %numcmds, align 4
  %conv = sext i32 %40 to i64
  call void @setDeferredArrayLen(ptr noundef %38, ptr noundef %39, i64 noundef %conv)
  br label %return

return:                                           ; preds = %if.end35, %if.else29, %if.else20
  ret void
}

declare ptr @addReplyDeferredLen(ptr noundef) #2

declare void @setDeferredArrayLen(ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @commandInfoCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %argc, align 8
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %3, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %4 = load i64, ptr %arrayidx, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %ht_used1 = getelementptr inbounds %struct.dict, ptr %5, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [2 x i64], ptr %ht_used1, i64 0, i64 1
  %6 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %4, %6
  call void @addReplyArrayLen(ptr noundef %2, i64 noundef %add)
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %call = call ptr @dictGetIterator(ptr noundef %7)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %8 = load ptr, ptr %di, align 8
  %call3 = call ptr @dictNext(ptr noundef %8)
  store ptr %call3, ptr %de, align 8
  %cmp4 = icmp ne ptr %call3, null
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load ptr, ptr %c.addr, align 8
  %10 = load ptr, ptr %de, align 8
  %call5 = call ptr @dictGetVal(ptr noundef %10)
  call void @addReplyCommandInfo(ptr noundef %9, ptr noundef %call5)
  br label %while.cond, !llvm.loop !62

while.end:                                        ; preds = %while.cond
  %11 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %11)
  br label %if.end

if.else:                                          ; preds = %entry
  %12 = load ptr, ptr %c.addr, align 8
  %13 = load ptr, ptr %c.addr, align 8
  %argc6 = getelementptr inbounds %struct.client, ptr %13, i32 0, i32 11
  %14 = load i32, ptr %argc6, align 8
  %sub = sub nsw i32 %14, 2
  %conv = sext i32 %sub to i64
  call void @addReplyArrayLen(ptr noundef %12, i64 noundef %conv)
  store i32 2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %15 = load i32, ptr %i, align 4
  %16 = load ptr, ptr %c.addr, align 8
  %argc7 = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 11
  %17 = load i32, ptr %argc7, align 8
  %cmp8 = icmp slt i32 %15, %17
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %c.addr, align 8
  %19 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %19, i32 0, i32 12
  %20 = load ptr, ptr %argv, align 8
  %21 = load i32, ptr %i, align 4
  %idxprom = sext i32 %21 to i64
  %arrayidx10 = getelementptr inbounds ptr, ptr %20, i64 %idxprom
  %22 = load ptr, ptr %arrayidx10, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %22, i32 0, i32 2
  %23 = load ptr, ptr %ptr, align 8
  %call11 = call ptr @lookupCommandBySds(ptr noundef %23)
  call void @addReplyCommandInfo(ptr noundef %18, ptr noundef %call11)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load i32, ptr %i, align 4
  %inc = add nsw i32 %24, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !63

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %while.end
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandDocsCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %di = alloca ptr, align 8
  %de = alloca ptr, align 8
  %cmd = alloca ptr, align 8
  %numcmds = alloca i32, align 4
  %replylen = alloca ptr, align 8
  %cmd11 = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %argc, align 8
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %ht_used = getelementptr inbounds %struct.dict, ptr %3, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %4 = load i64, ptr %arrayidx, align 8
  %5 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %ht_used1 = getelementptr inbounds %struct.dict, ptr %5, i32 0, i32 2
  %arrayidx2 = getelementptr inbounds [2 x i64], ptr %ht_used1, i64 0, i64 1
  %6 = load i64, ptr %arrayidx2, align 8
  %add = add i64 %4, %6
  call void @addReplyMapLen(ptr noundef %2, i64 noundef %add)
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %call = call ptr @dictGetIterator(ptr noundef %7)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %8 = load ptr, ptr %di, align 8
  %call3 = call ptr @dictNext(ptr noundef %8)
  store ptr %call3, ptr %de, align 8
  %cmp4 = icmp ne ptr %call3, null
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load ptr, ptr %de, align 8
  %call5 = call ptr @dictGetVal(ptr noundef %9)
  store ptr %call5, ptr %cmd, align 8
  %10 = load ptr, ptr %c.addr, align 8
  %11 = load ptr, ptr %cmd, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %11, i32 0, i32 27
  %12 = load ptr, ptr %fullname, align 8
  %13 = load ptr, ptr %cmd, align 8
  %fullname6 = getelementptr inbounds %struct.redisCommand, ptr %13, i32 0, i32 27
  %14 = load ptr, ptr %fullname6, align 8
  %call7 = call i64 @sdslen(ptr noundef %14)
  call void @addReplyBulkCBuffer(ptr noundef %10, ptr noundef %12, i64 noundef %call7)
  %15 = load ptr, ptr %c.addr, align 8
  %16 = load ptr, ptr %cmd, align 8
  call void @addReplyCommandDocs(ptr noundef %15, ptr noundef %16)
  br label %while.cond, !llvm.loop !64

while.end:                                        ; preds = %while.cond
  %17 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %17)
  br label %if.end19

if.else:                                          ; preds = %entry
  store i32 0, ptr %numcmds, align 4
  %18 = load ptr, ptr %c.addr, align 8
  %call8 = call ptr @addReplyDeferredLen(ptr noundef %18)
  store ptr %call8, ptr %replylen, align 8
  store i32 2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %19 = load i32, ptr %i, align 4
  %20 = load ptr, ptr %c.addr, align 8
  %argc9 = getelementptr inbounds %struct.client, ptr %20, i32 0, i32 11
  %21 = load i32, ptr %argc9, align 8
  %cmp10 = icmp slt i32 %19, %21
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %22, i32 0, i32 12
  %23 = load ptr, ptr %argv, align 8
  %24 = load i32, ptr %i, align 4
  %idxprom = sext i32 %24 to i64
  %arrayidx12 = getelementptr inbounds ptr, ptr %23, i64 %idxprom
  %25 = load ptr, ptr %arrayidx12, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %25, i32 0, i32 2
  %26 = load ptr, ptr %ptr, align 8
  %call13 = call ptr @lookupCommandBySds(ptr noundef %26)
  store ptr %call13, ptr %cmd11, align 8
  %27 = load ptr, ptr %cmd11, align 8
  %tobool = icmp ne ptr %27, null
  br i1 %tobool, label %if.end, label %if.then14

if.then14:                                        ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %28 = load ptr, ptr %c.addr, align 8
  %29 = load ptr, ptr %cmd11, align 8
  %fullname15 = getelementptr inbounds %struct.redisCommand, ptr %29, i32 0, i32 27
  %30 = load ptr, ptr %fullname15, align 8
  %31 = load ptr, ptr %cmd11, align 8
  %fullname16 = getelementptr inbounds %struct.redisCommand, ptr %31, i32 0, i32 27
  %32 = load ptr, ptr %fullname16, align 8
  %call17 = call i64 @sdslen(ptr noundef %32)
  call void @addReplyBulkCBuffer(ptr noundef %28, ptr noundef %30, i64 noundef %call17)
  %33 = load ptr, ptr %c.addr, align 8
  %34 = load ptr, ptr %cmd11, align 8
  call void @addReplyCommandDocs(ptr noundef %33, ptr noundef %34)
  %35 = load i32, ptr %numcmds, align 4
  %inc = add nsw i32 %35, 1
  store i32 %inc, ptr %numcmds, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end, %if.then14
  %36 = load i32, ptr %i, align 4
  %inc18 = add nsw i32 %36, 1
  store i32 %inc18, ptr %i, align 4
  br label %for.cond, !llvm.loop !65

for.end:                                          ; preds = %for.cond
  %37 = load ptr, ptr %c.addr, align 8
  %38 = load ptr, ptr %replylen, align 8
  %39 = load i32, ptr %numcmds, align 4
  %conv = sext i32 %39 to i64
  call void @setDeferredMapLen(ptr noundef %37, ptr noundef %38, i64 noundef %conv)
  br label %if.end19

if.end19:                                         ; preds = %for.end, %while.end
  ret void
}

declare void @setDeferredMapLen(ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @commandGetKeysCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  call void @getKeysSubcommand(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @commandHelpCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %help = alloca [19 x ptr], align 16
  store ptr %c, ptr %c.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %help, ptr align 16 @__const.commandHelpCommand.help, i64 152, i1 false)
  %0 = load ptr, ptr %c.addr, align 8
  %arraydecay = getelementptr inbounds [19 x ptr], ptr %help, i64 0, i64 0
  call void @addReplyHelp(ptr noundef %0, ptr noundef %arraydecay)
  ret void
}

declare void @addReplyHelp(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @bytesToHuman(ptr noundef %s, i64 noundef %size, i64 noundef %n) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %n.addr = alloca i64, align 8
  %d = alloca double, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp ult i64 %0, 1024
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %size.addr, align 8
  %3 = load i64, ptr %n.addr, align 8
  %call = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %1, i64 noundef %2, ptr noundef @.str.321, i64 noundef %3) #13
  br label %if.end38

if.else:                                          ; preds = %entry
  %4 = load i64, ptr %n.addr, align 8
  %cmp1 = icmp ult i64 %4, 1048576
  br i1 %cmp1, label %if.then2, label %if.else4

if.then2:                                         ; preds = %if.else
  %5 = load i64, ptr %n.addr, align 8
  %conv = uitofp i64 %5 to double
  %div = fdiv double %conv, 1.024000e+03
  store double %div, ptr %d, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i64, ptr %size.addr, align 8
  %8 = load double, ptr %d, align 8
  %call3 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %6, i64 noundef %7, ptr noundef @.str.322, double noundef %8) #13
  br label %if.end37

if.else4:                                         ; preds = %if.else
  %9 = load i64, ptr %n.addr, align 8
  %cmp5 = icmp ult i64 %9, 1073741824
  br i1 %cmp5, label %if.then7, label %if.else11

if.then7:                                         ; preds = %if.else4
  %10 = load i64, ptr %n.addr, align 8
  %conv8 = uitofp i64 %10 to double
  %div9 = fdiv double %conv8, 0x4130000000000000
  store double %div9, ptr %d, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i64, ptr %size.addr, align 8
  %13 = load double, ptr %d, align 8
  %call10 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %11, i64 noundef %12, ptr noundef @.str.323, double noundef %13) #13
  br label %if.end36

if.else11:                                        ; preds = %if.else4
  %14 = load i64, ptr %n.addr, align 8
  %cmp12 = icmp ult i64 %14, 1099511627776
  br i1 %cmp12, label %if.then14, label %if.else18

if.then14:                                        ; preds = %if.else11
  %15 = load i64, ptr %n.addr, align 8
  %conv15 = uitofp i64 %15 to double
  %div16 = fdiv double %conv15, 0x41D0000000000000
  store double %div16, ptr %d, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i64, ptr %size.addr, align 8
  %18 = load double, ptr %d, align 8
  %call17 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %16, i64 noundef %17, ptr noundef @.str.324, double noundef %18) #13
  br label %if.end35

if.else18:                                        ; preds = %if.else11
  %19 = load i64, ptr %n.addr, align 8
  %cmp19 = icmp ult i64 %19, 1125899906842624
  br i1 %cmp19, label %if.then21, label %if.else25

if.then21:                                        ; preds = %if.else18
  %20 = load i64, ptr %n.addr, align 8
  %conv22 = uitofp i64 %20 to double
  %div23 = fdiv double %conv22, 0x4270000000000000
  store double %div23, ptr %d, align 8
  %21 = load ptr, ptr %s.addr, align 8
  %22 = load i64, ptr %size.addr, align 8
  %23 = load double, ptr %d, align 8
  %call24 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %21, i64 noundef %22, ptr noundef @.str.325, double noundef %23) #13
  br label %if.end34

if.else25:                                        ; preds = %if.else18
  %24 = load i64, ptr %n.addr, align 8
  %cmp26 = icmp ult i64 %24, 1152921504606846976
  br i1 %cmp26, label %if.then28, label %if.else32

if.then28:                                        ; preds = %if.else25
  %25 = load i64, ptr %n.addr, align 8
  %conv29 = uitofp i64 %25 to double
  %div30 = fdiv double %conv29, 0x4310000000000000
  store double %div30, ptr %d, align 8
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i64, ptr %size.addr, align 8
  %28 = load double, ptr %d, align 8
  %call31 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %26, i64 noundef %27, ptr noundef @.str.326, double noundef %28) #13
  br label %if.end

if.else32:                                        ; preds = %if.else25
  %29 = load ptr, ptr %s.addr, align 8
  %30 = load i64, ptr %size.addr, align 8
  %31 = load i64, ptr %n.addr, align 8
  %call33 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %29, i64 noundef %30, ptr noundef @.str.321, i64 noundef %31) #13
  br label %if.end

if.end:                                           ; preds = %if.else32, %if.then28
  br label %if.end34

if.end34:                                         ; preds = %if.end, %if.then21
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then14
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then7
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then2
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local ptr @fillPercentileDistributionLatencies(ptr noundef %info, ptr noundef %histogram_name, ptr noundef %histogram) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %histogram_name.addr = alloca ptr, align 8
  %histogram.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  %fbuf = alloca [128 x i8], align 16
  %len = alloca i64, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %histogram_name, ptr %histogram_name.addr, align 8
  store ptr %histogram, ptr %histogram.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %1 = load ptr, ptr %histogram_name.addr, align 8
  %call = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %0, ptr noundef @.str.327, ptr noundef %1)
  store ptr %call, ptr %info.addr, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 183), align 8
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [128 x i8], ptr %fbuf, i64 0, i64 0
  %4 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 182), align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, ptr %4, i64 %idxprom
  %6 = load double, ptr %arrayidx, align 8
  %call1 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay, i64 noundef 128, ptr noundef @.str.328, double noundef %6) #13
  %conv = sext i32 %call1 to i64
  store i64 %conv, ptr %len, align 8
  %arraydecay2 = getelementptr inbounds [128 x i8], ptr %fbuf, i64 0, i64 0
  %7 = load i64, ptr %len, align 8
  %call3 = call i32 @trimDoubleString(ptr noundef %arraydecay2, i64 noundef %7)
  %8 = load ptr, ptr %info.addr, align 8
  %arraydecay4 = getelementptr inbounds [128 x i8], ptr %fbuf, i64 0, i64 0
  %9 = load ptr, ptr %histogram.addr, align 8
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 182), align 8
  %11 = load i32, ptr %j, align 4
  %idxprom5 = sext i32 %11 to i64
  %arrayidx6 = getelementptr inbounds double, ptr %10, i64 %idxprom5
  %12 = load double, ptr %arrayidx6, align 8
  %call7 = call i64 @hdr_value_at_percentile(ptr noundef %9, double noundef %12)
  %conv8 = sitofp i64 %call7 to double
  %div = fdiv double %conv8, 1.000000e+03
  %call9 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %8, ptr noundef @.str.329, ptr noundef %arraydecay4, double noundef %div)
  store ptr %call9, ptr %info.addr, align 8
  %13 = load i32, ptr %j, align 4
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 183), align 8
  %sub = sub nsw i32 %14, 1
  %cmp10 = icmp ne i32 %13, %sub
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %15 = load ptr, ptr %info.addr, align 8
  %call12 = call ptr @sdscatlen(ptr noundef %15, ptr noundef @.str.330, i64 noundef 1)
  store ptr %call12, ptr %info.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load i32, ptr %j, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %for.cond
  %17 = load ptr, ptr %info.addr, align 8
  %call13 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %17, ptr noundef @.str.170)
  store ptr %call13, ptr %info.addr, align 8
  %18 = load ptr, ptr %info.addr, align 8
  ret ptr %18
}

declare i32 @trimDoubleString(ptr noundef, i64 noundef) #2

declare i64 @hdr_value_at_percentile(ptr noundef, double noundef) #2

declare ptr @sdscatlen(ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @getSafeInfoString(ptr noundef %s, i64 noundef %len, ptr noundef %tmp) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %tmp.addr = alloca ptr, align 8
  %new = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %tmp, ptr %tmp.addr, align 8
  %0 = load ptr, ptr %tmp.addr, align 8
  store ptr null, ptr %0, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  %call = call ptr @mempbrk(ptr noundef %1, i64 noundef %2, ptr noundef @unsafe_info_chars, i64 noundef 4)
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i64, ptr %len.addr, align 8
  %add = add i64 %4, 1
  %call1 = call noalias ptr @zmalloc(i64 noundef %add) #18
  %5 = load ptr, ptr %tmp.addr, align 8
  store ptr %call1, ptr %5, align 8
  store ptr %call1, ptr %new, align 8
  %6 = load ptr, ptr %new, align 8
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i64, ptr %len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %6, ptr align 1 %7, i64 %8, i1 false)
  %9 = load ptr, ptr %new, align 8
  %10 = load i64, ptr %len.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %9, i64 %10
  store i8 0, ptr %arrayidx, align 1
  %11 = load ptr, ptr %new, align 8
  %12 = load i64, ptr %len.addr, align 8
  %call2 = call ptr @memmapchars(ptr noundef %11, i64 noundef %12, ptr noundef @unsafe_info_chars, ptr noundef @unsafe_info_chars_substs, i64 noundef 4)
  store ptr %call2, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

declare ptr @mempbrk(ptr noundef, i64 noundef, ptr noundef, i64 noundef) #2

declare ptr @memmapchars(ptr noundef, i64 noundef, ptr noundef, ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @genRedisInfoStringCommandStats(ptr noundef %info, ptr noundef %commands) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %commands.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %de = alloca ptr, align 8
  %di = alloca ptr, align 8
  %tmpsafe = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  %0 = load ptr, ptr %commands.addr, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end27, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %c, align 8
  %3 = load ptr, ptr %c, align 8
  %calls = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 23
  %4 = load i64, ptr %calls, align 8
  %tobool = icmp ne i64 %4, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %5 = load ptr, ptr %c, align 8
  %failed_calls = getelementptr inbounds %struct.redisCommand, ptr %5, i32 0, i32 25
  %6 = load i64, ptr %failed_calls, align 8
  %tobool3 = icmp ne i64 %6, 0
  br i1 %tobool3, label %if.then, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %7 = load ptr, ptr %c, align 8
  %rejected_calls = getelementptr inbounds %struct.redisCommand, ptr %7, i32 0, i32 24
  %8 = load i64, ptr %rejected_calls, align 8
  %tobool5 = icmp ne i64 %8, 0
  br i1 %tobool5, label %if.then, label %if.end22

if.then:                                          ; preds = %lor.lhs.false4, %lor.lhs.false, %while.body
  %9 = load ptr, ptr %info.addr, align 8
  %10 = load ptr, ptr %c, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 27
  %11 = load ptr, ptr %fullname, align 8
  %12 = load ptr, ptr %c, align 8
  %fullname6 = getelementptr inbounds %struct.redisCommand, ptr %12, i32 0, i32 27
  %13 = load ptr, ptr %fullname6, align 8
  %call7 = call i64 @sdslen(ptr noundef %13)
  %call8 = call ptr @getSafeInfoString(ptr noundef %11, i64 noundef %call7, ptr noundef %tmpsafe)
  %14 = load ptr, ptr %c, align 8
  %calls9 = getelementptr inbounds %struct.redisCommand, ptr %14, i32 0, i32 23
  %15 = load i64, ptr %calls9, align 8
  %16 = load ptr, ptr %c, align 8
  %microseconds = getelementptr inbounds %struct.redisCommand, ptr %16, i32 0, i32 22
  %17 = load i64, ptr %microseconds, align 8
  %18 = load ptr, ptr %c, align 8
  %calls10 = getelementptr inbounds %struct.redisCommand, ptr %18, i32 0, i32 23
  %19 = load i64, ptr %calls10, align 8
  %cmp11 = icmp eq i64 %19, 0
  br i1 %cmp11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %20 = load ptr, ptr %c, align 8
  %microseconds12 = getelementptr inbounds %struct.redisCommand, ptr %20, i32 0, i32 22
  %21 = load i64, ptr %microseconds12, align 8
  %conv = sitofp i64 %21 to float
  %22 = load ptr, ptr %c, align 8
  %calls13 = getelementptr inbounds %struct.redisCommand, ptr %22, i32 0, i32 23
  %23 = load i64, ptr %calls13, align 8
  %conv14 = sitofp i64 %23 to float
  %div = fdiv float %conv, %conv14
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ 0.000000e+00, %cond.true ], [ %div, %cond.false ]
  %conv15 = fpext float %cond to double
  %24 = load ptr, ptr %c, align 8
  %rejected_calls16 = getelementptr inbounds %struct.redisCommand, ptr %24, i32 0, i32 24
  %25 = load i64, ptr %rejected_calls16, align 8
  %26 = load ptr, ptr %c, align 8
  %failed_calls17 = getelementptr inbounds %struct.redisCommand, ptr %26, i32 0, i32 25
  %27 = load i64, ptr %failed_calls17, align 8
  %call18 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %9, ptr noundef @.str.334, ptr noundef %call8, i64 noundef %15, i64 noundef %17, double noundef %conv15, i64 noundef %25, i64 noundef %27)
  store ptr %call18, ptr %info.addr, align 8
  %28 = load ptr, ptr %tmpsafe, align 8
  %cmp19 = icmp ne ptr %28, null
  br i1 %cmp19, label %if.then21, label %if.end

if.then21:                                        ; preds = %cond.end
  %29 = load ptr, ptr %tmpsafe, align 8
  call void @zfree(ptr noundef %29)
  br label %if.end

if.end:                                           ; preds = %if.then21, %cond.end
  br label %if.end22

if.end22:                                         ; preds = %if.end, %lor.lhs.false4
  %30 = load ptr, ptr %c, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %30, i32 0, i32 30
  %31 = load ptr, ptr %subcommands_dict, align 8
  %tobool23 = icmp ne ptr %31, null
  br i1 %tobool23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %if.end22
  %32 = load ptr, ptr %info.addr, align 8
  %33 = load ptr, ptr %c, align 8
  %subcommands_dict25 = getelementptr inbounds %struct.redisCommand, ptr %33, i32 0, i32 30
  %34 = load ptr, ptr %subcommands_dict25, align 8
  %call26 = call ptr @genRedisInfoStringCommandStats(ptr noundef %32, ptr noundef %34)
  store ptr %call26, ptr %info.addr, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %if.end22
  br label %while.cond, !llvm.loop !67

while.end:                                        ; preds = %while.cond
  %35 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %35)
  %36 = load ptr, ptr %info.addr, align 8
  ret ptr %36
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genRedisInfoStringACLStats(ptr noundef %info) #0 {
entry:
  %info.addr = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %1 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 399), align 8
  %2 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 399, i32 1), align 8
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 399, i32 2), align 8
  %4 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 399, i32 3), align 8
  %call = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %0, ptr noundef @.str.335, i64 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4)
  store ptr %call, ptr %info.addr, align 8
  %5 = load ptr, ptr %info.addr, align 8
  ret ptr %5
}

; Function Attrs: nounwind uwtable
define dso_local ptr @genRedisInfoStringLatencyStats(ptr noundef %info, ptr noundef %commands) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %commands.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %de = alloca ptr, align 8
  %di = alloca ptr, align 8
  %tmpsafe = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  %0 = load ptr, ptr %commands.addr, align 8
  %call = call ptr @dictGetSafeIterator(ptr noundef %0)
  store ptr %call, ptr %di, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end15, %entry
  %1 = load ptr, ptr %di, align 8
  %call1 = call ptr @dictNext(ptr noundef %1)
  store ptr %call1, ptr %de, align 8
  %cmp = icmp ne ptr %call1, null
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %de, align 8
  %call2 = call ptr @dictGetVal(ptr noundef %2)
  store ptr %call2, ptr %c, align 8
  %3 = load ptr, ptr %c, align 8
  %latency_histogram = getelementptr inbounds %struct.redisCommand, ptr %3, i32 0, i32 28
  %4 = load ptr, ptr %latency_histogram, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %while.body
  %5 = load ptr, ptr %info.addr, align 8
  %6 = load ptr, ptr %c, align 8
  %fullname = getelementptr inbounds %struct.redisCommand, ptr %6, i32 0, i32 27
  %7 = load ptr, ptr %fullname, align 8
  %8 = load ptr, ptr %c, align 8
  %fullname3 = getelementptr inbounds %struct.redisCommand, ptr %8, i32 0, i32 27
  %9 = load ptr, ptr %fullname3, align 8
  %call4 = call i64 @sdslen(ptr noundef %9)
  %call5 = call ptr @getSafeInfoString(ptr noundef %7, i64 noundef %call4, ptr noundef %tmpsafe)
  %10 = load ptr, ptr %c, align 8
  %latency_histogram6 = getelementptr inbounds %struct.redisCommand, ptr %10, i32 0, i32 28
  %11 = load ptr, ptr %latency_histogram6, align 8
  %call7 = call ptr @fillPercentileDistributionLatencies(ptr noundef %5, ptr noundef %call5, ptr noundef %11)
  store ptr %call7, ptr %info.addr, align 8
  %12 = load ptr, ptr %tmpsafe, align 8
  %cmp8 = icmp ne ptr %12, null
  br i1 %cmp8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  %13 = load ptr, ptr %tmpsafe, align 8
  call void @zfree(ptr noundef %13)
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.then
  br label %if.end10

if.end10:                                         ; preds = %if.end, %while.body
  %14 = load ptr, ptr %c, align 8
  %subcommands_dict = getelementptr inbounds %struct.redisCommand, ptr %14, i32 0, i32 30
  %15 = load ptr, ptr %subcommands_dict, align 8
  %tobool11 = icmp ne ptr %15, null
  br i1 %tobool11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end10
  %16 = load ptr, ptr %info.addr, align 8
  %17 = load ptr, ptr %c, align 8
  %subcommands_dict13 = getelementptr inbounds %struct.redisCommand, ptr %17, i32 0, i32 30
  %18 = load ptr, ptr %subcommands_dict13, align 8
  %call14 = call ptr @genRedisInfoStringLatencyStats(ptr noundef %16, ptr noundef %18)
  store ptr %call14, ptr %info.addr, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end10
  br label %while.cond, !llvm.loop !68

while.end:                                        ; preds = %while.cond
  %19 = load ptr, ptr %di, align 8
  call void @dictReleaseIterator(ptr noundef %19)
  %20 = load ptr, ptr %info.addr, align 8
  ret ptr %20
}

; Function Attrs: nounwind uwtable
define dso_local void @addInfoSectionsToDict(ptr noundef %section_dict, ptr noundef %sections) #0 {
entry:
  %section_dict.addr = alloca ptr, align 8
  %sections.addr = alloca ptr, align 8
  %section = alloca ptr, align 8
  store ptr %section_dict, ptr %section_dict.addr, align 8
  store ptr %sections, ptr %sections.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load ptr, ptr %sections.addr, align 8
  %1 = load ptr, ptr %0, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %sections.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %call = call ptr @sdsnew(ptr noundef %3)
  store ptr %call, ptr %section, align 8
  %4 = load ptr, ptr %section_dict.addr, align 8
  %5 = load ptr, ptr %section, align 8
  %call1 = call i32 @dictAdd(ptr noundef %4, ptr noundef %5, ptr noundef null)
  %cmp = icmp eq i32 %call1, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %6 = load ptr, ptr %section, align 8
  call void @sdsfree(ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %7 = load ptr, ptr %sections.addr, align 8
  %incdec.ptr = getelementptr inbounds ptr, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %sections.addr, align 8
  br label %while.cond, !llvm.loop !69

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @releaseInfoSectionDict(ptr noundef %sec) #0 {
entry:
  %sec.addr = alloca ptr, align 8
  store ptr %sec, ptr %sec.addr, align 8
  %0 = load ptr, ptr %sec.addr, align 8
  %1 = load ptr, ptr @cached_default_info_sections, align 8
  %cmp = icmp ne ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %sec.addr, align 8
  call void @dictRelease(ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @dictRelease(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @genInfoSectionDict(ptr noundef %argv, i32 noundef %argc, ptr noundef %defaults, ptr noundef %out_all, ptr noundef %out_everything) #0 {
entry:
  %retval = alloca ptr, align 8
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %defaults.addr = alloca ptr, align 8
  %out_all.addr = alloca ptr, align 8
  %out_everything.addr = alloca ptr, align 8
  %default_sections = alloca [12 x ptr], align 16
  %section_dict = alloca ptr, align 8
  %i = alloca i32, align 4
  %section = alloca ptr, align 8
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %defaults, ptr %defaults.addr, align 8
  store ptr %out_all, ptr %out_all.addr, align 8
  store ptr %out_everything, ptr %out_everything.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %default_sections, ptr align 16 @__const.genInfoSectionDict.default_sections, i64 96, i1 false)
  %0 = load ptr, ptr %defaults.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [12 x ptr], ptr %default_sections, i64 0, i64 0
  store ptr %arraydecay, ptr %defaults.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32, ptr %argc.addr, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then1, label %if.end6

if.then1:                                         ; preds = %if.end
  %2 = load ptr, ptr @cached_default_info_sections, align 8
  %tobool2 = icmp ne ptr %2, null
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.then1
  %3 = load ptr, ptr @cached_default_info_sections, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %if.then1
  %call = call ptr @dictCreate(ptr noundef @stringSetDictType)
  store ptr %call, ptr @cached_default_info_sections, align 8
  %4 = load ptr, ptr @cached_default_info_sections, align 8
  %call5 = call i32 @dictExpand(ptr noundef %4, i64 noundef 16)
  %5 = load ptr, ptr @cached_default_info_sections, align 8
  %6 = load ptr, ptr %defaults.addr, align 8
  call void @addInfoSectionsToDict(ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr @cached_default_info_sections, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %if.end
  %call7 = call ptr @dictCreate(ptr noundef @stringSetDictType)
  store ptr %call7, ptr %section_dict, align 8
  %8 = load ptr, ptr %section_dict, align 8
  %9 = load i32, ptr %argc.addr, align 4
  %cmp8 = icmp slt i32 %9, 16
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end6
  %10 = load i32, ptr %argc.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end6
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ 16, %cond.false ]
  %conv = sext i32 %cond to i64
  %call9 = call i32 @dictExpand(ptr noundef %8, i64 noundef %conv)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %11 = load i32, ptr %i, align 4
  %12 = load i32, ptr %argc.addr, align 4
  %cmp10 = icmp slt i32 %11, %12
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load ptr, ptr %argv.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom = sext i32 %14 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %13, i64 %idxprom
  %15 = load ptr, ptr %arrayidx, align 8
  %ptr = getelementptr inbounds %struct.redisObject, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %ptr, align 8
  %call12 = call i32 @strcasecmp(ptr noundef %16, ptr noundef @.str.108) #14
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.else, label %if.then14

if.then14:                                        ; preds = %for.body
  %17 = load ptr, ptr %section_dict, align 8
  %18 = load ptr, ptr %defaults.addr, align 8
  call void @addInfoSectionsToDict(ptr noundef %17, ptr noundef %18)
  br label %if.end49

if.else:                                          ; preds = %for.body
  %19 = load ptr, ptr %argv.addr, align 8
  %20 = load i32, ptr %i, align 4
  %idxprom15 = sext i32 %20 to i64
  %arrayidx16 = getelementptr inbounds ptr, ptr %19, i64 %idxprom15
  %21 = load ptr, ptr %arrayidx16, align 8
  %ptr17 = getelementptr inbounds %struct.redisObject, ptr %21, i32 0, i32 2
  %22 = load ptr, ptr %ptr17, align 8
  %call18 = call i32 @strcasecmp(ptr noundef %22, ptr noundef @.str.347) #14
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.else24, label %if.then20

if.then20:                                        ; preds = %if.else
  %23 = load ptr, ptr %out_all.addr, align 8
  %tobool21 = icmp ne ptr %23, null
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then20
  %24 = load ptr, ptr %out_all.addr, align 8
  store i32 1, ptr %24, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then20
  br label %if.end48

if.else24:                                        ; preds = %if.else
  %25 = load ptr, ptr %argv.addr, align 8
  %26 = load i32, ptr %i, align 4
  %idxprom25 = sext i32 %26 to i64
  %arrayidx26 = getelementptr inbounds ptr, ptr %25, i64 %idxprom25
  %27 = load ptr, ptr %arrayidx26, align 8
  %ptr27 = getelementptr inbounds %struct.redisObject, ptr %27, i32 0, i32 2
  %28 = load ptr, ptr %ptr27, align 8
  %call28 = call i32 @strcasecmp(ptr noundef %28, ptr noundef @.str.348) #14
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.else37, label %if.then30

if.then30:                                        ; preds = %if.else24
  %29 = load ptr, ptr %out_everything.addr, align 8
  %tobool31 = icmp ne ptr %29, null
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.then30
  %30 = load ptr, ptr %out_everything.addr, align 8
  store i32 1, ptr %30, align 4
  br label %if.end33

if.end33:                                         ; preds = %if.then32, %if.then30
  %31 = load ptr, ptr %out_all.addr, align 8
  %tobool34 = icmp ne ptr %31, null
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end33
  %32 = load ptr, ptr %out_all.addr, align 8
  store i32 1, ptr %32, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end33
  br label %if.end47

if.else37:                                        ; preds = %if.else24
  %33 = load ptr, ptr %argv.addr, align 8
  %34 = load i32, ptr %i, align 4
  %idxprom38 = sext i32 %34 to i64
  %arrayidx39 = getelementptr inbounds ptr, ptr %33, i64 %idxprom38
  %35 = load ptr, ptr %arrayidx39, align 8
  %ptr40 = getelementptr inbounds %struct.redisObject, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %ptr40, align 8
  %call41 = call ptr @sdsnew(ptr noundef %36)
  store ptr %call41, ptr %section, align 8
  %37 = load ptr, ptr %section_dict, align 8
  %38 = load ptr, ptr %section, align 8
  %call42 = call i32 @dictAdd(ptr noundef %37, ptr noundef %38, ptr noundef null)
  %cmp43 = icmp ne i32 %call42, 0
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.else37
  %39 = load ptr, ptr %section, align 8
  call void @sdsfree(ptr noundef %39)
  br label %if.end46

if.end46:                                         ; preds = %if.then45, %if.else37
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end36
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end23
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.then14
  br label %for.inc

for.inc:                                          ; preds = %if.end49
  %40 = load i32, ptr %i, align 4
  %inc = add nsw i32 %40, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !70

for.end:                                          ; preds = %for.cond
  %41 = load ptr, ptr %section_dict, align 8
  store ptr %41, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.end4, %if.then3
  %42 = load ptr, ptr %retval, align 8
  ret ptr %42
}

declare i32 @dictExpand(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local ptr @genRedisInfoString(ptr noundef %section_dict, i32 noundef %all_sections, i32 noundef %everything) #0 {
entry:
  %section_dict.addr = alloca ptr, align 8
  %all_sections.addr = alloca i32, align 4
  %everything.addr = alloca i32, align 4
  %info = alloca ptr, align 8
  %uptime = alloca i64, align 8
  %j = alloca i32, align 4
  %sections = alloca i32, align 4
  %mode = alloca ptr, align 8
  %supervised = alloca ptr, align 8
  %maxin = alloca i64, align 8
  %maxout = alloca i64, align 8
  %blocking_keys = alloca i64, align 8
  %blocking_keys_on_nokey = alloca i64, align 8
  %hmem = alloca [64 x i8], align 16
  %peak_hmem = alloca [64 x i8], align 16
  %total_system_hmem = alloca [64 x i8], align 16
  %used_memory_lua_hmem = alloca [64 x i8], align 16
  %used_memory_vm_total_hmem = alloca [64 x i8], align 16
  %used_memory_scripts_hmem = alloca [64 x i8], align 16
  %used_memory_rss_hmem = alloca [64 x i8], align 16
  %maxmemory_hmem = alloca [64 x i8], align 16
  %zmalloc_used = alloca i64, align 8
  %total_system_mem = alloca i64, align 8
  %evict_policy = alloca ptr, align 8
  %memory_lua = alloca i64, align 8
  %memory_functions = alloca i64, align 8
  %mh = alloca ptr, align 8
  %fork_perc = alloca double, align 8
  %aof_bio_fsync_status = alloca i32, align 4
  %atomic-temp = alloca i32, align 4
  %perc = alloca double, align 8
  %eta = alloca i64, align 8
  %elapsed = alloca i64, align 8
  %remaining_bytes = alloca i64, align 8
  %stat_total_reads_processed = alloca i64, align 8
  %stat_total_writes_processed = alloca i64, align 8
  %stat_net_input_bytes = alloca i64, align 8
  %stat_net_output_bytes = alloca i64, align 8
  %stat_net_repl_input_bytes = alloca i64, align 8
  %stat_net_repl_output_bytes = alloca i64, align 8
  %current_eviction_exceeded_time = alloca i64, align 8
  %current_active_defrag_time = alloca i64, align 8
  %stat_client_qbuf_limit_disconnections = alloca i64, align 8
  %atomic-temp273 = alloca i64, align 8
  %atomic-temp276 = alloca i64, align 8
  %atomic-temp279 = alloca i64, align 8
  %atomic-temp282 = alloca i64, align 8
  %atomic-temp285 = alloca i64, align 8
  %atomic-temp288 = alloca i64, align 8
  %atomic-temp291 = alloca i64, align 8
  %slave_repl_offset = alloca i64, align 8
  %slave_read_repl_offset = alloca i64, align 8
  %perc397 = alloca double, align 8
  %slaveid = alloca i32, align 4
  %ln = alloca ptr, align 8
  %li = alloca %struct.listIter, align 8
  %slave = alloca ptr, align 8
  %ip = alloca [46 x i8], align 16
  %slaveip = alloca ptr, align 8
  %port = alloca i32, align 4
  %lag = alloca i64, align 8
  %state = alloca ptr, align 8
  %self_ru = alloca %struct.rusage, align 8
  %c_ru = alloca %struct.rusage, align 8
  %m_ru = alloca %struct.rusage, align 8
  %ri = alloca %struct.raxIterator, align 8
  %e = alloca ptr, align 8
  %tmpsafe = alloca ptr, align 8
  %keys = alloca i64, align 8
  %vkeys = alloca i64, align 8
  store ptr %section_dict, ptr %section_dict.addr, align 8
  store i32 %all_sections, ptr %all_sections.addr, align 4
  store i32 %everything, ptr %everything.addr, align 4
  %call = call ptr @sdsempty()
  store ptr %call, ptr %info, align 8
  %atomic-load = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %0 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 88), align 8
  %sub = sub nsw i64 %atomic-load, %0
  store i64 %sub, ptr %uptime, align 8
  store i32 0, ptr %sections, align 4
  %1 = load i32, ptr %everything.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %all_sections.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %all_sections.addr, align 4
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load ptr, ptr %section_dict.addr, align 8
  %call2 = call ptr @dictFind(ptr noundef %3, ptr noundef @.str.336)
  %cmp = icmp ne ptr %call2, null
  br i1 %cmp, label %if.then3, label %if.end60

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool4 = icmp ne i32 %4, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  store ptr @.str.345, ptr %mode, align 8
  br label %if.end10

if.else:                                          ; preds = %if.then3
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool6 = icmp ne i32 %5, 0
  br i1 %tobool6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %if.else
  store ptr @.str.349, ptr %mode, align 8
  br label %if.end9

if.else8:                                         ; preds = %if.else
  store ptr @.str.350, ptr %mode, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.else8, %if.then7
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.then5
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 174), align 4
  %tobool11 = icmp ne i32 %6, 0
  br i1 %tobool11, label %if.then12, label %if.else21

if.then12:                                        ; preds = %if.end10
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %cmp13 = icmp eq i32 %7, 3
  br i1 %cmp13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.then12
  store ptr @.str.351, ptr %supervised, align 8
  br label %if.end20

if.else15:                                        ; preds = %if.then12
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %cmp16 = icmp eq i32 %8, 2
  br i1 %cmp16, label %if.then17, label %if.else18

if.then17:                                        ; preds = %if.else15
  store ptr @.str.352, ptr %supervised, align 8
  br label %if.end19

if.else18:                                        ; preds = %if.else15
  store ptr @.str.277, ptr %supervised, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.else18, %if.then17
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then14
  br label %if.end22

if.else21:                                        ; preds = %if.end10
  store ptr @.str.353, ptr %supervised, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else21, %if.end20
  %9 = load i32, ptr %sections, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %sections, align 4
  %tobool23 = icmp ne i32 %9, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end22
  %10 = load ptr, ptr %info, align 8
  %call25 = call ptr @sdscat(ptr noundef %10, ptr noundef @.str.170)
  store ptr %call25, ptr %info, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end22
  %11 = load i32, ptr @genRedisInfoString.call_uname, align 4
  %tobool27 = icmp ne i32 %11, 0
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end26
  %call29 = call i32 @uname(ptr noundef @genRedisInfoString.name) #13
  store i32 0, ptr @genRedisInfoString.call_uname, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end26
  %12 = load ptr, ptr %info, align 8
  %call31 = call ptr @redisGitSHA1()
  %call32 = call ptr @redisGitDirty()
  %call33 = call i64 @strtol(ptr noundef %call32, ptr noundef null, i32 noundef 10) #13
  %cmp34 = icmp sgt i64 %call33, 0
  %conv = zext i1 %cmp34 to i32
  %call35 = call ptr @redisBuildIdString()
  %13 = load ptr, ptr %mode, align 8
  %14 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 24), align 8
  %call36 = call ptr @monotonicInfoString()
  %call37 = call ptr @aeGetApiName()
  %call38 = call i32 @getpid() #13
  %conv39 = sext i32 %call38 to i64
  %15 = load ptr, ptr %supervised, align 8
  %16 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  %tobool40 = icmp ne i32 %16, 0
  br i1 %tobool40, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end30
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end30
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %17, %cond.true ], [ %18, %cond.false ]
  %19 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 353), align 8
  %20 = load i64, ptr %uptime, align 8
  %21 = load i64, ptr %uptime, align 8
  %div = sdiv i64 %21, 86400
  %22 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 8), align 4
  %23 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 6), align 4
  %24 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 16), align 8
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 3), align 8
  %tobool41 = icmp ne ptr %25, null
  br i1 %tobool41, label %cond.true42, label %cond.false43

cond.true42:                                      ; preds = %cond.end
  %26 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 3), align 8
  br label %cond.end44

cond.false43:                                     ; preds = %cond.end
  br label %cond.end44

cond.end44:                                       ; preds = %cond.false43, %cond.true42
  %cond45 = phi ptr [ %26, %cond.true42 ], [ @.str.219, %cond.false43 ]
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  %tobool46 = icmp ne ptr %27, null
  br i1 %tobool46, label %cond.true47, label %cond.false48

cond.true47:                                      ; preds = %cond.end44
  %28 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  br label %cond.end49

cond.false48:                                     ; preds = %cond.end44
  br label %cond.end49

cond.end49:                                       ; preds = %cond.false48, %cond.true47
  %cond50 = phi ptr [ %28, %cond.true47 ], [ @.str.219, %cond.false48 ]
  %29 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 76), align 4
  %call51 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %12, ptr noundef @.str.354, ptr noundef @.str.355, ptr noundef %call31, i32 noundef %conv, ptr noundef %call35, ptr noundef %13, ptr noundef @genRedisInfoString.name, ptr noundef getelementptr inbounds (%struct.utsname, ptr @genRedisInfoString.name, i32 0, i32 2), ptr noundef getelementptr inbounds (%struct.utsname, ptr @genRedisInfoString.name, i32 0, i32 4), i32 noundef %14, ptr noundef %call36, ptr noundef %call37, ptr noundef @.str.356, ptr noundef @.str.357, i64 noundef %conv39, ptr noundef %15, ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 26), i32 noundef %cond, i64 noundef %19, i64 noundef %20, i64 noundef %div, i32 noundef %22, i32 noundef %23, i32 noundef %24, ptr noundef %cond45, ptr noundef %cond50, i32 noundef %29)
  store ptr %call51, ptr %info, align 8
  %call52 = call i32 @isShutdownInitiated()
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.then54, label %if.end58

if.then54:                                        ; preds = %cond.end49
  %30 = load ptr, ptr %info, align 8
  %31 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 18), align 8
  %call55 = call i64 @commandTimeSnapshot()
  %sub56 = sub nsw i64 %31, %call55
  %call57 = call ptr (ptr, ptr, ...) @sdscatfmt(ptr noundef %30, ptr noundef @.str.358, i64 noundef %sub56)
  store ptr %call57, ptr %info, align 8
  br label %if.end58

if.end58:                                         ; preds = %if.then54, %cond.end49
  %32 = load ptr, ptr %info, align 8
  %call59 = call ptr @getListensInfoString(ptr noundef %32)
  store ptr %call59, ptr %info, align 8
  br label %if.end60

if.end60:                                         ; preds = %if.end58, %lor.lhs.false
  %33 = load i32, ptr %all_sections.addr, align 4
  %tobool61 = icmp ne i32 %33, 0
  br i1 %tobool61, label %if.then66, label %lor.lhs.false62

lor.lhs.false62:                                  ; preds = %if.end60
  %34 = load ptr, ptr %section_dict.addr, align 8
  %call63 = call ptr @dictFind(ptr noundef %34, ptr noundef @.str.337)
  %cmp64 = icmp ne ptr %call63, null
  br i1 %cmp64, label %if.then66, label %if.end77

if.then66:                                        ; preds = %lor.lhs.false62, %if.end60
  call void @getExpansiveClientsInfo(ptr noundef %maxin, ptr noundef %maxout)
  call void @totalNumberOfBlockingKeys(ptr noundef %blocking_keys, ptr noundef %blocking_keys_on_nokey)
  %35 = load i32, ptr %sections, align 4
  %inc67 = add nsw i32 %35, 1
  store i32 %inc67, ptr %sections, align 4
  %tobool68 = icmp ne i32 %35, 0
  br i1 %tobool68, label %if.then69, label %if.end71

if.then69:                                        ; preds = %if.then66
  %36 = load ptr, ptr %info, align 8
  %call70 = call ptr @sdscat(ptr noundef %36, ptr noundef @.str.170)
  store ptr %call70, ptr %info, align 8
  br label %if.end71

if.end71:                                         ; preds = %if.then69, %if.then66
  %37 = load ptr, ptr %info, align 8
  %38 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  %len = getelementptr inbounds %struct.list, ptr %38, i32 0, i32 5
  %39 = load i64, ptr %len, align 8
  %40 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %len72 = getelementptr inbounds %struct.list, ptr %40, i32 0, i32 5
  %41 = load i64, ptr %len72, align 8
  %sub73 = sub i64 %39, %41
  %call74 = call i64 @getClusterConnectionsCount()
  %42 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 313), align 4
  %43 = load i64, ptr %maxin, align 8
  %44 = load i64, ptr %maxout, align 8
  %45 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 325), align 4
  %46 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 329), align 8
  %47 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 361), align 8
  %48 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 64), align 8
  %call75 = call i64 @raxSize(ptr noundef %48)
  %49 = load i64, ptr %blocking_keys, align 8
  %50 = load i64, ptr %blocking_keys_on_nokey, align 8
  %call76 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %37, ptr noundef @.str.359, i64 noundef %sub73, i64 noundef %call74, i32 noundef %42, i64 noundef %43, i64 noundef %44, i32 noundef %45, i32 noundef %46, i32 noundef %47, i64 noundef %call75, i64 noundef %49, i64 noundef %50)
  store ptr %call76, ptr %info, align 8
  br label %if.end77

if.end77:                                         ; preds = %if.end71, %lor.lhs.false62
  %51 = load i32, ptr %all_sections.addr, align 4
  %tobool78 = icmp ne i32 %51, 0
  br i1 %tobool78, label %if.then83, label %lor.lhs.false79

lor.lhs.false79:                                  ; preds = %if.end77
  %52 = load ptr, ptr %section_dict.addr, align 8
  %call80 = call ptr @dictFind(ptr noundef %52, ptr noundef @.str.338)
  %cmp81 = icmp ne ptr %call80, null
  br i1 %cmp81, label %if.then83, label %if.end137

if.then83:                                        ; preds = %lor.lhs.false79, %if.end77
  %call84 = call i64 @zmalloc_used_memory()
  store i64 %call84, ptr %zmalloc_used, align 8
  %53 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 401), align 8
  store i64 %53, ptr %total_system_mem, align 8
  %call85 = call ptr @evictPolicyToString()
  store ptr %call85, ptr %evict_policy, align 8
  %call86 = call i64 @evalMemory()
  store i64 %call86, ptr %memory_lua, align 8
  %call87 = call i64 @functionsMemory()
  store i64 %call87, ptr %memory_functions, align 8
  %call88 = call ptr @getMemoryOverheadData()
  store ptr %call88, ptr %mh, align 8
  %54 = load i64, ptr %zmalloc_used, align 8
  %55 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  %cmp89 = icmp ugt i64 %54, %55
  br i1 %cmp89, label %if.then91, label %if.end92

if.then91:                                        ; preds = %if.then83
  %56 = load i64, ptr %zmalloc_used, align 8
  store i64 %56, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  br label %if.end92

if.end92:                                         ; preds = %if.then91, %if.then83
  %arraydecay = getelementptr inbounds [64 x i8], ptr %hmem, i64 0, i64 0
  %57 = load i64, ptr %zmalloc_used, align 8
  call void @bytesToHuman(ptr noundef %arraydecay, i64 noundef 64, i64 noundef %57)
  %arraydecay93 = getelementptr inbounds [64 x i8], ptr %peak_hmem, i64 0, i64 0
  %58 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  call void @bytesToHuman(ptr noundef %arraydecay93, i64 noundef 64, i64 noundef %58)
  %arraydecay94 = getelementptr inbounds [64 x i8], ptr %total_system_hmem, i64 0, i64 0
  %59 = load i64, ptr %total_system_mem, align 8
  call void @bytesToHuman(ptr noundef %arraydecay94, i64 noundef 64, i64 noundef %59)
  %arraydecay95 = getelementptr inbounds [64 x i8], ptr %used_memory_lua_hmem, i64 0, i64 0
  %60 = load i64, ptr %memory_lua, align 8
  call void @bytesToHuman(ptr noundef %arraydecay95, i64 noundef 64, i64 noundef %60)
  %arraydecay96 = getelementptr inbounds [64 x i8], ptr %used_memory_vm_total_hmem, i64 0, i64 0
  %61 = load i64, ptr %memory_functions, align 8
  %62 = load i64, ptr %memory_lua, align 8
  %add = add nsw i64 %61, %62
  call void @bytesToHuman(ptr noundef %arraydecay96, i64 noundef 64, i64 noundef %add)
  %arraydecay97 = getelementptr inbounds [64 x i8], ptr %used_memory_scripts_hmem, i64 0, i64 0
  %63 = load ptr, ptr %mh, align 8
  %lua_caches = getelementptr inbounds %struct.redisMemOverhead, ptr %63, i32 0, i32 8
  %64 = load i64, ptr %lua_caches, align 8
  %65 = load ptr, ptr %mh, align 8
  %functions_caches = getelementptr inbounds %struct.redisMemOverhead, ptr %65, i32 0, i32 9
  %66 = load i64, ptr %functions_caches, align 8
  %add98 = add i64 %64, %66
  call void @bytesToHuman(ptr noundef %arraydecay97, i64 noundef 64, i64 noundef %add98)
  %arraydecay99 = getelementptr inbounds [64 x i8], ptr %used_memory_rss_hmem, i64 0, i64 0
  %67 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 1), align 8
  call void @bytesToHuman(ptr noundef %arraydecay99, i64 noundef 64, i64 noundef %67)
  %arraydecay100 = getelementptr inbounds [64 x i8], ptr %maxmemory_hmem, i64 0, i64 0
  %68 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  call void @bytesToHuman(ptr noundef %arraydecay100, i64 noundef 64, i64 noundef %68)
  %69 = load i32, ptr %sections, align 4
  %inc101 = add nsw i32 %69, 1
  store i32 %inc101, ptr %sections, align 4
  %tobool102 = icmp ne i32 %69, 0
  br i1 %tobool102, label %if.then103, label %if.end105

if.then103:                                       ; preds = %if.end92
  %70 = load ptr, ptr %info, align 8
  %call104 = call ptr @sdscat(ptr noundef %70, ptr noundef @.str.170)
  store ptr %call104, ptr %info, align 8
  br label %if.end105

if.end105:                                        ; preds = %if.then103, %if.end92
  %71 = load ptr, ptr %info, align 8
  %72 = load i64, ptr %zmalloc_used, align 8
  %arraydecay106 = getelementptr inbounds [64 x i8], ptr %hmem, i64 0, i64 0
  %73 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 1), align 8
  %arraydecay107 = getelementptr inbounds [64 x i8], ptr %used_memory_rss_hmem, i64 0, i64 0
  %74 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 108), align 8
  %arraydecay108 = getelementptr inbounds [64 x i8], ptr %peak_hmem, i64 0, i64 0
  %75 = load ptr, ptr %mh, align 8
  %peak_perc = getelementptr inbounds %struct.redisMemOverhead, ptr %75, i32 0, i32 15
  %76 = load float, ptr %peak_perc, align 4
  %conv109 = fpext float %76 to double
  %77 = load ptr, ptr %mh, align 8
  %overhead_total = getelementptr inbounds %struct.redisMemOverhead, ptr %77, i32 0, i32 10
  %78 = load i64, ptr %overhead_total, align 8
  %79 = load ptr, ptr %mh, align 8
  %startup_allocated = getelementptr inbounds %struct.redisMemOverhead, ptr %79, i32 0, i32 2
  %80 = load i64, ptr %startup_allocated, align 8
  %81 = load ptr, ptr %mh, align 8
  %dataset = getelementptr inbounds %struct.redisMemOverhead, ptr %81, i32 0, i32 11
  %82 = load i64, ptr %dataset, align 8
  %83 = load ptr, ptr %mh, align 8
  %dataset_perc = getelementptr inbounds %struct.redisMemOverhead, ptr %83, i32 0, i32 14
  %84 = load float, ptr %dataset_perc, align 8
  %conv110 = fpext float %84 to double
  %85 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 2), align 8
  %86 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 3), align 8
  %87 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 123, i32 4), align 8
  %88 = load i64, ptr %total_system_mem, align 8
  %arraydecay111 = getelementptr inbounds [64 x i8], ptr %total_system_hmem, i64 0, i64 0
  %89 = load i64, ptr %memory_lua, align 8
  %90 = load i64, ptr %memory_lua, align 8
  %arraydecay112 = getelementptr inbounds [64 x i8], ptr %used_memory_lua_hmem, i64 0, i64 0
  %91 = load ptr, ptr %mh, align 8
  %lua_caches113 = getelementptr inbounds %struct.redisMemOverhead, ptr %91, i32 0, i32 8
  %92 = load i64, ptr %lua_caches113, align 8
  %call114 = call ptr @evalScriptsDict()
  %ht_used = getelementptr inbounds %struct.dict, ptr %call114, i32 0, i32 2
  %arrayidx = getelementptr inbounds [2 x i64], ptr %ht_used, i64 0, i64 0
  %93 = load i64, ptr %arrayidx, align 8
  %call115 = call ptr @evalScriptsDict()
  %ht_used116 = getelementptr inbounds %struct.dict, ptr %call115, i32 0, i32 2
  %arrayidx117 = getelementptr inbounds [2 x i64], ptr %ht_used116, i64 0, i64 1
  %94 = load i64, ptr %arrayidx117, align 8
  %add118 = add i64 %93, %94
  %call119 = call i64 @functionsNum()
  %call120 = call i64 @functionsLibNum()
  %95 = load i64, ptr %memory_functions, align 8
  %96 = load i64, ptr %memory_functions, align 8
  %97 = load i64, ptr %memory_lua, align 8
  %add121 = add nsw i64 %96, %97
  %arraydecay122 = getelementptr inbounds [64 x i8], ptr %used_memory_vm_total_hmem, i64 0, i64 0
  %98 = load ptr, ptr %mh, align 8
  %functions_caches123 = getelementptr inbounds %struct.redisMemOverhead, ptr %98, i32 0, i32 9
  %99 = load i64, ptr %functions_caches123, align 8
  %100 = load ptr, ptr %mh, align 8
  %lua_caches124 = getelementptr inbounds %struct.redisMemOverhead, ptr %100, i32 0, i32 8
  %101 = load i64, ptr %lua_caches124, align 8
  %102 = load ptr, ptr %mh, align 8
  %functions_caches125 = getelementptr inbounds %struct.redisMemOverhead, ptr %102, i32 0, i32 9
  %103 = load i64, ptr %functions_caches125, align 8
  %add126 = add nsw i64 %101, %103
  %arraydecay127 = getelementptr inbounds [64 x i8], ptr %used_memory_scripts_hmem, i64 0, i64 0
  %104 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  %arraydecay128 = getelementptr inbounds [64 x i8], ptr %maxmemory_hmem, i64 0, i64 0
  %105 = load ptr, ptr %evict_policy, align 8
  %106 = load ptr, ptr %mh, align 8
  %allocator_frag = getelementptr inbounds %struct.redisMemOverhead, ptr %106, i32 0, i32 18
  %107 = load float, ptr %allocator_frag, align 8
  %conv129 = fpext float %107 to double
  %108 = load ptr, ptr %mh, align 8
  %allocator_frag_bytes = getelementptr inbounds %struct.redisMemOverhead, ptr %108, i32 0, i32 19
  %109 = load i64, ptr %allocator_frag_bytes, align 8
  %110 = load ptr, ptr %mh, align 8
  %allocator_rss = getelementptr inbounds %struct.redisMemOverhead, ptr %110, i32 0, i32 20
  %111 = load float, ptr %allocator_rss, align 8
  %conv130 = fpext float %111 to double
  %112 = load ptr, ptr %mh, align 8
  %allocator_rss_bytes = getelementptr inbounds %struct.redisMemOverhead, ptr %112, i32 0, i32 21
  %113 = load i64, ptr %allocator_rss_bytes, align 8
  %114 = load ptr, ptr %mh, align 8
  %rss_extra = getelementptr inbounds %struct.redisMemOverhead, ptr %114, i32 0, i32 22
  %115 = load float, ptr %rss_extra, align 8
  %conv131 = fpext float %115 to double
  %116 = load ptr, ptr %mh, align 8
  %rss_extra_bytes = getelementptr inbounds %struct.redisMemOverhead, ptr %116, i32 0, i32 23
  %117 = load i64, ptr %rss_extra_bytes, align 8
  %118 = load ptr, ptr %mh, align 8
  %total_frag = getelementptr inbounds %struct.redisMemOverhead, ptr %118, i32 0, i32 16
  %119 = load float, ptr %total_frag, align 8
  %conv132 = fpext float %119 to double
  %120 = load ptr, ptr %mh, align 8
  %total_frag_bytes = getelementptr inbounds %struct.redisMemOverhead, ptr %120, i32 0, i32 17
  %121 = load i64, ptr %total_frag_bytes, align 8
  %call133 = call i64 @freeMemoryGetNotCountedMemory()
  %122 = load ptr, ptr %mh, align 8
  %repl_backlog = getelementptr inbounds %struct.redisMemOverhead, ptr %122, i32 0, i32 3
  %123 = load i64, ptr %repl_backlog, align 8
  %124 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 279), align 8
  %125 = load ptr, ptr %mh, align 8
  %clients_slaves = getelementptr inbounds %struct.redisMemOverhead, ptr %125, i32 0, i32 4
  %126 = load i64, ptr %clients_slaves, align 8
  %127 = load ptr, ptr %mh, align 8
  %clients_normal = getelementptr inbounds %struct.redisMemOverhead, ptr %127, i32 0, i32 5
  %128 = load i64, ptr %clients_normal, align 8
  %129 = load ptr, ptr %mh, align 8
  %cluster_links = getelementptr inbounds %struct.redisMemOverhead, ptr %129, i32 0, i32 6
  %130 = load i64, ptr %cluster_links, align 8
  %131 = load ptr, ptr %mh, align 8
  %aof_buffer = getelementptr inbounds %struct.redisMemOverhead, ptr %131, i32 0, i32 7
  %132 = load i64, ptr %aof_buffer, align 8
  %133 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 22), align 4
  %call134 = call i64 @lazyfreeGetPendingObjectsCount()
  %call135 = call i64 @lazyfreeGetFreedObjectsCount()
  %call136 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %71, ptr noundef @.str.360, i64 noundef %72, ptr noundef %arraydecay106, i64 noundef %73, ptr noundef %arraydecay107, i64 noundef %74, ptr noundef %arraydecay108, double noundef %conv109, i64 noundef %78, i64 noundef %80, i64 noundef %82, double noundef %conv110, i64 noundef %85, i64 noundef %86, i64 noundef %87, i64 noundef %88, ptr noundef %arraydecay111, i64 noundef %89, i64 noundef %90, ptr noundef %arraydecay112, i64 noundef %92, i64 noundef %add118, i64 noundef %call119, i64 noundef %call120, i64 noundef %95, i64 noundef %add121, ptr noundef %arraydecay122, i64 noundef %99, i64 noundef %add126, ptr noundef %arraydecay127, i64 noundef %104, ptr noundef %arraydecay128, ptr noundef %105, double noundef %conv129, i64 noundef %109, double noundef %conv130, i64 noundef %113, double noundef %conv131, i64 noundef %117, double noundef %conv132, i64 noundef %121, i64 noundef %call133, i64 noundef %123, i64 noundef %124, i64 noundef %126, i64 noundef %128, i64 noundef %130, i64 noundef %132, ptr noundef @.str.361, i32 noundef %133, i64 noundef %call134, i64 noundef %call135)
  store ptr %call136, ptr %info, align 8
  %134 = load ptr, ptr %mh, align 8
  call void @freeMemoryOverheadData(ptr noundef %134)
  br label %if.end137

if.end137:                                        ; preds = %if.end105, %lor.lhs.false79
  %135 = load i32, ptr %all_sections.addr, align 4
  %tobool138 = icmp ne i32 %135, 0
  br i1 %tobool138, label %if.then143, label %lor.lhs.false139

lor.lhs.false139:                                 ; preds = %if.end137
  %136 = load ptr, ptr %section_dict.addr, align 8
  %call140 = call ptr @dictFind(ptr noundef %136, ptr noundef @.str.339)
  %cmp141 = icmp ne ptr %call140, null
  br i1 %cmp141, label %if.then143, label %if.end253

if.then143:                                       ; preds = %lor.lhs.false139, %if.end137
  %137 = load i32, ptr %sections, align 4
  %inc144 = add nsw i32 %137, 1
  store i32 %inc144, ptr %sections, align 4
  %tobool145 = icmp ne i32 %137, 0
  br i1 %tobool145, label %if.then146, label %if.end148

if.then146:                                       ; preds = %if.then143
  %138 = load ptr, ptr %info, align 8
  %call147 = call ptr @sdscat(ptr noundef %138, ptr noundef @.str.170)
  store ptr %call147, ptr %info, align 8
  br label %if.end148

if.end148:                                        ; preds = %if.then146, %if.then143
  store double 0.000000e+00, ptr %fork_perc, align 8
  %139 = load double, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 136), align 8
  %tobool149 = fcmp une double %139, 0.000000e+00
  br i1 %tobool149, label %if.then150, label %if.else151

if.then150:                                       ; preds = %if.end148
  %140 = load double, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 136), align 8
  %mul = fmul double %140, 1.000000e+02
  store double %mul, ptr %fork_perc, align 8
  br label %if.end159

if.else151:                                       ; preds = %if.end148
  %141 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 132), align 8
  %tobool152 = icmp ne i64 %141, 0
  br i1 %tobool152, label %if.then153, label %if.end158

if.then153:                                       ; preds = %if.else151
  %142 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 131), align 8
  %conv154 = uitofp i64 %142 to double
  %143 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 132), align 8
  %conv155 = uitofp i64 %143 to double
  %div156 = fdiv double %conv154, %conv155
  %mul157 = fmul double %div156, 1.000000e+02
  store double %mul157, ptr %fork_perc, align 8
  br label %if.end158

if.end158:                                        ; preds = %if.then153, %if.else151
  br label %if.end159

if.end159:                                        ; preds = %if.end158, %if.then150
  br label %do.body

do.body:                                          ; preds = %if.end159
  %144 = load atomic i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 215) monotonic, align 8
  store i32 %144, ptr %atomic-temp, align 4
  %145 = load i32, ptr %atomic-temp, align 4
  store i32 %145, ptr %aof_bio_fsync_status, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  %146 = load ptr, ptr %info, align 8
  %147 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool160 = icmp ne i32 %147, 0
  br i1 %tobool160, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.end
  %148 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 82), align 8
  %tobool161 = icmp ne i32 %148, 0
  %lnot = xor i1 %tobool161, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.end
  %149 = phi i1 [ false, %do.end ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %149 to i32
  %150 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 82), align 8
  %151 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 128), align 8
  %152 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 129), align 8
  %153 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 130), align 8
  %tobool162 = icmp ne i64 %153, 0
  br i1 %tobool162, label %cond.true163, label %cond.false166

cond.true163:                                     ; preds = %land.end
  %154 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 130), align 8
  %call164 = call i64 @elapsedMs(i64 noundef %154)
  %div165 = udiv i64 %call164, 1000
  br label %cond.end167

cond.false166:                                    ; preds = %land.end
  br label %cond.end167

cond.end167:                                      ; preds = %cond.false166, %cond.true163
  %cond168 = phi i64 [ %div165, %cond.true163 ], [ 0, %cond.false166 ]
  %155 = load double, ptr %fork_perc, align 8
  %156 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 131), align 8
  %157 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 132), align 8
  %158 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 219), align 8
  %159 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp169 = icmp eq i32 %159, 1
  %conv170 = zext i1 %cmp169 to i32
  %160 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 229), align 8
  %161 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 235), align 8
  %cmp171 = icmp eq i32 %161, 0
  %cond173 = select i1 %cmp171, ptr @.str.363, ptr @.str.364
  %162 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 231), align 8
  %163 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp174 = icmp ne i32 %163, 1
  br i1 %cmp174, label %cond.true176, label %cond.false177

cond.true176:                                     ; preds = %cond.end167
  br label %cond.end180

cond.false177:                                    ; preds = %cond.end167
  %call178 = call i64 @time(ptr noundef null) #13
  %164 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 232), align 8
  %sub179 = sub nsw i64 %call178, %164
  br label %cond.end180

cond.end180:                                      ; preds = %cond.false177, %cond.true176
  %cond181 = phi i64 [ -1, %cond.true176 ], [ %sub179, %cond.false177 ]
  %165 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 111), align 8
  %166 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 133), align 8
  %167 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 221), align 8
  %168 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 222), align 8
  %169 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp182 = icmp ne i32 %169, 0
  %conv183 = zext i1 %cmp182 to i32
  %170 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp184 = icmp eq i32 %170, 2
  %conv185 = zext i1 %cmp184 to i32
  %171 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 197), align 4
  %172 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 203), align 8
  %173 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp186 = icmp ne i32 %173, 2
  br i1 %cmp186, label %cond.true188, label %cond.false189

cond.true188:                                     ; preds = %cond.end180
  br label %cond.end192

cond.false189:                                    ; preds = %cond.end180
  %call190 = call i64 @time(ptr noundef null) #13
  %174 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 204), align 8
  %sub191 = sub nsw i64 %call190, %174
  br label %cond.end192

cond.end192:                                      ; preds = %cond.false189, %cond.true188
  %cond193 = phi i64 [ -1, %cond.true188 ], [ %sub191, %cond.false189 ]
  %175 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 207), align 4
  %cmp194 = icmp eq i32 %175, 0
  %cond196 = select i1 %cmp194, ptr @.str.363, ptr @.str.364
  %176 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 109), align 8
  %177 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 110), align 8
  %178 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 211), align 8
  %cmp197 = icmp eq i32 %178, 0
  br i1 %cmp197, label %land.rhs199, label %land.end202

land.rhs199:                                      ; preds = %cond.end192
  %179 = load i32, ptr %aof_bio_fsync_status, align 4
  %cmp200 = icmp eq i32 %179, 0
  br label %land.end202

land.end202:                                      ; preds = %land.rhs199, %cond.end192
  %180 = phi i1 [ false, %cond.end192 ], [ %cmp200, %land.rhs199 ]
  %cond204 = select i1 %180, ptr @.str.363, ptr @.str.364
  %181 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 134), align 8
  %182 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  %cmp205 = icmp eq i32 %182, 4
  %conv206 = zext i1 %cmp205 to i32
  %183 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 135), align 8
  %call207 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %146, ptr noundef @.str.362, i32 noundef %land.ext, i32 noundef %150, i64 noundef %151, i64 noundef %152, i64 noundef %cond168, double noundef %155, i64 noundef %156, i64 noundef %157, i64 noundef %158, i32 noundef %conv170, i64 noundef %160, ptr noundef %cond173, i64 noundef %162, i64 noundef %cond181, i64 noundef %165, i64 noundef %166, i64 noundef %167, i64 noundef %168, i32 noundef %conv183, i32 noundef %conv185, i32 noundef %171, i64 noundef %172, i64 noundef %cond193, ptr noundef %cond196, i64 noundef %176, i64 noundef %177, ptr noundef %cond204, i64 noundef %181, i32 noundef %conv206, i64 noundef %183)
  store ptr %call207, ptr %info, align 8
  %184 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 184), align 4
  %tobool208 = icmp ne i32 %184, 0
  br i1 %tobool208, label %if.then209, label %if.end213

if.then209:                                       ; preds = %land.end202
  %185 = load ptr, ptr %info, align 8
  %186 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 193), align 8
  %187 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 192), align 8
  %188 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 197), align 4
  %189 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 198), align 8
  %call210 = call i64 @sdslen(ptr noundef %189)
  %call211 = call i64 @bioPendingJobsOfType(i32 noundef 1)
  %190 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 208), align 8
  %call212 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %185, ptr noundef @.str.365, i64 noundef %186, i64 noundef %187, i32 noundef %188, i64 noundef %call210, i64 noundef %call211, i64 noundef %190)
  store ptr %call212, ptr %info, align 8
  br label %if.end213

if.end213:                                        ; preds = %if.then209, %land.end202
  %191 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool214 = icmp ne i32 %191, 0
  br i1 %tobool214, label %if.then215, label %if.end252

if.then215:                                       ; preds = %if.end213
  store double 0.000000e+00, ptr %perc, align 8
  store i64 1, ptr %remaining_bytes, align 8
  %192 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 83), align 8
  %tobool216 = icmp ne i64 %192, 0
  br i1 %tobool216, label %if.then217, label %if.else223

if.then217:                                       ; preds = %if.then215
  %193 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 85), align 8
  %conv218 = sitofp i64 %193 to double
  %194 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 83), align 8
  %conv219 = sitofp i64 %194 to double
  %div220 = fdiv double %conv218, %conv219
  %mul221 = fmul double %div220, 1.000000e+02
  store double %mul221, ptr %perc, align 8
  %195 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 83), align 8
  %196 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 85), align 8
  %sub222 = sub nsw i64 %195, %196
  store i64 %sub222, ptr %remaining_bytes, align 8
  br label %if.end240

if.else223:                                       ; preds = %if.then215
  %197 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 84), align 8
  %tobool224 = icmp ne i64 %197, 0
  br i1 %tobool224, label %if.then225, label %if.end239

if.then225:                                       ; preds = %if.else223
  %198 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 85), align 8
  %conv226 = sitofp i64 %198 to double
  %199 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 84), align 8
  %conv227 = sitofp i64 %199 to double
  %div228 = fdiv double %conv226, %conv227
  %mul229 = fmul double %div228, 1.000000e+02
  store double %mul229, ptr %perc, align 8
  %200 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 84), align 8
  %201 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 85), align 8
  %sub230 = sub nsw i64 %200, %201
  store i64 %sub230, ptr %remaining_bytes, align 8
  %202 = load double, ptr %perc, align 8
  %cmp231 = fcmp ogt double %202, 0x4058FF5C28F5C28F
  br i1 %cmp231, label %if.then233, label %if.end234

if.then233:                                       ; preds = %if.then225
  store double 0x4058FF5C28F5C28F, ptr %perc, align 8
  br label %if.end234

if.end234:                                        ; preds = %if.then233, %if.then225
  %203 = load i64, ptr %remaining_bytes, align 8
  %cmp235 = icmp slt i64 %203, 1
  br i1 %cmp235, label %if.then237, label %if.end238

if.then237:                                       ; preds = %if.end234
  store i64 1, ptr %remaining_bytes, align 8
  br label %if.end238

if.end238:                                        ; preds = %if.then237, %if.end234
  br label %if.end239

if.end239:                                        ; preds = %if.end238, %if.else223
  br label %if.end240

if.end240:                                        ; preds = %if.end239, %if.then217
  %call241 = call i64 @time(ptr noundef null) #13
  %204 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 86), align 8
  %sub242 = sub nsw i64 %call241, %204
  store i64 %sub242, ptr %elapsed, align 8
  %205 = load i64, ptr %elapsed, align 8
  %cmp243 = icmp eq i64 %205, 0
  br i1 %cmp243, label %if.then245, label %if.else246

if.then245:                                       ; preds = %if.end240
  store i64 1, ptr %eta, align 8
  br label %if.end250

if.else246:                                       ; preds = %if.end240
  %206 = load i64, ptr %elapsed, align 8
  %207 = load i64, ptr %remaining_bytes, align 8
  %mul247 = mul nsw i64 %206, %207
  %208 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 85), align 8
  %add248 = add nsw i64 %208, 1
  %div249 = sdiv i64 %mul247, %add248
  store i64 %div249, ptr %eta, align 8
  br label %if.end250

if.end250:                                        ; preds = %if.else246, %if.then245
  %209 = load ptr, ptr %info, align 8
  %210 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 86), align 8
  %211 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 83), align 8
  %212 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 84), align 8
  %213 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 85), align 8
  %214 = load double, ptr %perc, align 8
  %215 = load i64, ptr %eta, align 8
  %call251 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %209, ptr noundef @.str.366, i64 noundef %210, i64 noundef %211, i64 noundef %212, i64 noundef %213, double noundef %214, i64 noundef %215)
  store ptr %call251, ptr %info, align 8
  br label %if.end252

if.end252:                                        ; preds = %if.end250, %if.end213
  br label %if.end253

if.end253:                                        ; preds = %if.end252, %lor.lhs.false139
  %216 = load i32, ptr %all_sections.addr, align 4
  %tobool254 = icmp ne i32 %216, 0
  br i1 %tobool254, label %if.then259, label %lor.lhs.false255

lor.lhs.false255:                                 ; preds = %if.end253
  %217 = load ptr, ptr %section_dict.addr, align 8
  %call256 = call ptr @dictFind(ptr noundef %217, ptr noundef @.str.340)
  %cmp257 = icmp ne ptr %call256, null
  br i1 %cmp257, label %if.then259, label %if.end353

if.then259:                                       ; preds = %lor.lhs.false255, %if.end253
  %218 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 98), align 8
  %tobool260 = icmp ne i64 %218, 0
  br i1 %tobool260, label %cond.true261, label %cond.false263

cond.true261:                                     ; preds = %if.then259
  %219 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 98), align 8
  %call262 = call i64 @elapsedUs(i64 noundef %219)
  br label %cond.end264

cond.false263:                                    ; preds = %if.then259
  br label %cond.end264

cond.end264:                                      ; preds = %cond.false263, %cond.true261
  %cond265 = phi i64 [ %call262, %cond.true261 ], [ 0, %cond.false263 ]
  store i64 %cond265, ptr %current_eviction_exceeded_time, align 8
  %220 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 107), align 8
  %tobool266 = icmp ne i64 %220, 0
  br i1 %tobool266, label %cond.true267, label %cond.false269

cond.true267:                                     ; preds = %cond.end264
  %221 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 107), align 8
  %call268 = call i64 @elapsedUs(i64 noundef %221)
  br label %cond.end270

cond.false269:                                    ; preds = %cond.end264
  br label %cond.end270

cond.end270:                                      ; preds = %cond.false269, %cond.true267
  %cond271 = phi i64 [ %call268, %cond.true267 ], [ 0, %cond.false269 ]
  store i64 %cond271, ptr %current_active_defrag_time, align 8
  br label %do.body272

do.body272:                                       ; preds = %cond.end270
  %222 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 144) monotonic, align 8
  store i64 %222, ptr %atomic-temp273, align 8
  %223 = load i64, ptr %atomic-temp273, align 8
  store i64 %223, ptr %stat_total_reads_processed, align 8
  br label %do.end274

do.end274:                                        ; preds = %do.body272
  br label %do.body275

do.body275:                                       ; preds = %do.end274
  %224 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 145) monotonic, align 8
  store i64 %224, ptr %atomic-temp276, align 8
  %225 = load i64, ptr %atomic-temp276, align 8
  store i64 %225, ptr %stat_total_writes_processed, align 8
  br label %do.end277

do.end277:                                        ; preds = %do.body275
  br label %do.body278

do.body278:                                       ; preds = %do.end277
  %226 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 124) monotonic, align 8
  store i64 %226, ptr %atomic-temp279, align 8
  %227 = load i64, ptr %atomic-temp279, align 8
  store i64 %227, ptr %stat_net_input_bytes, align 8
  br label %do.end280

do.end280:                                        ; preds = %do.body278
  br label %do.body281

do.body281:                                       ; preds = %do.end280
  %228 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 125) monotonic, align 8
  store i64 %228, ptr %atomic-temp282, align 8
  %229 = load i64, ptr %atomic-temp282, align 8
  store i64 %229, ptr %stat_net_output_bytes, align 8
  br label %do.end283

do.end283:                                        ; preds = %do.body281
  br label %do.body284

do.body284:                                       ; preds = %do.end283
  %230 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 126) monotonic, align 8
  store i64 %230, ptr %atomic-temp285, align 8
  %231 = load i64, ptr %atomic-temp285, align 8
  store i64 %231, ptr %stat_net_repl_input_bytes, align 8
  br label %do.end286

do.end286:                                        ; preds = %do.body284
  br label %do.body287

do.body287:                                       ; preds = %do.end286
  %232 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 127) monotonic, align 8
  store i64 %232, ptr %atomic-temp288, align 8
  %233 = load i64, ptr %atomic-temp288, align 8
  store i64 %233, ptr %stat_net_repl_output_bytes, align 8
  br label %do.end289

do.end289:                                        ; preds = %do.body287
  br label %do.body290

do.body290:                                       ; preds = %do.end289
  %234 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 146) monotonic, align 8
  store i64 %234, ptr %atomic-temp291, align 8
  %235 = load i64, ptr %atomic-temp291, align 8
  store i64 %235, ptr %stat_client_qbuf_limit_disconnections, align 8
  br label %do.end292

do.end292:                                        ; preds = %do.body290
  %236 = load i32, ptr %sections, align 4
  %inc293 = add nsw i32 %236, 1
  store i32 %inc293, ptr %sections, align 4
  %tobool294 = icmp ne i32 %236, 0
  br i1 %tobool294, label %if.then295, label %if.end297

if.then295:                                       ; preds = %do.end292
  %237 = load ptr, ptr %info, align 8
  %call296 = call ptr @sdscat(ptr noundef %237, ptr noundef @.str.170)
  store ptr %call296, ptr %info, align 8
  br label %if.end297

if.end297:                                        ; preds = %if.then295, %do.end292
  %238 = load ptr, ptr %info, align 8
  %239 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 90), align 8
  %240 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 89), align 8
  %call298 = call i64 @getInstantaneousMetric(i32 noundef 0)
  %241 = load i64, ptr %stat_net_input_bytes, align 8
  %242 = load i64, ptr %stat_net_repl_input_bytes, align 8
  %add299 = add nsw i64 %241, %242
  %243 = load i64, ptr %stat_net_output_bytes, align 8
  %244 = load i64, ptr %stat_net_repl_output_bytes, align 8
  %add300 = add nsw i64 %243, %244
  %245 = load i64, ptr %stat_net_repl_input_bytes, align 8
  %246 = load i64, ptr %stat_net_repl_output_bytes, align 8
  %call301 = call i64 @getInstantaneousMetric(i32 noundef 1)
  %conv302 = sitofp i64 %call301 to float
  %div303 = fdiv float %conv302, 1.024000e+03
  %conv304 = fpext float %div303 to double
  %call305 = call i64 @getInstantaneousMetric(i32 noundef 2)
  %conv306 = sitofp i64 %call305 to float
  %div307 = fdiv float %conv306, 1.024000e+03
  %conv308 = fpext float %div307 to double
  %call309 = call i64 @getInstantaneousMetric(i32 noundef 3)
  %conv310 = sitofp i64 %call309 to float
  %div311 = fdiv float %conv310, 1.024000e+03
  %conv312 = fpext float %div311 to double
  %call313 = call i64 @getInstantaneousMetric(i32 noundef 4)
  %conv314 = sitofp i64 %call313 to float
  %div315 = fdiv float %conv314, 1.024000e+03
  %conv316 = fpext float %div315 to double
  %247 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 115), align 8
  %248 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 116), align 8
  %249 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 117), align 8
  %250 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 118), align 8
  %251 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 91), align 8
  %252 = load double, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 92), align 8
  %mul317 = fmul double %252, 1.000000e+02
  %253 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 93), align 8
  %254 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 94), align 8
  %div318 = sdiv i64 %254, 1000
  %255 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 95), align 8
  %256 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 96), align 8
  %257 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 97), align 8
  %258 = load i64, ptr %current_eviction_exceeded_time, align 8
  %add319 = add nsw i64 %257, %258
  %div320 = sdiv i64 %add319, 1000
  %259 = load i64, ptr %current_eviction_exceeded_time, align 8
  %div321 = sdiv i64 %259, 1000
  %260 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 99), align 8
  %261 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 100), align 8
  %262 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 357), align 8
  %ht_used322 = getelementptr inbounds %struct.dict, ptr %262, i32 0, i32 2
  %arrayidx323 = getelementptr inbounds [2 x i64], ptr %ht_used322, i64 0, i64 0
  %263 = load i64, ptr %arrayidx323, align 8
  %264 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 357), align 8
  %ht_used324 = getelementptr inbounds %struct.dict, ptr %264, i32 0, i32 2
  %arrayidx325 = getelementptr inbounds [2 x i64], ptr %ht_used324, i64 0, i64 1
  %265 = load i64, ptr %arrayidx325, align 8
  %add326 = add i64 %263, %265
  %266 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 358), align 8
  %ht_used327 = getelementptr inbounds %struct.dict, ptr %266, i32 0, i32 2
  %arrayidx328 = getelementptr inbounds [2 x i64], ptr %ht_used327, i64 0, i64 0
  %267 = load i64, ptr %arrayidx328, align 8
  %268 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 358), align 8
  %ht_used329 = getelementptr inbounds %struct.dict, ptr %268, i32 0, i32 2
  %arrayidx330 = getelementptr inbounds [2 x i64], ptr %ht_used329, i64 0, i64 1
  %269 = load i64, ptr %arrayidx330, align 8
  %add331 = add i64 %267, %269
  %270 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 360), align 8
  %ht_used332 = getelementptr inbounds %struct.dict, ptr %270, i32 0, i32 2
  %arrayidx333 = getelementptr inbounds [2 x i64], ptr %ht_used332, i64 0, i64 0
  %271 = load i64, ptr %arrayidx333, align 8
  %272 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 360), align 8
  %ht_used334 = getelementptr inbounds %struct.dict, ptr %272, i32 0, i32 2
  %arrayidx335 = getelementptr inbounds [2 x i64], ptr %ht_used334, i64 0, i64 1
  %273 = load i64, ptr %arrayidx335, align 8
  %add336 = add i64 %271, %273
  %274 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 112), align 8
  %275 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 114), align 8
  %276 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 71), align 8
  %ht_used337 = getelementptr inbounds %struct.dict, ptr %276, i32 0, i32 2
  %arrayidx338 = getelementptr inbounds [2 x i64], ptr %ht_used337, i64 0, i64 0
  %277 = load i64, ptr %arrayidx338, align 8
  %278 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 71), align 8
  %ht_used339 = getelementptr inbounds %struct.dict, ptr %278, i32 0, i32 2
  %arrayidx340 = getelementptr inbounds [2 x i64], ptr %ht_used339, i64 0, i64 1
  %279 = load i64, ptr %arrayidx340, align 8
  %add341 = add i64 %277, %279
  %call342 = call i64 @getSlaveKeyWithExpireCount()
  %280 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 101), align 8
  %281 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 102), align 8
  %282 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 103), align 8
  %283 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 104), align 8
  %284 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 106), align 8
  %285 = load i64, ptr %current_active_defrag_time, align 8
  %add343 = add nsw i64 %284, %285
  %div344 = sdiv i64 %add343, 1000
  %286 = load i64, ptr %current_active_defrag_time, align 8
  %div345 = sdiv i64 %286, 1000
  %call346 = call i64 @trackingGetTotalKeys()
  %call347 = call i64 @trackingGetTotalItems()
  %call348 = call i64 @trackingGetTotalPrefixes()
  %287 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 139), align 8
  %288 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 140), align 8
  %289 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 141), align 8
  %290 = load i64, ptr %stat_total_reads_processed, align 8
  %291 = load i64, ptr %stat_total_writes_processed, align 8
  %292 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 142), align 8
  %293 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 143), align 8
  %294 = load i64, ptr %stat_client_qbuf_limit_disconnections, align 8
  %295 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 147), align 8
  %296 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 149), align 8
  %297 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 150), align 8
  %298 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155), align 8
  %299 = load i64, ptr getelementptr inbounds (%struct.durationStats, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155), i32 0, i32 1), align 8
  %300 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155, i64 1, i32 1), align 8
  %call349 = call i64 @getInstantaneousMetric(i32 noundef 5)
  %call350 = call i64 @getInstantaneousMetric(i32 noundef 6)
  %call351 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %238, ptr noundef @.str.367, i64 noundef %239, i64 noundef %240, i64 noundef %call298, i64 noundef %add299, i64 noundef %add300, i64 noundef %245, i64 noundef %246, double noundef %conv304, double noundef %conv308, double noundef %conv312, double noundef %conv316, i64 noundef %247, i64 noundef %248, i64 noundef %249, i64 noundef %250, i64 noundef %251, double noundef %mul317, i64 noundef %253, i64 noundef %div318, i64 noundef %255, i64 noundef %256, i64 noundef %div320, i64 noundef %div321, i64 noundef %260, i64 noundef %261, i64 noundef %add326, i64 noundef %add331, i64 noundef %add336, i64 noundef %274, i64 noundef %275, i64 noundef %add341, i64 noundef %call342, i64 noundef %280, i64 noundef %281, i64 noundef %282, i64 noundef %283, i64 noundef %div344, i64 noundef %div345, i64 noundef %call346, i64 noundef %call347, i64 noundef %call348, i64 noundef %287, i64 noundef %288, i64 noundef %289, i64 noundef %290, i64 noundef %291, i64 noundef %292, i64 noundef %293, i64 noundef %294, i64 noundef %295, i64 noundef %296, i64 noundef %297, i64 noundef %298, i64 noundef %299, i64 noundef %300, i64 noundef %call349, i64 noundef %call350)
  store ptr %call351, ptr %info, align 8
  %301 = load ptr, ptr %info, align 8
  %call352 = call ptr @genRedisInfoStringACLStats(ptr noundef %301)
  store ptr %call352, ptr %info, align 8
  br label %if.end353

if.end353:                                        ; preds = %if.end297, %lor.lhs.false255
  %302 = load i32, ptr %all_sections.addr, align 4
  %tobool354 = icmp ne i32 %302, 0
  br i1 %tobool354, label %if.then359, label %lor.lhs.false355

lor.lhs.false355:                                 ; preds = %if.end353
  %303 = load ptr, ptr %section_dict.addr, align 8
  %call356 = call ptr @dictFind(ptr noundef %303, ptr noundef @.str.341)
  %cmp357 = icmp ne ptr %call356, null
  br i1 %cmp357, label %if.then359, label %if.end478

if.then359:                                       ; preds = %lor.lhs.false355, %if.end353
  %304 = load i32, ptr %sections, align 4
  %inc360 = add nsw i32 %304, 1
  store i32 %inc360, ptr %sections, align 4
  %tobool361 = icmp ne i32 %304, 0
  br i1 %tobool361, label %if.then362, label %if.end364

if.then362:                                       ; preds = %if.then359
  %305 = load ptr, ptr %info, align 8
  %call363 = call ptr @sdscat(ptr noundef %305, ptr noundef @.str.170)
  store ptr %call363, ptr %info, align 8
  br label %if.end364

if.end364:                                        ; preds = %if.then362, %if.then359
  %306 = load ptr, ptr %info, align 8
  %307 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %cmp365 = icmp eq ptr %307, null
  %cond367 = select i1 %cmp365, ptr @.str.369, ptr @.str.370
  %call368 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %306, ptr noundef @.str.368, ptr noundef %cond367)
  store ptr %call368, ptr %info, align 8
  %308 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool369 = icmp ne ptr %308, null
  br i1 %tobool369, label %if.then370, label %if.end424

if.then370:                                       ; preds = %if.end364
  store i64 1, ptr %slave_repl_offset, align 8
  store i64 1, ptr %slave_read_repl_offset, align 8
  %309 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 286), align 8
  %tobool371 = icmp ne ptr %309, null
  br i1 %tobool371, label %if.then372, label %if.else373

if.then372:                                       ; preds = %if.then370
  %310 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 286), align 8
  %reploff = getelementptr inbounds %struct.client, ptr %310, i32 0, i32 42
  %311 = load i64, ptr %reploff, align 8
  store i64 %311, ptr %slave_repl_offset, align 8
  %312 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 286), align 8
  %read_reploff = getelementptr inbounds %struct.client, ptr %312, i32 0, i32 41
  %313 = load i64, ptr %read_reploff, align 8
  store i64 %313, ptr %slave_read_repl_offset, align 8
  br label %if.end379

if.else373:                                       ; preds = %if.then370
  %314 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 287), align 8
  %tobool374 = icmp ne ptr %314, null
  br i1 %tobool374, label %if.then375, label %if.end378

if.then375:                                       ; preds = %if.else373
  %315 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 287), align 8
  %reploff376 = getelementptr inbounds %struct.client, ptr %315, i32 0, i32 42
  %316 = load i64, ptr %reploff376, align 8
  store i64 %316, ptr %slave_repl_offset, align 8
  %317 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 287), align 8
  %read_reploff377 = getelementptr inbounds %struct.client, ptr %317, i32 0, i32 41
  %318 = load i64, ptr %read_reploff377, align 8
  store i64 %318, ptr %slave_read_repl_offset, align 8
  br label %if.end378

if.end378:                                        ; preds = %if.then375, %if.else373
  br label %if.end379

if.end379:                                        ; preds = %if.end378, %if.then372
  %319 = load ptr, ptr %info, align 8
  %320 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %321 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 284), align 8
  %322 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp380 = icmp eq i32 %322, 12
  %cond382 = select i1 %cmp380, ptr @.str.372, ptr @.str.373
  %323 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 286), align 8
  %tobool383 = icmp ne ptr %323, null
  br i1 %tobool383, label %cond.true384, label %cond.false388

cond.true384:                                     ; preds = %if.end379
  %atomic-load385 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %324 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 286), align 8
  %lastinteraction = getelementptr inbounds %struct.client, ptr %324, i32 0, i32 32
  %325 = load i64, ptr %lastinteraction, align 8
  %sub386 = sub nsw i64 %atomic-load385, %325
  %conv387 = trunc i64 %sub386 to i32
  br label %cond.end389

cond.false388:                                    ; preds = %if.end379
  br label %cond.end389

cond.end389:                                      ; preds = %cond.false388, %cond.true384
  %cond390 = phi i32 [ %conv387, %cond.true384 ], [ -1, %cond.false388 ]
  %326 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp391 = icmp eq i32 %326, 11
  %conv392 = zext i1 %cmp391 to i32
  %327 = load i64, ptr %slave_read_repl_offset, align 8
  %328 = load i64, ptr %slave_repl_offset, align 8
  %call393 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %319, ptr noundef @.str.371, ptr noundef %320, i32 noundef %321, ptr noundef %cond382, i32 noundef %cond390, i32 noundef %conv392, i64 noundef %327, i64 noundef %328)
  store ptr %call393, ptr %info, align 8
  %329 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp394 = icmp eq i32 %329, 11
  br i1 %cmp394, label %if.then396, label %if.end410

if.then396:                                       ; preds = %cond.end389
  store double 0.000000e+00, ptr %perc397, align 8
  %330 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 290), align 8
  %tobool398 = icmp ne i64 %330, 0
  br i1 %tobool398, label %if.then399, label %if.end404

if.then399:                                       ; preds = %if.then396
  %331 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 291), align 8
  %conv400 = sitofp i64 %331 to double
  %332 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 290), align 8
  %conv401 = sitofp i64 %332 to double
  %div402 = fdiv double %conv400, %conv401
  %mul403 = fmul double %div402, 1.000000e+02
  store double %mul403, ptr %perc397, align 8
  br label %if.end404

if.end404:                                        ; preds = %if.then399, %if.then396
  %333 = load ptr, ptr %info, align 8
  %334 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 290), align 8
  %335 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 291), align 8
  %336 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 290), align 8
  %337 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 291), align 8
  %sub405 = sub nsw i64 %336, %337
  %338 = load double, ptr %perc397, align 8
  %atomic-load406 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %339 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 296), align 8
  %sub407 = sub nsw i64 %atomic-load406, %339
  %conv408 = trunc i64 %sub407 to i32
  %call409 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %333, ptr noundef @.str.374, i64 noundef %334, i64 noundef %335, i64 noundef %sub405, double noundef %338, i32 noundef %conv408)
  store ptr %call409, ptr %info, align 8
  br label %if.end410

if.end410:                                        ; preds = %if.end404, %cond.end389
  %340 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 289), align 4
  %cmp411 = icmp ne i32 %340, 12
  br i1 %cmp411, label %if.then413, label %if.end422

if.then413:                                       ; preds = %if.end410
  %341 = load ptr, ptr %info, align 8
  %342 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 300), align 8
  %tobool414 = icmp ne i64 %342, 0
  br i1 %tobool414, label %cond.true415, label %cond.false418

cond.true415:                                     ; preds = %if.then413
  %atomic-load416 = load atomic i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 349) seq_cst, align 8
  %343 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 300), align 8
  %sub417 = sub nsw i64 %atomic-load416, %343
  br label %cond.end419

cond.false418:                                    ; preds = %if.then413
  br label %cond.end419

cond.end419:                                      ; preds = %cond.false418, %cond.true415
  %cond420 = phi i64 [ %sub417, %cond.true415 ], [ -1, %cond.false418 ]
  %call421 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %341, ptr noundef @.str.375, i64 noundef %cond420)
  store ptr %call421, ptr %info, align 8
  br label %if.end422

if.end422:                                        ; preds = %cond.end419, %if.end410
  %344 = load ptr, ptr %info, align 8
  %345 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 302), align 4
  %346 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 298), align 4
  %347 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 303), align 8
  %call423 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %344, ptr noundef @.str.376, i32 noundef %345, i32 noundef %346, i32 noundef %347)
  store ptr %call423, ptr %info, align 8
  br label %if.end424

if.end424:                                        ; preds = %if.end422, %if.end364
  %348 = load ptr, ptr %info, align 8
  %349 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %len425 = getelementptr inbounds %struct.list, ptr %349, i32 0, i32 5
  %350 = load i64, ptr %len425, align 8
  %call426 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %348, ptr noundef @.str.377, i64 noundef %350)
  store ptr %call426, ptr %info, align 8
  %351 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 272), align 8
  %tobool427 = icmp ne i32 %351, 0
  br i1 %tobool427, label %land.lhs.true, label %if.end431

land.lhs.true:                                    ; preds = %if.end424
  %352 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 273), align 4
  %tobool428 = icmp ne i32 %352, 0
  br i1 %tobool428, label %if.then429, label %if.end431

if.then429:                                       ; preds = %land.lhs.true
  %353 = load ptr, ptr %info, align 8
  %354 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 274), align 8
  %call430 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %353, ptr noundef @.str.378, i32 noundef %354)
  store ptr %call430, ptr %info, align 8
  br label %if.end431

if.end431:                                        ; preds = %if.then429, %land.lhs.true, %if.end424
  %355 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %len432 = getelementptr inbounds %struct.list, ptr %355, i32 0, i32 5
  %356 = load i64, ptr %len432, align 8
  %tobool433 = icmp ne i64 %356, 0
  br i1 %tobool433, label %if.then434, label %if.end463

if.then434:                                       ; preds = %if.end431
  store i32 0, ptr %slaveid, align 4
  %357 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  call void @listRewind(ptr noundef %357, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end460, %if.then452, %if.then443, %if.then434
  %call435 = call ptr @listNext(ptr noundef %li)
  store ptr %call435, ptr %ln, align 8
  %tobool436 = icmp ne ptr %call435, null
  br i1 %tobool436, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %358 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %358, i32 0, i32 2
  %359 = load ptr, ptr %value, align 8
  store ptr %359, ptr %slave, align 8
  %360 = load ptr, ptr %slave, align 8
  %slave_addr = getelementptr inbounds %struct.client, ptr %360, i32 0, i32 51
  %361 = load ptr, ptr %slave_addr, align 8
  store ptr %361, ptr %slaveip, align 8
  store i64 0, ptr %lag, align 8
  %362 = load ptr, ptr %slaveip, align 8
  %tobool437 = icmp ne ptr %362, null
  br i1 %tobool437, label %if.end446, label %if.then438

if.then438:                                       ; preds = %while.body
  %363 = load ptr, ptr %slave, align 8
  %conn = getelementptr inbounds %struct.client, ptr %363, i32 0, i32 2
  %364 = load ptr, ptr %conn, align 8
  %arraydecay439 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  %call440 = call i32 @connAddrPeerName(ptr noundef %364, ptr noundef %arraydecay439, i64 noundef 46, ptr noundef %port)
  %cmp441 = icmp eq i32 %call440, -1
  br i1 %cmp441, label %if.then443, label %if.end444

if.then443:                                       ; preds = %if.then438
  br label %while.cond, !llvm.loop !71

if.end444:                                        ; preds = %if.then438
  %arraydecay445 = getelementptr inbounds [46 x i8], ptr %ip, i64 0, i64 0
  store ptr %arraydecay445, ptr %slaveip, align 8
  br label %if.end446

if.end446:                                        ; preds = %if.end444, %while.body
  %365 = load ptr, ptr %slave, align 8
  %replstate = getelementptr inbounds %struct.client, ptr %365, i32 0, i32 35
  %366 = load i32, ptr %replstate, align 4
  %call447 = call ptr @replstateToString(i32 noundef %366)
  store ptr %call447, ptr %state, align 8
  %367 = load ptr, ptr %state, align 8
  %arrayidx448 = getelementptr inbounds i8, ptr %367, i64 0
  %368 = load i8, ptr %arrayidx448, align 1
  %conv449 = sext i8 %368 to i32
  %cmp450 = icmp eq i32 %conv449, 0
  br i1 %cmp450, label %if.then452, label %if.end453

if.then452:                                       ; preds = %if.end446
  br label %while.cond, !llvm.loop !71

if.end453:                                        ; preds = %if.end446
  %369 = load ptr, ptr %slave, align 8
  %replstate454 = getelementptr inbounds %struct.client, ptr %369, i32 0, i32 35
  %370 = load i32, ptr %replstate454, align 4
  %cmp455 = icmp eq i32 %370, 9
  br i1 %cmp455, label %if.then457, label %if.end460

if.then457:                                       ; preds = %if.end453
  %call458 = call i64 @time(ptr noundef null) #13
  %371 = load ptr, ptr %slave, align 8
  %repl_ack_time = getelementptr inbounds %struct.client, ptr %371, i32 0, i32 46
  %372 = load i64, ptr %repl_ack_time, align 8
  %sub459 = sub nsw i64 %call458, %372
  store i64 %sub459, ptr %lag, align 8
  br label %if.end460

if.end460:                                        ; preds = %if.then457, %if.end453
  %373 = load ptr, ptr %info, align 8
  %374 = load i32, ptr %slaveid, align 4
  %375 = load ptr, ptr %slaveip, align 8
  %376 = load ptr, ptr %slave, align 8
  %slave_listening_port = getelementptr inbounds %struct.client, ptr %376, i32 0, i32 50
  %377 = load i32, ptr %slave_listening_port, align 4
  %378 = load ptr, ptr %state, align 8
  %379 = load ptr, ptr %slave, align 8
  %repl_ack_off = getelementptr inbounds %struct.client, ptr %379, i32 0, i32 44
  %380 = load i64, ptr %repl_ack_off, align 8
  %381 = load i64, ptr %lag, align 8
  %call461 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %373, ptr noundef @.str.379, i32 noundef %374, ptr noundef %375, i32 noundef %377, ptr noundef %378, i64 noundef %380, i64 noundef %381)
  store ptr %call461, ptr %info, align 8
  %382 = load i32, ptr %slaveid, align 4
  %inc462 = add nsw i32 %382, 1
  store i32 %inc462, ptr %slaveid, align 4
  br label %while.cond, !llvm.loop !71

while.end:                                        ; preds = %while.cond
  br label %if.end463

if.end463:                                        ; preds = %while.end, %if.end431
  %383 = load ptr, ptr %info, align 8
  %call464 = call ptr @getFailoverStateString()
  %384 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %385 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 263), align 8
  %386 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %cmp465 = icmp ne ptr %386, null
  %conv466 = zext i1 %cmp465 to i32
  %387 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 269), align 8
  %388 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %tobool467 = icmp ne ptr %388, null
  br i1 %tobool467, label %cond.true468, label %cond.false469

cond.true468:                                     ; preds = %if.end463
  %389 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %offset = getelementptr inbounds %struct.replBacklog, ptr %389, i32 0, i32 4
  %390 = load i64, ptr %offset, align 8
  br label %cond.end470

cond.false469:                                    ; preds = %if.end463
  br label %cond.end470

cond.end470:                                      ; preds = %cond.false469, %cond.true468
  %cond471 = phi i64 [ %390, %cond.true468 ], [ 0, %cond.false469 ]
  %391 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %tobool472 = icmp ne ptr %391, null
  br i1 %tobool472, label %cond.true473, label %cond.false474

cond.true473:                                     ; preds = %cond.end470
  %392 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %histlen = getelementptr inbounds %struct.replBacklog, ptr %392, i32 0, i32 3
  %393 = load i64, ptr %histlen, align 8
  br label %cond.end475

cond.false474:                                    ; preds = %cond.end470
  br label %cond.end475

cond.end475:                                      ; preds = %cond.false474, %cond.true473
  %cond476 = phi i64 [ %393, %cond.true473 ], [ 0, %cond.false474 ]
  %call477 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %383, ptr noundef @.str.380, ptr noundef %call464, ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 260), ptr noundef getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 261), i64 noundef %384, i64 noundef %385, i32 noundef %conv466, i64 noundef %387, i64 noundef %cond471, i64 noundef %cond476)
  store ptr %call477, ptr %info, align 8
  br label %if.end478

if.end478:                                        ; preds = %cond.end475, %lor.lhs.false355
  %394 = load i32, ptr %all_sections.addr, align 4
  %tobool479 = icmp ne i32 %394, 0
  br i1 %tobool479, label %if.then484, label %lor.lhs.false480

lor.lhs.false480:                                 ; preds = %if.end478
  %395 = load ptr, ptr %section_dict.addr, align 8
  %call481 = call ptr @dictFind(ptr noundef %395, ptr noundef @.str.342)
  %cmp482 = icmp ne ptr %call481, null
  br i1 %cmp482, label %if.then484, label %if.end515

if.then484:                                       ; preds = %lor.lhs.false480, %if.end478
  %396 = load i32, ptr %sections, align 4
  %inc485 = add nsw i32 %396, 1
  store i32 %inc485, ptr %sections, align 4
  %tobool486 = icmp ne i32 %396, 0
  br i1 %tobool486, label %if.then487, label %if.end489

if.then487:                                       ; preds = %if.then484
  %397 = load ptr, ptr %info, align 8
  %call488 = call ptr @sdscat(ptr noundef %397, ptr noundef @.str.170)
  store ptr %call488, ptr %info, align 8
  br label %if.end489

if.end489:                                        ; preds = %if.then487, %if.then484
  %call490 = call i32 @getrusage(i32 noundef 0, ptr noundef %self_ru) #13
  %call491 = call i32 @getrusage(i32 noundef -1, ptr noundef %c_ru) #13
  %398 = load ptr, ptr %info, align 8
  %ru_stime = getelementptr inbounds %struct.rusage, ptr %self_ru, i32 0, i32 1
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %ru_stime, i32 0, i32 0
  %399 = load i64, ptr %tv_sec, align 8
  %ru_stime492 = getelementptr inbounds %struct.rusage, ptr %self_ru, i32 0, i32 1
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %ru_stime492, i32 0, i32 1
  %400 = load i64, ptr %tv_usec, align 8
  %ru_utime = getelementptr inbounds %struct.rusage, ptr %self_ru, i32 0, i32 0
  %tv_sec493 = getelementptr inbounds %struct.timeval, ptr %ru_utime, i32 0, i32 0
  %401 = load i64, ptr %tv_sec493, align 8
  %ru_utime494 = getelementptr inbounds %struct.rusage, ptr %self_ru, i32 0, i32 0
  %tv_usec495 = getelementptr inbounds %struct.timeval, ptr %ru_utime494, i32 0, i32 1
  %402 = load i64, ptr %tv_usec495, align 8
  %ru_stime496 = getelementptr inbounds %struct.rusage, ptr %c_ru, i32 0, i32 1
  %tv_sec497 = getelementptr inbounds %struct.timeval, ptr %ru_stime496, i32 0, i32 0
  %403 = load i64, ptr %tv_sec497, align 8
  %ru_stime498 = getelementptr inbounds %struct.rusage, ptr %c_ru, i32 0, i32 1
  %tv_usec499 = getelementptr inbounds %struct.timeval, ptr %ru_stime498, i32 0, i32 1
  %404 = load i64, ptr %tv_usec499, align 8
  %ru_utime500 = getelementptr inbounds %struct.rusage, ptr %c_ru, i32 0, i32 0
  %tv_sec501 = getelementptr inbounds %struct.timeval, ptr %ru_utime500, i32 0, i32 0
  %405 = load i64, ptr %tv_sec501, align 8
  %ru_utime502 = getelementptr inbounds %struct.rusage, ptr %c_ru, i32 0, i32 0
  %tv_usec503 = getelementptr inbounds %struct.timeval, ptr %ru_utime502, i32 0, i32 1
  %406 = load i64, ptr %tv_usec503, align 8
  %call504 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %398, ptr noundef @.str.381, i64 noundef %399, i64 noundef %400, i64 noundef %401, i64 noundef %402, i64 noundef %403, i64 noundef %404, i64 noundef %405, i64 noundef %406)
  store ptr %call504, ptr %info, align 8
  %call505 = call i32 @getrusage(i32 noundef 1, ptr noundef %m_ru) #13
  %407 = load ptr, ptr %info, align 8
  %ru_stime506 = getelementptr inbounds %struct.rusage, ptr %m_ru, i32 0, i32 1
  %tv_sec507 = getelementptr inbounds %struct.timeval, ptr %ru_stime506, i32 0, i32 0
  %408 = load i64, ptr %tv_sec507, align 8
  %ru_stime508 = getelementptr inbounds %struct.rusage, ptr %m_ru, i32 0, i32 1
  %tv_usec509 = getelementptr inbounds %struct.timeval, ptr %ru_stime508, i32 0, i32 1
  %409 = load i64, ptr %tv_usec509, align 8
  %ru_utime510 = getelementptr inbounds %struct.rusage, ptr %m_ru, i32 0, i32 0
  %tv_sec511 = getelementptr inbounds %struct.timeval, ptr %ru_utime510, i32 0, i32 0
  %410 = load i64, ptr %tv_sec511, align 8
  %ru_utime512 = getelementptr inbounds %struct.rusage, ptr %m_ru, i32 0, i32 0
  %tv_usec513 = getelementptr inbounds %struct.timeval, ptr %ru_utime512, i32 0, i32 1
  %411 = load i64, ptr %tv_usec513, align 8
  %call514 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %407, ptr noundef @.str.382, i64 noundef %408, i64 noundef %409, i64 noundef %410, i64 noundef %411)
  store ptr %call514, ptr %info, align 8
  br label %if.end515

if.end515:                                        ; preds = %if.end489, %lor.lhs.false480
  %412 = load i32, ptr %all_sections.addr, align 4
  %tobool516 = icmp ne i32 %412, 0
  br i1 %tobool516, label %if.then525, label %lor.lhs.false517

lor.lhs.false517:                                 ; preds = %if.end515
  %413 = load ptr, ptr %section_dict.addr, align 8
  %call518 = call ptr @dictFind(ptr noundef %413, ptr noundef @.str.343)
  %cmp519 = icmp ne ptr %call518, null
  br i1 %cmp519, label %if.then525, label %lor.lhs.false521

lor.lhs.false521:                                 ; preds = %lor.lhs.false517
  %414 = load ptr, ptr %section_dict.addr, align 8
  %call522 = call ptr @dictFind(ptr noundef %414, ptr noundef @.str.383)
  %cmp523 = icmp ne ptr %call522, null
  br i1 %cmp523, label %if.then525, label %if.end533

if.then525:                                       ; preds = %lor.lhs.false521, %lor.lhs.false517, %if.end515
  %415 = load i32, ptr %sections, align 4
  %inc526 = add nsw i32 %415, 1
  store i32 %inc526, ptr %sections, align 4
  %tobool527 = icmp ne i32 %415, 0
  br i1 %tobool527, label %if.then528, label %if.end530

if.then528:                                       ; preds = %if.then525
  %416 = load ptr, ptr %info, align 8
  %call529 = call ptr @sdscat(ptr noundef %416, ptr noundef @.str.170)
  store ptr %call529, ptr %info, align 8
  br label %if.end530

if.end530:                                        ; preds = %if.then528, %if.then525
  %417 = load ptr, ptr %info, align 8
  %call531 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %417, ptr noundef @.str.384)
  store ptr %call531, ptr %info, align 8
  %418 = load ptr, ptr %info, align 8
  %call532 = call ptr @genModulesInfoString(ptr noundef %418)
  store ptr %call532, ptr %info, align 8
  br label %if.end533

if.end533:                                        ; preds = %if.end530, %lor.lhs.false521
  %419 = load i32, ptr %all_sections.addr, align 4
  %tobool534 = icmp ne i32 %419, 0
  br i1 %tobool534, label %if.then539, label %lor.lhs.false535

lor.lhs.false535:                                 ; preds = %if.end533
  %420 = load ptr, ptr %section_dict.addr, align 8
  %call536 = call ptr @dictFind(ptr noundef %420, ptr noundef @.str.385)
  %cmp537 = icmp ne ptr %call536, null
  br i1 %cmp537, label %if.then539, label %if.end547

if.then539:                                       ; preds = %lor.lhs.false535, %if.end533
  %421 = load i32, ptr %sections, align 4
  %inc540 = add nsw i32 %421, 1
  store i32 %inc540, ptr %sections, align 4
  %tobool541 = icmp ne i32 %421, 0
  br i1 %tobool541, label %if.then542, label %if.end544

if.then542:                                       ; preds = %if.then539
  %422 = load ptr, ptr %info, align 8
  %call543 = call ptr @sdscat(ptr noundef %422, ptr noundef @.str.170)
  store ptr %call543, ptr %info, align 8
  br label %if.end544

if.end544:                                        ; preds = %if.then542, %if.then539
  %423 = load ptr, ptr %info, align 8
  %call545 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %423, ptr noundef @.str.386)
  store ptr %call545, ptr %info, align 8
  %424 = load ptr, ptr %info, align 8
  %425 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %call546 = call ptr @genRedisInfoStringCommandStats(ptr noundef %424, ptr noundef %425)
  store ptr %call546, ptr %info, align 8
  br label %if.end547

if.end547:                                        ; preds = %if.end544, %lor.lhs.false535
  %426 = load i32, ptr %all_sections.addr, align 4
  %tobool548 = icmp ne i32 %426, 0
  br i1 %tobool548, label %if.then553, label %lor.lhs.false549

lor.lhs.false549:                                 ; preds = %if.end547
  %427 = load ptr, ptr %section_dict.addr, align 8
  %call550 = call ptr @dictFind(ptr noundef %427, ptr noundef @.str.344)
  %cmp551 = icmp ne ptr %call550, null
  br i1 %cmp551, label %if.then553, label %if.end574

if.then553:                                       ; preds = %lor.lhs.false549, %if.end547
  %428 = load i32, ptr %sections, align 4
  %inc554 = add nsw i32 %428, 1
  store i32 %inc554, ptr %sections, align 4
  %tobool555 = icmp ne i32 %428, 0
  br i1 %tobool555, label %if.then556, label %if.end558

if.then556:                                       ; preds = %if.then553
  %429 = load ptr, ptr %info, align 8
  %call557 = call ptr @sdscat(ptr noundef %429, ptr noundef @.str.170)
  store ptr %call557, ptr %info, align 8
  br label %if.end558

if.end558:                                        ; preds = %if.then556, %if.then553
  %430 = load ptr, ptr %info, align 8
  %call559 = call ptr @sdscat(ptr noundef %430, ptr noundef @.str.387)
  store ptr %call559, ptr %info, align 8
  %431 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 15), align 8
  call void @raxStart(ptr noundef %ri, ptr noundef %431)
  %call560 = call i32 @raxSeek(ptr noundef %ri, ptr noundef @.str.388, ptr noundef null, i64 noundef 0)
  br label %while.cond561

while.cond561:                                    ; preds = %if.end572, %if.end558
  %call562 = call i32 @raxNext(ptr noundef %ri)
  %tobool563 = icmp ne i32 %call562, 0
  br i1 %tobool563, label %while.body564, label %while.end573

while.body564:                                    ; preds = %while.cond561
  %data = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 3
  %432 = load ptr, ptr %data, align 8
  store ptr %432, ptr %e, align 8
  %433 = load ptr, ptr %info, align 8
  %key_len = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 4
  %434 = load i64, ptr %key_len, align 8
  %conv565 = trunc i64 %434 to i32
  %key = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 2
  %435 = load ptr, ptr %key, align 8
  %key_len566 = getelementptr inbounds %struct.raxIterator, ptr %ri, i32 0, i32 4
  %436 = load i64, ptr %key_len566, align 8
  %call567 = call ptr @getSafeInfoString(ptr noundef %435, i64 noundef %436, ptr noundef %tmpsafe)
  %437 = load ptr, ptr %e, align 8
  %count = getelementptr inbounds %struct.redisError, ptr %437, i32 0, i32 0
  %438 = load i64, ptr %count, align 8
  %call568 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %433, ptr noundef @.str.389, i32 noundef %conv565, ptr noundef %call567, i64 noundef %438)
  store ptr %call568, ptr %info, align 8
  %439 = load ptr, ptr %tmpsafe, align 8
  %cmp569 = icmp ne ptr %439, null
  br i1 %cmp569, label %if.then571, label %if.end572

if.then571:                                       ; preds = %while.body564
  %440 = load ptr, ptr %tmpsafe, align 8
  call void @zfree(ptr noundef %440)
  br label %if.end572

if.end572:                                        ; preds = %if.then571, %while.body564
  br label %while.cond561, !llvm.loop !72

while.end573:                                     ; preds = %while.cond561
  call void @raxStop(ptr noundef %ri)
  br label %if.end574

if.end574:                                        ; preds = %while.end573, %lor.lhs.false549
  %441 = load i32, ptr %all_sections.addr, align 4
  %tobool575 = icmp ne i32 %441, 0
  br i1 %tobool575, label %if.then580, label %lor.lhs.false576

lor.lhs.false576:                                 ; preds = %if.end574
  %442 = load ptr, ptr %section_dict.addr, align 8
  %call577 = call ptr @dictFind(ptr noundef %442, ptr noundef @.str.390)
  %cmp578 = icmp ne ptr %call577, null
  br i1 %cmp578, label %if.then580, label %if.end591

if.then580:                                       ; preds = %lor.lhs.false576, %if.end574
  %443 = load i32, ptr %sections, align 4
  %inc581 = add nsw i32 %443, 1
  store i32 %inc581, ptr %sections, align 4
  %tobool582 = icmp ne i32 %443, 0
  br i1 %tobool582, label %if.then583, label %if.end585

if.then583:                                       ; preds = %if.then580
  %444 = load ptr, ptr %info, align 8
  %call584 = call ptr @sdscat(ptr noundef %444, ptr noundef @.str.170)
  store ptr %call584, ptr %info, align 8
  br label %if.end585

if.end585:                                        ; preds = %if.then583, %if.then580
  %445 = load ptr, ptr %info, align 8
  %call586 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %445, ptr noundef @.str.391)
  store ptr %call586, ptr %info, align 8
  %446 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 181), align 4
  %tobool587 = icmp ne i32 %446, 0
  br i1 %tobool587, label %if.then588, label %if.end590

if.then588:                                       ; preds = %if.end585
  %447 = load ptr, ptr %info, align 8
  %448 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 12), align 8
  %call589 = call ptr @genRedisInfoStringLatencyStats(ptr noundef %447, ptr noundef %448)
  store ptr %call589, ptr %info, align 8
  br label %if.end590

if.end590:                                        ; preds = %if.then588, %if.end585
  br label %if.end591

if.end591:                                        ; preds = %if.end590, %lor.lhs.false576
  %449 = load i32, ptr %all_sections.addr, align 4
  %tobool592 = icmp ne i32 %449, 0
  br i1 %tobool592, label %if.then597, label %lor.lhs.false593

lor.lhs.false593:                                 ; preds = %if.end591
  %450 = load ptr, ptr %section_dict.addr, align 8
  %call594 = call ptr @dictFind(ptr noundef %450, ptr noundef @.str.345)
  %cmp595 = icmp ne ptr %call594, null
  br i1 %cmp595, label %if.then597, label %if.end604

if.then597:                                       ; preds = %lor.lhs.false593, %if.end591
  %451 = load i32, ptr %sections, align 4
  %inc598 = add nsw i32 %451, 1
  store i32 %inc598, ptr %sections, align 4
  %tobool599 = icmp ne i32 %451, 0
  br i1 %tobool599, label %if.then600, label %if.end602

if.then600:                                       ; preds = %if.then597
  %452 = load ptr, ptr %info, align 8
  %call601 = call ptr @sdscat(ptr noundef %452, ptr noundef @.str.170)
  store ptr %call601, ptr %info, align 8
  br label %if.end602

if.end602:                                        ; preds = %if.then600, %if.then597
  %453 = load ptr, ptr %info, align 8
  %454 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %call603 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %453, ptr noundef @.str.392, i32 noundef %454)
  store ptr %call603, ptr %info, align 8
  br label %if.end604

if.end604:                                        ; preds = %if.end602, %lor.lhs.false593
  %455 = load i32, ptr %all_sections.addr, align 4
  %tobool605 = icmp ne i32 %455, 0
  br i1 %tobool605, label %if.then610, label %lor.lhs.false606

lor.lhs.false606:                                 ; preds = %if.end604
  %456 = load ptr, ptr %section_dict.addr, align 8
  %call607 = call ptr @dictFind(ptr noundef %456, ptr noundef @.str.346)
  %cmp608 = icmp ne ptr %call607, null
  br i1 %cmp608, label %if.then610, label %if.end633

if.then610:                                       ; preds = %lor.lhs.false606, %if.end604
  %457 = load i32, ptr %sections, align 4
  %inc611 = add nsw i32 %457, 1
  store i32 %inc611, ptr %sections, align 4
  %tobool612 = icmp ne i32 %457, 0
  br i1 %tobool612, label %if.then613, label %if.end615

if.then613:                                       ; preds = %if.then610
  %458 = load ptr, ptr %info, align 8
  %call614 = call ptr @sdscat(ptr noundef %458, ptr noundef @.str.170)
  store ptr %call614, ptr %info, align 8
  br label %if.end615

if.end615:                                        ; preds = %if.then613, %if.then610
  %459 = load ptr, ptr %info, align 8
  %call616 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %459, ptr noundef @.str.393)
  store ptr %call616, ptr %info, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end615
  %460 = load i32, ptr %j, align 4
  %461 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 173), align 8
  %cmp617 = icmp slt i32 %460, %461
  br i1 %cmp617, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %462 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %463 = load i32, ptr %j, align 4
  %idxprom = sext i32 %463 to i64
  %arrayidx619 = getelementptr inbounds %struct.redisDb, ptr %462, i64 %idxprom
  %call620 = call i64 @dbSize(ptr noundef %arrayidx619, i32 noundef 0)
  store i64 %call620, ptr %keys, align 8
  %464 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %465 = load i32, ptr %j, align 4
  %idxprom621 = sext i32 %465 to i64
  %arrayidx622 = getelementptr inbounds %struct.redisDb, ptr %464, i64 %idxprom621
  %call623 = call i64 @dbSize(ptr noundef %arrayidx622, i32 noundef 1)
  store i64 %call623, ptr %vkeys, align 8
  %466 = load i64, ptr %keys, align 8
  %tobool624 = icmp ne i64 %466, 0
  br i1 %tobool624, label %if.then627, label %lor.lhs.false625

lor.lhs.false625:                                 ; preds = %for.body
  %467 = load i64, ptr %vkeys, align 8
  %tobool626 = icmp ne i64 %467, 0
  br i1 %tobool626, label %if.then627, label %if.end631

if.then627:                                       ; preds = %lor.lhs.false625, %for.body
  %468 = load ptr, ptr %info, align 8
  %469 = load i32, ptr %j, align 4
  %470 = load i64, ptr %keys, align 8
  %471 = load i64, ptr %vkeys, align 8
  %472 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 10), align 8
  %473 = load i32, ptr %j, align 4
  %idxprom628 = sext i32 %473 to i64
  %arrayidx629 = getelementptr inbounds %struct.redisDb, ptr %472, i64 %idxprom628
  %avg_ttl = getelementptr inbounds %struct.redisDb, ptr %arrayidx629, i32 0, i32 7
  %474 = load i64, ptr %avg_ttl, align 8
  %call630 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %468, ptr noundef @.str.394, i32 noundef %469, i64 noundef %470, i64 noundef %471, i64 noundef %474)
  store ptr %call630, ptr %info, align 8
  br label %if.end631

if.end631:                                        ; preds = %if.then627, %lor.lhs.false625
  br label %for.inc

for.inc:                                          ; preds = %if.end631
  %475 = load i32, ptr %j, align 4
  %inc632 = add nsw i32 %475, 1
  store i32 %inc632, ptr %j, align 4
  br label %for.cond, !llvm.loop !73

for.end:                                          ; preds = %for.cond
  br label %if.end633

if.end633:                                        ; preds = %for.end, %lor.lhs.false606
  %476 = load i32, ptr %everything.addr, align 4
  %tobool634 = icmp ne i32 %476, 0
  br i1 %tobool634, label %if.then657, label %lor.lhs.false635

lor.lhs.false635:                                 ; preds = %if.end633
  %477 = load ptr, ptr %section_dict.addr, align 8
  %call636 = call ptr @dictFind(ptr noundef %477, ptr noundef @.str.383)
  %cmp637 = icmp ne ptr %call636, null
  br i1 %cmp637, label %if.then657, label %lor.lhs.false639

lor.lhs.false639:                                 ; preds = %lor.lhs.false635
  %478 = load i32, ptr %sections, align 4
  %479 = load ptr, ptr %section_dict.addr, align 8
  %ht_used640 = getelementptr inbounds %struct.dict, ptr %479, i32 0, i32 2
  %arrayidx641 = getelementptr inbounds [2 x i64], ptr %ht_used640, i64 0, i64 0
  %480 = load i64, ptr %arrayidx641, align 8
  %481 = load ptr, ptr %section_dict.addr, align 8
  %ht_used642 = getelementptr inbounds %struct.dict, ptr %481, i32 0, i32 2
  %arrayidx643 = getelementptr inbounds [2 x i64], ptr %ht_used642, i64 0, i64 1
  %482 = load i64, ptr %arrayidx643, align 8
  %add644 = add i64 %480, %482
  %conv645 = trunc i64 %add644 to i32
  %cmp646 = icmp slt i32 %478, %conv645
  br i1 %cmp646, label %if.then657, label %lor.lhs.false648

lor.lhs.false648:                                 ; preds = %lor.lhs.false639
  %483 = load i32, ptr %all_sections.addr, align 4
  %tobool649 = icmp ne i32 %483, 0
  br i1 %tobool649, label %land.lhs.true650, label %if.end668

land.lhs.true650:                                 ; preds = %lor.lhs.false648
  %484 = load ptr, ptr %section_dict.addr, align 8
  %ht_used651 = getelementptr inbounds %struct.dict, ptr %484, i32 0, i32 2
  %arrayidx652 = getelementptr inbounds [2 x i64], ptr %ht_used651, i64 0, i64 0
  %485 = load i64, ptr %arrayidx652, align 8
  %486 = load ptr, ptr %section_dict.addr, align 8
  %ht_used653 = getelementptr inbounds %struct.dict, ptr %486, i32 0, i32 2
  %arrayidx654 = getelementptr inbounds [2 x i64], ptr %ht_used653, i64 0, i64 1
  %487 = load i64, ptr %arrayidx654, align 8
  %add655 = add i64 %485, %487
  %tobool656 = icmp ne i64 %add655, 0
  br i1 %tobool656, label %if.then657, label %if.end668

if.then657:                                       ; preds = %land.lhs.true650, %lor.lhs.false639, %lor.lhs.false635, %if.end633
  %488 = load ptr, ptr %info, align 8
  %489 = load i32, ptr %everything.addr, align 4
  %tobool658 = icmp ne i32 %489, 0
  br i1 %tobool658, label %cond.true663, label %lor.lhs.false659

lor.lhs.false659:                                 ; preds = %if.then657
  %490 = load ptr, ptr %section_dict.addr, align 8
  %call660 = call ptr @dictFind(ptr noundef %490, ptr noundef @.str.383)
  %cmp661 = icmp ne ptr %call660, null
  br i1 %cmp661, label %cond.true663, label %cond.false664

cond.true663:                                     ; preds = %lor.lhs.false659, %if.then657
  br label %cond.end665

cond.false664:                                    ; preds = %lor.lhs.false659
  %491 = load ptr, ptr %section_dict.addr, align 8
  br label %cond.end665

cond.end665:                                      ; preds = %cond.false664, %cond.true663
  %cond666 = phi ptr [ null, %cond.true663 ], [ %491, %cond.false664 ]
  %492 = load i32, ptr %sections, align 4
  %call667 = call ptr @modulesCollectInfo(ptr noundef %488, ptr noundef %cond666, i32 noundef 0, i32 noundef %492)
  store ptr %call667, ptr %info, align 8
  br label %if.end668

if.end668:                                        ; preds = %cond.end665, %land.lhs.true650, %lor.lhs.false648
  %493 = load ptr, ptr %section_dict.addr, align 8
  %call669 = call ptr @dictFind(ptr noundef %493, ptr noundef @.str.395)
  %cmp670 = icmp ne ptr %call669, null
  br i1 %cmp670, label %if.then672, label %if.end679

if.then672:                                       ; preds = %if.end668
  %494 = load i32, ptr %sections, align 4
  %inc673 = add nsw i32 %494, 1
  store i32 %inc673, ptr %sections, align 4
  %tobool674 = icmp ne i32 %494, 0
  br i1 %tobool674, label %if.then675, label %if.end677

if.then675:                                       ; preds = %if.then672
  %495 = load ptr, ptr %info, align 8
  %call676 = call ptr @sdscat(ptr noundef %495, ptr noundef @.str.170)
  store ptr %call676, ptr %info, align 8
  br label %if.end677

if.end677:                                        ; preds = %if.then675, %if.then672
  %496 = load ptr, ptr %info, align 8
  %497 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155, i64 2, i32 1), align 8
  %498 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155, i64 3, i32 1), align 8
  %499 = load i64, ptr getelementptr inbounds (%struct.durationStats, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 155), i32 0, i32 2), align 8
  %500 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 153), align 8
  %call678 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %496, ptr noundef @.str.396, i64 noundef %497, i64 noundef %498, i64 noundef %499, i64 noundef %500)
  store ptr %call678, ptr %info, align 8
  br label %if.end679

if.end679:                                        ; preds = %if.end677, %if.end668
  %501 = load ptr, ptr %info, align 8
  ret ptr %501
}

declare ptr @dictFind(ptr noundef, ptr noundef) #2

declare ptr @sdscat(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @uname(ptr noundef) #3

declare ptr @redisGitSHA1() #2

; Function Attrs: nounwind
declare i64 @strtol(ptr noundef, ptr noundef, i32 noundef) #3

declare ptr @redisGitDirty() #2

declare ptr @redisBuildIdString() #2

declare ptr @monotonicInfoString() #2

declare ptr @aeGetApiName() #2

declare ptr @getListensInfoString(ptr noundef) #2

declare void @totalNumberOfBlockingKeys(ptr noundef, ptr noundef) #2

declare i64 @getClusterConnectionsCount() #2

declare i64 @raxSize(ptr noundef) #2

declare ptr @evictPolicyToString() #2

declare i64 @functionsMemory() #2

declare ptr @getMemoryOverheadData() #2

declare ptr @evalScriptsDict() #2

declare i64 @functionsNum() #2

declare i64 @functionsLibNum() #2

declare i64 @freeMemoryGetNotCountedMemory() #2

declare i64 @lazyfreeGetPendingObjectsCount() #2

declare i64 @lazyfreeGetFreedObjectsCount() #2

declare void @freeMemoryOverheadData(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i64 @elapsedMs(i64 noundef %start_time) #0 {
entry:
  %start_time.addr = alloca i64, align 8
  store i64 %start_time, ptr %start_time.addr, align 8
  %0 = load i64, ptr %start_time.addr, align 8
  %call = call i64 @elapsedUs(i64 noundef %0)
  %div = udiv i64 %call, 1000
  ret i64 %div
}

declare i64 @bioPendingJobsOfType(i32 noundef) #2

declare i64 @getSlaveKeyWithExpireCount() #2

declare i64 @trackingGetTotalKeys() #2

declare i64 @trackingGetTotalItems() #2

declare i64 @trackingGetTotalPrefixes() #2

; Function Attrs: nounwind uwtable
define internal i32 @connAddrPeerName(ptr noundef %conn, ptr noundef %ip, i64 noundef %ip_len, ptr noundef %port) #0 {
entry:
  %conn.addr = alloca ptr, align 8
  %ip.addr = alloca ptr, align 8
  %ip_len.addr = alloca i64, align 8
  %port.addr = alloca ptr, align 8
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i64 %ip_len, ptr %ip_len.addr, align 8
  store ptr %port, ptr %port.addr, align 8
  %0 = load ptr, ptr %conn.addr, align 8
  %1 = load ptr, ptr %ip.addr, align 8
  %2 = load i64, ptr %ip_len.addr, align 8
  %3 = load ptr, ptr %port.addr, align 8
  %call = call i32 @connAddr(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef 1)
  ret i32 %call
}

declare ptr @getFailoverStateString() #2

; Function Attrs: nounwind
declare i32 @getrusage(i32 noundef, ptr noundef) #3

declare ptr @genModulesInfoString(ptr noundef) #2

declare void @raxStart(ptr noundef, ptr noundef) #2

declare i32 @raxSeek(ptr noundef, ptr noundef, ptr noundef, i64 noundef) #2

declare i32 @raxNext(ptr noundef) #2

declare void @raxStop(ptr noundef) #2

declare ptr @modulesCollectInfo(ptr noundef, ptr noundef, i32 noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @infoCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %all_sections = alloca i32, align 4
  %everything = alloca i32, align 4
  %sections_dict = alloca ptr, align 8
  %info = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %c.addr, align 8
  call void @sentinelInfoCommand(ptr noundef %1)
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %all_sections, align 4
  store i32 0, ptr %everything, align 4
  %2 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 12
  %3 = load ptr, ptr %argv, align 8
  %add.ptr = getelementptr inbounds ptr, ptr %3, i64 1
  %4 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 11
  %5 = load i32, ptr %argc, align 8
  %sub = sub nsw i32 %5, 1
  %call = call ptr @genInfoSectionDict(ptr noundef %add.ptr, i32 noundef %sub, ptr noundef null, ptr noundef %all_sections, ptr noundef %everything)
  store ptr %call, ptr %sections_dict, align 8
  %6 = load ptr, ptr %sections_dict, align 8
  %7 = load i32, ptr %all_sections, align 4
  %8 = load i32, ptr %everything, align 4
  %call1 = call ptr @genRedisInfoString(ptr noundef %6, i32 noundef %7, i32 noundef %8)
  store ptr %call1, ptr %info, align 8
  %9 = load ptr, ptr %c.addr, align 8
  %10 = load ptr, ptr %info, align 8
  %11 = load ptr, ptr %info, align 8
  %call2 = call i64 @sdslen(ptr noundef %11)
  call void @addReplyVerbatim(ptr noundef %9, ptr noundef %10, i64 noundef %call2, ptr noundef @.str.397)
  %12 = load ptr, ptr %info, align 8
  call void @sdsfree(ptr noundef %12)
  %13 = load ptr, ptr %sections_dict, align 8
  call void @releaseInfoSectionDict(ptr noundef %13)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @sentinelInfoCommand(ptr noundef) #2

declare void @addReplyVerbatim(ptr noundef, ptr noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @monitorCommand(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %flags = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %flags, align 8
  %and = and i64 %1, 2199023255552
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  call void @addReplyError(ptr noundef %2, ptr noundef @.str.398)
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %c.addr, align 8
  %flags1 = getelementptr inbounds %struct.client, ptr %3, i32 0, i32 1
  %4 = load i64, ptr %flags1, align 8
  %and2 = and i64 %4, 1
  %tobool3 = icmp ne i64 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %return

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %c.addr, align 8
  %flags6 = getelementptr inbounds %struct.client, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %flags6, align 8
  %or = or i64 %6, 5
  store i64 %or, ptr %flags6, align 8
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 60), align 8
  %8 = load ptr, ptr %c.addr, align 8
  %call = call ptr @listAddNodeTail(ptr noundef %7, ptr noundef %8)
  %9 = load ptr, ptr %c.addr, align 8
  %10 = load ptr, ptr @shared, align 8
  call void @addReply(ptr noundef %9, ptr noundef %10)
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @checkIgnoreWarning(ptr noundef %warning) #0 {
entry:
  %retval = alloca i32, align 4
  %warning.addr = alloca ptr, align 8
  %argc = alloca i32, align 4
  %j = alloca i32, align 4
  %argv = alloca ptr, align 8
  %flag = alloca ptr, align 8
  store ptr %warning, ptr %warning.addr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 33), align 8
  %call = call ptr @sdssplitargs(ptr noundef %0, ptr noundef %argc)
  store ptr %call, ptr %argv, align 8
  %1 = load ptr, ptr %argv, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr %argc, align 4
  %cmp1 = icmp slt i32 %2, %3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %argv, align 8
  %5 = load i32, ptr %j, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %4, i64 %idxprom
  %6 = load ptr, ptr %arrayidx, align 8
  store ptr %6, ptr %flag, align 8
  %7 = load ptr, ptr %flag, align 8
  %8 = load ptr, ptr %warning.addr, align 8
  %call2 = call i32 @strcasecmp(ptr noundef %7, ptr noundef %8) #14
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %for.body
  br label %for.end

if.end4:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end4
  %9 = load i32, ptr %j, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !74

for.end:                                          ; preds = %if.then3, %for.cond
  %10 = load ptr, ptr %argv, align 8
  %11 = load i32, ptr %argc, align 4
  call void @sdsfreesplitres(ptr noundef %10, i32 noundef %11)
  %12 = load i32, ptr %j, align 4
  %13 = load i32, ptr %argc, align 4
  %cmp5 = icmp slt i32 %12, %13
  %conv = zext i1 %cmp5 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

declare ptr @sdssplitargs(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @linuxMemoryWarnings() #0 {
entry:
  %err_msg = alloca ptr, align 8
  store ptr null, ptr %err_msg, align 8
  %call = call i32 @checkOvercommit(ptr noundef %err_msg)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 3, %0
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %1 = load ptr, ptr %err_msg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.399, ptr noundef %1)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then2
  %2 = load ptr, ptr %err_msg, align 8
  call void @sdsfree(ptr noundef %2)
  br label %if.end3

if.end3:                                          ; preds = %do.end, %entry
  %call4 = call i32 @checkTHPEnabled(ptr noundef %err_msg)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end16

if.then6:                                         ; preds = %if.end3
  store i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 35), align 4
  %call7 = call i32 @THPDisable()
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then6
  store i32 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 35), align 4
  br label %if.end15

if.else:                                          ; preds = %if.then6
  br label %do.body10

do.body10:                                        ; preds = %if.else
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp11 = icmp slt i32 3, %3
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %do.body10
  br label %do.end14

if.end13:                                         ; preds = %do.body10
  %4 = load ptr, ptr %err_msg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.399, ptr noundef %4)
  br label %do.end14

do.end14:                                         ; preds = %if.end13, %if.then12
  br label %if.end15

if.end15:                                         ; preds = %do.end14, %if.then9
  %5 = load ptr, ptr %err_msg, align 8
  call void @sdsfree(ptr noundef %5)
  br label %if.end16

if.end16:                                         ; preds = %if.end15, %if.end3
  ret void
}

declare i32 @checkOvercommit(ptr noundef) #2

declare i32 @checkTHPEnabled(ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @THPDisable() #0 {
entry:
  %retval = alloca i32, align 4
  %ret = alloca i32, align 4
  store i32 -22, ptr %ret, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 324), align 8
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %ret, align 4
  store i32 %1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call = call i32 (i32, ...) @prctl(i32 noundef 41, i32 noundef 1, i32 noundef 0, i32 noundef 0, i32 noundef 0) #13
  store i32 %call, ptr %ret, align 4
  %2 = load i32, ptr %ret, align 4
  store i32 %2, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define dso_local void @createPidFile() #0 {
entry:
  %fp = alloca ptr, align 8
  %0 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 23), align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call noalias ptr @zstrdup(ptr noundef @.str.400)
  store ptr %call, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 23), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 23), align 8
  %call1 = call noalias ptr @fopen64(ptr noundef %1, ptr noundef @.str.401)
  store ptr %call1, ptr %fp, align 8
  %2 = load ptr, ptr %fp, align 8
  %tobool2 = icmp ne ptr %2, null
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %3 = load ptr, ptr %fp, align 8
  %call4 = call i32 @getpid() #13
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %3, ptr noundef @.str.132, i32 noundef %call4)
  %4 = load ptr, ptr %fp, align 8
  %call6 = call i32 @fclose(ptr noundef %4)
  br label %if.end11

if.else:                                          ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.else
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 3, %5
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %do.body
  br label %do.end

if.end8:                                          ; preds = %do.body
  %call9 = call ptr @__errno_location() #17
  %6 = load i32, ptr %call9, align 4
  %call10 = call ptr @strerror(i32 noundef %6) #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.402, ptr noundef %call10)
  br label %do.end

do.end:                                           ; preds = %if.end8, %if.then7
  br label %if.end11

if.end11:                                         ; preds = %do.end, %if.then3
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @daemonize() #0 {
entry:
  %fd = alloca i32, align 4
  %call = call i32 @fork() #13
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @exit(i32 noundef 0) #16
  unreachable

if.end:                                           ; preds = %entry
  %call1 = call i32 @setsid() #13
  %call2 = call i32 (ptr, i32, ...) @open64(ptr noundef @.str.403, i32 noundef 2, i32 noundef 0)
  store i32 %call2, ptr %fd, align 4
  %cmp3 = icmp ne i32 %call2, -1
  br i1 %cmp3, label %if.then4, label %if.end12

if.then4:                                         ; preds = %if.end
  %0 = load i32, ptr %fd, align 4
  %call5 = call i32 @dup2(i32 noundef %0, i32 noundef 0) #13
  %1 = load i32, ptr %fd, align 4
  %call6 = call i32 @dup2(i32 noundef %1, i32 noundef 1) #13
  %2 = load i32, ptr %fd, align 4
  %call7 = call i32 @dup2(i32 noundef %2, i32 noundef 2) #13
  %3 = load i32, ptr %fd, align 4
  %cmp8 = icmp sgt i32 %3, 2
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.then4
  %4 = load i32, ptr %fd, align 4
  %call10 = call i32 @close(i32 noundef %4)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.then4
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.end
  ret void
}

; Function Attrs: nounwind
declare i32 @fork() #3

; Function Attrs: nounwind
declare i32 @setsid() #3

; Function Attrs: nounwind
declare i32 @dup2(i32 noundef, i32 noundef) #3

; Function Attrs: nounwind uwtable
define dso_local void @version() #0 {
entry:
  %call = call ptr @redisGitSHA1()
  %call1 = call ptr @redisGitDirty()
  %call2 = call i32 @atoi(ptr noundef %call1) #14
  %cmp = icmp sgt i32 %call2, 0
  %conv = zext i1 %cmp to i32
  %call3 = call i64 @redisBuildId()
  %call4 = call i32 (ptr, ...) @printf(ptr noundef @.str.404, ptr noundef @.str.355, ptr noundef %call, i32 noundef %conv, ptr noundef @.str.361, i32 noundef 64, i64 noundef %call3)
  call void @exit(i32 noundef 0) #16
  unreachable
}

declare i32 @printf(ptr noundef, ...) #2

declare i64 @redisBuildId() #2

; Function Attrs: nounwind uwtable
define dso_local void @usage() #0 {
entry:
  %0 = load ptr, ptr @stderr, align 8
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str.405)
  %1 = load ptr, ptr @stderr, align 8
  %call1 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %1, ptr noundef @.str.406)
  %2 = load ptr, ptr @stderr, align 8
  %call2 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %2, ptr noundef @.str.407)
  %3 = load ptr, ptr @stderr, align 8
  %call3 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %3, ptr noundef @.str.408)
  %4 = load ptr, ptr @stderr, align 8
  %call4 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %4, ptr noundef @.str.409)
  %5 = load ptr, ptr @stderr, align 8
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.410)
  %6 = load ptr, ptr @stderr, align 8
  %call6 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.8)
  %7 = load ptr, ptr @stderr, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %7, ptr noundef @.str.411)
  %8 = load ptr, ptr @stderr, align 8
  %call8 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %8, ptr noundef @.str.412)
  %9 = load ptr, ptr @stderr, align 8
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef @.str.413)
  %10 = load ptr, ptr @stderr, align 8
  %call10 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %10, ptr noundef @.str.414)
  %11 = load ptr, ptr @stderr, align 8
  %call11 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %11, ptr noundef @.str.415)
  %12 = load ptr, ptr @stderr, align 8
  %call12 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %12, ptr noundef @.str.416)
  %13 = load ptr, ptr @stderr, align 8
  %call13 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %13, ptr noundef @.str.417)
  %14 = load ptr, ptr @stderr, align 8
  %call14 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %14, ptr noundef @.str.418)
  %15 = load ptr, ptr @stderr, align 8
  %call15 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %15, ptr noundef @.str.419)
  %16 = load ptr, ptr @stderr, align 8
  %call16 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %16, ptr noundef @.str.420)
  call void @exit(i32 noundef 1) #16
  unreachable
}

; Function Attrs: nounwind uwtable
define dso_local void @redisAsciiArt() #0 {
entry:
  %ascii_logo = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %mode = alloca ptr, align 8
  %show_logo = alloca i32, align 4
  store ptr @.str.421, ptr %ascii_logo, align 8
  %call = call noalias ptr @zmalloc(i64 noundef 16384) #18
  store ptr %call, ptr %buf, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr @.str.345, ptr %mode, align 8
  br label %if.end4

if.else:                                          ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %if.else
  store ptr @.str.349, ptr %mode, align 8
  br label %if.end

if.else3:                                         ; preds = %if.else
  store ptr @.str.350, ptr %mode, align 8
  br label %if.end

if.end:                                           ; preds = %if.else3, %if.then2
  br label %if.end4

if.end4:                                          ; preds = %if.end, %if.then
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 251), align 8
  %tobool5 = icmp ne i32 %2, 0
  br i1 %tobool5, label %lor.rhs, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end4
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 250), align 8
  %arrayidx = getelementptr inbounds i8, ptr %3, i64 0
  %4 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true7, label %lor.rhs

land.lhs.true7:                                   ; preds = %land.lhs.true
  %5 = load ptr, ptr @stdout, align 8
  %call8 = call i32 @fileno(ptr noundef %5) #13
  %call9 = call i32 @isatty(i32 noundef %call8) #13
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true7, %land.lhs.true, %if.end4
  %6 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 29), align 8
  %tobool11 = icmp ne i32 %6, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true7
  %7 = phi i1 [ true, %land.lhs.true7 ], [ %tobool11, %lor.rhs ]
  %lor.ext = zext i1 %7 to i32
  store i32 %lor.ext, ptr %show_logo, align 4
  %8 = load i32, ptr %show_logo, align 4
  %tobool12 = icmp ne i32 %8, 0
  br i1 %tobool12, label %if.else19, label %if.then13

if.then13:                                        ; preds = %lor.end
  br label %do.body

do.body:                                          ; preds = %if.then13
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp14 = icmp slt i32 2, %9
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %do.body
  br label %do.end

if.end17:                                         ; preds = %do.body
  %10 = load ptr, ptr %mode, align 8
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  %tobool18 = icmp ne i32 %11, 0
  br i1 %tobool18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end17
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end17
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %12, %cond.true ], [ %13, %cond.false ]
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.422, ptr noundef %10, i32 noundef %cond)
  br label %do.end

do.end:                                           ; preds = %cond.end, %if.then16
  br label %if.end33

if.else19:                                        ; preds = %lor.end
  %14 = load ptr, ptr %buf, align 8
  %15 = load ptr, ptr %ascii_logo, align 8
  %call20 = call ptr @redisGitSHA1()
  %call21 = call ptr @redisGitDirty()
  %call22 = call i64 @strtol(ptr noundef %call21, ptr noundef null, i32 noundef 10) #13
  %cmp23 = icmp sgt i64 %call22, 0
  %conv24 = zext i1 %cmp23 to i32
  %16 = load ptr, ptr %mode, align 8
  %17 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  %tobool25 = icmp ne i32 %17, 0
  br i1 %tobool25, label %cond.true26, label %cond.false27

cond.true26:                                      ; preds = %if.else19
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  br label %cond.end28

cond.false27:                                     ; preds = %if.else19
  %19 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  br label %cond.end28

cond.end28:                                       ; preds = %cond.false27, %cond.true26
  %cond29 = phi i32 [ %18, %cond.true26 ], [ %19, %cond.false27 ]
  %call30 = call i32 @getpid() #13
  %conv31 = sext i32 %call30 to i64
  %call32 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %14, i64 noundef 16384, ptr noundef %15, ptr noundef @.str.355, ptr noundef %call20, i32 noundef %conv24, ptr noundef @.str.423, ptr noundef %16, i32 noundef %cond29, i64 noundef %conv31) #13
  %20 = load ptr, ptr %buf, align 8
  call void @serverLogRaw(i32 noundef 1026, ptr noundef %20)
  br label %if.end33

if.end33:                                         ; preds = %cond.end28, %do.end
  %21 = load ptr, ptr %buf, align 8
  call void @zfree(ptr noundef %21)
  ret void
}

; Function Attrs: nounwind
declare i32 @isatty(i32 noundef) #3

; Function Attrs: nounwind
declare i32 @fileno(ptr noundef) #3

; Function Attrs: nounwind uwtable
define dso_local ptr @listenerByType(ptr noundef %typename) #0 {
entry:
  %retval = alloca ptr, align 8
  %typename.addr = alloca ptr, align 8
  %conn_index = alloca i32, align 4
  store ptr %typename, ptr %typename.addr, align 8
  %0 = load ptr, ptr %typename.addr, align 8
  %call = call i32 @connectionIndexByType(ptr noundef %0)
  store i32 %call, ptr %conn_index, align 4
  %1 = load i32, ptr %conn_index, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %conn_index, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [8 x %struct.connListener], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 52), i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define dso_local i32 @changeListener(ptr noundef %listener) #0 {
entry:
  %retval = alloca i32, align 4
  %listener.addr = alloca ptr, align 8
  store ptr %listener, ptr %listener.addr, align 8
  %0 = load ptr, ptr %listener.addr, align 8
  call void @closeListener(ptr noundef %0)
  %1 = load ptr, ptr %listener.addr, align 8
  %port = getelementptr inbounds %struct.connListener, ptr %1, i32 0, i32 4
  %2 = load i32, ptr %port, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end2

if.then:                                          ; preds = %entry
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 177), align 8
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %call = call i32 @redisSetProcTitle(ptr noundef null)
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  store i32 0, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %entry
  %4 = load ptr, ptr %listener.addr, align 8
  %call3 = call i32 @connListen(ptr noundef %4)
  %cmp4 = icmp ne i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end2
  store i32 -1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end2
  %5 = load ptr, ptr %listener.addr, align 8
  %6 = load ptr, ptr %listener.addr, align 8
  %ct = getelementptr inbounds %struct.connListener, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %ct, align 8
  %accept_handler = getelementptr inbounds %struct.ConnectionType, ptr %7, i32 0, i32 5
  %8 = load ptr, ptr %accept_handler, align 8
  %call7 = call i32 @createSocketAcceptHandler(ptr noundef %5, ptr noundef %8)
  %cmp8 = icmp ne i32 %call7, 0
  br i1 %cmp8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end6
  %9 = load ptr, ptr %listener.addr, align 8
  %ct10 = getelementptr inbounds %struct.connListener, ptr %9, i32 0, i32 5
  %10 = load ptr, ptr %ct10, align 8
  %get_type = getelementptr inbounds %struct.ConnectionType, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %get_type, align 8
  %call11 = call ptr %11(ptr noundef null)
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 6350, ptr noundef @.str.424, ptr noundef %call11)
  call void @abort() #16
  unreachable

if.end12:                                         ; preds = %if.end6
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 177), align 8
  %tobool13 = icmp ne i32 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %call15 = call i32 @redisSetProcTitle(ptr noundef null)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end16, %if.then5, %if.end
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define dso_local i32 @redisSetProcTitle(ptr noundef %title) #0 {
entry:
  %retval = alloca i32, align 4
  %title.addr = alloca ptr, align 8
  %proc_title = alloca ptr, align 8
  store ptr %title, ptr %title.addr, align 8
  %0 = load ptr, ptr %title.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %arrayidx = getelementptr inbounds ptr, ptr %1, i64 0
  %2 = load ptr, ptr %arrayidx, align 8
  store ptr %2, ptr %title.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 178), align 8
  %4 = load ptr, ptr %title.addr, align 8
  %call = call ptr @expandProcTitleTemplate(ptr noundef %3, ptr noundef %4)
  store ptr %call, ptr %proc_title, align 8
  %5 = load ptr, ptr %proc_title, align 8
  %tobool1 = icmp ne ptr %5, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %6 = load ptr, ptr %proc_title, align 8
  call void (ptr, ...) @setproctitle(ptr noundef @.str.2, ptr noundef %6)
  %7 = load ptr, ptr %proc_title, align 8
  call void @sdsfree(ptr noundef %7)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind
declare i32 @sigemptyset(ptr noundef) #3

; Function Attrs: nounwind uwtable
define internal void @sigShutdownHandler(i32 noundef %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %msg = alloca ptr, align 8
  store i32 %sig, ptr %sig.addr, align 4
  %0 = load i32, ptr %sig.addr, align 4
  switch i32 %0, label %sw.default [
    i32 2, label %sw.bb
    i32 15, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store ptr @.str.465, ptr %msg, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store ptr @.str.466, ptr %msg, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  store ptr @.str.467, ptr %msg, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb1, %sw.bb
  %1 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %sw.epilog
  %2 = load i32, ptr %sig.addr, align 4
  %cmp = icmp eq i32 %2, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  call void @serverLogRawFromHandler(i32 noundef 3, ptr noundef @.str.468)
  %call = call i32 @getpid() #13
  call void @rdbRemoveTempFile(i32 noundef %call, i32 noundef 1)
  call void @exit(i32 noundef 1) #16
  unreachable

if.else:                                          ; preds = %land.lhs.true, %sw.epilog
  %3 = load volatile i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 81), align 4
  %tobool2 = icmp ne i32 %3, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  store ptr @.str.469, ptr %msg, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %msg, align 8
  call void @serverLogRawFromHandler(i32 noundef 3, ptr noundef %4)
  store volatile i32 1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 17), align 4
  %5 = load i32, ptr %sig.addr, align 4
  store i32 %5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 19), align 8
  ret void
}

; Function Attrs: nounwind
declare i32 @sigaction(i32 noundef, ptr noundef, ptr noundef) #3

declare void @setupDebugSigHandlers() #2

; Function Attrs: nounwind uwtable
define dso_local void @setupChildSignalHandlers() #0 {
entry:
  %act = alloca %struct.sigaction, align 8
  %sa_mask = getelementptr inbounds %struct.sigaction, ptr %act, i32 0, i32 1
  %call = call i32 @sigemptyset(ptr noundef %sa_mask) #13
  %sa_flags = getelementptr inbounds %struct.sigaction, ptr %act, i32 0, i32 2
  store i32 0, ptr %sa_flags, align 8
  %__sigaction_handler = getelementptr inbounds %struct.sigaction, ptr %act, i32 0, i32 0
  store ptr @sigKillChildHandler, ptr %__sigaction_handler, align 8
  %call1 = call i32 @sigaction(i32 noundef 10, ptr noundef %act, ptr noundef null) #13
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sigKillChildHandler(i32 noundef %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %level = alloca i32, align 4
  store i32 %sig, ptr %sig.addr, align 4
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 9), align 8
  %cmp = icmp eq i32 %0, 4
  %cond = select i1 %cmp, i32 1, i32 3
  store i32 %cond, ptr %level, align 4
  %1 = load i32, ptr %level, align 4
  call void @serverLogRawFromHandler(i32 noundef %1, ptr noundef @.str.470)
  call void @exitFromChild(i32 noundef 255)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @closeChildUnusedResourceAfterFork() #0 {
entry:
  call void @closeListeningSockets(i32 noundef 0)
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 382), align 8
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 382), align 8
  %call = call i32 @close(i32 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %3 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 23), align 8
  call void @zfree(ptr noundef %3)
  store ptr null, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 23), align 8
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local i32 @redisFork(i32 noundef %purpose) #0 {
entry:
  %retval = alloca i32, align 4
  %purpose.addr = alloca i32, align 4
  %childpid = alloca i32, align 4
  %start = alloca i64, align 8
  %fork_errno = alloca i32, align 4
  store i32 %purpose, ptr %purpose.addr, align 4
  %0 = load i32, ptr %purpose.addr, align 4
  %call = call i32 @isMutuallyExclusiveChildType(i32 noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %call1 = call i32 @hasActiveChildProcess()
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %call4 = call ptr @__errno_location() #17
  store i32 17, ptr %call4, align 4
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  call void @openChildInfoPipe()
  br label %if.end5

if.end5:                                          ; preds = %if.end, %entry
  %call6 = call i64 @ustime()
  store i64 %call6, ptr %start, align 8
  %call7 = call i32 @fork() #13
  store i32 %call7, ptr %childpid, align 4
  %cmp = icmp eq i32 %call7, 0
  br i1 %cmp, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end5
  %1 = load i32, ptr %purpose.addr, align 4
  store i32 %1, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 9), align 8
  call void @setupChildSignalHandlers()
  %call9 = call i32 @setOOMScoreAdj(i32 noundef 2)
  call void @updateDictResizePolicy()
  call void @dismissMemoryInChild()
  call void @closeChildUnusedResourceAfterFork()
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 246), align 4
  %cmp10 = icmp ne i32 %2, -1
  br i1 %cmp10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.then8
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 246), align 4
  %call12 = call i32 @close(i32 noundef %3)
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.then8
  br label %if.end39

if.else:                                          ; preds = %if.end5
  %4 = load i32, ptr %childpid, align 4
  %cmp14 = icmp eq i32 %4, -1
  br i1 %cmp14, label %if.then15, label %if.end22

if.then15:                                        ; preds = %if.else
  %call16 = call ptr @__errno_location() #17
  %5 = load i32, ptr %call16, align 4
  store i32 %5, ptr %fork_errno, align 4
  %6 = load i32, ptr %purpose.addr, align 4
  %call17 = call i32 @isMutuallyExclusiveChildType(i32 noundef %6)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.then15
  call void @closeChildInfoPipe()
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.then15
  %7 = load i32, ptr %fork_errno, align 4
  %call21 = call ptr @__errno_location() #17
  store i32 %7, ptr %call21, align 4
  store i32 -1, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.else
  %8 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 114), align 8
  %inc = add nsw i64 %8, 1
  store i64 %inc, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 114), align 8
  %call23 = call i64 @ustime()
  %9 = load i64, ptr %start, align 8
  %sub = sub nsw i64 %call23, %9
  store i64 %sub, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 112), align 8
  %call24 = call i64 @zmalloc_used_memory()
  %conv = uitofp i64 %call24 to double
  %mul = fmul double %conv, 1.000000e+06
  %10 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 112), align 8
  %conv25 = sitofp i64 %10 to double
  %div = fdiv double %mul, %conv25
  %div26 = fdiv double %div, 0x41D0000000000000
  store double %div26, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 113), align 8
  %11 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %tobool27 = icmp ne i64 %11, 0
  br i1 %tobool27, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %if.end22
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 112), align 8
  %div28 = sdiv i64 %12, 1000
  %13 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 393), align 8
  %cmp29 = icmp sge i64 %div28, %13
  br i1 %cmp29, label %if.then31, label %if.end33

if.then31:                                        ; preds = %land.lhs.true
  %14 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 112), align 8
  %div32 = sdiv i64 %14, 1000
  call void @latencyAddSample(ptr noundef @.str.425, i64 noundef %div32)
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %land.lhs.true, %if.end22
  %15 = load i32, ptr %purpose.addr, align 4
  %call34 = call i32 @isMutuallyExclusiveChildType(i32 noundef %15)
  %tobool35 = icmp ne i32 %call34, 0
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end33
  %16 = load i32, ptr %childpid, align 4
  store i32 %16, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 42), align 8
  %17 = load i32, ptr %purpose.addr, align 4
  store i32 %17, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 43), align 4
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 128), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 129), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 130), align 8
  store i64 0, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 131), align 8
  store double 0.000000e+00, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 136), align 8
  %call37 = call i64 @dbTotalServerKeyCount()
  store i64 %call37, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 132), align 8
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end33
  call void @updateDictResizePolicy()
  call void @moduleFireServerEvent(i64 noundef 13, i32 noundef 0, ptr noundef null)
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end13
  %18 = load i32, ptr %childpid, align 4
  store i32 %18, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end39, %if.end20, %if.then3
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

declare void @openChildInfoPipe() #2

; Function Attrs: nounwind uwtable
define dso_local void @dismissMemoryInChild() #0 {
entry:
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %o = alloca ptr, align 8
  %c = alloca ptr, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 35), align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %while.end7

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 280), align 8
  call void @listRewind(ptr noundef %1, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool1 = icmp ne ptr %call, null
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %value, align 8
  store ptr %3, ptr %o, align 8
  %4 = load ptr, ptr %o, align 8
  %5 = load ptr, ptr %o, align 8
  %size = getelementptr inbounds %struct.replBufBlock, ptr %5, i32 0, i32 3
  %6 = load i64, ptr %size, align 8
  call void @dismissMemory(ptr noundef %4, i64 noundef %6)
  br label %while.cond, !llvm.loop !75

while.end:                                        ; preds = %while.cond
  %7 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 55), align 8
  call void @listRewind(ptr noundef %7, ptr noundef %li)
  br label %while.cond2

while.cond2:                                      ; preds = %while.body5, %while.end
  %call3 = call ptr @listNext(ptr noundef %li)
  store ptr %call3, ptr %ln, align 8
  %tobool4 = icmp ne ptr %call3, null
  br i1 %tobool4, label %while.body5, label %while.end7

while.body5:                                      ; preds = %while.cond2
  %8 = load ptr, ptr %ln, align 8
  %value6 = getelementptr inbounds %struct.listNode, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %value6, align 8
  store ptr %9, ptr %c, align 8
  %10 = load ptr, ptr %c, align 8
  call void @dismissClientMemory(ptr noundef %10)
  br label %while.cond2, !llvm.loop !76

while.end7:                                       ; preds = %while.cond2, %if.then
  ret void
}

declare i64 @dbTotalServerKeyCount() #2

; Function Attrs: nounwind uwtable
define dso_local void @sendChildCowInfo(i32 noundef %info_type, ptr noundef %pname) #0 {
entry:
  %info_type.addr = alloca i32, align 4
  %pname.addr = alloca ptr, align 8
  store i32 %info_type, ptr %info_type.addr, align 4
  store ptr %pname, ptr %pname.addr, align 8
  %0 = load i32, ptr %info_type.addr, align 4
  %1 = load ptr, ptr %pname.addr, align 8
  call void @sendChildInfoGeneric(i32 noundef %0, i64 noundef 0, double noundef -1.000000e+00, ptr noundef %1)
  ret void
}

declare void @sendChildInfoGeneric(i32 noundef, i64 noundef, double noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @sendChildInfo(i32 noundef %info_type, i64 noundef %keys, ptr noundef %pname) #0 {
entry:
  %info_type.addr = alloca i32, align 4
  %keys.addr = alloca i64, align 8
  %pname.addr = alloca ptr, align 8
  store i32 %info_type, ptr %info_type.addr, align 4
  store i64 %keys, ptr %keys.addr, align 8
  store ptr %pname, ptr %pname.addr, align 8
  %0 = load i32, ptr %info_type.addr, align 4
  %1 = load i64, ptr %keys.addr, align 8
  %2 = load ptr, ptr %pname.addr, align 8
  call void @sendChildInfoGeneric(i32 noundef %0, i64 noundef %1, double noundef -1.000000e+00, ptr noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define dso_local void @dismissMemory(ptr noundef %ptr, i64 noundef %size_hint) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  %size_hint.addr = alloca i64, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i64 %size_hint, ptr %size_hint.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %size_hint.addr, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %if.end
  %2 = load i64, ptr %size_hint.addr, align 8
  %3 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 36), align 8
  %div = udiv i64 %3, 2
  %cmp1 = icmp ule i64 %2, %div
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %land.lhs.true
  br label %return

if.end3:                                          ; preds = %land.lhs.true, %if.end
  %4 = load ptr, ptr %ptr.addr, align 8
  call void @zmadvise_dontneed(ptr noundef %4)
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  ret void
}

declare void @zmadvise_dontneed(ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local void @dismissClientMemory(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %li = alloca %struct.listIter, align 8
  %ln = alloca ptr, align 8
  %bulk = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %buf = getelementptr inbounds %struct.client, ptr %0, i32 0, i32 84
  %1 = load ptr, ptr %buf, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %buf_usable_size = getelementptr inbounds %struct.client, ptr %2, i32 0, i32 83
  %3 = load i64, ptr %buf_usable_size, align 8
  call void @dismissMemory(ptr noundef %1, i64 noundef %3)
  %4 = load ptr, ptr %c.addr, align 8
  %querybuf = getelementptr inbounds %struct.client, ptr %4, i32 0, i32 8
  %5 = load ptr, ptr %querybuf, align 8
  call void @dismissSds(ptr noundef %5)
  %6 = load ptr, ptr %c.addr, align 8
  %argc = getelementptr inbounds %struct.client, ptr %6, i32 0, i32 11
  %7 = load i32, ptr %argc, align 8
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load ptr, ptr %c.addr, align 8
  %argv_len_sum = getelementptr inbounds %struct.client, ptr %8, i32 0, i32 16
  %9 = load i64, ptr %argv_len_sum, align 8
  %10 = load ptr, ptr %c.addr, align 8
  %argc1 = getelementptr inbounds %struct.client, ptr %10, i32 0, i32 11
  %11 = load i32, ptr %argc1, align 8
  %conv = sext i32 %11 to i64
  %div = udiv i64 %9, %conv
  %12 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 36), align 8
  %cmp = icmp uge i64 %div, %12
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %13 = load i32, ptr %i, align 4
  %14 = load ptr, ptr %c.addr, align 8
  %argc3 = getelementptr inbounds %struct.client, ptr %14, i32 0, i32 11
  %15 = load i32, ptr %argc3, align 8
  %cmp4 = icmp slt i32 %13, %15
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load ptr, ptr %c.addr, align 8
  %argv = getelementptr inbounds %struct.client, ptr %16, i32 0, i32 12
  %17 = load ptr, ptr %argv, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom = sext i32 %18 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %17, i64 %idxprom
  %19 = load ptr, ptr %arrayidx, align 8
  call void @dismissObject(ptr noundef %19, i64 noundef 0)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %20 = load i32, ptr %i, align 4
  %inc = add nsw i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !77

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %land.lhs.true, %entry
  %21 = load ptr, ptr %c.addr, align 8
  %argc6 = getelementptr inbounds %struct.client, ptr %21, i32 0, i32 11
  %22 = load i32, ptr %argc6, align 8
  %tobool7 = icmp ne i32 %22, 0
  br i1 %tobool7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end
  %23 = load ptr, ptr %c.addr, align 8
  %argv9 = getelementptr inbounds %struct.client, ptr %23, i32 0, i32 12
  %24 = load ptr, ptr %argv9, align 8
  %25 = load ptr, ptr %c.addr, align 8
  %argc10 = getelementptr inbounds %struct.client, ptr %25, i32 0, i32 11
  %26 = load i32, ptr %argc10, align 8
  %conv11 = sext i32 %26 to i64
  %mul = mul i64 %conv11, 8
  call void @dismissMemory(ptr noundef %24, i64 noundef %mul)
  br label %if.end12

if.end12:                                         ; preds = %if.then8, %if.end
  %27 = load ptr, ptr %c.addr, align 8
  %reply = getelementptr inbounds %struct.client, ptr %27, i32 0, i32 24
  %28 = load ptr, ptr %reply, align 8
  %len = getelementptr inbounds %struct.list, ptr %28, i32 0, i32 5
  %29 = load i64, ptr %len, align 8
  %tobool13 = icmp ne i64 %29, 0
  br i1 %tobool13, label %land.lhs.true14, label %if.end26

land.lhs.true14:                                  ; preds = %if.end12
  %30 = load ptr, ptr %c.addr, align 8
  %reply_bytes = getelementptr inbounds %struct.client, ptr %30, i32 0, i32 25
  %31 = load i64, ptr %reply_bytes, align 8
  %32 = load ptr, ptr %c.addr, align 8
  %reply15 = getelementptr inbounds %struct.client, ptr %32, i32 0, i32 24
  %33 = load ptr, ptr %reply15, align 8
  %len16 = getelementptr inbounds %struct.list, ptr %33, i32 0, i32 5
  %34 = load i64, ptr %len16, align 8
  %div17 = udiv i64 %31, %34
  %35 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 36), align 8
  %cmp18 = icmp uge i64 %div17, %35
  br i1 %cmp18, label %if.then20, label %if.end26

if.then20:                                        ; preds = %land.lhs.true14
  %36 = load ptr, ptr %c.addr, align 8
  %reply21 = getelementptr inbounds %struct.client, ptr %36, i32 0, i32 24
  %37 = load ptr, ptr %reply21, align 8
  call void @listRewind(ptr noundef %37, ptr noundef %li)
  br label %while.cond

while.cond:                                       ; preds = %if.end25, %if.then20
  %call = call ptr @listNext(ptr noundef %li)
  store ptr %call, ptr %ln, align 8
  %tobool22 = icmp ne ptr %call, null
  br i1 %tobool22, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %38 = load ptr, ptr %ln, align 8
  %value = getelementptr inbounds %struct.listNode, ptr %38, i32 0, i32 2
  %39 = load ptr, ptr %value, align 8
  store ptr %39, ptr %bulk, align 8
  %40 = load ptr, ptr %bulk, align 8
  %tobool23 = icmp ne ptr %40, null
  br i1 %tobool23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %while.body
  %41 = load ptr, ptr %bulk, align 8
  %42 = load ptr, ptr %bulk, align 8
  %size = getelementptr inbounds %struct.clientReplyBlock, ptr %42, i32 0, i32 0
  %43 = load i64, ptr %size, align 8
  call void @dismissMemory(ptr noundef %41, i64 noundef %43)
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %while.body
  br label %while.cond, !llvm.loop !78

while.end:                                        ; preds = %while.cond
  br label %if.end26

if.end26:                                         ; preds = %while.end, %land.lhs.true14, %if.end12
  ret void
}

declare void @dismissSds(ptr noundef) #2

declare void @dismissObject(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @checkForSentinelMode(i32 noundef %argc, ptr noundef %argv, ptr noundef %exec_name) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %exec_name.addr = alloca ptr, align 8
  %j = alloca i32, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store ptr %exec_name, ptr %exec_name.addr, align 8
  %0 = load ptr, ptr %exec_name.addr, align 8
  %call = call ptr @strstr(ptr noundef %0, ptr noundef @.str.426) #14
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, ptr %j, align 4
  %2 = load i32, ptr %argc.addr, align 4
  %cmp1 = icmp slt i32 %1, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %argv.addr, align 8
  %4 = load i32, ptr %j, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %3, i64 %idxprom
  %5 = load ptr, ptr %arrayidx, align 8
  %call2 = call i32 @strcmp(ptr noundef %5, ptr noundef @.str.427) #14
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %for.body
  store i32 1, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end4
  %6 = load i32, ptr %j, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !79

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then3, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strstr(ptr noundef, ptr noundef) #5

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #5

; Function Attrs: nounwind uwtable
define dso_local void @loadDataFromDisk() #0 {
entry:
  %start = alloca i64, align 8
  %ret = alloca i32, align 4
  %rsi = alloca %struct.rdbSaveInfo, align 8
  %rsi_is_valid = alloca i32, align 4
  %rdb_flags = alloca i32, align 4
  %rdb_load_ret = alloca i32, align 4
  %call = call i64 @ustime()
  store i64 %call, ptr %start, align 8
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 217), align 8
  %call1 = call i32 @loadAppendOnlyFiles(ptr noundef %1)
  store i32 %call1, ptr %ret, align 4
  %2 = load i32, ptr %ret, align 4
  %cmp2 = icmp eq i32 %2, 4
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %3 = load i32, ptr %ret, align 4
  %cmp3 = icmp eq i32 %3, 3
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %lor.lhs.false, %if.then
  call void @exit(i32 noundef 1) #16
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  %4 = load i32, ptr %ret, align 4
  %cmp5 = icmp ne i32 %4, 1
  br i1 %cmp5, label %if.then6, label %if.end12

if.then6:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then6
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp7 = icmp slt i32 2, %5
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %do.body
  br label %do.end

if.end9:                                          ; preds = %do.body
  %call10 = call i64 @ustime()
  %6 = load i64, ptr %start, align 8
  %sub = sub nsw i64 %call10, %6
  %conv = sitofp i64 %sub to float
  %div = fdiv float %conv, 1.000000e+06
  %conv11 = fpext float %div to double
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.428, double noundef %conv11)
  br label %do.end

do.end:                                           ; preds = %if.end9, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %do.end, %if.end
  br label %if.end78

if.else:                                          ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %rsi, ptr align 8 @__const.loadDataFromDisk.rsi, i64 64, i1 false)
  store i32 0, ptr %rsi_is_valid, align 4
  %call13 = call ptr @__errno_location() #17
  store i32 0, ptr %call13, align 4
  store i32 0, ptr %rdb_flags, align 4
  %call14 = call i32 @iAmMaster()
  %tobool = icmp ne i32 %call14, 0
  br i1 %tobool, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.else
  call void @createReplicationBacklog()
  %7 = load i32, ptr %rdb_flags, align 4
  %or = or i32 %7, 8
  store i32 %or, ptr %rdb_flags, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then15, %if.else
  %8 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 225), align 8
  %9 = load i32, ptr %rdb_flags, align 4
  %call17 = call i32 @rdbLoad(ptr noundef %8, ptr noundef %rsi, i32 noundef %9)
  store i32 %call17, ptr %rdb_load_ret, align 4
  %10 = load i32, ptr %rdb_load_ret, align 4
  %cmp18 = icmp eq i32 %10, 0
  br i1 %cmp18, label %if.then20, label %if.else61

if.then20:                                        ; preds = %if.end16
  br label %do.body21

do.body21:                                        ; preds = %if.then20
  %11 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp22 = icmp slt i32 2, %11
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %do.body21
  br label %do.end31

if.end25:                                         ; preds = %do.body21
  %call26 = call i64 @ustime()
  %12 = load i64, ptr %start, align 8
  %sub27 = sub nsw i64 %call26, %12
  %conv28 = sitofp i64 %sub27 to float
  %div29 = fdiv float %conv28, 1.000000e+06
  %conv30 = fpext float %div29 to double
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.429, double noundef %conv30)
  br label %do.end31

do.end31:                                         ; preds = %if.end25, %if.then24
  %repl_id_is_set = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 1
  %13 = load i32, ptr %repl_id_is_set, align 4
  %tobool32 = icmp ne i32 %13, 0
  br i1 %tobool32, label %land.lhs.true, label %if.end60

land.lhs.true:                                    ; preds = %do.end31
  %repl_offset = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 3
  %14 = load i64, ptr %repl_offset, align 8
  %cmp33 = icmp ne i64 %14, -1
  br i1 %cmp33, label %land.lhs.true35, label %if.end60

land.lhs.true35:                                  ; preds = %land.lhs.true
  %repl_stream_db = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 0
  %15 = load i32, ptr %repl_stream_db, align 8
  %cmp36 = icmp ne i32 %15, -1
  br i1 %cmp36, label %if.then38, label %if.end60

if.then38:                                        ; preds = %land.lhs.true35
  store i32 1, ptr %rsi_is_valid, align 4
  %call39 = call i32 @iAmMaster()
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.else45, label %if.then41

if.then41:                                        ; preds = %if.then38
  %repl_id = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 2
  %arraydecay = getelementptr inbounds [41 x i8], ptr %repl_id, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 260), ptr align 8 %arraydecay, i64 41, i1 false)
  %repl_offset42 = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 3
  %16 = load i64, ptr %repl_offset42, align 8
  store i64 %16, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  call void @replicationCacheMasterUsingMyself()
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 287), align 8
  %repl_stream_db43 = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 0
  %18 = load i32, ptr %repl_stream_db43, align 8
  %call44 = call i32 @selectDb(ptr noundef %17, i32 noundef %18)
  br label %if.end59

if.else45:                                        ; preds = %if.then38
  %repl_id46 = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 2
  %arraydecay47 = getelementptr inbounds [41 x i8], ptr %repl_id46, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 261), ptr align 8 %arraydecay47, i64 41, i1 false)
  %repl_offset48 = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 3
  %19 = load i64, ptr %repl_offset48, align 8
  %add = add nsw i64 %19, 1
  store i64 %add, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 263), align 8
  %repl_offset49 = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 3
  %20 = load i64, ptr %repl_offset49, align 8
  %21 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %add50 = add nsw i64 %21, %20
  store i64 %add50, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %tobool51 = icmp ne ptr %22, null
  %lnot = xor i1 %tobool51, true
  %lnot52 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot52 to i32
  %conv53 = sext i32 %lnot.ext to i64
  %tobool54 = icmp ne i64 %conv53, 0
  br i1 %tobool54, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else45
  br label %cond.end

cond.false:                                       ; preds = %if.else45
  call void @_serverAssert(ptr noundef @.str.430, ptr noundef @.str.9, i32 noundef 6661)
  call void @abort() #16
  unreachable

23:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %23, %cond.true
  %24 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 262), align 8
  %25 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %histlen = getelementptr inbounds %struct.replBacklog, ptr %25, i32 0, i32 3
  %26 = load i64, ptr %histlen, align 8
  %sub55 = sub nsw i64 %24, %26
  %add56 = add nsw i64 %sub55, 1
  %27 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %offset = getelementptr inbounds %struct.replBacklog, ptr %27, i32 0, i32 4
  store i64 %add56, ptr %offset, align 8
  %repl_offset57 = getelementptr inbounds %struct.rdbSaveInfo, ptr %rsi, i32 0, i32 3
  %28 = load i64, ptr %repl_offset57, align 8
  call void @rebaseReplicationBuffer(i64 noundef %28)
  %call58 = call i64 @time(ptr noundef null) #13
  store i64 %call58, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 271), align 8
  br label %if.end59

if.end59:                                         ; preds = %cond.end, %if.then41
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %land.lhs.true35, %land.lhs.true, %do.end31
  br label %if.end72

if.else61:                                        ; preds = %if.end16
  %29 = load i32, ptr %rdb_load_ret, align 4
  %cmp62 = icmp ne i32 %29, 1
  br i1 %cmp62, label %if.then64, label %if.end71

if.then64:                                        ; preds = %if.else61
  br label %do.body65

do.body65:                                        ; preds = %if.then64
  %30 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp66 = icmp slt i32 3, %30
  br i1 %cmp66, label %if.then68, label %if.end69

if.then68:                                        ; preds = %do.body65
  br label %do.end70

if.end69:                                         ; preds = %do.body65
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.431)
  br label %do.end70

do.end70:                                         ; preds = %if.end69, %if.then68
  call void @exit(i32 noundef 1) #16
  unreachable

if.end71:                                         ; preds = %if.else61
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %if.end60
  %31 = load i32, ptr %rsi_is_valid, align 4
  %tobool73 = icmp ne i32 %31, 0
  br i1 %tobool73, label %if.end77, label %land.lhs.true74

land.lhs.true74:                                  ; preds = %if.end72
  %32 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 268), align 8
  %tobool75 = icmp ne ptr %32, null
  br i1 %tobool75, label %if.then76, label %if.end77

if.then76:                                        ; preds = %land.lhs.true74
  call void @freeReplicationBacklog()
  br label %if.end77

if.end77:                                         ; preds = %if.then76, %land.lhs.true74, %if.end72
  br label %if.end78

if.end78:                                         ; preds = %if.end77, %if.end12
  ret void
}

declare i32 @loadAppendOnlyFiles(ptr noundef) #2

declare void @createReplicationBacklog() #2

declare i32 @rdbLoad(ptr noundef, ptr noundef, i32 noundef) #2

declare void @replicationCacheMasterUsingMyself() #2

declare i32 @selectDb(ptr noundef, i32 noundef) #2

declare void @rebaseReplicationBuffer(i64 noundef) #2

declare void @freeReplicationBacklog() #2

; Function Attrs: nounwind uwtable
define dso_local void @redisOutOfMemoryHandler(i64 noundef %allocation_size) #0 {
entry:
  %allocation_size.addr = alloca i64, align 8
  store i64 %allocation_size, ptr %allocation_size.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 3, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  %1 = load i64, ptr %allocation_size.addr, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.432, i64 noundef %1)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then
  %2 = load i64, ptr %allocation_size.addr, align 8
  call void (ptr, i32, ptr, ...) @_serverPanic(ptr noundef @.str.9, i32 noundef 6687, ptr noundef @.str.433, i64 noundef %2)
  call void @abort() #16
  unreachable
}

; Function Attrs: nounwind uwtable
define dso_local i32 @validateProcTitleTemplate(ptr noundef %template) #0 {
entry:
  %retval = alloca i32, align 4
  %template.addr = alloca ptr, align 8
  %ok = alloca i32, align 4
  %res = alloca ptr, align 8
  store ptr %template, ptr %template.addr, align 8
  store i32 1, ptr %ok, align 4
  %0 = load ptr, ptr %template.addr, align 8
  %call = call ptr @expandProcTitleTemplate(ptr noundef %0, ptr noundef @.str.219)
  store ptr %call, ptr %res, align 8
  %1 = load ptr, ptr %res, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %res, align 8
  %call1 = call i64 @sdslen(ptr noundef %2)
  %cmp = icmp eq i64 %call1, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %ok, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %3 = load ptr, ptr %res, align 8
  call void @sdsfree(ptr noundef %3)
  %4 = load i32, ptr %ok, align 4
  store i32 %4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end3, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal ptr @expandProcTitleTemplate(ptr noundef %template, ptr noundef %title) #0 {
entry:
  %retval = alloca ptr, align 8
  %template.addr = alloca ptr, align 8
  %title.addr = alloca ptr, align 8
  %res = alloca ptr, align 8
  store ptr %template, ptr %template.addr, align 8
  store ptr %title, ptr %title.addr, align 8
  %0 = load ptr, ptr %template.addr, align 8
  %1 = load ptr, ptr %title.addr, align 8
  %call = call ptr @sdstemplate(ptr noundef %0, ptr noundef @redisProcTitleGetVariable, ptr noundef %1)
  store ptr %call, ptr %res, align 8
  %2 = load ptr, ptr %res, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %res, align 8
  %call1 = call ptr @sdstrim(ptr noundef %3, ptr noundef @.str.40)
  store ptr %call1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

declare void @setproctitle(ptr noundef, ...) #2

; Function Attrs: nounwind uwtable
define dso_local void @redisSetCpuAffinity(ptr noundef %cpulist) #0 {
entry:
  %cpulist.addr = alloca ptr, align 8
  store ptr %cpulist, ptr %cpulist.addr, align 8
  %0 = load ptr, ptr %cpulist.addr, align 8
  call void @setcpuaffinity(ptr noundef %0)
  ret void
}

declare void @setcpuaffinity(ptr noundef) #2

declare i32 @sd_notify(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define dso_local i32 @redisIsSupervised(i32 noundef %mode) #0 {
entry:
  %mode.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  store i32 %mode, ptr %mode.addr, align 4
  store i32 0, ptr %ret, align 4
  %0 = load i32, ptr %mode.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %call = call ptr @getenv(ptr noundef @.str.436) #13
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then1
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp2 = icmp slt i32 1, %1
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.437)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then3
  store i32 3, ptr %mode.addr, align 4
  br label %if.end13

if.else:                                          ; preds = %if.then
  %call4 = call ptr @getenv(ptr noundef @.str.438) #13
  %tobool5 = icmp ne ptr %call4, null
  br i1 %tobool5, label %if.then6, label %if.end12

if.then6:                                         ; preds = %if.else
  br label %do.body7

do.body7:                                         ; preds = %if.then6
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp8 = icmp slt i32 1, %2
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.body7
  br label %do.end11

if.end10:                                         ; preds = %do.body7
  call void (i32, ptr, ...) @_serverLog(i32 noundef 1, ptr noundef @.str.439)
  br label %do.end11

do.end11:                                         ; preds = %if.end10, %if.then9
  store i32 2, ptr %mode.addr, align 4
  br label %if.end12

if.end12:                                         ; preds = %do.end11, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %do.end
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  %3 = load i32, ptr %mode.addr, align 4
  switch i32 %3, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb16
  ]

sw.bb:                                            ; preds = %if.end14
  %call15 = call i32 @redisSupervisedUpstart()
  store i32 %call15, ptr %ret, align 4
  br label %sw.epilog

sw.bb16:                                          ; preds = %if.end14
  %call17 = call i32 @redisSupervisedSystemd()
  store i32 %call17, ptr %ret, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end14
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb16, %sw.bb
  %4 = load i32, ptr %ret, align 4
  %tobool18 = icmp ne i32 %4, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %sw.epilog
  %5 = load i32, ptr %mode.addr, align 4
  store i32 %5, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %sw.epilog
  %6 = load i32, ptr %ret, align 4
  ret i32 %6
}

; Function Attrs: nounwind
declare ptr @getenv(ptr noundef) #3

; Function Attrs: nounwind uwtable
define internal i32 @redisSupervisedUpstart() #0 {
entry:
  %retval = alloca i32, align 4
  %upstart_job = alloca ptr, align 8
  %call = call ptr @getenv(ptr noundef @.str.436) #13
  store ptr %call, ptr %upstart_job, align 8
  %0 = load ptr, ptr %upstart_job, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end2, label %if.then

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp = icmp slt i32 3, %1
  br i1 %cmp, label %if.then1, label %if.end

if.then1:                                         ; preds = %do.body
  br label %do.end

if.end:                                           ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.484)
  br label %do.end

do.end:                                           ; preds = %if.end, %if.then1
  store i32 0, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %entry
  br label %do.body3

do.body3:                                         ; preds = %if.end2
  %2 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp4 = icmp slt i32 2, %2
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %do.body3
  br label %do.end7

if.end6:                                          ; preds = %do.body3
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.485)
  br label %do.end7

do.end7:                                          ; preds = %if.end6, %if.then5
  %call8 = call i32 @raise(i32 noundef 19) #13
  %call9 = call i32 @unsetenv(ptr noundef @.str.436) #13
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end7, %do.end
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @redisSupervisedSystemd() #0 {
entry:
  %retval = alloca i32, align 4
  %call = call i32 @redisCommunicateSystemd(ptr noundef @.str.486)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %0 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp1 = icmp slt i32 2, %0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.body
  br label %do.end

if.end3:                                          ; preds = %do.body
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.487)
  br label %do.end

do.end:                                           ; preds = %if.end3, %if.then2
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %do.end, %if.then
  %1 = load i32, ptr %retval, align 4
  ret i32 %1
}

declare i32 @clusterNodeIsMaster(ptr noundef) #2

declare ptr @getMyClusterNode() #2

; Function Attrs: nounwind uwtable
define dso_local i32 @main(i32 noundef %argc, ptr noundef %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %tv = alloca %struct.timeval, align 8
  %j = alloca i32, align 4
  %config_from_stdin = alloca i8, align 1
  %hashseed = alloca [16 x i8], align 16
  %exec_name = alloca ptr, align 8
  %options = alloca ptr, align 8
  %argv_tmp = alloca ptr, align 8
  %argc_tmp = alloca i32, align 4
  %handled_last_config_arg = alloca i32, align 4
  %err_msg = alloca ptr, align 8
  %background = alloca i32, align 4
  %listener = alloca ptr, align 8
  store i32 0, ptr %retval, align 4
  store i32 %argc, ptr %argc.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i8 0, ptr %config_from_stdin, align 1
  %0 = load i32, ptr %argc.addr, align 4
  %1 = load ptr, ptr %argv.addr, align 8
  call void @spt_init(i32 noundef %0, ptr noundef %1)
  call void @tzset() #13
  call void @zmalloc_set_oom_handler(ptr noundef @redisOutOfMemoryHandler)
  %call = call i32 @gettimeofday(ptr noundef %tv, ptr noundef null) #13
  %call1 = call i64 @time(ptr noundef null) #13
  %call2 = call i32 @getpid() #13
  %conv = sext i32 %call2 to i64
  %xor = xor i64 %call1, %conv
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 1
  %2 = load i64, ptr %tv_usec, align 8
  %xor3 = xor i64 %xor, %2
  %conv4 = trunc i64 %xor3 to i32
  call void @srand(i32 noundef %conv4) #13
  %call5 = call i64 @time(ptr noundef null) #13
  %call6 = call i32 @getpid() #13
  %conv7 = sext i32 %call6 to i64
  %xor8 = xor i64 %call5, %conv7
  %tv_usec9 = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 1
  %3 = load i64, ptr %tv_usec9, align 8
  %xor10 = xor i64 %xor8, %3
  %conv11 = trunc i64 %xor10 to i32
  call void @srandom(i32 noundef %conv11) #13
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 0
  %4 = load i64, ptr %tv_sec, align 8
  %mul = mul nsw i64 %4, 1000000
  %tv_usec12 = getelementptr inbounds %struct.timeval, ptr %tv, i32 0, i32 1
  %5 = load i64, ptr %tv_usec12, align 8
  %add = add nsw i64 %mul, %5
  %call13 = call i32 @getpid() #13
  %conv14 = sext i32 %call13 to i64
  %xor15 = xor i64 %add, %conv14
  call void @init_genrand64(i64 noundef %xor15)
  call void @crc64_init()
  %call16 = call i32 @umask(i32 noundef 511) #13
  store i32 %call16, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 7), align 8
  %call17 = call i32 @umask(i32 noundef %call16) #13
  %arraydecay = getelementptr inbounds [16 x i8], ptr %hashseed, i64 0, i64 0
  call void @getRandomBytes(ptr noundef %arraydecay, i64 noundef 16)
  %arraydecay18 = getelementptr inbounds [16 x i8], ptr %hashseed, i64 0, i64 0
  call void @dictSetHashFunctionSeed(ptr noundef %arraydecay18)
  %6 = load ptr, ptr %argv.addr, align 8
  %arrayidx = getelementptr inbounds ptr, ptr %6, i64 0
  %7 = load ptr, ptr %arrayidx, align 8
  %call19 = call ptr @strrchr(ptr noundef %7, i32 noundef 47) #14
  store ptr %call19, ptr %exec_name, align 8
  %8 = load ptr, ptr %exec_name, align 8
  %cmp = icmp eq ptr %8, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load ptr, ptr %argv.addr, align 8
  %arrayidx21 = getelementptr inbounds ptr, ptr %9, i64 0
  %10 = load ptr, ptr %arrayidx21, align 8
  store ptr %10, ptr %exec_name, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load i32, ptr %argc.addr, align 4
  %12 = load ptr, ptr %argv.addr, align 8
  %13 = load ptr, ptr %exec_name, align 8
  %call22 = call i32 @checkForSentinelMode(i32 noundef %11, ptr noundef %12, ptr noundef %13)
  store i32 %call22, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  call void @initServerConfig()
  call void @ACLInit()
  call void @moduleInitModulesSystem()
  %call23 = call i32 @connTypeInitialize()
  %14 = load ptr, ptr %argv.addr, align 8
  %arrayidx24 = getelementptr inbounds ptr, ptr %14, i64 0
  %15 = load ptr, ptr %arrayidx24, align 8
  %call25 = call ptr @getAbsolutePath(ptr noundef %15)
  store ptr %call25, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 3), align 8
  %16 = load i32, ptr %argc.addr, align 4
  %add26 = add nsw i32 %16, 1
  %conv27 = sext i32 %add26 to i64
  %mul28 = mul i64 8, %conv27
  %call29 = call noalias ptr @zmalloc(i64 noundef %mul28) #18
  store ptr %call29, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %17 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %18 = load i32, ptr %argc.addr, align 4
  %idxprom = sext i32 %18 to i64
  %arrayidx30 = getelementptr inbounds ptr, ptr %17, i64 %idxprom
  store ptr null, ptr %arrayidx30, align 8
  store i32 0, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %19 = load i32, ptr %j, align 4
  %20 = load i32, ptr %argc.addr, align 4
  %cmp31 = icmp slt i32 %19, %20
  br i1 %cmp31, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load ptr, ptr %argv.addr, align 8
  %22 = load i32, ptr %j, align 4
  %idxprom33 = sext i32 %22 to i64
  %arrayidx34 = getelementptr inbounds ptr, ptr %21, i64 %idxprom33
  %23 = load ptr, ptr %arrayidx34, align 8
  %call35 = call noalias ptr @zstrdup(ptr noundef %23)
  %24 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %25 = load i32, ptr %j, align 4
  %idxprom36 = sext i32 %25 to i64
  %arrayidx37 = getelementptr inbounds ptr, ptr %24, i64 %idxprom36
  store ptr %call35, ptr %arrayidx37, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %26 = load i32, ptr %j, align 4
  %inc = add nsw i32 %26, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond, !llvm.loop !80

for.end:                                          ; preds = %for.cond
  %27 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool = icmp ne i32 %27, 0
  br i1 %tobool, label %if.then38, label %if.end39

if.then38:                                        ; preds = %for.end
  call void @initSentinelConfig()
  call void @initSentinel()
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %for.end
  %28 = load ptr, ptr %exec_name, align 8
  %call40 = call ptr @strstr(ptr noundef %28, ptr noundef @.str.440) #14
  %cmp41 = icmp ne ptr %call40, null
  br i1 %cmp41, label %if.then43, label %if.else

if.then43:                                        ; preds = %if.end39
  %29 = load i32, ptr %argc.addr, align 4
  %30 = load ptr, ptr %argv.addr, align 8
  %call44 = call i32 @redis_check_rdb_main(i32 noundef %29, ptr noundef %30, ptr noundef null)
  br label %if.end51

if.else:                                          ; preds = %if.end39
  %31 = load ptr, ptr %exec_name, align 8
  %call45 = call ptr @strstr(ptr noundef %31, ptr noundef @.str.441) #14
  %cmp46 = icmp ne ptr %call45, null
  br i1 %cmp46, label %if.then48, label %if.end50

if.then48:                                        ; preds = %if.else
  %32 = load i32, ptr %argc.addr, align 4
  %33 = load ptr, ptr %argv.addr, align 8
  %call49 = call i32 @redis_check_aof_main(i32 noundef %32, ptr noundef %33)
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %if.else
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.then43
  %34 = load i32, ptr %argc.addr, align 4
  %cmp52 = icmp sge i32 %34, 2
  br i1 %cmp52, label %if.then54, label %if.end260

if.then54:                                        ; preds = %if.end51
  store i32 1, ptr %j, align 4
  %call55 = call ptr @sdsempty()
  store ptr %call55, ptr %options, align 8
  %35 = load ptr, ptr %argv.addr, align 8
  %arrayidx56 = getelementptr inbounds ptr, ptr %35, i64 1
  %36 = load ptr, ptr %arrayidx56, align 8
  %call57 = call i32 @strcmp(ptr noundef %36, ptr noundef @.str.442) #14
  %cmp58 = icmp eq i32 %call57, 0
  br i1 %cmp58, label %if.then64, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then54
  %37 = load ptr, ptr %argv.addr, align 8
  %arrayidx60 = getelementptr inbounds ptr, ptr %37, i64 1
  %38 = load ptr, ptr %arrayidx60, align 8
  %call61 = call i32 @strcmp(ptr noundef %38, ptr noundef @.str.443) #14
  %cmp62 = icmp eq i32 %call61, 0
  br i1 %cmp62, label %if.then64, label %if.end65

if.then64:                                        ; preds = %lor.lhs.false, %if.then54
  call void @version()
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %lor.lhs.false
  %39 = load ptr, ptr %argv.addr, align 8
  %arrayidx66 = getelementptr inbounds ptr, ptr %39, i64 1
  %40 = load ptr, ptr %arrayidx66, align 8
  %call67 = call i32 @strcmp(ptr noundef %40, ptr noundef @.str.444) #14
  %cmp68 = icmp eq i32 %call67, 0
  br i1 %cmp68, label %if.then75, label %lor.lhs.false70

lor.lhs.false70:                                  ; preds = %if.end65
  %41 = load ptr, ptr %argv.addr, align 8
  %arrayidx71 = getelementptr inbounds ptr, ptr %41, i64 1
  %42 = load ptr, ptr %arrayidx71, align 8
  %call72 = call i32 @strcmp(ptr noundef %42, ptr noundef @.str.445) #14
  %cmp73 = icmp eq i32 %call72, 0
  br i1 %cmp73, label %if.then75, label %if.end76

if.then75:                                        ; preds = %lor.lhs.false70, %if.end65
  call void @usage()
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %lor.lhs.false70
  %43 = load ptr, ptr %argv.addr, align 8
  %arrayidx77 = getelementptr inbounds ptr, ptr %43, i64 1
  %44 = load ptr, ptr %arrayidx77, align 8
  %call78 = call i32 @strcmp(ptr noundef %44, ptr noundef @.str.446) #14
  %cmp79 = icmp eq i32 %call78, 0
  br i1 %cmp79, label %if.then81, label %if.end91

if.then81:                                        ; preds = %if.end76
  %45 = load i32, ptr %argc.addr, align 4
  %cmp82 = icmp eq i32 %45, 3
  br i1 %cmp82, label %if.then84, label %if.else88

if.then84:                                        ; preds = %if.then81
  %46 = load ptr, ptr %argv.addr, align 8
  %arrayidx85 = getelementptr inbounds ptr, ptr %46, i64 2
  %47 = load ptr, ptr %arrayidx85, align 8
  %call86 = call i32 @atoi(ptr noundef %47) #14
  %conv87 = sext i32 %call86 to i64
  call void @memtest(i64 noundef %conv87, i32 noundef 50)
  call void @exit(i32 noundef 0) #16
  unreachable

if.else88:                                        ; preds = %if.then81
  %48 = load ptr, ptr @stderr, align 8
  %call89 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %48, ptr noundef @.str.447)
  %49 = load ptr, ptr @stderr, align 8
  %call90 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %49, ptr noundef @.str.448)
  call void @exit(i32 noundef 1) #16
  unreachable

if.end91:                                         ; preds = %if.end76
  %50 = load ptr, ptr %argv.addr, align 8
  %arrayidx92 = getelementptr inbounds ptr, ptr %50, i64 1
  %51 = load ptr, ptr %arrayidx92, align 8
  %call93 = call i32 @strcmp(ptr noundef %51, ptr noundef @.str.449) #14
  %cmp94 = icmp eq i32 %call93, 0
  br i1 %cmp94, label %if.then96, label %if.end99

if.then96:                                        ; preds = %if.end91
  %call97 = call i32 @syscheck()
  %tobool98 = icmp ne i32 %call97, 0
  %cond = select i1 %tobool98, i32 0, i32 1
  call void @exit(i32 noundef %cond) #16
  unreachable

if.end99:                                         ; preds = %if.end91
  %52 = load ptr, ptr %argv.addr, align 8
  %arrayidx100 = getelementptr inbounds ptr, ptr %52, i64 1
  %53 = load ptr, ptr %arrayidx100, align 8
  %arrayidx101 = getelementptr inbounds i8, ptr %53, i64 0
  %54 = load i8, ptr %arrayidx101, align 1
  %conv102 = sext i8 %54 to i32
  %cmp103 = icmp ne i32 %conv102, 45
  br i1 %cmp103, label %if.then105, label %if.end111

if.then105:                                       ; preds = %if.end99
  %55 = load ptr, ptr %argv.addr, align 8
  %arrayidx106 = getelementptr inbounds ptr, ptr %55, i64 1
  %56 = load ptr, ptr %arrayidx106, align 8
  %call107 = call ptr @getAbsolutePath(ptr noundef %56)
  store ptr %call107, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  %57 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %arrayidx108 = getelementptr inbounds ptr, ptr %57, i64 1
  %58 = load ptr, ptr %arrayidx108, align 8
  call void @zfree(ptr noundef %58)
  %59 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  %call109 = call noalias ptr @zstrdup(ptr noundef %59)
  %60 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 4), align 8
  %arrayidx110 = getelementptr inbounds ptr, ptr %60, i64 1
  store ptr %call109, ptr %arrayidx110, align 8
  store i32 2, ptr %j, align 4
  br label %if.end111

if.end111:                                        ; preds = %if.then105, %if.end99
  store i32 1, ptr %handled_last_config_arg, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end255, %if.end111
  %61 = load i32, ptr %j, align 4
  %62 = load i32, ptr %argc.addr, align 4
  %cmp112 = icmp slt i32 %61, %62
  br i1 %cmp112, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %63 = load ptr, ptr %argv.addr, align 8
  %64 = load i32, ptr %j, align 4
  %idxprom114 = sext i32 %64 to i64
  %arrayidx115 = getelementptr inbounds ptr, ptr %63, i64 %idxprom114
  %65 = load ptr, ptr %arrayidx115, align 8
  %arrayidx116 = getelementptr inbounds i8, ptr %65, i64 0
  %66 = load i8, ptr %arrayidx116, align 1
  %conv117 = sext i8 %66 to i32
  %cmp118 = icmp eq i32 %conv117, 45
  br i1 %cmp118, label %land.lhs.true, label %if.else133

land.lhs.true:                                    ; preds = %while.body
  %67 = load ptr, ptr %argv.addr, align 8
  %68 = load i32, ptr %j, align 4
  %idxprom120 = sext i32 %68 to i64
  %arrayidx121 = getelementptr inbounds ptr, ptr %67, i64 %idxprom120
  %69 = load ptr, ptr %arrayidx121, align 8
  %arrayidx122 = getelementptr inbounds i8, ptr %69, i64 1
  %70 = load i8, ptr %arrayidx122, align 1
  %conv123 = sext i8 %70 to i32
  %cmp124 = icmp eq i32 %conv123, 0
  br i1 %cmp124, label %land.lhs.true126, label %if.else133

land.lhs.true126:                                 ; preds = %land.lhs.true
  %71 = load i32, ptr %j, align 4
  %cmp127 = icmp eq i32 %71, 1
  br i1 %cmp127, label %if.then132, label %lor.lhs.false129

lor.lhs.false129:                                 ; preds = %land.lhs.true126
  %72 = load i32, ptr %j, align 4
  %73 = load i32, ptr %argc.addr, align 4
  %sub = sub nsw i32 %73, 1
  %cmp130 = icmp eq i32 %72, %sub
  br i1 %cmp130, label %if.then132, label %if.else133

if.then132:                                       ; preds = %lor.lhs.false129, %land.lhs.true126
  store i8 1, ptr %config_from_stdin, align 1
  br label %if.end255

if.else133:                                       ; preds = %lor.lhs.false129, %land.lhs.true, %while.body
  %74 = load i32, ptr %handled_last_config_arg, align 4
  %tobool134 = icmp ne i32 %74, 0
  br i1 %tobool134, label %land.lhs.true135, label %if.else246

land.lhs.true135:                                 ; preds = %if.else133
  %75 = load ptr, ptr %argv.addr, align 8
  %76 = load i32, ptr %j, align 4
  %idxprom136 = sext i32 %76 to i64
  %arrayidx137 = getelementptr inbounds ptr, ptr %75, i64 %idxprom136
  %77 = load ptr, ptr %arrayidx137, align 8
  %arrayidx138 = getelementptr inbounds i8, ptr %77, i64 0
  %78 = load i8, ptr %arrayidx138, align 1
  %conv139 = sext i8 %78 to i32
  %cmp140 = icmp eq i32 %conv139, 45
  br i1 %cmp140, label %land.lhs.true142, label %if.else246

land.lhs.true142:                                 ; preds = %land.lhs.true135
  %79 = load ptr, ptr %argv.addr, align 8
  %80 = load i32, ptr %j, align 4
  %idxprom143 = sext i32 %80 to i64
  %arrayidx144 = getelementptr inbounds ptr, ptr %79, i64 %idxprom143
  %81 = load ptr, ptr %arrayidx144, align 8
  %arrayidx145 = getelementptr inbounds i8, ptr %81, i64 1
  %82 = load i8, ptr %arrayidx145, align 1
  %conv146 = sext i8 %82 to i32
  %cmp147 = icmp eq i32 %conv146, 45
  br i1 %cmp147, label %if.then149, label %if.else246

if.then149:                                       ; preds = %land.lhs.true142
  %83 = load ptr, ptr %options, align 8
  %call150 = call i64 @sdslen(ptr noundef %83)
  %tobool151 = icmp ne i64 %call150, 0
  br i1 %tobool151, label %if.then152, label %if.end154

if.then152:                                       ; preds = %if.then149
  %84 = load ptr, ptr %options, align 8
  %call153 = call ptr @sdscat(ptr noundef %84, ptr noundef @.str.8)
  store ptr %call153, ptr %options, align 8
  br label %if.end154

if.end154:                                        ; preds = %if.then152, %if.then149
  %85 = load ptr, ptr %options, align 8
  %86 = load ptr, ptr %argv.addr, align 8
  %87 = load i32, ptr %j, align 4
  %idxprom155 = sext i32 %87 to i64
  %arrayidx156 = getelementptr inbounds ptr, ptr %86, i64 %idxprom155
  %88 = load ptr, ptr %arrayidx156, align 8
  %add.ptr = getelementptr inbounds i8, ptr %88, i64 2
  %call157 = call ptr @sdscat(ptr noundef %85, ptr noundef %add.ptr)
  store ptr %call157, ptr %options, align 8
  %89 = load ptr, ptr %options, align 8
  %call158 = call ptr @sdscat(ptr noundef %89, ptr noundef @.str.40)
  store ptr %call158, ptr %options, align 8
  %90 = load ptr, ptr %argv.addr, align 8
  %91 = load i32, ptr %j, align 4
  %idxprom159 = sext i32 %91 to i64
  %arrayidx160 = getelementptr inbounds ptr, ptr %90, i64 %idxprom159
  %92 = load ptr, ptr %arrayidx160, align 8
  %call161 = call ptr @sdssplitargs(ptr noundef %92, ptr noundef %argc_tmp)
  store ptr %call161, ptr %argv_tmp, align 8
  %93 = load i32, ptr %argc_tmp, align 4
  %cmp162 = icmp eq i32 %93, 1
  br i1 %cmp162, label %if.then164, label %if.else244

if.then164:                                       ; preds = %if.end154
  store i32 0, ptr %handled_last_config_arg, align 4
  %94 = load i32, ptr %j, align 4
  %95 = load i32, ptr %argc.addr, align 4
  %sub165 = sub nsw i32 %95, 1
  %cmp166 = icmp ne i32 %94, %sub165
  br i1 %cmp166, label %land.lhs.true168, label %if.else191

land.lhs.true168:                                 ; preds = %if.then164
  %96 = load ptr, ptr %argv.addr, align 8
  %97 = load i32, ptr %j, align 4
  %add169 = add nsw i32 %97, 1
  %idxprom170 = sext i32 %add169 to i64
  %arrayidx171 = getelementptr inbounds ptr, ptr %96, i64 %idxprom170
  %98 = load ptr, ptr %arrayidx171, align 8
  %arrayidx172 = getelementptr inbounds i8, ptr %98, i64 0
  %99 = load i8, ptr %arrayidx172, align 1
  %conv173 = sext i8 %99 to i32
  %cmp174 = icmp eq i32 %conv173, 45
  br i1 %cmp174, label %land.lhs.true176, label %if.else191

land.lhs.true176:                                 ; preds = %land.lhs.true168
  %100 = load ptr, ptr %argv.addr, align 8
  %101 = load i32, ptr %j, align 4
  %add177 = add nsw i32 %101, 1
  %idxprom178 = sext i32 %add177 to i64
  %arrayidx179 = getelementptr inbounds ptr, ptr %100, i64 %idxprom178
  %102 = load ptr, ptr %arrayidx179, align 8
  %arrayidx180 = getelementptr inbounds i8, ptr %102, i64 1
  %103 = load i8, ptr %arrayidx180, align 1
  %conv181 = sext i8 %103 to i32
  %cmp182 = icmp eq i32 %conv181, 45
  br i1 %cmp182, label %land.lhs.true184, label %if.else191

land.lhs.true184:                                 ; preds = %land.lhs.true176
  %104 = load ptr, ptr %argv.addr, align 8
  %105 = load i32, ptr %j, align 4
  %idxprom185 = sext i32 %105 to i64
  %arrayidx186 = getelementptr inbounds ptr, ptr %104, i64 %idxprom185
  %106 = load ptr, ptr %arrayidx186, align 8
  %call187 = call i32 @strcasecmp(ptr noundef %106, ptr noundef @.str.450) #14
  %tobool188 = icmp ne i32 %call187, 0
  br i1 %tobool188, label %if.else191, label %if.then189

if.then189:                                       ; preds = %land.lhs.true184
  %107 = load ptr, ptr %options, align 8
  %call190 = call ptr @sdscat(ptr noundef %107, ptr noundef @.str.451)
  store ptr %call190, ptr %options, align 8
  store i32 1, ptr %handled_last_config_arg, align 4
  br label %if.end243

if.else191:                                       ; preds = %land.lhs.true184, %land.lhs.true176, %land.lhs.true168, %if.then164
  %108 = load i32, ptr %j, align 4
  %109 = load i32, ptr %argc.addr, align 4
  %sub192 = sub nsw i32 %109, 1
  %cmp193 = icmp eq i32 %108, %sub192
  br i1 %cmp193, label %land.lhs.true195, label %if.else202

land.lhs.true195:                                 ; preds = %if.else191
  %110 = load ptr, ptr %argv.addr, align 8
  %111 = load i32, ptr %j, align 4
  %idxprom196 = sext i32 %111 to i64
  %arrayidx197 = getelementptr inbounds ptr, ptr %110, i64 %idxprom196
  %112 = load ptr, ptr %arrayidx197, align 8
  %call198 = call i32 @strcasecmp(ptr noundef %112, ptr noundef @.str.450) #14
  %tobool199 = icmp ne i32 %call198, 0
  br i1 %tobool199, label %if.else202, label %if.then200

if.then200:                                       ; preds = %land.lhs.true195
  %113 = load ptr, ptr %options, align 8
  %call201 = call ptr @sdscat(ptr noundef %113, ptr noundef @.str.451)
  store ptr %call201, ptr %options, align 8
  br label %if.end242

if.else202:                                       ; preds = %land.lhs.true195, %if.else191
  %114 = load i32, ptr %j, align 4
  %115 = load i32, ptr %argc.addr, align 4
  %sub203 = sub nsw i32 %115, 1
  %cmp204 = icmp ne i32 %114, %sub203
  br i1 %cmp204, label %land.lhs.true206, label %if.else229

land.lhs.true206:                                 ; preds = %if.else202
  %116 = load ptr, ptr %argv.addr, align 8
  %117 = load i32, ptr %j, align 4
  %add207 = add nsw i32 %117, 1
  %idxprom208 = sext i32 %add207 to i64
  %arrayidx209 = getelementptr inbounds ptr, ptr %116, i64 %idxprom208
  %118 = load ptr, ptr %arrayidx209, align 8
  %arrayidx210 = getelementptr inbounds i8, ptr %118, i64 0
  %119 = load i8, ptr %arrayidx210, align 1
  %conv211 = sext i8 %119 to i32
  %cmp212 = icmp eq i32 %conv211, 45
  br i1 %cmp212, label %land.lhs.true214, label %if.else229

land.lhs.true214:                                 ; preds = %land.lhs.true206
  %120 = load ptr, ptr %argv.addr, align 8
  %121 = load i32, ptr %j, align 4
  %add215 = add nsw i32 %121, 1
  %idxprom216 = sext i32 %add215 to i64
  %arrayidx217 = getelementptr inbounds ptr, ptr %120, i64 %idxprom216
  %122 = load ptr, ptr %arrayidx217, align 8
  %arrayidx218 = getelementptr inbounds i8, ptr %122, i64 1
  %123 = load i8, ptr %arrayidx218, align 1
  %conv219 = sext i8 %123 to i32
  %cmp220 = icmp eq i32 %conv219, 45
  br i1 %cmp220, label %land.lhs.true222, label %if.else229

land.lhs.true222:                                 ; preds = %land.lhs.true214
  %124 = load ptr, ptr %argv.addr, align 8
  %125 = load i32, ptr %j, align 4
  %idxprom223 = sext i32 %125 to i64
  %arrayidx224 = getelementptr inbounds ptr, ptr %124, i64 %idxprom223
  %126 = load ptr, ptr %arrayidx224, align 8
  %call225 = call i32 @strcasecmp(ptr noundef %126, ptr noundef @.str.427) #14
  %tobool226 = icmp ne i32 %call225, 0
  br i1 %tobool226, label %if.else229, label %if.then227

if.then227:                                       ; preds = %land.lhs.true222
  %127 = load ptr, ptr %options, align 8
  %call228 = call ptr @sdscat(ptr noundef %127, ptr noundef @.str.219)
  store ptr %call228, ptr %options, align 8
  store i32 1, ptr %handled_last_config_arg, align 4
  br label %if.end241

if.else229:                                       ; preds = %land.lhs.true222, %land.lhs.true214, %land.lhs.true206, %if.else202
  %128 = load i32, ptr %j, align 4
  %129 = load i32, ptr %argc.addr, align 4
  %sub230 = sub nsw i32 %129, 1
  %cmp231 = icmp eq i32 %128, %sub230
  br i1 %cmp231, label %land.lhs.true233, label %if.end240

land.lhs.true233:                                 ; preds = %if.else229
  %130 = load ptr, ptr %argv.addr, align 8
  %131 = load i32, ptr %j, align 4
  %idxprom234 = sext i32 %131 to i64
  %arrayidx235 = getelementptr inbounds ptr, ptr %130, i64 %idxprom234
  %132 = load ptr, ptr %arrayidx235, align 8
  %call236 = call i32 @strcasecmp(ptr noundef %132, ptr noundef @.str.427) #14
  %tobool237 = icmp ne i32 %call236, 0
  br i1 %tobool237, label %if.end240, label %if.then238

if.then238:                                       ; preds = %land.lhs.true233
  %133 = load ptr, ptr %options, align 8
  %call239 = call ptr @sdscat(ptr noundef %133, ptr noundef @.str.219)
  store ptr %call239, ptr %options, align 8
  br label %if.end240

if.end240:                                        ; preds = %if.then238, %land.lhs.true233, %if.else229
  br label %if.end241

if.end241:                                        ; preds = %if.end240, %if.then227
  br label %if.end242

if.end242:                                        ; preds = %if.end241, %if.then200
  br label %if.end243

if.end243:                                        ; preds = %if.end242, %if.then189
  br label %if.end245

if.else244:                                       ; preds = %if.end154
  store i32 1, ptr %handled_last_config_arg, align 4
  br label %if.end245

if.end245:                                        ; preds = %if.else244, %if.end243
  %134 = load ptr, ptr %argv_tmp, align 8
  %135 = load i32, ptr %argc_tmp, align 4
  call void @sdsfreesplitres(ptr noundef %134, i32 noundef %135)
  br label %if.end254

if.else246:                                       ; preds = %land.lhs.true142, %land.lhs.true135, %if.else133
  %136 = load ptr, ptr %options, align 8
  %137 = load ptr, ptr %argv.addr, align 8
  %138 = load i32, ptr %j, align 4
  %idxprom247 = sext i32 %138 to i64
  %arrayidx248 = getelementptr inbounds ptr, ptr %137, i64 %idxprom247
  %139 = load ptr, ptr %arrayidx248, align 8
  %140 = load ptr, ptr %argv.addr, align 8
  %141 = load i32, ptr %j, align 4
  %idxprom249 = sext i32 %141 to i64
  %arrayidx250 = getelementptr inbounds ptr, ptr %140, i64 %idxprom249
  %142 = load ptr, ptr %arrayidx250, align 8
  %call251 = call i64 @strlen(ptr noundef %142) #14
  %call252 = call ptr @sdscatrepr(ptr noundef %136, ptr noundef %139, i64 noundef %call251)
  store ptr %call252, ptr %options, align 8
  %143 = load ptr, ptr %options, align 8
  %call253 = call ptr @sdscat(ptr noundef %143, ptr noundef @.str.40)
  store ptr %call253, ptr %options, align 8
  store i32 1, ptr %handled_last_config_arg, align 4
  br label %if.end254

if.end254:                                        ; preds = %if.else246, %if.end245
  br label %if.end255

if.end255:                                        ; preds = %if.end254, %if.then132
  %144 = load i32, ptr %j, align 4
  %inc256 = add nsw i32 %144, 1
  store i32 %inc256, ptr %j, align 4
  br label %while.cond, !llvm.loop !81

while.end:                                        ; preds = %while.cond
  %145 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  %146 = load i8, ptr %config_from_stdin, align 1
  %147 = load ptr, ptr %options, align 8
  call void @loadServerConfig(ptr noundef %145, i8 noundef signext %146, ptr noundef %147)
  %148 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool257 = icmp ne i32 %148, 0
  br i1 %tobool257, label %if.then258, label %if.end259

if.then258:                                       ; preds = %while.end
  call void @loadSentinelConfigFromQueue()
  br label %if.end259

if.end259:                                        ; preds = %if.then258, %while.end
  %149 = load ptr, ptr %options, align 8
  call void @sdsfree(ptr noundef %149)
  br label %if.end260

if.end260:                                        ; preds = %if.end259, %if.end51
  %150 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool261 = icmp ne i32 %150, 0
  br i1 %tobool261, label %if.then262, label %if.end263

if.then262:                                       ; preds = %if.end260
  call void @sentinelCheckConfigFile()
  br label %if.end263

if.end263:                                        ; preds = %if.then262, %if.end260
  call void @linuxMemoryWarnings()
  store ptr null, ptr %err_msg, align 8
  %call264 = call i32 @checkXenClocksource(ptr noundef %err_msg)
  %cmp265 = icmp slt i32 %call264, 0
  br i1 %cmp265, label %if.then267, label %if.end272

if.then267:                                       ; preds = %if.end263
  br label %do.body

do.body:                                          ; preds = %if.then267
  %151 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp268 = icmp slt i32 3, %151
  br i1 %cmp268, label %if.then270, label %if.end271

if.then270:                                       ; preds = %do.body
  br label %do.end

if.end271:                                        ; preds = %do.body
  %152 = load ptr, ptr %err_msg, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.399, ptr noundef %152)
  br label %do.end

do.end:                                           ; preds = %if.end271, %if.then270
  %153 = load ptr, ptr %err_msg, align 8
  call void @sdsfree(ptr noundef %153)
  br label %if.end272

if.end272:                                        ; preds = %do.end, %if.end263
  %154 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %call273 = call i32 @redisIsSupervised(i32 noundef %154)
  store i32 %call273, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 174), align 4
  %155 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 176), align 4
  %tobool274 = icmp ne i32 %155, 0
  br i1 %tobool274, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end272
  %156 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 174), align 4
  %tobool275 = icmp ne i32 %156, 0
  %lnot = xor i1 %tobool275, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end272
  %157 = phi i1 [ false, %if.end272 ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %157 to i32
  store i32 %land.ext, ptr %background, align 4
  %158 = load i32, ptr %background, align 4
  %tobool276 = icmp ne i32 %158, 0
  br i1 %tobool276, label %if.then277, label %if.end278

if.then277:                                       ; preds = %land.end
  call void @daemonize()
  br label %if.end278

if.end278:                                        ; preds = %if.then277, %land.end
  br label %do.body279

do.body279:                                       ; preds = %if.end278
  %159 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp280 = icmp slt i32 2, %159
  br i1 %cmp280, label %if.then282, label %if.end283

if.then282:                                       ; preds = %do.body279
  br label %do.end284

if.end283:                                        ; preds = %do.body279
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.452)
  br label %do.end284

do.end284:                                        ; preds = %if.end283, %if.then282
  br label %do.body285

do.body285:                                       ; preds = %do.end284
  %160 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp286 = icmp slt i32 2, %160
  br i1 %cmp286, label %if.then288, label %if.end289

if.then288:                                       ; preds = %do.body285
  br label %do.end296

if.end289:                                        ; preds = %do.body285
  %call290 = call ptr @redisGitSHA1()
  %call291 = call ptr @redisGitDirty()
  %call292 = call i64 @strtol(ptr noundef %call291, ptr noundef null, i32 noundef 10) #13
  %cmp293 = icmp sgt i64 %call292, 0
  %conv294 = zext i1 %cmp293 to i32
  %call295 = call i32 @getpid() #13
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.453, ptr noundef @.str.355, i32 noundef 64, ptr noundef %call290, i32 noundef %conv294, i32 noundef %call295)
  br label %do.end296

do.end296:                                        ; preds = %if.end289, %if.then288
  %161 = load i32, ptr %argc.addr, align 4
  %cmp297 = icmp eq i32 %161, 1
  br i1 %cmp297, label %if.then299, label %if.else307

if.then299:                                       ; preds = %do.end296
  br label %do.body300

do.body300:                                       ; preds = %if.then299
  %162 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp301 = icmp slt i32 3, %162
  br i1 %cmp301, label %if.then303, label %if.end304

if.then303:                                       ; preds = %do.body300
  br label %do.end306

if.end304:                                        ; preds = %do.body300
  %163 = load ptr, ptr %argv.addr, align 8
  %arrayidx305 = getelementptr inbounds ptr, ptr %163, i64 0
  %164 = load ptr, ptr %arrayidx305, align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.454, ptr noundef %164)
  br label %do.end306

do.end306:                                        ; preds = %if.end304, %if.then303
  br label %if.end314

if.else307:                                       ; preds = %do.end296
  br label %do.body308

do.body308:                                       ; preds = %if.else307
  %165 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp309 = icmp slt i32 2, %165
  br i1 %cmp309, label %if.then311, label %if.end312

if.then311:                                       ; preds = %do.body308
  br label %do.end313

if.end312:                                        ; preds = %do.body308
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.455)
  br label %do.end313

do.end313:                                        ; preds = %if.end312, %if.then311
  br label %if.end314

if.end314:                                        ; preds = %do.end313, %do.end306
  call void @initServer()
  %166 = load i32, ptr %background, align 4
  %tobool315 = icmp ne i32 %166, 0
  br i1 %tobool315, label %if.then318, label %lor.lhs.false316

lor.lhs.false316:                                 ; preds = %if.end314
  %167 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 23), align 8
  %tobool317 = icmp ne ptr %167, null
  br i1 %tobool317, label %if.then318, label %if.end319

if.then318:                                       ; preds = %lor.lhs.false316, %if.end314
  call void @createPidFile()
  br label %if.end319

if.end319:                                        ; preds = %if.then318, %lor.lhs.false316
  %168 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 177), align 8
  %tobool320 = icmp ne i32 %168, 0
  br i1 %tobool320, label %if.then321, label %if.end323

if.then321:                                       ; preds = %if.end319
  %call322 = call i32 @redisSetProcTitle(ptr noundef null)
  br label %if.end323

if.end323:                                        ; preds = %if.then321, %if.end319
  call void @redisAsciiArt()
  call void @checkTcpBacklogSettings()
  %169 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool324 = icmp ne i32 %169, 0
  br i1 %tobool324, label %if.then325, label %if.end326

if.then325:                                       ; preds = %if.end323
  call void @clusterInit()
  br label %if.end326

if.end326:                                        ; preds = %if.then325, %if.end323
  %170 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool327 = icmp ne i32 %170, 0
  br i1 %tobool327, label %if.end329, label %if.then328

if.then328:                                       ; preds = %if.end326
  call void @moduleInitModulesSystemLast()
  call void @moduleLoadFromQueue()
  br label %if.end329

if.end329:                                        ; preds = %if.then328, %if.end326
  call void @ACLLoadUsersAtStartup()
  call void @initListeners()
  %171 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool330 = icmp ne i32 %171, 0
  br i1 %tobool330, label %if.then331, label %if.end332

if.then331:                                       ; preds = %if.end329
  call void @clusterInitLast()
  br label %if.end332

if.end332:                                        ; preds = %if.then331, %if.end329
  call void @InitServerLast()
  %172 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool333 = icmp ne i32 %172, 0
  br i1 %tobool333, label %if.else384, label %if.then334

if.then334:                                       ; preds = %if.end332
  br label %do.body335

do.body335:                                       ; preds = %if.then334
  %173 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp336 = icmp slt i32 2, %173
  br i1 %cmp336, label %if.then338, label %if.end339

if.then338:                                       ; preds = %do.body335
  br label %do.end340

if.end339:                                        ; preds = %do.body335
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.456)
  br label %do.end340

do.end340:                                        ; preds = %if.end339, %if.then338
  call void @aofLoadManifestFromDisk()
  call void @loadDataFromDisk()
  call void @aofOpenIfNeededOnServerStart()
  %call341 = call i32 @aofDelHistoryFiles()
  %174 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool342 = icmp ne i32 %174, 0
  br i1 %tobool342, label %if.then343, label %if.end351

if.then343:                                       ; preds = %do.end340
  %call344 = call i32 @verifyClusterConfigWithData()
  %cmp345 = icmp eq i32 %call344, 0
  %lnot347 = xor i1 %cmp345, true
  %lnot348 = xor i1 %lnot347, true
  %lnot.ext = zext i1 %lnot348 to i32
  %conv349 = sext i32 %lnot.ext to i64
  %tobool350 = icmp ne i64 %conv349, 0
  br i1 %tobool350, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then343
  br label %cond.end

cond.false:                                       ; preds = %if.then343
  call void @_serverAssert(ptr noundef @.str.457, ptr noundef @.str.9, i32 noundef 7177)
  call void @abort() #16
  unreachable

175:                                              ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %175, %cond.true
  br label %if.end351

if.end351:                                        ; preds = %cond.end, %do.end340
  store i32 0, ptr %j, align 4
  br label %for.cond352

for.cond352:                                      ; preds = %for.inc370, %if.end351
  %176 = load i32, ptr %j, align 4
  %cmp353 = icmp slt i32 %176, 8
  br i1 %cmp353, label %for.body355, label %for.end372

for.body355:                                      ; preds = %for.cond352
  %177 = load i32, ptr %j, align 4
  %idxprom356 = sext i32 %177 to i64
  %arrayidx357 = getelementptr inbounds [8 x %struct.connListener], ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 52), i64 0, i64 %idxprom356
  store ptr %arrayidx357, ptr %listener, align 8
  %178 = load ptr, ptr %listener, align 8
  %ct = getelementptr inbounds %struct.connListener, ptr %178, i32 0, i32 5
  %179 = load ptr, ptr %ct, align 8
  %cmp358 = icmp eq ptr %179, null
  br i1 %cmp358, label %if.then360, label %if.end361

if.then360:                                       ; preds = %for.body355
  br label %for.inc370

if.end361:                                        ; preds = %for.body355
  br label %do.body362

do.body362:                                       ; preds = %if.end361
  %180 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp363 = icmp slt i32 2, %180
  br i1 %cmp363, label %if.then365, label %if.end366

if.then365:                                       ; preds = %do.body362
  br label %do.end369

if.end366:                                        ; preds = %do.body362
  %181 = load ptr, ptr %listener, align 8
  %ct367 = getelementptr inbounds %struct.connListener, ptr %181, i32 0, i32 5
  %182 = load ptr, ptr %ct367, align 8
  %get_type = getelementptr inbounds %struct.ConnectionType, ptr %182, i32 0, i32 0
  %183 = load ptr, ptr %get_type, align 8
  %call368 = call ptr %183(ptr noundef null)
  call void (i32, ptr, ...) @_serverLog(i32 noundef 2, ptr noundef @.str.458, ptr noundef %call368)
  br label %do.end369

do.end369:                                        ; preds = %if.end366, %if.then365
  br label %for.inc370

for.inc370:                                       ; preds = %do.end369, %if.then360
  %184 = load i32, ptr %j, align 4
  %inc371 = add nsw i32 %184, 1
  store i32 %inc371, ptr %j, align 4
  br label %for.cond352, !llvm.loop !82

for.end372:                                       ; preds = %for.cond352
  %185 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %cmp373 = icmp eq i32 %185, 2
  br i1 %cmp373, label %if.then375, label %if.end383

if.then375:                                       ; preds = %for.end372
  %186 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 283), align 8
  %tobool376 = icmp ne ptr %186, null
  br i1 %tobool376, label %if.else379, label %if.then377

if.then377:                                       ; preds = %if.then375
  %call378 = call i32 @redisCommunicateSystemd(ptr noundef @.str.459)
  br label %if.end381

if.else379:                                       ; preds = %if.then375
  %call380 = call i32 @redisCommunicateSystemd(ptr noundef @.str.460)
  br label %if.end381

if.end381:                                        ; preds = %if.else379, %if.then377
  %call382 = call i32 @redisCommunicateSystemd(ptr noundef @.str.461)
  br label %if.end383

if.end383:                                        ; preds = %if.end381, %for.end372
  br label %if.end391

if.else384:                                       ; preds = %if.end332
  call void @sentinelIsRunning()
  %187 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 175), align 8
  %cmp385 = icmp eq i32 %187, 2
  br i1 %cmp385, label %if.then387, label %if.end390

if.then387:                                       ; preds = %if.else384
  %call388 = call i32 @redisCommunicateSystemd(ptr noundef @.str.459)
  %call389 = call i32 @redisCommunicateSystemd(ptr noundef @.str.461)
  br label %if.end390

if.end390:                                        ; preds = %if.then387, %if.else384
  br label %if.end391

if.end391:                                        ; preds = %if.end390, %if.end383
  %188 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  %cmp392 = icmp ugt i64 %188, 0
  br i1 %cmp392, label %land.lhs.true394, label %if.end404

land.lhs.true394:                                 ; preds = %if.end391
  %189 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  %cmp395 = icmp ult i64 %189, 1048576
  br i1 %cmp395, label %if.then397, label %if.end404

if.then397:                                       ; preds = %land.lhs.true394
  br label %do.body398

do.body398:                                       ; preds = %if.then397
  %190 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 156), align 8
  %cmp399 = icmp slt i32 3, %190
  br i1 %cmp399, label %if.then401, label %if.end402

if.then401:                                       ; preds = %do.body398
  br label %do.end403

if.end402:                                        ; preds = %do.body398
  %191 = load i64, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 314), align 8
  call void (i32, ptr, ...) @_serverLog(i32 noundef 3, ptr noundef @.str.462, i64 noundef %191)
  br label %do.end403

do.end403:                                        ; preds = %if.end402, %if.then401
  br label %if.end404

if.end404:                                        ; preds = %do.end403, %land.lhs.true394, %if.end391
  %192 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 406), align 8
  call void @redisSetCpuAffinity(ptr noundef %192)
  %call405 = call i32 @setOOMScoreAdj(i32 noundef -1)
  %193 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  call void @aeMain(ptr noundef %193)
  %194 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 14), align 8
  call void @aeDeleteEventLoop(ptr noundef %194)
  ret i32 0
}

declare void @spt_init(i32 noundef, ptr noundef) #2

; Function Attrs: nounwind
declare void @tzset() #3

declare void @zmalloc_set_oom_handler(ptr noundef) #2

; Function Attrs: nounwind
declare void @srand(i32 noundef) #3

; Function Attrs: nounwind
declare void @srandom(i32 noundef) #3

declare void @init_genrand64(i64 noundef) #2

declare void @crc64_init() #2

; Function Attrs: nounwind
declare i32 @umask(i32 noundef) #3

declare void @getRandomBytes(ptr noundef, i64 noundef) #2

declare void @dictSetHashFunctionSeed(ptr noundef) #2

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strrchr(ptr noundef, i32 noundef) #5

declare void @ACLInit() #2

declare void @moduleInitModulesSystem() #2

declare i32 @connTypeInitialize() #2

declare ptr @getAbsolutePath(ptr noundef) #2

declare void @initSentinelConfig() #2

declare void @initSentinel() #2

declare i32 @redis_check_rdb_main(i32 noundef, ptr noundef, ptr noundef) #2

declare i32 @redis_check_aof_main(i32 noundef, ptr noundef) #2

declare void @memtest(i64 noundef, i32 noundef) #2

declare i32 @syscheck() #2

declare ptr @sdscatrepr(ptr noundef, ptr noundef, i64 noundef) #2

declare void @loadServerConfig(ptr noundef, i8 noundef signext, ptr noundef) #2

declare void @loadSentinelConfigFromQueue() #2

declare void @sentinelCheckConfigFile() #2

declare i32 @checkXenClocksource(ptr noundef) #2

declare void @clusterInit() #2

declare void @moduleInitModulesSystemLast() #2

declare void @moduleLoadFromQueue() #2

declare void @ACLLoadUsersAtStartup() #2

declare void @clusterInitLast() #2

declare void @aofLoadManifestFromDisk() #2

declare void @aofOpenIfNeededOnServerStart() #2

declare i32 @aofDelHistoryFiles() #2

declare i32 @verifyClusterConfigWithData() #2

declare void @sentinelIsRunning() #2

declare void @aeMain(ptr noundef) #2

declare void @aeDeleteEventLoop(ptr noundef) #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #12

; Function Attrs: nounwind
declare ptr @localtime_r(ptr noundef, ptr noundef) #3

declare void @replicationFeedSlaves(ptr noundef, i32 noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal void @propagateNow(i32 noundef %dbid, ptr noundef %argv, i32 noundef %argc, i32 noundef %target) #0 {
entry:
  %dbid.addr = alloca i32, align 4
  %argv.addr = alloca ptr, align 8
  %argc.addr = alloca i32, align 4
  %target.addr = alloca i32, align 4
  store i32 %dbid, ptr %dbid.addr, align 4
  store ptr %argv, ptr %argv.addr, align 8
  store i32 %argc, ptr %argc.addr, align 4
  store i32 %target, ptr %target.addr, align 4
  %0 = load i32, ptr %target.addr, align 4
  %call = call i32 @shouldPropagate(i32 noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end15

if.end:                                           ; preds = %entry
  %call1 = call i32 @isPausedActions(i32 noundef 16)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %1 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 34), align 8
  %tobool3 = icmp ne i32 %1, 0
  %lnot = xor i1 %tobool3, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %2 = phi i1 [ false, %if.end ], [ %lnot, %land.rhs ]
  %lnot4 = xor i1 %2, true
  %lnot5 = xor i1 %lnot4, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool7 = icmp ne i64 %conv, 0
  br i1 %tobool7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  br label %cond.end

cond.false:                                       ; preds = %land.end
  call void @_serverAssert(ptr noundef @.str.464, ptr noundef @.str.9, i32 noundef 3340)
  call void @abort() #16
  unreachable

3:                                                ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 185), align 8
  %cmp = icmp ne i32 %4, 0
  br i1 %cmp, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %cond.end
  %5 = load i32, ptr %target.addr, align 4
  %and = and i32 %5, 1
  %tobool9 = icmp ne i32 %and, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %land.lhs.true
  %6 = load i32, ptr %dbid.addr, align 4
  %7 = load ptr, ptr %argv.addr, align 8
  %8 = load i32, ptr %argc.addr, align 4
  call void @feedAppendOnlyFile(i32 noundef %6, ptr noundef %7, i32 noundef %8)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %land.lhs.true, %cond.end
  %9 = load i32, ptr %target.addr, align 4
  %and12 = and i32 %9, 2
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 59), align 8
  %11 = load i32, ptr %dbid.addr, align 4
  %12 = load ptr, ptr %argv.addr, align 8
  %13 = load i32, ptr %argc.addr, align 4
  call void @replicationFeedSlaves(ptr noundef %10, i32 noundef %11, ptr noundef %12, i32 noundef %13)
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end11, %if.then
  ret void
}

declare void @feedAppendOnlyFile(i32 noundef, ptr noundef, i32 noundef) #2

declare void @replyToClientsBlockedOnShutdown() #2

declare void @unpauseActions(i32 noundef) #2

; Function Attrs: nounwind uwtable
define internal i32 @connAddr(ptr noundef %conn, ptr noundef %ip, i64 noundef %ip_len, ptr noundef %port, i32 noundef %remote) #0 {
entry:
  %retval = alloca i32, align 4
  %conn.addr = alloca ptr, align 8
  %ip.addr = alloca ptr, align 8
  %ip_len.addr = alloca i64, align 8
  %port.addr = alloca ptr, align 8
  %remote.addr = alloca i32, align 4
  store ptr %conn, ptr %conn.addr, align 8
  store ptr %ip, ptr %ip.addr, align 8
  store i64 %ip_len, ptr %ip_len.addr, align 8
  store ptr %port, ptr %port.addr, align 8
  store i32 %remote, ptr %remote.addr, align 4
  %0 = load ptr, ptr %conn.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %conn.addr, align 8
  %type = getelementptr inbounds %struct.connection, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %type, align 8
  %addr = getelementptr inbounds %struct.ConnectionType, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %addr, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load ptr, ptr %conn.addr, align 8
  %type2 = getelementptr inbounds %struct.connection, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %type2, align 8
  %addr3 = getelementptr inbounds %struct.ConnectionType, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %addr3, align 8
  %7 = load ptr, ptr %conn.addr, align 8
  %8 = load ptr, ptr %ip.addr, align 8
  %9 = load i64, ptr %ip_len.addr, align 8
  %10 = load ptr, ptr %port.addr, align 8
  %11 = load i32, ptr %remote.addr, align 4
  %call = call i32 %6(ptr noundef %7, ptr noundef %8, i64 noundef %9, ptr noundef %10, i32 noundef %11)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind
declare i32 @prctl(i32 noundef, ...) #3

declare ptr @sdstemplate(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal ptr @redisProcTitleGetVariable(ptr noundef %varname, ptr noundef %arg) #0 {
entry:
  %retval = alloca ptr, align 8
  %varname.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %varname, ptr %varname.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %varname.addr, align 8
  %call = call i32 @strcmp(ptr noundef %0, ptr noundef @.str.471) #14
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %arg.addr, align 8
  %call1 = call ptr @sdsnew(ptr noundef %1)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %varname.addr, align 8
  %call2 = call i32 @strcmp(ptr noundef %2, ptr noundef @.str.472) #14
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.else19, label %if.then4

if.then4:                                         ; preds = %if.else
  %3 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  %tobool5 = icmp ne i32 %3, 0
  br i1 %tobool5, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then4
  %4 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  %tobool6 = icmp ne i32 %4, 0
  br i1 %tobool6, label %if.then7, label %if.else16

if.then7:                                         ; preds = %lor.lhs.false, %if.then4
  %call8 = call ptr @sdsempty()
  %5 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 48), align 8
  %tobool9 = icmp ne i32 %5, 0
  br i1 %tobool9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then7
  %6 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 47), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %6, %cond.true ], [ @.str.116, %cond.false ]
  %7 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  %tobool10 = icmp ne i32 %7, 0
  br i1 %tobool10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.end
  %8 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  br label %cond.end13

cond.false12:                                     ; preds = %cond.end
  %9 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi i32 [ %8, %cond.true11 ], [ %9, %cond.false12 ]
  %call15 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call8, ptr noundef @.str.473, ptr noundef %cond, i32 noundef %cond14)
  store ptr %call15, ptr %retval, align 8
  br label %return

if.else16:                                        ; preds = %lor.lhs.false
  %call17 = call ptr @sdsempty()
  %10 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 50), align 8
  %call18 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call17, ptr noundef @.str.474, ptr noundef %10)
  store ptr %call18, ptr %retval, align 8
  br label %return

if.else19:                                        ; preds = %if.else
  %11 = load ptr, ptr %varname.addr, align 8
  %call20 = call i32 @strcmp(ptr noundef %11, ptr noundef @.str.475) #14
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.else32, label %if.then22

if.then22:                                        ; preds = %if.else19
  %12 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 362), align 4
  %tobool23 = icmp ne i32 %12, 0
  br i1 %tobool23, label %if.then24, label %if.else26

if.then24:                                        ; preds = %if.then22
  %call25 = call ptr @sdsnew(ptr noundef @.str.476)
  store ptr %call25, ptr %retval, align 8
  br label %return

if.else26:                                        ; preds = %if.then22
  %13 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 27), align 4
  %tobool27 = icmp ne i32 %13, 0
  br i1 %tobool27, label %if.then28, label %if.else30

if.then28:                                        ; preds = %if.else26
  %call29 = call ptr @sdsnew(ptr noundef @.str.477)
  store ptr %call29, ptr %retval, align 8
  br label %return

if.else30:                                        ; preds = %if.else26
  %call31 = call ptr @sdsempty()
  store ptr %call31, ptr %retval, align 8
  br label %return

if.else32:                                        ; preds = %if.else19
  %14 = load ptr, ptr %varname.addr, align 8
  %call33 = call i32 @strcmp(ptr noundef %14, ptr noundef @.str.478) #14
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.else42, label %if.then35

if.then35:                                        ; preds = %if.else32
  %15 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  %tobool36 = icmp ne ptr %15, null
  br i1 %tobool36, label %cond.true37, label %cond.false38

cond.true37:                                      ; preds = %if.then35
  %16 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 2), align 8
  br label %cond.end39

cond.false38:                                     ; preds = %if.then35
  br label %cond.end39

cond.end39:                                       ; preds = %cond.false38, %cond.true37
  %cond40 = phi ptr [ %16, %cond.true37 ], [ @.str.479, %cond.false38 ]
  %call41 = call ptr @sdsnew(ptr noundef %cond40)
  store ptr %call41, ptr %retval, align 8
  br label %return

if.else42:                                        ; preds = %if.else32
  %17 = load ptr, ptr %varname.addr, align 8
  %call43 = call i32 @strcmp(ptr noundef %17, ptr noundef @.str.480) #14
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %if.else48, label %if.then45

if.then45:                                        ; preds = %if.else42
  %call46 = call ptr @sdsempty()
  %18 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 44), align 8
  %call47 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call46, ptr noundef @.str.481, i32 noundef %18)
  store ptr %call47, ptr %retval, align 8
  br label %return

if.else48:                                        ; preds = %if.else42
  %19 = load ptr, ptr %varname.addr, align 8
  %call49 = call i32 @strcmp(ptr noundef %19, ptr noundef @.str.482) #14
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.else54, label %if.then51

if.then51:                                        ; preds = %if.else48
  %call52 = call ptr @sdsempty()
  %20 = load i32, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 45), align 4
  %call53 = call ptr (ptr, ptr, ...) @sdscatprintf(ptr noundef %call52, ptr noundef @.str.481, i32 noundef %20)
  store ptr %call53, ptr %retval, align 8
  br label %return

if.else54:                                        ; preds = %if.else48
  %21 = load ptr, ptr %varname.addr, align 8
  %call55 = call i32 @strcmp(ptr noundef %21, ptr noundef @.str.483) #14
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.else59, label %if.then57

if.then57:                                        ; preds = %if.else54
  %22 = load ptr, ptr getelementptr inbounds (%struct.redisServer, ptr @server, i32 0, i32 50), align 8
  %call58 = call ptr @sdsnew(ptr noundef %22)
  store ptr %call58, ptr %retval, align 8
  br label %return

if.else59:                                        ; preds = %if.else54
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else59, %if.then57, %if.then51, %if.then45, %cond.end39, %if.else30, %if.then28, %if.then24, %if.else16, %cond.end13, %if.then
  %23 = load ptr, ptr %retval, align 8
  ret ptr %23
}

declare ptr @sdstrim(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind
declare i32 @raise(i32 noundef) #3

; Function Attrs: nounwind
declare i32 @unsetenv(ptr noundef) #3

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nocallback nofree nosync nounwind willreturn }
attributes #5 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #11 = { allocsize(1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #13 = { nounwind }
attributes #14 = { nounwind willreturn memory(read) }
attributes #15 = { noreturn }
attributes #16 = { noreturn nounwind }
attributes #17 = { nounwind willreturn memory(none) }
attributes #18 = { allocsize(0) }
attributes #19 = { allocsize(1) }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
